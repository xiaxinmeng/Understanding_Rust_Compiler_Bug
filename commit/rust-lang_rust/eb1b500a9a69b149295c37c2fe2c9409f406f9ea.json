{"sha": "eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMWI1MDBhOWE2OWIxNDkyOTVjMzdjMmZlMmM5NDA5ZjQwNmY5ZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-22T10:15:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-22T10:15:40Z"}, "message": "Auto merge of #22548 - Manishearth:rollup, r=Manishearth\n\nI had most of these tested locally, why not  get them out of the way too?", "tree": {"sha": "038fef94f8b208553ce2bc0409d9f051bc88693d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038fef94f8b208553ce2bc0409d9f051bc88693d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "html_url": "https://github.com/rust-lang/rust/commit/eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b01a37ec38db9301239f0c0abcf3c695055b0ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b01a37ec38db9301239f0c0abcf3c695055b0ff", "html_url": "https://github.com/rust-lang/rust/commit/2b01a37ec38db9301239f0c0abcf3c695055b0ff"}, {"sha": "686648d15546cead638ababda5a70d8f36fbc78a", "url": "https://api.github.com/repos/rust-lang/rust/commits/686648d15546cead638ababda5a70d8f36fbc78a", "html_url": "https://github.com/rust-lang/rust/commit/686648d15546cead638ababda5a70d8f36fbc78a"}], "stats": {"total": 7545, "additions": 1274, "deletions": 6271}, "files": [{"sha": "71b20cb0946c482b519edbe74ba93b8ae12ff00c", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -14,7 +14,7 @@ links to the major sections:\n If you have questions, please make a post on [internals.rust-lang.org][internals] or\n hop on [#rust-internals][pound-rust-internals].\n \n-As a reminder, all contributors are expected to follow our [Code of Conduct](coc).\n+As a reminder, all contributors are expected to follow our [Code of Conduct][coc].\n \n [pound-rust-internals]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-internals\n [internals]: http://internals.rust-lang.org"}, {"sha": "69b804cf24c40ab16e1d9fe431614a9ce6bb3c99", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -51,7 +51,7 @@ Version 1.0.0-alpha.2 (February 2015)\n     * Abstract [OS-specific string types][osstr], `std::ff::{OsString,\n       OsStr}`, provide strings in platform-specific encodings for easier\n       interop with system APIs. [RFC][osstr-rfc].\n-    * The `boxed::into_raw` and `Box::frow_raw` functions [convert\n+    * The `boxed::into_raw` and `Box::from_raw` functions [convert\n       between `Box<T>` and `*mut T`][boxraw], a common pattern for\n       creating raw pointers.\n "}, {"sha": "a40374fe30fadde9235a6607f6f010307eaf0649", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -91,7 +91,7 @@ fn main() {\n ```\n \n You've seen this code before, when we talked about standard input. We\n-import the `std::io` module with `use`, and then our `main` function contains\n+import the `std::old_io` module with `use`, and then our `main` function contains\n our program's logic. We print a little message announcing the game, ask the\n user to input a guess, get their input, and then print it out.\n "}, {"sha": "7dac49987d84908ac37dd4ce6cce80fdabfa3c6c", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -34,6 +34,20 @@ if x == 5 {\n }\n ```\n \n+If there is more than one case, use an `else if`:\n+\n+```rust\n+let x = 5;\n+\n+if x == 5 {\n+    println!(\"x is five!\");\n+} else if x == 6 {\n+    println!(\"x is six!\");\n+} else {\n+    println!(\"x is not five or six :(\");\n+}\n+```\n+\n This is all pretty standard. However, you can also do this:\n \n "}, {"sha": "332f299a67f3c421e44dc9feed706c600bb1511e", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -687,7 +687,9 @@ than the hundred `int`s that make up the `BigStruct`.\n \n This is an antipattern in Rust. Instead, write this:\n \n-```{rust}\n+```rust\n+#![feature(box_syntax)]\n+\n struct BigStruct {\n     one: i32,\n     two: i32,\n@@ -706,10 +708,13 @@ fn main() {\n         one_hundred: 100,\n     });\n \n-    let y = Box::new(foo(x));\n+    let y = box foo(x);\n }\n ```\n \n+Note that this uses the `box_syntax` feature gate, so this syntax may change in\n+the future.\n+\n This gives you flexibility without sacrificing performance.\n \n You may think that this gives us terrible performance: return a value and then"}, {"sha": "98dac9bf84bb47c519eb8f65cdd780452be8510f", "filename": "src/doc/trpl/static-and-dynamic-dispatch.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -84,7 +84,7 @@ inlining and hence usually higher performance. It also has some downsides:\n causing code bloat due to many copies of the same function existing in the\n binary, one for each type.\n \n-Furthermore, compilers aren\u2019t perfect and may \u201coptimise\u201d code to become slower.\n+Furthermore, compilers aren\u2019t perfect and may \u201coptimize\u201d code to become slower.\n For example, functions inlined too eagerly will bloat the instruction cache\n (cache rules everything around us). This is part of the reason that `#[inline]`\n and `#[inline(always)]` should be used carefully, and one reason why using a\n@@ -104,15 +104,15 @@ objects, like `&Foo` or `Box<Foo>`, are normal values that store a value of\n known at runtime. The methods of the trait can be called on a trait object via\n a special record of function pointers (created and managed by the compiler).\n \n-A function that takes a trait object is not specialised to each of the types\n+A function that takes a trait object is not specialized to each of the types\n that implements `Foo`: only one copy is generated, often (but not always)\n resulting in less code bloat. However, this comes at the cost of requiring\n slower virtual function calls, and effectively inhibiting any chance of\n inlining and related optimisations from occurring.\n \n Trait objects are both simple and complicated: their core representation and\n layout is quite straight-forward, but there are some curly error messages and\n-surprising behaviours to discover.\n+surprising behaviors to discover.\n \n ### Obtaining a trait object\n \n@@ -140,13 +140,13 @@ and casts are identical.\n \n This operation can be seen as \"erasing\" the compiler's knowledge about the\n specific type of the pointer, and hence trait objects are sometimes referred to\n-\"type erasure\".\n+as \"type erasure\".\n \n ### Representation\n \n Let's start simple, with the runtime representation of a trait object. The\n `std::raw` module contains structs with layouts that are the same as the\n-complicated build-in types, [including trait objects][stdraw]:\n+complicated built-in types, [including trait objects][stdraw]:\n \n ```rust\n # mod foo {\n@@ -223,14 +223,14 @@ static Foo_for_String_vtable: FooVtable = FooVtable {\n The `destructor` field in each vtable points to a function that will clean up\n any resources of the vtable's type, for `u8` it is trivial, but for `String` it\n will free the memory. This is necessary for owning trait objects like\n-`Box<Foo>`, which need to clean-up both the `Box` allocation and as well as the\n+`Box<Foo>`, which need to clean-up both the `Box` allocation as well as the\n internal type when they go out of scope. The `size` and `align` fields store\n the size of the erased type, and its alignment requirements; these are\n essentially unused at the moment since the information is embedded in the\n-destructor, but will be used in future, as trait objects are progressively made\n-more flexible.\n+destructor, but will be used in the future, as trait objects are progressively\n+made more flexible.\n \n-Suppose we've got some values that implement `Foo`, the explicit form of\n+Suppose we've got some values that implement `Foo`, then the explicit form of\n construction and use of `Foo` trait objects might look a bit like (ignoring the\n type mismatches: they're all just pointers anyway):\n "}, {"sha": "cc49164ef91b349f78e716bf3b7c6962392ad9c8", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -598,13 +598,6 @@ impl<T: Default + Sync + Send> Default for Arc<T> {\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n-#[cfg(stage0)]\n-impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n-    fn hash(&self, state: &mut H) {\n-        (**self).hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash> Hash for Arc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "ce889c796012cb4c065d03e205c021796caac6b1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -220,14 +220,6 @@ impl<T: ?Sized + Ord> Ord for Box<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Hash> Hash for Box<T> {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {"}, {"sha": "0cdc71b6f604f68bf88e988af72988a9aa8c9ca9", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -73,6 +73,7 @@\n #![feature(unboxed_closures)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(core)]\n+#![cfg_attr(test, feature(test, alloc, rustc_private))]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]\n "}, {"sha": "ed7d34de7a68847d9a5bbb5a0d0acc83b33d7150", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -592,14 +592,6 @@ impl<T: Ord> Ord for Rc<T> {\n }\n \n // FIXME (#18248) Make `T` `Sized?`\n-#[cfg(stage0)]\n-impl<S: Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash> Hash for Rc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "21218201182f988f5635a98b078c124d968e6240", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -985,17 +985,6 @@ impl fmt::Debug for BitVec {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitVec {\n-    fn hash(&self, state: &mut S) {\n-        self.nbits.hash(state);\n-        for elem in self.blocks() {\n-            elem.hash(state);\n-        }\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl hash::Hash for BitVec {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         self.nbits.hash(state);\n@@ -1776,16 +1765,7 @@ impl fmt::Debug for BitSet {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitSet {\n-    fn hash(&self, state: &mut S) {\n-        for pos in self {\n-            pos.hash(state);\n-        }\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl hash::Hash for BitSet {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         for pos in self {"}, {"sha": "e92f38741c9a0bd3abab4b3378e7b354b57f383d", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -282,16 +282,6 @@ impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<'a, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, B> where B: Hash<S> + ToOwned\n-{\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n {\n     #[inline]"}, {"sha": "c1d74b16ce6bcacff795ef172f31283a17ec04fb", "filename": "src/libcollections/borrow_stage0.rs", "status": "removed", "additions": 0, "deletions": 313, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibcollections%2Fborrow_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibcollections%2Fborrow_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow_stage0.rs?ref=2b01a37ec38db9301239f0c0abcf3c695055b0ff", "patch": "@@ -1,313 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A module for working with borrowed data.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use core::clone::Clone;\n-use core::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n-use core::hash::{Hash, Hasher};\n-use core::marker::Sized;\n-use core::ops::Deref;\n-use core::option::Option;\n-\n-use fmt;\n-use alloc::{rc, arc};\n-\n-use self::Cow::*;\n-\n-/// A trait for borrowing data.\n-///\n-/// In general, there may be several ways to \"borrow\" a piece of data.  The\n-/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n-/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n-/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n-///\n-/// When writing generic code, it is often desirable to abstract over all ways\n-/// of borrowing data from a given type. That is the role of the `Borrow`\n-/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n-/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n-/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Borrow<Borrowed: ?Sized> {\n-    /// Immutably borrow from an owned value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn borrow(&self) -> &Borrowed;\n-}\n-\n-/// A trait for mutably borrowing data.\n-///\n-/// Similar to `Borrow`, but for mutable borrows.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n-    /// Mutably borrow from an owned value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn borrow_mut(&mut self) -> &mut Borrowed;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Borrow<T> for T {\n-    fn borrow(&self) -> &T { self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> BorrowMut<T> for T {\n-    fn borrow_mut(&mut self) -> &mut T { self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> Borrow<T> for &'a T {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> Borrow<T> for &'a mut T {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n-    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n-}\n-\n-impl<T> Borrow<T> for rc::Rc<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-impl<T> Borrow<T> for arc::Arc<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n-    fn borrow(&self) -> &B {\n-        &**self\n-    }\n-}\n-\n-/// A generalization of Clone to borrowed data.\n-///\n-/// Some types make it possible to go from borrowed to owned, usually by\n-/// implementing the `Clone` trait. But `Clone` works only for going from `&T`\n-/// to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n-/// from any borrow of a given type.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait ToOwned {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Owned: Borrow<Self>;\n-\n-    /// Create owned data from borrowed data, usually by copying.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn to_owned(&self) -> Self::Owned;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ToOwned for T where T: Clone {\n-    type Owned = T;\n-    fn to_owned(&self) -> T { self.clone() }\n-}\n-\n-/// A clone-on-write smart pointer.\n-///\n-/// The type `Cow` is a smart pointer providing clone-on-write functionality: it\n-/// can enclose and provide immutable access to borrowed data, and clone the\n-/// data lazily when mutation or ownership is required. The type is designed to\n-/// work with general borrowed data via the `Borrow` trait.\n-///\n-/// `Cow` implements both `Deref`, which means that you can call\n-/// non-mutating methods directly on the data it encloses. If mutation\n-/// is desired, `to_mut` will obtain a mutable references to an owned\n-/// value, cloning if necessary.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::borrow::Cow;\n-///\n-/// fn abs_all(input: &mut Cow<[int]>) {\n-///     for i in 0..input.len() {\n-///         let v = input[i];\n-///         if v < 0 {\n-///             // clones into a vector the first time (if not already owned)\n-///             input.to_mut()[i] = -v;\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {\n-    /// Borrowed data.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Borrowed(&'a B),\n-\n-    /// Owned data.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Owned(<B as ToOwned>::Owned)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n-    fn clone(&self) -> Cow<'a, B> {\n-        match *self {\n-            Borrowed(b) => Borrowed(b),\n-            Owned(ref o) => {\n-                let b: &B = o.borrow();\n-                Owned(b.to_owned())\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n-    /// Acquire a mutable reference to the owned form of the data.\n-    ///\n-    /// Copies the data if it is not already owned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned where <B as ToOwned>::Owned: 'a {\n-        match *self {\n-            Borrowed(borrowed) => {\n-                *self = Owned(borrowed.to_owned());\n-                self.to_mut()\n-            }\n-            Owned(ref mut owned) => owned\n-        }\n-    }\n-\n-    /// Extract the owned data.\n-    ///\n-    /// Copies the data if it is not already owned.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_owned(self) -> <B as ToOwned>::Owned {\n-        match self {\n-            Borrowed(borrowed) => borrowed.to_owned(),\n-            Owned(owned) => owned\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps a borrowed value\n-    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_borrowed(&self) -> bool {\n-        match *self {\n-            Borrowed(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps an owned value\n-    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            Owned(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Deref for Cow<'a, B> where\n-    B: ToOwned, <B as ToOwned>::Owned: 'a\n-{\n-    type Target = B;\n-\n-    fn deref(&self) -> &B {\n-        match *self {\n-            Borrowed(borrowed) => borrowed,\n-            Owned(ref owned) => owned.borrow()\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned, <B as ToOwned>::Owned: 'a {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Ord for Cow<'a, B> where\n-    B: Ord + ToOwned, <B as ToOwned>::Owned: 'a\n-{\n-    #[inline]\n-    fn cmp(&self, other: &Cow<'a, B>) -> Ordering {\n-        Ord::cmp(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n-    B: PartialEq<C> + ToOwned, C: ToOwned,\n-    <B as ToOwned>::Owned: 'a, <C as ToOwned>::Owned: 'b,\n-{\n-    #[inline]\n-    fn eq(&self, other: &Cow<'b, C>) -> bool {\n-        PartialEq::eq(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where\n-    B: PartialOrd + ToOwned, <B as ToOwned>::Owned: 'a\n-{\n-    #[inline]\n-    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n-        PartialOrd::partial_cmp(&**self, &**other)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n-    B: fmt::Debug + ToOwned,\n-    <B as ToOwned>::Owned: fmt::Debug,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n-            Owned(ref o) => fmt::Debug::fmt(o, f),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n-    B: fmt::Display + ToOwned,\n-    <B as ToOwned>::Owned: fmt::Display,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Borrowed(ref b) => fmt::Display::fmt(b, f),\n-            Owned(ref o) => fmt::Display::fmt(o, f),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, B> where\n-    B: Hash<S> + ToOwned, <B as ToOwned>::Owned: 'a\n-{\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n-    }\n-}\n-\n-/// Trait for moving into a `Cow`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n-    /// Moves `self` into `Cow`\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn into_cow(self) -> Cow<'a, B>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n-    fn into_cow(self) -> Cow<'a, B> {\n-        self\n-    }\n-}"}, {"sha": "1b456eec830b14d84015d392cd8cc397ea6c40ee", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -852,16 +852,6 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n-    fn hash(&self, state: &mut S) {\n-        for elt in self {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "1f3c54a4cb53fd496fa8b58df7d98f020989e16f", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -86,23 +86,17 @@ mod macros;\n pub mod binary_heap;\n mod bit;\n mod btree;\n-pub mod linked_list;\n+pub mod borrow;\n pub mod enum_set;\n pub mod fmt;\n-pub mod vec_deque;\n+pub mod linked_list;\n pub mod slice;\n pub mod str;\n pub mod string;\n pub mod vec;\n+pub mod vec_deque;\n pub mod vec_map;\n \n-#[cfg(stage0)]\n-#[path = \"borrow_stage0.rs\"]\n-pub mod borrow;\n-\n-#[cfg(not(stage0))]\n-pub mod borrow;\n-\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub mod bit_vec {"}, {"sha": "3c61fc3da90e3dd706a83ed0d73bcae9ace17880", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -28,8 +28,6 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-#[cfg(stage0)]\n-use core::hash::Writer;\n use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n@@ -932,17 +930,6 @@ impl<A: fmt::Debug> fmt::Debug for LinkedList<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for LinkedList<A> {\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<A: Hash> Hash for LinkedList<A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);"}, {"sha": "6c2624cd204de1711879cc5b78a16c345e4bdc84", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -834,16 +834,7 @@ impl fmt::Debug for String {\n     }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Hash stabilization\")]\n-#[cfg(stage0)]\n-impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n-    #[inline]\n-    fn hash(&self, hasher: &mut H) {\n-        (**self).hash(hasher)\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl hash::Hash for String {\n     #[inline]\n     fn hash<H: hash::Hasher>(&self, hasher: &mut H) {"}, {"sha": "2f9577c08deba502cda273242582f08568e28af7", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1303,15 +1303,7 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: Hash> Hash for Vec<T> {\n     #[inline]\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n@@ -1599,9 +1591,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     fn as_slice(&self) -> &[T] {\n         unsafe {\n             let p = *self.ptr;\n-            if cfg!(not(stage0)) { // NOTE remove cfg after next snapshot\n-                assume(p != 0 as *mut T);\n-            }\n+            assume(p != 0 as *mut T);\n             mem::transmute(RawSlice {\n                 data: p,\n                 len: self.len"}, {"sha": "f65e644fa52842f7325ee1d0ac3a1bf76a53af20", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -32,7 +32,6 @@ use core::ptr::{self, Unique};\n use core::raw::Slice as RawSlice;\n \n use core::hash::{Hash, Hasher};\n-#[cfg(stage0)] use core::hash::Writer;\n use core::cmp;\n \n use alloc::heap;\n@@ -1675,17 +1674,6 @@ impl<A: Ord> Ord for VecDeque<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for VecDeque<A> {\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<A: Hash> Hash for VecDeque<A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);"}, {"sha": "d59e3c70c39ba6d7fbcfba8fd5cf74e5e8935399", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -21,7 +21,6 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-#[cfg(stage0)] use core::hash::Writer;\n use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n use core::mem::replace;\n@@ -113,21 +112,7 @@ impl<V:Clone> Clone for VecMap<V> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n-    fn hash(&self, state: &mut S) {\n-        // In order to not traverse the `VecMap` twice, count the elements\n-        // during iteration.\n-        let mut count: usize = 0;\n-        for elt in self {\n-            elt.hash(state);\n-            count += 1;\n-        }\n-        count.hash(state);\n-    }\n-}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<V: Hash> Hash for VecMap<V> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // In order to not traverse the `VecMap` twice, count the elements"}, {"sha": "e8f6e31756df99cbba394853bafc1365effd9a85", "filename": "src/libcore/array.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -35,13 +35,6 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[cfg(stage0)]\n-            impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for [T; $N] {\n-                fn hash(&self, state: &mut S) {\n-                    Hash::hash(&self[..], state)\n-                }\n-            }\n-            #[cfg(not(stage0))]\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: Hash> Hash for [T; $N] {\n                 fn hash<H: hash::Hasher>(&self, state: &mut H) {"}, {"sha": "38e2bd98ef9e3d64629f9e247850a376c5d2ba6a", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -15,7 +15,7 @@\n //! types.\n //!\n //! This module defines atomic versions of a select number of primitive\n-//! types, including `AtomicBool`, `AtomicIsize`, `AtomicUsize`, and `AtomicOption`.\n+//! types, including `AtomicBool`, `AtomicIsize`, and `AtomicUsize`.\n //! Atomic types present operations that, when used correctly, synchronize\n //! updates between threads.\n //!"}, {"sha": "ed48903a7c2550ab31b5c415f71b389f331bb9f7", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -73,7 +73,6 @@ mod sip;\n /// to compute the hash. Specific implementations of this trait may specialize\n /// for particular instances of `H` in order to be able to optimize the hashing\n /// behavior.\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n     /// Feeds this value into the state given, updating the hasher as necessary.\n@@ -89,72 +88,40 @@ pub trait Hash {\n     }\n }\n \n-/// A hashable type.\n-///\n-/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n-/// to compute the hash. Specific implementations of this trait may specialize\n-/// for particular instances of `H` in order to be able to optimize the hashing\n-/// behavior.\n-#[cfg(stage0)]\n-pub trait Hash<H: Hasher> {\n-    /// Feeds this value into the state given, updating the hasher as necessary.\n-    fn hash(&self, state: &mut H);\n-}\n-\n /// A trait which represents the ability to hash an arbitrary stream of bytes.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n-    /// Result type of one run of hashing generated by this hasher.\n-    #[cfg(stage0)]\n-    type Output;\n-\n-    /// Resets this hasher back to its initial state (as if it were just\n-    /// created).\n-    #[cfg(stage0)]\n-    fn reset(&mut self);\n-\n-    /// Completes a round of hashing, producing the output hash generated.\n-    #[cfg(stage0)]\n-    fn finish(&self) -> Self::Output;\n-\n     /// Completes a round of hashing, producing the output hash generated.\n-    #[cfg(not(stage0))]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn finish(&self) -> u64;\n \n     /// Writes some data into this `Hasher`\n-    #[cfg(not(stage0))]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, bytes: &[u8]);\n \n     /// Write a single `u8` into this hasher\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n     /// Write a single `u16` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_u16(&mut self, i: u16) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i) })\n     }\n     /// Write a single `u32` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_u32(&mut self, i: u32) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i) })\n     }\n     /// Write a single `u64` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n     /// Write a single `usize` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_usize(&mut self, i: usize) {\n@@ -166,58 +133,31 @@ pub trait Hasher {\n     }\n \n     /// Write a single `i8` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n     /// Write a single `i16` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n     /// Write a single `i32` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n     /// Write a single `i64` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n     /// Write a single `isize` into this hasher.\n-    #[cfg(not(stage0))]\n     #[inline]\n     #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n     fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n }\n \n-/// A common bound on the `Hasher` parameter to `Hash` implementations in order\n-/// to generically hash an aggregate.\n-#[unstable(feature = \"hash\",\n-           reason = \"this trait will likely be replaced by io::Writer\")]\n-#[allow(missing_docs)]\n-#[cfg(stage0)]\n-pub trait Writer {\n-    fn write(&mut self, bytes: &[u8]);\n-}\n-\n /// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n ///\n /// The specified value will be hashed with this hasher and then the resulting\n /// hash will be returned.\n-#[cfg(stage0)]\n-pub fn hash<T: Hash<H>, H: Hasher + Default>(value: &T) -> H::Output {\n-    let mut h: H = Default::default();\n-    value.hash(&mut h);\n-    h.finish()\n-}\n-\n-/// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n-///\n-/// The specified value will be hashed with this hasher and then the resulting\n-/// hash will be returned.\n-#[cfg(not(stage0))]\n #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n     let mut h: H = Default::default();\n@@ -227,145 +167,6 @@ pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n \n //////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(stage0)]\n-mod impls {\n-    use prelude::*;\n-\n-    use mem;\n-    use num::Int;\n-    use super::*;\n-\n-    macro_rules! impl_hash {\n-        ($ty:ident, $uty:ident) => {\n-            impl<S: Writer + Hasher> Hash<S> for $ty {\n-                #[inline]\n-                fn hash(&self, state: &mut S) {\n-                    let a: [u8; ::$ty::BYTES] = unsafe {\n-                        mem::transmute(*self)\n-                    };\n-                    state.write(&a)\n-                }\n-            }\n-        }\n-    }\n-\n-    impl_hash! { u8, u8 }\n-    impl_hash! { u16, u16 }\n-    impl_hash! { u32, u32 }\n-    impl_hash! { u64, u64 }\n-    impl_hash! { uint, uint }\n-    impl_hash! { i8, u8 }\n-    impl_hash! { i16, u16 }\n-    impl_hash! { i32, u32 }\n-    impl_hash! { i64, u64 }\n-    impl_hash! { int, uint }\n-\n-    impl<S: Writer + Hasher> Hash<S> for bool {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (*self as u8).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer + Hasher> Hash<S> for char {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (*self as u32).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer + Hasher> Hash<S> for str {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            state.write(self.as_bytes());\n-            0xffu8.hash(state)\n-        }\n-    }\n-\n-    macro_rules! impl_hash_tuple {\n-        () => (\n-            impl<S: Hasher> Hash<S> for () {\n-                #[inline]\n-                fn hash(&self, _state: &mut S) {}\n-            }\n-        );\n-\n-        ( $($name:ident)+) => (\n-            impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-                #[inline]\n-                #[allow(non_snake_case)]\n-                fn hash(&self, state: &mut S) {\n-                    match *self {\n-                        ($(ref $name,)*) => {\n-                            $(\n-                                $name.hash(state);\n-                            )*\n-                        }\n-                    }\n-                }\n-            }\n-        );\n-    }\n-\n-    impl_hash_tuple! {}\n-    impl_hash_tuple! { A }\n-    impl_hash_tuple! { A B }\n-    impl_hash_tuple! { A B C }\n-    impl_hash_tuple! { A B C D }\n-    impl_hash_tuple! { A B C D E }\n-    impl_hash_tuple! { A B C D E F }\n-    impl_hash_tuple! { A B C D E F G }\n-    impl_hash_tuple! { A B C D E F G H }\n-    impl_hash_tuple! { A B C D E F G H I }\n-    impl_hash_tuple! { A B C D E F G H I J }\n-    impl_hash_tuple! { A B C D E F G H I J K }\n-    impl_hash_tuple! { A B C D E F G H I J K L }\n-\n-    impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            self.len().hash(state);\n-            for elt in self {\n-                elt.hash(state);\n-            }\n-        }\n-    }\n-\n-\n-    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (**self).hash(state);\n-        }\n-    }\n-\n-    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (**self).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer + Hasher, T> Hash<S> for *const T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            // NB: raw-pointer Hash does _not_ dereference\n-            // to the target; it just gives you the pointer-bytes.\n-            (*self as uint).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            // NB: raw-pointer Hash does _not_ dereference\n-            // to the target; it just gives you the pointer-bytes.\n-            (*self as uint).hash(state);\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n mod impls {\n     use prelude::*;\n "}, {"sha": "6f24fc7067344c3cb848a0f645142f90c4d9a24f", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -16,8 +16,6 @@ use prelude::*;\n use default::Default;\n \n use super::Hasher;\n-#[cfg(stage0)]\n-use super::Writer;\n \n /// An implementation of SipHash 2-4.\n ///\n@@ -175,26 +173,9 @@ impl SipHasher {\n     }\n }\n \n-#[cfg(stage0)]\n-impl Writer for SipHasher {\n-    #[inline]\n-    fn write(&mut self, msg: &[u8]) {\n-        self.write(msg)\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hasher for SipHasher {\n-    #[cfg(stage0)]\n-    type Output = u64;\n-\n-    #[cfg(stage0)]\n-    fn reset(&mut self) {\n-        self.reset();\n-    }\n-\n     #[inline]\n-    #[cfg(not(stage0))]\n     fn write(&mut self, msg: &[u8]) {\n         self.write(msg)\n     }"}, {"sha": "2d50bbb641363373a3e25a1ecdde6b79fdf5ef9c", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -2592,7 +2592,29 @@ pub struct RangeStep<A> {\n     rev: bool,\n }\n \n-/// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n+/// Return an iterator over the range [start, stop) by `step`.\n+///\n+/// It handles overflow by stopping.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::iter::range_step;\n+///\n+/// for i in range_step(0, 10, 2) {\n+///     println!(\"{}\", i);\n+/// }\n+/// ```\n+///\n+/// This prints:\n+///\n+/// ```text\n+/// 0\n+/// 2\n+/// 4\n+/// 6\n+/// 8\n+/// ```\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n@@ -2633,7 +2655,30 @@ pub struct RangeStepInclusive<A> {\n     done: bool,\n }\n \n-/// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n+/// Return an iterator over the range [start, stop] by `step`.\n+///\n+/// It handles overflow by stopping.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::iter::range_step_inclusive;\n+///\n+/// for i in range_step_inclusive(0, 10, 2) {\n+///     println!(\"{}\", i);\n+/// }\n+/// ```\n+///\n+/// This prints:\n+///\n+/// ```text\n+/// 0\n+/// 2\n+/// 4\n+/// 6\n+/// 8\n+/// 10\n+/// ```\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]"}, {"sha": "99385725a99a1f3ced716dac07f4b7eb9eb8bfa4", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -31,20 +31,10 @@ use option::Option;\n use hash::Hash;\n use hash::Hasher;\n \n-/// Types able to be transferred across thread boundaries.\n-#[unstable(feature = \"core\",\n-           reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n-#[lang=\"send\"]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[cfg(stage0)]\n-pub unsafe trait Send: 'static {\n-    // empty.\n-}\n /// Types able to be transferred across thread boundaries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[cfg(not(stage0))]\n pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n@@ -233,13 +223,6 @@ pub struct Managed;\n \n macro_rules! impls{\n     ($t: ident) => (\n-        #[cfg(stage0)]\n-        impl<T:?Sized, S: Hasher> Hash<S> for $t<T> {\n-            #[inline]\n-            fn hash(&self, _: &mut S) {\n-            }\n-        }\n-        #[cfg(not(stage0))]\n         impl<T:?Sized> Hash for $t<T> {\n             #[inline]\n             fn hash<H: Hasher>(&self, _: &mut H) {\n@@ -348,14 +331,6 @@ impl<T:?Sized> MarkerTrait for T { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n \n-#[cfg(stage0)] // built into the trait matching system after stage0\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n-\n-/// Specific to stage0. You should not be seeing these docs!\n-#[cfg(stage0)]\n-#[lang=\"covariant_type\"] // only relevant to stage0\n-pub struct PhantomData<T:?Sized>;\n-\n /// `PhantomData` is a way to tell the compiler about fake fields.\n /// Phantom data is required whenever type parameters are not used.\n /// The idea is that if the compiler encounters a `PhantomData<T>`\n@@ -374,14 +349,12 @@ pub struct PhantomData<T:?Sized>;\n /// here! For now, please see [RFC 738][738] for more information.\n ///\n /// [738]: https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\n-#[cfg(not(stage0))]\n #[lang=\"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n \n impls! { PhantomData }\n \n-#[cfg(not(stage0))]\n mod impls {\n     use super::{Send, Sync, Sized};\n \n@@ -417,7 +390,6 @@ pub struct ContravariantType<T>;\n #[unstable(feature = \"core\", reason = \"deprecated\")]\n #[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<T>`\")]\n #[lang=\"covariant_type\"]\n-#[cfg(not(stage0))]\n pub struct CovariantType<T>;\n \n /// Old-style marker trait. Deprecated."}, {"sha": "bc3995439a0173c782f158f56daa1c835dd3b7ac", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -170,84 +170,84 @@ mod u32 {\n     use test::Bencher;\n     use core::fmt::radix;\n     use std::rand::{weak_rng, Rng};\n-    use std::old_io::util::NullWriter;\n+    use std::io::{Write, sink};\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{:b}\", rng.gen::<u32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{:b}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_oct(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{:o}\", rng.gen::<u32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{:o}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{}\", rng.gen::<u32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_hex(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{:x}\", rng.gen::<u32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{:x}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_show(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{:?}\", rng.gen::<u32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{:?}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{}\", radix(rng.gen::<u32>(), 36)) })\n+        b.iter(|| { write!(&mut sink(), \"{}\", radix(rng.gen::<u32>(), 36)) })\n     }\n }\n \n mod i32 {\n     use test::Bencher;\n     use core::fmt::radix;\n     use std::rand::{weak_rng, Rng};\n-    use std::old_io::util::NullWriter;\n+    use std::io::{Write, sink};\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{:b}\", rng.gen::<i32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{:b}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_oct(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{:o}\", rng.gen::<i32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{:o}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{}\", rng.gen::<i32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_hex(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{:x}\", rng.gen::<i32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{:x}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_show(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{:?}\", rng.gen::<i32>()) })\n+        b.iter(|| { write!(&mut sink(), \"{:?}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        b.iter(|| { write!(&mut NullWriter, \"{}\", radix(rng.gen::<i32>(), 36)) })\n+        b.iter(|| { write!(&mut sink(), \"{}\", radix(rng.gen::<i32>(), 36)) })\n     }\n }"}, {"sha": "6cbc7bf1bbc51a72b3e34a5a98e2a545b54b2094", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -82,7 +82,7 @@ fn test_iterator_chain() {\n     let xs = [0, 1, 2, 3, 4, 5];\n     let ys = [30, 40, 50, 60];\n     let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n-    let mut it = xs.iter().chain(ys.iter());\n+    let it = xs.iter().chain(ys.iter());\n     let mut i = 0;\n     for &x in it {\n         assert_eq!(x, expected[i]);\n@@ -91,7 +91,7 @@ fn test_iterator_chain() {\n     assert_eq!(i, expected.len());\n \n     let ys = count(30, 10).take(4);\n-    let mut it = xs.iter().cloned().chain(ys);\n+    let it = xs.iter().cloned().chain(ys);\n     let mut i = 0;\n     for x in it {\n         assert_eq!(x, expected[i]);\n@@ -110,7 +110,7 @@ fn test_filter_map() {\n #[test]\n fn test_iterator_enumerate() {\n     let xs = [0, 1, 2, 3, 4, 5];\n-    let mut it = xs.iter().enumerate();\n+    let it = xs.iter().enumerate();\n     for (i, &x) in it {\n         assert_eq!(i, x);\n     }\n@@ -152,7 +152,7 @@ fn test_iterator_peekable() {\n fn test_iterator_take_while() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n     let ys = [0, 1, 2, 3, 5, 13];\n-    let mut it = xs.iter().take_while(|&x| *x < 15);\n+    let it = xs.iter().take_while(|&x| *x < 15);\n     let mut i = 0;\n     for x in it {\n         assert_eq!(*x, ys[i]);\n@@ -165,7 +165,7 @@ fn test_iterator_take_while() {\n fn test_iterator_skip_while() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n     let ys = [15, 16, 17, 19];\n-    let mut it = xs.iter().skip_while(|&x| *x < 15);\n+    let it = xs.iter().skip_while(|&x| *x < 15);\n     let mut i = 0;\n     for x in it {\n         assert_eq!(*x, ys[i]);\n@@ -231,7 +231,7 @@ fn test_iterator_scan() {\n     let xs = [0, 1, 2, 3, 4];\n     let ys = [0f64, 1.0, 3.0, 6.0, 10.0];\n \n-    let mut it = xs.iter().scan(0, add);\n+    let it = xs.iter().scan(0, add);\n     let mut i = 0;\n     for x in it {\n         assert_eq!(x, ys[i]);\n@@ -244,7 +244,7 @@ fn test_iterator_scan() {\n fn test_iterator_flat_map() {\n     let xs = [0, 3, 6];\n     let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    let mut it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n+    let it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n     let mut i = 0;\n     for x in it {\n         assert_eq!(x, ys[i]);\n@@ -279,7 +279,7 @@ fn test_unfoldr() {\n         }\n     }\n \n-    let mut it = Unfold::new(0, count);\n+    let it = Unfold::new(0, count);\n     let mut i = 0;\n     for counted in it {\n         assert_eq!(counted, i);"}, {"sha": "03924910e0485d12acf5f4c86798842dacac6fe6", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -12,6 +12,15 @@\n #![feature(int_uint)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_destructor)]\n+#![feature(core)]\n+#![feature(test)]\n+#![feature(rand)]\n+#![feature(unicode)]\n+#![feature(std_misc)]\n+#![feature(libc)]\n+#![feature(hash)]\n+#![feature(io)]\n+#![feature(collections)]\n #![allow(deprecated)] // rand\n \n extern crate core;"}, {"sha": "4e329897e1ab21958e6dd520aabdaea04b3b34ff", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -784,7 +784,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(&desc_rows.connect(&desc_sep[..])[]);\n+        row.push_str(&desc_rows.connect(&desc_sep[..]));\n \n         row\n     });"}, {"sha": "583c658dfe0582f3b02847e71aab3d4770620237", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -32,6 +32,8 @@\n #![deprecated(reason = \"use the crates.io `rand` library instead\",\n               since = \"1.0.0-alpha\")]\n \n+#![cfg_attr(test, feature(test, rand))]\n+\n #![allow(deprecated)]\n \n #[macro_use]"}, {"sha": "c48dd7a6ee89406fe26a978264a17ba81dd6c9f3", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -32,6 +32,8 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n+#![cfg_attr(test, feature(test))]\n+\n extern crate serialize;\n #[macro_use] extern crate log;\n "}, {"sha": "1db993fdafd271cfc3c921bd9f2e203ed1a6fe0a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 64, "deletions": 20, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -588,7 +588,7 @@ impl LintPass for RawPointerDerive {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(&item.attrs[], \"automatically_derived\") {\n+        if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n             return\n         }\n         let did = match item.node {\n@@ -652,7 +652,7 @@ impl LintPass for UnusedAttributes {\n \n         if !attr::is_used(attr) {\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n-            if KNOWN_ATTRIBUTES.contains(&(&attr.name()[], AttributeType::CrateLevel)) {\n+            if KNOWN_ATTRIBUTES.contains(&(&attr.name(), AttributeType::CrateLevel)) {\n                 let msg = match attr.node.style {\n                     ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                        attribute: add an exclamation mark: #![foo]\",\n@@ -732,7 +732,7 @@ impl LintPass for UnusedResults {\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, &it.attrs[], s.span);\n+                        warned |= check_must_use(cx, &it.attrs, s.span);\n                     }\n                 } else {\n                     let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n@@ -1093,7 +1093,7 @@ impl UnusedParens {\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n                              &format!(\"unnecessary parentheses around {}\",\n-                                     msg)[])\n+                                     msg))\n             }\n         }\n \n@@ -1235,7 +1235,7 @@ impl LintPass for NonShorthandFieldPatterns {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str())[])\n+                                              be removed\", ident.node.as_str()))\n                     }\n                 }\n             }\n@@ -1269,27 +1269,71 @@ impl LintPass for UnusedUnsafe {\n }\n \n declare_lint! {\n-    UNSAFE_BLOCKS,\n+    UNSAFE_CODE,\n     Allow,\n-    \"usage of an `unsafe` block\"\n+    \"usage of `unsafe` code\"\n }\n \n #[derive(Copy)]\n-pub struct UnsafeBlocks;\n+pub struct UnsafeCode;\n \n-impl LintPass for UnsafeBlocks {\n+impl LintPass for UnsafeCode {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSAFE_BLOCKS)\n+        lint_array!(UNSAFE_CODE)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == ast::UnsafeBlock(ast::UserProvided) {\n-                cx.span_lint(UNSAFE_BLOCKS, blk.span, \"usage of an `unsafe` block\");\n+                cx.span_lint(UNSAFE_CODE, blk.span, \"usage of an `unsafe` block\");\n             }\n         }\n     }\n+\n+    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n+        use syntax::ast::Unsafety::Unsafe;\n+\n+        fn check_method(cx: &Context, meth: &P<ast::Method>) {\n+            if let ast::Method_::MethDecl(_, _, _, _, Unsafe, _, _, _) = meth.node {\n+                cx.span_lint(UNSAFE_CODE, meth.span, \"implementation of an `unsafe` method\");\n+            }\n+        }\n+\n+        match it.node {\n+            ast::ItemFn(_, Unsafe, _, _, _) =>\n+                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` function\"),\n+\n+            ast::ItemTrait(trait_safety, _, _, ref items) => {\n+                if trait_safety == Unsafe {\n+                    cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\");\n+                }\n+\n+                for it in items {\n+                    match *it {\n+                        ast::RequiredMethod(ast::TypeMethod { unsafety: Unsafe, span, ..}) =>\n+                            cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` method\"),\n+                        ast::ProvidedMethod(ref meth) => check_method(cx, meth),\n+                        _ => (),\n+                    }\n+                }\n+            },\n+\n+            ast::ItemImpl(impl_safety, _, _, _, _, ref impls) => {\n+                if impl_safety == Unsafe {\n+                    cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\");\n+                }\n+\n+                for item in impls {\n+                    if let ast::ImplItem::MethodImplItem(ref meth) = *item {\n+                        check_method(cx, meth);\n+                    }\n+                }\n+            },\n+\n+            _ => return,\n+        }\n+    }\n }\n \n declare_lint! {\n@@ -1339,7 +1383,7 @@ impl LintPass for UnusedMut {\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms {\n-                self.check_unused_mut_pat(cx, &a.pats[])\n+                self.check_unused_mut_pat(cx, &a.pats)\n             }\n         }\n     }\n@@ -1460,7 +1504,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                &format!(\"missing documentation for {}\", desc)[]);\n+                &format!(\"missing documentation for {}\", desc));\n         }\n     }\n }\n@@ -1496,7 +1540,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, &krate.attrs[],\n+        self.check_missing_docs_attrs(cx, None, &krate.attrs,\n                                      krate.span, \"crate\");\n     }\n \n@@ -1510,7 +1554,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs,\n                                      it.span, desc);\n     }\n \n@@ -1523,13 +1567,13 @@ impl LintPass for MissingDoc {\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs[],\n+            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs,\n                                           m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs,\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1539,14 +1583,14 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              &sf.node.attrs[], sf.span,\n+                                              &sf.node.attrs, sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs,\n                                      v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;"}, {"sha": "d344ee8c881c5ab4fa796f64f80f9ae2264ffcb2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -105,7 +105,7 @@ impl LintStore {\n     }\n \n     pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        &self.lints[]\n+        &self.lints\n     }\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n@@ -206,7 +206,7 @@ impl LintStore {\n                      UnusedImportBraces,\n                      NonShorthandFieldPatterns,\n                      UnusedUnsafe,\n-                     UnsafeBlocks,\n+                     UnsafeCode,\n                      UnusedMut,\n                      UnusedAllocation,\n                      MissingCopyImplementations,\n@@ -276,7 +276,7 @@ impl LintStore {\n                              .collect::<Vec<()>>();\n                         }\n                         None => sess.err(&format!(\"unknown {} flag: {}\",\n-                                                 level.as_str(), lint_name)[]),\n+                                                 level.as_str(), lint_name)),\n                     }\n                 }\n             }\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     self.tcx.sess.span_err(span,\n                                            &format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n-                                                   lint_name)[]);\n+                                                   lint_name));\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n@@ -562,15 +562,15 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        self.with_lint_attrs(&it.attrs[], |cx| {\n+        self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n-        self.with_lint_attrs(&it.attrs[], |cx| {\n+        self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n@@ -595,7 +595,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(&m.attrs[], |cx| {\n+                self.with_lint_attrs(&m.attrs, |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id);\n@@ -611,7 +611,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(&t.attrs[], |cx| {\n+        self.with_lint_attrs(&t.attrs, |cx| {\n             run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t);\n         })\n@@ -628,14 +628,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        self.with_lint_attrs(&s.node.attrs[], |cx| {\n+        self.with_lint_attrs(&s.node.attrs, |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        self.with_lint_attrs(&v.node.attrs[], |cx| {\n+        self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -779,7 +779,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(&krate.attrs[], |cx| {\n+    cx.with_lint_attrs(&krate.attrs, |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;"}, {"sha": "021827b0101c81f7dee8caf04ab20ca6bcc9cac5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -185,14 +185,6 @@ impl PartialEq for LintId {\n \n impl Eq for LintId { }\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for LintId {\n-    fn hash(&self, state: &mut S) {\n-        let ptr = self.lint as *const Lint;\n-        ptr.hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl hash::Hash for LintId {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         let ptr = self.lint as *const Lint;"}, {"sha": "4c123b55e8e5034f51b8ec7d5af440fd953d112c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -61,7 +61,7 @@ fn dump_crates(cstore: &CStore) {\n }\n \n fn should_link(i: &ast::Item) -> bool {\n-    !attr::contains_name(&i.attrs[], \"no_link\")\n+    !attr::contains_name(&i.attrs, \"no_link\")\n }\n \n struct CrateInfo {\n@@ -85,7 +85,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n         if c == '_' || c == '-' { continue }\n-        err(&format!(\"invalid character `{}` in crate name: `{}`\", c, s)[]);\n+        err(&format!(\"invalid character `{}` in crate name: `{}`\", c, s));\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n@@ -210,8 +210,8 @@ impl<'a> CrateReader<'a> {\n                 match self.extract_crate_info(i) {\n                     Some(info) => {\n                         let (cnum, _, _) = self.resolve_crate(&None,\n-                                                              &info.ident[],\n-                                                              &info.name[],\n+                                                              &info.ident,\n+                                                              &info.name,\n                                                               None,\n                                                               i.span,\n                                                               PathKind::Crate);\n@@ -268,7 +268,7 @@ impl<'a> CrateReader<'a> {\n                                     } else {\n                                         self.sess.span_err(m.span,\n                                             &format!(\"unknown kind: `{}`\",\n-                                                    k)[]);\n+                                                    k));\n                                         cstore::NativeUnknown\n                                     }\n                                 }\n@@ -413,7 +413,7 @@ impl<'a> CrateReader<'a> {\n                     hash: hash.map(|a| &*a),\n                     filesearch: self.sess.target_filesearch(kind),\n                     target: &self.sess.target.target,\n-                    triple: &self.sess.opts.target_triple[],\n+                    triple: &self.sess.opts.target_triple,\n                     root: root,\n                     rejected_via_hash: vec!(),\n                     rejected_via_triple: vec!(),\n@@ -440,8 +440,8 @@ impl<'a> CrateReader<'a> {\n         decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n-                                                   &dep.name[],\n-                                                   &dep.name[],\n+                                                   &dep.name,\n+                                                   &dep.name,\n                                                    Some(&dep.hash),\n                                                    span,\n                                                    PathKind::Dependency);\n@@ -450,7 +450,7 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n-        let target_triple = &self.sess.opts.target_triple[];\n+        let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let mut target_only = false;\n@@ -493,8 +493,8 @@ impl<'a> CrateReader<'a> {\n                                                           PathKind::Crate).is_none();\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n-            let (_, cmd, _) = self.register_crate(&None, &info.ident[],\n-                                &info.name[], span, library);\n+            let (_, cmd, _) = self.register_crate(&None, &info.ident,\n+                                &info.name, span, library);\n             PMDSource::Registered(cmd)\n         } else {\n             // Not registering the crate; just hold on to the metadata"}, {"sha": "38e15af2056bec11d74dc57e681c5b5c6e61a6ec", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -92,7 +92,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    let mut r = vec![ast_map::PathMod(token::intern(&cdata.name[]))];\n+    let mut r = vec![ast_map::PathMod(token::intern(&cdata.name))];\n     r.push_all(&path);\n     r\n }\n@@ -391,7 +391,7 @@ pub fn is_staged_api(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n     let attrs = decoder::get_crate_attributes(cdata.data());\n     for attr in &attrs {\n-        if &attr.name()[] == \"staged_api\" {\n+        if &attr.name()[..] == \"staged_api\" {\n             match attr.node.value.node { ast::MetaWord(_) => return true, _ => (/*pass*/) }\n         }\n     }"}, {"sha": "f883c8a1bb9189eb6bf1d9a3900eef3b042aa9f5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1225,7 +1225,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash)[]);\n+        let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash));\n         deps.push(CrateDep {\n             cnum: crate_num,\n             name: name,"}, {"sha": "629b19300e62ce6fc4c8c897a004758b9a46d13b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 39, "deletions": 81, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -94,7 +94,7 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id)[]);\n+    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id));\n }\n \n #[derive(Clone)]\n@@ -273,7 +273,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                &format!(\"encode_symbol: id not found {}\", id)[]);\n+                &format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n     rbml_w.end_tag();\n@@ -341,8 +341,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(rbml_w, variant.node.name.name);\n         encode_parent_item(rbml_w, local_def(id));\n         encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, &variant.node.attrs[]);\n-        encode_repr_attrs(rbml_w, ecx, &variant.node.attrs[]);\n+        encode_attributes(rbml_w, &variant.node.attrs);\n+        encode_repr_attrs(rbml_w, ecx, &variant.node.attrs);\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(rbml_w, stab);\n@@ -394,12 +394,12 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(&def_to_string(method_def_id)[]);\n+    rbml_w.wr_str(&def_to_string(method_def_id));\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n     rbml_w.wr_str(&format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_name(method_name))[]);\n+                          token::get_name(method_name)));\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -537,7 +537,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(&def_to_string(exp.def_id)[]);\n+                rbml_w.wr_str(&def_to_string(exp.def_id));\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n                 rbml_w.wr_str(exp.name.as_str());\n@@ -570,13 +570,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in &md.items {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n+        rbml_w.wr_str(&def_to_string(local_def(item.id)));\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(&def_to_string(local_def(\n-                        auxiliary_node_id))[]);\n+                        auxiliary_node_id)));\n             rbml_w.end_tag();\n             true\n         });\n@@ -588,7 +588,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(&def_to_string(local_def(did))[]);\n+            rbml_w.wr_str(&def_to_string(local_def(did)));\n             rbml_w.end_tag();\n         }\n     }\n@@ -623,7 +623,7 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(&ch.to_string()[]);\n+    rbml_w.wr_str(&ch.to_string());\n     rbml_w.end_tag();\n }\n \n@@ -783,7 +783,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n \n         rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             &def_to_string(param.def_id)[]);\n+                             &def_to_string(param.def_id));\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -858,10 +858,10 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, &ast_method.attrs[]);\n+            encode_attributes(rbml_w, &ast_method.attrs);\n             let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(&ast_method.attrs[]) {\n+            if any_types || is_default_impl || should_inline(&ast_method.attrs) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -906,7 +906,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     match typedef_opt {\n         None => {}\n         Some(typedef) => {\n-            encode_attributes(rbml_w, &typedef.attrs[]);\n+            encode_attributes(rbml_w, &typedef.attrs);\n             encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n                                                          typedef.id));\n         }\n@@ -1040,7 +1040,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n         rbml_w.end_tag();\n       }\n       ast::ItemConst(_, _) => {\n@@ -1066,8 +1066,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, &item.attrs[]);\n-        if tps_len > 0 || should_inline(&item.attrs[]) {\n+        encode_attributes(rbml_w, &item.attrs);\n+        if tps_len > 0 || should_inline(&item.attrs) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n@@ -1083,7 +1083,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n-                            &item.attrs[],\n+                            &item.attrs,\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1100,7 +1100,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(local_def(foreign_item.id))[]);\n+            rbml_w.wr_str(&def_to_string(local_def(foreign_item.id)));\n             rbml_w.end_tag();\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1128,8 +1128,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, &item.attrs[]);\n-        encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n+        encode_repr_attrs(rbml_w, ecx, &item.attrs);\n         for v in &enum_definition.variants {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n@@ -1146,7 +1146,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 &(*enum_definition).variants[],\n+                                 &(*enum_definition).variants,\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n@@ -1172,11 +1172,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, &item.attrs);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n@@ -1213,7 +1213,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n@@ -1319,7 +1319,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         for &method_def_id in &*ty::trait_item_def_ids(tcx, def_id) {\n@@ -1337,7 +1337,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(method_def_id.def_id())[]);\n+            rbml_w.wr_str(&def_to_string(method_def_id.def_id()));\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1426,14 +1426,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n             match trait_item {\n                 &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, &m.attrs[]);\n+                    encode_attributes(rbml_w, &m.attrs);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, &m.attrs[]);\n+                    encode_attributes(rbml_w, &m.attrs);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n@@ -1442,7 +1442,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                 &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n-                                      &associated_type.attrs[]);\n+                                      &associated_type.attrs);\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }\n@@ -1588,48 +1588,6 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n // Path and definition ID indexing\n \n-#[cfg(stage0)]\n-fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n-    F: FnMut(&mut SeekableMemWriter, &T),\n-    T: Hash<SipHasher>,\n-{\n-    let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n-    for elt in index {\n-        let mut s = SipHasher::new();\n-        elt.val.hash(&mut s);\n-        let h = s.finish() as uint;\n-        (&mut buckets[h % 256]).push(elt);\n-    }\n-\n-    rbml_w.start_tag(tag_index);\n-    let mut bucket_locs = Vec::new();\n-    rbml_w.start_tag(tag_index_buckets);\n-    for bucket in &buckets {\n-        bucket_locs.push(rbml_w.writer.tell().unwrap());\n-        rbml_w.start_tag(tag_index_buckets_bucket);\n-        for elt in bucket {\n-            rbml_w.start_tag(tag_index_buckets_bucket_elt);\n-            assert!(elt.pos < 0xffff_ffff);\n-            {\n-                let wr: &mut SeekableMemWriter = rbml_w.writer;\n-                wr.write_be_u32(elt.pos as u32);\n-            }\n-            write_fn(rbml_w.writer, &elt.val);\n-            rbml_w.end_tag();\n-        }\n-        rbml_w.end_tag();\n-    }\n-    rbml_w.end_tag();\n-    rbml_w.start_tag(tag_index_table);\n-    for pos in &bucket_locs {\n-        assert!(*pos < 0xffff_ffff);\n-        let wr: &mut SeekableMemWriter = rbml_w.writer;\n-        wr.write_be_u32(*pos as u32);\n-    }\n-    rbml_w.end_tag();\n-    rbml_w.end_tag();\n-}\n-#[cfg(not(stage0))]\n fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash,\n@@ -1867,10 +1825,10 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_macro_def);\n \n         encode_name(rbml_w, def.ident.name);\n-        encode_attributes(rbml_w, &def.attrs[]);\n+        encode_attributes(rbml_w, &def.attrs);\n \n         rbml_w.start_tag(tag_macro_def_body);\n-        rbml_w.wr_str(&pprust::tts_to_string(&def.body[])[]);\n+        rbml_w.wr_str(&pprust::tts_to_string(&def.body));\n         rbml_w.end_tag();\n \n         rbml_w.end_tag();\n@@ -1887,7 +1845,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n         fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.rbml_w, &field.node.attrs[]);\n+            encode_attributes(self.rbml_w, &field.node.attrs);\n             self.rbml_w.end_tag();\n         }\n     }\n@@ -1959,13 +1917,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n+        rbml_w.wr_str(&def_to_string(local_def(item.id)));\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(&def_to_string(local_def(\n-                        auxiliary_node_id))[]);\n+                        auxiliary_node_id)));\n             rbml_w.end_tag();\n             true\n         });\n@@ -2132,17 +2090,17 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name[]);\n+    encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name);\n     encode_crate_triple(&mut rbml_w,\n                         &tcx.sess\n                            .opts\n                            .target_triple\n-                           []);\n+                           );\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.tell().unwrap();\n-    encode_attributes(&mut rbml_w, &krate.attrs[]);\n+    encode_attributes(&mut rbml_w, &krate.attrs);\n     stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "fbc3e76cf934b2e073d18c9bfee730d52bbcfc1f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -329,7 +329,7 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     &format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display())[]);\n+                            self.ident, i+1, got, path.display()));\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -339,15 +339,15 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     &format!(\"crate `{}` path #{}: {}\",\n-                            self.ident, i+1, path.display())[]);\n+                            self.ident, i+1, path.display()));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n                             &format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display())[]);\n+                                    r.ident, i+1, path.display()));\n                     }\n                 }\n             }\n@@ -359,7 +359,7 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                                         &format!(\"crate `{}` path #{}: {}\",\n-                                                 self.ident, i+1, path.display())[]);\n+                                                 self.ident, i+1, path.display()));\n             }\n         }\n         self.sess.abort_if_errors();\n@@ -472,26 +472,26 @@ impl<'a> Context<'a> {\n             _ => {\n                 self.sess.span_err(self.span,\n                     &format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name)[]);\n+                            self.crate_name));\n                 self.sess.note(\"candidates:\");\n                 for lib in &libraries {\n                     match lib.dylib {\n                         Some((ref p, _)) => {\n                             self.sess.note(&format!(\"path: {}\",\n-                                                   p.display())[]);\n+                                                   p.display()));\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some((ref p, _)) => {\n                             self.sess.note(&format!(\"path: {}\",\n-                                                    p.display())[]);\n+                                                    p.display()));\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), &name[]);\n+                    note_crate_name(self.sess.diagnostic(), &name);\n                 }\n                 None\n             }\n@@ -545,19 +545,19 @@ impl<'a> Context<'a> {\n                                    &format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_name)[]);\n+                                           self.crate_name));\n                 self.sess.span_note(self.span,\n                                     &format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap().0\n-                                               .display())[]);\n+                                               .display()));\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n                                     &format!(r\"candidate #{}: {}\", error,\n-                                            lib.display())[]);\n+                                            lib.display()));\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -630,14 +630,14 @@ impl<'a> Context<'a> {\n             let locs = locs.iter().map(|l| Path::new(&l[..])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display())[]);\n+                                     self.crate_name, loc.display()));\n                     return false;\n                 }\n                 let file = match loc.filename_str() {\n                     Some(file) => file,\n                     None => {\n                         sess.err(&format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display())[]);\n+                                         self.crate_name, loc.display()));\n                         return false;\n                     }\n                 };\n@@ -651,7 +651,7 @@ impl<'a> Context<'a> {\n                     }\n                 }\n                 sess.err(&format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display())[]);\n+                                 self.crate_name, loc.display()));\n                 false\n             });\n \n@@ -686,7 +686,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(&format!(\"crate name: {}\", name)[]);\n+    diag.handler().note(&format!(\"crate name: {}\", name));\n }\n \n impl ArchiveMetadata {"}, {"sha": "d25dc4f58a5dfa6181472a12ff73c75237c69155", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -78,15 +78,15 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n \n         for attr in &item.attrs {\n             let mut used = true;\n-            match &attr.name()[] {\n+            match &attr.name()[..] {\n                 \"phase\" => {\n                     self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n                 }\n                 \"plugin\" => {\n                     self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n                     self.sess.span_help(attr.span, &format!(\"use a crate attribute instead, \\\n                                                             i.e. #![plugin({})]\",\n-                                                            item.ident.as_str())[]);\n+                                                            item.ident.as_str()));\n                 }\n                 \"macro_use\" => {\n                     let names = attr.meta_item_list();"}, {"sha": "4a45b7fbfdcc743b48ae28d2522279a2cb46f0f2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -305,7 +305,7 @@ fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion wher\n         }\n         '[' => {\n             let def = parse_def_(st, RegionParameter, conv);\n-            let ident = token::str_to_ident(&parse_str(st, ']')[]);\n+            let ident = token::str_to_ident(&parse_str(st, ']'));\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -344,7 +344,7 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n         assert_eq!(next(st), '|');\n         let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(&parse_str(st, ']')[]);\n+        let nm = token::str_to_ident(&parse_str(st, ']'));\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n@@ -485,7 +485,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        let name = token::intern(&parse_str(st, ']')[]);\n+        let name = token::intern(&parse_str(st, ']'));\n         return ty::mk_param(tcx, space, index, name);\n       }\n       '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),"}, {"sha": "d699ba40e822045bf4ac34ff6b13a86bfc93198e", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -48,7 +48,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       &format!(\"unbound path {}\",\n-                                              path.repr(tcx))[])\n+                                              path.repr(tcx)))\n                 }\n                 Some(&d) => d\n             };"}, {"sha": "eb723830d383c8d6da97b8902170f3a59b53328f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1852,7 +1852,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n             None => {\n                 dcx.tcx.sess.bug(\n                     &format!(\"unknown tag found in side tables: {:x}\",\n-                            tag)[]);\n+                            tag));\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1937,7 +1937,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     _ => {\n                         dcx.tcx.sess.bug(\n                             &format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag)[]);\n+                                    tag));\n                     }\n                 }\n             }"}, {"sha": "d95dfb6feaec40eed64bbec4b21dbe1985d7bcca", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let mut cond_exit = discr_exit;\n                 for arm in arms {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(&arm.pats[],\n+                    let pats_exit = self.pats_any(&arm.pats,\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n@@ -582,14 +582,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             &format!(\"no loop scope for id {}\",\n-                                    loop_id)[]);\n+                                    loop_id));\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             &format!(\"bad entry `{:?}` in def_map for label\",\n-                                    r)[]);\n+                                    r));\n                     }\n                 }\n             }"}, {"sha": "14c6ff01e0e66d9384732a159c0eda97647052bb", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -54,7 +54,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[]).ok().unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[..]).ok().unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n         dot::Id::new(format!(\"N{}\", i.node_id())).ok().unwrap()\n@@ -92,7 +92,7 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = replace_newline_with_backslash_l(s);\n             label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n-                                   &s[..])[]);\n+                                   &s[..]));\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "f1c8ad947642fab284d991ebc1893d3dae1fec61", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         };\n \n         self.tcx.sess.span_err(e.span, &format!(\"mutable statics are not allowed \\\n-                                                 to have {}\", suffix)[]);\n+                                                 to have {}\", suffix));\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n@@ -382,7 +382,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n                                     &format!(\"{}s are not allowed to have destructors\",\n-                                             v.msg())[]);\n+                                             v.msg()));\n             }\n         }\n         _ => {}"}, {"sha": "7bd64a4f487d60414863d6456ad65cd330d6f676", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -163,7 +163,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n-                                                &arm.pats[]);\n+                                                &arm.pats);\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n@@ -1101,7 +1101,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                             &format!(\"binding pattern {} is not an \\\n                                      identifier: {:?}\",\n                                     p.id,\n-                                    p.node)[]);\n+                                    p.node));\n                     }\n                 }\n             }"}, {"sha": "cf33cd71365789ccd6b62d32b5c28ff225662dcf", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -554,7 +554,7 @@ fn bits_to_string(words: &[uint]) -> String {\n         let mut v = word;\n         for _ in 0..usize::BYTES {\n             result.push(sep);\n-            result.push_str(&format!(\"{:02x}\", v & 0xFF)[]);\n+            result.push_str(&format!(\"{:02x}\", v & 0xFF));\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "40e7610582f9c7454846a43c3bb06fec1aaebb54", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -118,7 +118,7 @@ fn calculate_type(sess: &session::Session,\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name)[]);\n+                                 data.name));\n             });\n             return Vec::new();\n         }\n@@ -197,7 +197,7 @@ fn calculate_type(sess: &session::Session,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 })[]);\n+                                 }));\n             }\n         }\n     }\n@@ -222,7 +222,7 @@ fn add_library(sess: &session::Session,\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n                                   shows up once\",\n-                                 data.name)[]);\n+                                 data.name));\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "ba81b2f3899a8b7406e2b8d60a16f9016e34a91e", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! Enforces the Rust effect system. Currently there is just one effect,\n-/// `unsafe`.\n+//! `unsafe`.\n use self::UnsafeContext::*;\n \n use middle::def;"}, {"sha": "625093e3c5dea50bb8c976a39cbbbec3fa5962db", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -841,7 +841,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 &format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx()))[])\n+                                    method_ty.repr(self.tcx())))\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,"}, {"sha": "99cb2a0978e7eeb1668c1680504f13c364544c8a", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -433,7 +433,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             &format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n                     a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx))[]);\n+                    b.repr(this.infcx().tcx)));\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n@@ -818,7 +818,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     &format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr(self.tcx()))[]);\n+                            r.repr(self.tcx())));\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "110c7bf41e559136aa7e7f5059c45e5e140c44ee", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n                         bound_kind.user_string(self.tcx),\n-                        sub.user_string(self.tcx))[]);\n+                        sub.user_string(self.tcx)));\n             }\n \n             ty::ReStatic => {\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx)));\n             }\n \n             _ => {\n@@ -472,10 +472,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx)));\n                 note_and_explain_region(\n                     self.tcx,\n-                    &format!(\"{} must be valid for \", labeled_user_string)[],\n+                    &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\");\n             }\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"...but `{}` is only valid for \",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n-                                .to_string())[],\n+                                .to_string()),\n                     sup,\n                     \"\");\n             }\n@@ -568,7 +568,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"captured variable `{}` does not \\\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n-                                                   id).to_string())[]);\n+                                                   id).to_string()));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)));\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -636,7 +636,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)));\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"type is only valid for \",\n@@ -752,7 +752,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -988,7 +988,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(&names[0][]).name;\n+            let name = token::str_to_ident(&names[0]).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1240,7 +1240,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 .sess\n                                 .fatal(&format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_string(path))[])\n+                                        pprust::path_to_string(path)))\n                         }\n                         Some(&d) => d\n                     };\n@@ -1479,7 +1479,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             var_origin.span(),\n             &format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description)[]);\n+                    var_description));\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1527,7 +1527,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n                             &format!(\"...so that {} ({})\",\n-                                    desc, values_str)[]);\n+                                    desc, values_str));\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1536,7 +1536,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            &format!(\"...so that {}\", desc)[]);\n+                            &format!(\"...so that {}\", desc));\n                     }\n                 }\n             }\n@@ -1552,7 +1552,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n-                            .to_string())[])\n+                            .to_string()))\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1577,7 +1577,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).to_string())[]);\n+                                id).to_string()));\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1626,7 +1626,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)));\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n@@ -1638,28 +1638,28 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)));\n             }\n             infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     &format!(\"...so that the type `{}` \\\n                              will meet its required lifetime bounds\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)));\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     &format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)));\n             }\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     &format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\")[]);\n+                                are satisfied\"));\n             }\n             infer::SafeDestructor(span) => {\n                 self.tcx.sess.span_note(\n@@ -1717,15 +1717,15 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 ast::ItemFn(_, _, _, ref gen, _) => {\n-                    taken.push_all(&gen.lifetimes[]);\n+                    taken.push_all(&gen.lifetimes);\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(&m.pe_generics().lifetimes[]);\n+                        taken.push_all(&m.pe_generics().lifetimes);\n                         Some(m.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n@@ -1784,7 +1784,7 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(&num_to_string(self.counter.get())[]);\n+            s.push_str(&num_to_string(self.counter.get()));\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n                                     token::str_to_ident(&s[..]).name);"}, {"sha": "b0b9a80589d0d62a78a261ade7d9cbc8118edec4", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -189,7 +189,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 span,\n                 &format!(\"region {:?} is not associated with \\\n                          any bound region from A!\",\n-                        r0)[])\n+                        r0))\n         }\n     }\n \n@@ -322,7 +322,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n             infcx.tcx.sess.span_bug(\n                 span,\n-                &format!(\"could not find original bound region for {:?}\", r)[]);\n+                &format!(\"could not find original bound region for {:?}\", r));\n         }\n \n         fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    &format!(\"found non-region-vid: {:?}\", r)[]);\n+                    &format!(\"found non-region-vid: {:?}\", r));\n             }\n         }).collect()\n }"}, {"sha": "835964828d419c468785a2722902c113086febdb", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -999,7 +999,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str)[]);\n+                    error_str));\n \n                 if let Some(err) = err {\n                     ty::note_and_explain_type_err(self.tcx, err)"}, {"sha": "5959b4a7c507a46420893aa508a91e9e5899fd67", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 origin.span(),\n                 &format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx))[]);\n+                        sup.repr(self.tcx)));\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.bug(\n                 &format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx))[]);\n+                        b.repr(self.tcx)));\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -750,7 +750,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 &format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {:?}, {:?}\",\n                         a,\n-                        b)[]);\n+                        b));\n           }\n \n           (ReFree(ref fr), ReScope(s_id)) |\n@@ -834,7 +834,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n               self.tcx.sess.bug(\n                   &format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx))[]);\n+                          b.repr(self.tcx)));\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -854,7 +854,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     &format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {:?}, {:?}\",\n                             a,\n-                            b)[]);\n+                            b));\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -1417,7 +1417,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx))[]);\n+                    upper_bounds.repr(self.tcx)));\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1461,7 +1461,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             &format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {:?}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx))[]);\n+                    upper_bounds.repr(self.tcx)));\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "547696c0c4c2f243b409b6aecdb765b25226409a", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 ty::ty_infer(_) => {\n                     self.infcx.tcx.sess.bug(\n                         &format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr(self.infcx.tcx))[]);\n+                                t.repr(self.infcx.tcx)));\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "145fccd7972bb5bcbf927d27d391abc5f4d41c97", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -325,7 +325,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             self.tcx\n                 .sess\n                 .span_bug(span, &format!(\"no variable registered for id {}\",\n-                                        node_id)[]);\n+                                        node_id));\n           }\n         }\n     }\n@@ -585,7 +585,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.ir.tcx.sess.span_bug(\n                 span,\n                 &format!(\"no live node registered for node {}\",\n-                        node_id)[]);\n+                        node_id));\n           }\n         }\n     }"}, {"sha": "d1fba421bbe58eeb9649b9ac594c3dc66bd5939c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -624,7 +624,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           span,\n                           &format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx()))[]);\n+                                  ty.repr(self.tcx())));\n                   }\n               }\n           }"}, {"sha": "7774314b6e08848ce58dd2611bbead69b066071a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -50,7 +50,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(&item.attrs[]) {\n+    if attributes_specify_inlining(&item.attrs) {\n         return true\n     }\n \n@@ -65,7 +65,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(&method.attrs[]) ||\n+    if attributes_specify_inlining(&method.attrs) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n-                                    &method.attrs[]) {\n+                                    &method.attrs) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 None => {\n                     self.tcx.sess.bug(&format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item)[])\n+                                              search_item))\n                 }\n             }\n         }\n@@ -342,7 +342,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     .bug(&format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_string(search_item))[])\n+                                     .node_to_string(search_item)))\n             }\n         }\n     }"}, {"sha": "cfa5e5fce387930a2a71a6ef89c2dc3b3fdd1824", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -181,7 +181,7 @@ impl Index {\n     pub fn new(krate: &Crate) -> Index {\n         let mut staged_api = false;\n         for attr in &krate.attrs {\n-            if &attr.name()[] == \"staged_api\" {\n+            if &attr.name()[..] == \"staged_api\" {\n                 match attr.node.value.node {\n                     ast::MetaWord(_) => {\n                         attr::mark_used(attr);"}, {"sha": "684b28d03739e3fe28b84a524b120e4b48a32d3a", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -639,7 +639,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                      (space={:?}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n-                                    space, i)[]);\n+                                    space, i));\n                             }\n                         }\n                 }\n@@ -696,7 +696,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                             p.space,\n                             p.idx,\n                             self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx()))[]);\n+                            self.substs.repr(self.tcx())));\n             }\n         };\n "}, {"sha": "6d3b910e720a71dc67dd32e33e382542d9b179fb", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -198,7 +198,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_err => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx))[])\n+                        ty.repr(tcx)))\n         }\n     }\n }"}, {"sha": "d2b5b460d142002b174a88910a9972944f3f7316", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -422,5 +422,5 @@ pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n         span,\n         &format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-            suggested_limit)[]);\n+            suggested_limit));\n }"}, {"sha": "c1066aa899eaea4fe4f7e34ea89b319a443c4e8f", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n-        &self.predicates[]\n+        &self.predicates\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it"}, {"sha": "085758b44b5c7a0ee39188fdd5a6561caa563999", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1575,7 +1575,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx()))[]);\n+                        self_ty.repr(self.tcx())));\n             }\n         };\n \n@@ -1727,7 +1727,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     &format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx()))[]);\n+                            obligation.repr(self.tcx())));\n             }\n         }\n     }\n@@ -1995,7 +1995,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\"Impl {} was matchable against {} but now is not\",\n                             impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx()))[]);\n+                            obligation.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "1206424550f951a36414149410de25e23ed188a7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -73,7 +73,6 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n-#[cfg(stage0)] use std::hash::Writer;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -959,13 +958,6 @@ impl<'tcx> PartialEq for TyS<'tcx> {\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n \n-#[cfg(stage0)]\n-impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n-    fn hash(&self, s: &mut S) {\n-        (self as *const _).hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'tcx> Hash for TyS<'tcx> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         (self as *const _).hash(s)\n@@ -988,13 +980,6 @@ impl<'tcx> PartialEq for InternedTy<'tcx> {\n \n impl<'tcx> Eq for InternedTy<'tcx> {}\n \n-#[cfg(stage0)]\n-impl<'tcx, S: Writer + Hasher> Hash<S> for InternedTy<'tcx> {\n-    fn hash(&self, s: &mut S) {\n-        self.ty.sty.hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'tcx> Hash for InternedTy<'tcx> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         self.ty.sty.hash(s)\n@@ -2295,7 +2280,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             _ => {\n                 cx.sess.bug(&format!(\"ParameterEnvironment::from_item(): \\\n                                      `{}` is not an item\",\n-                                    cx.map.node_to_string(id))[])\n+                                    cx.map.node_to_string(id)))\n             }\n         }\n     }\n@@ -2737,7 +2722,7 @@ impl FlagComputation {\n     fn add_fn_sig(&mut self, fn_sig: &PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(&fn_sig.0.inputs[]);\n+        computation.add_tys(&fn_sig.0.inputs);\n \n         if let ty::FnConverging(output) = fn_sig.0.output {\n             computation.add_ty(output);\n@@ -3177,7 +3162,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         ty_str => mk_mach_uint(cx, ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty))[]),\n+                                 ty_to_string(cx, ty))),\n     }\n }\n \n@@ -3538,7 +3523,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n                     TypeContents::union(&variants[..], |variant| {\n-                        TypeContents::union(&variant.args[],\n+                        TypeContents::union(&variant.args,\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n@@ -4121,7 +4106,7 @@ pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(&format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty))[])\n+                                 ty_to_string(cx, ty)))\n     }\n }\n \n@@ -4222,7 +4207,7 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n             &format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_string(id))[])\n+                    cx.map.node_to_string(id)))\n     }\n }\n \n@@ -4231,7 +4216,7 @@ pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n            &format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_string(id))[])\n+                   cx.map.node_to_string(id)))\n     }\n }\n \n@@ -4305,7 +4290,7 @@ pub fn ty_region(tcx: &ctxt,\n             tcx.sess.span_bug(\n                 span,\n                 &format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n-                        s)[]);\n+                        s));\n         }\n     }\n }\n@@ -4370,11 +4355,11 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n         Some(f) => {\n             cx.sess.bug(&format!(\"Node id {} is not an expr: {:?}\",\n                                 id,\n-                                f)[]);\n+                                f));\n         }\n         None => {\n             cx.sess.bug(&format!(\"Node id {} is not present \\\n-                                in the node map\", id)[]);\n+                                in the node map\", id));\n         }\n     }\n }\n@@ -4390,14 +4375,14 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                     cx.sess.bug(\n                         &format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                pat)[]);\n+                                pat));\n                 }\n             }\n         }\n         r => {\n             cx.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                r)[]);\n+                                r));\n         }\n     }\n }\n@@ -4428,7 +4413,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             cx.sess.bug(\n                                 &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n                                          {:?}\",\n-                                        b)[]);\n+                                        b));\n                         }\n                     }\n                 }\n@@ -4459,7 +4444,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                                 {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n-                                        []);\n+                                        );\n                                 }\n                             }\n                         }\n@@ -4522,7 +4507,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   &format!(\"UnsizeLength with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty))[])\n+                                          ty_to_string(cx, ty)))\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, substs) => {\n@@ -4534,7 +4519,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   &format!(\"UnsizeStruct with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty))[])\n+                                          ty_to_string(cx, ty)))\n         },\n         &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n             mk_trait(cx, principal.clone(), bounds.clone())\n@@ -4547,7 +4532,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, &format!(\n-                \"no def-map entry for expr {}\", expr.id)[]);\n+                \"no def-map entry for expr {}\", expr.id));\n         }\n     }\n }\n@@ -4639,7 +4624,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                         expr.span,\n                         &format!(\"uncategorized def for expr {}: {:?}\",\n                                 expr.id,\n-                                def)[]);\n+                                def));\n                 }\n             }\n         }\n@@ -4767,7 +4752,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).to_string())\n-              .collect::<Vec<String>>())[]);\n+              .collect::<Vec<String>>()));\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n@@ -5019,14 +5004,14 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                     _ => {\n                         cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is \\\n                                              not a trait\",\n-                                            id)[])\n+                                            id))\n                     }\n                 }\n             }\n             _ => {\n                 cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a \\\n                                      trait\",\n-                                    id)[])\n+                                    id))\n             }\n         }\n     } else {\n@@ -5262,7 +5247,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                 };\n             },\n             ast::StructVariantKind(ref struct_def) => {\n-                let fields: &[StructField] = &struct_def.fields[];\n+                let fields: &[StructField] = &struct_def.fields;\n \n                 assert!(fields.len() > 0);\n \n@@ -5624,7 +5609,7 @@ pub fn get_attrs<'tcx>(tcx: &'tcx ctxt, did: DefId)\n                        -> CowVec<'tcx, ast::Attribute> {\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n-        Cow::Borrowed(&item.attrs[])\n+        Cow::Borrowed(&item.attrs)\n     } else {\n         Cow::Owned(csearch::get_item_attrs(&tcx.sess.cstore, did))\n     }\n@@ -5686,7 +5671,7 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n             _ => {\n                 cx.sess.bug(\n                     &format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_string(did.node))[]);\n+                            cx.map.node_to_string(did.node)));\n             }\n         }\n     } else {\n@@ -5719,7 +5704,7 @@ pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tc\n pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            name: token::intern(&i.to_string()[]),\n+            name: token::intern(&i.to_string()),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable"}, {"sha": "efc12d00b10c60145b43fc222069523169b7a015", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -311,19 +311,19 @@ macro_rules! options {\n                     match (value, opt_type_desc) {\n                         (Some(..), None) => {\n                             early_error(&format!(\"{} option `{}` takes no \\\n-                                                 value\", $outputname, key)[])\n+                                                 value\", $outputname, key))\n                         }\n                         (None, Some(type_desc)) => {\n                             early_error(&format!(\"{0} option `{1}` requires \\\n                                                  {2} ({3} {1}=<value>)\",\n                                                 $outputname, key,\n-                                                type_desc, $prefix)[])\n+                                                type_desc, $prefix))\n                         }\n                         (Some(value), Some(type_desc)) => {\n                             early_error(&format!(\"incorrect value `{}` for {} \\\n                                                  option `{}` - {} was expected\",\n                                                  value, $outputname,\n-                                                 key, type_desc)[])\n+                                                 key, type_desc))\n                         }\n                         (None, None) => unreachable!()\n                     }\n@@ -333,7 +333,7 @@ macro_rules! options {\n             }\n             if !found {\n                 early_error(&format!(\"unknown {} option: `{}`\",\n-                                    $outputname, key)[]);\n+                                    $outputname, key));\n             }\n         }\n         return op;\n@@ -590,10 +590,10 @@ pub fn default_lib_output() -> CrateType {\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     use syntax::parse::token::intern_and_get_ident as intern;\n \n-    let end = &sess.target.target.target_endian[];\n-    let arch = &sess.target.target.arch[];\n-    let wordsz = &sess.target.target.target_pointer_width[];\n-    let os = &sess.target.target.target_os[];\n+    let end = &sess.target.target.target_endian;\n+    let arch = &sess.target.target.arch;\n+    let wordsz = &sess.target.target.target_pointer_width;\n+    let os = &sess.target.target.target_os;\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -634,18 +634,18 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n }\n \n pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n-    let target = match Target::search(&opts.target_triple[]) {\n+    let target = match Target::search(&opts.target_triple) {\n         Ok(t) => t,\n         Err(e) => {\n             sp.handler().fatal(&format!(\"Error loading target specification: {}\", e));\n     }\n     };\n \n-    let (int_type, uint_type) = match &target.target_pointer_width[] {\n+    let (int_type, uint_type) = match &target.target_pointer_width[..] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n         w    => sp.handler().fatal(&format!(\"target specification was invalid: unrecognized \\\n-                                             target-pointer-width {}\", w)[])\n+                                             target-pointer-width {}\", w))\n     };\n \n     Config {\n@@ -863,7 +863,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"dep-info\" => OutputTypeDepInfo,\n                     _ => {\n                         early_error(&format!(\"unknown emission type: `{}`\",\n-                                            part)[])\n+                                            part))\n                     }\n                 };\n                 output_types.push(output_type)\n@@ -955,7 +955,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             (_, s) => {\n                 early_error(&format!(\"unknown library kind `{}`, expected \\\n                                      one of dylib, framework, or static\",\n-                                    s)[]);\n+                                    s));\n             }\n         };\n         (name.to_string(), kind)\n@@ -991,7 +991,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         Some(arg) => {\n             early_error(&format!(\"argument for --color must be auto, always \\\n                                  or never (instead was `{}`)\",\n-                                arg)[])\n+                                arg))\n         }\n     };\n \n@@ -1111,7 +1111,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], &optgroups()[]) {\n+            &match getopts(&[\"--test\".to_string()], &optgroups()) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n@@ -1128,7 +1128,7 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           &optgroups()[]) {\n+                           &optgroups()) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1148,7 +1148,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n-            ], &optgroups()[]).unwrap();\n+            ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1159,7 +1159,7 @@ mod test {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], &optgroups()[]).unwrap();\n+            ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1169,7 +1169,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n-            ], &optgroups()[]).unwrap();\n+            ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);"}, {"sha": "932a96e9b9ebd7df28572fd289f76fe55fdcb6a1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -186,7 +186,7 @@ impl Session {\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp,\n-                      &format!(\"impossible case reached: {}\", msg)[]);\n+                      &format!(\"impossible case reached: {}\", msg));\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n@@ -228,7 +228,7 @@ impl Session {\n     }\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n         filesearch::FileSearch::new(self.sysroot(),\n-                                    &self.opts.target_triple[],\n+                                    &self.opts.target_triple,\n                                     &self.opts.search_paths,\n                                     kind)\n     }"}, {"sha": "a3cc23b7bba839d9ee2ed0ffdd705e11ba1ce1cc", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 6, "deletions": 97, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -14,7 +14,6 @@ use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt::Debug;\n use std::hash::Hash;\n-#[cfg(stage0)] use std::hash::Hasher;\n use std::iter::repeat;\n use std::time::Duration;\n use std::collections::hash_state::HashState;\n@@ -139,57 +138,13 @@ pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -\n \n /// K: Eq + Hash<S>, V, S, H: Hasher<S>\n ///\n-/// Determines whether there exists a path from `source` to `destination`.  The graph is defined by\n-/// the `edges_map`, which maps from a node `S` to a list of its adjacent nodes `T`.\n+/// Determines whether there exists a path from `source` to `destination`.  The\n+/// graph is defined by the `edges_map`, which maps from a node `S` to a list of\n+/// its adjacent nodes `T`.\n ///\n-/// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n-/// very small graphs. If the graphs become larger, a more efficient graph representation and\n-/// algorithm would probably be advised.\n-#[cfg(stage0)]\n-pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n-                       destination: T) -> bool\n-    where S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>,\n-          T: Hash<<S as HashState>::Hasher> + Eq + Clone,\n-{\n-    if source == destination {\n-        return true;\n-    }\n-\n-    // Do a little breadth-first-search here.  The `queue` list\n-    // doubles as a way to detect if we've seen a particular FR\n-    // before.  Note that we expect this graph to be an *extremely\n-    // shallow* tree.\n-    let mut queue = vec!(source);\n-    let mut i = 0;\n-    while i < queue.len() {\n-        match edges_map.get(&queue[i]) {\n-            Some(edges) => {\n-                for target in edges {\n-                    if *target == destination {\n-                        return true;\n-                    }\n-\n-                    if !queue.iter().any(|x| x == target) {\n-                        queue.push((*target).clone());\n-                    }\n-                }\n-            }\n-            None => {}\n-        }\n-        i += 1;\n-    }\n-    return false;\n-}\n-/// K: Eq + Hash<S>, V, S, H: Hasher<S>\n-///\n-/// Determines whether there exists a path from `source` to `destination`.  The graph is defined by\n-/// the `edges_map`, which maps from a node `S` to a list of its adjacent nodes `T`.\n-///\n-/// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n-/// very small graphs. If the graphs become larger, a more efficient graph representation and\n-/// algorithm would probably be advised.\n-#[cfg(not(stage0))]\n+/// Efficiency note: This is implemented in an inefficient way because it is\n+/// typically invoked on very small graphs. If the graphs become larger, a more\n+/// efficient graph representation and algorithm would probably be advised.\n pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n                        destination: T) -> bool\n     where S: HashState, T: Hash + Eq + Clone,\n@@ -250,52 +205,6 @@ pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n /// }\n /// ```\n #[inline(always)]\n-#[cfg(stage0)]\n-pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n-    where T: Clone + Hash<<S as HashState>::Hasher> + Eq,\n-          U: Clone,\n-          S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>,\n-          F: FnOnce(T) -> U,\n-{\n-    let key = arg.clone();\n-    let result = cache.borrow().get(&key).cloned();\n-    match result {\n-        Some(result) => result,\n-        None => {\n-            let result = f(arg);\n-            cache.borrow_mut().insert(key, result.clone());\n-            result\n-        }\n-    }\n-}\n-/// Memoizes a one-argument closure using the given RefCell containing\n-/// a type implementing MutableMap to serve as a cache.\n-///\n-/// In the future the signature of this function is expected to be:\n-/// ```\n-/// pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n-///    cache: &RefCell<M>,\n-///    f: &|T| -> U\n-/// ) -> impl |T| -> U {\n-/// ```\n-/// but currently it is not possible.\n-///\n-/// # Example\n-/// ```\n-/// struct Context {\n-///    cache: RefCell<HashMap<uint, uint>>\n-/// }\n-///\n-/// fn factorial(ctxt: &Context, n: uint) -> uint {\n-///     memoized(&ctxt.cache, n, |n| match n {\n-///         0 | 1 => n,\n-///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)\n-///     })\n-/// }\n-/// ```\n-#[inline(always)]\n-#[cfg(not(stage0))]\n pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n     where T: Clone + Hash + Eq,\n           U: Clone,"}, {"sha": "b15da7dab3ee606627f78d4d53618fa47e55dfd8", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -16,7 +16,6 @@ use std::collections::hash_state::{DefaultState};\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n use std::hash::{Hasher, Hash};\n-#[cfg(stage0)] use std::hash::Writer;\n use syntax::ast;\n \n pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n@@ -28,19 +27,9 @@ pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n pub type NodeSet = FnvHashSet<ast::NodeId>;\n pub type DefIdSet = FnvHashSet<ast::DefId>;\n \n-#[cfg(stage0)]\n-pub fn FnvHashMap<K: Hash<FnvHasher> + Eq, V>() -> FnvHashMap<K, V> {\n-    Default::default()\n-}\n-#[cfg(stage0)]\n-pub fn FnvHashSet<V: Hash<FnvHasher> + Eq>() -> FnvHashSet<V> {\n-    Default::default()\n-}\n-#[cfg(not(stage0))]\n pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n     Default::default()\n }\n-#[cfg(not(stage0))]\n pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n     Default::default()\n }\n@@ -63,26 +52,6 @@ impl Default for FnvHasher {\n     fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n }\n \n-#[cfg(stage0)]\n-impl Hasher for FnvHasher {\n-    type Output = u64;\n-    fn reset(&mut self) { *self = Default::default(); }\n-    fn finish(&self) -> u64 { self.0 }\n-}\n-\n-#[cfg(stage0)]\n-impl Writer for FnvHasher {\n-    fn write(&mut self, bytes: &[u8]) {\n-        let FnvHasher(mut hash) = *self;\n-        for byte in bytes {\n-            hash = hash ^ (*byte as u64);\n-            hash = hash * 0x100000001b3;\n-        }\n-        *self = FnvHasher(hash);\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Hasher for FnvHasher {\n     fn write(&mut self, bytes: &[u8]) {\n         let FnvHasher(mut hash) = *self;"}, {"sha": "23b63bc26657c6519e0ed39b295ec09f0d33e019", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -29,7 +29,6 @@ use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use std::collections::hash_state::HashState;\n use std::hash::Hash;\n-#[cfg(stage0)] use std::hash::Hasher;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast_map;\n@@ -58,12 +57,12 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            &format!(\"{}{}{}\", prefix, *str, suffix)[]);\n+            &format!(\"{}{}{}\", prefix, *str, suffix));\n         Some(span)\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            &format!(\"{}{}{}\", prefix, *str, suffix)[]);\n+            &format!(\"{}{}{}\", prefix, *str, suffix));\n         None\n       }\n     }\n@@ -274,7 +273,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(&format!(\"extern {} \", abi.to_string())[]);\n+            s.push_str(&format!(\"extern {} \", abi.to_string()));\n         };\n \n         s.push_str(\"fn\");\n@@ -330,7 +329,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(&ty_to_string(cx, t)[]);\n+                   s.push_str(&ty_to_string(cx, t));\n                 }\n             }\n             ty::FnDiverging => {\n@@ -367,7 +366,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, *r);\n-            buf.push_str(&mt_to_string(cx, tm)[]);\n+            buf.push_str(&mt_to_string(cx, tm));\n             buf\n         }\n         ty_open(typ) =>\n@@ -561,7 +560,7 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n                     &strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n                 } else {\n-                    &strs[0][]\n+                    &strs[0][..]\n                 },\n                 tail)\n     } else if strs.len() > 0 {\n@@ -1434,23 +1433,6 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n-    where K: Hash<<S as HashState>::Hasher> + Eq + Repr<'tcx>,\n-          V: Repr<'tcx>,\n-          S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>,\n-{\n-    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"HashMap({})\",\n-                self.iter()\n-                    .map(|(k,v)| format!(\"{} => {}\", k.repr(tcx), v.repr(tcx)))\n-                    .collect::<Vec<String>>()\n-                    .connect(\", \"))\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n     where K: Hash + Eq + Repr<'tcx>,\n           V: Repr<'tcx>,"}, {"sha": "6bf745315eace71965a8d3ea4b47e71a07557b02", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -73,19 +73,19 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status)[]);\n+                handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n                 handler.note(&format!(\"stdout ---\\n{}\",\n-                                  str::from_utf8(&o.output[]).unwrap())[]);\n+                                  str::from_utf8(&o.output).unwrap()));\n                 handler.note(&format!(\"stderr ---\\n{}\",\n-                                  str::from_utf8(&o.error[]).unwrap())\n-                             []);\n+                                  str::from_utf8(&o.error).unwrap())\n+                             );\n                 handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n             handler.err(&format!(\"could not exec `{}`: {}\", &ar[..],\n-                             e)[]);\n+                             e));\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -110,7 +110,7 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n     }\n     handler.fatal(&format!(\"could not find native static library `{}`, \\\n                            perhaps an -L flag is missing?\",\n-                          name)[]);\n+                          name));\n }\n \n impl<'a> Archive<'a> {\n@@ -142,7 +142,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(&output.output[]).unwrap();\n+        let output = str::from_utf8(&output.output).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -174,9 +174,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> old_io::IoResult<()> {\n         let location = find_library(name,\n-                                    &self.archive.slib_prefix[],\n-                                    &self.archive.slib_suffix[],\n-                                    &self.archive.lib_search_paths[],\n+                                    &self.archive.slib_prefix,\n+                                    &self.archive.slib_suffix,\n+                                    &self.archive.lib_search_paths,\n                                     self.archive.handler);\n         self.add_archive(&location, name, |_| false)\n     }"}, {"sha": "3f2dcee5110951faae02c1ea3481141d5799004a", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -49,7 +49,7 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths {\n-        ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)[]));\n+        ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)));\n     }\n     return ret;\n }"}, {"sha": "2fc43ab26b58ef328699c5a295df5386f79f982f", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -64,7 +64,7 @@ impl Svh {\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        &self.hash[]\n+        &self.hash\n     }\n \n     pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n@@ -329,7 +329,7 @@ mod svh_visitor {\n             // macro invocations, namely macro_rules definitions,\n             // *can* appear as items, even in the expanded crate AST.\n \n-            if &macro_name(mac)[] == \"macro_rules\" {\n+            if &macro_name(mac)[..] == \"macro_rules\" {\n                 // Pretty-printing definition to a string strips out\n                 // surface artifacts (currently), such as the span\n                 // information, yielding a content-based hash.\n@@ -356,7 +356,7 @@ mod svh_visitor {\n             fn macro_name(mac: &Mac) -> token::InternedString {\n                 match &mac.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = &path.segments[];\n+                        let s = &path.segments;\n                         assert_eq!(s.len(), 1);\n                         content(s[0].identifier)\n                     }"}, {"sha": "b04c07977c369be1dfb38233a13ef98d5fa1305f", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -239,7 +239,7 @@ impl Target {\n                      .and_then(|os| os.map(|s| s.to_string())) {\n                 Some(val) => val,\n                 None =>\n-                    handler.fatal(&format!(\"Field {} in target specification is required\", name)[])\n+                    handler.fatal(&format!(\"Field {} in target specification is required\", name))\n             }\n         };\n "}, {"sha": "23ca5b636815b0ae8512de888a10f3bd1a25947f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -466,23 +466,23 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         new_loan.span,\n                         &format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                nl, new_loan_msg)[])\n+                                nl, new_loan_msg))\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         &format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg)[]);\n+                                nl, ol_pronoun, old_loan_msg));\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         &format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str())[]);\n+                                nl, new_loan_msg, new_loan.kind.to_user_str()));\n                 }\n \n                 (_, _) => {\n@@ -495,7 +495,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                 new_loan.kind.to_user_str(),\n                                 ol_pronoun,\n                                 old_loan.kind.to_user_str(),\n-                                old_loan_msg)[]);\n+                                old_loan_msg));\n                 }\n             }\n \n@@ -504,7 +504,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_note(\n                         span,\n                         &format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl)[]);\n+                                nl));\n                 }\n                 _ => { }\n             }\n@@ -553,7 +553,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                &format!(\"{}; {}\", borrow_summary, rule_summary)[]);\n+                &format!(\"{}; {}\", borrow_summary, rule_summary));\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n@@ -623,13 +623,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.bccx.span_err(\n                     span,\n                     &format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            &self.bccx.loan_path_to_string(copy_path)[])\n-                    []);\n+                            &self.bccx.loan_path_to_string(copy_path))\n+                    );\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n-                            &self.bccx.loan_path_to_string(&*loan_path)[])\n-                    []);\n+                            &self.bccx.loan_path_to_string(&*loan_path))\n+                    );\n             }\n         }\n     }\n@@ -648,20 +648,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                &self.bccx.loan_path_to_string(move_path)[]),\n+                                &self.bccx.loan_path_to_string(move_path)),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                &self.bccx.loan_path_to_string(move_path)[])\n+                                &self.bccx.loan_path_to_string(move_path))\n                 };\n \n                 self.bccx.span_err(span, &err_message[..]);\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n-                            &self.bccx.loan_path_to_string(&*loan_path)[])\n-                    []);\n+                            &self.bccx.loan_path_to_string(&*loan_path))\n+                    );\n             }\n         }\n     }\n@@ -842,7 +842,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_err(\n                         assignment_span,\n                         &format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)));\n                     self.bccx.span_help(\n                         self.tcx().map.span(upvar_id.closure_expr_id),\n                         \"consider changing this closure to take self by mutable reference\");\n@@ -851,7 +851,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span,\n                         &format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)));\n                 }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n@@ -861,14 +861,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         &format!(\"cannot assign to {} {} `{}`\",\n                                 assignee_cmt.mutbl.to_user_str(),\n                                 self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp))[]);\n+                                self.bccx.loan_path_to_string(&*lp)));\n                 }\n                 None => {\n                     self.bccx.span_err(\n                         assignment_span,\n                         &format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)));\n                 }\n             }\n         }\n@@ -988,10 +988,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         self.bccx.span_err(\n             span,\n             &format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path))[]);\n+                    self.bccx.loan_path_to_string(loan_path)));\n         self.bccx.span_note(\n             loan.span,\n             &format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path))[]);\n+                    self.bccx.loan_path_to_string(loan_path)));\n     }\n }"}, {"sha": "41ccee4f8fbf0bd21b5449c01519dd56c7468922", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -123,12 +123,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         let attrs : &[ast::Attribute];\n         attrs = match tcx.map.find(id) {\n             Some(ast_map::NodeItem(ref item)) =>\n-                &item.attrs[],\n+                &item.attrs,\n             Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                &m.attrs[],\n+                &m.attrs,\n             Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                &m.attrs[],\n-            _ => &[][],\n+                &m.attrs,\n+            _ => &[],\n         };\n \n         let span_err =\n@@ -144,7 +144,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let render = || this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render())[]);\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -156,7 +156,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, f) in vec_rc.iter().enumerate() {\n             let render = || f.loan_path_user_string(this, tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render())[]);\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());"}, {"sha": "333aef81390bfe892370c5770ee50a121f55ffc7", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -307,7 +307,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             &format!(\"invalid borrow lifetime: {:?}\",\n-                                    loan_region)[]);\n+                                    loan_region));\n                     }\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);"}, {"sha": "53761eb14713def82f45a671a5a2dc45a3f6daab", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -121,7 +121,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_static_item => {\n             bccx.span_err(move_from.span,\n                           &format!(\"cannot move out of {}\",\n-                                  move_from.descriptive_string(bccx.tcx))[]);\n+                                  move_from.descriptive_string(bccx.tcx)));\n         }\n \n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n@@ -130,7 +130,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 bccx.span_err(move_from.span,\n                               &format!(\"cannot move out of type `{}`, \\\n                                         a non-copy fixed-size array\",\n-                                       b.ty.user_string(bccx.tcx))[]);\n+                                       b.ty.user_string(bccx.tcx)));\n             }\n         }\n \n@@ -143,7 +143,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx))[]);\n+                                b.ty.user_string(bccx.tcx)));\n                 },\n                 _ => {\n                     bccx.span_bug(move_from.span, \"this path should not cause illegal move\")\n@@ -170,10 +170,10 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             &format!(\"to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference\",\n-                    pat_name)[]);\n+                    pat_name));\n     } else {\n         bccx.span_note(move_to_span,\n                        &format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name)[]);\n+                               pat_name));\n     }\n }"}, {"sha": "dfd98881ace86afc38a1b2f38cc29ad9fd6d638c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -524,7 +524,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n-            &self.bckerr_to_string(&err)[]);\n+            &self.bckerr_to_string(&err));\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -546,7 +546,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     use_span,\n                     &format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_string(lp))[]);\n+                            self.loan_path_to_string(lp)));\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     &format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             msg,\n-                            nl)[]);\n+                            nl));\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -607,7 +607,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(&format!(\"MoveExpr({}) maps to \\\n                                                    {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r)[])\n+                                                  r))\n                     }\n                 };\n                 let (suggestion, _) =\n@@ -618,7 +618,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion)[]);\n+                            suggestion));\n             }\n \n             move_data::MovePat => {\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx))[]);\n+                            pat_ty.user_string(self.tcx)));\n                 self.tcx.sess.span_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -645,7 +645,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(&format!(\"Captured({}) maps to \\\n                                                    {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r)[])\n+                                                  r))\n                     }\n                 };\n                 let (suggestion, help) =\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion)[]);\n+                            suggestion));\n                 self.tcx.sess.span_help(expr_span, help);\n             }\n         }\n@@ -704,7 +704,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(\n             span,\n             &format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp))[]);\n+                    self.loan_path_to_string(lp)));\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -825,7 +825,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     &format!(\"{} in an aliasable location\",\n-                             prefix)[]);\n+                             prefix));\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n@@ -847,12 +847,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    &format!(\"{} in a static location\", prefix)[]);\n+                    &format!(\"{} in a static location\", prefix));\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    &format!(\"{} in a `&` reference\", prefix)[]);\n+                    &format!(\"{} in a `&` reference\", prefix));\n             }\n         }\n \n@@ -920,12 +920,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 note_and_explain_region(\n                     self.tcx,\n                     &format!(\"{} would have to be valid for \",\n-                            descr)[],\n+                            descr),\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    &format!(\"...but {} is only valid for \", descr)[],\n+                    &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n                     \"\");\n             }\n@@ -945,7 +945,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&ty::item_path_str(self.tcx, variant_def_id)[]);\n+                out.push_str(&ty::item_path_str(self.tcx, variant_def_id));\n                 out.push(')');\n             }\n \n@@ -959,7 +959,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');\n-                        out.push_str(&idx.to_string()[]);\n+                        out.push_str(&idx.to_string());\n                     }\n                 }\n             }\n@@ -991,7 +991,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(&ty::item_path_str(self.tcx, variant_def_id)[]);\n+                out.push_str(&ty::item_path_str(self.tcx, variant_def_id));\n                 out.push(')');\n             }\n "}, {"sha": "4465000d8d81e1298111ca0129d58034aa96e98b", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");\n-            sets.push_str(&self.dataflow_for_variant(e, n, variant)[]);\n+            sets.push_str(&self.dataflow_for_variant(e, n, variant));\n         }\n         sets\n     }"}, {"sha": "b12f05d7c50f75b527322f2a4af9c7b9d41101eb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -77,10 +77,10 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n-                                                 &krate.attrs[],\n+                                                 &krate.attrs,\n                                                  &sess);\n             let id = link::find_crate_name(Some(&sess),\n-                                           &krate.attrs[],\n+                                           &krate.attrs,\n                                            input);\n             let expanded_crate\n                 = match phase_2_configure_and_expand(&sess,\n@@ -112,6 +112,7 @@ pub fn compile_input(sess: Session,\n                                                                      &sess,\n                                                                      outdir,\n                                                                      &ast_map,\n+                                                                     &ast_map.krate(),\n                                                                      &id[..]));\n \n         let analysis = phase_3_run_analysis_passes(sess,\n@@ -287,26 +288,28 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                               session: &'a Session,\n                               out_dir: &'a Option<Path>,\n                               ast_map: &'a ast_map::Map<'ast>,\n+                              expanded_crate: &'a ast::Crate,\n                               crate_name: &'a str)\n                               -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n             ast_map: Some(ast_map),\n+            expanded_crate: Some(expanded_crate),\n             .. CompileState::empty(input, session, out_dir)\n         }\n     }\n \n     fn state_after_analysis(input: &'a Input,\n                             session: &'a Session,\n                             out_dir: &'a Option<Path>,\n-                            krate: &'a ast::Crate,\n+                            expanded_crate: &'a ast::Crate,\n                             analysis: &'a ty::CrateAnalysis<'tcx>,\n                             tcx: &'a ty::ctxt<'tcx>)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n             tcx: Some(tcx),\n-            krate: Some(krate),\n+            expanded_crate: Some(expanded_crate),\n             .. CompileState::empty(input, session, out_dir)\n         }\n     }\n@@ -375,9 +378,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, &krate.attrs[]);\n+        collect_crate_types(sess, &krate.attrs);\n     *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, &krate.attrs[]);\n+        collect_crate_metadata(sess, &krate.attrs);\n \n     time(time_passes, \"recursion limit\", (), |_| {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -721,7 +724,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             write::run_passes(sess,\n                               trans,\n-                              &sess.opts.output_types[],\n+                              &sess.opts.output_types,\n                               outputs));\n     }\n \n@@ -742,7 +745,7 @@ pub fn phase_6_link_output(sess: &Session,\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           &trans.link.crate_name[]));\n+                           &trans.link.crate_name));\n \n     env::set_var(\"PATH\", &old_path);\n }\n@@ -796,7 +799,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| escape_dep_filename(&fmap.name[]))\n+                                   .map(|fmap| escape_dep_filename(&fmap.name))\n                                    .collect();\n         let mut file = try!(old_io::File::create(&deps_filename));\n         for path in &out_filenames {\n@@ -810,7 +813,7 @@ fn write_out_deps(sess: &Session,\n         Ok(()) => {}\n         Err(e) => {\n             sess.fatal(&format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e)[]);\n+                               deps_filename.display(), e));\n         }\n     }\n }\n@@ -881,7 +884,7 @@ pub fn collect_crate_types(session: &Session,\n         if !res {\n             session.warn(&format!(\"dropping unsupported crate type `{}` \\\n                                    for target `{}`\",\n-                                 *crate_type, session.opts.target_triple)[]);\n+                                 *crate_type, session.opts.target_triple));\n         }\n \n         res"}, {"sha": "0fbfeb831850f2d7dc9e4e37cb081899ac5c4029", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -124,7 +124,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let sopts = config::build_session_options(&matches);\n \n     let (odir, ofile) = make_output(&matches);\n-    let (input, input_file_path) = match make_input(&matches.free[]) {\n+    let (input, input_file_path) = match make_input(&matches.free) {\n         Some((input, input_file_path)) => callbacks.some_input(input, input_file_path),\n         None => match callbacks.no_input(&matches, &sopts, &odir, &ofile, &descriptions) {\n             Some((input, input_file_path)) => (input, input_file_path),\n@@ -166,7 +166,7 @@ fn make_output(matches: &getopts::Matches) -> (Option<Path>, Option<Path>) {\n // Extract input (string or file and optional path) from matches.\n fn make_input(free_matches: &[String]) -> Option<(Input, Option<Path>)> {\n     if free_matches.len() == 1 {\n-        let ifile = &free_matches[0][];\n+        let ifile = &free_matches[0][..];\n         if ifile == \"-\" {\n             let contents = old_io::stdin().read_to_end().unwrap();\n             let src = String::from_utf8(contents).unwrap();\n@@ -277,7 +277,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                         println!(\"{}\", description);\n                     }\n                     None => {\n-                        early_error(&format!(\"no extended information for {}\", code)[]);\n+                        early_error(&format!(\"no extended information for {}\", code));\n                     }\n                 }\n                 return Compilation::Stop;\n@@ -373,11 +373,13 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n \n         if sess.opts.debugging_opts.save_analysis {\n             control.after_analysis.callback = box |state| {\n-                time(state.session.time_passes(), \"save analysis\", state.krate.unwrap(), |krate|\n-                     save::process_crate(state.session,\n-                                         krate,\n-                                         state.analysis.unwrap(),\n-                                         state.out_dir));\n+                time(state.session.time_passes(),\n+                     \"save analysis\",\n+                     state.expanded_crate.unwrap(),\n+                     |krate| save::process_crate(state.session,\n+                                                 krate,\n+                                                 state.analysis.unwrap(),\n+                                                 state.out_dir));\n             };\n             control.make_glob_map = resolve::MakeGlobMap::Yes;\n         }\n@@ -678,7 +680,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(&args[..], &config::optgroups()[]) {\n+        match getopts::getopts(&args[..], &config::optgroups()) {\n             Ok(m) => m,\n             Err(f_stable_attempt) => {\n                 // redo option parsing, including unstable options this time,\n@@ -811,7 +813,7 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n                     Err(e) => {\n                         emitter.emit(None,\n                                      &format!(\"failed to read internal \\\n-                                              stderr: {}\", e)[],\n+                                              stderr: {}\", e),\n                                      None,\n                                      diagnostic::Error)\n                     }"}, {"sha": "3f9fdd28e4405acaa10ed21cfdf7c311623670d4", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -312,7 +312,7 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n                 try!(pp::word(&mut s.s,\n                               &ppaux::ty_to_string(\n                                   tcx,\n-                                  ty::expr_ty(tcx, expr))[]));\n+                                  ty::expr_ty(tcx, expr))));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -602,15 +602,15 @@ pub fn pretty_print_input(sess: Session,\n             debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(&format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\")[])\n+                                     unique path suffix (b::c::d)\"))\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n                 sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid)[])\n+                                   nodeid))\n             });\n \n             let code = blocks::Code::from_node(node);"}, {"sha": "eae02e0bf66c4768f78123b2e5f4c5c4125ab1bf", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -712,7 +712,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                              method_id,\n                                              None,\n                                              &format!(\"method `{}`\",\n-                                                     string)[]));\n+                                                     string)));\n     }\n \n     // Checks that a path is in scope.\n@@ -727,7 +727,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   &format!(\"{} `{}`\", tyname, name)[])\n+                                   &format!(\"{} `{}`\", tyname, name))\n             };\n \n             match self.last_private_map[path_id] {"}, {"sha": "3b3106af818b3ea1688298c53b440bdc0da4f141", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -220,14 +220,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.resolve_error(sp,\n                         &format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_name(name))[]);\n+                             token::get_name(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         if let Some(sp) = r {\n                             self.session.span_note(sp,\n                                  &format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name))[]);\n+                                      token::get_name(name)));\n                         }\n                     }\n                 }\n@@ -307,8 +307,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     ViewPathSimple(binding, ref full_path) => {\n                         let source_name =\n                             full_path.segments.last().unwrap().identifier.name;\n-                        if &token::get_name(source_name)[] == \"mod\" ||\n-                           &token::get_name(source_name)[] == \"self\" {\n+                        if &token::get_name(source_name)[..] == \"mod\" ||\n+                           &token::get_name(source_name)[..] == \"self\" {\n                             self.resolve_error(view_path.span,\n                                 \"`self` imports are only allowed within a { } list\");\n                         }\n@@ -1192,7 +1192,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n                        self.names_to_string(&module_.imports.borrow().last().unwrap().\n-                                                             module_path[]),\n+                                                             module_path),\n                        token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions"}, {"sha": "062ea885bf40a578a9f763c693c9acd80c5bdbb8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1068,7 +1068,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n                     let msg = format!(\"unresolved import `{}`{}\",\n                                       self.import_path_to_string(\n-                                          &import_directive.module_path[],\n+                                          &import_directive.module_path,\n                                           import_directive.subclass),\n                                       help);\n                     self.resolve_error(span, &msg[..]);\n@@ -2247,7 +2247,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               true) {\n                 Failed(Some((span, msg))) =>\n                     self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                     msg)[]),\n+                                                     msg)),\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -2603,7 +2603,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    &format!(\"unexpected {:?} in bindings\", d)[])\n+                    &format!(\"unexpected {:?} in bindings\", d))\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -2931,7 +2931,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    &struct_def.fields[]);\n+                                    &struct_def.fields);\n             }\n \n             ItemMod(ref module_) => {\n@@ -3019,7 +3019,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     parameter in this type \\\n                                                     parameter list\",\n                                                    token::get_name(\n-                                                       name))[])\n+                                                       name)))\n                     }\n                     seen_bindings.insert(name);\n \n@@ -3204,14 +3204,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.resolve_error(trait_reference.path.span,\n                                            &format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                       &trait_reference.path))[]);\n+                                                       &trait_reference.path)));\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n                             self.session.span_note(\n                                 trait_reference.path.span,\n                                 &format!(\"`type` aliases cannot be used for traits\")\n-                                []);\n+                                );\n                         }\n                     }\n                 }\n@@ -3408,7 +3408,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_error(span,\n                                     &format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n-                                            path_str)[]);\n+                                            path_str));\n             }\n         }\n     }\n@@ -3477,7 +3477,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         &format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 token::get_name(key),\n-                                i + 1)[]);\n+                                i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n@@ -3486,7 +3486,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             &format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     token::get_name(key),\n-                                    i + 1)[]);\n+                                    i + 1));\n                     }\n                   }\n                 }\n@@ -3499,7 +3499,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         &format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                \"#\", i + 1, \"#\")[]);\n+                                \"#\", i + 1, \"#\"));\n                 }\n             }\n         }\n@@ -3698,7 +3698,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 &format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed))[]);\n+                                        token::get_name(renamed)));\n                         }\n                         FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -3750,7 +3750,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   [])\n+                                                   )\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n@@ -3759,7 +3759,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     &format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident))[]);\n+                                            token::get_ident(ident)));\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -3883,7 +3883,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match err {\n                     Some((span, msg)) => {\n                         self.resolve_error(span, &format!(\"failed to resolve: {}\",\n-                                                         msg)[]);\n+                                                         msg));\n                     }\n                     None => ()\n                 }\n@@ -4093,7 +4093,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg)[]);\n+                                                 msg));\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -4152,7 +4152,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg)[]);\n+                                                 msg));\n                 return None;\n             }\n \n@@ -4193,7 +4193,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(&self.type_ribs[], name, span)\n+                self.search_ribs(&self.type_ribs, name, span)\n             }\n         };\n \n@@ -4248,7 +4248,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match err {\n                     Some((span, msg)) =>\n                         self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                         msg)[]),\n+                                                         msg)),\n                     None => ()\n                 }\n \n@@ -4410,7 +4410,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             values[smallest] != usize::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n-            name != &maybes[smallest][] {\n+            name != &maybes[smallest][..] {\n \n             Some(maybes[smallest].to_string())\n \n@@ -4502,7 +4502,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     false // Stop advancing\n                                 });\n \n-                                if method_scope && &token::get_name(self.self_name)[]\n+                                if method_scope && &token::get_name(self.self_name)[..]\n                                                                    == path_name {\n                                         self.resolve_error(\n                                             expr.span,\n@@ -4592,7 +4592,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.resolve_error(\n                             expr.span,\n                             &format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label))[])\n+                                    token::get_ident(label)))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -4731,7 +4731,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   then {:?}\",\n                                  node_id,\n                                  *entry.get(),\n-                                 def)[]);\n+                                 def));\n             },\n             Vacant(entry) => { entry.insert(def); },\n         }\n@@ -4747,7 +4747,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_error(pat.span,\n                                    &format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr)[]);\n+                                           descr));\n             }\n         }\n     }\n@@ -4783,7 +4783,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return \"???\".to_string();\n         }\n         self.names_to_string(&names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>()[])\n+                                  .collect::<Vec<ast::Name>>())\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "ea5001aa814b49ab5dab7f8be7c047e8f6456498", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -191,17 +191,17 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(&link_meta.crate_name[]);\n+    symbol_hasher.input_str(&link_meta.crate_name);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in &*tcx.sess.crate_metadata.borrow() {\n         symbol_hasher.input_str(&meta[..]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(&encoder::encoded_ty(tcx, t)[]);\n+    symbol_hasher.input_str(&encoder::encoded_ty(tcx, t));\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from_str(\"h\");\n-    hash.push_str(&truncated_hash_result(symbol_hasher)[]);\n+    hash.push_str(&truncated_hash_result(symbol_hasher));\n     hash\n }\n \n@@ -288,7 +288,7 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n \n     fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(&format!(\"{}{}\", sani.len(), sani)[]);\n+        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n     }\n \n     // First, connect each component with <len, name> pairs.\n@@ -361,7 +361,7 @@ pub fn remove(sess: &Session, path: &Path) {\n         Err(e) => {\n             sess.err(&format!(\"failed to remove {}: {}\",\n                              path.display(),\n-                             e)[]);\n+                             e));\n         }\n     }\n }\n@@ -376,7 +376,7 @@ pub fn link_binary(sess: &Session,\n     for &crate_type in &*sess.crate_types.borrow() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(&format!(\"invalid output type `{:?}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple)[]);\n+                             crate_type, sess.opts.target_triple));\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -441,8 +441,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = (&sess.target.target.options.dll_prefix[],\n-                                    &sess.target.target.options.dll_suffix[]);\n+            let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n+                                    &sess.target.target.options.dll_suffix);\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -452,7 +452,7 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            let suffix = &sess.target.target.options.exe_suffix[];\n+            let suffix = &sess.target.target.options.exe_suffix;\n             out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n@@ -481,12 +481,12 @@ fn link_binary_output(sess: &Session,\n     if !out_is_writeable {\n         sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n                             permissions.\",\n-                           out_filename.display())[]);\n+                           out_filename.display()));\n     }\n     else if !obj_is_writeable {\n         sess.fatal(&format!(\"object file {} is not writeable -- check its \\\n                             permissions.\",\n-                           obj_filename.display())[]);\n+                           obj_filename.display()));\n     }\n \n     match crate_type {\n@@ -588,12 +588,12 @@ fn link_rlib<'a>(sess: &'a Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write_all(&trans.metadata[]) {\n+            match fs::File::create(&metadata).write_all(&trans.metadata) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(&format!(\"failed to write {}: {}\",\n                                      metadata.display(),\n-                                     e)[]);\n+                                     e));\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -611,25 +611,25 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // was exactly 16 bytes.\n                 let bc_filename = obj_filename.with_extension(&format!(\"{}.bc\", i));\n                 let bc_deflated_filename = obj_filename.with_extension(\n-                    &format!(\"{}.bytecode.deflate\", i)[]);\n+                    &format!(\"{}.bytecode.deflate\", i));\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n                     Err(e) => sess.fatal(&format!(\"failed to read bytecode: {}\",\n-                                                 e)[])\n+                                                 e))\n                 };\n \n                 let bc_data_deflated = match flate::deflate_bytes(&bc_data[..]) {\n                     Some(compressed) => compressed,\n                     None => sess.fatal(&format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display())[])\n+                                               bc_filename.display()))\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n                         sess.fatal(&format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e)[])\n+                                            file: {}\", e))\n                     }\n                 };\n \n@@ -638,7 +638,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     Ok(()) => {}\n                     Err(e) => {\n                         sess.err(&format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e)[]);\n+                                          {}\", e));\n                         sess.abort_if_errors()\n                     }\n                 };\n@@ -729,7 +729,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(&format!(\"could not find rlib for: `{}`\",\n-                                 name)[]);\n+                                 name));\n                 continue\n             }\n         };\n@@ -755,7 +755,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             cstore::NativeUnknown => \"library\",\n             cstore::NativeFramework => \"framework\",\n         };\n-        sess.note(&format!(\"{}: {}\", name, *lib)[]);\n+        sess.note(&format!(\"{}: {}\", name, *lib));\n     }\n }\n \n@@ -771,10 +771,10 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     let pname = get_cc_prog(sess);\n     let mut cmd = Command::new(&pname[..]);\n \n-    cmd.args(&sess.target.target.options.pre_link_args[]);\n+    cmd.args(&sess.target.target.options.pre_link_args);\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(&sess.target.target.options.post_link_args[]);\n+    cmd.args(&sess.target.target.options.post_link_args);\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n@@ -794,10 +794,10 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             if !prog.status.success() {\n                 sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status)[]);\n-                sess.note(&format!(\"{:?}\", &cmd)[]);\n+                                 prog.status));\n+                sess.note(&format!(\"{:?}\", &cmd));\n                 let mut output = prog.error.clone();\n-                output.push_all(&prog.output[]);\n+                output.push_all(&prog.output);\n                 sess.note(str::from_utf8(&output[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n@@ -807,7 +807,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         Err(e) => {\n             sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e)[]);\n+                             e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -819,7 +819,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(&format!(\"failed to run dsymutil: {}\", e)[]);\n+                sess.err(&format!(\"failed to run dsymutil: {}\", e));\n                 sess.abort_if_errors();\n             }\n         }\n@@ -1005,7 +1005,7 @@ fn link_args(cmd: &mut Command,\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n-        let target_triple = &sess.opts.target_triple[];\n+        let target_triple = &sess.opts.target_triple;\n         let get_install_prefix_lib_path = || {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -1022,13 +1022,13 @@ fn link_args(cmd: &mut Command,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n-        cmd.args(&rpath::get_rpath_flags(rpath_config)[]);\n+        cmd.args(&rpath::get_rpath_flags(rpath_config));\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n-    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n+    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty));\n     cmd.args(&used_link_args[..]);\n }\n \n@@ -1189,7 +1189,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n             let name = cratepath.filename_str().unwrap();\n             let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n             time(sess.time_passes(),\n-                 &format!(\"altering {}.rlib\", name)[],\n+                 &format!(\"altering {}.rlib\", name),\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n@@ -1198,7 +1198,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.err(&format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e)[]);\n+                                         e));\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1210,7 +1210,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     Err(e) => {\n                         sess.err(&format!(\"failed to chmod {} when preparing \\\n                                           for LTO: {}\", dst.display(),\n-                                         e)[]);\n+                                         e));\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1224,9 +1224,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n-                archive.remove_file(&format!(\"{}.o\", name)[]);\n+                archive.remove_file(&format!(\"{}.o\", name));\n                 let files = archive.files();\n-                if files.iter().any(|s| s[].ends_with(\".o\")) {\n+                if files.iter().any(|s| s.ends_with(\".o\")) {\n                     cmd.arg(dst);\n                 }\n             });"}, {"sha": "9507da2febbdb235f04b87a961eecd8722e06b32", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -54,7 +54,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             Some(p) => p,\n             None => {\n                 sess.fatal(&format!(\"could not find rlib for: `{}`\",\n-                                   name)[]);\n+                                   name));\n             }\n         };\n \n@@ -68,15 +68,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                                   (),\n                                   |_| {\n                                       archive.read(&format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i)[])\n+                                                           file, i))\n                                   });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n                     if i == 0 {\n                         // No bitcode was found at all.\n                         sess.fatal(&format!(\"missing compressed bytecode in {}\",\n-                                           path.display())[]);\n+                                           path.display()));\n                     }\n                     // No more bitcode files to read.\n                     break;\n@@ -99,12 +99,12 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                             Some(inflated) => inflated,\n                             None => {\n                                 sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n-                                                   name)[])\n+                                                   name))\n                             }\n                         }\n                     } else {\n                         sess.fatal(&format!(\"Unsupported bytecode format version {}\",\n-                                           version)[])\n+                                           version))\n                     }\n                 })\n             } else {\n@@ -115,7 +115,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         Some(bc) => bc,\n                         None => {\n                             sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n-                                               name)[])\n+                                               name))\n                         }\n                     }\n                 })\n@@ -124,7 +124,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let ptr = bc_decoded.as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),\n-                 &format!(\"ll link {}.{}\", name, i)[],\n+                 &format!(\"ll link {}.{}\", name, i),\n                  (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,"}, {"sha": "a1fc63778ce8af858a5bda6b5a935b2c7fa81571", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -54,7 +54,7 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n             libc::free(cstr as *mut _);\n             handler.fatal(&format!(\"{}: {}\",\n                                   &msg[..],\n-                                  &err[..])[]);\n+                                  &err[..]));\n         }\n     }\n }\n@@ -104,13 +104,13 @@ impl SharedEmitter {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n-                                           &diag.msg[],\n+                                           &diag.msg,\n                                            &code[..],\n                                            diag.lvl);\n                 },\n                 None => {\n                     handler.emit(None,\n-                                 &diag.msg[],\n+                                 &diag.msg,\n                                  diag.lvl);\n                 },\n             }\n@@ -166,7 +166,7 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n         Some(ref s) => &s[..],\n-        None => &sess.target.target.options.relocation_model[]\n+        None => &sess.target.target.options.relocation_model[..],\n     };\n     let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n@@ -177,7 +177,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(&format!(\"{:?} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n-                                 .relocation_model)[]);\n+                                 .relocation_model));\n             sess.abort_if_errors();\n             unreachable!();\n         }\n@@ -199,7 +199,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n \n     let code_model_arg = match sess.opts.cg.code_model {\n         Some(ref s) => &s[..],\n-        None => &sess.target.target.options.code_model[]\n+        None => &sess.target.target.options.code_model[..],\n     };\n \n     let code_model = match code_model_arg {\n@@ -212,13 +212,13 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(&format!(\"{:?} is not a valid code model\",\n                              sess.opts\n                                  .cg\n-                                 .code_model)[]);\n+                                 .code_model));\n             sess.abort_if_errors();\n             unreachable!();\n         }\n     };\n \n-    let triple = &sess.target.target.llvm_target[];\n+    let triple = &sess.target.target.llvm_target;\n \n     let tm = unsafe {\n         let triple = CString::new(triple.as_bytes()).unwrap();\n@@ -526,14 +526,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(&format!(\"{}.s\", name_extra)[]);\n+            let path = output_names.with_extension(&format!(\"{}.s\", name_extra));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n-            let path = output_names.with_extension(&format!(\"{}.o\", name_extra)[]);\n+            let path = output_names.with_extension(&format!(\"{}.o\", name_extra));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n@@ -647,7 +647,7 @@ pub fn run_passes(sess: &Session,\n \n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n-        run_work_singlethreaded(sess, &trans.reachable[], work_items);\n+        run_work_singlethreaded(sess, &trans.reachable, work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n     }\n@@ -679,7 +679,7 @@ pub fn run_passes(sess: &Session,\n                 // 2) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n                 sess.warn(&format!(\"ignoring -o because multiple .{} files were produced\",\n-                                  ext)[]);\n+                                  ext));\n             } else {\n                 // 3) Multiple codegen units, but no `-o some_name`.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -713,18 +713,18 @@ pub fn run_passes(sess: &Session,\n         let pname = get_cc_prog(sess);\n         let mut cmd = Command::new(&pname[..]);\n \n-        cmd.args(&sess.target.target.options.pre_link_args[]);\n+        cmd.args(&sess.target.target.options.pre_link_args);\n         cmd.arg(\"-nostdlib\");\n \n         for index in 0..trans.modules.len() {\n-            cmd.arg(crate_output.with_extension(&format!(\"{}.o\", index)[]));\n+            cmd.arg(crate_output.with_extension(&format!(\"{}.o\", index)));\n         }\n \n         cmd.arg(\"-r\")\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n-        cmd.args(&sess.target.target.options.post_link_args[]);\n+        cmd.args(&sess.target.target.options.post_link_args);\n \n         if sess.opts.debugging_opts.print_link_args {\n             println!(\"{:?}\", &cmd);\n@@ -737,14 +737,14 @@ pub fn run_passes(sess: &Session,\n             Ok(status) => {\n                 if !status.success() {\n                     sess.err(&format!(\"linking of {} with `{:?}` failed\",\n-                                     output_path.display(), cmd)[]);\n+                                     output_path.display(), cmd));\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n                 sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                                  pname,\n-                                 e)[]);\n+                                 e));\n                 sess.abort_if_errors();\n             },\n         }\n@@ -971,18 +971,18 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n             if !prog.status.success() {\n                 sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status)[]);\n-                sess.note(&format!(\"{:?}\", &cmd)[]);\n+                                 prog.status));\n+                sess.note(&format!(\"{:?}\", &cmd));\n                 let mut note = prog.error.clone();\n-                note.push_all(&prog.output[]);\n+                note.push_all(&prog.output);\n                 sess.note(str::from_utf8(&note[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n             sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e)[]);\n+                             e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1018,7 +1018,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.target.target.arch == \"aarch64\" { add(\"-fast-isel=0\"); }\n \n         for arg in &sess.opts.cg.llvm_args {\n-            add(&(*arg)[]);\n+            add(&(*arg));\n         }\n     }\n "}, {"sha": "28dcbe3ae86b27477e9f9cfc4497c82165e25cf1", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -94,7 +94,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, &cmd.name[], n);\n+            self.fmt.external_crate_str(krate.span, &cmd.name, n);\n         });\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -216,7 +216,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id)[]);\n+                                  ref_id));\n         }\n         let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n@@ -229,7 +229,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id)[]);\n+                                             ref_id));\n         }\n         let def = (*def_map)[ref_id];\n         match def {\n@@ -258,7 +258,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n                 self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n-                                                 def)[]);\n+                                                 def));\n             },\n         }\n     }\n@@ -279,7 +279,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    &path_to_string(p)[],\n+                                    &path_to_string(p),\n                                     &typ[..]);\n             }\n             self.collected_paths.clear();\n@@ -302,7 +302,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(&ty_to_string(&**ty)[]);\n+                            result.push_str(&ty_to_string(&**ty));\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n@@ -319,7 +319,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                &format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id)[]);\n+                                                       impl_id.node, method.id));\n                         },\n                     }\n                 },\n@@ -329,7 +329,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                            \"Container {} for method {} is not a node item {:?}\",\n                                            impl_id.node,\n                                            method.id,\n-                                           self.analysis.ty_cx.map.get(impl_id.node))[]);\n+                                           self.analysis.ty_cx.map.get(impl_id.node)));\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n@@ -343,14 +343,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                &format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id)[]);\n+                                                       def_id.node, method.id));\n                         }\n                     }\n                 },\n                 None => {\n                     self.sess.span_bug(method.span,\n                                        &format!(\"Could not find container for method {}\",\n-                                               method.id)[]);\n+                                               method.id));\n                 },\n             },\n         };\n@@ -442,7 +442,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n                                                &format!(\"Could not find sub-span for field {}\",\n-                                                       qualname)[]),\n+                                                       qualname)),\n                 }\n             },\n             _ => (),\n@@ -528,7 +528,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             &get_ident(item.ident),\n                             &qualname[..],\n                             &value[..],\n-                            &ty_to_string(&*typ)[],\n+                            &ty_to_string(&*typ),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -551,7 +551,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             &get_ident(item.ident),\n                             &qualname[..],\n                             \"\",\n-                            &ty_to_string(&*typ)[],\n+                            &ty_to_string(&*typ),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -603,7 +603,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                 &val[..]),\n             None => self.sess.span_bug(item.span,\n                                        &format!(\"Could not find subspan for enum {}\",\n-                                               enum_name)[]),\n+                                               enum_name)),\n         }\n         for variant in &enum_definition.variants {\n             let name = get_ident(variant.node.name);\n@@ -872,7 +872,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     &format!(\"Unexpected def kind while looking \\\n                                               up path in `{}`: `{:?}`\",\n                                              self.span.snippet(span),\n-                                             *def)[]),\n+                                             *def)),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -1007,7 +1007,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(p.span,\n                                            &format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span))[]);\n+                                                   self.span.snippet(p.span)));\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields {\n@@ -1255,7 +1255,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(method_type.span,\n                                            &format!(\"Could not find trait for method {}\",\n-                                                   method_type.id)[]);\n+                                                   method_type.id));\n                     },\n                 };\n \n@@ -1362,7 +1362,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         }\n                     }\n                     _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct type, found {:?}\", ty)[]),\n+                                            &format!(\"Expected struct type, found {:?}\", ty)),\n                 }\n             },\n             ast::ExprTupField(ref sub_ex, idx) => {\n@@ -1391,7 +1391,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     ty::ty_tup(_) => {}\n                     _ => self.sess.span_bug(ex.span,\n                                             &format!(\"Expected struct or tuple \\\n-                                                      type, found {:?}\", ty)[]),\n+                                                      type, found {:?}\", ty)),\n                 }\n             },\n             ast::ExprClosure(_, ref decl, ref body) => {\n@@ -1400,7 +1400,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let mut id = String::from_str(\"$\");\n-                id.push_str(&ex.id.to_string()[]);\n+                id.push_str(&ex.id.to_string());\n                 self.process_formals(&decl.inputs, &id[..]);\n \n                 // walk arg and return types\n@@ -1448,7 +1448,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n-                                           id)[]);\n+                                           id));\n             }\n             let def = &(*def_map)[id];\n             match *def {\n@@ -1463,7 +1463,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     self.fmt.variable_str(p.span,\n                                           Some(p.span),\n                                           id,\n-                                          &path_to_string(p)[],\n+                                          &path_to_string(p),\n                                           &value[..],\n                                           \"\")\n                 }\n@@ -1519,7 +1519,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  &path_to_string(p)[],\n+                                  &path_to_string(p),\n                                   &value[..],\n                                   &typ[..]);\n         }\n@@ -1540,7 +1540,7 @@ pub fn process_crate(sess: &Session,\n     }\n \n     assert!(analysis.glob_map.is_some());\n-    let cratename = match attr::find_crate_name(&krate.attrs[]) {\n+    let cratename = match attr::find_crate_name(&krate.attrs) {\n         Some(name) => name.to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n@@ -1561,7 +1561,7 @@ pub fn process_crate(sess: &Session,\n \n     match fs::mkdir_recursive(&root_path, old_io::USER_RWX) {\n         Err(e) => sess.err(&format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e)[]),\n+                           root_path.display(), e)),\n         _ => (),\n     }\n \n@@ -1578,7 +1578,7 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(&format!(\"Could not open {}: {}\", disp, e)[]);\n+            sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n         }\n     };\n     root_path.pop();"}, {"sha": "937f2d07677aa790141757ee034ee08135735f5f", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -162,7 +162,7 @@ impl<'a> FmtStrs<'a> {\n         if values.len() != fields.len() {\n             self.span.sess.span_bug(span, &format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len())[]);\n+                kind, fields.len(), values.len()));\n         }\n \n         let values = values.iter().map(|s| {\n@@ -191,7 +191,7 @@ impl<'a> FmtStrs<'a> {\n         if needs_span {\n             self.span.sess.span_bug(span, &format!(\n                 \"Called record_without_span for '{}' which does requires a span\",\n-                label)[]);\n+                label));\n         }\n         assert!(!dump_spans);\n \n@@ -268,7 +268,7 @@ impl<'a> FmtStrs<'a> {\n         // variable def's node id\n         let mut qualname = String::from_str(name);\n         qualname.push_str(\"$\");\n-        qualname.push_str(&id.to_string()[]);\n+        qualname.push_str(&id.to_string());\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "a5bebaa257ca0ca80b192afa37223ab1e6289279", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -219,7 +219,7 @@ impl<'a> SpanUtils<'a> {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n                 &format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line)[]);\n+                        self.snippet(span), loc.file.name, loc.line));\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -245,7 +245,7 @@ impl<'a> SpanUtils<'a> {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n                     self.sess.span_bug(span, &format!(\n                         \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line)[]);\n+                         self.snippet(span), loc.file.name, loc.line));\n                 }\n                 return result\n             }"}, {"sha": "1a24b3fabf898c8de62de4cd0fb3a591de07847a", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -444,7 +444,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(&br.pats[]).map(|pats| {\n+        e(&br.pats).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -825,7 +825,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         let did = langcall(cx,\n                            None,\n                            &format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t))[],\n+                                   cx.ty_to_string(rhs_t)),\n                            StrEqFnLangItem);\n         let t = ty::mk_str_slice(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ast::MutImmutable);\n         // The comparison function gets the slices by value, so we have to make copies here. Even\n@@ -1375,21 +1375,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         &bcx.ident(ident)[]));\n+                                         &bcx.ident(ident)));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 &bcx.ident(ident)[]);\n+                                 &bcx.ident(ident));\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 &bcx.ident(ident)[]);\n+                                 &bcx.ident(ident));\n                 trmode = TrByRef;\n             }\n         };\n@@ -1610,7 +1610,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, &bcx.ident(*ident)[]);\n+    let llval = alloc_ty(bcx, var_ty, &bcx.ident(*ident));\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1648,7 +1648,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx()))[]);\n+                                 pat.repr(bcx.tcx())));\n     }\n \n     let _indenter = indenter();"}, {"sha": "903de940207702062ecce6312bf7a1318688979c", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -177,7 +177,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n@@ -210,7 +210,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id))[]);\n+                                                        def_id)));\n             }\n \n             if cases.len() == 1 {\n@@ -228,7 +228,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, &cases[discr].tys[],\n+                        let st = mk_struct(cx, &cases[discr].tys,\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n                             Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n@@ -318,7 +318,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n-                ftys.push_all(&c.tys[]);\n+                ftys.push_all(&c.tys);\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n                 mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n@@ -328,7 +328,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             General(ity, fields, dtor)\n         }\n         _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t))[])\n+                           ty_to_string(cx.tcx(), t)))\n     }\n }\n \n@@ -414,7 +414,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n impl<'tcx> Case<'tcx> {\n     fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n-        mk_struct(cx, &self.tys[], false, scapegoat).size == 0\n+        mk_struct(cx, &self.tys, false, scapegoat).size == 0\n     }\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n@@ -504,7 +504,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match &cx.sess().target.target.arch[] {\n+            attempts = match &cx.sess().target.target.arch[..] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n@@ -624,7 +624,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(&struct_llfields(cx, st, false, false)[],\n+            llty.set_struct_body(&struct_llfields(cx, st, false, false),\n                                  st.packed)\n     }\n }\n@@ -640,7 +640,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst)[],\n+                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -965,7 +965,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             for (discr, case) in cases.iter().enumerate() {\n                 let mut variant_cx = fcx.new_temp_block(\n-                    &format!(\"enum-variant-iter-{}\", &discr.to_string())[]\n+                    &format!(\"enum-variant-iter-{}\", &discr.to_string())\n                 );\n                 let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n                 AddCase(llswitch, rhs_val, variant_cx.llbb);\n@@ -1070,7 +1070,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             if discr == nndiscr {\n                 C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals)[],\n+                                                 vals),\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n@@ -1080,7 +1080,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 &vals[..])[],\n+                                                 &vals[..]),\n                          false)\n             }\n         }"}, {"sha": "9c0aa9f69576ee09e163615d02614eec9edcf5df", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -365,7 +365,7 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Err(s) => {\n             bcx.sess().fatal(&format!(\"allocation of `{}` {}\",\n                                      bcx.ty_to_string(info_ty),\n-                                     s)[]);\n+                                     s));\n         }\n     }\n }\n@@ -444,7 +444,7 @@ pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: Val\n \n     for attr in attrs {\n         let mut used = true;\n-        match &attr.name()[] {\n+        match &attr.name()[..] {\n             \"no_stack_check\" => unset_split_stack(llfn),\n             \"no_split_stack\" => {\n                 unset_split_stack(llfn);\n@@ -486,7 +486,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(&format!(\"duplicate LLVM symbol: {}\", sym)[]);\n+        ccx.sess().bug(&format!(\"duplicate LLVM symbol: {}\", sym));\n     }\n     ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n@@ -541,7 +541,7 @@ pub fn bin_op_to_icmp_predicate(ccx: &CrateContext, op: ast::BinOp_, signed: boo\n         ast::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n         op => {\n             ccx.sess().bug(&format!(\"comparison_op_to_icmp_predicate: expected \\\n-                                     comparison operator, found {:?}\", op)[]);\n+                                     comparison operator, found {:?}\", op));\n         }\n     }\n }\n@@ -557,7 +557,7 @@ pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: ast::BinOp_)\n         ast::BiGe => llvm::RealOGE,\n         op => {\n             ccx.sess().bug(&format!(\"comparison_op_to_fcmp_predicate: expected \\\n-                                     comparison operator, found {:?}\", op)[]);\n+                                     comparison operator, found {:?}\", op));\n         }\n     }\n }\n@@ -735,8 +735,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               &format!(\"enum-iter-variant-{}\",\n-                                      &variant.disr_val.to_string()[])\n-                              []);\n+                                      &variant.disr_val.to_string())\n+                              );\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -761,7 +761,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       _ => {\n           cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t))[])\n+                                   ty_to_string(cx.tcx(), t)))\n       }\n     }\n     return cx;\n@@ -843,7 +843,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n         _ => {\n             cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t))[]);\n+                                  ty_to_string(cx.tcx(), rhs_t)));\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -1116,7 +1116,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match &ccx.sess().target.target.target_pointer_width[] {\n+    let key = match &ccx.sess().target.target.target_pointer_width[..] {\n         \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n         \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n@@ -1163,7 +1163,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match &ccx.sess().target.target.target_pointer_width[] {\n+    let intrinsic_key = match &ccx.sess().target.target.target_pointer_width[..] {\n         \"32\" => \"llvm.memset.p0i8.i32\",\n         \"64\" => \"llvm.memset.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n@@ -1833,14 +1833,14 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         closure::ClosureEnv::NotClosure => {\n             copy_args_to_allocas(bcx,\n                                  arg_scope,\n-                                 &decl.inputs[],\n+                                 &decl.inputs,\n                                  arg_datums)\n         }\n         closure::ClosureEnv::Closure(_) => {\n             copy_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n-                &decl.inputs[],\n+                &decl.inputs,\n                 arg_datums,\n                 &monomorphized_arg_types[..])\n         }\n@@ -1964,7 +1964,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx))[])\n+                     ctor_ty.repr(tcx)))\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -2042,7 +2042,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty))[])\n+                    ty_to_string(ccx.tcx(), ctor_ty)))\n     };\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -2143,7 +2143,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                             *lvlsrc.unwrap(), Some(sp),\n                             &format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest)[]);\n+                                    largest));\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2261,7 +2261,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(&item.attrs[]);\n+            let trans_everywhere = attr::requests_inline(&item.attrs);\n             // Ignore `trans_everywhere` for cross-crate inlined items\n             // (`from_external`).  `trans_item` will be called once for each\n             // compilation unit that references the item, so it will still get\n@@ -2273,7 +2273,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n-                                                            &item.attrs[],\n+                                                            &item.attrs,\n                                                             llfn,\n                                                             empty_substs,\n                                                             item.id,\n@@ -2285,7 +2285,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                              llfn,\n                              empty_substs,\n                              item.id,\n-                             &item.attrs[]);\n+                             &item.attrs);\n                 }\n                 update_linkage(ccx,\n                                llfn,\n@@ -2332,7 +2332,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(&item.attrs[], \"static_assert\") {\n+          if attr::contains_name(&item.attrs, \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess().span_fatal(expr.span,\n                                         \"cannot have static_assert on a mutable \\\n@@ -2746,7 +2746,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = || exported_name(ccx, id, ty, &i.attrs[]);\n+            let sym = || exported_name(ccx, id, ty, &i.attrs);\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -2773,13 +2773,13 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         if contains_null(&sym[..]) {\n                             ccx.sess().fatal(\n                                 &format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym)[]);\n+                                         value: `{}`\", sym));\n                         }\n                         let buf = CString::new(sym.clone()).unwrap();\n                         let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n                                                     buf.as_ptr());\n \n-                        if attr::contains_name(&i.attrs[],\n+                        if attr::contains_name(&i.attrs,\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n@@ -2798,19 +2798,19 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, &i.attrs[], llfn);\n+                    set_llvm_fn_attrs(ccx, &i.attrs, llfn);\n                     llfn\n                 }\n \n                 _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n-            match attr::first_attr_value_str_by_name(&i.attrs[],\n+            match attr::first_attr_value_str_by_name(&i.attrs,\n                                                      \"link_section\") {\n                 Some(sect) => {\n                     if contains_null(&sect) {\n                         ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 &sect)[]);\n+                                                 &sect));\n                     }\n                     unsafe {\n                         let buf = CString::new(sect.as_bytes()).unwrap();\n@@ -2876,7 +2876,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    &enm.attrs[]);\n+                                    &enm.attrs);\n \n             llfn = match enm.node {\n                 ast::ItemEnum(_, _) => {\n@@ -2903,7 +2903,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    &struct_item.attrs[]);\n+                                    &struct_item.attrs);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n             set_inline_hint(llfn);\n@@ -2912,7 +2912,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         ref variant => {\n             ccx.sess().bug(&format!(\"get_item_val(): unexpected variant: {:?}\",\n-                                   variant)[])\n+                                   variant))\n         }\n     };\n \n@@ -2933,10 +2933,10 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, &m.attrs[]);\n+    let sym = exported_name(ccx, id, mty, &m.attrs);\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, &m.attrs[], llfn);\n+    set_llvm_fn_attrs(ccx, &m.attrs, llfn);\n     llfn\n }\n \n@@ -3104,7 +3104,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(&link_meta.crate_name[],\n+    let shared_ccx = SharedCrateContext::new(&link_meta.crate_name,\n                                              codegen_units,\n                                              tcx,\n                                              export_map,\n@@ -3206,7 +3206,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n-    let no_builtins = attr::contains_name(&krate.attrs[], \"no_builtins\");\n+    let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n     let translation = CrateTranslation {\n         modules: modules,"}, {"sha": "0ff5264c00f0f8346ebd9d3180affdf7787c9216", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -109,7 +109,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match &ccx.sess().target.target.arch[] {\n+    match &ccx.sess().target.target.arch[..] {\n         \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n             cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n@@ -128,6 +128,6 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n         \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, atys, rty, ret_def),\n         a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)\n-                              []),\n+                              ),\n     }\n }"}, {"sha": "1cc8f62045df8dac6ed2f5d9416035c7dba0872f", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -118,7 +118,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     expr.span,\n                     &format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_string(datum.ty))[]);\n+                            bcx.ty_to_string(datum.ty)));\n             }\n         }\n     }\n@@ -215,7 +215,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\\n-                             to a callable thing!\", def)[]);\n+                             to a callable thing!\", def));\n             }\n         }\n     }\n@@ -298,7 +298,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n             _ => {\n                 tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx))[]);\n+                                           bare_fn_ty.repr(tcx)));\n             }\n         };\n     let sig = ty::erase_late_bound_regions(tcx, sig);"}, {"sha": "a3705a67cdc5a4e37f30dbff6bf3e5bdb5b86a3b", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -513,7 +513,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         self.ccx.sess().bug(\n             &format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope))[]);\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope)));\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -695,7 +695,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(&format!(\n                                 \"cannot exit from scope {}, \\\n-                                not in scope\", id)[]);\n+                                not in scope\", id));\n                     }\n                 }\n             }\n@@ -1135,7 +1135,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n         }\n         None => {\n             tcx.sess.bug(&format!(\"no temporary scope available for expr {}\",\n-                                 id)[])\n+                                 id))\n         }\n     }\n }"}, {"sha": "60725bf9b2a290ae023dd53fb8a869fea4670536", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -278,7 +278,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n     let num = token::gensym(name).usize();\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n+    PathName(token::gensym(&format!(\"{}:{}\", name, num)))\n }\n \n #[derive(Copy)]\n@@ -606,7 +606,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(&format!(\n-                    \"no def associated with node id {}\", nid)[]);\n+                    \"no def associated with node id {}\", nid));\n             }\n         }\n     }\n@@ -1011,7 +1011,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 span,\n                 &format!(\"Encountered error `{}` selecting `{}` during trans\",\n                         e.repr(tcx),\n-                        trait_ref.repr(tcx))[])\n+                        trait_ref.repr(tcx)))\n         }\n     };\n \n@@ -1104,7 +1104,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n                 infcx.tcx.sess.span_bug(\n                     span,\n                     &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                            errors.repr(infcx.tcx))[]);\n+                            errors.repr(infcx.tcx)));\n             }\n         }\n     }\n@@ -1144,7 +1144,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n             tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                                 node, substs.repr(tcx))[]);\n+                                 node, substs.repr(tcx)));\n         }\n \n         monomorphize::apply_param_substs(tcx,"}, {"sha": "3c0024712b23acc9110302be1bf9c88e90b4f1ad", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -54,7 +54,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                 _ => cx.sess().span_bug(lit.span,\n                         &format!(\"integer literal has type {} (expected int \\\n                                  or uint)\",\n-                                ty_to_string(cx.tcx(), lit_int_ty))[])\n+                                ty_to_string(cx.tcx(), lit_int_ty)))\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -152,7 +152,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         None => {\n             cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                   ty_to_string(cx.tcx(), ty))[])\n+                                   ty_to_string(cx.tcx(), ty)))\n         }\n     }\n }\n@@ -174,7 +174,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     } else {\n         ccx.sess().span_bug(ref_expr.span,\n                             &format!(\"get_const_val given non-constant item {}\",\n-                                     item.repr(ccx.tcx()))[]);\n+                                     item.repr(ccx.tcx())));\n     }\n }\n \n@@ -301,15 +301,15 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             }\n                             None => {\n                                 cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                                       ty_to_string(cx.tcx(), ty))[])\n+                                                       ty_to_string(cx.tcx(), ty)))\n                             }\n                         }\n                     }\n                     opt_autoref\n                 }\n                 Some(autoref) => {\n                     cx.sess().span_bug(e.span,\n-                        &format!(\"unimplemented const first autoref {:?}\", autoref)[])\n+                        &format!(\"unimplemented const first autoref {:?}\", autoref))\n                 }\n             };\n             match second_autoref {\n@@ -333,7 +333,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 Some(autoref) => {\n                     cx.sess().span_bug(e.span,\n-                        &format!(\"unimplemented const second autoref {:?}\", autoref)[])\n+                        &format!(\"unimplemented const second autoref {:?}\", autoref))\n                 }\n             }\n         }\n@@ -351,7 +351,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety_adjusted),\n-                         csize, tsize)[]);\n+                         csize, tsize));\n     }\n     (llconst, ety_adjusted)\n }\n@@ -485,7 +485,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       _ => cx.sess().span_bug(base.span,\n                                               &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt))[])\n+                                                      ty_to_string(cx.tcx(), bt)))\n                   },\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n@@ -494,12 +494,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       _ => cx.sess().span_bug(base.span,\n                                               &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt))[])\n+                                                      ty_to_string(cx.tcx(), bt)))\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           &format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  ty_to_string(cx.tcx(), bt))[])\n+                                                  ty_to_string(cx.tcx(), bt)))\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;"}, {"sha": "3586a9dda20675bbc89752d0a45f6cd9d6d24750", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -378,7 +378,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                                           .target\n                                           .target\n                                           .data_layout\n-                                          []);\n+                                          );\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n@@ -731,7 +731,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n     /// address space on 64-bit ARMv8 and x86_64.\n     pub fn obj_size_bound(&self) -> u64 {\n-        match &self.sess().target.target.target_pointer_width[] {\n+        match &self.sess().target.target.target_pointer_width[..] {\n             \"32\" => 1 << 31,\n             \"64\" => 1 << 47,\n             _ => unreachable!() // error handled by config::build_target_config\n@@ -741,7 +741,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n             &format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx()))[])\n+                    obj.repr(self.tcx())))\n     }\n }\n "}, {"sha": "6860cda8241c9011489874b7cae1094a4b27355b", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -12,6 +12,7 @@ use llvm::ValueRef;\n use middle::def;\n use middle::lang_items::{PanicFnLangItem, PanicBoundsCheckFnLangItem};\n use trans::base::*;\n+use trans::basic_block::BasicBlock;\n use trans::build::*;\n use trans::callee;\n use trans::cleanup::CleanupMethods;\n@@ -40,7 +41,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, &s.repr(cx.tcx())[]);\n+        add_span_comment(cx, s.span, &s.repr(cx.tcx()));\n     }\n \n     let mut bcx = cx;\n@@ -280,6 +281,12 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fcx.pop_loop_cleanup_scope(loop_expr.id);\n \n+    // If there are no predecessors for the next block, we just translated an endless loop and the\n+    // next block is unreachable\n+    if BasicBlock(next_bcx_in.llbb).pred_iter().next().is_none() {\n+        Unreachable(next_bcx_in);\n+    }\n+\n     return next_bcx_in;\n }\n \n@@ -303,7 +310,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n-                                               r)[])\n+                                               r))\n                 }\n             }\n         }\n@@ -368,7 +375,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name[]);\n+    let filename = token::intern_and_get_ident(&loc.file.name);\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n@@ -395,7 +402,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name[]);\n+    let filename = token::intern_and_get_ident(&loc.file.name);\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);"}, {"sha": "96211832c1cc921556c14eda4b6bd715e137098f", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -557,7 +557,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n             }\n             _ => bcx.tcx().sess.bug(\n                 &format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty))[])\n+                        bcx.ty_to_string(self.ty)))\n         };\n         Datum {\n             val: val,"}, {"sha": "b5cba9b67406cee1c6c7f04ab16a05840b3fed2a", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_))[]);\n+                                   ppaux::ty_to_string(cx.tcx(), type_)));\n         }\n     }\n \n@@ -299,7 +299,7 @@ impl<'tcx> TypeMap<'tcx> {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  &unique_type_id_str[..])[]);\n+                                  &unique_type_id_str[..]));\n         }\n     }\n \n@@ -412,7 +412,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n-                        unique_type_id.push_str(&format!(\"[{}]\", len)[]);\n+                        unique_type_id.push_str(&format!(\"[{}]\", len));\n                     }\n                     None => {\n                         unique_type_id.push_str(\"[]\");\n@@ -481,8 +481,8 @@ impl<'tcx> TypeMap<'tcx> {\n             },\n             _ => {\n                 cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                      &ppaux::ty_to_string(cx.tcx(), type_)[],\n-                                      type_.sty)[])\n+                                      &ppaux::ty_to_string(cx.tcx(), type_),\n+                                      type_.sty))\n             }\n         };\n \n@@ -525,7 +525,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(&format!(\"{:x}\", def_id.node)[]);\n+            output.push_str(&format!(\"{:x}\", def_id.node));\n \n             // Maybe check that there is no self type here.\n \n@@ -600,7 +600,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                               -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n-                                           &self.get_unique_type_id_as_string(enum_type_id)[],\n+                                           &self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n@@ -783,19 +783,19 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n                                          unexpected ast_item variant: {:?}\",\n-                                        var_item)[])\n+                                        var_item))\n                 }\n             }\n         },\n         _ => cx.sess().bug(&format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n                                     ast_map variant: {:?}\",\n-                                   var_item)[])\n+                                   var_item))\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, &loc.file.name[]), loc.line as c_uint)\n+        (file_metadata(cx, &loc.file.name), loc.line as c_uint)\n     } else {\n         (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };\n@@ -847,7 +847,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     &format!(\"no entry in lllocals table for {}\",\n-                            node_id)[]);\n+                            node_id));\n             }\n         };\n \n@@ -903,7 +903,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                 ast_item)[]);\n+                                 ast_item));\n                 }\n             }\n         }\n@@ -913,7 +913,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         &format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                ast_item)[]);\n+                                ast_item));\n         }\n     };\n \n@@ -1025,7 +1025,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     &format!(\"no entry in lllocals table for {}\",\n-                            node_id)[]);\n+                            node_id));\n             }\n         };\n \n@@ -1319,7 +1319,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     cx.sess()\n                       .bug(&format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                    fnitem)[])\n+                                    fnitem))\n                 }\n             }\n         }\n@@ -1330,7 +1330,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                   fnitem)[])\n+                                   fnitem))\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -1339,7 +1339,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name[]);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx,\n@@ -1751,7 +1751,7 @@ fn scope_metadata(fcx: &FunctionContext,\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n                 &format!(\"debuginfo: Could not find scope info for node {:?}\",\n-                        node)[]);\n+                        node));\n         }\n     }\n }\n@@ -1947,7 +1947,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                         cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n                                               ppaux::ty_to_string(cx.tcx(), unfinished_type))\n-                                      []);\n+                                      );\n                     }\n                 }\n \n@@ -2370,7 +2370,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     .iter()\n                                     .map(|&t| type_of::type_of(cx, t))\n                                     .collect::<Vec<_>>()\n-                                    [],\n+                                    ,\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n@@ -2437,7 +2437,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, &loc.file.name[]);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n \n     let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n@@ -2624,7 +2624,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                                         Please use a rustc built with anewer \\\n                                         version of LLVM.\",\n                                        llvm_version_major,\n-                                       llvm_version_minor)[]);\n+                                       llvm_version_minor));\n             } else {\n                 cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n                                Already completed forward declaration re-encountered.\");\n@@ -2786,7 +2786,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name[]);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n@@ -2865,7 +2865,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   &pp_type_name[..])[]);\n+                                   &pp_type_name[..]));\n         }\n     };\n \n@@ -3005,7 +3005,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             cx.sess().bug(&format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n-                                  sty)[])\n+                                  sty))\n         }\n     };\n \n@@ -3248,7 +3248,7 @@ fn create_scope_map(cx: &CrateContext,\n     {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, &loc.file.name[]);\n+        let file_metadata = file_metadata(cx, &loc.file.name);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -3370,7 +3370,7 @@ fn create_scope_map(cx: &CrateContext,\n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, &loc.file.name[]);\n+                        let file_metadata = file_metadata(cx, &loc.file.name);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -3832,7 +3832,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_projection(..) |\n         ty::ty_param(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n         }\n     }\n \n@@ -3915,21 +3915,21 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(&format!(\"{}\", string.len())[]);\n+            output.push_str(&format!(\"{}\", string.len()));\n             output.push_str(&string);\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(&format!(\"{}\", item_name.len())[]);\n+        name.push_str(&format!(\"{}\", item_name.len()));\n         name.push_str(item_name);\n         name.push('E');\n         name\n     }\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    &cx.link_meta().crate_name[]\n+    &cx.link_meta().crate_name\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n@@ -4005,7 +4005,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             None => {\n                 cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n                                        path too short for {:?}\",\n-                                      def_id)[]);\n+                                      def_id));\n             }\n         }\n     })"}, {"sha": "78992959a6f2288f39c5c734988d0561baa041c6", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -308,7 +308,7 @@ pub fn unsized_info<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n                 unsized_info(ccx, k, id, ty_substs[tp_index], param_substs, identity)\n             }\n             _ => ccx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n-                                         unadjusted_ty.repr(ccx.tcx()))[])\n+                                         unadjusted_ty.repr(ccx.tcx())))\n         },\n         &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n             // Note that we preserve binding levels here:\n@@ -524,7 +524,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let unboxed_ty = match datum_ty.sty {\n             ty::ty_uniq(t) => t,\n             _ => bcx.sess().bug(&format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_string(datum_ty))[])\n+                                        bcx.ty_to_string(datum_ty)))\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n@@ -696,7 +696,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 &format!(\"trans_rvalue_datum_unadjusted reached \\\n                          fall-through case: {:?}\",\n-                        expr.node)[]);\n+                        expr.node));\n         }\n     }\n }\n@@ -1020,7 +1020,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 &format!(\"trans_rvalue_stmt_unadjusted reached \\\n                          fall-through case: {:?}\",\n-                        expr.node)[]);\n+                        expr.node));\n         }\n     }\n }\n@@ -1216,7 +1216,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 &format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n                          case: {:?}\",\n-                        expr.node)[]);\n+                        expr.node));\n         }\n     }\n }\n@@ -1266,7 +1266,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, &format!(\n                 \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id))[]);\n+                def, bcx.node_id_to_string(ref_expr.id)));\n         }\n     }\n }\n@@ -1295,7 +1295,7 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n                     \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n                     def,\n-                    ref_expr.repr(ccx.tcx()))[]);\n+                    ref_expr.repr(ccx.tcx())));\n         }\n     }\n }\n@@ -1315,7 +1315,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(&format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n-                        nid)[]);\n+                        nid));\n                 }\n             }\n         }\n@@ -1325,7 +1325,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(&format!(\n                         \"trans_local_var: no datum for local/arg {} found\",\n-                        nid)[]);\n+                        nid));\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n@@ -1335,7 +1335,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.sess().unimpl(&format!(\n                 \"unsupported def type in trans_local_var: {:?}\",\n-                def)[]);\n+                def));\n         }\n     }\n }\n@@ -1358,7 +1358,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, &tup_fields(&v[..])[])\n+            op(0, &tup_fields(&v[..]))\n         }\n \n         ty::ty_enum(_, substs) => {\n@@ -1368,7 +1368,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.bug(&format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx))[]);\n+                        ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow()[node_id].clone();\n@@ -1392,7 +1392,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         _ => {\n             tcx.sess.bug(&format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx))[]);\n+                ty.repr(tcx)));\n         }\n     }\n }\n@@ -2097,7 +2097,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n-                                            k_out)[])\n+                                            k_out))\n                 }\n             }\n         }\n@@ -2106,7 +2106,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),\n-                                    k_out)[])\n+                                    k_out))\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2272,7 +2272,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 &format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx()))[]);\n+                        datum.ty.repr(bcx.tcx())));\n         }\n     };\n "}, {"sha": "efae76c5ef41c76027b149666d001858e9f058ae", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -111,7 +111,7 @@ pub fn register_static(ccx: &CrateContext,\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n-    match attr::first_attr_value_str_by_name(&foreign_item.attrs[],\n+    match attr::first_attr_value_str_by_name(&foreign_item.attrs,\n                                              \"linkage\") {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -240,11 +240,11 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[..]);\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         &llsig.llarg_tys[],\n+                                         &llsig.llarg_tys,\n                                          llsig.llret_ty,\n                                          llsig.ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = &fn_type.arg_tys[];\n+    let arg_tys: &[cabi::ArgType] = &fn_type.arg_tys;\n \n     let mut llargs_foreign = Vec::new();\n \n@@ -439,7 +439,7 @@ fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n                 tcx.sess.span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n-                                       pprust::ty_to_string(ast_ty))[]);\n+                                       pprust::ty_to_string(ast_ty)));\n                 tcx.sess.span_help(ast_ty.span,\n                                    \"add #![feature(simd_ffi)] to the crate attributes to enable\");\n             }\n@@ -603,7 +603,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx))[]);\n+                                       t.repr(tcx)));\n             }\n         };\n \n@@ -868,9 +868,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(&i.attrs[], \"link_name\") {\n+    match attr::first_attr_value_str_by_name(&i.attrs, \"link_name\") {\n         Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(&i.attrs[]) {\n+        None => match weak_lang_items::link_name(&i.attrs) {\n             Some(name) => name,\n             None => token::get_ident(i.ident),\n         }\n@@ -913,7 +913,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, &fn_sig.inputs);\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       &llsig.llarg_tys[],\n+                                       &llsig.llarg_tys,\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -922,7 +922,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn().types_to_str(&llsig.llarg_tys[]),\n+           ccx.tn().types_to_str(&llsig.llarg_tys),\n            ccx.tn().type_to_string(llsig.llret_ty),\n            ccx.tn().types_to_str(&fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),"}, {"sha": "20956bf795b8537ed94987d632ad1bc0fe04f108", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -243,7 +243,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             sig.inputs[0]\n         }\n         _ => bcx.sess().bug(&format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty))[])\n+                                    bcx.ty_to_string(fty)))\n     };\n \n     let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n@@ -370,7 +370,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n              C_uint(bcx.ccx(), unit_align))\n         }\n         _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t))[])\n+                                    bcx.ty_to_string(t)))\n     }\n }\n \n@@ -443,7 +443,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\",\n-                                                bcx.ty_to_string(t))[]);\n+                                                bcx.ty_to_string(t)));\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n@@ -521,7 +521,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident(\n-        &ppaux::ty_to_string(ccx.tcx(), t)[]);\n+        &ppaux::ty_to_string(ccx.tcx(), t));\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -540,7 +540,7 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n         t,\n-        &format!(\"glue_{}\", name)[]);\n+        &format!(\"glue_{}\", name));\n     let llfn = decl_cdecl_fn(ccx, &fn_nm[..], llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);"}, {"sha": "993c9eae45bf6326f016693dea46bb25dfe043ec", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -36,7 +36,7 @@ use syntax::parse::token;\n use util::ppaux::{Repr, ty_to_string};\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n-    let name = match &token::get_ident(item.ident)[] {\n+    let name = match &token::get_ident(item.ident)[..] {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n         \"powif32\" => \"llvm.powi.f32\","}, {"sha": "65d8f8ec3614d071d3e7d0e5d5ae67223c97d3f1", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -79,7 +79,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0 {\n-                    let trans_everywhere = attr::requests_inline(&method.attrs[]);\n+                    let trans_everywhere = attr::requests_inline(&method.attrs);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         let empty_substs = tcx.mk_substs(Substs::trans_empty());\n@@ -305,7 +305,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             tcx.sess.bug(&format!(\"static call to invalid vtable: {}\",\n-                                 vtbl.repr(tcx))[]);\n+                                 vtbl.repr(tcx)));\n         }\n     }\n }\n@@ -393,7 +393,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n                 &format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx()))[]);\n+                        vtable.repr(bcx.tcx())));\n         }\n     }\n }\n@@ -749,7 +749,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 tcx.sess.bug(\n                     &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(tcx),\n-                            vtable.repr(tcx))[]);\n+                            vtable.repr(tcx)));\n             }\n         }\n     });"}, {"sha": "5ab1ec2a69eda56f5aef11c173feae75c06871d2", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -177,7 +177,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, &i.attrs[]);\n+                  let needs_body = setup_lldecl(d, &i.attrs);\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n@@ -220,7 +220,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *ii {\n                 ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, &mth.attrs[]);\n+                    let needs_body = setup_lldecl(d, &mth.attrs);\n                     if needs_body {\n                         trans_fn(ccx,\n                                  mth.pe_fn_decl(),\n@@ -241,7 +241,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *method {\n                 ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, &mth.attrs[]);\n+                    let needs_body = setup_lldecl(d, &mth.attrs);\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  psubsts, mth.id, &[]);\n@@ -250,15 +250,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 }\n                 _ => {\n                     ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                           map_node)[])\n+                                           map_node))\n                 }\n             }\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     &struct_def.fields[],\n+                                     &struct_def.fields,\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -276,7 +276,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                   map_node)[])\n+                                   map_node))\n         }\n     };\n "}, {"sha": "0c69a7132a77be8b9855dc1b5b4a7c578445a0e5", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -109,7 +109,7 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match &ccx.tcx().sess.target.target.target_pointer_width[] {\n+        match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n             tws => panic!(\"Unsupported target word size for int: {}\", tws),"}, {"sha": "b53ea79804c08f3815ab27ad53087c118cbf983b", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -185,7 +185,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     let llsizingty = match t.sty {\n         _ if !lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(&format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t))[])\n+                                  ppaux::ty_to_string(cx.tcx(), t)))\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -238,7 +238,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_string(cx.tcx(), t))[])\n+                                  ppaux::ty_to_string(cx.tcx(), t)))\n         }\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n     };\n@@ -418,7 +418,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n           _ => cx.sess().bug(&format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t))[])\n+                                     ppaux::ty_to_string(cx.tcx(), t)))\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),"}, {"sha": "afdc414c163ce17f103959f242164d0e688d96fe", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -195,7 +195,7 @@ pub fn opt_ast_region_to_region<'tcx>(\n                                     help_name\n                                 } else {\n                                     format!(\"one of {}'s {} elided lifetimes\", help_name, n)\n-                                })[]);\n+                                })[..]);\n \n                                 if len == 2 && i == 0 {\n                                     m.push_str(\" or \");\n@@ -876,7 +876,7 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                         .sess\n                         .span_bug(ast_ty.span,\n                                   &format!(\"unbound path {}\",\n-                                          path.repr(this.tcx()))[])\n+                                          path.repr(this.tcx())))\n                 }\n                 Some(&d) => d\n             };\n@@ -898,7 +898,7 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                             this.tcx().sess.span_bug(\n                                 path.span,\n                                 &format!(\"converting `Box` to `{}`\",\n-                                        ty.repr(this.tcx()))[]);\n+                                        ty.repr(this.tcx())));\n                         }\n                     }\n                 }\n@@ -1206,7 +1206,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n                                      &format!(\"unbound path {}\",\n-                                             path.repr(tcx))[])\n+                                             path.repr(tcx)))\n                     }\n                     Some(&d) => d\n                 };\n@@ -1419,7 +1419,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let input_params = if self_ty.is_some() {\n         &decl.inputs[1..]\n     } else {\n-        &decl.inputs[]\n+        &decl.inputs[..]\n     };\n     let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n     let input_pats: Vec<String> = input_params.iter()"}, {"sha": "998a4504088a330394d69157cf5ec74687b9f2af", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n             ty::ty_open(_) => {\n                 self.tcx().sess.bug(\n                     &format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx()))[]);\n+                            ty.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "53976df75d6160e5530a3c481c703afeb5e47cf1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -331,7 +331,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty.repr(self.tcx()))[])\n+                            self_ty.repr(self.tcx())))\n             }\n         }\n     }\n@@ -386,7 +386,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     &format!(\n                         \"{} was a subtype of {} but now is not?\",\n                         self_ty.repr(self.tcx()),\n-                        method_self_ty.repr(self.tcx()))[]);\n+                        method_self_ty.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "ed86925bd57daed348e6ba4e28baec299c40aaa4", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -272,7 +272,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 span,\n                                 &format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx()))[]);\n+                                    transformed_self_ty.repr(fcx.tcx())));\n                         }\n                     }\n                 }\n@@ -282,7 +282,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         span,\n                         &format!(\n                             \"unexpected explicit self type in operator method: {:?}\",\n-                            method_ty.explicit_self)[]);\n+                            method_ty.explicit_self));\n                 }\n             }\n         }"}, {"sha": "1cc4fe37fbdddf59928799b287752c412457d9db", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -878,15 +878,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, &self.inherent_candidates[]) {\n+        match self.consider_candidates(self_ty, &self.inherent_candidates) {\n             None => {}\n             Some(pick) => {\n                 return Some(pick);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        self.consider_candidates(self_ty, &self.extension_candidates[])\n+        self.consider_candidates(self_ty, &self.extension_candidates)\n     }\n \n     fn consider_candidates(&self,"}, {"sha": "f5a03f0721a65be59544993b9412d16caa22f532", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -71,7 +71,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if is_field {\n                 cx.sess.span_note(span,\n                     &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring)[]);\n+                            function stored in the `{0}` field\", method_ustring));\n             }\n \n             if static_sources.len() > 0 {"}, {"sha": "0430954ad7e2f9612e9482636956ca01b4bb5cb2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -117,7 +117,7 @@ use std::iter::repeat;\n use std::slice;\n use syntax::{self, abi, attr};\n use syntax::attr::AttrMetaMethods;\n-use syntax::ast::{self, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n+use syntax::ast::{self, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId, Visibility};\n use syntax::ast_util::{self, local_def, PostExpansionMethod};\n use syntax::codemap::{self, Span};\n use syntax::owned_slice::OwnedSlice;\n@@ -615,7 +615,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    let arg_tys = &fn_sig.inputs[];\n+    let arg_tys = &fn_sig.inputs;\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n@@ -713,7 +713,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            &enum_definition.variants[],\n+                            &enum_definition.variants,\n                             it.id);\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n@@ -1334,7 +1334,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     span,\n                     &format!(\"no type for local variable {}\",\n-                            nid)[]);\n+                            nid));\n             }\n         }\n     }\n@@ -1707,7 +1707,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(&format!(\"no type for expr in fcx {}\",\n-                                            self.tag())[]);\n+                                            self.tag()));\n             }\n         }\n     }\n@@ -1739,7 +1739,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\"no type for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_string(id),\n-                            self.tag())[]);\n+                            self.tag()));\n             }\n         }\n     }\n@@ -2275,7 +2275,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         if arg_types.len() == 1 {\"\"} else {\"s\"},\n                         args.len(),\n                         if args.len() == 1 {\" was\"} else {\"s were\"});\n-                    expected_arg_tys = &[][];\n+                    expected_arg_tys = &[];\n                     err_args(fcx.tcx(), args.len())\n                 } else {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n@@ -2292,7 +2292,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n                      for the function trait is neither a tuple nor unit\");\n-                expected_arg_tys = &[][];\n+                expected_arg_tys = &[];\n                 err_args(fcx.tcx(), args.len())\n             }\n         }\n@@ -2309,7 +2309,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if expected_arg_count == 1 {\"\"} else {\"s\"},\n                 supplied_arg_count,\n                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-            expected_arg_tys = &[][];\n+            expected_arg_tys = &[];\n             err_args(fcx.tcx(), supplied_arg_count)\n         }\n     } else {\n@@ -2319,7 +2319,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if expected_arg_count == 1 {\"\"} else {\"s\"},\n             supplied_arg_count,\n             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-        expected_arg_tys = &[][];\n+        expected_arg_tys = &[];\n         err_args(fcx.tcx(), supplied_arg_count)\n     };\n \n@@ -2809,7 +2809,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n         let args = match rhs {\n             Some(rhs) => slice::ref_slice(rhs),\n-            None => &[][]\n+            None => &[][..]\n         };\n         match method {\n             Some(method) => {\n@@ -3117,6 +3117,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             if skip.iter().any(|&x| x == n) {\n                 continue;\n             }\n+            // ignore private fields from non-local crates\n+            if id.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n+                continue;\n+            }\n             let dist = lev_distance(n, name);\n             if dist < best_dist {\n                 best = Some(n);\n@@ -4584,7 +4588,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n-        [].get(0).unwrap_or(&attr::ReprAny);\n+        .get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {"}, {"sha": "f6ac1ddee497694ac39c4be6d7edbd6af4a7d9e0", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -188,7 +188,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n         }\n         _ => {\n             tcx.sess.bug(&format!(\"unexpected def in region_of_def: {:?}\",\n-                                 def)[])\n+                                 def))\n         }\n     }\n }\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n-                    &format!(\"No fn-sig entry for id={}\", id)[]);\n+                    &format!(\"No fn-sig entry for id={}\", id));\n             }\n         };\n \n@@ -1013,7 +1013,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                         rcx.tcx().sess.span_bug(\n                             deref_expr.span,\n                             &format!(\"bad overloaded deref type {}\",\n-                                     method.ty.repr(rcx.tcx()))[])\n+                                     method.ty.repr(rcx.tcx())))\n                     }\n                 };\n \n@@ -1417,7 +1417,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                     rcx.tcx().sess.span_bug(\n                         span,\n                         &format!(\"Illegal upvar id: {}\",\n-                                upvar_id.repr(rcx.tcx()))[]);\n+                                upvar_id.repr(rcx.tcx())));\n                 }\n             }\n         }\n@@ -1562,7 +1562,7 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         GenericKind::Param(..) => { }\n         GenericKind::Projection(ref projection_ty) => {\n             param_bounds.push_all(\n-                &projection_bounds(rcx, origin.span(), projection_ty)[]);\n+                &projection_bounds(rcx, origin.span(), projection_ty));\n         }\n     }\n "}, {"sha": "b0ded25af1700d0440e2d5ef442812946103a8be", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -393,7 +393,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         self.tcx().sess.span_err(\n             span,\n             &format!(\"parameter `{}` is never used\",\n-                     param_name.user_string(self.tcx()))[]);\n+                     param_name.user_string(self.tcx())));\n \n         match suggested_marker_id {\n             Some(def_id) => {"}, {"sha": "7215ab01b02dec250d1e7b22509b6a10dc9be742", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -86,7 +86,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             inference_context.tcx.sess.span_bug(\n                 span,\n                 &format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                        ty.repr(inference_context.tcx))[]);\n+                        ty.repr(inference_context.tcx)));\n         }\n     }\n }"}, {"sha": "bb5566ab131ec1c7559a2af6c708f6307cf1b8ab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -899,7 +899,7 @@ fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n             tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n-                                  trait_id.node)[])\n+                                  trait_id.node))\n         }\n     }\n }\n@@ -925,7 +925,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                &format!(\"trait_def_of_item invoked on {:?}\", s)[]);\n+                &format!(\"trait_def_of_item invoked on {:?}\", s));\n         }\n     };\n \n@@ -1025,7 +1025,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                &format!(\"trait_def_of_item invoked on {:?}\", s)[]);\n+                &format!(\"trait_def_of_item invoked on {:?}\", s));\n         }\n     };\n \n@@ -1284,8 +1284,8 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n-                &generics.lifetimes[],\n-                &generics.ty_params[],\n+                &generics.lifetimes,\n+                &generics.ty_params,\n                 &generics.where_clause,\n                 ty::Generics::empty())\n }\n@@ -1314,8 +1314,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n-                    &ast_generics.lifetimes[],\n-                    &ast_generics.ty_params[],\n+                    &ast_generics.lifetimes,\n+                    &ast_generics.ty_params,\n                     &ast_generics.where_clause,\n                     ty::Generics::empty());\n \n@@ -1360,7 +1360,7 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     ty_generics(ccx,\n                 subst::FnSpace,\n                 &early_lifetimes[..],\n-                &generics.ty_params[],\n+                &generics.ty_params,\n                 &generics.where_clause,\n                 base_generics)\n }\n@@ -1557,7 +1557,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n     let bounds = compute_bounds(ccx,\n                                 param_ty.to_ty(ccx.tcx),\n-                                &param.bounds[],\n+                                &param.bounds,\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n@@ -1733,7 +1733,7 @@ fn check_bounds_compatible<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n             ccx.tcx,\n-            &param_bounds.trait_bounds[],\n+            &param_bounds.trait_bounds,\n             |trait_ref| {\n                 let trait_def = ccx.get_trait_def(trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {"}, {"sha": "78f13b37a8238012127ec66826562a994b3d0d42", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -253,7 +253,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                               &format!(\"main has a non-function type: found \\\n                                        `{}`\",\n                                       ppaux::ty_to_string(tcx,\n-                                                       main_t))[]);\n+                                                       main_t)));\n         }\n     }\n }\n@@ -304,7 +304,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             tcx.sess.span_bug(start_span,\n                               &format!(\"start has a non-function type: found \\\n                                        `{}`\",\n-                                      ppaux::ty_to_string(tcx, start_t))[]);\n+                                      ppaux::ty_to_string(tcx, start_t)));\n         }\n     }\n }"}, {"sha": "cd4406b770dbfbe4b113fa70975096189dafb6b5", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -595,7 +595,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 let trait_def = ty::lookup_trait_def(tcx, did);\n                 let predicates = ty::predicates(tcx, ty::mk_self_type(tcx), &trait_def.bounds);\n                 self.add_constraints_from_predicates(&trait_def.generics,\n-                                                     &predicates[],\n+                                                     &predicates,\n                                                      self.covariant);\n \n                 let trait_items = ty::trait_items(tcx, did);\n@@ -652,7 +652,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             None => {\n                 self.tcx().sess.bug(&format!(\n                         \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id))[]);\n+                        self.tcx().map.node_to_string(param_id)));\n             }\n         }\n     }\n@@ -941,7 +941,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n-                            ty.repr(self.tcx()))[]);\n+                            ty.repr(self.tcx())));\n             }\n         }\n     }\n@@ -1071,7 +1071,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     .sess\n                     .bug(&format!(\"unexpected region encountered in variance \\\n                                   inference: {}\",\n-                                 region.repr(self.tcx()))[]);\n+                                 region.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "19c34aff9a81eaffbb3ac6314381f5adf79d2f02", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -2169,7 +2169,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n         let denied = self.vis != ast::Public || self.attrs.iter().any(|a| {\n-            &a.name()[] == \"doc\" && match a.meta_item_list() {\n+            &a.name()[..] == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::contains_name(l, \"no_inline\"),\n                 None => false,\n             }"}, {"sha": "11d9ecac14dd06a89d5d53c54890f8903d3d587e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -25,6 +25,7 @@ use clean;\n use stability_summary::ModuleSummary;\n use html::item_type::ItemType;\n use html::render;\n+use html::escape::Escape;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n \n /// Helper to render an optional visibility with a space after it (if the\n@@ -710,13 +711,14 @@ impl<'a> fmt::Display for Stability<'a> {\n         let Stability(stab) = *self;\n         match *stab {\n             Some(ref stability) => {\n+                let lvl = if stability.deprecated_since.is_empty() {\n+                    format!(\"{}\", stability.level)\n+                } else {\n+                    \"Deprecated\".to_string()\n+                };\n                 write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n-                       lvl = if stability.deprecated_since.is_empty() {\n-                           format!(\"{}\", stability.level)\n-                       } else {\n-                           \"Deprecated\".to_string()\n-                       },\n-                       reason = stability.reason)\n+                       lvl = Escape(&*lvl),\n+                       reason = Escape(&*stability.reason))\n             }\n             None => Ok(())\n         }\n@@ -728,14 +730,15 @@ impl<'a> fmt::Display for ConciseStability<'a> {\n         let ConciseStability(stab) = *self;\n         match *stab {\n             Some(ref stability) => {\n+                let lvl = if stability.deprecated_since.is_empty() {\n+                    format!(\"{}\", stability.level)\n+                } else {\n+                    \"Deprecated\".to_string()\n+                };\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n-                       lvl = if stability.deprecated_since.is_empty() {\n-                           format!(\"{}\", stability.level)\n-                       } else {\n-                           \"Deprecated\".to_string()\n-                       },\n+                       lvl = Escape(&*lvl),\n                        colon = if stability.reason.len() > 0 { \": \" } else { \"\" },\n-                       reason = stability.reason)\n+                       reason = Escape(&*stability.reason))\n             }\n             None => {\n                 write!(f, \"<a class='stability Unmarked' title='No stability level'></a>\")"}, {"sha": "b88e5065b4f9c82b77f2801a82529010b039e446", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -142,7 +142,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n \n             // keywords are also included in the identifier set\n             token::Ident(ident, _is_mod_sep) => {\n-                match &token::get_ident(ident)[] {\n+                match &token::get_ident(ident)[..] {\n                     \"ref\" | \"mut\" => \"kw-2\",\n \n                     \"self\" => \"self\","}, {"sha": "21b7de9ff7c821ab6f68c9439b5c9371a4369d8e", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -374,8 +374,14 @@ a {\n     color: #000;\n     background: transparent;\n }\n-.docblock a { color: #4e8bca; }\n-.docblock a:hover { text-decoration: underline; }\n+\n+.docblock a {\n+    color: #4e8bca;\n+}\n+\n+.docblock a:hover {\n+    text-decoration: underline;\n+}\n \n .content span.trait, .content a.trait, .block a.current.trait { color: #ed9603; }\n .content span.mod, .content a.mod, block a.current.mod { color: #4d76ae; }\n@@ -529,10 +535,19 @@ pre.rust { position: relative; }\n     margin: 0 0 -5px;\n     padding: 0;\n }\n+\n .section-header:hover a:after {\n     content: '\\2002\\00a7\\2002';\n }\n \n+.section-header:hover a {\n+    text-decoration: none;\n+}\n+\n+.section-header a {\n+    color: inherit;\n+}\n+\n .collapse-toggle {\n     font-weight: 300;\n     position: absolute;"}, {"sha": "9181682d176d64c09a8c760aa8a63d2d840c9f1e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n                             Some(list) => {\n-                                list.iter().any(|i| &i.name()[] == \"inline\")\n+                                list.iter().any(|i| &i.name()[..] == \"inline\")\n                             }\n                             None => false,\n                         }"}, {"sha": "e7430f698e9c962e5bdec559d7a18ec3ba70004b", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -13,7 +13,6 @@\n use std::usize;\n use std::default::Default;\n use std::hash::Hash;\n-#[cfg(stage0)] use std::hash::Hasher;\n use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n@@ -158,26 +157,6 @@ impl<\n     }\n }\n \n-#[cfg(stage0)]\n-impl<K, V, S> Encodable for HashMap<K, V, S>\n-    where K: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n-          V: Encodable,\n-          S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>\n-{\n-    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self {\n-                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n-                i += 1;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<K, V, S> Encodable for HashMap<K, V, S>\n     where K: Encodable + Hash + Eq,\n           V: Encodable,\n@@ -196,27 +175,6 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n     }\n }\n \n-#[cfg(stage0)]\n-impl<K, V, S> Decodable for HashMap<K, V, S>\n-    where K: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n-          V: Decodable,\n-          S: HashState + Default,\n-          <S as HashState>::Hasher: Hasher<Output=u64>\n-{\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n-        d.read_map(|d, len| {\n-            let state = Default::default();\n-            let mut map = HashMap::with_capacity_and_hash_state(len, state);\n-            for i in 0..len {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n-                map.insert(key, val);\n-            }\n-            Ok(map)\n-        })\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<K, V, S> Decodable for HashMap<K, V, S>\n     where K: Decodable + Hash + Eq,\n           V: Decodable,\n@@ -236,24 +194,6 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T, S> Encodable for HashSet<T, S>\n-    where T: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n-          S: HashState,\n-          <S as HashState>::Hasher: Hasher<Output=u64>\n-{\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n-                i += 1;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T, S> Encodable for HashSet<T, S>\n     where T: Encodable + Hash + Eq,\n           S: HashState,\n@@ -270,24 +210,6 @@ impl<T, S> Encodable for HashSet<T, S>\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T, S> Decodable for HashSet<T, S>\n-    where T: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n-          S: HashState + Default,\n-          <S as HashState>::Hasher: Hasher<Output=u64>\n-{\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n-        d.read_seq(|d, len| {\n-            let state = Default::default();\n-            let mut set = HashSet::with_capacity_and_hash_state(len, state);\n-            for i in 0..len {\n-                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            Ok(set)\n-        })\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T, S> Decodable for HashSet<T, S>\n     where T: Decodable + Hash + Eq,\n           S: HashState + Default,"}, {"sha": "f5d2b8aed29df340567b370b8b93743fd886b247", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -88,7 +88,6 @@ impl DefaultResizePolicy {\n \n #[test]\n fn test_resize_policy() {\n-    use prelude::v1::*;\n     let rp = DefaultResizePolicy;\n     for n in 0..1000 {\n         assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n@@ -2256,6 +2255,7 @@ mod test_map {\n \n     #[test]\n     fn test_entry_take_doesnt_corrupt() {\n+        #![allow(deprecated)] //rand\n         // Test for #19292\n         fn check(m: &HashMap<isize, ()>) {\n             for k in m.keys() {"}, {"sha": "f9e5044c597616a129a687e25e0f3a35d8e7f786", "filename": "src/libstd/collections/hash/map_stage0.rs", "status": "removed", "additions": 0, "deletions": 2330, "changes": 2330, "blob_url": "https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs?ref=2b01a37ec38db9301239f0c0abcf3c695055b0ff", "patch": "@@ -1,2330 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-use self::Entry::*;\n-use self::SearchResult::*;\n-use self::VacantEntryState::*;\n-\n-use borrow::Borrow;\n-use clone::Clone;\n-use cmp::{max, Eq, PartialEq};\n-use default::Default;\n-use fmt::{self, Debug};\n-use hash::{self, Hash, SipHasher};\n-use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n-use marker::Sized;\n-use mem::{self, replace};\n-use num::{Int, UnsignedInt};\n-use ops::{Deref, FnMut, Index, IndexMut};\n-use option::Option::{self, Some, None};\n-use rand::{self, Rng};\n-use result::Result::{self, Ok, Err};\n-\n-use super::table::{\n-    self,\n-    Bucket,\n-    EmptyBucket,\n-    FullBucket,\n-    FullBucketImm,\n-    FullBucketMut,\n-    RawTable,\n-    SafeHash\n-};\n-use super::table::BucketState::{\n-    Empty,\n-    Full,\n-};\n-use super::state::HashState;\n-\n-const INITIAL_LOG2_CAP: usize = 5;\n-#[unstable(feature = \"std_misc\")]\n-pub const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n-\n-/// The default behavior of HashMap implements a load factor of 90.9%.\n-/// This behavior is characterized by the following condition:\n-///\n-/// - if size > 0.909 * capacity: grow the map\n-#[derive(Clone)]\n-struct DefaultResizePolicy;\n-\n-impl DefaultResizePolicy {\n-    fn new() -> DefaultResizePolicy {\n-        DefaultResizePolicy\n-    }\n-\n-    #[inline]\n-    fn min_capacity(&self, usable_size: usize) -> usize {\n-        // Here, we are rephrasing the logic by specifying the lower limit\n-        // on capacity:\n-        //\n-        // - if `cap < size * 1.1`: grow the map\n-        usable_size * 11 / 10\n-    }\n-\n-    /// An inverse of `min_capacity`, approximately.\n-    #[inline]\n-    fn usable_capacity(&self, cap: usize) -> usize {\n-        // As the number of entries approaches usable capacity,\n-        // min_capacity(size) must be smaller than the internal capacity,\n-        // so that the map is not resized:\n-        // `min_capacity(usable_capacity(x)) <= x`.\n-        // The left-hand side can only be smaller due to flooring by integer\n-        // division.\n-        //\n-        // This doesn't have to be checked for overflow since allocation size\n-        // in bytes will overflow earlier than multiplication by 10.\n-        cap * 10 / 11\n-    }\n-}\n-\n-#[test]\n-fn test_resize_policy() {\n-    use prelude::v1::*;\n-    let rp = DefaultResizePolicy;\n-    for n in 0..1000 {\n-        assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n-        assert!(rp.usable_capacity(rp.min_capacity(n)) <= n);\n-    }\n-}\n-\n-// The main performance trick in this hashmap is called Robin Hood Hashing.\n-// It gains its excellent performance from one essential operation:\n-//\n-//    If an insertion collides with an existing element, and that element's\n-//    \"probe distance\" (how far away the element is from its ideal location)\n-//    is higher than how far we've already probed, swap the elements.\n-//\n-// This massively lowers variance in probe distance, and allows us to get very\n-// high load factors with good performance. The 90% load factor I use is rather\n-// conservative.\n-//\n-// > Why a load factor of approximately 90%?\n-//\n-// In general, all the distances to initial buckets will converge on the mean.\n-// At a load factor of \u03b1, the odds of finding the target bucket after k\n-// probes is approximately 1-\u03b1^k. If we set this equal to 50% (since we converge\n-// on the mean) and set k=8 (64-byte cache line / 8-byte hash), \u03b1=0.92. I round\n-// this down to make the math easier on the CPU and avoid its FPU.\n-// Since on average we start the probing in the middle of a cache line, this\n-// strategy pulls in two cache lines of hashes on every lookup. I think that's\n-// pretty good, but if you want to trade off some space, it could go down to one\n-// cache line on average with an \u03b1 of 0.84.\n-//\n-// > Wait, what? Where did you get 1-\u03b1^k from?\n-//\n-// On the first probe, your odds of a collision with an existing element is \u03b1.\n-// The odds of doing this twice in a row is approximately \u03b1^2. For three times,\n-// \u03b1^3, etc. Therefore, the odds of colliding k times is \u03b1^k. The odds of NOT\n-// colliding after k tries is 1-\u03b1^k.\n-//\n-// The paper from 1986 cited below mentions an implementation which keeps track\n-// of the distance-to-initial-bucket histogram. This approach is not suitable\n-// for modern architectures because it requires maintaining an internal data\n-// structure. This allows very good first guesses, but we are most concerned\n-// with guessing entire cache lines, not individual indexes. Furthermore, array\n-// accesses are no longer linear and in one direction, as we have now. There\n-// is also memory and cache pressure that this would entail that would be very\n-// difficult to properly see in a microbenchmark.\n-//\n-// ## Future Improvements (FIXME!)\n-//\n-// Allow the load factor to be changed dynamically and/or at initialization.\n-//\n-// Also, would it be possible for us to reuse storage when growing the\n-// underlying table? This is exactly the use case for 'realloc', and may\n-// be worth exploring.\n-//\n-// ## Future Optimizations (FIXME!)\n-//\n-// Another possible design choice that I made without any real reason is\n-// parameterizing the raw table over keys and values. Technically, all we need\n-// is the size and alignment of keys and values, and the code should be just as\n-// efficient (well, we might need one for power-of-two size and one for not...).\n-// This has the potential to reduce code bloat in rust executables, without\n-// really losing anything except 4 words (key size, key alignment, val size,\n-// val alignment) which can be passed in to every call of a `RawTable` function.\n-// This would definitely be an avenue worth exploring if people start complaining\n-// about the size of rust executables.\n-//\n-// Annotate exceedingly likely branches in `table::make_hash`\n-// and `search_hashed` to reduce instruction cache pressure\n-// and mispredictions once it becomes possible (blocked on issue #11092).\n-//\n-// Shrinking the table could simply reallocate in place after moving buckets\n-// to the first half.\n-//\n-// The growth algorithm (fragment of the Proof of Correctness)\n-// --------------------\n-//\n-// The growth algorithm is basically a fast path of the naive reinsertion-\n-// during-resize algorithm. Other paths should never be taken.\n-//\n-// Consider growing a robin hood hashtable of capacity n. Normally, we do this\n-// by allocating a new table of capacity `2n`, and then individually reinsert\n-// each element in the old table into the new one. This guarantees that the\n-// new table is a valid robin hood hashtable with all the desired statistical\n-// properties. Remark that the order we reinsert the elements in should not\n-// matter. For simplicity and efficiency, we will consider only linear\n-// reinsertions, which consist of reinserting all elements in the old table\n-// into the new one by increasing order of index. However we will not be\n-// starting our reinsertions from index 0 in general. If we start from index\n-// i, for the purpose of reinsertion we will consider all elements with real\n-// index j < i to have virtual index n + j.\n-//\n-// Our hash generation scheme consists of generating a 64-bit hash and\n-// truncating the most significant bits. When moving to the new table, we\n-// simply introduce a new bit to the front of the hash. Therefore, if an\n-// elements has ideal index i in the old table, it can have one of two ideal\n-// locations in the new table. If the new bit is 0, then the new ideal index\n-// is i. If the new bit is 1, then the new ideal index is n + i. Intuitively,\n-// we are producing two independent tables of size n, and for each element we\n-// independently choose which table to insert it into with equal probability.\n-// However the rather than wrapping around themselves on overflowing their\n-// indexes, the first table overflows into the first, and the first into the\n-// second. Visually, our new table will look something like:\n-//\n-// [yy_xxx_xxxx_xxx|xx_yyy_yyyy_yyy]\n-//\n-// Where x's are elements inserted into the first table, y's are elements\n-// inserted into the second, and _'s are empty sections. We now define a few\n-// key concepts that we will use later. Note that this is a very abstract\n-// perspective of the table. A real resized table would be at least half\n-// empty.\n-//\n-// Theorem: A linear robin hood reinsertion from the first ideal element\n-// produces identical results to a linear naive reinsertion from the same\n-// element.\n-//\n-// FIXME(Gankro, pczarn): review the proof and put it all in a separate doc.rs\n-\n-/// A hash map implementation which uses linear probing with Robin\n-/// Hood bucket stealing.\n-///\n-/// The hashes are all keyed by the task-local random number generator\n-/// on creation by default. This means that the ordering of the keys is\n-/// randomized, but makes the tables more resistant to\n-/// denial-of-service attacks (Hash DoS). This behaviour can be\n-/// overridden with one of the constructors.\n-///\n-/// It is required that the keys implement the `Eq` and `Hash` traits, although\n-/// this can frequently be achieved by using `#[derive(Eq, Hash)]`.\n-///\n-/// Relevant papers/articles:\n-///\n-/// 1. Pedro Celis. [\"Robin Hood Hashing\"](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)\n-/// 2. Emmanuel Goossaert. [\"Robin Hood\n-///    hashing\"](http://codecapsule.com/2013/11/11/robin-hood-hashing/)\n-/// 3. Emmanuel Goossaert. [\"Robin Hood hashing: backward shift\n-///    deletion\"](http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/)\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::collections::HashMap;\n-///\n-/// // type inference lets us omit an explicit type signature (which\n-/// // would be `HashMap<&str, &str>` in this example).\n-/// let mut book_reviews = HashMap::new();\n-///\n-/// // review some books.\n-/// book_reviews.insert(\"Adventures of Huckleberry Finn\",    \"My favorite book.\");\n-/// book_reviews.insert(\"Grimms' Fairy Tales\",               \"Masterpiece.\");\n-/// book_reviews.insert(\"Pride and Prejudice\",               \"Very enjoyable.\");\n-/// book_reviews.insert(\"The Adventures of Sherlock Holmes\", \"Eye lyked it alot.\");\n-///\n-/// // check for a specific one.\n-/// if !book_reviews.contains_key(&(\"Les Mis\u00e9rables\")) {\n-///     println!(\"We've got {} reviews, but Les Mis\u00e9rables ain't one.\",\n-///              book_reviews.len());\n-/// }\n-///\n-/// // oops, this review has a lot of spelling mistakes, let's delete it.\n-/// book_reviews.remove(&(\"The Adventures of Sherlock Holmes\"));\n-///\n-/// // look up the values associated with some keys.\n-/// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n-/// for book in to_find.iter() {\n-///     match book_reviews.get(book) {\n-///         Some(review) => println!(\"{}: {}\", *book, *review),\n-///         None => println!(\"{} is unreviewed.\", *book)\n-///     }\n-/// }\n-///\n-/// // iterate over everything.\n-/// for (book, review) in book_reviews.iter() {\n-///     println!(\"{}: \\\"{}\\\"\", *book, *review);\n-/// }\n-/// ```\n-///\n-/// The easiest way to use `HashMap` with a custom type as key is to derive `Eq` and `Hash`.\n-/// We must also derive `PartialEq`.\n-///\n-/// ```\n-/// use std::collections::HashMap;\n-///\n-/// #[derive(Hash, Eq, PartialEq, Debug)]\n-/// struct Viking {\n-///     name: String,\n-///     country: String,\n-/// }\n-///\n-/// impl Viking {\n-///     /// Create a new Viking.\n-///     fn new(name: &str, country: &str) -> Viking {\n-///         Viking { name: name.to_string(), country: country.to_string() }\n-///     }\n-/// }\n-///\n-/// // Use a HashMap to store the vikings' health points.\n-/// let mut vikings = HashMap::new();\n-///\n-/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n-/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n-/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n-///\n-/// // Use derived implementation to print the status of the vikings.\n-/// for (viking, health) in vikings.iter() {\n-///     println!(\"{:?} has {} hp\", viking, health);\n-/// }\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct HashMap<K, V, S = RandomState> {\n-    // All hashes are keyed on these values, to prevent hash collision attacks.\n-    hash_state: S,\n-\n-    table: RawTable<K, V>,\n-\n-    resize_policy: DefaultResizePolicy,\n-}\n-\n-/// Search for a pre-hashed key.\n-fn search_hashed<K, V, M, F>(table: M,\n-                             hash: SafeHash,\n-                             mut is_match: F)\n-                             -> SearchResult<K, V, M> where\n-    M: Deref<Target=RawTable<K, V>>,\n-    F: FnMut(&K) -> bool,\n-{\n-    let size = table.size();\n-    let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index();\n-\n-    while probe.index() != ib + size {\n-        let full = match probe.peek() {\n-            Empty(b) => return TableRef(b.into_table()), // hit an empty bucket\n-            Full(b) => b\n-        };\n-\n-        if full.distance() + ib < full.index() {\n-            // We can finish the search early if we hit any bucket\n-            // with a lower distance to initial bucket than we've probed.\n-            return TableRef(full.into_table());\n-        }\n-\n-        // If the hash doesn't match, it can't be this one..\n-        if hash == full.hash() {\n-            // If the key doesn't match, it can't be this one..\n-            if is_match(full.read().0) {\n-                return FoundExisting(full);\n-            }\n-        }\n-\n-        probe = full.next();\n-    }\n-\n-    TableRef(probe.into_table())\n-}\n-\n-fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n-    let (empty, retkey, retval) = starting_bucket.take();\n-    let mut gap = match empty.gap_peek() {\n-        Some(b) => b,\n-        None => return (retkey, retval)\n-    };\n-\n-    while gap.full().distance() != 0 {\n-        gap = match gap.shift() {\n-            Some(b) => b,\n-            None => break\n-        };\n-    }\n-\n-    // Now we've done all our shifting. Return the value we grabbed earlier.\n-    (retkey, retval)\n-}\n-\n-/// Perform robin hood bucket stealing at the given `bucket`. You must\n-/// also pass the position of that bucket's initial bucket so we don't have\n-/// to recalculate it.\n-///\n-/// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n-fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n-                        mut ib: usize,\n-                        mut hash: SafeHash,\n-                        mut k: K,\n-                        mut v: V)\n-                        -> &'a mut V {\n-    let starting_index = bucket.index();\n-    let size = {\n-        let table = bucket.table(); // FIXME \"lifetime too short\".\n-        table.size()\n-    };\n-    // There can be at most `size - dib` buckets to displace, because\n-    // in the worst case, there are `size` elements and we already are\n-    // `distance` buckets away from the initial one.\n-    let idx_end = starting_index + size - bucket.distance();\n-\n-    loop {\n-        let (old_hash, old_key, old_val) = bucket.replace(hash, k, v);\n-        loop {\n-            let probe = bucket.next();\n-            assert!(probe.index() != idx_end);\n-\n-            let full_bucket = match probe.peek() {\n-                Empty(bucket) => {\n-                    // Found a hole!\n-                    let b = bucket.put(old_hash, old_key, old_val);\n-                    // Now that it's stolen, just read the value's pointer\n-                    // right out of the table!\n-                    return Bucket::at_index(b.into_table(), starting_index)\n-                               .peek()\n-                               .expect_full()\n-                               .into_mut_refs()\n-                               .1;\n-                },\n-                Full(bucket) => bucket\n-            };\n-\n-            let probe_ib = full_bucket.index() - full_bucket.distance();\n-\n-            bucket = full_bucket;\n-\n-            // Robin hood! Steal the spot.\n-            if ib < probe_ib {\n-                ib = probe_ib;\n-                hash = old_hash;\n-                k = old_key;\n-                v = old_val;\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-/// A result that works like Option<FullBucket<..>> but preserves\n-/// the reference that grants us access to the table in any case.\n-enum SearchResult<K, V, M> {\n-    // This is an entry that holds the given key:\n-    FoundExisting(FullBucket<K, V, M>),\n-\n-    // There was no such entry. The reference is given back:\n-    TableRef(M)\n-}\n-\n-impl<K, V, M> SearchResult<K, V, M> {\n-    fn into_option(self) -> Option<FullBucket<K, V, M>> {\n-        match self {\n-            FoundExisting(bucket) => Some(bucket),\n-            TableRef(_) => None\n-        }\n-    }\n-}\n-\n-impl<K, V, S, H> HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash<H> {\n-        table::make_hash(&self.hash_state, x)\n-    }\n-\n-    /// Search for a key, yielding the index if it's found in the hashtable.\n-    /// If you already have the hash for the key lying around, use\n-    /// search_hashed.\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n-        where K: Borrow<Q>, Q: Eq + Hash<H>\n-    {\n-        let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n-            .into_option()\n-    }\n-\n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n-        where K: Borrow<Q>, Q: Eq + Hash<H>\n-    {\n-        let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n-            .into_option()\n-    }\n-\n-    // The caller should ensure that invariants by Robin Hood Hashing hold.\n-    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n-        let cap = self.table.capacity();\n-        let mut buckets = Bucket::new(&mut self.table, hash);\n-        let ib = buckets.index();\n-\n-        while buckets.index() != ib + cap {\n-            // We don't need to compare hashes for value swap.\n-            // Not even DIBs for Robin Hood.\n-            buckets = match buckets.peek() {\n-                Empty(empty) => {\n-                    empty.put(hash, k, v);\n-                    return;\n-                }\n-                Full(b) => b.into_bucket()\n-            };\n-            buckets.next();\n-        }\n-        panic!(\"Internal HashMap error: Out of space.\");\n-    }\n-}\n-\n-impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n-    /// Create an empty HashMap.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> HashMap<K, V, RandomState> {\n-        Default::default()\n-    }\n-\n-    /// Creates an empty hash map with the given initial capacity.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n-        HashMap::with_capacity_and_hash_state(capacity, Default::default())\n-    }\n-}\n-\n-impl<K, V, S, H> HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    /// Creates an empty hashmap which will use the given hasher to hash keys.\n-    ///\n-    /// The creates map has the default initial capacity.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut map = HashMap::with_hash_state(s);\n-    /// map.insert(1, 2);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n-        HashMap {\n-            hash_state:    hash_state,\n-            resize_policy: DefaultResizePolicy::new(),\n-            table:         RawTable::new(0),\n-        }\n-    }\n-\n-    /// Create an empty HashMap with space for at least `capacity`\n-    /// elements, using `hasher` to hash the keys.\n-    ///\n-    /// Warning: `hasher` is normally randomly generated, and\n-    /// is designed to allow HashMaps to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting it\n-    /// manually using this function can expose a DoS attack vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n-    /// map.insert(1, 2);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n-                                        -> HashMap<K, V, S> {\n-        let resize_policy = DefaultResizePolicy::new();\n-        let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n-        let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n-        assert!(internal_cap >= capacity, \"capacity overflow\");\n-        HashMap {\n-            hash_state:    hash_state,\n-            resize_policy: resize_policy,\n-            table:         RawTable::new(internal_cap),\n-        }\n-    }\n-\n-    /// Returns the number of elements the map can hold without reallocating.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let map: HashMap<int, int> = HashMap::with_capacity(100);\n-    /// assert!(map.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.resize_policy.usable_capacity(self.table.capacity())\n-    }\n-\n-    /// Reserves capacity for at least `additional` more elements to be inserted\n-    /// in the `HashMap`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new allocation size overflows `usize`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n-    /// map.reserve(10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: usize) {\n-        let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n-        let min_cap = self.resize_policy.min_capacity(new_size);\n-\n-        // An invalid value shouldn't make us run out of space. This includes\n-        // an overflow check.\n-        assert!(new_size <= min_cap);\n-\n-        if self.table.capacity() < min_cap {\n-            let new_capacity = max(min_cap.next_power_of_two(), INITIAL_CAPACITY);\n-            self.resize(new_capacity);\n-        }\n-    }\n-\n-    /// Resizes the internal vectors to a new capacity. It's your responsibility to:\n-    ///   1) Make sure the new capacity is enough for all the elements, accounting\n-    ///      for the load factor.\n-    ///   2) Ensure new_capacity is a power of two or zero.\n-    fn resize(&mut self, new_capacity: usize) {\n-        assert!(self.table.size() <= new_capacity);\n-        assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n-\n-        let mut old_table = replace(&mut self.table, RawTable::new(new_capacity));\n-        let old_size = old_table.size();\n-\n-        if old_table.capacity() == 0 || old_table.size() == 0 {\n-            return;\n-        }\n-\n-        // Grow the table.\n-        // Specialization of the other branch.\n-        let mut bucket = Bucket::first(&mut old_table);\n-\n-        // \"So a few of the first shall be last: for many be called,\n-        // but few chosen.\"\n-        //\n-        // We'll most likely encounter a few buckets at the beginning that\n-        // have their initial buckets near the end of the table. They were\n-        // placed at the beginning as the probe wrapped around the table\n-        // during insertion. We must skip forward to a bucket that won't\n-        // get reinserted too early and won't unfairly steal others spot.\n-        // This eliminates the need for robin hood.\n-        loop {\n-            bucket = match bucket.peek() {\n-                Full(full) => {\n-                    if full.distance() == 0 {\n-                        // This bucket occupies its ideal spot.\n-                        // It indicates the start of another \"cluster\".\n-                        bucket = full.into_bucket();\n-                        break;\n-                    }\n-                    // Leaving this bucket in the last cluster for later.\n-                    full.into_bucket()\n-                }\n-                Empty(b) => {\n-                    // Encountered a hole between clusters.\n-                    b.into_bucket()\n-                }\n-            };\n-            bucket.next();\n-        }\n-\n-        // This is how the buckets might be laid out in memory:\n-        // ($ marks an initialized bucket)\n-        //  ________________\n-        // |$$$_$$$$$$_$$$$$|\n-        //\n-        // But we've skipped the entire initial cluster of buckets\n-        // and will continue iteration in this order:\n-        //  ________________\n-        //     |$$$$$$_$$$$$\n-        //                  ^ wrap around once end is reached\n-        //  ________________\n-        //  $$$_____________|\n-        //    ^ exit once table.size == 0\n-        loop {\n-            bucket = match bucket.peek() {\n-                Full(bucket) => {\n-                    let h = bucket.hash();\n-                    let (b, k, v) = bucket.take();\n-                    self.insert_hashed_ordered(h, k, v);\n-                    {\n-                        let t = b.table(); // FIXME \"lifetime too short\".\n-                        if t.size() == 0 { break }\n-                    };\n-                    b.into_bucket()\n-                }\n-                Empty(b) => b.into_bucket()\n-            };\n-            bucket.next();\n-        }\n-\n-        assert_eq!(self.table.size(), old_size);\n-    }\n-\n-    /// Shrinks the capacity of the map as much as possible. It will drop\n-    /// down as much as possible while maintaining the internal rules\n-    /// and possibly leaving some space in accordance with the resize policy.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map: HashMap<int, int> = HashMap::with_capacity(100);\n-    /// map.insert(1, 2);\n-    /// map.insert(3, 4);\n-    /// assert!(map.capacity() >= 100);\n-    /// map.shrink_to_fit();\n-    /// assert!(map.capacity() >= 2);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn shrink_to_fit(&mut self) {\n-        let min_capacity = self.resize_policy.min_capacity(self.len());\n-        let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n-\n-        // An invalid value shouldn't make us run out of space.\n-        debug_assert!(self.len() <= min_capacity);\n-\n-        if self.table.capacity() != min_capacity {\n-            let old_table = replace(&mut self.table, RawTable::new(min_capacity));\n-            let old_size = old_table.size();\n-\n-            // Shrink the table. Naive algorithm for resizing:\n-            for (h, k, v) in old_table.into_iter() {\n-                self.insert_hashed_nocheck(h, k, v);\n-            }\n-\n-            debug_assert_eq!(self.table.size(), old_size);\n-        }\n-    }\n-\n-    /// Insert a pre-hashed key-value pair, without first checking\n-    /// that there's enough room in the buckets. Returns a reference to the\n-    /// newly insert value.\n-    ///\n-    /// If the key already exists, the hashtable will be returned untouched\n-    /// and a reference to the existing element will be returned.\n-    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V {\n-        self.insert_or_replace_with(hash, k, v, |_, _, _| ())\n-    }\n-\n-    fn insert_or_replace_with<'a, F>(&'a mut self,\n-                                     hash: SafeHash,\n-                                     k: K,\n-                                     v: V,\n-                                     mut found_existing: F)\n-                                     -> &'a mut V where\n-        F: FnMut(&mut K, &mut V, V),\n-    {\n-        // Worst case, we'll find one empty bucket among `size + 1` buckets.\n-        let size = self.table.size();\n-        let mut probe = Bucket::new(&mut self.table, hash);\n-        let ib = probe.index();\n-\n-        loop {\n-            let mut bucket = match probe.peek() {\n-                Empty(bucket) => {\n-                    // Found a hole!\n-                    return bucket.put(hash, k, v).into_mut_refs().1;\n-                }\n-                Full(bucket) => bucket\n-            };\n-\n-            // hash matches?\n-            if bucket.hash() == hash {\n-                // key matches?\n-                if k == *bucket.read_mut().0 {\n-                    let (bucket_k, bucket_v) = bucket.into_mut_refs();\n-                    debug_assert!(k == *bucket_k);\n-                    // Key already exists. Get its reference.\n-                    found_existing(bucket_k, bucket_v, v);\n-                    return bucket_v;\n-                }\n-            }\n-\n-            let robin_ib = bucket.index() as int - bucket.distance() as int;\n-\n-            if (ib as int) < robin_ib {\n-                // Found a luckier bucket than me. Better steal his spot.\n-                return robin_hood(bucket, robin_ib as usize, hash, k, v);\n-            }\n-\n-            probe = bucket.next();\n-            assert!(probe.index() != ib + size + 1);\n-        }\n-    }\n-\n-    /// An iterator visiting all keys in arbitrary order.\n-    /// Iterator element type is `&'a K`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for key in map.keys() {\n-    ///     println!(\"{}\", key);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n-\n-        Keys { inner: self.iter().map(first) }\n-    }\n-\n-    /// An iterator visiting all values in arbitrary order.\n-    /// Iterator element type is `&'a V`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for val in map.values() {\n-    ///     println!(\"{}\", val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        fn second<A, B>((_, b): (A, B)) -> B { b }\n-        let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n-\n-        Values { inner: self.iter().map(second) }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order.\n-    /// Iterator element type is `(&'a K, &'a V)`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for (key, val) in map.iter() {\n-    ///     println!(\"key: {} val: {}\", key, val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<K, V> {\n-        Iter { inner: self.table.iter() }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order,\n-    /// with mutable references to the values.\n-    /// Iterator element type is `(&'a K, &'a mut V)`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// // Update all values\n-    /// for (_, val) in map.iter_mut() {\n-    ///     *val *= 2;\n-    /// }\n-    ///\n-    /// for (key, val) in map.iter() {\n-    ///     println!(\"key: {} val: {}\", key, val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n-        IterMut { inner: self.table.iter_mut() }\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each key-value\n-    /// pair out of the map in arbitrary order. The map cannot be used after\n-    /// calling this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// // Not possible with .iter()\n-    /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<K, V> {\n-        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n-        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n-\n-        IntoIter {\n-            inner: self.table.into_iter().map(last_two)\n-        }\n-    }\n-\n-    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, key: K) -> Entry<K, V> {\n-        // Gotta resize now.\n-        self.reserve(1);\n-\n-        let hash = self.make_hash(&key);\n-        search_entry_hashed(&mut self.table, hash, key)\n-    }\n-\n-    /// Returns the number of elements in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// assert_eq!(a.len(), 0);\n-    /// a.insert(1, \"a\");\n-    /// assert_eq!(a.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.table.size() }\n-\n-    /// Returns true if the map contains no elements.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// assert!(a.is_empty());\n-    /// a.insert(1, \"a\");\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n-    /// allocated memory for reuse.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.insert(2, \"b\");\n-    ///\n-    /// for (k, v) in a.drain().take(1) {\n-    ///     assert!(k == 1 || k == 2);\n-    ///     assert!(v == \"a\" || v == \"b\");\n-    /// }\n-    ///\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn drain(&mut self) -> Drain<K, V> {\n-        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n-        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two; // coerce to fn pointer\n-\n-        Drain {\n-            inner: self.table.drain().map(last_two),\n-        }\n-    }\n-\n-    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n-    /// for reuse.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.clear();\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn clear(&mut self) {\n-        self.drain();\n-    }\n-\n-    /// Returns a reference to the value corresponding to the key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the key type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.get(&1), Some(&\"a\"));\n-    /// assert_eq!(map.get(&2), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where K: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.search(k).map(|bucket| bucket.into_refs().1)\n-    }\n-\n-    /// Returns true if the map contains a value for the specified key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the key type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.contains_key(&1), true);\n-    /// assert_eq!(map.contains_key(&2), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where K: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.search(k).is_some()\n-    }\n-\n-    /// Returns a mutable reference to the value corresponding to the key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the key type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(1, \"a\");\n-    /// match map.get_mut(&1) {\n-    ///     Some(x) => *x = \"b\",\n-    ///     None => (),\n-    /// }\n-    /// assert_eq!(map[1], \"b\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where K: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n-    }\n-\n-    /// Inserts a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise, `None` is returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.insert(37, \"a\"), None);\n-    /// assert_eq!(map.is_empty(), false);\n-    ///\n-    /// map.insert(37, \"b\");\n-    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        let hash = self.make_hash(&k);\n-        self.reserve(1);\n-\n-        let mut retval = None;\n-        self.insert_or_replace_with(hash, k, v, |_, val_ref, val| {\n-            retval = Some(replace(val_ref, val));\n-        });\n-        retval\n-    }\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    ///\n-    /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the key type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), Some(\"a\"));\n-    /// assert_eq!(map.remove(&1), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where K: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        if self.table.size() == 0 {\n-            return None\n-        }\n-\n-        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n-    }\n-}\n-\n-fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n-        -> Entry<'a, K, V>\n-{\n-    // Worst case, we'll find one empty bucket among `size + 1` buckets.\n-    let size = table.size();\n-    let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index();\n-\n-    loop {\n-        let bucket = match probe.peek() {\n-            Empty(bucket) => {\n-                // Found a hole!\n-                return Vacant(VacantEntry {\n-                    hash: hash,\n-                    key: k,\n-                    elem: NoElem(bucket),\n-                });\n-            },\n-            Full(bucket) => bucket\n-        };\n-\n-        // hash matches?\n-        if bucket.hash() == hash {\n-            // key matches?\n-            if k == *bucket.read().0 {\n-                return Occupied(OccupiedEntry{\n-                    elem: bucket,\n-                });\n-            }\n-        }\n-\n-        let robin_ib = bucket.index() as int - bucket.distance() as int;\n-\n-        if (ib as int) < robin_ib {\n-            // Found a luckier bucket than me. Better steal his spot.\n-            return Vacant(VacantEntry {\n-                hash: hash,\n-                key: k,\n-                elem: NeqElem(bucket, robin_ib as usize),\n-            });\n-        }\n-\n-        probe = bucket.next();\n-        assert!(probe.index() != ib + size + 1);\n-    }\n-}\n-\n-impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n-    where K: Eq + Hash<H>, V: PartialEq,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n-        if self.len() != other.len() { return false; }\n-\n-        self.iter().all(|(key, value)|\n-            other.get(key).map_or(false, |v| *value == *v)\n-        )\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Eq for HashMap<K, V, S>\n-    where K: Eq + Hash<H>, V: Eq,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Debug for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Debug, V: Debug,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"HashMap {{\"));\n-\n-        for (i, (k, v)) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{:?}: {:?}\", *k, *v));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Default for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn default() -> HashMap<K, V, S> {\n-        HashMap::with_hash_state(Default::default())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Borrow<Q>,\n-          Q: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = V;\n-\n-    #[inline]\n-    fn index<'a>(&'a self, index: &Q) -> &'a V {\n-        self.get(index).expect(\"no entry found for key\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Borrow<Q>,\n-          Q: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n-        self.get_mut(index).expect(\"no entry found for key\")\n-    }\n-}\n-\n-/// HashMap iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, K: 'a, V: 'a> {\n-    inner: table::Iter<'a, K, V>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, K, V> Clone for Iter<'a, K, V> {\n-    fn clone(&self) -> Iter<'a, K, V> {\n-        Iter {\n-            inner: self.inner.clone()\n-        }\n-    }\n-}\n-\n-/// HashMap mutable values iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, K: 'a, V: 'a> {\n-    inner: table::IterMut<'a, K, V>\n-}\n-\n-/// HashMap move iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<K, V> {\n-    inner: iter::Map<table::IntoIter<K, V>, fn((SafeHash, K, V)) -> (K, V)>\n-}\n-\n-/// HashMap keys iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, K, V> Clone for Keys<'a, K, V> {\n-    fn clone(&self) -> Keys<'a, K, V> {\n-        Keys {\n-            inner: self.inner.clone()\n-        }\n-    }\n-}\n-\n-/// HashMap values iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, K, V> Clone for Values<'a, K, V> {\n-    fn clone(&self) -> Values<'a, K, V> {\n-        Values {\n-            inner: self.inner.clone()\n-        }\n-    }\n-}\n-\n-/// HashMap drain iterator.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"matches collection reform specification, waiting for dust to settle\")]\n-pub struct Drain<'a, K: 'a, V: 'a> {\n-    inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n-}\n-\n-/// A view into a single occupied location in a HashMap.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n-pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n-}\n-\n-/// A view into a single empty location in a HashMap.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n-pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    hash: SafeHash,\n-    key: K,\n-    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n-}\n-\n-/// A view into a single location in a map, which may be vacant or occupied.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n-pub enum Entry<'a, K: 'a, V: 'a> {\n-    /// An occupied Entry.\n-    Occupied(OccupiedEntry<'a, K, V>),\n-    /// A vacant Entry.\n-    Vacant(VacantEntry<'a, K, V>),\n-}\n-\n-/// Possible states of a VacantEntry.\n-enum VacantEntryState<K, V, M> {\n-    /// The index is occupied, but the key to insert has precedence,\n-    /// and will kick the current one out on insertion.\n-    NeqElem(FullBucket<K, V, M>, usize),\n-    /// The index is genuinely vacant.\n-    NoElem(EmptyBucket<K, V, M>),\n-}\n-\n-impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = (&'a K, &'a V);\n-    type IntoIter = Iter<'a, K, V>;\n-\n-    fn into_iter(self) -> Iter<'a, K, V> {\n-        self.iter()\n-    }\n-}\n-\n-impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = (&'a K, &'a mut V);\n-    type IntoIter = IterMut<'a, K, V>;\n-\n-    fn into_iter(mut self) -> IterMut<'a, K, V> {\n-        self.iter_mut()\n-    }\n-}\n-\n-impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = (K, V);\n-    type IntoIter = IntoIter<K, V>;\n-\n-    fn into_iter(self) -> IntoIter<K, V> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Iter<'a, K, V> {\n-    type Item = (&'a K, &'a V);\n-\n-    #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n-    type Item = (&'a K, &'a mut V);\n-\n-    #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> Iterator for IntoIter<K, V> {\n-    type Item = (K, V);\n-\n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Keys<'a, K, V> {\n-    type Item = &'a K;\n-\n-    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Values<'a, K, V> {\n-    type Item = &'a V;\n-\n-    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> Iterator for Drain<'a, K, V> {\n-    type Item = (K, V);\n-\n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n-}\n-\n-#[unstable(feature = \"std_misc\",\n-           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n-impl<'a, K, V> Entry<'a, K, V> {\n-    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant.\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n-        match self {\n-            Occupied(entry) => Ok(entry.into_mut()),\n-            Vacant(entry) => Err(entry),\n-        }\n-    }\n-}\n-\n-impl<'a, K, V> OccupiedEntry<'a, K, V> {\n-    /// Gets a reference to the value in the entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> &V {\n-        self.elem.read().1\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut V {\n-        self.elem.read_mut().1\n-    }\n-\n-    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n-    /// with a lifetime bound to the map itself\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_mut(self) -> &'a mut V {\n-        self.elem.into_mut_refs().1\n-    }\n-\n-    /// Sets the value of the entry, and returns the entry's old value\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, mut value: V) -> V {\n-        let old_value = self.get_mut();\n-        mem::swap(&mut value, old_value);\n-        value\n-    }\n-\n-    /// Takes the value out of the entry, and returns it\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(self) -> V {\n-        pop_internal(self.elem).1\n-    }\n-}\n-\n-impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n-    /// Sets the value of the entry with the VacantEntry's key,\n-    /// and returns a mutable reference to it\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n-        match self.elem {\n-            NeqElem(bucket, ib) => {\n-                robin_hood(bucket, ib, self.hash, self.key, value)\n-            }\n-            NoElem(bucket) => {\n-                bucket.put(self.hash, self.key, value).into_mut_refs().1\n-            }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n-        let iter = iter.into_iter();\n-        let lower = iter.size_hint().0;\n-        let mut map = HashMap::with_capacity_and_hash_state(lower,\n-                                                            Default::default());\n-        map.extend(iter);\n-        map\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n-    }\n-}\n-\n-\n-/// `RandomState` is the default state for `HashMap` types.\n-///\n-/// A particular instance `RandomState` will create the same instances of\n-/// `Hasher`, but the hashers created by two different `RandomState`\n-/// instances are unlikely to produce the same result for the same values.\n-#[derive(Clone)]\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-pub struct RandomState {\n-    k0: u64,\n-    k1: u64,\n-}\n-\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-impl RandomState {\n-    /// Construct a new `RandomState` that is initialized with random keys.\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn new() -> RandomState {\n-        let mut r = rand::thread_rng();\n-        RandomState { k0: r.gen(), k1: r.gen() }\n-    }\n-}\n-\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-impl HashState for RandomState {\n-    type Hasher = Hasher;\n-    fn hasher(&self) -> Hasher {\n-        Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n-    }\n-}\n-\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-impl Default for RandomState {\n-    #[inline]\n-    fn default() -> RandomState {\n-        RandomState::new()\n-    }\n-}\n-\n-/// A hasher implementation which is generated from `RandomState` instances.\n-///\n-/// This is the default hasher used in a `HashMap` to hash keys. Types do not\n-/// typically declare an ability to explicitly hash into this particular type,\n-/// but rather in a `H: hash::Writer` type parameter.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-pub struct Hasher { inner: SipHasher }\n-\n-impl hash::Writer for Hasher {\n-    fn write(&mut self, data: &[u8]) {\n-        hash::Writer::write(&mut self.inner, data)\n-    }\n-}\n-\n-impl hash::Hasher for Hasher {\n-    type Output = u64;\n-    fn reset(&mut self) { hash::Hasher::reset(&mut self.inner) }\n-    fn finish(&self) -> u64 { self.inner.finish() }\n-}\n-\n-#[cfg(test)]\n-mod test_map {\n-    use prelude::v1::*;\n-\n-    use super::HashMap;\n-    use super::Entry::{Occupied, Vacant};\n-    use iter::{range_inclusive, range_step_inclusive, repeat};\n-    use cell::RefCell;\n-    use rand::{weak_rng, Rng};\n-\n-    #[test]\n-    fn test_create_capacity_zero() {\n-        let mut m = HashMap::with_capacity(0);\n-\n-        assert!(m.insert(1, 1).is_none());\n-\n-        assert!(m.contains_key(&1));\n-        assert!(!m.contains_key(&0));\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut m = HashMap::new();\n-        assert_eq!(m.len(), 0);\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(m.len(), 1);\n-        assert!(m.insert(2, 4).is_none());\n-        assert_eq!(m.len(), 2);\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&2).unwrap(), 4);\n-    }\n-\n-    thread_local! { static DROP_VECTOR: RefCell<Vec<int>> = RefCell::new(Vec::new()) }\n-\n-    #[derive(Hash, PartialEq, Eq)]\n-    struct Dropable {\n-        k: usize\n-    }\n-\n-    impl Dropable {\n-        fn new(k: usize) -> Dropable {\n-            DROP_VECTOR.with(|slot| {\n-                slot.borrow_mut()[k] += 1;\n-            });\n-\n-            Dropable { k: k }\n-        }\n-    }\n-\n-    impl Drop for Dropable {\n-        fn drop(&mut self) {\n-            DROP_VECTOR.with(|slot| {\n-                slot.borrow_mut()[self.k] -= 1;\n-            });\n-        }\n-    }\n-\n-    impl Clone for Dropable {\n-        fn clone(&self) -> Dropable {\n-            Dropable::new(self.k)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drops() {\n-        DROP_VECTOR.with(|slot| {\n-            *slot.borrow_mut() = repeat(0).take(200).collect();\n-        });\n-\n-        {\n-            let mut m = HashMap::new();\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                }\n-            });\n-\n-            for i in 0..100 {\n-                let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i+100);\n-                m.insert(d1, d2);\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            for i in 0..50 {\n-                let k = Dropable::new(i);\n-                let v = m.remove(&k);\n-\n-                assert!(v.is_some());\n-\n-                DROP_VECTOR.with(|v| {\n-                    assert_eq!(v.borrow()[i], 1);\n-                    assert_eq!(v.borrow()[i+100], 1);\n-                });\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..50 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                    assert_eq!(v.borrow()[i+100], 0);\n-                }\n-\n-                for i in 50..100 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                    assert_eq!(v.borrow()[i+100], 1);\n-                }\n-            });\n-        }\n-\n-        DROP_VECTOR.with(|v| {\n-            for i in 0..200 {\n-                assert_eq!(v.borrow()[i], 0);\n-            }\n-        });\n-    }\n-\n-    #[test]\n-    fn test_move_iter_drops() {\n-        DROP_VECTOR.with(|v| {\n-            *v.borrow_mut() = repeat(0).take(200).collect();\n-        });\n-\n-        let hm = {\n-            let mut hm = HashMap::new();\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                }\n-            });\n-\n-            for i in 0..100 {\n-                let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i+100);\n-                hm.insert(d1, d2);\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            hm\n-        };\n-\n-        // By the way, ensure that cloning doesn't screw up the dropping.\n-        drop(hm.clone());\n-\n-        {\n-            let mut half = hm.into_iter().take(50);\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            for _ in half.by_ref() {}\n-\n-            DROP_VECTOR.with(|v| {\n-                let nk = (0..100).filter(|&i| {\n-                    v.borrow()[i] == 1\n-                }).count();\n-\n-                let nv = (0..100).filter(|&i| {\n-                    v.borrow()[i+100] == 1\n-                }).count();\n-\n-                assert_eq!(nk, 50);\n-                assert_eq!(nv, 50);\n-            });\n-        };\n-\n-        DROP_VECTOR.with(|v| {\n-            for i in 0..200 {\n-                assert_eq!(v.borrow()[i], 0);\n-            }\n-        });\n-    }\n-\n-    #[test]\n-    fn test_empty_pop() {\n-        let mut m: HashMap<int, bool> = HashMap::new();\n-        assert_eq!(m.remove(&0), None);\n-    }\n-\n-    #[test]\n-    fn test_lots_of_insertions() {\n-        let mut m = HashMap::new();\n-\n-        // Try this a few times to make sure we never screw up the hashmap's\n-        // internal state.\n-        for _ in 0..10 {\n-            assert!(m.is_empty());\n-\n-            for i in range_inclusive(1, 1000) {\n-                assert!(m.insert(i, i).is_none());\n-\n-                for j in range_inclusive(1, i) {\n-                    let r = m.get(&j);\n-                    assert_eq!(r, Some(&j));\n-                }\n-\n-                for j in range_inclusive(i+1, 1000) {\n-                    let r = m.get(&j);\n-                    assert_eq!(r, None);\n-                }\n-            }\n-\n-            for i in range_inclusive(1001, 2000) {\n-                assert!(!m.contains_key(&i));\n-            }\n-\n-            // remove forwards\n-            for i in range_inclusive(1, 1000) {\n-                assert!(m.remove(&i).is_some());\n-\n-                for j in range_inclusive(1, i) {\n-                    assert!(!m.contains_key(&j));\n-                }\n-\n-                for j in range_inclusive(i+1, 1000) {\n-                    assert!(m.contains_key(&j));\n-                }\n-            }\n-\n-            for i in range_inclusive(1, 1000) {\n-                assert!(!m.contains_key(&i));\n-            }\n-\n-            for i in range_inclusive(1, 1000) {\n-                assert!(m.insert(i, i).is_none());\n-            }\n-\n-            // remove backwards\n-            for i in range_step_inclusive(1000, 1, -1) {\n-                assert!(m.remove(&i).is_some());\n-\n-                for j in range_inclusive(i, 1000) {\n-                    assert!(!m.contains_key(&j));\n-                }\n-\n-                for j in range_inclusive(1, i-1) {\n-                    assert!(m.contains_key(&j));\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_find_mut() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 12).is_none());\n-        assert!(m.insert(2, 8).is_none());\n-        assert!(m.insert(5, 14).is_none());\n-        let new = 100;\n-        match m.get_mut(&5) {\n-            None => panic!(), Some(x) => *x = new\n-        }\n-        assert_eq!(m.get(&5), Some(&new));\n-    }\n-\n-    #[test]\n-    fn test_insert_overwrite() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert!(!m.insert(1, 3).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 3);\n-    }\n-\n-    #[test]\n-    fn test_insert_conflicts() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(m.insert(5, 3).is_none());\n-        assert!(m.insert(9, 4).is_none());\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-    }\n-\n-    #[test]\n-    fn test_conflict_remove() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert!(m.insert(5, 3).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert!(m.insert(9, 4).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert!(m.remove(&1).is_some());\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(!m.is_empty());\n-        assert!(m.remove(&1).is_some());\n-        assert!(m.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_pop() {\n-        let mut m = HashMap::new();\n-        m.insert(1, 2);\n-        assert_eq!(m.remove(&1), Some(2));\n-        assert_eq!(m.remove(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_iterate() {\n-        let mut m = HashMap::with_capacity(4);\n-        for i in 0..32 {\n-            assert!(m.insert(i, i*2).is_none());\n-        }\n-        assert_eq!(m.len(), 32);\n-\n-        let mut observed: u32 = 0;\n-\n-        for (k, v) in &m {\n-            assert_eq!(*v, *k * 2);\n-            observed |= 1 << *k;\n-        }\n-        assert_eq!(observed, 0xFFFF_FFFF);\n-    }\n-\n-    #[test]\n-    fn test_keys() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map: HashMap<_, _> = vec.into_iter().collect();\n-        let keys: Vec<_> = map.keys().cloned().collect();\n-        assert_eq!(keys.len(), 3);\n-        assert!(keys.contains(&1));\n-        assert!(keys.contains(&2));\n-        assert!(keys.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_values() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map: HashMap<_, _> = vec.into_iter().collect();\n-        let values: Vec<_> = map.values().cloned().collect();\n-        assert_eq!(values.len(), 3);\n-        assert!(values.contains(&'a'));\n-        assert!(values.contains(&'b'));\n-        assert!(values.contains(&'c'));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let mut m = HashMap::new();\n-        assert!(m.get(&1).is_none());\n-        m.insert(1, 2);\n-        match m.get(&1) {\n-            None => panic!(),\n-            Some(v) => assert_eq!(*v, 2)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut m1 = HashMap::new();\n-        m1.insert(1, 2);\n-        m1.insert(2, 3);\n-        m1.insert(3, 4);\n-\n-        let mut m2 = HashMap::new();\n-        m2.insert(1, 2);\n-        m2.insert(2, 3);\n-\n-        assert!(m1 != m2);\n-\n-        m2.insert(3, 4);\n-\n-        assert_eq!(m1, m2);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut map = HashMap::new();\n-        let empty: HashMap<i32, i32> = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(3, 4);\n-\n-        let map_str = format!(\"{:?}\", map);\n-\n-        assert!(map_str == \"HashMap {1: 2, 3: 4}\" ||\n-                map_str == \"HashMap {3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"HashMap {}\");\n-    }\n-\n-    #[test]\n-    fn test_expand() {\n-        let mut m = HashMap::new();\n-\n-        assert_eq!(m.len(), 0);\n-        assert!(m.is_empty());\n-\n-        let mut i = 0;\n-        let old_cap = m.table.capacity();\n-        while old_cap == m.table.capacity() {\n-            m.insert(i, i);\n-            i += 1;\n-        }\n-\n-        assert_eq!(m.len(), i);\n-        assert!(!m.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_behavior_resize_policy() {\n-        let mut m = HashMap::new();\n-\n-        assert_eq!(m.len(), 0);\n-        assert_eq!(m.table.capacity(), 0);\n-        assert!(m.is_empty());\n-\n-        m.insert(0, 0);\n-        m.remove(&0);\n-        assert!(m.is_empty());\n-        let initial_cap = m.table.capacity();\n-        m.reserve(initial_cap);\n-        let cap = m.table.capacity();\n-\n-        assert_eq!(cap, initial_cap * 2);\n-\n-        let mut i = 0;\n-        for _ in 0..cap * 3 / 4 {\n-            m.insert(i, i);\n-            i += 1;\n-        }\n-        // three quarters full\n-\n-        assert_eq!(m.len(), i);\n-        assert_eq!(m.table.capacity(), cap);\n-\n-        for _ in 0..cap / 4 {\n-            m.insert(i, i);\n-            i += 1;\n-        }\n-        // half full\n-\n-        let new_cap = m.table.capacity();\n-        assert_eq!(new_cap, cap * 2);\n-\n-        for _ in 0..cap / 2 - 1 {\n-            i -= 1;\n-            m.remove(&i);\n-            assert_eq!(m.table.capacity(), new_cap);\n-        }\n-        // A little more than one quarter full.\n-        m.shrink_to_fit();\n-        assert_eq!(m.table.capacity(), cap);\n-        // again, a little more than half full\n-        for _ in 0..cap / 2 - 1 {\n-            i -= 1;\n-            m.remove(&i);\n-        }\n-        m.shrink_to_fit();\n-\n-        assert_eq!(m.len(), i);\n-        assert!(!m.is_empty());\n-        assert_eq!(m.table.capacity(), initial_cap);\n-    }\n-\n-    #[test]\n-    fn test_reserve_shrink_to_fit() {\n-        let mut m = HashMap::new();\n-        m.insert(0, 0);\n-        m.remove(&0);\n-        assert!(m.capacity() >= m.len());\n-        for i in 0..128 {\n-            m.insert(i, i);\n-        }\n-        m.reserve(256);\n-\n-        let usable_cap = m.capacity();\n-        for i in 128..(128 + 256) {\n-            m.insert(i, i);\n-            assert_eq!(m.capacity(), usable_cap);\n-        }\n-\n-        for i in 100..(128 + 256) {\n-            assert_eq!(m.remove(&i), Some(i));\n-        }\n-        m.shrink_to_fit();\n-\n-        assert_eq!(m.len(), 100);\n-        assert!(!m.is_empty());\n-        assert!(m.capacity() >= m.len());\n-\n-        for i in 0..100 {\n-            assert_eq!(m.remove(&i), Some(i));\n-        }\n-        m.shrink_to_fit();\n-        m.insert(0, 0);\n-\n-        assert_eq!(m.len(), 1);\n-        assert!(m.capacity() >= m.len());\n-        assert_eq!(m.remove(&0), Some(0));\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        for &(k, v) in &xs {\n-            assert_eq!(map.get(&k), Some(&v));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_size_hint() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.size_hint(), (3, Some(3)));\n-    }\n-\n-    #[test]\n-    fn test_iter_len() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_mut_size_hint() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter_mut();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.size_hint(), (3, Some(3)));\n-    }\n-\n-    #[test]\n-    fn test_iter_mut_len() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter_mut();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_index() {\n-        let mut map = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        assert_eq!(map[2], 1);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_index_nonexistent() {\n-        let mut map = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        map[4];\n-    }\n-\n-    #[test]\n-    fn test_entry(){\n-        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n-\n-        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        // Existing key (insert)\n-        match map.entry(1) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                assert_eq!(view.get(), &10);\n-                assert_eq!(view.insert(100), 10);\n-            }\n-        }\n-        assert_eq!(map.get(&1).unwrap(), &100);\n-        assert_eq!(map.len(), 6);\n-\n-\n-        // Existing key (update)\n-        match map.entry(2) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                let v = view.get_mut();\n-                let new_v = (*v) * 10;\n-                *v = new_v;\n-            }\n-        }\n-        assert_eq!(map.get(&2).unwrap(), &200);\n-        assert_eq!(map.len(), 6);\n-\n-        // Existing key (take)\n-        match map.entry(3) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(view) => {\n-                assert_eq!(view.remove(), 30);\n-            }\n-        }\n-        assert_eq!(map.get(&3), None);\n-        assert_eq!(map.len(), 5);\n-\n-\n-        // Inexistent key (insert)\n-        match map.entry(10) {\n-            Occupied(_) => unreachable!(),\n-            Vacant(view) => {\n-                assert_eq!(*view.insert(1000), 1000);\n-            }\n-        }\n-        assert_eq!(map.get(&10).unwrap(), &1000);\n-        assert_eq!(map.len(), 6);\n-    }\n-\n-    #[test]\n-    fn test_entry_take_doesnt_corrupt() {\n-        // Test for #19292\n-        fn check(m: &HashMap<isize, ()>) {\n-            for k in m.keys() {\n-                assert!(m.contains_key(k),\n-                        \"{} is in keys() but not in the map?\", k);\n-            }\n-        }\n-\n-        let mut m = HashMap::new();\n-        let mut rng = weak_rng();\n-\n-        // Populate the map with some items.\n-        for _ in 0..50 {\n-            let x = rng.gen_range(-10, 10);\n-            m.insert(x, ());\n-        }\n-\n-        for i in 0..1000 {\n-            let x = rng.gen_range(-10, 10);\n-            match m.entry(x) {\n-                Vacant(_) => {},\n-                Occupied(e) => {\n-                    println!(\"{}: remove {}\", i, x);\n-                    e.remove();\n-                },\n-            }\n-\n-            check(&m);\n-        }\n-    }\n-}"}, {"sha": "47e300af26981da7cd395a6b361bf63704358cb6", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -12,14 +12,6 @@\n \n mod bench;\n mod table;\n-#[cfg(stage0)]\n-#[path = \"map_stage0.rs\"]\n pub mod map;\n-#[cfg(not(stage0))]\n-pub mod map;\n-#[cfg(stage0)]\n-#[path = \"set_stage0.rs\"]\n-pub mod set;\n-#[cfg(not(stage0))]\n pub mod set;\n pub mod state;"}, {"sha": "68c9e02d8ad7205483c7e577506fab2c4f3299a6", "filename": "src/libstd/collections/hash/set_stage0.rs", "status": "removed", "additions": 0, "deletions": 1252, "changes": 1252, "blob_url": "https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs?ref=2b01a37ec38db9301239f0c0abcf3c695055b0ff", "patch": "@@ -1,1252 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-use borrow::Borrow;\n-use clone::Clone;\n-use cmp::{Eq, PartialEq};\n-use core::marker::Sized;\n-use default::Default;\n-use fmt::Debug;\n-use fmt;\n-use hash::{self, Hash};\n-use iter::{\n-    Iterator, IntoIterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend,\n-};\n-use ops::{BitOr, BitAnd, BitXor, Sub};\n-use option::Option::{Some, None, self};\n-\n-use super::map::{self, HashMap, Keys, INITIAL_CAPACITY, RandomState, Hasher};\n-use super::state::HashState;\n-\n-// Future Optimization (FIXME!)\n-// =============================\n-//\n-// Iteration over zero sized values is a noop. There is no need\n-// for `bucket.val` in the case of HashSet. I suppose we would need HKT\n-// to get rid of it properly.\n-\n-/// An implementation of a hash set using the underlying representation of a\n-/// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n-/// requires that the elements implement the `Eq` and `Hash` traits.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::collections::HashSet;\n-/// // Type inference lets us omit an explicit type signature (which\n-/// // would be `HashSet<&str>` in this example).\n-/// let mut books = HashSet::new();\n-///\n-/// // Add some books.\n-/// books.insert(\"A Dance With Dragons\");\n-/// books.insert(\"To Kill a Mockingbird\");\n-/// books.insert(\"The Odyssey\");\n-/// books.insert(\"The Great Gatsby\");\n-///\n-/// // Check for a specific one.\n-/// if !books.contains(&(\"The Winds of Winter\")) {\n-///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n-///              books.len());\n-/// }\n-///\n-/// // Remove a book.\n-/// books.remove(&\"The Odyssey\");\n-///\n-/// // Iterate over everything.\n-/// for book in books.iter() {\n-///     println!(\"{}\", *book);\n-/// }\n-/// ```\n-///\n-/// The easiest way to use `HashSet` with a custom type is to derive\n-/// `Eq` and `Hash`. We must also derive `PartialEq`, this will in the\n-/// future be implied by `Eq`.\n-///\n-/// ```\n-/// use std::collections::HashSet;\n-/// #[derive(Hash, Eq, PartialEq, Debug)]\n-/// struct Viking<'a> {\n-///     name: &'a str,\n-///     power: usize,\n-/// }\n-///\n-/// let mut vikings = HashSet::new();\n-///\n-/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n-/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n-/// vikings.insert(Viking { name: \"Olaf\", power: 4 });\n-/// vikings.insert(Viking { name: \"Harald\", power: 8 });\n-///\n-/// // Use derived implementation to print the vikings.\n-/// for x in vikings.iter() {\n-///     println!(\"{:?}\", x);\n-/// }\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct HashSet<T, S = RandomState> {\n-    map: HashMap<T, (), S>\n-}\n-\n-impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n-    /// Create an empty HashSet.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::new();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> HashSet<T, RandomState> {\n-        HashSet::with_capacity(INITIAL_CAPACITY)\n-    }\n-\n-    /// Create an empty HashSet with space for at least `n` elements in\n-    /// the hash table.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n-        HashSet { map: HashMap::with_capacity(capacity) }\n-    }\n-}\n-\n-impl<T, S, H> HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    /// Creates a new empty hash set which will use the given hasher to hash\n-    /// keys.\n-    ///\n-    /// The hash set is also created with the default initial capacity.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut set = HashSet::with_hash_state(s);\n-    /// set.insert(2);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n-        HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n-    }\n-\n-    /// Create an empty HashSet with space for at least `capacity`\n-    /// elements in the hash table, using `hasher` to hash the keys.\n-    ///\n-    /// Warning: `hasher` is normally randomly generated, and\n-    /// is designed to allow `HashSet`s to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting it\n-    /// manually using this function can expose a DoS attack vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut set = HashSet::with_capacity_and_hash_state(10, s);\n-    /// set.insert(1);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n-    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n-                                        -> HashSet<T, S> {\n-        HashSet {\n-            map: HashMap::with_capacity_and_hash_state(capacity, hash_state),\n-        }\n-    }\n-\n-    /// Returns the number of elements the set can hold without reallocating.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let set: HashSet<int> = HashSet::with_capacity(100);\n-    /// assert!(set.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.map.capacity()\n-    }\n-\n-    /// Reserves capacity for at least `additional` more elements to be inserted\n-    /// in the `HashSet`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new allocation size overflows `usize`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set: HashSet<int> = HashSet::new();\n-    /// set.reserve(10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: usize) {\n-        self.map.reserve(additional)\n-    }\n-\n-    /// Shrinks the capacity of the set as much as possible. It will drop\n-    /// down as much as possible while maintaining the internal rules\n-    /// and possibly leaving some space in accordance with the resize policy.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set: HashSet<int> = HashSet::with_capacity(100);\n-    /// set.insert(1);\n-    /// set.insert(2);\n-    /// assert!(set.capacity() >= 100);\n-    /// set.shrink_to_fit();\n-    /// assert!(set.capacity() >= 2);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn shrink_to_fit(&mut self) {\n-        self.map.shrink_to_fit()\n-    }\n-\n-    /// An iterator visiting all elements in arbitrary order.\n-    /// Iterator element type is &'a T.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set = HashSet::new();\n-    /// set.insert(\"a\");\n-    /// set.insert(\"b\");\n-    ///\n-    /// // Will print in an arbitrary order.\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<T> {\n-        Iter { iter: self.map.keys() }\n-    }\n-\n-    /// Creates a consuming iterator, that is, one that moves each value out\n-    /// of the set in arbitrary order. The set cannot be used after calling\n-    /// this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set = HashSet::new();\n-    /// set.insert(\"a\".to_string());\n-    /// set.insert(\"b\".to_string());\n-    ///\n-    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n-    /// let v: Vec<String> = set.into_iter().collect();\n-    ///\n-    /// // Will print in an arbitrary order.\n-    /// for x in v.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((T, ())) -> T = first;\n-\n-        IntoIter { iter: self.map.into_iter().map(first) }\n-    }\n-\n-    /// Visit the values representing the difference.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Can be seen as `a - b`.\n-    /// for x in a.difference(&b) {\n-    ///     println!(\"{}\", x); // Print 1\n-    /// }\n-    ///\n-    /// let diff: HashSet<int> = a.difference(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1].iter().map(|&x| x).collect());\n-    ///\n-    /// // Note that difference is not symmetric,\n-    /// // and `b - a` means something else:\n-    /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n-    /// assert_eq!(diff, [4].iter().map(|&x| x).collect());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n-        Difference {\n-            iter: self.iter(),\n-            other: other,\n-        }\n-    }\n-\n-    /// Visit the values representing the symmetric difference.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 4 in arbitrary order.\n-    /// for x in a.symmetric_difference(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff1: HashSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n-    /// let diff2: HashSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n-    ///\n-    /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1, 4].iter().map(|&x| x).collect());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n-        -> SymmetricDifference<'a, T, S> {\n-        SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n-    }\n-\n-    /// Visit the values representing the intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 2, 3 in arbitrary order.\n-    /// for x in a.intersection(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n-        Intersection {\n-            iter: self.iter(),\n-            other: other,\n-        }\n-    }\n-\n-    /// Visit the values representing the union.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n-    ///\n-    /// // Print 1, 2, 3, 4 in arbitrary order.\n-    /// for x in a.union(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1, 2, 3, 4].iter().map(|&x| x).collect());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n-        Union { iter: self.iter().chain(other.difference(self)) }\n-    }\n-\n-    /// Return the number of elements in the set\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.map.len() }\n-\n-    /// Returns true if the set contains no elements\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n-\n-    /// Clears the set, returning all elements in an iterator.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n-\n-        Drain { iter: self.map.drain().map(first) }\n-    }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// v.insert(1);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) { self.map.clear() }\n-\n-    /// Returns `true` if the set contains a value.\n-    ///\n-    /// The value may be any borrowed form of the set's value type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the value type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// assert_eq!(set.contains(&1), true);\n-    /// assert_eq!(set.contains(&4), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where T: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.map.contains_key(value)\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// let mut b = HashSet::new();\n-    ///\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(4);\n-    /// assert_eq!(a.is_disjoint(&b), true);\n-    /// b.insert(1);\n-    /// assert_eq!(a.is_disjoint(&b), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n-        self.iter().all(|v| !other.contains(v))\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_subset(&sup), true);\n-    /// set.insert(4);\n-    /// assert_eq!(set.is_subset(&sup), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n-        self.iter().all(|v| other.contains(v))\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(0);\n-    /// set.insert(1);\n-    /// assert_eq!(set.is_superset(&sub), false);\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.is_superset(&sub), true);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// assert_eq!(set.insert(2), true);\n-    /// assert_eq!(set.insert(2), false);\n-    /// assert_eq!(set.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    ///\n-    /// The value may be any borrowed form of the set's value type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n-    /// the value type.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set = HashSet::new();\n-    ///\n-    /// set.insert(2);\n-    /// assert_eq!(set.remove(&2), true);\n-    /// assert_eq!(set.remove(&2), false);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where T: Borrow<Q>, Q: Hash<H> + Eq\n-    {\n-        self.map.remove(value).is_some()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> PartialEq for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn eq(&self, other: &HashSet<T, S>) -> bool {\n-        if self.len() != other.len() { return false; }\n-\n-        self.iter().all(|key| other.contains(key))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Eq for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> fmt::Debug for HashSet<T, S>\n-    where T: Eq + Hash<H> + fmt::Debug,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"HashSet {{\"));\n-\n-        for (i, x) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{:?}\", *x));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> FromIterator<T> for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> HashSet<T, S> {\n-        let iter = iter.into_iter();\n-        let lower = iter.size_hint().0;\n-        let mut set = HashSet::with_capacity_and_hash_state(lower, Default::default());\n-        set.extend(iter);\n-        set\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Extend<T> for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n-        for k in iter {\n-            self.insert(k);\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Default for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> HashSet<T, S> {\n-        HashSet::with_hash_state(Default::default())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = HashSet<T, S>;\n-\n-    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set = &a | &b;\n-    ///\n-    /// let mut i = 0;\n-    /// let expected = [1, 2, 3, 4, 5];\n-    /// for x in set.iter() {\n-    ///     assert!(expected.contains(x));\n-    ///     i += 1;\n-    /// }\n-    /// assert_eq!(i, expected.len());\n-    /// ```\n-    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n-        self.union(rhs).cloned().collect()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = HashSet<T, S>;\n-\n-    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n-    ///\n-    /// let set = &a & &b;\n-    ///\n-    /// let mut i = 0;\n-    /// let expected = [2, 3];\n-    /// for x in set.iter() {\n-    ///     assert!(expected.contains(x));\n-    ///     i += 1;\n-    /// }\n-    /// assert_eq!(i, expected.len());\n-    /// ```\n-    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n-        self.intersection(rhs).cloned().collect()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = HashSet<T, S>;\n-\n-    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set = &a ^ &b;\n-    ///\n-    /// let mut i = 0;\n-    /// let expected = [1, 2, 4, 5];\n-    /// for x in set.iter() {\n-    ///     assert!(expected.contains(x));\n-    ///     i += 1;\n-    /// }\n-    /// assert_eq!(i, expected.len());\n-    /// ```\n-    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n-        self.symmetric_difference(rhs).cloned().collect()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Output = HashSet<T, S>;\n-\n-    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n-    ///\n-    /// let set = &a - &b;\n-    ///\n-    /// let mut i = 0;\n-    /// let expected = [1, 2];\n-    /// for x in set.iter() {\n-    ///     assert!(expected.contains(x));\n-    ///     i += 1;\n-    /// }\n-    /// assert_eq!(i, expected.len());\n-    /// ```\n-    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n-        self.difference(rhs).cloned().collect()\n-    }\n-}\n-\n-/// HashSet iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, K: 'a> {\n-    iter: Keys<'a, K, ()>\n-}\n-\n-/// HashSet move iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<K> {\n-    iter: Map<map::IntoIter<K, ()>, fn((K, ())) -> K>\n-}\n-\n-/// HashSet drain iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Drain<'a, K: 'a> {\n-    iter: Map<map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n-}\n-\n-/// Intersection iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Intersection<'a, T: 'a, S: 'a> {\n-    // iterator of the first set\n-    iter: Iter<'a, T>,\n-    // the second set\n-    other: &'a HashSet<T, S>,\n-}\n-\n-/// Difference iterator\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Difference<'a, T: 'a, S: 'a> {\n-    // iterator of the first set\n-    iter: Iter<'a, T>,\n-    // the second set\n-    other: &'a HashSet<T, S>,\n-}\n-\n-/// Symmetric difference iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n-    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n-}\n-\n-/// Set union iterator.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T: 'a, S: 'a> {\n-    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n-}\n-\n-impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-impl<T, S, H> IntoIterator for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = T;\n-    type IntoIter = IntoIter<T>;\n-\n-    fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K> Iterator for Iter<'a, K> {\n-    type Item = &'a K;\n-\n-    fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K> Iterator for IntoIter<K> {\n-    type Item = K;\n-\n-    fn next(&mut self) -> Option<K> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K> ExactSizeIterator for IntoIter<K> {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K> Iterator for Drain<'a, K> {\n-    type Item = K;\n-\n-    fn next(&mut self) -> Option<K> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match self.iter.next() {\n-                None => return None,\n-                Some(elt) => if self.other.contains(elt) {\n-                    return Some(elt)\n-                },\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match self.iter.next() {\n-                None => return None,\n-                Some(elt) => if !self.other.contains(elt) {\n-                    return Some(elt)\n-                },\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Union<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n-{\n-    type Item = &'a T;\n-\n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-#[cfg(test)]\n-mod test_set {\n-    use prelude::v1::*;\n-\n-    use super::HashSet;\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = HashSet::new();\n-        let mut ys = HashSet::new();\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5));\n-        assert!(ys.insert(11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(7));\n-        assert!(xs.insert(19));\n-        assert!(xs.insert(4));\n-        assert!(ys.insert(2));\n-        assert!(ys.insert(-11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(ys.insert(7));\n-        assert!(!xs.is_disjoint(&ys));\n-        assert!(!ys.is_disjoint(&xs));\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = HashSet::new();\n-        assert!(a.insert(0));\n-        assert!(a.insert(5));\n-        assert!(a.insert(11));\n-        assert!(a.insert(7));\n-\n-        let mut b = HashSet::new();\n-        assert!(b.insert(0));\n-        assert!(b.insert(7));\n-        assert!(b.insert(19));\n-        assert!(b.insert(250));\n-        assert!(b.insert(11));\n-        assert!(b.insert(200));\n-\n-        assert!(!a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(!b.is_superset(&a));\n-\n-        assert!(b.insert(5));\n-\n-        assert!(a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(b.is_superset(&a));\n-    }\n-\n-    #[test]\n-    fn test_iterate() {\n-        let mut a = HashSet::new();\n-        for i in 0..32 {\n-            assert!(a.insert(i));\n-        }\n-        let mut observed: u32 = 0;\n-        for k in &a {\n-            observed |= 1 << *k;\n-        }\n-        assert_eq!(observed, 0xFFFF_FFFF);\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(11));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(77));\n-        assert!(a.insert(103));\n-        assert!(a.insert(5));\n-        assert!(a.insert(-5));\n-\n-        assert!(b.insert(2));\n-        assert!(b.insert(11));\n-        assert!(b.insert(77));\n-        assert!(b.insert(-9));\n-        assert!(b.insert(-42));\n-        assert!(b.insert(5));\n-        assert!(b.insert(3));\n-\n-        let mut i = 0;\n-        let expected = [3, 5, 11, 77];\n-        for x in a.intersection(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-\n-        let mut i = 0;\n-        let expected = [1, 5, 11];\n-        for x in a.difference(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(-2));\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-        assert!(b.insert(14));\n-        assert!(b.insert(22));\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 5, 11, 14, 22];\n-        for x in a.symmetric_difference(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-        assert!(a.insert(16));\n-        assert!(a.insert(19));\n-        assert!(a.insert(24));\n-\n-        assert!(b.insert(-2));\n-        assert!(b.insert(1));\n-        assert!(b.insert(5));\n-        assert!(b.insert(9));\n-        assert!(b.insert(13));\n-        assert!(b.insert(19));\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        for x in a.union(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n-\n-        let set: HashSet<_> = xs.iter().cloned().collect();\n-\n-        for x in &xs {\n-            assert!(set.contains(x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let hs = {\n-            let mut hs = HashSet::new();\n-\n-            hs.insert('a');\n-            hs.insert('b');\n-\n-            hs\n-        };\n-\n-        let v = hs.into_iter().collect::<Vec<char>>();\n-        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        // These constants once happened to expose a bug in insert().\n-        // I'm keeping them around to prevent a regression.\n-        let mut s1 = HashSet::new();\n-\n-        s1.insert(1);\n-        s1.insert(2);\n-        s1.insert(3);\n-\n-        let mut s2 = HashSet::new();\n-\n-        s2.insert(1);\n-        s2.insert(2);\n-\n-        assert!(s1 != s2);\n-\n-        s2.insert(3);\n-\n-        assert_eq!(s1, s2);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set = HashSet::new();\n-        let empty = HashSet::<i32>::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{:?}\", set);\n-\n-        assert!(set_str == \"HashSet {1, 2}\" || set_str == \"HashSet {2, 1}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"HashSet {}\");\n-    }\n-\n-    #[test]\n-    fn test_trivial_drain() {\n-        let mut s = HashSet::<i32>::new();\n-        for _ in s.drain() {}\n-        assert!(s.is_empty());\n-        drop(s);\n-\n-        let mut s = HashSet::<i32>::new();\n-        drop(s.drain());\n-        assert!(s.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-        let mut s: HashSet<_> = (1..100).collect();\n-\n-        // try this a bunch of times to make sure we don't screw up internal state.\n-        for _ in 0..20 {\n-            assert_eq!(s.len(), 99);\n-\n-            {\n-                let mut last_i = 0;\n-                let mut d = s.drain();\n-                for (i, x) in d.by_ref().take(50).enumerate() {\n-                    last_i = i;\n-                    assert!(x != 0);\n-                }\n-                assert_eq!(last_i, 49);\n-            }\n-\n-            for _ in &s { panic!(\"s should be empty!\"); }\n-\n-            // reset to try again.\n-            s.extend(1..100);\n-        }\n-    }\n-}"}, {"sha": "7513cb8a61c7c63f77f20c7f2bb813f5b049b786", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -143,25 +143,6 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n-#[cfg(stage0)]\n-pub fn make_hash<T: ?Sized, S, H>(hash_state: &S, t: &T) -> SafeHash\n-    where T: Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: Hasher<Output=u64>\n-{\n-    let mut state = hash_state.hasher();\n-    t.hash(&mut state);\n-    // We need to avoid 0u64 in order to prevent collisions with\n-    // EMPTY_HASH. We can maintain our precious uniform distribution\n-    // of initial indexes by unconditionally setting the MSB,\n-    // effectively reducing 64-bits hashes to 63 bits.\n-    SafeHash { hash: 0x8000_0000_0000_0000 | state.finish() }\n-}\n-\n-/// We need to remove hashes of 0. That's reserved for empty buckets.\n-/// This function wraps up `hash_keyed` to be the only way outside this\n-/// module to generate a SafeHash.\n-#[cfg(not(stage0))]\n pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash\n     where T: Hash, S: HashState\n {"}, {"sha": "fe0df1728efc0bd34559941d394346acc3d0a63d", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -41,7 +41,6 @@ use string::{String, CowString};\n use ops;\n use cmp;\n use hash::{Hash, Hasher};\n-#[cfg(stage0)] use hash::Writer;\n use old_path::{Path, GenericPath};\n \n use sys::os_str::{Buf, Slice};\n@@ -163,14 +162,6 @@ impl Ord for OsString {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'a, S: Hasher + Writer> Hash<S> for OsString {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (&**self).hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hash for OsString {\n     #[inline]\n@@ -263,14 +254,6 @@ impl Ord for OsStr {\n     fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }\n }\n \n-#[cfg(stage0)]\n-impl<'a, S: Hasher + Writer> Hash<S> for OsStr {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.bytes().hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hash for OsStr {\n     #[inline]"}, {"sha": "98c1b50a9bf14e2885ef371a5bdc08398349498f", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -744,6 +744,8 @@ pub fn set_permissions<P: AsPath + ?Sized>(path: &P, perm: Permissions)\n \n #[cfg(test)]\n mod tests {\n+    #![allow(deprecated)] //rand\n+\n     use prelude::v1::*;\n     use io::prelude::*;\n \n@@ -1035,7 +1037,7 @@ mod tests {\n             let msg = msg_str.as_bytes();\n             check!(w.write(msg));\n         }\n-        let mut files = check!(fs::read_dir(dir));\n+        let files = check!(fs::read_dir(dir));\n         let mut mem = [0u8; 4];\n         for f in files {\n             let f = f.unwrap().path();\n@@ -1065,7 +1067,7 @@ mod tests {\n         check!(fs::create_dir_all(dir2));\n         check!(File::create(&dir2.join(\"14\")));\n \n-        let mut files = check!(fs::walk_dir(dir));\n+        let files = check!(fs::walk_dir(dir));\n         let mut cur = [0u8; 2];\n         for f in files {\n             let f = f.unwrap().path();"}, {"sha": "9ef319782369d7090506bddfcb676b0e30f8640b", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -497,7 +497,6 @@ mod tests {\n         assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n \n         writer.write(&[9, 10, 11]).unwrap();\n-        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n         assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n \n         writer.flush().unwrap();\n@@ -593,7 +592,7 @@ mod tests {\n     #[test]\n     fn test_lines() {\n         let in_buf = b\"a\\nb\\nc\";\n-        let mut reader = BufReader::with_capacity(2, in_buf);\n+        let reader = BufReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n         assert_eq!(it.next(), Some(Ok(\"a\".to_string())));\n         assert_eq!(it.next(), Some(Ok(\"b\".to_string())));\n@@ -618,14 +617,14 @@ mod tests {\n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n-        let mut reader = BufReader::with_capacity(1, &buf[..]);\n+        let reader = BufReader::with_capacity(1, &buf[..]);\n         assert_eq!(reader.chars().next(), Some(Ok('\u00df')));\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195u8, 159u8, b'a'];\n-        let mut reader = BufReader::with_capacity(1, &buf[..]);\n+        let reader = BufReader::with_capacity(1, &buf[..]);\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));\n         assert_eq!(it.next(), Some(Ok('a')));"}, {"sha": "5b319f4c6876dc28acdc0461c1347c1d575a602c", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -15,7 +15,7 @@\n //! > module while the details of this module shake out.\n \n #![unstable(feature = \"io\",\n-            reason = \"this new I/O module is still under active deveopment and \\\n+            reason = \"this new I/O module is still under active development and \\\n                       APIs are subject to tweaks fairly regularly\")]\n \n use cmp;\n@@ -869,12 +869,12 @@ mod tests {\n \n     #[test]\n     fn split() {\n-        let mut buf = Cursor::new(b\"12\");\n+        let buf = Cursor::new(b\"12\");\n         let mut s = buf.split(b'3');\n         assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n         assert_eq!(s.next(), None);\n \n-        let mut buf = Cursor::new(b\"1233\");\n+        let buf = Cursor::new(b\"1233\");\n         let mut s = buf.split(b'3');\n         assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n         assert_eq!(s.next(), Some(Ok(vec![])));\n@@ -902,12 +902,12 @@ mod tests {\n \n     #[test]\n     fn lines() {\n-        let mut buf = Cursor::new(b\"12\");\n+        let buf = Cursor::new(b\"12\");\n         let mut s = buf.lines();\n         assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n         assert_eq!(s.next(), None);\n \n-        let mut buf = Cursor::new(b\"12\\n\\n\");\n+        let buf = Cursor::new(b\"12\\n\\n\");\n         let mut s = buf.lines();\n         assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n         assert_eq!(s.next(), Some(Ok(String::new())));"}, {"sha": "4b6e9cf76f9e570f3566d7d8cc6cb103d61a00a9", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -109,7 +109,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(lang_items)]\n #![feature(libc)]\n@@ -123,7 +122,7 @@\n #![feature(unsafe_destructor)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(macro_reexport)]\n-#![cfg_attr(test, feature(test))]\n+#![cfg_attr(test, feature(test, rustc_private, env))]\n \n // Don't link to std. We are std.\n #![feature(no_std)]\n@@ -219,15 +218,15 @@ mod int_macros;\n #[macro_use]\n mod uint_macros;\n \n-#[path = \"num/int.rs\"]  pub mod int;\n #[path = \"num/isize.rs\"]  pub mod isize;\n+pub use isize as int;\n #[path = \"num/i8.rs\"]   pub mod i8;\n #[path = \"num/i16.rs\"]  pub mod i16;\n #[path = \"num/i32.rs\"]  pub mod i32;\n #[path = \"num/i64.rs\"]  pub mod i64;\n \n-#[path = \"num/uint.rs\"] pub mod uint;\n #[path = \"num/usize.rs\"] pub mod usize;\n+pub use usize as uint;\n #[path = \"num/u8.rs\"]   pub mod u8;\n #[path = \"num/u16.rs\"]  pub mod u16;\n #[path = \"num/u32.rs\"]  pub mod u32;"}, {"sha": "f16f501c46a19006ff789b01839a71f054684528", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -147,21 +147,6 @@ impl PartialEq for Repr {\n }\n impl Eq for Repr {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Repr {\n-    fn hash(&self, s: &mut S) {\n-        match *self {\n-            Repr::V4(ref a) => {\n-                (a.sin_family, a.sin_port, a.sin_addr.s_addr).hash(s)\n-            }\n-            Repr::V6(ref a) => {\n-                (a.sin6_family, a.sin6_port, &a.sin6_addr.s6_addr,\n-                 a.sin6_flowinfo, a.sin6_scope_id).hash(s)\n-            }\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Repr {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {"}, {"sha": "d699886e57747dbbf2ca041d9f94271564f6a72c", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -189,13 +189,6 @@ impl PartialEq for Ipv4Addr {\n }\n impl Eq for Ipv4Addr {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv4Addr {\n-    fn hash(&self, s: &mut S) {\n-        self.inner.s_addr.hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Ipv4Addr {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {\n@@ -429,13 +422,6 @@ impl PartialEq for Ipv6Addr {\n }\n impl Eq for Ipv6Addr {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv6Addr {\n-    fn hash(&self, s: &mut S) {\n-        self.inner.s6_addr.hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Ipv6Addr {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {"}, {"sha": "f99cd2b1d1be9eeb59887f081817a4787236af95", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -456,12 +456,6 @@ mod tests {\n         }\n     }\n \n-    pub fn socket_name(addr: SocketAddr) {\n-    }\n-\n-    pub fn peer_name(addr: SocketAddr) {\n-    }\n-\n     #[test]\n     fn socket_and_peer_name_ip4() {\n         each_ip(&mut |addr| {"}, {"sha": "c70e92884ac653749ea3d9915323fe760b65b6aa", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -33,7 +33,7 @@ fn base_port() -> u16 {\n     let cwd = env::current_dir().unwrap();\n     let dirs = [\"32-opt\", \"32-nopt\", \"64-opt\", \"64-nopt\", \"64-opt-vg\",\n                 \"all-opt\", \"snap3\", \"dist\"];\n-    dirs.iter().enumerate().find(|&(i, dir)| {\n+    dirs.iter().enumerate().find(|&(_, dir)| {\n         cwd.as_str().unwrap().contains(dir)\n     }).map(|p| p.0).unwrap_or(0) as u16 * 1000 + 19600\n }"}, {"sha": "669952eee3924a8bb81e94cd953a16ca965cdc77", "filename": "src/libstd/num/int.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=2b01a37ec38db9301239f0c0abcf3c695055b0ff", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Deprecated: replaced by `isize`.\n-//!\n-//! The rollout of the new type will gradually take place over the\n-//! alpha cycle along with the development of clearer conventions\n-//! around integer types.\n-\n-#![unstable(feature = \"std_misc\")]\n-#![deprecated(since = \"1.0.0\", reason = \"replaced by isize\")]\n-\n-pub use core::int::{BITS, BYTES, MIN, MAX};\n-\n-int_module! { int }"}, {"sha": "968adfafeab73df1f4e5496403be1708c70c91f0", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -11,7 +11,7 @@\n //! Numeric traits and functions for generic mathematics\n //!\n //! These are implemented for the primitive numeric types in `std::{u8, u16,\n-//! u32, u64, uint, i8, i16, i32, i64, int, f32, f64}`.\n+//! u32, u64, usize, i8, i16, i32, i64, isize, f32, f64}`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n@@ -146,12 +146,12 @@ pub trait Float\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n     /// Deprecated: use `std::f32::DIGITS` or `std::f64::DIGITS` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> uint;\n+    fn digits(unused_self: Option<Self>) -> usize;\n     /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n@@ -161,22 +161,22 @@ pub trait Float\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> int;\n+    fn min_exp(unused_self: Option<Self>) -> isize;\n     /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> int;\n+    fn max_exp(unused_self: Option<Self>) -> isize;\n     /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    fn min_10_exp(unused_self: Option<Self>) -> isize;\n     /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> int;\n+    fn max_10_exp(unused_self: Option<Self>) -> isize;\n \n     /// Returns the smallest finite value that this type can represent.\n     ///\n@@ -698,7 +698,7 @@ pub trait Float\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n-    fn ldexp(x: Self, exp: int) -> Self;\n+    fn ldexp(x: Self, exp: isize) -> Self;\n     /// Breaks the number into a normalized fraction and a base-2 exponent,\n     /// satisfying:\n     ///\n@@ -720,7 +720,7 @@ pub trait Float\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n-    fn frexp(self) -> (Self, int);\n+    fn frexp(self) -> (Self, isize);\n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n     ///\n@@ -1112,12 +1112,12 @@ mod tests {\n     use i16;\n     use i32;\n     use i64;\n-    use int;\n+    use isize;\n     use u8;\n     use u16;\n     use u32;\n     use u64;\n-    use uint;\n+    use usize;\n \n     macro_rules! test_cast_20 {\n         ($_20:expr) => ({\n@@ -1179,33 +1179,33 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_int_min() {\n-        assert_eq!(int::MIN.to_int(),  Some(int::MIN as int));\n-        assert_eq!(int::MIN.to_i8(),   None);\n-        assert_eq!(int::MIN.to_i16(),  None);\n-        // int::MIN.to_i32() is word-size specific\n-        assert_eq!(int::MIN.to_i64(),  Some(int::MIN as i64));\n-        assert_eq!(int::MIN.to_uint(), None);\n-        assert_eq!(int::MIN.to_u8(),   None);\n-        assert_eq!(int::MIN.to_u16(),  None);\n-        assert_eq!(int::MIN.to_u32(),  None);\n-        assert_eq!(int::MIN.to_u64(),  None);\n+        assert_eq!(isize::MIN.to_int(),  Some(isize::MIN as isize));\n+        assert_eq!(isize::MIN.to_i8(),   None);\n+        assert_eq!(isize::MIN.to_i16(),  None);\n+        // isize::MIN.to_i32() is word-size specific\n+        assert_eq!(isize::MIN.to_i64(),  Some(isize::MIN as i64));\n+        assert_eq!(isize::MIN.to_uint(), None);\n+        assert_eq!(isize::MIN.to_u8(),   None);\n+        assert_eq!(isize::MIN.to_u16(),  None);\n+        assert_eq!(isize::MIN.to_u32(),  None);\n+        assert_eq!(isize::MIN.to_u64(),  None);\n \n         #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(int::MIN.to_i32(), Some(int::MIN as i32));\n+            assert_eq!(isize::MIN.to_i32(), Some(isize::MIN as i32));\n         }\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(int::MIN.to_i32(), None);\n+            assert_eq!(isize::MIN.to_i32(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_i8_min() {\n-        assert_eq!(i8::MIN.to_int(),  Some(i8::MIN as int));\n+        assert_eq!(i8::MIN.to_int(),  Some(i8::MIN as isize));\n         assert_eq!(i8::MIN.to_i8(),   Some(i8::MIN as i8));\n         assert_eq!(i8::MIN.to_i16(),  Some(i8::MIN as i16));\n         assert_eq!(i8::MIN.to_i32(),  Some(i8::MIN as i32));\n@@ -1219,7 +1219,7 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_i16_min() {\n-        assert_eq!(i16::MIN.to_int(),  Some(i16::MIN as int));\n+        assert_eq!(i16::MIN.to_int(),  Some(i16::MIN as isize));\n         assert_eq!(i16::MIN.to_i8(),   None);\n         assert_eq!(i16::MIN.to_i16(),  Some(i16::MIN as i16));\n         assert_eq!(i16::MIN.to_i32(),  Some(i16::MIN as i32));\n@@ -1233,7 +1233,7 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_i32_min() {\n-        assert_eq!(i32::MIN.to_int(),  Some(i32::MIN as int));\n+        assert_eq!(i32::MIN.to_int(),  Some(i32::MIN as isize));\n         assert_eq!(i32::MIN.to_i8(),   None);\n         assert_eq!(i32::MIN.to_i16(),  None);\n         assert_eq!(i32::MIN.to_i32(),  Some(i32::MIN as i32));\n@@ -1265,47 +1265,47 @@ mod tests {\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(i64::MIN.to_int(), Some(i64::MIN as int));\n+            assert_eq!(i64::MIN.to_int(), Some(i64::MIN as isize));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_int_max() {\n-        assert_eq!(int::MAX.to_int(),  Some(int::MAX as int));\n-        assert_eq!(int::MAX.to_i8(),   None);\n-        assert_eq!(int::MAX.to_i16(),  None);\n-        // int::MAX.to_i32() is word-size specific\n-        assert_eq!(int::MAX.to_i64(),  Some(int::MAX as i64));\n-        assert_eq!(int::MAX.to_u8(),   None);\n-        assert_eq!(int::MAX.to_u16(),  None);\n-        // int::MAX.to_u32() is word-size specific\n-        assert_eq!(int::MAX.to_u64(),  Some(int::MAX as u64));\n+        assert_eq!(isize::MAX.to_int(),  Some(isize::MAX as isize));\n+        assert_eq!(isize::MAX.to_i8(),   None);\n+        assert_eq!(isize::MAX.to_i16(),  None);\n+        // isize::MAX.to_i32() is word-size specific\n+        assert_eq!(isize::MAX.to_i64(),  Some(isize::MAX as i64));\n+        assert_eq!(isize::MAX.to_u8(),   None);\n+        assert_eq!(isize::MAX.to_u16(),  None);\n+        // isize::MAX.to_u32() is word-size specific\n+        assert_eq!(isize::MAX.to_u64(),  Some(isize::MAX as u64));\n \n         #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(int::MAX.to_i32(), Some(int::MAX as i32));\n-            assert_eq!(int::MAX.to_u32(), Some(int::MAX as u32));\n+            assert_eq!(isize::MAX.to_i32(), Some(isize::MAX as i32));\n+            assert_eq!(isize::MAX.to_u32(), Some(isize::MAX as u32));\n         }\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(int::MAX.to_i32(), None);\n-            assert_eq!(int::MAX.to_u32(), None);\n+            assert_eq!(isize::MAX.to_i32(), None);\n+            assert_eq!(isize::MAX.to_u32(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_i8_max() {\n-        assert_eq!(i8::MAX.to_int(),  Some(i8::MAX as int));\n+        assert_eq!(i8::MAX.to_int(),  Some(i8::MAX as isize));\n         assert_eq!(i8::MAX.to_i8(),   Some(i8::MAX as i8));\n         assert_eq!(i8::MAX.to_i16(),  Some(i8::MAX as i16));\n         assert_eq!(i8::MAX.to_i32(),  Some(i8::MAX as i32));\n         assert_eq!(i8::MAX.to_i64(),  Some(i8::MAX as i64));\n-        assert_eq!(i8::MAX.to_uint(), Some(i8::MAX as uint));\n+        assert_eq!(i8::MAX.to_uint(), Some(i8::MAX as usize));\n         assert_eq!(i8::MAX.to_u8(),   Some(i8::MAX as u8));\n         assert_eq!(i8::MAX.to_u16(),  Some(i8::MAX as u16));\n         assert_eq!(i8::MAX.to_u32(),  Some(i8::MAX as u32));\n@@ -1314,12 +1314,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_i16_max() {\n-        assert_eq!(i16::MAX.to_int(),  Some(i16::MAX as int));\n+        assert_eq!(i16::MAX.to_int(),  Some(i16::MAX as isize));\n         assert_eq!(i16::MAX.to_i8(),   None);\n         assert_eq!(i16::MAX.to_i16(),  Some(i16::MAX as i16));\n         assert_eq!(i16::MAX.to_i32(),  Some(i16::MAX as i32));\n         assert_eq!(i16::MAX.to_i64(),  Some(i16::MAX as i64));\n-        assert_eq!(i16::MAX.to_uint(), Some(i16::MAX as uint));\n+        assert_eq!(i16::MAX.to_uint(), Some(i16::MAX as usize));\n         assert_eq!(i16::MAX.to_u8(),   None);\n         assert_eq!(i16::MAX.to_u16(),  Some(i16::MAX as u16));\n         assert_eq!(i16::MAX.to_u32(),  Some(i16::MAX as u32));\n@@ -1328,12 +1328,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_i32_max() {\n-        assert_eq!(i32::MAX.to_int(),  Some(i32::MAX as int));\n+        assert_eq!(i32::MAX.to_int(),  Some(i32::MAX as isize));\n         assert_eq!(i32::MAX.to_i8(),   None);\n         assert_eq!(i32::MAX.to_i16(),  None);\n         assert_eq!(i32::MAX.to_i32(),  Some(i32::MAX as i32));\n         assert_eq!(i32::MAX.to_i64(),  Some(i32::MAX as i64));\n-        assert_eq!(i32::MAX.to_uint(), Some(i32::MAX as uint));\n+        assert_eq!(i32::MAX.to_uint(), Some(i32::MAX as usize));\n         assert_eq!(i32::MAX.to_u8(),   None);\n         assert_eq!(i32::MAX.to_u16(),  None);\n         assert_eq!(i32::MAX.to_u32(),  Some(i32::MAX as u32));\n@@ -1361,35 +1361,35 @@ mod tests {\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as int));\n-            assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as uint));\n+            assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as isize));\n+            assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as usize));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_uint_min() {\n-        assert_eq!(uint::MIN.to_int(),  Some(uint::MIN as int));\n-        assert_eq!(uint::MIN.to_i8(),   Some(uint::MIN as i8));\n-        assert_eq!(uint::MIN.to_i16(),  Some(uint::MIN as i16));\n-        assert_eq!(uint::MIN.to_i32(),  Some(uint::MIN as i32));\n-        assert_eq!(uint::MIN.to_i64(),  Some(uint::MIN as i64));\n-        assert_eq!(uint::MIN.to_uint(), Some(uint::MIN as uint));\n-        assert_eq!(uint::MIN.to_u8(),   Some(uint::MIN as u8));\n-        assert_eq!(uint::MIN.to_u16(),  Some(uint::MIN as u16));\n-        assert_eq!(uint::MIN.to_u32(),  Some(uint::MIN as u32));\n-        assert_eq!(uint::MIN.to_u64(),  Some(uint::MIN as u64));\n+        assert_eq!(usize::MIN.to_int(),  Some(usize::MIN as isize));\n+        assert_eq!(usize::MIN.to_i8(),   Some(usize::MIN as i8));\n+        assert_eq!(usize::MIN.to_i16(),  Some(usize::MIN as i16));\n+        assert_eq!(usize::MIN.to_i32(),  Some(usize::MIN as i32));\n+        assert_eq!(usize::MIN.to_i64(),  Some(usize::MIN as i64));\n+        assert_eq!(usize::MIN.to_uint(), Some(usize::MIN as usize));\n+        assert_eq!(usize::MIN.to_u8(),   Some(usize::MIN as u8));\n+        assert_eq!(usize::MIN.to_u16(),  Some(usize::MIN as u16));\n+        assert_eq!(usize::MIN.to_u32(),  Some(usize::MIN as u32));\n+        assert_eq!(usize::MIN.to_u64(),  Some(usize::MIN as u64));\n     }\n \n     #[test]\n     fn test_cast_range_u8_min() {\n-        assert_eq!(u8::MIN.to_int(),  Some(u8::MIN as int));\n+        assert_eq!(u8::MIN.to_int(),  Some(u8::MIN as isize));\n         assert_eq!(u8::MIN.to_i8(),   Some(u8::MIN as i8));\n         assert_eq!(u8::MIN.to_i16(),  Some(u8::MIN as i16));\n         assert_eq!(u8::MIN.to_i32(),  Some(u8::MIN as i32));\n         assert_eq!(u8::MIN.to_i64(),  Some(u8::MIN as i64));\n-        assert_eq!(u8::MIN.to_uint(), Some(u8::MIN as uint));\n+        assert_eq!(u8::MIN.to_uint(), Some(u8::MIN as usize));\n         assert_eq!(u8::MIN.to_u8(),   Some(u8::MIN as u8));\n         assert_eq!(u8::MIN.to_u16(),  Some(u8::MIN as u16));\n         assert_eq!(u8::MIN.to_u32(),  Some(u8::MIN as u32));\n@@ -1398,12 +1398,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_u16_min() {\n-        assert_eq!(u16::MIN.to_int(),  Some(u16::MIN as int));\n+        assert_eq!(u16::MIN.to_int(),  Some(u16::MIN as isize));\n         assert_eq!(u16::MIN.to_i8(),   Some(u16::MIN as i8));\n         assert_eq!(u16::MIN.to_i16(),  Some(u16::MIN as i16));\n         assert_eq!(u16::MIN.to_i32(),  Some(u16::MIN as i32));\n         assert_eq!(u16::MIN.to_i64(),  Some(u16::MIN as i64));\n-        assert_eq!(u16::MIN.to_uint(), Some(u16::MIN as uint));\n+        assert_eq!(u16::MIN.to_uint(), Some(u16::MIN as usize));\n         assert_eq!(u16::MIN.to_u8(),   Some(u16::MIN as u8));\n         assert_eq!(u16::MIN.to_u16(),  Some(u16::MIN as u16));\n         assert_eq!(u16::MIN.to_u32(),  Some(u16::MIN as u32));\n@@ -1412,12 +1412,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_u32_min() {\n-        assert_eq!(u32::MIN.to_int(),  Some(u32::MIN as int));\n+        assert_eq!(u32::MIN.to_int(),  Some(u32::MIN as isize));\n         assert_eq!(u32::MIN.to_i8(),   Some(u32::MIN as i8));\n         assert_eq!(u32::MIN.to_i16(),  Some(u32::MIN as i16));\n         assert_eq!(u32::MIN.to_i32(),  Some(u32::MIN as i32));\n         assert_eq!(u32::MIN.to_i64(),  Some(u32::MIN as i64));\n-        assert_eq!(u32::MIN.to_uint(), Some(u32::MIN as uint));\n+        assert_eq!(u32::MIN.to_uint(), Some(u32::MIN as usize));\n         assert_eq!(u32::MIN.to_u8(),   Some(u32::MIN as u8));\n         assert_eq!(u32::MIN.to_u16(),  Some(u32::MIN as u16));\n         assert_eq!(u32::MIN.to_u32(),  Some(u32::MIN as u32));\n@@ -1426,12 +1426,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_u64_min() {\n-        assert_eq!(u64::MIN.to_int(),  Some(u64::MIN as int));\n+        assert_eq!(u64::MIN.to_int(),  Some(u64::MIN as isize));\n         assert_eq!(u64::MIN.to_i8(),   Some(u64::MIN as i8));\n         assert_eq!(u64::MIN.to_i16(),  Some(u64::MIN as i16));\n         assert_eq!(u64::MIN.to_i32(),  Some(u64::MIN as i32));\n         assert_eq!(u64::MIN.to_i64(),  Some(u64::MIN as i64));\n-        assert_eq!(u64::MIN.to_uint(), Some(u64::MIN as uint));\n+        assert_eq!(u64::MIN.to_uint(), Some(u64::MIN as usize));\n         assert_eq!(u64::MIN.to_u8(),   Some(u64::MIN as u8));\n         assert_eq!(u64::MIN.to_u16(),  Some(u64::MIN as u16));\n         assert_eq!(u64::MIN.to_u32(),  Some(u64::MIN as u32));\n@@ -1440,39 +1440,39 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_uint_max() {\n-        assert_eq!(uint::MAX.to_int(),  None);\n-        assert_eq!(uint::MAX.to_i8(),   None);\n-        assert_eq!(uint::MAX.to_i16(),  None);\n-        assert_eq!(uint::MAX.to_i32(),  None);\n-        // uint::MAX.to_i64() is word-size specific\n-        assert_eq!(uint::MAX.to_u8(),   None);\n-        assert_eq!(uint::MAX.to_u16(),  None);\n-        // uint::MAX.to_u32() is word-size specific\n-        assert_eq!(uint::MAX.to_u64(),  Some(uint::MAX as u64));\n+        assert_eq!(usize::MAX.to_int(),  None);\n+        assert_eq!(usize::MAX.to_i8(),   None);\n+        assert_eq!(usize::MAX.to_i16(),  None);\n+        assert_eq!(usize::MAX.to_i32(),  None);\n+        // usize::MAX.to_i64() is word-size specific\n+        assert_eq!(usize::MAX.to_u8(),   None);\n+        assert_eq!(usize::MAX.to_u16(),  None);\n+        // usize::MAX.to_u32() is word-size specific\n+        assert_eq!(usize::MAX.to_u64(),  Some(usize::MAX as u64));\n \n         #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(uint::MAX.to_u32(), Some(uint::MAX as u32));\n-            assert_eq!(uint::MAX.to_i64(), Some(uint::MAX as i64));\n+            assert_eq!(usize::MAX.to_u32(), Some(usize::MAX as u32));\n+            assert_eq!(usize::MAX.to_i64(), Some(usize::MAX as i64));\n         }\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(uint::MAX.to_u32(), None);\n-            assert_eq!(uint::MAX.to_i64(), None);\n+            assert_eq!(usize::MAX.to_u32(), None);\n+            assert_eq!(usize::MAX.to_i64(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_u8_max() {\n-        assert_eq!(u8::MAX.to_int(),  Some(u8::MAX as int));\n+        assert_eq!(u8::MAX.to_int(),  Some(u8::MAX as isize));\n         assert_eq!(u8::MAX.to_i8(),   None);\n         assert_eq!(u8::MAX.to_i16(),  Some(u8::MAX as i16));\n         assert_eq!(u8::MAX.to_i32(),  Some(u8::MAX as i32));\n         assert_eq!(u8::MAX.to_i64(),  Some(u8::MAX as i64));\n-        assert_eq!(u8::MAX.to_uint(), Some(u8::MAX as uint));\n+        assert_eq!(u8::MAX.to_uint(), Some(u8::MAX as usize));\n         assert_eq!(u8::MAX.to_u8(),   Some(u8::MAX as u8));\n         assert_eq!(u8::MAX.to_u16(),  Some(u8::MAX as u16));\n         assert_eq!(u8::MAX.to_u32(),  Some(u8::MAX as u32));\n@@ -1481,12 +1481,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_u16_max() {\n-        assert_eq!(u16::MAX.to_int(),  Some(u16::MAX as int));\n+        assert_eq!(u16::MAX.to_int(),  Some(u16::MAX as isize));\n         assert_eq!(u16::MAX.to_i8(),   None);\n         assert_eq!(u16::MAX.to_i16(),  None);\n         assert_eq!(u16::MAX.to_i32(),  Some(u16::MAX as i32));\n         assert_eq!(u16::MAX.to_i64(),  Some(u16::MAX as i64));\n-        assert_eq!(u16::MAX.to_uint(), Some(u16::MAX as uint));\n+        assert_eq!(u16::MAX.to_uint(), Some(u16::MAX as usize));\n         assert_eq!(u16::MAX.to_u8(),   None);\n         assert_eq!(u16::MAX.to_u16(),  Some(u16::MAX as u16));\n         assert_eq!(u16::MAX.to_u32(),  Some(u16::MAX as u32));\n@@ -1500,7 +1500,7 @@ mod tests {\n         assert_eq!(u32::MAX.to_i16(),  None);\n         assert_eq!(u32::MAX.to_i32(),  None);\n         assert_eq!(u32::MAX.to_i64(),  Some(u32::MAX as i64));\n-        assert_eq!(u32::MAX.to_uint(), Some(u32::MAX as uint));\n+        assert_eq!(u32::MAX.to_uint(), Some(u32::MAX as usize));\n         assert_eq!(u32::MAX.to_u8(),   None);\n         assert_eq!(u32::MAX.to_u16(),  None);\n         assert_eq!(u32::MAX.to_u32(),  Some(u32::MAX as u32));\n@@ -1513,7 +1513,7 @@ mod tests {\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as int));\n+            assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as isize));\n         }\n \n         check_word_size();\n@@ -1539,15 +1539,15 @@ mod tests {\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as uint));\n+            assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as usize));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_saturating_add_uint() {\n-        use uint::MAX;\n+        use usize::MAX;\n         assert_eq!(3_usize.saturating_add(5_usize), 8_usize);\n         assert_eq!(3_usize.saturating_add(MAX-1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n@@ -1556,7 +1556,7 @@ mod tests {\n \n     #[test]\n     fn test_saturating_sub_uint() {\n-        use uint::MAX;\n+        use usize::MAX;\n         assert_eq!(5_usize.saturating_sub(3_usize), 2_usize);\n         assert_eq!(3_usize.saturating_sub(5_usize), 0_usize);\n         assert_eq!(0_usize.saturating_sub(1_usize), 0_usize);\n@@ -1565,7 +1565,7 @@ mod tests {\n \n     #[test]\n     fn test_saturating_add_int() {\n-        use int::{MIN,MAX};\n+        use isize::{MIN,MAX};\n         assert_eq!(3.saturating_add(5), 8);\n         assert_eq!(3.saturating_add(MAX-1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n@@ -1577,7 +1577,7 @@ mod tests {\n \n     #[test]\n     fn test_saturating_sub_int() {\n-        use int::{MIN,MAX};\n+        use isize::{MIN,MAX};\n         assert_eq!(3.saturating_sub(5), -2);\n         assert_eq!(MIN.saturating_sub(1), MIN);\n         assert_eq!((-2).saturating_sub(MAX), MIN);\n@@ -1589,13 +1589,13 @@ mod tests {\n \n     #[test]\n     fn test_checked_add() {\n-        let five_less = uint::MAX - 5;\n-        assert_eq!(five_less.checked_add(0), Some(uint::MAX - 5));\n-        assert_eq!(five_less.checked_add(1), Some(uint::MAX - 4));\n-        assert_eq!(five_less.checked_add(2), Some(uint::MAX - 3));\n-        assert_eq!(five_less.checked_add(3), Some(uint::MAX - 2));\n-        assert_eq!(five_less.checked_add(4), Some(uint::MAX - 1));\n-        assert_eq!(five_less.checked_add(5), Some(uint::MAX));\n+        let five_less = usize::MAX - 5;\n+        assert_eq!(five_less.checked_add(0), Some(usize::MAX - 5));\n+        assert_eq!(five_less.checked_add(1), Some(usize::MAX - 4));\n+        assert_eq!(five_less.checked_add(2), Some(usize::MAX - 3));\n+        assert_eq!(five_less.checked_add(3), Some(usize::MAX - 2));\n+        assert_eq!(five_less.checked_add(4), Some(usize::MAX - 1));\n+        assert_eq!(five_less.checked_add(5), Some(usize::MAX));\n         assert_eq!(five_less.checked_add(6), None);\n         assert_eq!(five_less.checked_add(7), None);\n     }\n@@ -1614,7 +1614,7 @@ mod tests {\n \n     #[test]\n     fn test_checked_mul() {\n-        let third = uint::MAX / 3;\n+        let third = usize::MAX / 3;\n         assert_eq!(third.checked_mul(0), Some(0));\n         assert_eq!(third.checked_mul(1), Some(third));\n         assert_eq!(third.checked_mul(2), Some(third * 2));\n@@ -1641,7 +1641,7 @@ mod tests {\n     test_is_power_of_two!{ test_is_power_of_two_u16, u16 }\n     test_is_power_of_two!{ test_is_power_of_two_u32, u32 }\n     test_is_power_of_two!{ test_is_power_of_two_u64, u64 }\n-    test_is_power_of_two!{ test_is_power_of_two_uint, uint }\n+    test_is_power_of_two!{ test_is_power_of_two_uint, usize }\n \n     macro_rules! test_next_power_of_two {\n         ($test_name:ident, $T:ident) => (\n@@ -1661,7 +1661,7 @@ mod tests {\n     test_next_power_of_two! { test_next_power_of_two_u16, u16 }\n     test_next_power_of_two! { test_next_power_of_two_u32, u32 }\n     test_next_power_of_two! { test_next_power_of_two_u64, u64 }\n-    test_next_power_of_two! { test_next_power_of_two_uint, uint }\n+    test_next_power_of_two! { test_next_power_of_two_uint, usize }\n \n     macro_rules! test_checked_next_power_of_two {\n         ($test_name:ident, $T:ident) => (\n@@ -1684,19 +1684,19 @@ mod tests {\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u16, u16 }\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u32, u32 }\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u64, u64 }\n-    test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, uint }\n+    test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, usize }\n \n     #[derive(PartialEq, Debug)]\n-    struct Value { x: int }\n+    struct Value { x: isize }\n \n     impl ToPrimitive for Value {\n         fn to_i64(&self) -> Option<i64> { self.x.to_i64() }\n         fn to_u64(&self) -> Option<u64> { self.x.to_u64() }\n     }\n \n     impl FromPrimitive for Value {\n-        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as int }) }\n-        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as int }) }\n+        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as isize }) }\n+        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as isize }) }\n     }\n \n     #[test]\n@@ -1734,7 +1734,7 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Int>(base: T, exp: uint) -> T {\n+        fn naive_pow<T: Int>(base: T, exp: usize) -> T {\n             let one: T = Int::one();\n             (0..exp).fold(one, |acc, _| acc * base)\n         }"}, {"sha": "c7b491381f337abca0b65054bfdaa8b620469cd9", "filename": "src/libstd/num/uint.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=2b01a37ec38db9301239f0c0abcf3c695055b0ff", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Deprecated: replaced by `usize`.\n-//!\n-//! The rollout of the new type will gradually take place over the\n-//! alpha cycle along with the development of clearer conventions\n-//! around integer types.\n-\n-#![unstable(feature = \"std_misc\")]\n-#![deprecated(since = \"1.0.0\", reason = \"replaced by usize\")]\n-\n-pub use core::uint::{BITS, BYTES, MIN, MAX};\n-\n-uint_module! { uint }"}, {"sha": "b82572fc08957380c68f439b2ae1919d7ccca064", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -240,6 +240,8 @@\n \n #![unstable(feature = \"old_io\")]\n #![deny(unused_must_use)]\n+#![allow(deprecated)] // seriously this is all deprecated\n+#![allow(unused_imports)]\n \n pub use self::SeekStyle::*;\n pub use self::FileMode::*;"}, {"sha": "a13295b1ccb5014ea8137156559b628cca769547", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -104,19 +104,7 @@ struct EnvKey(CString);\n #[derive(Eq, Clone, Debug)]\n struct EnvKey(CString);\n \n-#[cfg(all(windows, stage0))]\n-impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for EnvKey {\n-    fn hash(&self, state: &mut H) {\n-        let &EnvKey(ref x) = self;\n-        match str::from_utf8(x.as_bytes()) {\n-            Ok(s) => for ch in s.chars() {\n-                (ch as u8 as char).to_lowercase().hash(state);\n-            },\n-            Err(..) => x.hash(state)\n-        }\n-    }\n-}\n-#[cfg(all(windows, not(stage0)))]\n+#[cfg(windows)]\n impl hash::Hash for EnvKey {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         let &EnvKey(ref x) = self;"}, {"sha": "4f8976fb2ecda2e18faf75c8f5098e9929d43a17", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -60,6 +60,8 @@\n //! ```\n \n #![unstable(feature = \"old_path\")]\n+#![allow(deprecated)] // seriously this is all deprecated\n+#![allow(unused_imports)]\n \n use core::marker::Sized;\n use ffi::CString;"}, {"sha": "8d5765e1ffe5e929f3c386e62d54d11d97fc053e", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -100,14 +100,6 @@ impl FromStr for Path {\n #[derive(Debug, Clone, PartialEq, Copy)]\n pub struct ParsePathError;\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.repr.hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Path {\n     #[inline]"}, {"sha": "31a2be1daf3594146b6721f7001bc87d235aaa21", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -127,21 +127,6 @@ impl FromStr for Path {\n #[derive(Debug, Clone, PartialEq, Copy)]\n pub struct ParsePathError;\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n-    #[cfg(not(test))]\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.repr.hash(state)\n-    }\n-\n-    #[cfg(test)]\n-    #[inline]\n-    fn hash(&self, _: &mut S) {\n-        // No-op because the `hash` implementation will be wrong.\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for Path {\n     #[cfg(not(test))]"}, {"sha": "86f5c2c356e5e924643e91ab61c746ad7214d49f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -595,7 +595,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n // res\n #[cfg(target_os = \"ios\")]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use ffi::c_str_to_bytes;\n+    use ffi::CStr;\n     use iter::range;\n     use mem;\n \n@@ -630,7 +630,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n             let tmp = objc_msgSend(args, objectAtSel, i);\n             let utf_c_str: *const libc::c_char =\n                 mem::transmute(objc_msgSend(tmp, utf8Sel));\n-            res.push(c_str_to_bytes(&utf_c_str).to_vec());\n+            res.push(CStr::from_ptr(utf_c_str).to_bytes().to_vec());\n         }\n     }\n "}, {"sha": "88543ad85ed116e78326c1dbc83d392733637745", "filename": "src/libstd/path.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1324,7 +1324,6 @@ impl<T: AsOsStr + ?Sized> AsPath for T {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ffi::OsStr;\n     use core::prelude::*;\n     use string::{ToString, String};\n     use vec::Vec;"}, {"sha": "86604f62171ef073369a56646de779961ba80c38", "filename": "src/libstd/process.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -489,18 +489,14 @@ impl Child {\n mod tests {\n     use io::ErrorKind;\n     use io::prelude::*;\n-    use prelude::v1::{Ok, Err, range, drop, Some, None, Vec};\n+    use prelude::v1::{Ok, Err, drop, Some, Vec};\n     use prelude::v1::{String, Clone};\n     use prelude::v1::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n-    use path::Path;\n     use old_path;\n     use old_io::fs::PathExtensions;\n     use rt::running_on_valgrind;\n     use str;\n-    use super::{Child, Command, Output, ExitStatus, Stdio};\n-    use sync::mpsc::channel;\n-    use thread;\n-    use time::Duration;\n+    use super::{Command, Output, Stdio};\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n "}, {"sha": "9119a3c60d855a3d2b0e2b87b1ad9e006b698259", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -32,7 +32,6 @@ use borrow::Cow;\n use cmp;\n use fmt;\n use hash::{Hash, Hasher};\n-#[cfg(stage0)] use hash::Writer;\n use iter::{FromIterator, IntoIterator};\n use mem;\n use num::Int;\n@@ -796,30 +795,13 @@ impl<'a> Iterator for EncodeWide<'a> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Writer + Hasher> Hash<S> for CodePoint {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.value.hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl Hash for CodePoint {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.value.hash(state)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Writer + Hasher> Hash<S> for Wtf8Buf {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(&self.bytes);\n-        0xfeu8.hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl Hash for Wtf8Buf {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n@@ -828,15 +810,6 @@ impl Hash for Wtf8Buf {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<'a, S: Writer + Hasher> Hash<S> for Wtf8 {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(&self.bytes);\n-        0xfeu8.hash(state)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl Hash for Wtf8 {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {"}, {"sha": "d51f907307e46f12dff05a9306888e54b7dbb13e", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -220,7 +220,7 @@ pub fn current_exe() -> IoResult<Path> {\n         if v.is_null() {\n             Err(IoError::last_error())\n         } else {\n-            Ok(Path::new(CStr::from_ptr(&v).to_bytes().to_vec()))\n+            Ok(Path::new(CStr::from_ptr(v).to_bytes().to_vec()))\n         }\n     }\n }"}, {"sha": "2be841989e6b355b02676f04cd5a04112c9f2446", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -12,8 +12,6 @@ use prelude::v1::*;\n use self::Req::*;\n \n use collections::HashMap;\n-#[cfg(stage0)]\n-use collections::hash_map::Hasher;\n use ffi::CString;\n use hash::Hash;\n use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n@@ -64,223 +62,6 @@ impl Process {\n         mkerr_libc(r)\n     }\n \n-    #[cfg(stage0)]\n-    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n-                              out_fd: Option<P>, err_fd: Option<P>)\n-                              -> IoResult<Process>\n-        where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n-              K: BytesContainer + Eq + Hash<Hasher>, V: BytesContainer\n-    {\n-        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-\n-        mod rustrt {\n-            extern {\n-                pub fn rust_unset_sigprocmask();\n-            }\n-        }\n-\n-        #[cfg(all(target_os = \"android\", target_arch = \"aarch64\"))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::sysconf(libc::consts::os::sysconf::_SC_OPEN_MAX) as c_int\n-        }\n-        #[cfg(not(all(target_os = \"android\", target_arch = \"aarch64\")))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::funcs::bsd44::getdtablesize()\n-        }\n-\n-        unsafe fn set_cloexec(fd: c_int) {\n-            let ret = c::ioctl(fd, c::FIOCLEX);\n-            assert_eq!(ret, 0);\n-        }\n-\n-        let dirp = cfg.cwd().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n-\n-        // temporary until unboxed closures land\n-        let cfg = unsafe {\n-            mem::transmute::<&ProcessConfig<K,V>,&'static ProcessConfig<K,V>>(cfg)\n-        };\n-\n-        with_envp(cfg.env(), move|envp: *const c_void| {\n-            with_argv(cfg.program(), cfg.args(), move|argv: *const *const libc::c_char| unsafe {\n-                let (input, mut output) = try!(sys::os::pipe());\n-\n-                // We may use this in the child, so perform allocations before the\n-                // fork\n-                let devnull = b\"/dev/null\\0\";\n-\n-                set_cloexec(output.fd());\n-\n-                let pid = fork();\n-                if pid < 0 {\n-                    return Err(super::last_error())\n-                } else if pid > 0 {\n-                    #[inline]\n-                    fn combine(arr: &[u8]) -> i32 {\n-                        let a = arr[0] as u32;\n-                        let b = arr[1] as u32;\n-                        let c = arr[2] as u32;\n-                        let d = arr[3] as u32;\n-\n-                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n-                    }\n-\n-                    let p = Process{ pid: pid };\n-                    drop(output);\n-                    let mut bytes = [0; 8];\n-                    return match input.read(&mut bytes) {\n-                        Ok(8) => {\n-                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                                \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                            let errno = combine(&bytes[0.. 4]);\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            Err(super::decode_error(errno))\n-                        }\n-                        Err(ref e) if e.kind == EndOfFile => Ok(p),\n-                        Err(e) => {\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                        },\n-                        Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n-                            panic!(\"short read on the CLOEXEC pipe\")\n-                        }\n-                    };\n-                }\n-\n-                // And at this point we've reached a special time in the life of the\n-                // child. The child must now be considered hamstrung and unable to\n-                // do anything other than syscalls really. Consider the following\n-                // scenario:\n-                //\n-                //      1. Thread A of process 1 grabs the malloc() mutex\n-                //      2. Thread B of process 1 forks(), creating thread C\n-                //      3. Thread C of process 2 then attempts to malloc()\n-                //      4. The memory of process 2 is the same as the memory of\n-                //         process 1, so the mutex is locked.\n-                //\n-                // This situation looks a lot like deadlock, right? It turns out\n-                // that this is what pthread_atfork() takes care of, which is\n-                // presumably implemented across platforms. The first thing that\n-                // threads to *before* forking is to do things like grab the malloc\n-                // mutex, and then after the fork they unlock it.\n-                //\n-                // Despite this information, libnative's spawn has been witnessed to\n-                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n-                // all collected backtraces point at malloc/free traffic in the\n-                // child spawned process.\n-                //\n-                // For this reason, the block of code below should contain 0\n-                // invocations of either malloc of free (or their related friends).\n-                //\n-                // As an example of not having malloc/free traffic, we don't close\n-                // this file descriptor by dropping the FileDesc (which contains an\n-                // allocation). Instead we just close it manually. This will never\n-                // have the drop glue anyway because this code never returns (the\n-                // child will either exec() or invoke libc::exit)\n-                let _ = libc::close(input.fd());\n-\n-                fn fail(output: &mut FileDesc) -> ! {\n-                    let errno = sys::os::errno() as u32;\n-                    let bytes = [\n-                        (errno >> 24) as u8,\n-                        (errno >> 16) as u8,\n-                        (errno >>  8) as u8,\n-                        (errno >>  0) as u8,\n-                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                    ];\n-                    // pipe I/O up to PIPE_BUF bytes should be atomic\n-                    assert!(output.write(&bytes).is_ok());\n-                    unsafe { libc::_exit(1) }\n-                }\n-\n-                rustrt::rust_unset_sigprocmask();\n-\n-                // If a stdio file descriptor is set to be ignored (via a -1 file\n-                // descriptor), then we don't actually close it, but rather open\n-                // up /dev/null into that file descriptor. Otherwise, the first file\n-                // descriptor opened up in the child would be numbered as one of the\n-                // stdio file descriptors, which is likely to wreak havoc.\n-                let setup = |src: Option<P>, dst: c_int| {\n-                    let src = match src {\n-                        None => {\n-                            let flags = if dst == libc::STDIN_FILENO {\n-                                libc::O_RDONLY\n-                            } else {\n-                                libc::O_RDWR\n-                            };\n-                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n-                        }\n-                        Some(obj) => {\n-                            let fd = obj.as_inner().fd();\n-                            // Leak the memory and the file descriptor. We're in the\n-                            // child now an all our resources are going to be\n-                            // cleaned up very soon\n-                            mem::forget(obj);\n-                            fd\n-                        }\n-                    };\n-                    src != -1 && retry(|| dup2(src, dst)) != -1\n-                };\n-\n-                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n-                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n-                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n-\n-                // close all other fds\n-                for fd in (3..getdtablesize()).rev() {\n-                    if fd != output.fd() {\n-                        let _ = close(fd as c_int);\n-                    }\n-                }\n-\n-                match cfg.gid() {\n-                    Some(u) => {\n-                        if libc::setgid(u as libc::gid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                match cfg.uid() {\n-                    Some(u) => {\n-                        // When dropping privileges from root, the `setgroups` call\n-                        // will remove any extraneous groups. If we don't call this,\n-                        // then even though our uid has dropped, we may still have\n-                        // groups that enable us to do super-user things. This will\n-                        // fail if we aren't root, so don't bother checking the\n-                        // return value, this is just done as an optimistic\n-                        // privilege dropping function.\n-                        extern {\n-                            fn setgroups(ngroups: libc::c_int,\n-                                         ptr: *const libc::c_void) -> libc::c_int;\n-                        }\n-                        let _ = setgroups(0, ptr::null());\n-\n-                        if libc::setuid(u as libc::uid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                if cfg.detach() {\n-                    // Don't check the error of setsid because it fails if we're the\n-                    // process leader already. We just forked so it shouldn't return\n-                    // error, but ignore it anyway.\n-                    let _ = libc::setsid();\n-                }\n-                if !dirp.is_null() && chdir(dirp) == -1 {\n-                    fail(&mut output);\n-                }\n-                if !envp.is_null() {\n-                    *sys::os::environ() = envp as *const _;\n-                }\n-                let _ = execvp(*argv, argv as *mut _);\n-                fail(&mut output);\n-            })\n-        })\n-    }\n-    #[cfg(not(stage0))]\n     pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n@@ -766,45 +547,6 @@ fn with_argv<T,F>(prog: &CString, args: &[CString],\n     cb(ptrs.as_ptr())\n }\n \n-#[cfg(stage0)]\n-fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n-                      cb: F)\n-                      -> T\n-    where F : FnOnce(*const c_void) -> T,\n-          K : BytesContainer + Eq + Hash<Hasher>,\n-          V : BytesContainer\n-{\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\0\" strings. Since we must create\n-    // these strings locally, yet expose a raw pointer to them, we\n-    // create a temporary vector to own the CStrings that outlives the\n-    // call to cb.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = Vec::with_capacity(env.len());\n-\n-            for pair in env {\n-                let mut kv = Vec::new();\n-                kv.push_all(pair.0.container_as_bytes());\n-                kv.push('=' as u8);\n-                kv.push_all(pair.1.container_as_bytes());\n-                kv.push(0); // terminating null\n-                tmps.push(kv);\n-            }\n-\n-            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*const libc::c_char> =\n-                tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                    .collect();\n-            ptrs.push(ptr::null());\n-\n-            cb(ptrs.as_ptr() as *const c_void)\n-        }\n-        _ => cb(ptr::null())\n-    }\n-}\n-#[cfg(not(stage0))]\n fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n                       cb: F)\n                       -> T"}, {"sha": "334cafd3eb1136767fa4cc355360e44aafa50183", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -10,7 +10,6 @@\n \n use prelude::v1::*;\n \n-#[cfg(stage0)] use collections::hash_map::Hasher;\n use collections;\n use env;\n use ffi::CString;\n@@ -106,170 +105,6 @@ impl Process {\n     }\n \n     #[allow(deprecated)]\n-    #[cfg(stage0)]\n-    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n-                              out_fd: Option<P>, err_fd: Option<P>)\n-                              -> IoResult<Process>\n-        where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n-              K: BytesContainer + Eq + Hash<Hasher>, V: BytesContainer\n-    {\n-        use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-        use libc::consts::os::extra::{\n-            TRUE, FALSE,\n-            STARTF_USESTDHANDLES,\n-            INVALID_HANDLE_VALUE,\n-            DUPLICATE_SAME_ACCESS\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            GetCurrentProcess,\n-            DuplicateHandle,\n-            CloseHandle,\n-            CreateProcessW\n-        };\n-        use libc::funcs::extra::msvcrt::get_osfhandle;\n-\n-        use mem;\n-        use iter::IteratorExt;\n-        use str::StrExt;\n-\n-        if cfg.gid().is_some() || cfg.uid().is_some() {\n-            return Err(IoError {\n-                kind: old_io::IoUnavailable,\n-                desc: \"unsupported gid/uid requested on windows\",\n-                detail: None,\n-            })\n-        }\n-\n-        // To have the spawning semantics of unix/windows stay the same, we need to\n-        // read the *child's* PATH if one is provided. See #15149 for more details.\n-        let program = cfg.env().and_then(|env| {\n-            for (key, v) in env {\n-                if b\"PATH\" != key.container_as_bytes() { continue }\n-\n-                // Split the value and test each path to see if the\n-                // program exists.\n-                for path in os::split_paths(v.container_as_bytes()) {\n-                    let path = path.join(cfg.program().as_bytes())\n-                                   .with_extension(env::consts::EXE_EXTENSION);\n-                    if path.exists() {\n-                        return Some(CString::from_slice(path.as_vec()))\n-                    }\n-                }\n-                break\n-            }\n-            None\n-        });\n-\n-        unsafe {\n-            let mut si = zeroed_startupinfo();\n-            si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n-            si.dwFlags = STARTF_USESTDHANDLES;\n-\n-            let cur_proc = GetCurrentProcess();\n-\n-            // Similarly to unix, we don't actually leave holes for the stdio file\n-            // descriptors, but rather open up /dev/null equivalents. These\n-            // equivalents are drawn from libuv's windows process spawning.\n-            let set_fd = |fd: &Option<P>, slot: &mut HANDLE,\n-                          is_stdin: bool| {\n-                match *fd {\n-                    None => {\n-                        let access = if is_stdin {\n-                            libc::FILE_GENERIC_READ\n-                        } else {\n-                            libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n-                        };\n-                        let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n-                        let mut sa = libc::SECURITY_ATTRIBUTES {\n-                            nLength: size as libc::DWORD,\n-                            lpSecurityDescriptor: ptr::null_mut(),\n-                            bInheritHandle: 1,\n-                        };\n-                        let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n-                        filename.push(0);\n-                        *slot = libc::CreateFileW(filename.as_ptr(),\n-                                                  access,\n-                                                  libc::FILE_SHARE_READ |\n-                                                      libc::FILE_SHARE_WRITE,\n-                                                  &mut sa,\n-                                                  libc::OPEN_EXISTING,\n-                                                  0,\n-                                                  ptr::null_mut());\n-                        if *slot == INVALID_HANDLE_VALUE {\n-                            return Err(super::last_error())\n-                        }\n-                    }\n-                    Some(ref fd) => {\n-                        let orig = get_osfhandle(fd.as_inner().fd()) as HANDLE;\n-                        if orig == INVALID_HANDLE_VALUE {\n-                            return Err(super::last_error())\n-                        }\n-                        if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n-                                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-                            return Err(super::last_error())\n-                        }\n-                    }\n-                }\n-                Ok(())\n-            };\n-\n-            try!(set_fd(&in_fd, &mut si.hStdInput, true));\n-            try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n-            try!(set_fd(&err_fd, &mut si.hStdError, false));\n-\n-            let cmd_str = make_command_line(program.as_ref().unwrap_or(cfg.program()),\n-                                            cfg.args());\n-            let mut pi = zeroed_process_information();\n-            let mut create_err = None;\n-\n-            // stolen from the libuv code.\n-            let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n-            if cfg.detach() {\n-                flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n-            }\n-\n-            with_envp(cfg.env(), |envp| {\n-                with_dirp(cfg.cwd(), |dirp| {\n-                    let mut cmd_str: Vec<u16> = cmd_str.utf16_units().collect();\n-                    cmd_str.push(0);\n-                    let _lock = CREATE_PROCESS_LOCK.lock().unwrap();\n-                    let created = CreateProcessW(ptr::null(),\n-                                                 cmd_str.as_mut_ptr(),\n-                                                 ptr::null_mut(),\n-                                                 ptr::null_mut(),\n-                                                 TRUE,\n-                                                 flags, envp, dirp,\n-                                                 &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(super::last_error());\n-                    }\n-                })\n-            });\n-\n-            assert!(CloseHandle(si.hStdInput) != 0);\n-            assert!(CloseHandle(si.hStdOutput) != 0);\n-            assert!(CloseHandle(si.hStdError) != 0);\n-\n-            match create_err {\n-                Some(err) => return Err(err),\n-                None => {}\n-            }\n-\n-            // We close the thread handle because we don't care about keeping the\n-            // thread id valid, and we aren't keeping the thread handle around to be\n-            // able to close it later. We don't close the process handle however\n-            // because std::we want the process id to stay valid at least until the\n-            // calling code closes the process handle.\n-            assert!(CloseHandle(pi.hThread) != 0);\n-\n-            Ok(Process {\n-                pid: pi.dwProcessId as pid_t,\n-                handle: pi.hProcess as *mut ()\n-            })\n-        }\n-    }\n-    #[allow(deprecated)]\n-    #[cfg(not(stage0))]\n     pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n@@ -589,35 +424,6 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     }\n }\n \n-#[cfg(stage0)]\n-fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T\n-    where K: BytesContainer + Eq + Hash<Hasher>,\n-          V: BytesContainer,\n-          F: FnOnce(*mut c_void) -> T,\n-{\n-    // On Windows we pass an \"environment block\" which is not a char**, but\n-    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n-    // \\0 to terminate.\n-    match env {\n-        Some(env) => {\n-            let mut blk = Vec::new();\n-\n-            for pair in env {\n-                let kv = format!(\"{}={}\",\n-                                 pair.0.container_as_str().unwrap(),\n-                                 pair.1.container_as_str().unwrap());\n-                blk.extend(kv.utf16_units());\n-                blk.push(0);\n-            }\n-\n-            blk.push(0);\n-\n-            cb(blk.as_mut_ptr() as *mut c_void)\n-        }\n-        _ => cb(ptr::null_mut())\n-    }\n-}\n-#[cfg(not(stage0))]\n fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T\n     where K: BytesContainer + Eq + Hash,\n           V: BytesContainer,"}, {"sha": "1f70e1526a096c61c5b0c50d1d14704d9d6c0a27", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -465,16 +465,16 @@ impl Thread {\n         }\n     }\n \n-    /// Deprecated: use module-level free fucntion.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n+    /// Deprecated: use module-level free function.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n     #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n         Builder::new().spawn(f).unwrap().thread().clone()\n     }\n \n-    /// Deprecated: use module-level free fucntion.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n+    /// Deprecated: use module-level free function.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n     #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n@@ -483,30 +483,30 @@ impl Thread {\n         Builder::new().scoped(f).unwrap()\n     }\n \n-    /// Deprecated: use module-level free fucntion.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n+    /// Deprecated: use module-level free function.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn current() -> Thread {\n         thread_info::current_thread()\n     }\n \n-    /// Deprecated: use module-level free fucntion.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n+    /// Deprecated: use module-level free function.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n     #[unstable(feature = \"std_misc\", reason = \"name may change\")]\n     pub fn yield_now() {\n         unsafe { imp::yield_now() }\n     }\n \n-    /// Deprecated: use module-level free fucntion.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n+    /// Deprecated: use module-level free function.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n \n-    /// Deprecated: use module-level free fucntion.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n+    /// Deprecated: use module-level free function.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park() {\n         let thread = current();\n@@ -517,8 +517,8 @@ impl Thread {\n         *guard = false;\n     }\n \n-    /// Deprecated: use module-level free fucntion.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n+    /// Deprecated: use module-level free function.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park_timeout(dur: Duration) {\n         let thread = current();\n@@ -702,7 +702,7 @@ mod test {\n     use boxed::BoxAny;\n     use result;\n     use std::old_io::{ChanReader, ChanWriter};\n-    use super::{Thread, Builder};\n+    use super::{Builder};\n     use thread;\n     use thunk::Thunk;\n     use time::Duration;\n@@ -767,7 +767,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_scoped_implicit_panic() {\n-        thread::scoped(|| panic!());\n+        let _ = thread::scoped(|| panic!());\n     }\n \n     #[test]"}, {"sha": "5bede984f13c7bc37bdb9bb00ccc443419664340", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -17,9 +17,6 @@ use core::marker::Send;\n use core::ops::FnOnce;\n \n pub struct Thunk<'a, A=(),R=()> {\n-    #[cfg(stage0)]\n-    invoke: Box<Invoke<A,R>+Send>,\n-    #[cfg(not(stage0))]\n     invoke: Box<Invoke<A,R>+Send + 'a>,\n }\n "}, {"sha": "009bfef86230f76add03dc90a0232912a67969b6", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -113,7 +113,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         Some(('=', _)) => None,\n                         Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(&format!(\n-                                        \"={}\", operand)[]))\n+                                        \"={}\", operand)))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");"}, {"sha": "2ef90f04f7527d214cf07b779a1a453ec0041f61", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -83,15 +83,15 @@ pub enum Annotatable {\n impl Annotatable {\n     pub fn attrs(&self) -> &[ast::Attribute] {\n         match *self {\n-            Annotatable::Item(ref i) => &i.attrs[],\n+            Annotatable::Item(ref i) => &i.attrs,\n             Annotatable::TraitItem(ref i) => match *i {\n-                ast::TraitItem::RequiredMethod(ref tm) => &tm.attrs[],\n-                ast::TraitItem::ProvidedMethod(ref m) => &m.attrs[],\n-                ast::TraitItem::TypeTraitItem(ref at) => &at.attrs[],\n+                ast::TraitItem::RequiredMethod(ref tm) => &tm.attrs,\n+                ast::TraitItem::ProvidedMethod(ref m) => &m.attrs,\n+                ast::TraitItem::TypeTraitItem(ref at) => &at.attrs,\n             },\n             Annotatable::ImplItem(ref i) => match *i {\n-                ast::ImplItem::MethodImplItem(ref m) => &m.attrs[],\n-                ast::ImplItem::TypeImplItem(ref t) => &t.attrs[],\n+                ast::ImplItem::MethodImplItem(ref m) => &m.attrs,\n+                ast::ImplItem::TypeImplItem(ref t) => &t.attrs,\n             }\n         }\n     }\n@@ -639,7 +639,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n-        v.push(token::str_to_ident(&self.ecfg.crate_name[]));\n+        v.push(token::str_to_ident(&self.ecfg.crate_name));\n         v.extend(self.mod_path.iter().cloned());\n         return v;\n     }\n@@ -648,7 +648,7 @@ impl<'a> ExtCtxt<'a> {\n         if self.recursion_count > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                                    ei.callee.name)[]);\n+                                    ei.callee.name));\n         }\n \n         let mut call_site = ei.call_site;\n@@ -773,7 +773,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n                       tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n-        cx.span_err(sp, &format!(\"{} takes no arguments\", name)[]);\n+        cx.span_err(sp, &format!(\"{} takes no arguments\", name));\n     }\n }\n \n@@ -786,12 +786,12 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n                                -> Option<String> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n+        cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None\n     }\n     let ret = cx.expander().fold_expr(p.parse_expr());\n     if p.token != token::Eof {\n-        cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n+        cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n         s.to_string()"}, {"sha": "8923290d655c81812071a3fb04da62324b3839d5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -762,7 +762,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span,\n-                                      token::intern_and_get_ident(&loc.file.name[]));\n+                                      token::intern_and_get_ident(&loc.file.name));\n         let expr_line = self.expr_usize(span, loc.line);\n         let expr_file_line_tuple = self.expr_tuple(span, vec!(expr_file, expr_line));\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);"}, {"sha": "84f786e9780f0425bbdc089827060c50d0e31ad6", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -40,14 +40,14 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitInt(i, ast::UnsignedIntLit(_)) |\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Plus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                        accumulator.push_str(&format!(\"{}\", i)[]);\n+                        accumulator.push_str(&format!(\"{}\", i));\n                     }\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Minus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Minus)) => {\n-                        accumulator.push_str(&format!(\"-{}\", i)[]);\n+                        accumulator.push_str(&format!(\"-{}\", i));\n                     }\n                     ast::LitBool(b) => {\n-                        accumulator.push_str(&format!(\"{}\", b)[]);\n+                        accumulator.push_str(&format!(\"{}\", b));\n                     }\n                     ast::LitByte(..) |\n                     ast::LitBinary(..) => {"}, {"sha": "5f460264216a1567182a5c8b63f3d6bb44623455", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -81,11 +81,11 @@ fn cs_clone(\n         EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n                         &format!(\"non-matching enum variants in \\\n-                                 `derive({})`\", name)[])\n+                                 `derive({})`\", name))\n         }\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span,\n-                        &format!(\"static method in `derive({})`\", name)[])\n+                        &format!(\"static method in `derive({})`\", name))\n         }\n     }\n \n@@ -102,7 +102,7 @@ fn cs_clone(\n                 None => {\n                     cx.span_bug(trait_span,\n                                 &format!(\"unnamed field in normal struct in \\\n-                                         `derive({})`\", name)[])\n+                                         `derive({})`\", name))\n                 }\n             };\n             cx.field_imm(field.span, ident, subcall(field))"}, {"sha": "f27bbc338e5704b05f89bb5573d3834c1ca01695", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -204,7 +204,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n             } else {\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(cx, span,\n-                           token::intern_and_get_ident(&format!(\"_field{}\", i)[]),\n+                           token::intern_and_get_ident(&format!(\"_field{}\", i)),\n                            i)\n                 }).collect();\n "}, {"sha": "8038074cee14fbe3473da0f0ce5997bbb6a9b800", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -191,7 +191,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let name = match name {\n                     Some(id) => token::get_ident(id),\n                     None => {\n-                        token::intern_and_get_ident(&format!(\"_field{}\", i)[])\n+                        token::intern_and_get_ident(&format!(\"_field{}\", i))\n                     }\n                 };\n                 let enc = cx.expr_method_call(span, self_.clone(),"}, {"sha": "36bd8d39a83631af78f184b09e9a4b770f5ec721", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -363,7 +363,7 @@ impl<'a> TraitDef<'a> {\n         // generated implementations are linted\n         let mut attrs = newitem.attrs.clone();\n         attrs.extend(item.attrs.iter().filter(|a| {\n-            match &a.name()[] {\n+            match &a.name()[..] {\n                 \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n                 _ => false,\n             }\n@@ -671,7 +671,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(&format!(\"__arg_{}\", i)[]);\n+            let ident = cx.ident_of(&format!(\"__arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -778,7 +778,7 @@ impl<'a> MethodDef<'a> {\n                                              struct_path,\n                                              struct_def,\n                                              &format!(\"__self_{}\",\n-                                                     i)[],\n+                                                     i),\n                                              ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n@@ -971,7 +971,7 @@ impl<'a> MethodDef<'a> {\n                 let mut subpats = Vec::with_capacity(self_arg_names.len());\n                 let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n                 let first_self_pat_idents = {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0][]);\n+                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0]);\n                     subpats.push(p);\n                     idents\n                 };\n@@ -1289,7 +1289,7 @@ impl<'a> TraitDef<'a> {\n                     cx.span_bug(sp, \"a struct with named and unnamed fields in `derive`\");\n                 }\n             };\n-            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)[]);\n+            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n             paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr(\n                 sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n@@ -1335,7 +1335,7 @@ impl<'a> TraitDef<'a> {\n                 let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n-                    let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)[]);\n+                    let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n                     let path1 = codemap::Spanned{span: sp, node: ident};\n                     paths.push(path1);\n                     let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n@@ -1378,15 +1378,15 @@ pub fn cs_fold<F>(use_foldl: bool,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      &field.other[])\n+                      &field.other)\n                 })\n             } else {\n                 all_fields.iter().rev().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      &field.other[])\n+                      &field.other)\n                 })\n             }\n         },"}, {"sha": "eee780f457c9f053049e67f174f093c9016b5477", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -157,7 +157,7 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                                 cx.span_err(titem.span,\n                                             &format!(\"unknown `derive` \\\n                                                      trait: `{}`\",\n-                                                    *tname)[]);\n+                                                    *tname));\n                             }\n                         };\n                     }"}, {"sha": "93f8ee5042bb1674e7843180e51bbc5832c827d7", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -83,7 +83,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         None => {\n             token::intern_and_get_ident(&format!(\"environment variable `{}` \\\n                                                  not defined\",\n-                                                var)[])\n+                                                var))\n         }\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {"}, {"sha": "bc239d0c7c2698fb5d097579ff555f56202ff8ea", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -389,7 +389,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                     fld.cx.span_err(\n                         pth.span,\n                         &format!(\"macro undefined: '{}!'\",\n-                                &extnamestr)[]);\n+                                &extnamestr));\n \n                     // let compilation continue\n                     None\n@@ -426,7 +426,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                     pth.span,\n                                     &format!(\"non-expression macro in expression position: {}\",\n                                             &extnamestr[..]\n-                                            )[]);\n+                                            ));\n                                 return None;\n                             }\n                         };\n@@ -436,7 +436,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.span_err(\n                             pth.span,\n                             &format!(\"'{}' is not a tt-style macro\",\n-                                    &extnamestr)[]);\n+                                    &extnamestr));\n                         None\n                     }\n                 }\n@@ -608,7 +608,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n             None => {\n                 fld.cx.span_err(path_span,\n                                 &format!(\"macro undefined: '{}!'\",\n-                                        extnamestr)[]);\n+                                        extnamestr));\n                 // let compilation continue\n                 return SmallVector::zero();\n             }\n@@ -618,10 +618,9 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name != parse::token::special_idents::invalid.name {\n                         fld.cx\n                             .span_err(path_span,\n-                                      &format!(\"macro {}! expects no ident argument, \\\n-                                        given '{}'\",\n-                                      extnamestr,\n-                                      token::get_ident(it.ident))[]);\n+                                      &format!(\"macro {}! expects no ident argument, given '{}'\",\n+                                               extnamestr,\n+                                               token::get_ident(it.ident)));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -640,7 +639,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n-                                                &extnamestr)[]);\n+                                                &extnamestr));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -659,7 +658,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro_rules! expects an ident argument\")\n-                                        []);\n+                                        );\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -691,7 +690,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                 _ => {\n                     fld.cx.span_err(it.span,\n                                     &format!(\"{}! is not legal in item position\",\n-                                            &extnamestr)[]);\n+                                            &extnamestr));\n                     return SmallVector::zero();\n                 }\n             }\n@@ -710,7 +709,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         None => {\n             fld.cx.span_err(path_span,\n                             &format!(\"non-item macro in item position: {}\",\n-                                    &extnamestr)[]);\n+                                    &extnamestr));\n             return SmallVector::zero();\n         }\n     };\n@@ -954,7 +953,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             None => {\n                 fld.cx.span_err(pth.span,\n                                 &format!(\"macro undefined: '{}!'\",\n-                                        extnamestr)[]);\n+                                        extnamestr));\n                 // let compilation continue\n                 return DummyResult::raw_pat(span);\n             }\n@@ -983,7 +982,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                                 &format!(\n                                     \"non-pattern macro in pattern position: {}\",\n                                     &extnamestr\n-                                    )[]\n+                                    )\n                             );\n                             return DummyResult::raw_pat(span);\n                         }\n@@ -995,7 +994,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 _ => {\n                     fld.cx.span_err(span,\n                                     &format!(\"{}! is not legal in pattern position\",\n-                                            &extnamestr)[]);\n+                                            &extnamestr));\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -1981,7 +1980,7 @@ foo_module!();\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && \"xx\" == &token::get_ident(p.segments[0].identifier)[]\n+            && \"xx\" == &*token::get_ident(p.segments[0].identifier)\n         }).enumerate() {\n             if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");"}, {"sha": "1c2374e31f13037820596790264e98aeea593981", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -113,7 +113,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 _ => {\n                     ecx.span_err(p.span,\n                                  &format!(\"expected ident for named argument, found `{}`\",\n-                                         p.this_token_to_string())[]);\n+                                         p.this_token_to_string()));\n                     return None;\n                 }\n             };\n@@ -127,7 +127,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 Some(prev) => {\n                     ecx.span_err(e.span,\n                                  &format!(\"duplicate argument named `{}`\",\n-                                         name)[]);\n+                                         name));\n                     ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n                     continue\n                 }\n@@ -281,19 +281,19 @@ impl<'a, 'b> Context<'a, 'b> {\n                                   &format!(\"argument redeclared with type `{}` when \\\n                                            it was previously `{}`\",\n                                           *ty,\n-                                          *cur)[]);\n+                                          *cur));\n             }\n             (&Known(ref cur), _) => {\n                 self.ecx.span_err(sp,\n                                   &format!(\"argument used to format with `{}` was \\\n                                            attempted to not be used for formatting\",\n-                                           *cur)[]);\n+                                           *cur));\n             }\n             (_, &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   &format!(\"argument previously used as a format \\\n                                            argument attempted to be used as `{}`\",\n-                                           *ty)[]);\n+                                           *ty));\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -337,7 +337,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = token::intern_and_get_ident(&self.literal[]);\n+        let s = token::intern_and_get_ident(&self.literal);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n@@ -494,7 +494,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 None => continue // error already generated\n             };\n \n-            let name = self.ecx.ident_of(&format!(\"__arg{}\", i)[]);\n+            let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(e.span, name));\n             locals.push(Context::format_arg(self.ecx, e.span, arg_ty,\n                                             self.ecx.expr_ident(e.span, name)));\n@@ -511,7 +511,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             };\n \n             let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n-                                                  *name)[]);\n+                                                  *name));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n             names[self.name_positions[*name]] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n@@ -600,7 +600,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     _ => {\n                         ecx.span_err(sp,\n                                      &format!(\"unknown format trait `{}`\",\n-                                             *tyname)[]);\n+                                             *tyname));\n                         \"Dummy\"\n                     }\n                 }\n@@ -694,7 +694,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n     if !parser.errors.is_empty() {\n         cx.ecx.span_err(cx.fmtsp, &format!(\"invalid format string: {}\",\n-                                          parser.errors.remove(0))[]);\n+                                          parser.errors.remove(0)));\n         return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {"}, {"sha": "554529b5cb23cc4a805d1d9f69cce55372ac905a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -466,7 +466,7 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n }\n \n fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n-    strs.iter().map(|str| str_to_ident(&(*str)[])).collect()\n+    strs.iter().map(|str| str_to_ident(&(*str))).collect()\n }\n \n fn id_ext(str: &str) -> ast::Ident {"}, {"sha": "ac82effeaeacdbdaf4043b268c3b6e11b4cf1ec4", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -57,7 +57,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = cx.original_span_in_file();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name[]);\n+    let filename = token::intern_and_get_ident(&loc.file.name);\n     base::MacExpr::new(cx.expr_str(topmost, filename))\n }\n "}, {"sha": "ce513bc91f5a998fda321bb638b4a68bbd0d926c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -153,7 +153,7 @@ pub fn count_names(ms: &[TokenTree]) -> usize {\n                 seq.num_captures\n             }\n             &TtDelimited(_, ref delim) => {\n-                count_names(&delim.tts[])\n+                count_names(&delim.tts)\n             }\n             &TtToken(_, MatchNt(..)) => {\n                 1"}, {"sha": "a0e2b4dbf5a70bae65ede6b0efb4c520ac2a8f1e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -94,7 +94,7 @@ impl<'a> ParserAttr for Parser<'a> {\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                self.fatal(&format!(\"expected `#`, found `{}`\", token_str)[]);\n+                self.fatal(&format!(\"expected `#`, found `{}`\", token_str));\n             }\n         };\n "}, {"sha": "83d2bb0cc70a9b542572ab7ddd6f86a16e80f68c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1109,7 +1109,7 @@ impl<'a> StringReader<'a> {\n                 // expansion purposes. See #12512 for the gory details of why\n                 // this is necessary.\n                 let ident = self.with_str_from(start, |lifetime_name| {\n-                    str_to_ident(&format!(\"'{}\", lifetime_name)[])\n+                    str_to_ident(&format!(\"'{}\", lifetime_name))\n                 });\n \n                 // Conjure up a \"keyword checking ident\" to make sure that"}, {"sha": "43dfcbae57e497b0a82f493ff427bbaccfe75fe4", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -254,7 +254,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n         Ok(bytes) => bytes,\n         Err(e) => {\n             err(&format!(\"couldn't read {:?}: {}\",\n-                        path.display(), e)[]);\n+                        path.display(), e));\n             unreachable!()\n         }\n     };\n@@ -264,7 +264,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n                                      path.as_str().unwrap().to_string())\n         }\n         None => {\n-            err(&format!(\"{:?} is not UTF-8 encoded\", path.display())[])\n+            err(&format!(\"{:?} is not UTF-8 encoded\", path.display()))\n         }\n     }\n     unreachable!()\n@@ -827,19 +827,19 @@ mod test {\n              ast::TtDelimited(_, ref macro_delimed)]\n             if name_macro_rules.as_str() == \"macro_rules\"\n             && name_zip.as_str() == \"zip\" => {\n-                match &macro_delimed.tts[] {\n+                match &macro_delimed.tts[..] {\n                     [ast::TtDelimited(_, ref first_delimed),\n                      ast::TtToken(_, token::FatArrow),\n                      ast::TtDelimited(_, ref second_delimed)]\n                     if macro_delimed.delim == token::Paren => {\n-                        match &first_delimed.tts[] {\n+                        match &first_delimed.tts[..] {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if first_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n-                        match &second_delimed.tts[] {\n+                        match &second_delimed.tts[..] {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if second_delimed.delim == token::Paren\n@@ -1207,7 +1207,7 @@ mod test {\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n-        let docs = item.attrs.iter().filter(|a| &a.name()[] == \"doc\")\n+        let docs = item.attrs.iter().filter(|a| &*a.name() == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);"}, {"sha": "e6bcb8ac745675b0c4a8ec2320db2311805f6dfb", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -106,16 +106,16 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n               desc: &str,\n               error: bool) {\n         if error {\n-            self.span_err(sp, &format!(\"obsolete syntax: {}\", kind_str)[]);\n+            self.span_err(sp, &format!(\"obsolete syntax: {}\", kind_str));\n         } else {\n-            self.span_warn(sp, &format!(\"obsolete syntax: {}\", kind_str)[]);\n+            self.span_warn(sp, &format!(\"obsolete syntax: {}\", kind_str));\n         }\n \n         if !self.obsolete_set.contains(&kind) {\n             self.sess\n                 .span_diagnostic\n                 .handler()\n-                .note(&format!(\"{}\", desc)[]);\n+                .note(&format!(\"{}\", desc));\n             self.obsolete_set.insert(kind);\n         }\n     }"}, {"sha": "88c349371592c4cacce0d33d5a3816c88a27a404", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -2562,7 +2562,8 @@ impl<'a> Parser<'a> {\n                     let index = self.mk_index(e, ix);\n                     e = self.mk_expr(lo, hi, index);\n \n-                    self.obsolete(span, ObsoleteSyntax::EmptyIndex);\n+                    let obsolete_span = mk_sp(bracket_pos, hi);\n+                    self.obsolete(obsolete_span, ObsoleteSyntax::EmptyIndex);\n                 } else {\n                     let ix = self.parse_expr();\n                     hi = self.span.hi;\n@@ -5190,7 +5191,7 @@ impl<'a> Parser<'a> {\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut prefix = Path::new(self.sess.span_diagnostic.cm.span_to_filename(self.span));\n         prefix.pop();\n-        let mod_path = Path::new(\".\").join_many(&self.mod_path_stack[]);\n+        let mod_path = Path::new(\".\").join_many(&self.mod_path_stack);\n         let dir_path = prefix.join(&mod_path);\n         let mod_string = token::get_ident(id);\n         let (file_path, owns_directory) = match ::attr::first_attr_value_str_by_name("}, {"sha": "2797ef084d9caf36185d985b3bd46ed437f9b755", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -652,47 +652,47 @@ impl BytesContainer for InternedString {\n \n impl fmt::Debug for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.string[], f)\n+        fmt::Debug::fmt(&self.string, f)\n     }\n }\n \n impl fmt::Display for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.string[], f)\n+        fmt::Display::fmt(&self.string, f)\n     }\n }\n \n impl<'a> PartialEq<&'a str> for InternedString {\n     #[inline(always)]\n     fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(&self.string[], *other)\n+        PartialEq::eq(&self.string[..], *other)\n     }\n     #[inline(always)]\n     fn ne(&self, other: & &'a str) -> bool {\n-        PartialEq::ne(&self.string[], *other)\n+        PartialEq::ne(&self.string[..], *other)\n     }\n }\n \n impl<'a> PartialEq<InternedString > for &'a str {\n     #[inline(always)]\n     fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, &other.string[])\n+        PartialEq::eq(*self, &other.string[..])\n     }\n     #[inline(always)]\n     fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(*self, &other.string[])\n+        PartialEq::ne(*self, &other.string[..])\n     }\n }\n \n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(get_name(get_ident_interner().intern(&try!(d.read_str())[])))\n+        Ok(get_name(get_ident_interner().intern(&try!(d.read_str())[..])))\n     }\n }\n \n impl Encodable for InternedString {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.string[])\n+        s.emit_str(&self.string)\n     }\n }\n "}, {"sha": "5b3fde8535b3df4dfd1a8a189a722047e0d8e02b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -139,7 +139,7 @@ pub fn buf_str(toks: &[Token],\n         }\n         s.push_str(&format!(\"{}={}\",\n                            szs[i],\n-                           tok_str(&toks[i]))[]);\n+                           tok_str(&toks[i])));\n         i += 1;\n         i %= n;\n     }"}, {"sha": "92e7f4d287091ca283829cb283c15bc7d1844f89", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -2342,7 +2342,7 @@ impl<'a> State<'a> {\n \n         // HACK(eddyb) ignore the separately printed self argument.\n         let args = if first {\n-            &decl.inputs[]\n+            &decl.inputs[..]\n         } else {\n             &decl.inputs[1..]\n         };"}, {"sha": "ca3a1848c3a6161313590be914a2b5d1a2756302", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -111,13 +111,6 @@ impl<T: Display> Display for P<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Hasher, T: Hash<S>> Hash<S> for P<T> {\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T: Hash> Hash for P<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);"}, {"sha": "ac7cdb1b4130703ba30b7150a4eb25331b6cc7e8", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -38,7 +38,7 @@ pub fn maybe_inject_prelude(krate: ast::Crate) -> ast::Crate {\n }\n \n pub fn use_std(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(&krate.attrs[], \"no_std\")\n+    !attr::contains_name(&krate.attrs, \"no_std\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -88,14 +88,14 @@ impl fold::Folder for PreludeInjector {\n         // only add `use std::prelude::*;` if there wasn't a\n         // `#![no_implicit_prelude]` at the crate level.\n         // fold_mod() will insert glob path.\n-        if !no_prelude(&krate.attrs[]) {\n+        if !no_prelude(&krate.attrs) {\n             krate.module = self.fold_mod(krate.module);\n         }\n         krate\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if !no_prelude(&item.attrs[]) {\n+        if !no_prelude(&item.attrs) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree"}, {"sha": "5bada41badfd8077b4980f4bb79deb6c6fc4066a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -73,14 +73,14 @@ pub fn modify_for_testing(sess: &ParseSess,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains_name(&krate.config[], \"test\");\n+    let should_test = attr::contains_name(&krate.config, \"test\");\n \n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use some_name = __test::main;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(&krate.attrs[],\n+        attr::first_attr_value_str_by_name(&krate.attrs,\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n@@ -306,7 +306,7 @@ enum HasTestSignature {\n \n \n fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(&i.attrs[], \"test\");\n+    let has_test_attr = attr::contains_name(&i.attrs, \"test\");\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match &i.node {\n@@ -342,7 +342,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n }\n \n fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(&i.attrs[], \"bench\");\n+    let has_bench_attr = attr::contains_name(&i.attrs, \"bench\");\n \n     fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n@@ -562,7 +562,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n-    match attr::find_crate_name(&krate.attrs[]) {\n+    match attr::find_crate_name(&krate.attrs) {\n         Some(ref s) if \"test\" == &s[..] => true,\n         _ => false\n     }"}, {"sha": "5be45a2698f40ae34c295c3e2e892994d465fc2a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -18,7 +18,6 @@ use std::borrow::Borrow;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::HashMap;\n-#[cfg(stage0)] use std::collections::hash_map::Hasher;\n use std::fmt;\n use std::hash::Hash;\n use std::ops::Deref;\n@@ -30,71 +29,6 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n-#[cfg(stage0)]\n-impl<T: Eq + Hash<Hasher> + Clone + 'static> Interner<T> {\n-    pub fn new() -> Interner<T> {\n-        Interner {\n-            map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(Vec::new()),\n-        }\n-    }\n-\n-    pub fn prefill(init: &[T]) -> Interner<T> {\n-        let rv = Interner::new();\n-        for v in init {\n-            rv.intern((*v).clone());\n-        }\n-        rv\n-    }\n-\n-    pub fn intern(&self, val: T) -> Name {\n-        let mut map = self.map.borrow_mut();\n-        match (*map).get(&val) {\n-            Some(&idx) => return idx,\n-            None => (),\n-        }\n-\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        (*map).insert(val.clone(), new_idx);\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn gensym(&self, val: T) -> Name {\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        // leave out of .map to avoid colliding\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn get(&self, idx: Name) -> T {\n-        let vect = self.vect.borrow();\n-        (*vect)[idx.usize()].clone()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        let vect = self.vect.borrow();\n-        (*vect).len()\n-    }\n-\n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where T: Borrow<Q>, Q: Eq + Hash<Hasher> {\n-        let map = self.map.borrow();\n-        match (*map).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n-    }\n-\n-    pub fn clear(&self) {\n-        *self.map.borrow_mut() = HashMap::new();\n-        *self.vect.borrow_mut() = Vec::new();\n-    }\n-}\n-// when traits can extend traits, we should extend index<Name,T> to get []\n-#[cfg(not(stage0))]\n impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n@@ -275,15 +209,6 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n-    #[cfg(stage0)]\n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where RcStr: Borrow<Q>, Q: Eq + Hash<Hasher> {\n-        match (*self.map.borrow()).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where RcStr: Borrow<Q>, Q: Eq + Hash {\n         match (*self.map.borrow()).get(val) {"}, {"sha": "46a942b6eeb86a24f1345dbe733a2dc1b0279e55", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -1,3 +1,12 @@\n+S 2015-02-19 522d09d\n+  freebsd-x86_64 7ea14ef85a25bca70a310a2cd660b356cf61abc7\n+  linux-i386 26e3caa1ce1c482b9941a6bdc64b3e65d036c200\n+  linux-x86_64 44f514aabb4e4049e4db9a4e1fdeb16f6cee60f2\n+  macos-i386 157910592224083df56f5f31ced3e6f3dc9b1de0\n+  macos-x86_64 56c28aa0e14ec6991ad6ca213568f1155561105d\n+  winnt-i386 da0f7a3fbc913fbb177917f2850bb41501affb5c\n+  winnt-x86_64 22bd816ccd2690fc9804b27ca525f603be8aeaa5\n+\n S 2015-02-17 f1bb6c2\n   freebsd-x86_64 59f3a2c6350c170804fb65838e1b504eeab89105\n   linux-i386 191ed5ec4f17e32d36abeade55a1c6085e51245c"}, {"sha": "15f04df6939811dce2bc9ac603907d710de24ade", "filename": "src/test/compile-fail/if-loop.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Ftest%2Fcompile-fail%2Fif-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Ftest%2Fcompile-fail%2Fif-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-loop.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+// This used to ICE because the \"if\" being unreachable was not handled correctly\n+fn err() {\n+    if loop {} {}\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "56d2b2cd6c0845c8a2b4e1ca0df6e6e95ddb853f", "filename": "src/test/compile-fail/lint-unsafe-block.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b01a37ec38db9301239f0c0abcf3c695055b0ff/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs?ref=2b01a37ec38db9301239f0c0abcf3c695055b0ff", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(unused_unsafe)]\n-#![allow(dead_code)]\n-#![deny(unsafe_blocks)]\n-unsafe fn allowed() {}\n-\n-#[allow(unsafe_blocks)] fn also_allowed() { unsafe {} }\n-\n-macro_rules! unsafe_in_macro {\n-    () => {\n-        unsafe {} //~ ERROR: usage of an `unsafe` block\n-    }\n-}\n-\n-fn main() {\n-    unsafe {} //~ ERROR: usage of an `unsafe` block\n-\n-    unsafe_in_macro!()\n-}"}, {"sha": "7b17d8877572f14b6ee5b34474c7cb65c1f5164d", "filename": "src/test/compile-fail/lint-unsafe-code.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_unsafe)]\n+#![allow(dead_code)]\n+#![deny(unsafe_code)]\n+\n+use std::marker::PhantomFn;\n+\n+struct Bar;\n+\n+#[allow(unsafe_code)]\n+mod allowed_unsafe {\n+    use std::marker::PhantomFn;\n+    fn allowed() { unsafe {} }\n+    unsafe fn also_allowed() {}\n+    unsafe trait AllowedUnsafe : PhantomFn<Self> {}\n+    unsafe impl AllowedUnsafe for super::Bar {}\n+}\n+\n+macro_rules! unsafe_in_macro {\n+    () => {\n+        unsafe {} //~ ERROR: usage of an `unsafe` block\n+    }\n+}\n+\n+unsafe fn baz() {} //~ ERROR: declaration of an `unsafe` function\n+unsafe trait Foo : PhantomFn<Self> {} //~ ERROR: declaration of an `unsafe` trait\n+unsafe impl Foo for Bar {} //~ ERROR: implementation of an `unsafe` trait\n+\n+trait Baz {\n+    unsafe fn baz(&self); //~ ERROR: declaration of an `unsafe` method\n+    unsafe fn provided(&self) {} //~ ERROR: implementation of an `unsafe` method\n+    unsafe fn provided_override(&self) {} //~ ERROR: implementation of an `unsafe` method\n+}\n+\n+impl Baz for Bar {\n+    unsafe fn baz(&self) {} //~ ERROR: implementation of an `unsafe` method\n+    unsafe fn provided_override(&self) {} //~ ERROR: implementation of an `unsafe` method\n+}\n+\n+fn main() {\n+    unsafe {} //~ ERROR: usage of an `unsafe` block\n+\n+    unsafe_in_macro!()\n+}"}, {"sha": "30648498ba88589db46d0e9b2b89a268083de59e", "filename": "src/test/compile-fail/suggest-private-fields.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:struct-field-privacy.rs\n+\n+extern crate \"struct-field-privacy\" as xc;\n+\n+use xc::B;\n+\n+struct A {\n+    pub a: u32,\n+    b: u32,\n+}\n+\n+fn main () {\n+    // external crate struct\n+    let k = B {\n+        aa: 20, //~ ERROR structure `struct-field-privacy::B` has no field named `aa`\n+        //~^ HELP did you mean `a`?\n+        bb: 20, //~ ERROR structure `struct-field-privacy::B` has no field named `bb`\n+    };\n+    // local crate struct\n+    let l = A {\n+        aa: 20, //~ ERROR structure `A` has no field named `aa`\n+        //~^ HELP did you mean `a`?\n+        bb: 20, //~ ERROR structure `A` has no field named `bb`\n+        //~^ HELP did you mean `b`?\n+    };\n+}"}, {"sha": "7c0ab11bc44620b070b47f911a03d1fb61db0117", "filename": "src/test/run-pass/issue-22356.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Ftest%2Frun-pass%2Fissue-22356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb1b500a9a69b149295c37c2fe2c9409f406f9ea/src%2Ftest%2Frun-pass%2Fissue-22356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22356.rs?ref=eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::{PhantomData, PhantomFn};\n+\n+pub struct Handle<T, I>(T, I);\n+\n+impl<T, I> Handle<T, I> {\n+    pub fn get_info(&self) -> &I {\n+        let Handle(_, ref info) = *self;\n+        info\n+    }\n+}\n+\n+pub struct BufferHandle<D: Device, T> {\n+    raw: RawBufferHandle<D>,\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<D: Device, T> BufferHandle<D, T> {\n+    pub fn get_info(&self) -> &String {\n+        self.raw.get_info()\n+    }\n+}\n+\n+pub type RawBufferHandle<D: Device> = Handle<<D as Device>::Buffer, String>;\n+\n+pub trait Device: PhantomFn<Self> {\n+    type Buffer;\n+}\n+\n+fn main() {}"}]}