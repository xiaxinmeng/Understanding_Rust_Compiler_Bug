{"sha": "a04b2cda0bf2f6f8c5c0a483b8f3356bde1cbd80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNGIyY2RhMGJmMmY2ZjhjNWMwYTQ4M2I4ZjMzNTZiZGUxY2JkODA=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2018-06-29T20:46:20Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2018-08-03T05:55:10Z"}, "message": "Provide `{to,from}_{ne,le,be}_bytes` functions on integers\n\nIf one doesn't view integers as containers of bytes, converting them to\nbytes necessarily needs the specfication of encoding.\n\nI think Rust is a language that wants to be explicit. The `to_bytes`\nfunction is basically the opposite of that \u2013 it converts an integer into\nthe native byte representation, but there's no mention (in the function\nname) of it being very much platform dependent. Therefore, I think it\nwould be better to replace that method by three methods, the explicit\n`to_ne_bytes` (\"native endian\") which does the same thing and\n`to_{le,be}_bytes` which return the little- resp. big-endian encoding.", "tree": {"sha": "d4d22b6917d878bf8fbcf276a4593d34c5ab0cb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4d22b6917d878bf8fbcf276a4593d34c5ab0cb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a04b2cda0bf2f6f8c5c0a483b8f3356bde1cbd80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a04b2cda0bf2f6f8c5c0a483b8f3356bde1cbd80", "html_url": "https://github.com/rust-lang/rust/commit/a04b2cda0bf2f6f8c5c0a483b8f3356bde1cbd80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a04b2cda0bf2f6f8c5c0a483b8f3356bde1cbd80/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e8ca9f8bd8325398e76bc30ac09aab138bbb127", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e8ca9f8bd8325398e76bc30ac09aab138bbb127", "html_url": "https://github.com/rust-lang/rust/commit/7e8ca9f8bd8325398e76bc30ac09aab138bbb127"}], "stats": {"total": 100, "additions": 86, "deletions": 14}, "files": [{"sha": "09ffe4ef61eb88d9a47440e870dd46168a023879", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 86, "deletions": 14, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a04b2cda0bf2f6f8c5c0a483b8f3356bde1cbd80/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04b2cda0bf2f6f8c5c0a483b8f3356bde1cbd80/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a04b2cda0bf2f6f8c5c0a483b8f3356bde1cbd80", "patch": "@@ -1892,47 +1892,119 @@ $EndFeature, \"\n             pub fn is_negative(self) -> bool { self < 0 }\n         }\n \n-        /// Return the memory representation of this integer as a byte array.\n+        /// Return the memory representation of this integer as a byte array in\n+        /// big-endian (network) byte order.\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use this after [`to_be`] or [`to_le`].\n+        /// # Examples\n         ///\n-        /// [`to_be`]: #method.to_be\n-        /// [`to_le`]: #method.to_le\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = 0x12345678i32.to_be_bytes();\n+        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[inline]\n+        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_be().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// little-endian byte order.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = 0x12345678i32.to_le_bytes();\n+        /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[inline]\n+        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_le().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// native byte order.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+        /// instead.\n+        ///\n+        /// [`to_be_bytes`]: #method.to_be_bytes\n+        /// [`to_le_bytes`]: #method.to_le_bytes\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let bytes = i32::min_value().to_be().to_bytes();\n+        /// let bytes = i32::min_value().to_be().to_ne_bytes();\n         /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n         #[inline]\n-        pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Create an integer value from its memory representation as a byte array.\n+        /// Create an integer value from its representation as a byte array in\n+        /// big endian.\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use [`from_be`] or [`from_le`] after this.\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n         ///\n-        /// [`from_be`]: #method.from_be\n-        /// [`from_le`]: #method.from_le\n+        /// let int = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x12_34_56_78);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[inline]\n+        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_be(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its representation as a byte array in\n+        /// little endian.\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let int = i32::from_be(i32::from_bytes([0x80, 0, 0, 0]));\n+        /// let int = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x78_56_34_12);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[inline]\n+        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_le(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its memory representation as a byte\n+        /// array in native endianness.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+        /// appropriate instead.\n+        ///\n+        /// [`from_be_bytes`]: #method.from_be_bytes\n+        /// [`from_le_bytes`]: #method.from_le_bytes\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n         /// assert_eq!(int, i32::min_value());\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n         #[inline]\n-        pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }\n         }\n     }"}]}