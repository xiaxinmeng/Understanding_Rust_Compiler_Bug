{"sha": "b22aa57fd54c240131c9a31b78213de9f3bee64b", "node_id": "C_kwDOAAsO6NoAKGIyMmFhNTdmZDU0YzI0MDEzMWM5YTMxYjc4MjEzZGU5ZjNiZWU2NGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-21T07:49:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-21T07:49:09Z"}, "message": "Auto merge of #106884 - clubby789:fieldless-enum-debug, r=michaelwoerister\n\nSimplify `derive(Debug)` output for fieldless enums\n\nFixes #106875", "tree": {"sha": "1a95aa971661b0ee072403f1185143272bea3541", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a95aa971661b0ee072403f1185143272bea3541"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b22aa57fd54c240131c9a31b78213de9f3bee64b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b22aa57fd54c240131c9a31b78213de9f3bee64b", "html_url": "https://github.com/rust-lang/rust/commit/b22aa57fd54c240131c9a31b78213de9f3bee64b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b22aa57fd54c240131c9a31b78213de9f3bee64b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e098eb17e1514bcd604ac4bd57cec362944687af", "url": "https://api.github.com/repos/rust-lang/rust/commits/e098eb17e1514bcd604ac4bd57cec362944687af", "html_url": "https://github.com/rust-lang/rust/commit/e098eb17e1514bcd604ac4bd57cec362944687af"}, {"sha": "95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e", "url": "https://api.github.com/repos/rust-lang/rust/commits/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e", "html_url": "https://github.com/rust-lang/rust/commit/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e"}], "stats": {"total": 177, "additions": 130, "deletions": 47}, "files": [{"sha": "ef5a75f428d4e979c8582c5708c79a8c9854180e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -82,7 +82,7 @@ pub fn expand_deriving_clone(\n             nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: substructure,\n         }],\n         associated_types: Vec::new(),\n@@ -177,7 +177,9 @@ fn cs_clone(\n             all_fields = af;\n             vdata = &variant.data;\n         }\n-        EnumTag(..) => cx.span_bug(trait_span, &format!(\"enum tags in `derive({})`\", name,)),\n+        EnumTag(..) | AllFieldlessEnum(..) => {\n+            cx.span_bug(trait_span, &format!(\"enum tags in `derive({})`\", name,))\n+        }\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, &format!(\"associated function in `derive({})`\", name))\n         }"}, {"sha": "3e994f037ad7aa7e2843b0a271257b679bbab3e4", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -36,7 +36,7 @@ pub fn expand_deriving_eq(\n             nonself_args: vec![],\n             ret_ty: Unit,\n             attributes: attrs,\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 cs_total_eq_assert(a, b, c)\n             })),"}, {"sha": "a926fca4e65f8ac21fe7eabd06a1c260d5c0b474", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -29,7 +29,7 @@ pub fn expand_deriving_ord(\n             nonself_args: vec![(self_ref(), sym::other)],\n             ret_ty: Path(path_std!(cmp::Ordering)),\n             attributes: attrs,\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| cs_cmp(a, b, c))),\n         }],\n         associated_types: Vec::new(),"}, {"sha": "9051fe0b28abec750146a6435e0b50c021e99d6f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -76,7 +76,7 @@ pub fn expand_deriving_partial_eq(\n         nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty: Path(path_local!(bool)),\n         attributes: attrs,\n-        unify_fieldless_variants: true,\n+        fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n         combine_substructure: combine_substructure(Box::new(|a, b, c| cs_eq(a, b, c))),\n     }];\n "}, {"sha": "c9dc89212622d70d7d6ddc2bdbfac0093a7bf263", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_partial_ord(\n         nonself_args: vec![(self_ref(), sym::other)],\n         ret_ty,\n         attributes: attrs,\n-        unify_fieldless_variants: true,\n+        fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n         combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n             cs_partial_cmp(cx, span, substr)\n         })),"}, {"sha": "e0f487e864898d72d530efd0d1b1b0815d01894d", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -2,6 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n+use ast::EnumDef;\n use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -31,7 +32,8 @@ pub fn expand_deriving_debug(\n             nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n             attributes: ast::AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy:\n+                FieldlessVariantsStrategy::SpecializeIfAllVariantsFieldless,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 show_substructure(a, b, c)\n             })),\n@@ -43,16 +45,18 @@ pub fn expand_deriving_debug(\n }\n \n fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n+    // We want to make sure we have the ctxt set so that we can use unstable methods\n+    let span = cx.with_def_site_ctxt(span);\n+\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n+        AllFieldlessEnum(enum_def) => return show_fieldless_enum(cx, span, enum_def, substr),\n         EnumTag(..) | StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\")\n         }\n     };\n \n-    // We want to make sure we have the ctxt set so that we can use unstable methods\n-    let span = cx.with_def_site_ctxt(span);\n     let name = cx.expr_str(span, ident.name);\n     let fmt = substr.nonselflike_args[0].clone();\n \n@@ -173,3 +177,47 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         BlockOrExpr::new_mixed(stmts, Some(expr))\n     }\n }\n+\n+/// Special case for enums with no fields. Builds:\n+/// ```text\n+/// impl ::core::fmt::Debug for A {\n+///     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+///          ::core::fmt::Formatter::write_str(f,\n+///             match self {\n+///                 A::A => \"A\",\n+///                 A::B() => \"B\",\n+///                 A::C {} => \"C\",\n+///             })\n+///     }\n+/// }\n+/// ```\n+fn show_fieldless_enum(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    def: &EnumDef,\n+    substr: &Substructure<'_>,\n+) -> BlockOrExpr {\n+    let fmt = substr.nonselflike_args[0].clone();\n+    let arms = def\n+        .variants\n+        .iter()\n+        .map(|v| {\n+            let variant_path = cx.path(span, vec![substr.type_ident, v.ident]);\n+            let pat = match &v.data {\n+                ast::VariantData::Tuple(fields, _) => {\n+                    debug_assert!(fields.is_empty());\n+                    cx.pat_tuple_struct(span, variant_path, vec![])\n+                }\n+                ast::VariantData::Struct(fields, _) => {\n+                    debug_assert!(fields.is_empty());\n+                    cx.pat_struct(span, variant_path, vec![])\n+                }\n+                ast::VariantData::Unit(_) => cx.pat_path(span, variant_path),\n+            };\n+            cx.arm(span, pat, cx.expr_str(span, v.ident.name))\n+        })\n+        .collect::<Vec<_>>();\n+    let name = cx.expr_match(span, cx.expr_self(span), arms);\n+    let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n+    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]))\n+}"}, {"sha": "5f9519dad1b25e91213e145a4ec768cc376f5d01", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -49,7 +49,7 @@ pub fn expand_deriving_rustc_decodable(\n                 PathKind::Std,\n             )),\n             attributes: ast::AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 decodable_substructure(a, b, c, krate)\n             })),"}, {"sha": "18270747296b8f7c7d8762e141f7c8df88da5f36", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -34,7 +34,7 @@ pub fn expand_deriving_default(\n             nonself_args: Vec::new(),\n             ret_ty: Self_,\n             attributes: attrs,\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|cx, trait_span, substr| {\n                 match substr.fields {\n                     StaticStruct(_, fields) => {"}, {"sha": "2afeed927ac2c7664d8e941f211f7c3f3bccff74", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -133,7 +133,7 @@ pub fn expand_deriving_rustc_encodable(\n                 PathKind::Std,\n             )),\n             attributes: AttrVec::new(),\n-            unify_fieldless_variants: false,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 encodable_substructure(a, b, c, krate)\n             })),"}, {"sha": "17b7ac0eba1209de55bddbee1ba6087945b409ed", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -222,14 +222,27 @@ pub struct MethodDef<'a> {\n \n     pub attributes: ast::AttrVec,\n \n-    /// Can we combine fieldless variants for enums into a single match arm?\n-    /// If true, indicates that the trait operation uses the enum tag in some\n-    /// way.\n-    pub unify_fieldless_variants: bool,\n+    pub fieldless_variants_strategy: FieldlessVariantsStrategy,\n \n     pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n }\n \n+/// How to handle fieldless enum variants.\n+#[derive(PartialEq)]\n+pub enum FieldlessVariantsStrategy {\n+    /// Combine fieldless variants into a single match arm.\n+    /// This assumes that relevant information has been handled\n+    /// by looking at the enum's discriminant.\n+    Unify,\n+    /// Don't do anything special about fieldless variants. They are\n+    /// handled like any other variant.\n+    Default,\n+    /// If all variants of the enum are fieldless, expand the special\n+    /// `AllFieldLessEnum` substructure, so that the entire enum can be handled\n+    /// at once.\n+    SpecializeIfAllVariantsFieldless,\n+}\n+\n /// All the data about the data structure/method being derived upon.\n pub struct Substructure<'a> {\n     /// ident of self\n@@ -264,9 +277,14 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n-    /// A non-static method with `Self` is a struct.\n+    /// A non-static method where `Self` is a struct.\n     Struct(&'a ast::VariantData, Vec<FieldInfo>),\n \n+    /// A non-static method handling the entire enum at once\n+    /// (after it has been determined that none of the enum\n+    /// variants has any fields).\n+    AllFieldlessEnum(&'a ast::EnumDef),\n+\n     /// Matching variants of the enum: variant index, variant count, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n@@ -1086,8 +1104,8 @@ impl<'a> MethodDef<'a> {\n     /// ```\n     /// Creates a tag check combined with a match for a tuple of all\n     /// `selflike_args`, with an arm for each variant with fields, possibly an\n-    /// arm for each fieldless variant (if `!unify_fieldless_variants` is not\n-    /// true), and possibly a default arm.\n+    /// arm for each fieldless variant (if `unify_fieldless_variants` is not\n+    /// `Unify`), and possibly a default arm.\n     fn expand_enum_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1101,7 +1119,8 @@ impl<'a> MethodDef<'a> {\n         let variants = &enum_def.variants;\n \n         // Traits that unify fieldless variants always use the tag(s).\n-        let uses_tags = self.unify_fieldless_variants;\n+        let unify_fieldless_variants =\n+            self.fieldless_variants_strategy == FieldlessVariantsStrategy::Unify;\n \n         // There is no sensible code to be generated for *any* deriving on a\n         // zero-variant enum. So we just generate a failing expression.\n@@ -1161,23 +1180,35 @@ impl<'a> MethodDef<'a> {\n         // match is necessary.\n         let all_fieldless = variants.iter().all(|v| v.data.fields().is_empty());\n         if all_fieldless {\n-            if uses_tags && variants.len() > 1 {\n-                // If the type is fieldless and the trait uses the tag and\n-                // there are multiple variants, we need just an operation on\n-                // the tag(s).\n-                let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n-                let mut tag_check = self.call_substructure_method(\n-                    cx,\n-                    trait_,\n-                    type_ident,\n-                    nonselflike_args,\n-                    &EnumTag(tag_field, None),\n-                );\n-                tag_let_stmts.append(&mut tag_check.0);\n-                return BlockOrExpr(tag_let_stmts, tag_check.1);\n-            }\n-\n-            if variants.len() == 1 {\n+            if variants.len() > 1 {\n+                match self.fieldless_variants_strategy {\n+                    FieldlessVariantsStrategy::Unify => {\n+                        // If the type is fieldless and the trait uses the tag and\n+                        // there are multiple variants, we need just an operation on\n+                        // the tag(s).\n+                        let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n+                        let mut tag_check = self.call_substructure_method(\n+                            cx,\n+                            trait_,\n+                            type_ident,\n+                            nonselflike_args,\n+                            &EnumTag(tag_field, None),\n+                        );\n+                        tag_let_stmts.append(&mut tag_check.0);\n+                        return BlockOrExpr(tag_let_stmts, tag_check.1);\n+                    }\n+                    FieldlessVariantsStrategy::SpecializeIfAllVariantsFieldless => {\n+                        return self.call_substructure_method(\n+                            cx,\n+                            trait_,\n+                            type_ident,\n+                            nonselflike_args,\n+                            &AllFieldlessEnum(enum_def),\n+                        );\n+                    }\n+                    FieldlessVariantsStrategy::Default => (),\n+                }\n+            } else if variants.len() == 1 {\n                 // If there is a single variant, we don't need an operation on\n                 // the tag(s). Just use the most degenerate result.\n                 return self.call_substructure_method(\n@@ -1187,7 +1218,7 @@ impl<'a> MethodDef<'a> {\n                     nonselflike_args,\n                     &EnumMatching(0, 1, &variants[0], Vec::new()),\n                 );\n-            };\n+            }\n         }\n \n         // These arms are of the form:\n@@ -1198,7 +1229,7 @@ impl<'a> MethodDef<'a> {\n         let mut match_arms: Vec<ast::Arm> = variants\n             .iter()\n             .enumerate()\n-            .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n+            .filter(|&(_, v)| !(unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n@@ -1249,7 +1280,7 @@ impl<'a> MethodDef<'a> {\n         // Add a default arm to the match, if necessary.\n         let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n         let default = match first_fieldless {\n-            Some(v) if self.unify_fieldless_variants => {\n+            Some(v) if unify_fieldless_variants => {\n                 // We need a default case that handles all the fieldless\n                 // variants. The index and actual variant aren't meaningful in\n                 // this case, so just use dummy values.\n@@ -1296,7 +1327,7 @@ impl<'a> MethodDef<'a> {\n         // If the trait uses the tag and there are multiple variants, we need\n         // to add a tag check operation before the match. Otherwise, the match\n         // is enough.\n-        if uses_tags && variants.len() > 1 {\n+        if unify_fieldless_variants && variants.len() > 1 {\n             let (tag_field, mut tag_let_stmts) = get_tag_pieces(cx);\n \n             // Combine a tag check with the match.\n@@ -1580,5 +1611,6 @@ where\n             }\n         }\n         StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n+        AllFieldlessEnum(..) => cx.span_bug(trait_span, \"fieldless enum in `derive`\"),\n     }\n }"}, {"sha": "f8570d8f86a08dd691fe82dbd23c26518afcde24", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -33,7 +33,7 @@ pub fn expand_deriving_hash(\n             nonself_args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n             ret_ty: Unit,\n             attributes: AttrVec::new(),\n-            unify_fieldless_variants: true,\n+            fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 hash_substructure(a, b, c)\n             })),"}, {"sha": "e6ee11a783b8849acabb006b020b5dad05d4f5ce", "filename": "tests/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b22aa57fd54c240131c9a31b78213de9f3bee64b/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b22aa57fd54c240131c9a31b78213de9f3bee64b/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=b22aa57fd54c240131c9a31b78213de9f3bee64b", "patch": "@@ -731,11 +731,12 @@ impl ::core::marker::Copy for Fieldless { }\n #[automatically_derived]\n impl ::core::fmt::Debug for Fieldless {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match self {\n-            Fieldless::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n-            Fieldless::B => ::core::fmt::Formatter::write_str(f, \"B\"),\n-            Fieldless::C => ::core::fmt::Formatter::write_str(f, \"C\"),\n-        }\n+        ::core::fmt::Formatter::write_str(f,\n+            match self {\n+                Fieldless::A => \"A\",\n+                Fieldless::B => \"B\",\n+                Fieldless::C => \"C\",\n+            })\n     }\n }\n #[automatically_derived]"}]}