{"sha": "e0f305a6bf710f64f789f909da93a8c362823b67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZjMwNWE2YmY3MTBmNjRmNzg5ZjkwOWRhOTNhOGMzNjI4MjNiNjc=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-06T16:55:58Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-08T17:33:28Z"}, "message": "Support textual scoped macros", "tree": {"sha": "c34e3c7e8973c5a7137d1e0cd06ce9903f67b710", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c34e3c7e8973c5a7137d1e0cd06ce9903f67b710"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0f305a6bf710f64f789f909da93a8c362823b67", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl11O2gACgkQztOS3gxI\nPQBUHg/+PGFxH7I+NGWZrmc2YlSza6sBS3VK+X0VmdvAW/z7UHkTYq+hUu1TOy56\neBTlrUylTGEhukskUY4Zc+NkiUE4KIQX+juJnJmj++zNjJIz+GwDk7eS7QngL7H1\nGzqqjYoQoIzLjAXrkLWxfHrBQrDmwnKmo+01P3E75yojMzev7IiOHyu5ACsri6VS\nNdo8gvwfoNaD+TN4bLgj7CHjme0odxD6THl+TnAYpXIxQ+44mVjT/H3sleYUdTzw\nB1eoMBSK5vlknXHW/LYSA0Fg3Pt633mydeSUHKZl0KplQHFmtN8Z6Qenxb93LSgU\nmO8g6P1iK1sH8zz0PJHSe8x6WttoQvzjuqQe5Wx001LWG/TrBbhtReaPKYEbzsZB\ni2NafmW2YI5reCRgPyAqS8Kt8QQsMH9SlUEuCxIXQK+FAszymZaeN/B2uvKuEzwl\nKntI15x2LpKAES+pZ3iqfwudoa62QxGGBdv5EG53/xWvg/3+MF22YwwrV3vmB91m\nEsp6thKc4rg9oloaF+pIqwiWG05wO+ksugRzgti9lIeWxspjYm84b+mrIon1GX0/\nLbNsKPuHCj9HNY6eMdGtlCjuYHTqvOVZT5FffMOLAyH7BOItdlypbEwGbe/njOJy\njbGSCQw8X9R48h+u4ga0P5YqwLa6QvJnvsS+4/RA3SyUijC3z3Y=\n=k+Am\n-----END PGP SIGNATURE-----", "payload": "tree c34e3c7e8973c5a7137d1e0cd06ce9903f67b710\nparent 07e3976f426aaab93bfd3056374ec6ed32ffb255\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1567788958 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1567964008 +0800\n\nSupport textual scoped macros\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f305a6bf710f64f789f909da93a8c362823b67", "html_url": "https://github.com/rust-lang/rust/commit/e0f305a6bf710f64f789f909da93a8c362823b67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0f305a6bf710f64f789f909da93a8c362823b67/comments", "author": null, "committer": null, "parents": [{"sha": "07e3976f426aaab93bfd3056374ec6ed32ffb255", "url": "https://api.github.com/repos/rust-lang/rust/commits/07e3976f426aaab93bfd3056374ec6ed32ffb255", "html_url": "https://github.com/rust-lang/rust/commit/07e3976f426aaab93bfd3056374ec6ed32ffb255"}], "stats": {"total": 192, "additions": 158, "deletions": 34}, "files": [{"sha": "e6bf0e90c978e506a9ef4bbee6d5a1efd911541f", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0f305a6bf710f64f789f909da93a8c362823b67/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f305a6bf710f64f789f909da93a8c362823b67/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=e0f305a6bf710f64f789f909da93a8c362823b67", "patch": "@@ -139,6 +139,7 @@ pub(crate) struct ModuleData {\n pub struct ModuleScope {\n     items: FxHashMap<Name, Resolution>,\n     macros: FxHashMap<Name, MacroDef>,\n+    textual_macros: FxHashMap<Name, MacroDef>,\n }\n \n static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n@@ -164,13 +165,17 @@ impl ModuleScope {\n             _ => None,\n         })\n     }\n+    /// It resolves in module scope. Textual scoped macros are ignored here.\n     fn get_item_or_macro(&self, name: &Name) -> Option<ItemOrMacro> {\n         match (self.get(name), self.macros.get(name)) {\n             (Some(item), _) if !item.def.is_none() => Some(Either::A(item.def)),\n             (_, Some(macro_)) => Some(Either::B(*macro_)),\n             _ => None,\n         }\n     }\n+    fn get_textual_macro(&self, name: &Name) -> Option<MacroDef> {\n+        self.textual_macros.get(name).copied()\n+    }\n }\n \n type ItemOrMacro = Either<PerNs<ModuleDef>, MacroDef>;"}, {"sha": "f897547e39c160eb4c5dbb15dec7d5b7f268caa2", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e0f305a6bf710f64f789f909da93a8c362823b67/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f305a6bf710f64f789f909da93a8c362823b67/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=e0f305a6bf710f64f789f909da93a8c362823b67", "patch": "@@ -40,7 +40,6 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n-        global_macro_scope: FxHashMap::default(),\n         macro_stack_monitor: MacroStackMonitor::default(),\n     };\n     collector.collect();\n@@ -82,7 +81,6 @@ struct DefCollector<DB> {\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n     unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n-    global_macro_scope: FxHashMap<Name, MacroDefId>,\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n@@ -136,20 +134,6 @@ where\n         macro_id: MacroDefId,\n         export: bool,\n     ) {\n-        // macro-by-example in Rust have completely weird name resolution logic,\n-        // unlike anything else in the language. We'd don't fully implement yet,\n-        // just give a somewhat precise approximation.\n-        //\n-        // Specifically, we store a set of visible macros in each module, just\n-        // like how we do with usual items. This is wrong, however, because\n-        // macros can be shadowed and their scopes are mostly unrelated to\n-        // modules. To paper over the second problem, we also maintain\n-        // `global_macro_scope` which works when we construct `CrateDefMap`, but\n-        // is completely ignored in expressions.\n-        //\n-        // What we should do is that, in CrateDefMap, we should maintain a\n-        // separate tower of macro scopes, with ids. Then, for each item in the\n-        // module, we need to store it's macro scope.\n         let def = Either::B(MacroDef { id: macro_id });\n \n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n@@ -162,13 +146,35 @@ where\n             self.def_map.exported_macros.insert(name.clone(), macro_id);\n         }\n         self.update(module_id, None, &[(name.clone(), def)]);\n-        self.global_macro_scope.insert(name, macro_id);\n+        self.define_textual_macro(module_id, name.clone(), macro_id);\n+    }\n+\n+    /// Define a macro in current textual scope.\n+    ///\n+    /// We use a map `textual_macros` to store all textual macros visable per module.\n+    /// It will clone all macros from parent textual scope, whose definition is prior to\n+    /// the definition of current module.\n+    /// And also, `macro_use` on a module will import all textual macros visable inside to\n+    /// current textual scope, with possible shadowing.\n+    ///\n+    /// In a single module, the order of definition/usage of textual scoped macros matters.\n+    /// But we ignore it here to make it easy to implement.\n+    fn define_textual_macro(&mut self, module_id: CrateModuleId, name: Name, macro_id: MacroDefId) {\n+        // Always shadowing\n+        self.def_map.modules[module_id]\n+            .scope\n+            .textual_macros\n+            .insert(name, MacroDef { id: macro_id });\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n     ///\n     /// They are non-scoped, and will only be inserted into mutable `global_macro_scope`.\n-    fn import_macros_from_extern_crate(&mut self, import: &raw::ImportData) {\n+    fn import_macros_from_extern_crate(\n+        &mut self,\n+        current_module_id: CrateModuleId,\n+        import: &raw::ImportData,\n+    ) {\n         log::debug!(\n             \"importing macros from extern crate: {:?} ({:?})\",\n             import,\n@@ -184,14 +190,14 @@ where\n \n         if let Some(ModuleDef::Module(m)) = res.take_types() {\n             tested_by!(macro_rules_from_other_crates_are_visible_with_macro_use);\n-            self.import_all_macros_exported(m);\n+            self.import_all_macros_exported(current_module_id, m);\n         }\n     }\n \n-    fn import_all_macros_exported(&mut self, module: Module) {\n+    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, module: Module) {\n         let item_map = self.db.crate_def_map(module.krate);\n         for (name, &macro_id) in &item_map.exported_macros {\n-            self.global_macro_scope.insert(name.clone(), macro_id);\n+            self.define_textual_macro(current_module_id, name.clone(), macro_id);\n         }\n     }\n \n@@ -528,7 +534,7 @@ where\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n             if prelude_module.krate != self.def_collector.def_map.krate {\n                 tested_by!(prelude_is_macro_use);\n-                self.def_collector.import_all_macros_exported(prelude_module);\n+                self.def_collector.import_all_macros_exported(self.module_id, prelude_module);\n             }\n         }\n \n@@ -539,7 +545,7 @@ where\n             if let raw::RawItem::Import(import_id) = *item {\n                 let import = self.raw_items[import_id].clone();\n                 if import.is_extern_crate && import.is_macro_use {\n-                    self.def_collector.import_macros_from_extern_crate(&import);\n+                    self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n                 }\n             }\n         }\n@@ -561,10 +567,11 @@ where\n     fn collect_module(&mut self, module: &raw::ModuleData) {\n         match module {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, items, ast_id, attr_path } => {\n+            raw::ModuleData::Definition { name, items, ast_id, attr_path, is_macro_use } => {\n                 let module_id =\n                     self.push_child_module(name.clone(), ast_id.with_file_id(self.file_id), None);\n                 let parent_module = ParentModule { name, attr_path: attr_path.as_ref() };\n+\n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n                     module_id,\n@@ -573,9 +580,12 @@ where\n                     parent_module: Some(parent_module),\n                 }\n                 .collect(&*items);\n+                if *is_macro_use {\n+                    self.import_all_textual_macros(module_id);\n+                }\n             }\n             // out of line module, resolve, parse and recurse\n-            raw::ModuleData::Declaration { name, ast_id, attr_path } => {\n+            raw::ModuleData::Declaration { name, ast_id, attr_path, is_macro_use } => {\n                 let ast_id = ast_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n                 match resolve_submodule(\n@@ -596,7 +606,10 @@ where\n                             raw_items: &raw_items,\n                             parent_module: None,\n                         }\n-                        .collect(raw_items.items())\n+                        .collect(raw_items.items());\n+                        if *is_macro_use {\n+                            self.import_all_textual_macros(module_id);\n+                        }\n                     }\n                     Err(candidate) => self.def_collector.def_map.diagnostics.push(\n                         DefDiagnostic::UnresolvedModule {\n@@ -621,6 +634,7 @@ where\n         modules[res].parent = Some(self.module_id);\n         modules[res].declaration = Some(declaration);\n         modules[res].definition = definition;\n+        modules[res].scope.textual_macros = modules[self.module_id].scope.textual_macros.clone();\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n             def: PerNs::types(\n@@ -674,12 +688,12 @@ where\n \n         let ast_id = mac.ast_id.with_file_id(self.file_id);\n \n-        // Case 2: try to expand macro_rules from this crate, triggering\n+        // Case 2: try to resolve in textual scope and expand macro_rules, triggering\n         // recursive item collection.\n-        if let Some(macro_id) =\n-            mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(&name))\n-        {\n-            let def = *macro_id;\n+        if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n+            self.def_collector.def_map[self.module_id].scope.get_textual_macro(&name)\n+        }) {\n+            let def = macro_def.id;\n             let macro_call_id = MacroCallLoc { def, ast_id }.id(self.def_collector.db);\n \n             self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, def);\n@@ -689,6 +703,13 @@ where\n         // Case 3: path to a macro from another crate, expand during name resolution\n         self.def_collector.unexpanded_macros.push((self.module_id, ast_id, mac.path.clone()))\n     }\n+\n+    fn import_all_textual_macros(&mut self, module_id: CrateModuleId) {\n+        let macros = self.def_collector.def_map[module_id].scope.textual_macros.clone();\n+        for (name, macro_) in macros {\n+            self.def_collector.define_textual_macro(self.module_id, name.clone(), macro_.id);\n+        }\n+    }\n }\n \n fn is_macro_rules(path: &Path) -> bool {\n@@ -715,7 +736,6 @@ mod tests {\n             glob_imports: FxHashMap::default(),\n             unresolved_imports: Vec::new(),\n             unexpanded_macros: Vec::new(),\n-            global_macro_scope: FxHashMap::default(),\n             macro_stack_monitor: monitor,\n         };\n         collector.collect();"}, {"sha": "c646d3d005f2c1bc5f01792f63a9a7abebd4dc42", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0f305a6bf710f64f789f909da93a8c362823b67/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f305a6bf710f64f789f909da93a8c362823b67/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=e0f305a6bf710f64f789f909da93a8c362823b67", "patch": "@@ -134,12 +134,14 @@ pub(super) enum ModuleData {\n         name: Name,\n         ast_id: FileAstId<ast::Module>,\n         attr_path: Option<SmolStr>,\n+        is_macro_use: bool,\n     },\n     Definition {\n         name: Name,\n         ast_id: FileAstId<ast::Module>,\n         items: Vec<RawItem>,\n         attr_path: Option<SmolStr>,\n+        is_macro_use: bool,\n     },\n }\n \n@@ -267,10 +269,15 @@ impl RawItemsCollector {\n         };\n \n         let ast_id = self.source_ast_id_map.ast_id(&module);\n+        let is_macro_use = module.has_atom_attr(\"macro_use\");\n         if module.has_semi() {\n             let attr_path = extract_mod_path_attribute(&module);\n-            let item =\n-                self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id, attr_path });\n+            let item = self.raw_items.modules.alloc(ModuleData::Declaration {\n+                name,\n+                ast_id,\n+                attr_path,\n+                is_macro_use,\n+            });\n             self.push_item(current_module, RawItem::Module(item));\n             return;\n         }\n@@ -282,6 +289,7 @@ impl RawItemsCollector {\n                 ast_id,\n                 items: Vec::new(),\n                 attr_path,\n+                is_macro_use,\n             });\n             self.process_module(Some(item), item_list);\n             self.push_item(current_module, RawItem::Module(item));"}, {"sha": "8f0db95f23fa18880bad25e479871bcd3f3e179e", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e0f305a6bf710f64f789f909da93a8c362823b67/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f305a6bf710f64f789f909da93a8c362823b67/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=e0f305a6bf710f64f789f909da93a8c362823b67", "patch": "@@ -277,3 +277,94 @@ fn prelude_cycle() {\n         \u22eecrate::foo\n     \"###);\n }\n+\n+#[test]\n+fn plain_macros_are_textual_scoped_between_modules() {\n+    let map = def_map(\n+        r#\"\n+        //- /main.rs\n+        mod m1;\n+        bar!(NotFoundNotMacroUse);\n+\n+        mod m2 {\n+            foo!(NotFoundBeforeInside2);\n+        }\n+\n+        macro_rules! foo {\n+            ($x:ident) => { struct $x; }\n+        }\n+        foo!(Ok);\n+\n+        mod m3;\n+        foo!(OkShadowStop);\n+        bar!(NotFoundMacroUseStop);\n+\n+        #[macro_use]\n+        mod m5 {\n+            #[macro_use]\n+            mod m6 {\n+                macro_rules! foo {\n+                    ($x:ident) => { fn $x() {} }\n+                }\n+            }\n+        }\n+        foo!(ok_double_macro_use_shadow);\n+\n+        //- /m1.rs\n+        foo!(NotFoundBeforeInside1);\n+        macro_rules! bar {\n+            ($x:ident) => { struct $x; }\n+        }\n+\n+        //- /m3/mod.rs\n+        foo!(OkAfterInside);\n+        macro_rules! foo {\n+            ($x:ident) => { fn $x() {} }\n+        }\n+        foo!(ok_shadow);\n+\n+        #[macro_use]\n+        mod m4;\n+        bar!(OkMacroUse);\n+\n+        //- /m3/m4.rs\n+        foo!(ok_shadow_deep);\n+        macro_rules! bar {\n+            ($x:ident) => { struct $x; }\n+        }\n+        \"#,\n+    );\n+    assert_snapshot!(map, @r###\"\n+   \u22eecrate\n+   \u22eeOk: t v\n+   \u22eeOkShadowStop: t v\n+   \u22eefoo: m\n+   \u22eem1: t\n+   \u22eem2: t\n+   \u22eem3: t\n+   \u22eem5: t\n+   \u22eeok_double_macro_use_shadow: v\n+   \u22ee\n+   \u22eecrate::m1\n+   \u22eebar: m\n+   \u22ee\n+   \u22eecrate::m5\n+   \u22eem6: t\n+   \u22ee\n+   \u22eecrate::m5::m6\n+   \u22eefoo: m\n+   \u22ee\n+   \u22eecrate::m2\n+   \u22ee\n+   \u22eecrate::m3\n+   \u22eeOkAfterInside: t v\n+   \u22eeOkMacroUse: t v\n+   \u22eefoo: m\n+   \u22eem4: t\n+   \u22eeok_shadow: v\n+   \u22ee\n+   \u22eecrate::m3::m4\n+   \u22eebar: m\n+   \u22eeok_shadow_deep: v\n+    \"###);\n+}"}]}