{"sha": "59a56ad043d30d69f7c14dea1abeda2899fd1f28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YTU2YWQwNDNkMzBkNjlmN2MxNGRlYTFhYmVkYTI4OTlmZDFmMjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-12T23:33:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-12T23:33:55Z"}, "message": "Revert \"rustc: Add node IDs to AST types so we can associate them with region environments\"\n\nThis reverts commit 96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d.", "tree": {"sha": "e277d9750a1f00f8435b2cb3d8fc33b77816c129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e277d9750a1f00f8435b2cb3d8fc33b77816c129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59a56ad043d30d69f7c14dea1abeda2899fd1f28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59a56ad043d30d69f7c14dea1abeda2899fd1f28", "html_url": "https://github.com/rust-lang/rust/commit/59a56ad043d30d69f7c14dea1abeda2899fd1f28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59a56ad043d30d69f7c14dea1abeda2899fd1f28/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d", "html_url": "https://github.com/rust-lang/rust/commit/96e1bbd4a0abd2c8e76e7e02b396c5319dea7a8d"}], "stats": {"total": 109, "additions": 34, "deletions": 75}, "files": [{"sha": "47cd332875523905003900697b0d20d521254392", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=59a56ad043d30d69f7c14dea1abeda2899fd1f28", "patch": "@@ -254,15 +254,11 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n                  types: []});\n \n     let test_desc_ty: ast::ty =\n-        {id: cx.sess.next_node_id(),\n-         node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n-         span: dummy_sp()};\n+        nospan(ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()));\n \n     let vec_mt: ast::mt = {ty: @test_desc_ty, mutbl: ast::m_imm};\n \n-    ret @{id: cx.sess.next_node_id(),\n-          node: ast::ty_vec(vec_mt),\n-          span: dummy_sp()};\n+    ret @nospan(ast::ty_vec(vec_mt));\n }\n \n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n@@ -350,7 +346,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n \n     let wrapper_decl: ast::fn_decl = {\n         inputs: [],\n-        output: @{id: cx.sess.next_node_id(), node: ast::ty_nil, span: span},\n+        output: @nospan(ast::ty_nil),\n         purity: ast::impure_fn,\n         cf: ast::return_val,\n         constraints: []\n@@ -381,23 +377,17 @@ fn mk_test_wrapper(cx: test_ctxt,\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n     let str_pt = @nospan({global: false, idents: [\"str\"], types: []});\n-    let str_ty = @{id: cx.sess.next_node_id(),\n-                   node: ast::ty_path(str_pt, cx.sess.next_node_id()),\n-                   span: dummy_sp()};\n+    let str_ty = @nospan(ast::ty_path(str_pt, cx.sess.next_node_id()));\n     let args_mt: ast::mt = {ty: str_ty, mutbl: ast::m_imm};\n-    let args_ty: ast::ty = {id: cx.sess.next_node_id(),\n-                            node: ast::ty_vec(args_mt),\n-                            span: dummy_sp()};\n+    let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg =\n         {mode: ast::expl(ast::by_val),\n          ty: @args_ty,\n          ident: \"args\",\n          id: cx.sess.next_node_id()};\n \n-    let ret_ty = {id: cx.sess.next_node_id(),\n-                  node: ast::ty_nil,\n-                  span: dummy_sp()};\n+    let ret_ty = nospan(ast::ty_nil);\n \n     let decl: ast::fn_decl =\n         {inputs: [args_arg],"}, {"sha": "8aeefe084dcd0594a949f61de660a0d6b586e9ad", "filename": "src/rustc/metadata/astencode_gen.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fmetadata%2Fastencode_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fmetadata%2Fastencode_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode_gen.rs?ref=59a56ad043d30d69f7c14dea1abeda2899fd1f28", "patch": "@@ -3463,15 +3463,12 @@ fn serialize_31<S: std::serialization::serializer>(s: S,\n /*syntax::ast::ty*/\n fn serialize_30<S: std::serialization::serializer>(s: S, v: syntax::ast::ty) {\n \n-    s.emit_rec(/*syntax::ast::node_id*//*syntax::ast::ty_*/\n-               /*syntax::codemap::span*/\n+    s.emit_rec(/*syntax::ast::ty_*//*syntax::codemap::span*/\n                {||\n                    {\n-                       s.emit_rec_field(\"id\", 0u,\n-                                        {|| serialize_27(s, v.id) });\n-                       s.emit_rec_field(\"node\", 1u,\n+                       s.emit_rec_field(\"node\", 0u,\n                                         {|| serialize_31(s, v.node) });\n-                       s.emit_rec_field(\"span\", 2u,\n+                       s.emit_rec_field(\"span\", 1u,\n                                         {|| serialize_19(s, v.span) })\n                    }\n                });\n@@ -7328,18 +7325,15 @@ fn deserialize_30<S: std::serialization::deserializer>(s: S) ->\n     s.read_rec(\n \n \n-               /*syntax::ast::node_id*/\n-\n                /*syntax::ast::ty_*/\n \n                /*syntax::codemap::span*/\n \n                {||\n-                   {id: s.read_rec_field(\"id\", 0u, {|| deserialize_27(s) }),\n-                    node:\n-                        s.read_rec_field(\"node\", 1u, {|| deserialize_31(s) }),\n+                   {node:\n+                        s.read_rec_field(\"node\", 0u, {|| deserialize_31(s) }),\n                     span:\n-                        s.read_rec_field(\"span\", 2u,\n+                        s.read_rec_field(\"span\", 1u,\n                                          {|| deserialize_19(s) }),}\n                })\n "}, {"sha": "03749b86818c3942ee6bb9d47246c17e2274d91c", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=59a56ad043d30d69f7c14dea1abeda2899fd1f28", "patch": "@@ -4419,8 +4419,7 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n               node: ast::pat_ident(rslt_path, none),\n               span: ctor.node.body.span};\n         // Set up obj's type\n-        let rslt_ast_ty : @ast::ty = @{id: ccx.sess.next_node_id(),\n-                                       node: ast::ty_infer,\n+        let rslt_ast_ty : @ast::ty = @{node: ast::ty_infer,\n                                        span: ctor.node.body.span};\n         // kludgy\n         let ty_args = [], i = 0u;"}, {"sha": "fdd40e6e199d70de4ad89bbb1891120dfd5d6b76", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=59a56ad043d30d69f7c14dea1abeda2899fd1f28", "patch": "@@ -334,7 +334,7 @@ enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n-type ty = {id: node_id, node: ty_, span: span};\n+type ty = spanned<ty_>;\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n enum prim_ty {"}, {"sha": "dbdd8cd9b366bed374e5ec744367573231a00f77", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=59a56ad043d30d69f7c14dea1abeda2899fd1f28", "patch": "@@ -699,7 +699,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     }\n     fn f_ty(afp: ast_fold_precursor, f: ast_fold, &&x: @ty) -> @ty {\n         let (n, s) = afp.fold_ty(x.node, x.span, f);\n-        ret @{id: x.id, node: n, span: afp.new_span(s)};\n+        ret @{node: n, span: afp.new_span(s)};\n     }\n     fn f_constr(afp: ast_fold_precursor, f: ast_fold, &&x: @ast::constr) ->\n        @ast::constr {"}, {"sha": "e1309fc264138bfbeb02957539da097ec124d78b", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 43, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a56ad043d30d69f7c14dea1abeda2899fd1f28/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=59a56ad043d30d69f7c14dea1abeda2899fd1f28", "patch": "@@ -385,24 +385,19 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool,\n         expect(p, token::LT);\n     } else if !colons_before_params && p.token == token::LT {\n         p.bump();\n-    } else {\n-        ret @{id: p.get_id(),\n-              node: orig_t,\n-              span: ast_util::mk_sp(lo, p.last_span.hi)};\n-    }\n+    } else { ret @spanned(lo, p.last_span.hi, orig_t); }\n \n     // If we're here, we have explicit type parameter instantiation.\n     let seq = parse_seq_to_gt(some(token::COMMA), {|p| parse_ty(p, false)},\n                               p);\n \n     alt orig_t {\n       ast::ty_path(pth, ann) {\n-        ret @{id: p.get_id(),\n-              node: ast::ty_path(@spanned(lo, p.last_span.hi,\n-                                          {global: pth.node.global,\n-                                           idents: pth.node.idents,\n-                                           types: seq}), ann),\n-              span: ast_util::mk_sp(lo, p.last_span.hi)};\n+        ret @spanned(lo, p.last_span.hi,\n+                     ast::ty_path(@spanned(lo, p.last_span.hi,\n+                                           {global: pth.node.global,\n+                                            idents: pth.node.idents,\n+                                            types: seq}), ann));\n       }\n       _ { p.fatal(\"type parameter instantiation only allowed for paths\"); }\n     }\n@@ -412,17 +407,11 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n     ret if eat(p, token::RARROW) {\n         let lo = p.span.lo;\n         if eat(p, token::NOT) {\n-            (ast::noreturn, @{id: p.get_id(),\n-                              node: ast::ty_bot,\n-                              span: ast_util::mk_sp(lo, p.last_span.hi)})\n-        } else {\n-            (ast::return_val, parse_ty(p, false))\n-        }\n+            (ast::noreturn, @spanned(lo, p.last_span.hi, ast::ty_bot))\n+        } else { (ast::return_val, parse_ty(p, false)) }\n     } else {\n         let pos = p.span.lo;\n-        (ast::return_val, @{id: p.get_id(),\n-                            node: ast::ty_nil,\n-                            span: ast_util::mk_sp(pos, pos)})\n+        (ast::return_val, @spanned(pos, pos, ast::ty_nil))\n     }\n }\n \n@@ -446,11 +435,8 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     let lo = p.span.lo;\n \n     alt have_dollar(p) {\n-      some(e) {\n-        ret @{id: p.get_id(),\n-              node: ast::ty_mac(spanned(lo, p.span.hi, e)),\n-              span: ast_util::mk_sp(lo, p.span.hi)};\n-      }\n+      some(e) {ret @spanned(lo, p.span.hi,\n+                            ast::ty_mac(spanned(lo, p.span.hi, e)))}\n       none {}\n     }\n \n@@ -489,10 +475,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n         let t = ast::ty_rec(elems.node);\n         if p.token == token::COLON {\n             p.bump();\n-            ast::ty_constr(@{id: p.get_id(),\n-                             node: t,\n-                             span: ast_util::mk_sp(lo, hi)},\n-                           parse_type_constraints(p))\n+            ast::ty_constr(@spanned(lo, hi, t), parse_type_constraints(p))\n         } else { t }\n     } else if p.token == token::LBRACKET {\n         expect(p, token::LBRACKET);\n@@ -551,9 +534,7 @@ fn parse_fn_block_arg(p: parser) -> ast::arg {\n     let t = if eat(p, token::COLON) {\n                 parse_ty(p, false)\n             } else {\n-                @{id: p.get_id(),\n-                  node: ast::ty_infer,\n-                  span: ast_util::mk_sp(p.span.lo, p.span.hi)}\n+                @spanned(p.span.lo, p.span.hi, ast::ty_infer)\n             };\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n@@ -1625,9 +1606,7 @@ fn parse_local(p: parser, is_mutbl: bool,\n                allow_init: bool) -> @ast::local {\n     let lo = p.span.lo;\n     let pat = parse_pat(p);\n-    let ty = @{id: p.get_id(),\n-               node: ast::ty_infer,\n-               span: ast_util::mk_sp(lo, lo)};\n+    let ty = @spanned(lo, lo, ast::ty_infer);\n     if eat(p, token::COLON) { ty = parse_ty(p, false); }\n     let init = if allow_init { parse_initializer(p) } else { none };\n     ret @spanned(lo, p.last_span.hi,\n@@ -1903,7 +1882,7 @@ fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n     let output = if eat(p, token::RARROW) {\n                      parse_ty(p, false)\n                  } else {\n-                     @{id: p.get_id(), node: ast::ty_infer, span: p.span}\n+                     @spanned(p.span.lo, p.span.hi, ast::ty_infer)\n                  };\n     ret {inputs: inputs,\n          output: output,\n@@ -1978,7 +1957,7 @@ fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n-        @{id: p.get_id(), node: ast::ty_path(pt, p.get_id()), span: pt.span}\n+        @{node: ast::ty_path(pt, p.get_id()), span: pt.span}\n     }\n     let (ident, tps) = if !is_word(p, \"of\") {\n         if p.token == token::LT { (none, parse_ty_params(p)) }\n@@ -2017,9 +1996,7 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n         {inputs:\n              [{mode: ast::expl(ast::by_ref), ty: t,\n                ident: arg_ident, id: p.get_id()}],\n-         output: @{id: p.get_id(),\n-                   node: ast::ty_nil,\n-                   span: ast_util::mk_sp(lo, lo)},\n+         output: @spanned(lo, lo, ast::ty_nil),\n          purity: ast::impure_fn,\n          cf: ast::return_val,\n          constraints: []};\n@@ -2089,9 +2066,8 @@ enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n         // Can ctors have attrs?\n             // result type is always the type of the class\n         let decl_ = parse_fn_decl(p, ast::impure_fn);\n-        let decl = {output: @{id: p.get_id(),\n-                              node: ast::ty_path(class_name, p.get_id()),\n-                              span: decl_.output.span}\n+        let decl = {output: @{node: ast::ty_path(class_name, p.get_id()),\n+                                  span: decl_.output.span}\n                     with decl_};\n         let body = parse_block(p);\n         ret ctor_decl(decl, body, ast_util::mk_sp(lo, p.last_span.hi));"}]}