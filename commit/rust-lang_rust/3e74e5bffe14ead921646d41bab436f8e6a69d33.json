{"sha": "3e74e5bffe14ead921646d41bab436f8e6a69d33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNzRlNWJmZmUxNGVhZDkyMTY0NmQ0MWJhYjQzNmY4ZTZhNjlkMzM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-10T17:39:09Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T02:50:57Z"}, "message": "rustc: split Generics of a method from its parent Generics.", "tree": {"sha": "3ac416b7a43156453f0095d21df1fed04ee84ef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ac416b7a43156453f0095d21df1fed04ee84ef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e74e5bffe14ead921646d41bab436f8e6a69d33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e74e5bffe14ead921646d41bab436f8e6a69d33", "html_url": "https://github.com/rust-lang/rust/commit/3e74e5bffe14ead921646d41bab436f8e6a69d33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e74e5bffe14ead921646d41bab436f8e6a69d33/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cfd58cbdb84f834b8907dc5e1c7242c451225d", "html_url": "https://github.com/rust-lang/rust/commit/c1cfd58cbdb84f834b8907dc5e1c7242c451225d"}], "stats": {"total": 554, "additions": 290, "deletions": 264}, "files": [{"sha": "9a6375719c1bcd406138ce002a37e941c8bdc178", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -82,7 +82,6 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use infer::{self, TypeOrigin};\n use middle::region;\n-use ty::subst;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n@@ -1369,7 +1368,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                             let generics = self.tcx.lookup_generics(did);\n \n                             let expected =\n-                                generics.regions.len(subst::TypeSpace) as u32;\n+                                generics.regions.len() as u32;\n                             let lifetimes =\n                                 path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();"}, {"sha": "77d7d5115efbca733278d14ea5e59d4041c57023", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -271,14 +271,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 let trait_str = def.trait_ref.to_string();\n                 if let Some(ref istring) = item.value_str() {\n-                    let mut generic_map = def.generics.types.iter_enumerated()\n-                                             .map(|(param, i, gen)| {\n-                                                   (gen.name.as_str().to_string(),\n-                                                    trait_ref.substs.types.get(param, i)\n-                                                             .to_string())\n-                                                  }).collect::<FnvHashMap<String, String>>();\n-                    generic_map.insert(\"Self\".to_string(),\n-                                       trait_ref.self_ty().to_string());\n+                    let generic_map = def.generics.types.iter().map(|param| {\n+                        (param.name.as_str().to_string(),\n+                         trait_ref.substs.type_for_def(param).to_string())\n+                    }).collect::<FnvHashMap<String, String>>();\n                     let parser = Parser::new(&istring);\n                     let mut errored = false;\n                     let err: String = parser.filter_map(|p| {"}, {"sha": "25d2df8fdedb39a0a260703315e9fee84cc4bcc1", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -20,7 +20,6 @@\n use super::elaborate_predicates;\n \n use hir::def_id::DefId;\n-use ty::subst;\n use traits;\n use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use std::rc::Rc;\n@@ -266,7 +265,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !method.generics.types.is_empty_in(subst::FnSpace) {\n+        if !method.generics.types.is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "689f2ad02c94c25008e678ae84aeba42a989d71c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -757,33 +757,14 @@ impl RegionParameterDef {\n /// with an item or method. Analogous to hir::Generics.\n #[derive(Clone, Debug)]\n pub struct Generics<'tcx> {\n-    pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n-    pub regions: VecPerParamSpace<RegionParameterDef>,\n+    pub parent: Option<DefId>,\n+    pub parent_regions: u32,\n+    pub parent_types: u32,\n+    pub regions: Vec<RegionParameterDef>,\n+    pub types: Vec<TypeParameterDef<'tcx>>,\n     pub has_self: bool,\n }\n \n-impl<'tcx> Generics<'tcx> {\n-    pub fn empty() -> Generics<'tcx> {\n-        Generics {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty(),\n-            has_self: false,\n-        }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.types.is_empty() && self.regions.is_empty()\n-    }\n-\n-    pub fn has_type_params(&self, space: subst::ParamSpace) -> bool {\n-        !self.types.is_empty_in(space)\n-    }\n-\n-    pub fn has_region_params(&self, space: subst::ParamSpace) -> bool {\n-        !self.regions.is_empty_in(space)\n-    }\n-}\n-\n /// Bounds on generics.\n #[derive(Clone)]\n pub struct GenericPredicates<'tcx> {"}, {"sha": "248d5d9062d594bacbd10bb2f5c4f6a21768b360", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -832,20 +832,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::Generics {\n-            types: self.types.fold_with(folder),\n-            regions: self.regions.fold_with(folder),\n-            has_self: self.has_self\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.types.visit_with(visitor) || self.regions.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::GenericPredicates {"}, {"sha": "594d15ad5f734cbe34524c93aa75636eba2b2eac", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -89,42 +89,55 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n         let defs = tcx.lookup_generics(def_id);\n+        let num_regions = defs.parent_regions as usize + defs.regions.len();\n+        let num_types = defs.parent_types as usize + defs.types.len();\n         let mut substs = Substs {\n-            types: VecPerParamSpace {\n+            regions: VecPerParamSpace {\n                 type_limit: 0,\n-                content: Vec::with_capacity(defs.types.content.len())\n+                content: Vec::with_capacity(num_regions)\n             },\n-            regions: VecPerParamSpace {\n+            types: VecPerParamSpace {\n                 type_limit: 0,\n-                content: Vec::with_capacity(defs.regions.content.len())\n+                content: Vec::with_capacity(num_types)\n             }\n         };\n \n-        for &space in &ParamSpace::all() {\n-            for def in defs.regions.get_slice(space) {\n-                assert_eq!(def.space, space);\n-\n-                let region = mk_region(def, &substs);\n-                substs.regions.content.push(region);\n+        substs.fill_item(tcx, defs, &mut mk_region, &mut mk_type);\n \n-                if space == TypeSpace {\n-                    substs.regions.type_limit += 1;\n-                }\n-            }\n+        Substs::new(tcx, substs.types, substs.regions)\n+    }\n \n-            for def in defs.types.get_slice(space) {\n-                assert_eq!(def.space, space);\n+    fn fill_item<FR, FT>(&mut self,\n+                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         defs: &ty::Generics<'tcx>,\n+                         mk_region: &mut FR,\n+                         mk_type: &mut FT)\n+    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n+        if let Some(def_id) = defs.parent {\n+            let parent_defs = tcx.lookup_generics(def_id);\n+            self.fill_item(tcx, parent_defs, mk_region, mk_type);\n+        }\n \n-                let ty = mk_type(def, &substs);\n-                substs.types.content.push(ty);\n+        for def in &defs.regions {\n+            let region = mk_region(def, self);\n+            self.regions.content.push(region);\n \n-                if space == TypeSpace {\n-                    substs.types.type_limit += 1;\n-                }\n+            if def.space == TypeSpace {\n+                self.regions.type_limit += 1;\n+                assert_eq!(self.regions.content.len(), self.regions.type_limit);\n             }\n         }\n \n-        Substs::new(tcx, substs.types, substs.regions)\n+        for def in &defs.types {\n+            let ty = mk_type(def, self);\n+            self.types.content.push(ty);\n+\n+            if def.space == TypeSpace {\n+                self.types.type_limit += 1;\n+                assert_eq!(self.types.content.len(), self.types.type_limit);\n+            }\n+        }\n     }\n \n     pub fn is_noop(&self) -> bool {\n@@ -149,16 +162,14 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         let defs = tcx.lookup_generics(source_ancestor);\n-        assert_eq!(self.types.len(TypeSpace), defs.types.len(TypeSpace));\n+        assert_eq!(self.types.len(TypeSpace), defs.types.len());\n         assert_eq!(target_substs.types.len(FnSpace), 0);\n-        assert_eq!(defs.types.len(FnSpace), 0);\n-        assert_eq!(self.regions.len(TypeSpace), defs.regions.len(TypeSpace));\n+        assert_eq!(self.regions.len(TypeSpace), defs.regions.len());\n         assert_eq!(target_substs.regions.len(FnSpace), 0);\n-        assert_eq!(defs.regions.len(FnSpace), 0);\n \n         let Substs { mut types, mut regions } = target_substs.clone();\n-        types.content.extend(&self.types.as_full_slice()[defs.types.content.len()..]);\n-        regions.content.extend(&self.regions.as_full_slice()[defs.regions.content.len()..]);\n+        types.content.extend(&self.types.as_full_slice()[defs.types.len()..]);\n+        regions.content.extend(&self.regions.as_full_slice()[defs.regions.len()..]);\n         Substs::new(tcx, types, regions)\n     }\n }\n@@ -597,8 +608,8 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        -> ty::TraitRef<'tcx> {\n         let Substs { mut types, mut regions } = substs.clone();\n         let defs = tcx.lookup_generics(trait_id);\n-        types.content.truncate(defs.types.type_limit);\n-        regions.content.truncate(defs.regions.type_limit);\n+        types.content.truncate(defs.types.len());\n+        regions.content.truncate(defs.regions.len());\n \n         ty::TraitRef {\n             def_id: trait_id,"}, {"sha": "a62ee37613e5027d6ae7eefeca4755f2521d390a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -73,13 +73,15 @@ pub fn parameterized(f: &mut fmt::Formatter,\n     let mut has_self = false;\n     let (fn_trait_kind, item_name) = ty::tls::with(|tcx| {\n         verbose = tcx.sess.verbose();\n-        let generics = tcx.lookup_generics(did);\n+        let mut generics = tcx.lookup_generics(did);\n+        if let Some(def_id) = generics.parent {\n+            generics = tcx.lookup_generics(def_id);\n+        }\n         if !verbose {\n-            let ty_params = generics.types.get_slice(subst::TypeSpace);\n-            if ty_params.last().map_or(false, |def| def.default.is_some()) {\n+            if generics.types.last().map_or(false, |def| def.default.is_some()) {\n                 if let Some(substs) = tcx.lift(&substs) {\n                     let tps = substs.types.get_slice(subst::TypeSpace);\n-                    for (def, actual) in ty_params.iter().zip(tps).rev() {\n+                    for (def, actual) in generics.types.iter().zip(tps).rev() {\n                         if def.default.subst(tcx, substs) != Some(actual) {\n                             break;\n                         }"}, {"sha": "0cde9b48d6f88eab489857a6566dc26b20f5bb2d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -620,9 +620,9 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     if let Some(impl_item) = impl_item_opt {\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             encode_attributes(rbml_w, &impl_item.attrs);\n-            let scheme = ecx.tcx.lookup_item_type(m.def_id);\n-            let any_types = !scheme.generics.types.is_empty();\n-            let needs_inline = any_types || is_default_impl ||\n+            let generics = ecx.tcx.lookup_generics(m.def_id);\n+            let types = generics.parent_types as usize + generics.types.len();\n+            let needs_inline = types > 0 || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n             if needs_inline || sig.constness == hir::Constness::Const {\n                 encode_inlined_item(ecx,"}, {"sha": "e8e3679a60ca2f37ba90fb2a164af50f677a2b34", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -149,9 +149,29 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     pub fn parse_generics(&mut self) -> &'tcx ty::Generics<'tcx> {\n-        let regions = self.parse_vec_per_param_space(|this| this.parse_region_param_def());\n-        let types = self.parse_vec_per_param_space(|this| this.parse_type_param_def());\n+        let parent = self.parse_opt(|this| this.parse_def());\n+        let parent_regions = self.parse_u32();\n+        assert_eq!(self.next(), '|');\n+        let parent_types = self.parse_u32();\n+\n+        let mut regions = vec![];\n+        assert_eq!(self.next(), '[');\n+        while self.peek() != ']' {\n+            regions.push(self.parse_region_param_def());\n+        }\n+        assert_eq!(self.next(), ']');\n+\n+        let mut types = vec![];\n+        assert_eq!(self.next(), '[');\n+        while self.peek() != ']' {\n+            types.push(self.parse_type_param_def());\n+        }\n+        assert_eq!(self.next(), ']');\n+\n         self.tcx.alloc_generics(ty::Generics {\n+            parent: parent,\n+            parent_regions: parent_regions,\n+            parent_types: parent_types,\n             regions: regions,\n             types: types,\n             has_self: self.next() == 'S'"}, {"sha": "27907596ca7887142475b12aa8b249eaf12a8e7f", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -274,10 +274,21 @@ pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n \n pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                               generics: &ty::Generics<'tcx>) {\n-    enc_vec_per_param_space(w, cx, &generics.regions,\n-                            |w, cx, r| enc_region_param_def(w, cx, r));\n-    enc_vec_per_param_space(w, cx, &generics.types,\n-                            |w, cx, ty| enc_type_param_def(w, cx, ty));\n+    enc_opt(w, generics.parent, |w, def_id| {\n+        write!(w, \"{}|\", (cx.ds)(cx.tcx, def_id));\n+    });\n+    write!(w, \"{}|{}[\",\n+           generics.parent_regions,\n+           generics.parent_types);\n+\n+    for r in &generics.regions {\n+        enc_region_param_def(w, cx, r)\n+    }\n+    write!(w, \"][\");\n+    for t in &generics.types {\n+        enc_type_param_def(w, cx, t);\n+    }\n+    write!(w, \"]\");\n \n     if generics.has_self {\n         write!(w, \"S\");"}, {"sha": "f190fbeb6feb9553d42e7cda76ceb1cf77620ac1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -2470,8 +2470,8 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n                 let def_id = tcx.map.local_def_id(id);\n-                let scheme = tcx.lookup_item_type(def_id);\n-                scheme.generics.types.is_empty()\n+                let generics = tcx.lookup_generics(def_id);\n+                generics.parent_types == 0 && generics.types.is_empty()\n             }\n \n             _ => false"}, {"sha": "76910304eebb0e40c43717fbe1c4f8cf1c3ad2ff", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -195,7 +195,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n use rustc::traits;\n-use rustc::ty::subst::{self, Substs, Subst};\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::repr as mir;\n@@ -1219,17 +1219,16 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    def_id_to_string(tcx, impl_def_id));\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-                let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n                 let overridden_methods: FnvHashSet<_> = items.iter()\n                                                              .map(|item| item.name)\n                                                              .collect();\n-                for default_impl in default_impls {\n-                    if overridden_methods.contains(&default_impl.name) {\n+                for method in tcx.provided_trait_methods(trait_ref.def_id) {\n+                    if overridden_methods.contains(&method.name) {\n                         continue;\n                     }\n \n-                    if default_impl.generics.has_type_params(subst::FnSpace) {\n+                    if !method.generics.types.is_empty() {\n                         continue;\n                     }\n \n@@ -1242,7 +1241,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     callee_substs,\n                                                     impl_def_id,\n                                                     impl_substs,\n-                                                    default_impl.name);\n+                                                    method.name);\n \n                     assert!(mth.is_provided);\n \n@@ -1251,10 +1250,10 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         continue;\n                     }\n \n-                    if can_have_local_instance(tcx, default_impl.def_id) {\n+                    if can_have_local_instance(tcx, method.def_id) {\n                         let empty_substs = tcx.erase_regions(&mth.substs);\n                         let item = create_fn_trans_item(tcx,\n-                                                        default_impl.def_id,\n+                                                        method.def_id,\n                                                         callee_substs,\n                                                         empty_substs);\n                         output.push(item);"}, {"sha": "684628e9a40fbe18c72618a53d636362a6b35496", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -381,10 +381,11 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         // Again, only create type information if full debuginfo is enabled\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n-            generics.types.as_full_slice().iter().enumerate().map(|(i, param)| {\n-                let actual_type = cx.tcx().normalize_associated_type(&actual_types[i]);\n+            let names = get_type_parameter_names(cx, generics);\n+            actual_types.iter().zip(names).map(|(ty, name)| {\n+                let actual_type = cx.tcx().normalize_associated_type(ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n-                let name = CString::new(param.name.as_str().as_bytes()).unwrap();\n+                let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {\n                     llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -403,6 +404,16 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n \n+    fn get_type_parameter_names<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                          generics: &ty::Generics<'tcx>)\n+                                          -> Vec<ast::Name> {\n+        let mut names = generics.parent.map_or(vec![], |def_id| {\n+            get_type_parameter_names(cx, cx.tcx().lookup_generics(def_id))\n+        });\n+        names.extend(generics.types.iter().map(|param| param.name));\n+        names\n+    }\n+\n     fn get_containing_scope_and_span<'ccx, 'tcx>(cx: &CrateContext<'ccx, 'tcx>,\n                                                  instance: Instance<'tcx>)\n                                                  -> (DIScope, Span) {"}, {"sha": "a452b55a7d33d82c1dcb9d83fb59bfad7d334bd0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -429,7 +429,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 bug!(\"ErrorReported returned, but no errors reports?\")\n             }\n         };\n-        let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n+        let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n         let regions = if expected_num_region_params == supplied_num_region_params {\n             lifetimes.iter().map(|l| ast_region_to_region(tcx, l)).collect()\n@@ -454,8 +454,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Check the number of type parameters supplied by the user.\n         if let Some(num_provided) = num_types_provided {\n-            let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-            let ty_param_defs = &ty_param_defs[self_ty.is_some() as usize..];\n+            let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n             check_type_argument_count(tcx, span, num_provided, ty_param_defs);\n         }\n "}, {"sha": "5bfe58e78f112a6c96a1daeb53feb1a38100eabe", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -13,7 +13,7 @@ use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, Reveal};\n use rustc::ty::error::ExpectedFound;\n-use rustc::ty::subst::{self, Subst, Substs};\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::hir::map::Node;\n use rustc::hir::{ImplItemKind, TraitItem_};\n \n@@ -95,8 +95,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }\n \n-    let num_impl_m_type_params = impl_m.generics.types.len(subst::FnSpace);\n-    let num_trait_m_type_params = trait_m.generics.types.len(subst::FnSpace);\n+    let num_impl_m_type_params = impl_m.generics.types.len();\n+    let num_trait_m_type_params = trait_m.generics.types.len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n         span_err!(tcx.sess, impl_m_span, E0049,\n             \"method `{}` has {} type parameter{} \\\n@@ -389,8 +389,8 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     -> bool\n     {\n \n-        let trait_params = trait_generics.regions.get_slice(subst::FnSpace);\n-        let impl_params = impl_generics.regions.get_slice(subst::FnSpace);\n+        let trait_params = &trait_generics.regions[..];\n+        let impl_params = &impl_generics.regions[..];\n \n         debug!(\"check_region_bounds_on_impl_method: \\\n                trait_generics={:?} \\"}, {"sha": "b2af51c12e6bbd1c0b4072f9c95daed400076fee", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -49,7 +49,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             variadic: false,\n         }),\n     }));\n-    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    let i_n_tps = i_ty.generics.types.len();\n     if i_n_tps != n_tps {\n         struct_span_err!(tcx.sess, it.span, E0094,\n             \"intrinsic has wrong number of type \\\n@@ -321,7 +321,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n \n     let tcx = ccx.tcx;\n     let i_ty = tcx.lookup_item_type(tcx.map.local_def_id(it.id));\n-    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    let i_n_tps = i_ty.generics.types.len();\n     let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {"}, {"sha": "8aa4ad56aea885f8c2839684c91d8b5bfc5e0ade", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n         let method = pick.item.as_opt_method().unwrap();\n-        let num_method_types = method.generics.types.len(subst::FnSpace);\n+        let num_method_types = method.generics.types.len();\n \n         if num_supplied_types > 0 && num_supplied_types != num_method_types {\n             if num_method_types == 0 {"}, {"sha": "b057ad3150b5191341d5a403a27381552e5b1301", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -183,15 +183,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n         if let Some(ref input_types) = opt_input_types {\n-            assert_eq!(trait_def.generics.types.len(subst::TypeSpace) - 1, input_types.len());\n+            assert_eq!(trait_def.generics.types.len() - 1, input_types.len());\n         }\n-        assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n         assert!(trait_def.generics.regions.is_empty());\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n         let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, substs| {\n+            assert_eq!(def.space, subst::TypeSpace);\n             if def.index == 0 {\n                 self_ty\n             } else if let Some(ref input_types) = opt_input_types {\n@@ -221,8 +221,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n         let method_item = self.trait_item(trait_def_id, m_name).unwrap();\n         let method_ty = method_item.as_opt_method().unwrap();\n-        assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n-        assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n+        assert_eq!(method_ty.generics.types.len(), 0);\n+        assert_eq!(method_ty.generics.regions.len(), 0);\n \n         debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n                method_item, method_ty);"}, {"sha": "c52bb36911a2a4389d27bd96547d968463dac467", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -518,9 +518,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        trait_ref,\n                        trait_ref.substs,\n                        m);\n-                assert_eq!(m.generics.types.len(subst::TypeSpace),\n+                assert_eq!(m.generics.parent_types as usize,\n                            trait_ref.substs.types.len(subst::TypeSpace));\n-                assert_eq!(m.generics.regions.len(subst::TypeSpace),\n+                assert_eq!(m.generics.parent_regions as usize,\n                            trait_ref.substs.regions.len(subst::TypeSpace));\n             }\n \n@@ -1232,8 +1232,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let xform_self_ty = method.fty.sig.input(0);\n         let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n \n-        if method.generics.types.is_empty_in(subst::FnSpace) &&\n-           method.generics.regions.is_empty_in(subst::FnSpace) {\n+        if method.generics.types.is_empty() && method.generics.regions.is_empty() {\n             xform_self_ty.subst(self.tcx, substs)\n         } else {\n             let substs = Substs::for_item(self.tcx, method.def_id, |def, _| {\n@@ -1260,17 +1259,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                           impl_def_id: DefId)\n                           -> (Ty<'tcx>, &'tcx Substs<'tcx>)\n     {\n-        let impl_pty = self.tcx.lookup_item_type(impl_def_id);\n+        let impl_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n \n-        let type_vars =\n-            impl_pty.generics.types.map(\n-                |_| self.next_ty_var());\n+        let substs = Substs::for_item(self.tcx, impl_def_id,\n+                                      |_, _| ty::ReErased,\n+                                      |_, _| self.next_ty_var());\n \n-        let region_placeholders =\n-            impl_pty.generics.regions.map(\n-                |_| ty::ReErased); // see erase_late_bound_regions() for an expl of why 'erased\n-\n-        (impl_pty.ty, Substs::new(self.tcx, type_vars, region_placeholders))\n+        (impl_ty, substs)\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using"}, {"sha": "d699bafed9a05d1cb15c6d0cbe9827230c9c3762", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -881,8 +881,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // `{Self}` is allowed\n                         Position::ArgumentNamed(s) if s == \"Self\" => (),\n                         // So is `{A}` if A is a type parameter\n-                        Position::ArgumentNamed(s) => match types.as_full_slice()\n-                                                                 .iter().find(|t| {\n+                        Position::ArgumentNamed(s) => match types.iter().find(|t| {\n                             t.name.as_str() == s\n                         }) {\n                             Some(_) => (),\n@@ -1693,7 +1692,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut ty = self.tcx.lookup_item_type(did).ty;\n         if ty.is_fn() {\n             // Tuple variants have fn type even in type namespace, extract true variant type from it\n-            ty = self.tcx.no_late_bound_regions(&type_scheme.ty.fn_ret()).unwrap();\n+            ty = self.tcx.no_late_bound_regions(&ty.fn_ret()).unwrap();\n         }\n         let type_predicates = self.tcx.lookup_predicates(did);\n         let substs = AstConv::ast_path_substs_for_ty(self, self,\n@@ -3222,28 +3221,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(..) | Def::Struct(..) => {\n-                Some(self.tcx.expect_variant_def(def))\n+            Def::Variant(type_did, _) | Def::Struct(type_did) => {\n+                Some((type_did, self.tcx.expect_variant_def(def)))\n             }\n-            Def::TyAlias(did) | Def::AssociatedTy(_, did) => {\n+            Def::TyAlias(did) => {\n                 if let Some(&ty::TyStruct(adt, _)) = self.tcx.opt_lookup_item_type(did)\n                                                              .map(|scheme| &scheme.ty.sty) {\n-                    Some(adt.struct_variant())\n+                    Some((did, adt.struct_variant()))\n                 } else {\n                     None\n                 }\n             }\n             _ => None\n         };\n \n-        if let Some(variant) = variant {\n+        if let Some((def_id, variant)) = variant {\n             if variant.kind == ty::VariantKind::Tuple &&\n                     !self.tcx.sess.features.borrow().relaxed_adts {\n                 emit_feature_err(&self.tcx.sess.parse_sess.span_diagnostic,\n                                  \"relaxed_adts\", span, GateIssue::Language,\n                                  \"tuple structs and variants in struct patterns are unstable\");\n             }\n-            let ty = self.instantiate_type_path(def.def_id(), path, node_id);\n+            let ty = self.instantiate_type_path(def_id, path, node_id);\n             Some((variant, ty))\n         } else {\n             struct_span_err!(self.tcx.sess, path.span, E0071,\n@@ -4122,25 +4121,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut fn_segment = None;\n         match def {\n             // Case 1 and 1b. Reference to a *type* or *enum variant*.\n-            Def::SelfTy(..) |\n-            Def::Struct(..) |\n-            Def::Variant(..) |\n-            Def::Enum(..) |\n-            Def::TyAlias(..) |\n-            Def::AssociatedTy(..) |\n-            Def::Trait(..) |\n-            Def::PrimTy(..) |\n-            Def::TyParam(..) => {\n+            Def::Struct(def_id) |\n+            Def::Variant(_, def_id) |\n+            Def::Enum(def_id) |\n+            Def::TyAlias(def_id) |\n+            Def::AssociatedTy(_, def_id) |\n+            Def::Trait(def_id) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n-                type_segment = segments.last();\n+                let mut generics = self.tcx.lookup_generics(def_id);\n+                if let Some(def_id) = generics.parent {\n+                    // Variant and struct constructors use the\n+                    // generics of their parent type definition.\n+                    generics = self.tcx.lookup_generics(def_id);\n+                }\n+                type_segment = Some((segments.last().unwrap(), generics));\n             }\n \n             // Case 2. Reference to a top-level value.\n-            Def::Fn(..) |\n-            Def::Const(..) |\n-            Def::Static(..) => {\n-                fn_segment = segments.last();\n+            Def::Fn(def_id) |\n+            Def::Const(def_id) |\n+            Def::Static(def_id, _) => {\n+                fn_segment = Some((segments.last().unwrap(),\n+                                   self.tcx.lookup_generics(def_id)));\n             }\n \n             // Case 3. Reference to a method or associated const.\n@@ -4154,21 +4157,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::ImplContainer(_) => {}\n                 }\n \n+                let generics = self.tcx.lookup_generics(def_id);\n                 if segments.len() >= 2 {\n-                    type_segment = Some(&segments[segments.len() - 2]);\n+                    let parent_generics = self.tcx.lookup_generics(generics.parent.unwrap());\n+                    type_segment = Some((&segments[segments.len() - 2], parent_generics));\n                 } else {\n                     // `<T>::assoc` will end up here, and so can `T::assoc`.\n                     let self_ty = opt_self_ty.expect(\"UFCS sugared assoc missing Self\");\n                     ufcs_associated = Some((container, self_ty));\n                 }\n-                fn_segment = segments.last();\n+                fn_segment = Some((segments.last().unwrap(), generics));\n             }\n \n             // Other cases. Various nonsense that really shouldn't show up\n             // here. If they do, an error will have been reported\n             // elsewhere. (I hope)\n             Def::Mod(..) |\n             Def::ForeignMod(..) |\n+            Def::PrimTy(..) |\n+            Def::SelfTy(..) |\n+            Def::TyParam(..) |\n             Def::Local(..) |\n             Def::Label(..) |\n             Def::Upvar(..) |\n@@ -4213,12 +4221,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // a problem.\n         self.check_path_parameter_count(subst::TypeSpace,\n                                         span,\n-                                        scheme.generics,\n                                         !require_type_space,\n                                         &mut type_segment);\n         self.check_path_parameter_count(subst::FnSpace,\n                                         span,\n-                                        scheme.generics,\n                                         true,\n                                         &mut fn_segment);\n \n@@ -4228,7 +4234,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 subst::TypeSpace => type_segment,\n                 subst::FnSpace => fn_segment\n             };\n-            let lifetimes = match segment.map(|s| &s.parameters) {\n+            let lifetimes = match segment.map(|(s, _)| &s.parameters) {\n                 Some(&hir::AngleBracketedParameters(ref data)) => &data.lifetimes[..],\n                 Some(&hir::ParenthesizedParameters(_)) => bug!(),\n                 None => &[]\n@@ -4242,25 +4248,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }, |def, substs| {\n             let mut i = def.index as usize;\n             let segment = match def.space {\n-                subst::TypeSpace => type_segment,\n+                subst::TypeSpace => {\n+                    // Handle Self first, so we can adjust the index to match the AST.\n+                    match (type_segment, fn_segment) {\n+                        (Some((_, generics)), _) | (_, Some((_, generics))) => {\n+                            if generics.has_self {\n+                                if i == 0 {\n+                                    return opt_self_ty.unwrap_or_else(|| {\n+                                        self.type_var_for_def(span, def, substs)\n+                                    });\n+                                }\n+                                i -= 1;\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                    type_segment\n+                }\n                 subst::FnSpace => fn_segment\n             };\n-            let types = match segment.map(|s| &s.parameters) {\n+            let types = match segment.map(|(s, _)| &s.parameters) {\n                 Some(&hir::AngleBracketedParameters(ref data)) => &data.types[..],\n                 Some(&hir::ParenthesizedParameters(_)) => bug!(),\n                 None => &[]\n             };\n \n-            // Handle Self first, so we can adjust the index to match the AST.\n-            if scheme.generics.has_self && def.space == subst::TypeSpace {\n-                if i == 0 {\n-                    return opt_self_ty.unwrap_or_else(|| {\n-                        self.type_var_for_def(span, def, substs)\n-                    });\n-                }\n-                i -= 1;\n-            }\n-\n             let can_omit = def.space != subst::TypeSpace || !require_type_space;\n             let default = if can_omit && types.len() == 0 {\n                 def.default\n@@ -4306,9 +4318,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // with the substituted impl type.\n             let impl_scheme = self.tcx.lookup_item_type(impl_def_id);\n             assert_eq!(substs.types.len(subst::TypeSpace),\n-                       impl_scheme.generics.types.len(subst::TypeSpace));\n+                       impl_scheme.generics.types.len());\n             assert_eq!(substs.regions.len(subst::TypeSpace),\n-                       impl_scheme.generics.regions.len(subst::TypeSpace));\n+                       impl_scheme.generics.regions.len());\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n             match self.sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n@@ -4339,10 +4351,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_path_parameter_count(&self,\n                                   space: subst::ParamSpace,\n                                   span: Span,\n-                                  generics: &ty::Generics<'tcx>,\n                                   can_omit: bool,\n-                                  segment: &mut Option<&hir::PathSegment>) {\n-        let (lifetimes, types, bindings) = match segment.map(|s| &s.parameters) {\n+                                  segment: &mut Option<(&hir::PathSegment, &ty::Generics)>) {\n+        let (lifetimes, types, bindings) = match segment.map(|(s, _)| &s.parameters) {\n             Some(&hir::AngleBracketedParameters(ref data)) => {\n                 (&data.lifetimes[..], &data.types[..], &data.bindings[..])\n             }\n@@ -4357,7 +4368,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Check provided lifetime parameters.\n-        let lifetime_defs = generics.regions.get_slice(space);\n+        let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n         if lifetimes.len() > lifetime_defs.len() {\n             let span = lifetimes[lifetime_defs.len()].span;\n             span_err!(self.tcx.sess, span, E0088,\n@@ -4374,12 +4385,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Check provided type parameters.\n-        let type_defs = generics.types.get_slice(space);\n-        let type_defs = if space == subst::TypeSpace {\n-            &type_defs[generics.has_self as usize..]\n-        } else {\n-            type_defs\n-        };\n+        let type_defs = segment.map_or(&[][..], |(_, generics)| {\n+            if space == subst::TypeSpace {\n+                &generics.types[generics.has_self as usize..]\n+            } else {\n+                &generics.types\n+            }\n+        });\n         let required_len = type_defs.iter()\n                                     .take_while(|d| d.default.is_none())\n                                     .count();"}, {"sha": "f793ce7acb7c798f61f8e74cc48c4440783c9672", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -523,10 +523,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n }\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n-    let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n-        .map(|tp| tp.name).collect::<HashSet<_>>();\n+    let parent = tcx.lookup_generics(generics.parent.unwrap());\n+    let impl_params: HashSet<_> = parent.types.iter().map(|tp| tp.name).collect();\n \n-    for method_param in generics.types.get_slice(subst::FnSpace) {\n+    for method_param in &generics.types {\n         if impl_params.contains(&method_param.name) {\n             error_194(tcx, span, method_param.name);\n         }"}, {"sha": "9e8fe710cc1cd90668ccff545295539737c7a1ad", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -65,7 +65,7 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n-use rustc::ty::subst::{Substs, FnSpace, ParamSpace, TypeSpace, VecPerParamSpace};\n+use rustc::ty::subst::{Substs, FnSpace, ParamSpace, TypeSpace};\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::{VariantKind};\n@@ -793,9 +793,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                 }\n \n                 if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {\n+                    let const_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n+                    let ty_generics = generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&ty_predicates)\n                                 .to_ty(&ExplicitRscope, &ty);\n-                    tcx.register_item_type(ccx.tcx.map.local_def_id(impl_item.id),\n+                    tcx.register_item_type(const_def_id,\n                                            TypeScheme {\n                                                generics: ty_generics,\n                                                ty: ty,\n@@ -858,11 +860,13 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             // Convert all the associated constants.\n             for trait_item in trait_items {\n                 if let hir::ConstTraitItem(ref ty, ref default) = trait_item.node {\n+                    let const_def_id = ccx.tcx.map.local_def_id(trait_item.id);\n+                    let ty_generics = generics_of_def_id(ccx, const_def_id);\n                     let ty = ccx.icx(&trait_predicates)\n                         .to_ty(&ExplicitRscope, ty);\n-                    tcx.register_item_type(ccx.tcx.map.local_def_id(trait_item.id),\n+                    tcx.register_item_type(const_def_id,\n                                            TypeScheme {\n-                                               generics: trait_def.generics,\n+                                               generics: ty_generics,\n                                                ty: ty,\n                                            });\n                     convert_associated_const(ccx,\n@@ -957,7 +961,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n     let def_id = tcx.map.local_def_id(ctor_id);\n-    tcx.generics.borrow_mut().insert(def_id, scheme.generics);\n+    generics_of_def_id(ccx, def_id);\n     let ctor_ty = match variant.kind {\n         VariantKind::Unit | VariantKind::Struct => scheme.ty,\n         VariantKind::Tuple => {\n@@ -1389,24 +1393,35 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n \n+        let node = tcx.map.get(node_id);\n+        let parent_def_id = match node {\n+            NodeImplItem(_) |\n+            NodeTraitItem(_) |\n+            NodeVariant(_) |\n+            NodeStructCtor(_) => {\n+                let parent_id = tcx.map.get_parent(node_id);\n+                Some(tcx.map.local_def_id(parent_id))\n+            }\n+            _ => None\n+        };\n+\n         let mut opt_self = None;\n-        let mut base_def_id = None;\n         let mut allow_defaults = false;\n \n         let no_generics = hir::Generics::empty();\n-        let (space, ast_generics) = match tcx.map.get(node_id) {\n-            NodeImplItem(&ImplItem { node: ImplItemKind::Method(ref sig, _), .. }) |\n-            NodeTraitItem(&TraitItem { node: MethodTraitItem(ref sig, _), .. }) => {\n-                let parent_id = tcx.map.get_parent(node_id);\n-                base_def_id = Some(tcx.map.local_def_id(parent_id));\n-                (FnSpace, &sig.generics)\n+        let (space, ast_generics) = match node {\n+            NodeTraitItem(item) => {\n+                match item.node {\n+                    MethodTraitItem(ref sig, _) => (FnSpace, &sig.generics),\n+                    _ => (FnSpace, &no_generics)\n+                }\n             }\n \n-            NodeImplItem(_) |\n-            NodeTraitItem(_) => {\n-                let parent_id = tcx.map.get_parent(node_id);\n-                base_def_id = Some(tcx.map.local_def_id(parent_id));\n-                (FnSpace, &no_generics)\n+            NodeImplItem(item) => {\n+                match item.node {\n+                    ImplItemKind::Method(ref sig, _) => (FnSpace, &sig.generics),\n+                    _ => (FnSpace, &no_generics)\n+                }\n             }\n \n             NodeItem(item) => {\n@@ -1457,9 +1472,16 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             _ => (TypeSpace, &no_generics)\n         };\n \n-        let empty_generics = ty::Generics::empty();\n-        let base_generics = base_def_id.map_or(&empty_generics, |def_id| {\n-            generics_of_def_id(ccx, def_id)\n+        let has_self = opt_self.is_some();\n+        let mut parent_has_self = false;\n+        let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n+            let generics = generics_of_def_id(ccx, def_id);\n+            assert_eq!(generics.parent, None);\n+            assert_eq!(generics.parent_regions, 0);\n+            assert_eq!(generics.parent_types, 0);\n+            assert_eq!(has_self, false);\n+            parent_has_self = generics.has_self;\n+            (generics.regions.len(), generics.types.len())\n         });\n \n         let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n@@ -1477,32 +1499,15 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         // Now create the real type parameters.\n         let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n-            let i = opt_self.is_some() as u32 + i as u32;\n+            let i = has_self as u32 + i as u32;\n             get_or_create_type_parameter_def(ccx, ast_generics, space, i, p, allow_defaults)\n-        }).collect();\n-\n-        let has_self = base_generics.has_self || opt_self.is_some();\n-        let (regions, types) = match space {\n-            TypeSpace => {\n-                assert_eq!(base_generics.regions.as_full_slice().len(), 0);\n-                assert_eq!(base_generics.types.as_full_slice().len(), 0);\n-                (VecPerParamSpace::new(regions, vec![]),\n-                 VecPerParamSpace::new(opt_self.into_iter().chain(types).collect(), vec![]))\n-            }\n-            FnSpace => {\n-                assert_eq!(base_generics.regions.len(FnSpace), 0);\n-                assert_eq!(base_generics.types.len(FnSpace), 0);\n-                (VecPerParamSpace::new(base_generics.regions.get_slice(TypeSpace).to_vec(),\n-                                       regions),\n-                 VecPerParamSpace::new(base_generics.types.get_slice(TypeSpace).to_vec(),\n-                                       types))\n-            }\n-        };\n+        });\n+        let types: Vec<_> = opt_self.into_iter().chain(types).collect();\n \n         // Debugging aid.\n         if tcx.has_attr(def_id, \"rustc_object_lifetime_default\") {\n             let object_lifetime_default_reprs: String =\n-                types.as_full_slice().iter().map(|t| {\n+                types.iter().map(|t| {\n                     match t.object_lifetime_default {\n                         ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n                         d => format!(\"{:?}\", d),\n@@ -1512,9 +1517,12 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n \n         tcx.alloc_generics(ty::Generics {\n+            parent: parent_def_id,\n+            parent_regions: parent_regions as u32,\n+            parent_types: parent_types as u32,\n             regions: regions,\n             types: types,\n-            has_self: has_self\n+            has_self: has_self || parent_has_self\n         })\n     })\n }\n@@ -2148,7 +2156,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        &mut input_parameters);\n \n     let ty_generics = generics_of_def_id(ccx, impl_def_id);\n-    for (ty_param, param) in ty_generics.types.as_full_slice().iter().zip(&generics.ty_params) {\n+    for (ty_param, param) in ty_generics.types.iter().zip(&generics.ty_params) {\n         let param_ty = ty::ParamTy::for_def(ty_param);\n         if !input_parameters.contains(&ctp::Parameter::Type(param_ty)) {\n             report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());"}, {"sha": "95ddb59c0e28a35264705f9c0fac361b7de05872", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -301,8 +301,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         self.add_constraints_from_substs(\n             generics,\n             trait_ref.def_id,\n-            trait_def.generics.types.as_full_slice(),\n-            trait_def.generics.regions.as_full_slice(),\n+            &trait_def.generics.types,\n+            &trait_def.generics.regions,\n             trait_ref.substs,\n             variance);\n     }\n@@ -359,16 +359,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // README.md for a discussion on dep-graph management.\n                 self.tcx().dep_graph.read(ItemVariances::to_dep_node(&def.did));\n \n-                // All type parameters on enums and structs should be\n-                // in the TypeSpace.\n-                assert!(item_type.generics.types.is_empty_in(subst::FnSpace));\n-                assert!(item_type.generics.regions.is_empty_in(subst::FnSpace));\n-\n                 self.add_constraints_from_substs(\n                     generics,\n                     def.did,\n-                    item_type.generics.types.as_full_slice(),\n-                    item_type.generics.regions.as_full_slice(),\n+                    &item_type.generics.types,\n+                    &item_type.generics.regions,\n                     substs,\n                     variance);\n             }\n@@ -385,8 +380,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_substs(\n                     generics,\n                     trait_ref.def_id,\n-                    trait_def.generics.types.as_full_slice(),\n-                    trait_def.generics.regions.as_full_slice(),\n+                    &trait_def.generics.types,\n+                    &trait_def.generics.regions,\n                     trait_ref.substs,\n                     variance);\n             }\n@@ -406,7 +401,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyParam(ref data) => {\n-                let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n+                assert_eq!(data.space, subst::TypeSpace);\n+                assert_eq!(generics.parent, None);\n+                let def_id = generics.types[data.idx as usize].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n@@ -493,8 +490,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(ref data) => {\n-                let def_id =\n-                    generics.regions.get(data.space, data.index as usize).def_id;\n+                assert_eq!(data.space, subst::TypeSpace);\n+                assert_eq!(generics.parent, None);\n+                let def_id = generics.regions[data.index as usize].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n                     let index = self.inferred_index(node_id);"}, {"sha": "427468069d04e201d7213d9a9a74649eb4b3d0e4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -21,7 +21,6 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n-use rustc::ty::subst;\n \n use rustc_const_eval::lookup_const_by_id;\n \n@@ -161,7 +160,7 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n     let def = tcx.lookup_trait_def(did);\n     let trait_items = tcx.trait_items(did).clean(cx);\n     let predicates = tcx.lookup_predicates(did);\n-    let generics = (def.generics, &predicates, subst::TypeSpace).clean(cx);\n+    let generics = (def.generics, &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     clean::Trait {\n@@ -189,7 +188,7 @@ fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx\n     let predicates = tcx.lookup_predicates(did);\n     clean::Function {\n         decl: decl,\n-        generics: (t.generics, &predicates, subst::FnSpace).clean(cx),\n+        generics: (t.generics, &predicates).clean(cx),\n         unsafety: style,\n         constness: constness,\n         abi: abi,\n@@ -209,7 +208,7 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             &[..] if variant.kind == ty::VariantKind::Tuple => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n-        generics: (t.generics, &predicates, subst::TypeSpace).clean(cx),\n+        generics: (t.generics, &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n@@ -222,7 +221,7 @@ fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match t.ty.sty {\n         ty::TyEnum(edef, _) if !tcx.sess.cstore.is_typedef(did) => {\n             return clean::EnumItem(clean::Enum {\n-                generics: (t.generics, &predicates, subst::TypeSpace).clean(cx),\n+                generics: (t.generics, &predicates).clean(cx),\n                 variants_stripped: false,\n                 variants: edef.variants.clean(cx),\n             })\n@@ -232,7 +231,7 @@ fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     clean::TypedefItem(clean::Typedef {\n         type_: t.ty.clean(cx),\n-        generics: (t.generics, &predicates, subst::TypeSpace).clean(cx),\n+        generics: (t.generics, &predicates).clean(cx),\n     }, false)\n }\n \n@@ -393,9 +392,11 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 // because an associated type won't have generics on the LHS\n                 let typedef = clean::Typedef {\n                     type_: assoc_ty.ty.unwrap().clean(cx),\n-                    generics: (&ty::Generics::empty(),\n-                               &ty::GenericPredicates::empty(),\n-                               subst::TypeSpace).clean(cx)\n+                    generics: clean::Generics {\n+                        lifetimes: vec![],\n+                        type_params: vec![],\n+                        where_predicates: vec![]\n+                    }\n                 };\n                 Some(clean::Item {\n                     name: Some(assoc_ty.name.clean(cx)),\n@@ -434,7 +435,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             provided_trait_methods: provided,\n             trait_: trait_,\n             for_: for_,\n-            generics: (ty.generics, &predicates, subst::TypeSpace).clean(cx),\n+            generics: (ty.generics, &predicates).clean(cx),\n             items: trait_items,\n             polarity: polarity.map(|p| { p.clean(cx) }),\n         }),"}, {"sha": "07821a730ccf6f0d3a5b3fc3844ac2bcf83f4921", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e74e5bffe14ead921646d41bab436f8e6a69d33/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e74e5bffe14ead921646d41bab436f8e6a69d33", "patch": "@@ -973,25 +973,24 @@ impl Clean<Generics> for hir::Generics {\n }\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n-                                    &'a ty::GenericPredicates<'tcx>,\n-                                    subst::ParamSpace) {\n+                                    &'a ty::GenericPredicates<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         use self::WherePredicate as WP;\n \n-        let (gens, preds, space) = *self;\n+        let (gens, preds) = *self;\n \n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.types.get_slice(space).iter().filter_map(|tp| {\n+        let stripped_typarams = gens.types.iter().filter_map(|tp| {\n             if tp.name == keywords::SelfType.name() {\n                 assert_eq!(tp.index, 0);\n                 None\n             } else {\n                 Some(tp.clean(cx))\n             }\n         }).collect::<Vec<_>>();\n-        let stripped_lifetimes = gens.regions.get_slice(space).iter().map(|rp| {\n+        let stripped_lifetimes = gens.regions.iter().map(|rp| {\n             let mut srp = rp.clone();\n             srp.bounds = Vec::new();\n             srp.clean(cx)\n@@ -1359,8 +1358,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             predicates: self.predicates.predicates[method_start..].to_vec()\n         };\n \n-        let generics = (self.generics, &method_predicates,\n-                        subst::FnSpace).clean(cx);\n+        let generics = (self.generics, &method_predicates).clean(cx);\n         let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n         match self.explicit_self {\n             ty::ExplicitSelfCategory::ByValue => {\n@@ -2929,7 +2927,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n             // applied to this associated type in question.\n             let def = cx.tcx().lookup_trait_def(did);\n             let predicates = cx.tcx().lookup_predicates(did);\n-            let generics = (def.generics, &predicates, subst::TypeSpace).clean(cx);\n+            let generics = (def.generics, &predicates).clean(cx);\n             generics.where_predicates.iter().filter_map(|pred| {\n                 let (name, self_type, trait_, bounds) = match *pred {\n                     WherePredicate::BoundPredicate {"}]}