{"sha": "bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c", "node_id": "C_kwDOAAsO6NoAKGJiMDBiMDlkMjJkNGNkODkyY2U3ZjRhNjA1YTJjOGZhZTVkMDA5NWM", "commit": {"author": {"name": "Pawe\u0142 Palenica", "email": "pawelpalenica11@gmail.com", "date": "2021-10-21T06:28:19Z"}, "committer": {"name": "Pawe\u0142 Palenica", "email": "pawelpalenica11@gmail.com", "date": "2021-10-21T06:28:30Z"}, "message": "Add qualify method call assist", "tree": {"sha": "d692f31370463afc0f2607391d71db36f0a8fb55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d692f31370463afc0f2607391d71db36f0a8fb55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c", "html_url": "https://github.com/rust-lang/rust/commit/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/comments", "author": {"login": "qepasa", "id": 18561325, "node_id": "MDQ6VXNlcjE4NTYxMzI1", "avatar_url": "https://avatars.githubusercontent.com/u/18561325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qepasa", "html_url": "https://github.com/qepasa", "followers_url": "https://api.github.com/users/qepasa/followers", "following_url": "https://api.github.com/users/qepasa/following{/other_user}", "gists_url": "https://api.github.com/users/qepasa/gists{/gist_id}", "starred_url": "https://api.github.com/users/qepasa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qepasa/subscriptions", "organizations_url": "https://api.github.com/users/qepasa/orgs", "repos_url": "https://api.github.com/users/qepasa/repos", "events_url": "https://api.github.com/users/qepasa/events{/privacy}", "received_events_url": "https://api.github.com/users/qepasa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qepasa", "id": 18561325, "node_id": "MDQ6VXNlcjE4NTYxMzI1", "avatar_url": "https://avatars.githubusercontent.com/u/18561325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qepasa", "html_url": "https://github.com/qepasa", "followers_url": "https://api.github.com/users/qepasa/followers", "following_url": "https://api.github.com/users/qepasa/following{/other_user}", "gists_url": "https://api.github.com/users/qepasa/gists{/gist_id}", "starred_url": "https://api.github.com/users/qepasa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qepasa/subscriptions", "organizations_url": "https://api.github.com/users/qepasa/orgs", "repos_url": "https://api.github.com/users/qepasa/repos", "events_url": "https://api.github.com/users/qepasa/events{/privacy}", "received_events_url": "https://api.github.com/users/qepasa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6877240fdf597533e2d3349454f62fdc40aaae54", "url": "https://api.github.com/repos/rust-lang/rust/commits/6877240fdf597533e2d3349454f62fdc40aaae54", "html_url": "https://github.com/rust-lang/rust/commit/6877240fdf597533e2d3349454f62fdc40aaae54"}], "stats": {"total": 532, "additions": 515, "deletions": 17}, "files": [{"sha": "00b12411b087587714c1d0c22c504ca5d7d004b1", "filename": "crates/ide_assists/src/handlers/qualify_method_call.rs", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c", "patch": "@@ -0,0 +1,481 @@\n+use hir::{ItemInNs, ModuleDef};\n+use ide_db::{assists::{AssistId, AssistKind}, helpers::import_assets::item_for_path_search};\n+use syntax::{AstNode, ast};\n+\n+use crate::{assist_context::{AssistContext, Assists}, handlers::qualify_path::QualifyCandidate};\n+\n+// Assist: qualify_method_call\n+//\n+// If the name is resolvable, provides fully qualified path for it.\n+//\n+// ```\n+// struct Foo;\n+// impl Foo {\n+//     fn foo(&self) {}    \n+// }\n+// fn main() {\n+//     let foo = Foo;\n+//     foo.fo$0o();\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Foo;\n+// impl Foo {\n+//     fn foo(&self) {}    \n+// }\n+// fn main() {\n+//     let foo = Foo;\n+//     Foo::foo(&foo);\n+// }\n+// ```\n+pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+    let fn_name = &call.name_ref()?;\n+    \n+    // let callExpr = path_expr.syntax();\n+    let range = call.syntax().text_range();\n+    let resolved_call = ctx.sema.resolve_method_call(&call)?;\n+\n+    let current_module = ctx.sema.scope(&call.syntax()).module()?;\n+    let target_module_def = ModuleDef::from(resolved_call);\n+    let item_in_ns = ItemInNs::from(target_module_def);\n+    let receiver_path = current_module.find_use_path(ctx.sema.db, item_for_path_search(ctx.sema.db, item_in_ns)?)?;\n+\n+    let qualify_candidate = QualifyCandidate::ImplMethod(ctx.sema.db, call, resolved_call);\n+    \n+    acc.add(\n+        AssistId(\"qualify_method_call\", AssistKind::RefactorInline),\n+        format!(\"Qualify call `{}`\", fn_name),\n+        range,\n+        |builder| {\n+            qualify_candidate.qualify(\n+                |replace_with: String| builder.replace(range, replace_with),\n+                &receiver_path,\n+                item_in_ns\n+            )\n+        }\n+    );\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist};\n+    use super::*;\n+\n+    #[test]\n+    fn struct_method() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o()\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo(&foo)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_multi_params() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo(&foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_consume() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo(foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_exclusive() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&mut self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo(&mut self, p1: i32, p2: u32) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo(&mut foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_cross_crate() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let foo = dep::test_mod::Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    pub struct Foo;\n+    impl Foo {\n+        pub fn foo(&mut self, p1: i32, p2: u32) {}\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo = dep::test_mod::Foo {};\n+    dep::test_mod::Foo::foo(&mut foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_method_generic() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo<T>(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    foo.fo$0o::<()>()\n+}\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn foo<T>(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo {};\n+    Foo::foo::<()>(&foo)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od()\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    TestTrait::test_method(&test_struct)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_multi_params() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self, p1: i32, p2: u32) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od(12, 32u)\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&self, p1: i32, p2: u32) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    TestTrait::test_method(&test_struct, 12, 32u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_consume() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(self, p1: i32, p2: u32) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od(12, 32u)\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(self, p1: i32, p2: u32) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    TestTrait::test_method(test_struct, 12, 32u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_exclusive() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&mut self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&mut self, p1: i32, p2: u32);\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    test_struct.test_meth$0od(12, 32u)\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method(&mut self, p1: i32, p2: u32);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method(&mut self, p1: i32, p2: u32);\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = test_mod::TestStruct {};\n+    TestTrait::test_method(&mut test_struct, 12, 32u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_cross_crate() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn main() {\n+    let foo = dep::test_mod::Foo {};\n+    foo.fo$0o(9, 9u)\n+}\n+//- /dep.rs crate:dep\n+pub mod test_mod {\n+    pub struct Foo;\n+    impl Foo {\n+        pub fn foo(&mut self, p1: i32, p2: u32) {}\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let foo = dep::test_mod::Foo {};\n+    dep::test_mod::Foo::foo(&mut foo, 9, 9u)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trait_method_generic() {\n+        check_assist(\n+            qualify_method_call,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method<T>(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method<T>(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = TestStruct {};\n+    test_struct.test_meth$0od::<()>()\n+}\n+\"#,\n+            r#\"\n+mod test_mod {\n+    pub trait TestTrait {\n+        fn test_method<T>(&self);\n+    }\n+    pub struct TestStruct {}\n+    impl TestTrait for TestStruct {\n+        fn test_method<T>(&self) {}\n+    }\n+}\n+\n+use test_mod::*;\n+\n+fn main() {\n+    let test_struct = TestStruct {};\n+    TestTrait::test_method::<()>(&test_struct)\n+}\n+\"#,\n+        );\n+    }\n+}\n+"}, {"sha": "ecfced83b1490033513ba5cc411f38eb12a6d114", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c", "patch": "@@ -1,10 +1,7 @@\n use std::iter;\n \n use hir::AsAssocItem;\n-use ide_db::helpers::{\n-    import_assets::{ImportCandidate, LocatedImport},\n-    mod_path_to_ast,\n-};\n+use ide_db::helpers::{import_assets::{ImportCandidate, LocatedImport}, mod_path_to_ast};\n use ide_db::RootDatabase;\n use syntax::{\n     ast,\n@@ -37,6 +34,7 @@ use crate::{\n // ```\n pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n+\n     let mut proposed_imports = import_assets.search_for_relative_paths(&ctx.sema);\n     if proposed_imports.is_empty() {\n         return None;\n@@ -91,16 +89,17 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     }\n     Some(())\n }\n-\n-enum QualifyCandidate<'db> {\n+#[derive(Debug)]\n+pub(crate) enum QualifyCandidate<'db> {\n     QualifierStart(ast::PathSegment, Option<ast::GenericArgList>),\n     UnqualifiedName(Option<ast::GenericArgList>),\n     TraitAssocItem(ast::Path, ast::PathSegment),\n     TraitMethod(&'db RootDatabase, ast::MethodCallExpr),\n+    ImplMethod(&'db RootDatabase, ast::MethodCallExpr, hir::Function),\n }\n \n impl QualifyCandidate<'_> {\n-    fn qualify(\n+    pub(crate) fn qualify(\n         &self,\n         mut replacer: impl FnMut(String),\n         import: &hir::ModPath,\n@@ -122,24 +121,26 @@ impl QualifyCandidate<'_> {\n             QualifyCandidate::TraitMethod(db, mcall_expr) => {\n                 Self::qualify_trait_method(db, mcall_expr, replacer, import, item);\n             }\n+            QualifyCandidate::ImplMethod(db, mcall_expr, hir_fn) => {\n+                Self::qualify_fn_call(db, mcall_expr, replacer, import, hir_fn);\n+            }\n         }\n     }\n \n-    fn qualify_trait_method(\n+    fn qualify_fn_call(\n         db: &RootDatabase,\n         mcall_expr: &ast::MethodCallExpr,\n         mut replacer: impl FnMut(String),\n         import: ast::Path,\n-        item: hir::ItemInNs,\n+        hir_fn: &hir::Function,\n     ) -> Option<()> {\n         let receiver = mcall_expr.receiver()?;\n-        let trait_method_name = mcall_expr.name_ref()?;\n-        let generics =\n+        let method_name = mcall_expr.name_ref()?;\n+        let generics = \n             mcall_expr.generic_arg_list().as_ref().map_or_else(String::new, ToString::to_string);\n         let arg_list = mcall_expr.arg_list().map(|arg_list| arg_list.args());\n-        let trait_ = item_as_trait(db, item)?;\n-        let method = find_trait_method(db, trait_, &trait_method_name)?;\n-        if let Some(self_access) = method.self_param(db).map(|sp| sp.access(db)) {\n+\n+        if let Some(self_access) = hir_fn.self_param(db).map(|sp| sp.access(db)) {\n             let receiver = match self_access {\n                 hir::Access::Shared => make::expr_ref(receiver, false),\n                 hir::Access::Exclusive => make::expr_ref(receiver, true),\n@@ -148,7 +149,7 @@ impl QualifyCandidate<'_> {\n             replacer(format!(\n                 \"{}::{}{}{}\",\n                 import,\n-                trait_method_name,\n+                method_name,\n                 generics,\n                 match arg_list {\n                     Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n@@ -158,6 +159,20 @@ impl QualifyCandidate<'_> {\n         }\n         Some(())\n     }\n+\n+    fn qualify_trait_method(\n+        db: &RootDatabase,\n+        mcall_expr: &ast::MethodCallExpr,\n+        replacer: impl FnMut(String),\n+        import: ast::Path,\n+        item: hir::ItemInNs,\n+    ) -> Option<()> {\n+        let trait_method_name = mcall_expr.name_ref()?;\n+        let trait_ = item_as_trait(db, item)?;\n+        let method = find_trait_method(db, trait_, &trait_method_name)?;\n+        Self::qualify_fn_call(db, mcall_expr, replacer, import, &method);\n+        Some(())\n+    }\n }\n \n fn find_trait_method("}, {"sha": "2801c3c44bb2d842139690c809aeea5a106e2c1f", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c", "patch": "@@ -160,6 +160,7 @@ mod handlers {\n     mod promote_local_to_const;\n     mod pull_assignment_up;\n     mod qualify_path;\n+    mod qualify_method_call;\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n@@ -241,6 +242,7 @@ mod handlers {\n             pull_assignment_up::pull_assignment_up,\n             promote_local_to_const::promote_local_to_const,\n             qualify_path::qualify_path,\n+            qualify_method_call::qualify_method_call,\n             raw_string::add_hash,\n             raw_string::make_usual_string,\n             raw_string::remove_hash,"}, {"sha": "7170e14d8488a0c0736f7c0395f96be8ef9ba7ef", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=bb00b09d22d4cd892ce7f4a605a2c8fae5d0095c", "patch": "@@ -372,7 +372,7 @@ fn import_for_item(\n     })\n }\n \n-fn item_for_path_search(db: &RootDatabase, item: ItemInNs) -> Option<ItemInNs> {\n+pub fn item_for_path_search(db: &RootDatabase, item: ItemInNs) -> Option<ItemInNs> {\n     Some(match item {\n         ItemInNs::Types(_) | ItemInNs::Values(_) => match item_as_assoc(db, item) {\n             Some(assoc_item) => match assoc_item.container(db) {\n@@ -619,6 +619,6 @@ fn path_import_candidate(\n     })\n }\n \n-fn item_as_assoc(db: &RootDatabase, item: ItemInNs) -> Option<AssocItem> {\n+pub fn item_as_assoc(db: &RootDatabase, item: ItemInNs) -> Option<AssocItem> {\n     item.as_module_def().and_then(|module_def| module_def.as_assoc_item(db))\n }"}]}