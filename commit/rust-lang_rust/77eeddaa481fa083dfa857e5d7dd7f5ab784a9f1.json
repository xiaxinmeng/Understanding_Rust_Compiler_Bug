{"sha": "77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZWVkZGFhNDgxZmEwODNkZmE4NTdlNWQ3ZGQ3ZjVhYjc4NGE5ZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-14T07:26:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-14T07:26:36Z"}, "message": "auto merge of #11501 : alexcrichton/rust/dox, r=brson\n\nThe official documentation sorely needs an explanation of the rust runtime and what it is exactly, and I want this guide to provide that information.\r\n\r\nI'm unsure of whether I've been too light on some topics while too heavy on others. I also feel like a few things are still missing. As always, feedback is appreciated, especially about things you'd like to see written about!", "tree": {"sha": "d0e27a5fd35af72eb03487ab742ebec0a4ddae79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0e27a5fd35af72eb03487ab742ebec0a4ddae79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "html_url": "https://github.com/rust-lang/rust/commit/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900893112570eea5a01c0573ae1fa1e3a72397e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/900893112570eea5a01c0573ae1fa1e3a72397e9", "html_url": "https://github.com/rust-lang/rust/commit/900893112570eea5a01c0573ae1fa1e3a72397e9"}, {"sha": "289ba105ae613291f0a3a16ef295875130abdc49", "url": "https://api.github.com/repos/rust-lang/rust/commits/289ba105ae613291f0a3a16ef295875130abdc49", "html_url": "https://github.com/rust-lang/rust/commit/289ba105ae613291f0a3a16ef295875130abdc49"}], "stats": {"total": 279, "additions": 276, "deletions": 3}, "files": [{"sha": "1b498bff6b229deb029ab0ed9f4a4c86ea73e98c", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/configure", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -795,6 +795,7 @@ do\n     make_dir $h/test/codegen\n     make_dir $h/test/doc-tutorial\n     make_dir $h/test/doc-guide-ffi\n+    make_dir $h/test/doc-guide-runtime\n     make_dir $h/test/doc-guide-macros\n     make_dir $h/test/doc-guide-lifetimes\n     make_dir $h/test/doc-guide-pointers"}, {"sha": "86a8c23d947b1f0d0d3f31868852ac5e96a94abb", "filename": "doc/guide-runtime.md", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-runtime.md?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -0,0 +1,263 @@\n+% A Guide to the Rust Runtime\n+\n+Rust includes two runtime libraries in the standard distribution, which provide\n+a unified interface to primitives such as I/O, but the language itself does not\n+require a runtime. The compiler is capable of generating code that works in all\n+environments, even kernel environments. Neither does the Rust language need a\n+runtime to provide memory safety; the type system itself is sufficient to write\n+safe code, verified statically at compile time. The runtime merely uses the\n+safety features of the language to build a number of convenient and safe\n+high-level abstractions.\n+\n+That being said, code without a runtime is often very limited in what it can do.\n+As a result, Rust's standard libraries supply a set of functionality that is\n+normally considered the Rust runtime.  This guide will discuss Rust's user-space\n+runtime, how to use it, and what it can do.\n+\n+# What is the runtime?\n+\n+The Rust runtime can be viewed as a collection of code which enables services\n+like I/O, task spawning, TLS, etc. It's essentially an ephemeral collection of\n+objects which enable programs to perform common tasks more easily. The actual\n+implementation of the runtime itself is mostly a sparse set of opt-in primitives\n+that are all self-contained and avoid leaking their abstractions into libraries.\n+\n+The current runtime is the engine behind these features (not a comprehensive\n+list):\n+\n+* I/O\n+* Task spawning\n+* Message passing\n+* Task synchronization\n+* Task-local storage\n+* Logging\n+* Local heaps (GC heaps)\n+* Task unwinding\n+\n+## What is the runtime accomplishing?\n+\n+The runtime is designed with a few goals in mind:\n+\n+* Rust libraries should work in a number of environments without having to worry\n+  about the exact details of the environment itself. Two commonly referred to\n+  environments are the M:N and 1:1 environments. Since the Rust runtime was\n+  first designed, it has supported M:N threading, and it has since gained 1:1\n+  support as well.\n+\n+* The runtime should not enforce separate \"modes of compilation\" in order to\n+  work in multiple circumstances. Is it an explicit goal that you compile a Rust\n+  library once and use it forever (in all environments).\n+\n+* The runtime should be fast. There should be no architectural design barrier\n+  which is preventing programs from running at optimal speeds. It is not a goal\n+  for the runtime to be written \"as fast as can be\" at every moment in time. For\n+  example, no claims will be made that the current implementation of the runtime\n+  is the fastest it will ever be. This goal is simply to prevent any\n+  architectural roadblock from hindering performance.\n+\n+* The runtime should be nearly invisible. The design of the runtime should not\n+  encourage direct interaction with it, and using the runtime should be\n+  essentially transparent to libraries. This does not mean it should be\n+  impossible to query the runtime, but rather it should be unconventional.\n+\n+# Architecture of the runtime\n+\n+This section explains the current architecture of the Rust runtime. It has\n+evolved over the development of Rust through many iterations, and this is simply\n+the documentation of the current iteration.\n+\n+## A local task\n+\n+The core abstraction of the Rust runtime is the task. A task represents a\n+\"thread\" of execution of Rust code, but it does not necessarily correspond to an\n+OS thread. Most runtime services are accessed through the local task, allowing\n+for runtime policy decisions to be made on a per-task basis.\n+\n+A consequence of this decision is to require all Rust code using the standard\n+library to have a local `Task` structure available to them. This `Task` is\n+stored in the OS's thread local storage (OS TLS) to allow for efficient access\n+to it.\n+\n+It has also been decided that the presence or non-presence of a local `Task` is\n+essentially the *only* assumption that the runtime can make. Almost all runtime\n+services are routed through this local structure.\n+\n+This requirement of a local task is a core assumption on behalf of *all* code\n+using the standard library, hence it is defined in the standard library itself.\n+\n+## I/O\n+\n+When dealing with I/O in general, there are a few flavors by which it can be\n+dealt with, and not all flavors are right for all situations. I/O is also a\n+tricky topic that is nearly impossible to get consistent across all\n+environments. As a result, a Rust task is not guaranteed to have access to I/O,\n+and it is not even guaranteed what the implementation of the I/O will be.\n+\n+This conclusion implies that I/O *cannot* be defined in the standard library.\n+The standard library does, however, provide the interface to I/O that all Rust\n+tasks are able to consume.\n+\n+This interface is implemented differently for various flavors of tasks, and is\n+designed with a focus around synchronous I/O calls. This architecture does not\n+fundamentally prevent other forms of I/O from being defined, but it is not done\n+at this time.\n+\n+The I/O interface that the runtime must provide can be found in the\n+[std::rt::rtio](std/rt/rtio/trait.IoFactory.html) module. Note that this\n+interface is *unstable*, and likely always will be.\n+\n+## Task Spawning\n+\n+A frequent operation performed by tasks is to spawn a child task to perform some\n+work. This is the means by which parallelism is enabled in Rust. This decision\n+of how to spawn a task is not a general decision, and is hence a local decision\n+to the task (not defined in the standard library).\n+\n+Task spawning is interpreted as \"spawning a sibling\" and is enabled through the\n+high level interface in `std::task`. The child task can be configured\n+accordingly, and runtime implementations must respect these options when\n+spawning a new task.\n+\n+Another local task operation is dealing with the runnable state of the task\n+itself.  This frequently comes up when the question is \"how do I block a task?\"\n+or \"how do I wake up a task?\". These decisions are inherently local to the task\n+itself, yet again implying that they are not defined in the standard library.\n+\n+## The `Runtime` trait and the `Task` structure\n+\n+The full complement of runtime features is defined by the [`Runtime`\n+trait](std/rt/trait.Runtime.html) and the [`Task`\n+struct](std/rt/task/struct.Task.html). A `Task` is constant among all runtime\n+implementations, but each runtime implements has its own implementation of the\n+`Runtime` trait.\n+\n+The local `Task` stores the runtime value inside of itself, and then ownership\n+dances ensue to invoke methods on the runtime.\n+\n+# Implementations of the runtime\n+\n+The Rust distribution provides two implementations of the runtime. These two\n+implementations are generally known as 1:1 threading and M:N threading.\n+\n+As with many problems in computer science, there is no right answer in this\n+question of which implementation of the runtime to choose. Each implementation\n+has its benefits and each has its drawbacks. The descriptions below are meant to\n+inform programmers about what the implementation provides and what it doesn't\n+provide in order to make an informed decision about which to choose.\n+\n+## 1:1 - using `libnative`\n+\n+The library `libnative` is an implementation of the runtime built upon native OS\n+threads plus libc blocking I/O calls. This is called 1:1 threading because each\n+user-space thread corresponds to exactly one kernel thread.\n+\n+In this model, each Rust task corresponds to one OS thread, and each I/O object\n+essentially corresponds to a file descriptor (or the equivalent of the platform\n+you're running on).\n+\n+Some benefits to using libnative are:\n+\n+* Guaranteed interop with FFI bindings. If a C library you are using blocks the\n+  thread to do I/O (such as a database driver), then this will not interfere\n+  with other Rust tasks (because only the OS thread will be blocked).\n+* Less I/O overhead as opposed to M:N in some cases. Not all M:N I/O is\n+  guaranteed to be \"as fast as can be\", and some things (like filesystem APIs)\n+  are not truly asynchronous on all platforms, meaning that the M:N\n+  implementation may incur more overhead than a 1:1 implementation.\n+\n+## M:N - using `libgreen`\n+\n+The library `libgreen` implements the runtime with \"green threads\" on top of the\n+asynchronous I/O framework [libuv][libuv]. The M in M:N threading is the number\n+of OS threads that a process has, and the N is the number of Rust tasks. In this\n+model, N Rust tasks are multiplexed among M OS threads, and context switching is\n+implemented in user-space.\n+\n+The primary concern of an M:N runtime is that a Rust task cannot block itself in\n+a syscall. If this happens, then the entire OS thread is frozen and unavailable\n+for running more Rust tasks, making this a (M-1):N runtime (and you can see how\n+this can reach 0/deadlock. By using asynchronous I/O under the hood (all I/O\n+still looks synchronous in terms of code), OS threads are never blocked until\n+the appropriate time comes.\n+\n+Upon reading `libgreen`, you may notice that there is no I/O implementation\n+inside of the library, but rather just the infrastructure for maintaining a set\n+of green schedulers which switch among Rust tasks. The actual I/O implementation\n+is found in `librustuv` which are the Rust bindings to libuv. This distinction\n+is made to allow for other I/O implementations not built on libuv (but none\n+exist at this time).\n+\n+Some benefits of using libgreen are:\n+\n+* Fast task spawning. When using M:N threading, spawning a new task can avoid\n+  executing a syscall entirely, which can lead to more efficient task spawning\n+  times.\n+* Fast task switching. Because context switching is implemented in user-space,\n+  all task contention operations (mutexes, channels, etc) never execute\n+  syscalls, leading to much faster implementations and runtimes. An efficient\n+  context switch also leads to higher throughput servers than 1:1 threading\n+  because tasks can be switched out much more efficiently.\n+\n+### Pools of Schedulers\n+\n+M:N threading is built upon the concept of a pool of M OS threads (which\n+libgreen refers to as schedulers), able to run N Rust tasks. This abstraction is\n+encompassed in libgreen's [`SchedPool`][schedpool] type. This type allows for\n+fine-grained control over the pool of schedulers which will be used to run Rust\n+tasks.\n+\n+In addition the `SchedPool` type is the *only* way through which a new M:N task\n+can be spawned. Sibling tasks to Rust tasks themselves (created through\n+`std::task::spawn`) will be spawned into the same pool of schedulers that the\n+original task was home to. New tasks must previously have some form of handle\n+into the pool of schedulers in order to spawn a new task.\n+\n+## Which to choose?\n+\n+With two implementations of the runtime available, a choice obviously needs to\n+be made to see which will be used. The compiler itself will always by-default\n+link to one of these runtimes. At the time of this writing, the default runtime\n+is `libgreen` but in the future this will become `libnative`.\n+\n+Having a default decision made in the compiler is done out of necessity and\n+convenience. The compiler's decision of runtime to link to is *not* an\n+endorsement of one over the other. As always, this decision can be overridden.\n+\n+For example, this program will be linked to \"the default runtime\"\n+\n+~~~{.rust}\n+fn main() {}\n+~~~\n+\n+Whereas this program explicitly opts into using a particular runtime\n+\n+~~~{.rust}\n+extern mod green;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    do green::start(argc, argv) {\n+        main();\n+    }\n+}\n+\n+fn main() {}\n+~~~\n+\n+Both libgreen/libnative provide a top-level `start` function which is used to\n+boot an initial Rust task in that specified runtime.\n+\n+# Finding the runtime\n+\n+The actual code for the runtime is spread out among a few locations:\n+\n+* [std::rt][stdrt]\n+* [libnative][libnative]\n+* [libgreen][libgreen]\n+* [librustuv][librustuv]\n+\n+[libuv]: https://github.com/joyent/libuv/\n+[stdrt]: std/rt/index.html\n+[libnative]: native/index.html\n+[libgreen]: green/index.html\n+[librustuv]: rustuv/index.html"}, {"sha": "cf68310d353d5ca5ffdbb83f5fb0449b553d84fa", "filename": "doc/index.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Findex.md?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -20,6 +20,7 @@\n [Packaging](guide-rustpkg.html)  \n [Testing](guide-testing.html)  \n [Conditions](guide-conditions.html)\n+[Rust's Runtime](guide-runtime.html)\n \n # Libraries\n "}, {"sha": "fd92a4cc0800f92e8191278730e34a84f10e92f7", "filename": "doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -2067,7 +2067,7 @@ fn head_bad<T>(v: &[T]) -> T {\n \n However, we can tell the compiler\n that the `head` function is only for copyable types.\n-In Rust, copyable types are those that _implement the `Clone` trait_.  \n+In Rust, copyable types are those that _implement the `Clone` trait_.\n We can then explicitly create a second copy of the value we are returning\n by calling the `clone` method:\n \n@@ -3282,6 +3282,7 @@ guides on individual topics.\n * [Packaging up Rust code][rustpkg]\n * [Documenting Rust code][rustdoc]\n * [Testing Rust code][testing]\n+* [The Rust Runtime][runtime]\n \n There is further documentation on the [wiki], however those tend to be even more out of date as this document.\n \n@@ -3294,6 +3295,7 @@ There is further documentation on the [wiki], however those tend to be even more\n [conditions]: guide-conditions.html\n [rustpkg]: guide-rustpkg.html\n [testing]: guide-testing.html\n+[runtime]: guide-runtime.html\n [rustdoc]: rustdoc.html\n [wiki]: https://github.com/mozilla/rust/wiki/Docs\n "}, {"sha": "71ea4ba44d177581b6caea4da29699a3f8341ca1", "filename": "mk/docs.mk", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -72,7 +72,7 @@ endif\n ifneq ($(NO_DOCS),1)\n \n DOCS += doc/rust.html\n-doc/rust.html: rust.md doc/full-toc.inc $(HTML_DEPS) \n+doc/rust.html: rust.md doc/full-toc.inc $(HTML_DEPS)\n \t@$(call E, pandoc: $@)\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(HTML_OPTS) --include-in-header=doc/full-toc.inc --output=$@\n@@ -224,6 +224,12 @@ doc/guide-pointers.html: $(S)doc/guide-pointers.md $(HTML_DEPS)\n \t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n \t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n \n+DOCS += doc/guide-runtime.html\n+doc/guide-runtime.html: $(S)doc/guide-runtime.md $(HTML_DEPS)\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+\t$(CFG_PANDOC) $(HTML_OPTS) --output=$@\n+\n   ifeq ($(CFG_PDFLATEX),)\n     $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n   else"}, {"sha": "d7d94b7eedfa5885cf56cdd4be101855abd39b6f", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=77eeddaa481fa083dfa857e5d7dd7f5ab784a9f1", "patch": "@@ -22,7 +22,7 @@ TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n # Markdown files under doc/ that should have their code extracted and run\n DOC_TEST_NAMES = tutorial guide-ffi guide-macros guide-lifetimes \\\n                  guide-tasks guide-conditions guide-container guide-pointers \\\n-                 complement-cheatsheet \\\n+                 complement-cheatsheet guide-runtime \\\n                  rust\n \n ######################################################################"}]}