{"sha": "608625dae95cde00e4570eb6c2d63b2244bbf34c", "node_id": "C_kwDOAAsO6NoAKDYwODYyNWRhZTk1Y2RlMDBlNDU3MGViNmMyZDYzYjIyNDRiYmYzNGM", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-20T09:40:15Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-21T11:08:56Z"}, "message": "move `considering_regions` to the infcx", "tree": {"sha": "7df33e210f9f884331365ef5837f1e3716e3d7f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7df33e210f9f884331365ef5837f1e3716e3d7f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/608625dae95cde00e4570eb6c2d63b2244bbf34c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/608625dae95cde00e4570eb6c2d63b2244bbf34c", "html_url": "https://github.com/rust-lang/rust/commit/608625dae95cde00e4570eb6c2d63b2244bbf34c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/608625dae95cde00e4570eb6c2d63b2244bbf34c/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceeb5ade201e4181c6d5df2ba96ae5fb2193aadc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceeb5ade201e4181c6d5df2ba96ae5fb2193aadc", "html_url": "https://github.com/rust-lang/rust/commit/ceeb5ade201e4181c6d5df2ba96ae5fb2193aadc"}], "stats": {"total": 163, "additions": 75, "deletions": 88}, "files": [{"sha": "130214a653f7c1c84cc846415fb583df800b58bf", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -65,6 +65,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         Self {\n             tcx: self.tcx,\n             defining_use_anchor: self.defining_use_anchor,\n+            considering_regions: self.considering_regions,\n             in_progress_typeck_results: self.in_progress_typeck_results,\n             inner: self.inner.clone(),\n             skip_leak_check: self.skip_leak_check.clone(),"}, {"sha": "c9acca063a6d1c441ece1c532cc8848fc4e38f3e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -265,6 +265,11 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// might come up during inference or typeck.\n     pub defining_use_anchor: DefiningAnchor,\n \n+    /// Whether this inference context should care about region obligations in\n+    /// the root universe. Most notably, this is used during hir typeck as region\n+    /// solving is left to borrowck instead.\n+    pub considering_regions: bool,\n+\n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n@@ -539,8 +544,9 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n /// without using `Rc` or something similar.\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n     defining_use_anchor: DefiningAnchor,\n+    considering_regions: bool,\n+    fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -552,6 +558,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n         InferCtxtBuilder {\n             tcx: self,\n             defining_use_anchor: DefiningAnchor::Error,\n+            considering_regions: true,\n             fresh_typeck_results: None,\n         }\n     }\n@@ -577,6 +584,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn ignoring_regions(mut self) -> Self {\n+        self.considering_regions = false;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -601,11 +613,17 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;\n+        let InferCtxtBuilder {\n+            tcx,\n+            defining_use_anchor,\n+            considering_regions,\n+            ref fresh_typeck_results,\n+        } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n             defining_use_anchor,\n+            considering_regions,\n             in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),"}, {"sha": "5fcaa52d41747ad2124cc701f54b9dec3ccc9646", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -30,7 +30,9 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(|infcx| {\n+    let mut infcx_builder =\n+        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n+    infcx_builder.enter(|infcx| {\n         //~^ HACK `Bubble` is required for\n         // this test to pass: type-alias-impl-trait/assoc-projection-ice.rs\n         let mut selcx = SelectionContext::new(&infcx);"}, {"sha": "6c177f6388704a943548eb824a97e5df6ab2b46d", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -15,8 +15,6 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub trait TraitEngineExt<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n-\n-    fn new_ignoring_regions(tcx: TyCtxt<'tcx>) -> Box<Self>;\n }\n \n impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n@@ -27,14 +25,6 @@ impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n             Box::new(FulfillmentContext::new())\n         }\n     }\n-\n-    fn new_ignoring_regions(tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        if tcx.sess.opts.unstable_opts.chalk {\n-            Box::new(ChalkFulfillmentContext::new())\n-        } else {\n-            Box::new(FulfillmentContext::new_ignoring_regions())\n-        }\n-    }\n }\n \n /// Used if you want to have pleasant experience when dealing"}, {"sha": "9b0ad15bc0560657ebd1461753f58287bf9eb59e", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -58,19 +58,6 @@ pub struct FulfillmentContext<'tcx> {\n \n     relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n \n-    // Should this fulfillment context register type-lives-for-region\n-    // obligations on its parent infcx? In some cases, region\n-    // obligations are either already known to hold (normalization) or\n-    // hopefully verified elsewhere (type-impls-bound), and therefore\n-    // should not be checked.\n-    //\n-    // Note that if we are normalizing a type that we already\n-    // know is well-formed, there should be no harm setting this\n-    // to true - all the region variables should be determinable\n-    // using the RFC 447 rules, which don't depend on\n-    // type-lives-for-region constraints, and because the type\n-    // is well-formed, the constraints should hold.\n-    register_region_obligations: bool,\n     // Is it OK to register obligations into this infcx inside\n     // an infcx snapshot?\n     //\n@@ -103,7 +90,6 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             relationships: FxHashMap::default(),\n-            register_region_obligations: true,\n             usable_in_snapshot: false,\n         }\n     }\n@@ -112,30 +98,18 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             relationships: FxHashMap::default(),\n-            register_region_obligations: true,\n             usable_in_snapshot: true,\n         }\n     }\n \n-    pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n-        FulfillmentContext {\n-            predicates: ObligationForest::new(),\n-            relationships: FxHashMap::default(),\n-            register_region_obligations: false,\n-            usable_in_snapshot: false,\n-        }\n-    }\n-\n     /// Attempts to select obligations using `selcx`.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx>) -> Vec<FulfillmentError<'tcx>> {\n         let span = debug_span!(\"select\", obligation_forest_size = ?self.predicates.len());\n         let _enter = span.enter();\n \n         // Process pending obligations.\n-        let outcome: Outcome<_, _> = self.predicates.process_obligations(&mut FulfillProcessor {\n-            selcx,\n-            register_region_obligations: self.register_region_obligations,\n-        });\n+        let outcome: Outcome<_, _> =\n+            self.predicates.process_obligations(&mut FulfillProcessor { selcx });\n \n         // FIXME: if we kept the original cache key, we could mark projection\n         // obligations as complete for the projection cache here.\n@@ -239,7 +213,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n struct FulfillProcessor<'a, 'b, 'tcx> {\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    register_region_obligations: bool,\n }\n \n fn mk_pending(os: Vec<PredicateObligation<'_>>) -> Vec<PendingPredicateObligation<'_>> {\n@@ -385,19 +358,21 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n \n                 ty::PredicateKind::RegionOutlives(data) => {\n-                    match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {\n-                        Ok(()) => ProcessResult::Changed(vec![]),\n-                        Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n+                    if infcx.considering_regions || data.has_placeholders() {\n+                        match infcx\n+                            .region_outlives_predicate(&obligation.cause, Binder::dummy(data))\n+                        {\n+                            Ok(()) => ProcessResult::Changed(vec![]),\n+                            Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n+                        }\n+                    } else {\n+                        ProcessResult::Changed(vec![])\n                     }\n                 }\n \n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n-                    if self.register_region_obligations {\n-                        self.selcx.infcx().register_region_obligation_with_cause(\n-                            t_a,\n-                            r_b,\n-                            &obligation.cause,\n-                        );\n+                    if infcx.considering_regions {\n+                        infcx.register_region_obligation_with_cause(t_a, r_b, &obligation.cause);\n                     }\n                     ProcessResult::Changed(vec![])\n                 }"}, {"sha": "3ef51b0c27abd9e8273509cda48459690cc12cba", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -163,7 +163,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n         // The handling of regions in this area of the code is terrible,\n         // see issue #29149. We should be able to improve on this with\n         // NLL.\n-        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+        let mut fulfill_cx = FulfillmentContext::new();\n \n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n@@ -207,21 +207,21 @@ fn do_normalize_predicates<'tcx>(\n     predicates: Vec<ty::Predicate<'tcx>>,\n ) -> Result<Vec<ty::Predicate<'tcx>>, ErrorGuaranteed> {\n     let span = cause.span;\n-    tcx.infer_ctxt().enter(|infcx| {\n-        // FIXME. We should really... do something with these region\n-        // obligations. But this call just continues the older\n-        // behavior (i.e., doesn't cause any new bugs), and it would\n-        // take some further refactoring to actually solve them. In\n-        // particular, we would have to handle implied bounds\n-        // properly, and that code is currently largely confined to\n-        // regionck (though I made some efforts to extract it\n-        // out). -nmatsakis\n-        //\n-        // @arielby: In any case, these obligations are checked\n-        // by wfcheck anyway, so I'm not sure we have to check\n-        // them here too, and we will remove this function when\n-        // we move over to lazy normalization *anyway*.\n-        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+    // FIXME. We should really... do something with these region\n+    // obligations. But this call just continues the older\n+    // behavior (i.e., doesn't cause any new bugs), and it would\n+    // take some further refactoring to actually solve them. In\n+    // particular, we would have to handle implied bounds\n+    // properly, and that code is currently largely confined to\n+    // regionck (though I made some efforts to extract it\n+    // out). -nmatsakis\n+    //\n+    // @arielby: In any case, these obligations are checked\n+    // by wfcheck anyway, so I'm not sure we have to check\n+    // them here too, and we will remove this function when\n+    // we move over to lazy normalization *anyway*.\n+    tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n+        let fulfill_cx = FulfillmentContext::new();\n         let predicates =\n             match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, predicates) {\n                 Ok(predicates) => predicates,"}, {"sha": "5f77aae6f221fd4ee74007a960164a5e4c060f5e", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -207,18 +207,7 @@ fn fulfill_implication<'a, 'tcx>(\n     // (which are packed up in penv)\n \n     infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        // If we came from `translate_substs`, we already know that the\n-        // predicates for our impl hold (after all, we know that a more\n-        // specialized impl holds, so our impl must hold too), and\n-        // we only want to process the projections to determine the\n-        // the types in our substs using RFC 447, so we can safely\n-        // ignore region obligations, which allows us to avoid threading\n-        // a node-id to assign them with.\n-        //\n-        // If we came from specialization graph construction, then\n-        // we already make a mockery out of the region system, so\n-        // why not ignore them a bit earlier?\n-        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+        let mut fulfill_cx = FulfillmentContext::new();\n         for oblig in obligations.chain(more_obligations) {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }"}, {"sha": "2f841fc277ded364f3d9b4203ea3f17099d65ae6", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -86,7 +86,10 @@ impl<'tcx> Inherited<'_, 'tcx> {\n         let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_typeck_results(hir_owner),\n+            infcx: tcx\n+                .infer_ctxt()\n+                .ignoring_regions()\n+                .with_fresh_in_progress_typeck_results(hir_owner),\n             def_id,\n         }\n     }\n@@ -113,7 +116,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n                 maybe_typeck_results: infcx.in_progress_typeck_results,\n             },\n             infcx,\n-            fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new_ignoring_regions(tcx)),\n+            fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new(tcx)),\n             locals: RefCell::new(Default::default()),\n             deferred_sized_obligations: RefCell::new(Vec::new()),\n             deferred_call_resolutions: RefCell::new(Default::default()),"}, {"sha": "b088fc9eddb85a14a3e84ef89fdc80824e2f1b0c", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -87,10 +87,10 @@ mod op;\n mod pat;\n mod place_op;\n mod region;\n-mod regionck;\n+pub mod regionck;\n pub mod rvalue_scopes;\n mod upvar;\n-mod wfcheck;\n+pub mod wfcheck;\n pub mod writeback;\n \n use check::{check_abi, check_fn, check_mod_item_types};"}, {"sha": "1b80e4edca91086ea154a26531a00ace1c22abe8", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -1913,7 +1913,7 @@ impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n     }\n }\n \n-pub(super) fn impl_implied_bounds<'tcx>(\n+pub fn impl_implied_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     impl_def_id: LocalDefId,"}, {"sha": "d8e42729ff31d5ac53356b068534d1955a41dc34", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -116,8 +116,8 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n                 // why this field does not implement Copy. This is useful because sometimes\n                 // it is not immediately clear why Copy is not implemented for a field, since\n                 // all we point at is the field itself.\n-                tcx.infer_ctxt().enter(|infcx| {\n-                    let mut fulfill_cx = traits::FulfillmentContext::new_ignoring_regions();\n+                tcx.infer_ctxt().ignoring_regions().enter(|infcx| {\n+                    let mut fulfill_cx = traits::FulfillmentContext::new();\n                     fulfill_cx.register_bound(\n                         &infcx,\n                         param_env,"}, {"sha": "f16888345e9d509d35551101ce82dca5c7387b8f", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/608625dae95cde00e4570eb6c2d63b2244bbf34c/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=608625dae95cde00e4570eb6c2d63b2244bbf34c", "patch": "@@ -65,6 +65,8 @@\n //! cause use after frees with purely safe code in the same way as specializing\n //! on traits with methods can.\n \n+use crate::check::regionck::OutlivesEnvironmentExt;\n+use crate::check::wfcheck::impl_implied_bounds;\n use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n \n@@ -148,8 +150,15 @@ fn get_impl_substs<'tcx>(\n     let impl2_substs =\n         translate_substs(infcx, param_env, impl1_def_id.to_def_id(), impl1_substs, impl2_node);\n \n-    // Conservatively use an empty `ParamEnv`.\n-    let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n+    let mut outlives_env = OutlivesEnvironment::new(param_env);\n+    let implied_bounds =\n+        impl_implied_bounds(infcx.tcx, param_env, impl1_def_id, tcx.def_span(impl1_def_id));\n+    outlives_env.add_implied_bounds(\n+        infcx,\n+        implied_bounds,\n+        tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n+    );\n+    infcx.process_registered_region_obligations(outlives_env.region_bound_pairs(), param_env);\n     infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);"}]}