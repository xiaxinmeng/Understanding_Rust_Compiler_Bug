{"sha": "f119bf2761ab11ca577fac9881678c04d3e7fdb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMTliZjI3NjFhYjExY2E1NzdmYWM5ODgxNjc4YzA0ZDNlN2ZkYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-05T06:55:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-05T06:55:48Z"}, "message": "Auto merge of #62099 - Mark-Simulacrum:syntax-print-clean-2, r=eddyb\n\nRemove io::Result from syntax::print\n\nSince we're now writing directly to the vector, there's no need to\nthread results through the whole printing infrastructure", "tree": {"sha": "f48f186557f8b204878001e23f7703c58908a063", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f48f186557f8b204878001e23f7703c58908a063"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f119bf2761ab11ca577fac9881678c04d3e7fdb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f119bf2761ab11ca577fac9881678c04d3e7fdb0", "html_url": "https://github.com/rust-lang/rust/commit/f119bf2761ab11ca577fac9881678c04d3e7fdb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f119bf2761ab11ca577fac9881678c04d3e7fdb0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baab1914ec9a9742776a8147780947b48fddf54d", "url": "https://api.github.com/repos/rust-lang/rust/commits/baab1914ec9a9742776a8147780947b48fddf54d", "html_url": "https://github.com/rust-lang/rust/commit/baab1914ec9a9742776a8147780947b48fddf54d"}, {"sha": "d26c4b7bd6e5905280dd4441482331fb9fb65e07", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26c4b7bd6e5905280dd4441482331fb9fb65e07", "html_url": "https://github.com/rust-lang/rust/commit/d26c4b7bd6e5905280dd4441482331fb9fb65e07"}], "stats": {"total": 4356, "additions": 2076, "deletions": 2280}, "files": [{"sha": "4da9919c2d6ebbcb700e65d8a8e9edb5aac16deb", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0", "patch": "@@ -25,7 +25,6 @@ use crate::hir::print::Nested;\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n-use std::io;\n use std::result::Result::Err;\n use crate::ty::query::Providers;\n \n@@ -1187,7 +1186,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n /// Identical to the `PpAnn` implementation for `hir::Crate`,\n /// except it avoids creating a dependency on the whole crate.\n impl<'hir> print::PpAnn for Map<'hir> {\n-    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) -> io::Result<()> {\n+    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) {\n         match nested {\n             Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n@@ -1199,7 +1198,7 @@ impl<'hir> print::PpAnn for Map<'hir> {\n }\n \n impl<'a> print::State<'a> {\n-    pub fn print_node(&mut self, node: Node<'_>) -> io::Result<()> {\n+    pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n             Node::Item(a)         => self.print_item(&a),\n             Node::ForeignItem(a)  => self.print_foreign_item(&a),\n@@ -1219,9 +1218,9 @@ impl<'a> print::State<'a> {\n                 use syntax::print::pprust::PrintState;\n \n                 // containing cbox, will be closed by print-block at }\n-                self.cbox(print::indent_unit)?;\n+                self.cbox(print::indent_unit);\n                 // head-ibox, will be closed by print-block after {\n-                self.ibox(0)?;\n+                self.ibox(0);\n                 self.print_block(&a)\n             }\n             Node::Lifetime(a)     => self.print_lifetime(&a),"}, {"sha": "573b9add133ea40a1358e5e1f9460564a273b7e4", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 855, "deletions": 895, "changes": 1750, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0"}, {"sha": "95580952ffb95ee204d084a61df63b484d1363f5", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0", "patch": "@@ -6,7 +6,6 @@\n use rustc::cfg;\n use rustc::cfg::CFGIndex;\n use rustc::ty::TyCtxt;\n-use std::io;\n use std::mem;\n use std::usize;\n use syntax::print::pprust::PrintState;\n@@ -98,23 +97,23 @@ impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n }\n \n impl<'tcx, O: DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n-    fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) -> io::Result<()> {\n+    fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) {\n         pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n     }\n     fn pre(&self,\n            ps: &mut pprust::State<'_>,\n-           node: pprust::AnnNode<'_>) -> io::Result<()> {\n+           node: pprust::AnnNode<'_>) {\n         let id = match node {\n-            pprust::AnnNode::Name(_) => return Ok(()),\n+            pprust::AnnNode::Name(_) => return,\n             pprust::AnnNode::Expr(expr) => expr.hir_id.local_id,\n             pprust::AnnNode::Block(blk) => blk.hir_id.local_id,\n             pprust::AnnNode::Item(_) |\n-            pprust::AnnNode::SubItem(_) => return Ok(()),\n+            pprust::AnnNode::SubItem(_) => return,\n             pprust::AnnNode::Pat(pat) => pat.hir_id.local_id\n         };\n \n         if !self.has_bitset_for_local_id(id) {\n-            return Ok(());\n+            return;\n         }\n \n         assert!(self.bits_per_id > 0);\n@@ -147,10 +146,9 @@ impl<'tcx, O: DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n \n             ps.synth_comment(\n                 format!(\"id {}: {}{}{}{}\", id.as_usize(), entry_str,\n-                        gens_str, action_kills_str, scope_kills_str))?;\n-            ps.s.space()?;\n+                        gens_str, action_kills_str, scope_kills_str));\n+            ps.s.space();\n         }\n-        Ok(())\n     }\n }\n \n@@ -531,8 +529,8 @@ impl<'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'tcx, O> {\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", pprust::to_string(self, |s| {\n-            s.cbox(pprust::indent_unit)?;\n-            s.ibox(0)?;\n+            s.cbox(pprust::indent_unit);\n+            s.ibox(0);\n             s.print_expr(&body.value)\n         }));\n     }"}, {"sha": "9f0e90e5214fee3df570fc98680c44c143363f2e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 61, "deletions": 71, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0", "patch": "@@ -297,12 +297,9 @@ impl<'hir> HirPrinterSupport<'hir> for NoAnn<'hir> {\n \n impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n-    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n-              -> io::Result<()> {\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(tcx) = self.tcx {\n             pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n-        } else {\n-            Ok(())\n         }\n     }\n }\n@@ -323,37 +320,37 @@ impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n }\n \n impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n-    fn pre(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n         match node {\n             pprust::AnnNode::Expr(_) => s.popen(),\n-            _ => Ok(()),\n+            _ => {}\n         }\n     }\n-    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n         match node {\n             pprust::AnnNode::Ident(_) |\n-            pprust::AnnNode::Name(_) => Ok(()),\n+            pprust::AnnNode::Name(_) => {},\n \n             pprust::AnnNode::Item(item) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(item.id.to_string())\n             }\n             pprust::AnnNode::SubItem(id) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(id.to_string())\n             }\n             pprust::AnnNode::Block(blk) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust::AnnNode::Expr(expr) => {\n-                s.s.space()?;\n-                s.synth_comment(expr.id.to_string())?;\n+                s.s.space();\n+                s.synth_comment(expr.id.to_string());\n                 s.pclose()\n             }\n             pprust::AnnNode::Pat(pat) => {\n-                s.s.space()?;\n-                s.synth_comment(format!(\"pat {}\", pat.id))\n+                s.s.space();\n+                s.synth_comment(format!(\"pat {}\", pat.id));\n             }\n         }\n     }\n@@ -374,45 +371,42 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n }\n \n impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n-    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n-              -> io::Result<()> {\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(ref tcx) = self.tcx {\n             pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n-        } else {\n-            Ok(())\n         }\n     }\n-    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         match node {\n             pprust_hir::AnnNode::Expr(_) => s.popen(),\n-            _ => Ok(()),\n+            _ => {}\n         }\n     }\n-    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         match node {\n-            pprust_hir::AnnNode::Name(_) => Ok(()),\n+            pprust_hir::AnnNode::Name(_) => {},\n             pprust_hir::AnnNode::Item(item) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"hir_id: {} hir local_id: {}\",\n                                         item.hir_id, item.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::SubItem(id) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(id.to_string())\n             }\n             pprust_hir::AnnNode::Block(blk) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"block hir_id: {} hir local_id: {}\",\n                                         blk.hir_id, blk.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::Expr(expr) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"expr hir_id: {} hir local_id: {}\",\n-                                        expr.hir_id, expr.hir_id.local_id.as_u32()))?;\n+                                        expr.hir_id, expr.hir_id.local_id.as_u32()));\n                 s.pclose()\n             }\n             pprust_hir::AnnNode::Pat(pat) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"pat hir_id: {} hir local_id: {}\",\n                                         pat.hir_id, pat.hir_id.local_id.as_u32()))\n             }\n@@ -435,19 +429,19 @@ impl<'a> PrinterSupport for HygieneAnnotation<'a> {\n }\n \n impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n-    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n         match node {\n             pprust::AnnNode::Ident(&ast::Ident { name, span }) => {\n-                s.s.space()?;\n+                s.s.space();\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n                 s.synth_comment(format!(\"{}{:?}\", name.as_u32(), span.ctxt()))\n             }\n             pprust::AnnNode::Name(&name) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(name.as_u32().to_string())\n             }\n-            _ => Ok(()),\n+            _ => {}\n         }\n     }\n }\n@@ -476,32 +470,30 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n }\n \n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n-    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n-              -> io::Result<()> {\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         let old_tables = self.tables.get();\n         if let pprust_hir::Nested::Body(id) = nested {\n             self.tables.set(self.tcx.body_tables(id));\n         }\n-        pprust_hir::PpAnn::nested(self.tcx.hir(), state, nested)?;\n+        pprust_hir::PpAnn::nested(self.tcx.hir(), state, nested);\n         self.tables.set(old_tables);\n-        Ok(())\n     }\n-    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         match node {\n             pprust_hir::AnnNode::Expr(_) => s.popen(),\n-            _ => Ok(()),\n+            _ => {}\n         }\n     }\n-    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         match node {\n             pprust_hir::AnnNode::Expr(expr) => {\n-                s.s.space()?;\n-                s.s.word(\"as\")?;\n-                s.s.space()?;\n-                s.s.word(self.tables.get().expr_ty(expr).to_string())?;\n-                s.pclose()\n+                s.s.space();\n+                s.s.word(\"as\");\n+                s.s.space();\n+                s.s.word(self.tables.get().expr_ty(expr).to_string());\n+                s.pclose();\n             }\n-            _ => Ok(()),\n+            _ => {},\n         }\n     }\n }\n@@ -728,11 +720,11 @@ pub fn print_after_parsing(sess: &Session,\n     let (src, src_name) = get_source(input, sess);\n \n     let mut rdr = &*src;\n-    let mut out = Vec::new();\n+    let mut out = String::new();\n \n     if let PpmSource(s) = ppm {\n         // Silently ignores an identified node.\n-        let out: &mut dyn Write = &mut out;\n+        let out = &mut out;\n         s.call_with_pp_support(sess, None, move |annotation| {\n             debug!(\"pretty printing source code {:?}\", s);\n             let sess = annotation.sess();\n@@ -741,15 +733,15 @@ pub fn print_after_parsing(sess: &Session,\n                                 krate,\n                                 src_name,\n                                 &mut rdr,\n-                                box out,\n+                                out,\n                                 annotation.pp_ann(),\n                                 false)\n-        }).unwrap()\n+        })\n     } else {\n         unreachable!();\n     };\n \n-    write_output(out, ofile);\n+    write_output(out.into_bytes(), ofile);\n }\n \n pub fn print_after_hir_lowering<'tcx>(\n@@ -773,12 +765,12 @@ pub fn print_after_hir_lowering<'tcx>(\n     let (src, src_name) = get_source(input, tcx.sess);\n \n     let mut rdr = &src[..];\n-    let mut out = Vec::new();\n+    let mut out = String::new();\n \n     match (ppm, opt_uii) {\n             (PpmSource(s), _) => {\n                 // Silently ignores an identified node.\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support(tcx.sess, Some(tcx), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n@@ -787,14 +779,14 @@ pub fn print_after_hir_lowering<'tcx>(\n                                         krate,\n                                         src_name,\n                                         &mut rdr,\n-                                        box out,\n+                                        out,\n                                         annotation.pp_ann(),\n                                         true)\n                 })\n             }\n \n             (PpmHir(s), None) => {\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support_hir(tcx, move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n@@ -803,21 +795,21 @@ pub fn print_after_hir_lowering<'tcx>(\n                                             krate,\n                                             src_name,\n                                             &mut rdr,\n-                                            box out,\n+                                            out,\n                                             annotation.pp_ann())\n                 })\n             }\n \n             (PpmHirTree(s), None) => {\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support_hir(tcx, move |_annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n-                    write!(out, \"{:#?}\", krate)\n-                })\n+                    *out = format!(\"{:#?}\", krate);\n+                });\n             }\n \n             (PpmHir(s), Some(uii)) => {\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support_hir(tcx, move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n@@ -826,40 +818,38 @@ pub fn print_after_hir_lowering<'tcx>(\n                                                                          &sess.parse_sess,\n                                                                          src_name,\n                                                                          &mut rdr,\n-                                                                         box out,\n+                                                                         out,\n                                                                          annotation.pp_ann());\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);\n                         let node = hir_map.get(hir_id);\n-                        pp_state.print_node(node)?;\n-                        pp_state.s.space()?;\n+                        pp_state.print_node(node);\n+                        pp_state.s.space();\n                         let path = annotation.node_path(hir_id)\n                             .expect(\"-Z unpretty missing node paths\");\n-                        pp_state.synth_comment(path)?;\n-                        pp_state.s.hardbreak()?;\n+                        pp_state.synth_comment(path);\n+                        pp_state.s.hardbreak();\n                     }\n-                    pp_state.s.eof()\n+                    pp_state.s.eof();\n                 })\n             }\n \n             (PpmHirTree(s), Some(uii)) => {\n-                let out: &mut dyn Write = &mut out;\n+                let out = &mut out;\n                 s.call_with_pp_support_hir(tcx, move |_annotation, _krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     for node_id in uii.all_matching_node_ids(tcx.hir()) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);\n                         let node = tcx.hir().get(hir_id);\n-                        write!(out, \"{:#?}\", node)?;\n+                        out.push_str(&format!(\"{:#?}\", node));\n                     }\n-                    Ok(())\n                 })\n             }\n \n             _ => unreachable!(),\n         }\n-        .unwrap();\n \n-    write_output(out, ofile);\n+    write_output(out.into_bytes(), ofile);\n }\n \n // In an ideal world, this would be a public function called by the driver after"}, {"sha": "11a1de13fc217874cef8fb8d67eed2fefc9bd50b", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0", "patch": "@@ -1261,7 +1261,6 @@ pub fn noop_visit_vis<T: MutVisitor>(Spanned { node, span }: &mut Visibility, vi\n \n #[cfg(test)]\n mod tests {\n-    use std::io;\n     use crate::ast::{self, Ident};\n     use crate::util::parser_testing::{string_to_crate, matches_codepattern};\n     use crate::print::pprust;\n@@ -1271,7 +1270,7 @@ mod tests {\n \n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: &mut pprust::State<'_>,\n-                        krate: &ast::Crate) -> io::Result<()> {\n+                        krate: &ast::Crate) {\n         s.print_mod(&krate.module, &krate.attrs)\n     }\n "}, {"sha": "edcdb18a037d863f5b08fff410fce9c6e4c6bebc", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0", "patch": "@@ -613,12 +613,12 @@ impl<'a> Parser<'a> {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     use crate::print::pprust::PrintState;\n \n-                    s.s.word(\"&\")?;\n-                    s.print_opt_lifetime(lifetime)?;\n-                    s.print_mutability(mut_ty.mutbl)?;\n-                    s.popen()?;\n-                    s.print_type(&mut_ty.ty)?;\n-                    s.print_type_bounds(\" +\", &bounds)?;\n+                    s.s.word(\"&\");\n+                    s.print_opt_lifetime(lifetime);\n+                    s.print_mutability(mut_ty.mutbl);\n+                    s.popen();\n+                    s.print_type(&mut_ty.ty);\n+                    s.print_type_bounds(\" +\", &bounds);\n                     s.pclose()\n                 });\n                 err.span_suggestion("}, {"sha": "cef14632e641fd3552846fcd40673f53f37feeb9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0", "patch": "@@ -2572,12 +2572,12 @@ impl<'a> Parser<'a> {\n                           };\n                           let sugg = pprust::to_string(|s| {\n                               use crate::print::pprust::PrintState;\n-                              s.popen()?;\n-                              s.print_expr(&e)?;\n-                              s.s.word( \".\")?;\n-                              s.print_usize(float.trunc() as usize)?;\n-                              s.pclose()?;\n-                              s.s.word(\".\")?;\n+                              s.popen();\n+                              s.print_expr(&e);\n+                              s.s.word( \".\");\n+                              s.print_usize(float.trunc() as usize);\n+                              s.pclose();\n+                              s.s.word(\".\");\n                               s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n                           });\n                           err.span_suggestion(\n@@ -4583,9 +4583,9 @@ impl<'a> Parser<'a> {\n                     }\n                     let sugg = pprust::to_string(|s| {\n                         use crate::print::pprust::{PrintState, INDENT_UNIT};\n-                        s.ibox(INDENT_UNIT)?;\n-                        s.bopen()?;\n-                        s.print_stmt(&stmt)?;\n+                        s.ibox(INDENT_UNIT);\n+                        s.bopen();\n+                        s.print_stmt(&stmt);\n                         s.bclose_maybe_open(stmt.span, INDENT_UNIT, false)\n                     });\n                     e.span_suggestion("}, {"sha": "f64e95aee5bca91ee5ac4382bdf997db165a519e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 55, "deletions": 83, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0", "patch": "@@ -136,7 +136,6 @@\n \n use std::collections::VecDeque;\n use std::fmt;\n-use std::io;\n use std::borrow::Cow;\n use log::debug;\n \n@@ -172,7 +171,7 @@ pub enum Token {\n }\n \n impl Token {\n-    pub fn is_eof(&self) -> bool {\n+    crate fn is_eof(&self) -> bool {\n         match *self {\n             Token::Eof => true,\n             _ => false,\n@@ -223,20 +222,21 @@ fn buf_str(buf: &[BufEntry], left: usize, right: usize, lim: usize) -> String {\n }\n \n #[derive(Copy, Clone)]\n-pub enum PrintStackBreak {\n+crate enum PrintStackBreak {\n     Fits,\n     Broken(Breaks),\n }\n \n #[derive(Copy, Clone)]\n-pub struct PrintStackElem {\n+crate struct PrintStackElem {\n     offset: isize,\n     pbreak: PrintStackBreak\n }\n \n const SIZE_INFINITY: isize = 0xffff;\n \n-pub fn mk_printer<'a>(out: Box<dyn io::Write+'a>, linewidth: usize) -> Printer<'a> {\n+pub fn mk_printer(out: &mut String) -> Printer<'_> {\n+    let linewidth = 78;\n     // Yes 55, it makes the ring buffers big enough to never fall behind.\n     let n: usize = 55 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n@@ -259,7 +259,7 @@ pub fn mk_printer<'a>(out: Box<dyn io::Write+'a>, linewidth: usize) -> Printer<'\n }\n \n pub struct Printer<'a> {\n-    out: Box<dyn io::Write+'a>,\n+    out: &'a mut String,\n     buf_max_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,\n@@ -300,8 +300,6 @@ impl Default for BufEntry {\n     }\n }\n \n-const SPACES: [u8; 128] = [b' '; 128];\n-\n impl<'a> Printer<'a> {\n     pub fn last_token(&mut self) -> Token {\n         self.buf[self.right].token.clone()\n@@ -312,16 +310,15 @@ impl<'a> Printer<'a> {\n         self.buf[self.right].token = t;\n     }\n \n-    fn pretty_print_eof(&mut self) -> io::Result<()> {\n+    fn pretty_print_eof(&mut self) {\n         if !self.scan_stack.is_empty() {\n             self.check_stack(0);\n-            self.advance_left()?;\n+            self.advance_left();\n         }\n         self.indent(0);\n-        Ok(())\n     }\n \n-    fn pretty_print_begin(&mut self, b: BeginToken) -> io::Result<()> {\n+    fn pretty_print_begin(&mut self, b: BeginToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n@@ -335,24 +332,22 @@ impl<'a> Printer<'a> {\n         self.buf[self.right] = BufEntry { token: Token::Begin(b), size: -self.right_total };\n         let right = self.right;\n         self.scan_push(right);\n-        Ok(())\n     }\n \n-    fn pretty_print_end(&mut self) -> io::Result<()> {\n+    fn pretty_print_end(&mut self) {\n         if self.scan_stack.is_empty() {\n             debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n-            self.print_end()\n+            self.print_end();\n         } else {\n             debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n             self.advance_right();\n             self.buf[self.right] = BufEntry { token: Token::End, size: -1 };\n             let right = self.right;\n             self.scan_push(right);\n-            Ok(())\n         }\n     }\n \n-    fn pretty_print_break(&mut self, b: BreakToken) -> io::Result<()> {\n+    fn pretty_print_break(&mut self, b: BreakToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n@@ -368,25 +363,24 @@ impl<'a> Printer<'a> {\n         self.scan_push(right);\n         self.buf[self.right] = BufEntry { token: Token::Break(b), size: -self.right_total };\n         self.right_total += b.blank_space;\n-        Ok(())\n     }\n \n-    fn pretty_print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+    fn pretty_print_string(&mut self, s: Cow<'static, str>, len: isize) {\n         if self.scan_stack.is_empty() {\n             debug!(\"pp String('{}')/print Vec<{},{}>\",\n                    s, self.left, self.right);\n-            self.print_string(s, len)\n+            self.print_string(s, len);\n         } else {\n             debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n                    s, self.left, self.right);\n             self.advance_right();\n             self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n             self.right_total += len;\n-            self.check_stream()\n+            self.check_stream();\n         }\n     }\n \n-    pub fn check_stream(&mut self) -> io::Result<()> {\n+    crate fn check_stream(&mut self) {\n         debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -397,32 +391,31 @@ impl<'a> Printer<'a> {\n                 let scanned = self.scan_pop_bottom();\n                 self.buf[scanned].size = SIZE_INFINITY;\n             }\n-            self.advance_left()?;\n+            self.advance_left();\n             if self.left != self.right {\n-                self.check_stream()?;\n+                self.check_stream();\n             }\n         }\n-        Ok(())\n     }\n \n-    pub fn scan_push(&mut self, x: usize) {\n+    crate fn scan_push(&mut self, x: usize) {\n         debug!(\"scan_push {}\", x);\n         self.scan_stack.push_front(x);\n     }\n \n-    pub fn scan_pop(&mut self) -> usize {\n+    crate fn scan_pop(&mut self) -> usize {\n         self.scan_stack.pop_front().unwrap()\n     }\n \n-    pub fn scan_top(&mut self) -> usize {\n+    crate fn scan_top(&mut self) -> usize {\n         *self.scan_stack.front().unwrap()\n     }\n \n-    pub fn scan_pop_bottom(&mut self) -> usize {\n+    crate fn scan_pop_bottom(&mut self) -> usize {\n         self.scan_stack.pop_back().unwrap()\n     }\n \n-    pub fn advance_right(&mut self) {\n+    crate fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_max_len;\n         // Extend the buf if necessary.\n@@ -432,7 +425,7 @@ impl<'a> Printer<'a> {\n         assert_ne!(self.right, self.left);\n     }\n \n-    pub fn advance_left(&mut self) -> io::Result<()> {\n+    crate fn advance_left(&mut self) {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n                self.left, self.buf[self.left].size);\n \n@@ -450,7 +443,7 @@ impl<'a> Printer<'a> {\n                 _ => 0\n             };\n \n-            self.print(left, left_size)?;\n+            self.print(left, left_size);\n \n             self.left_total += len;\n \n@@ -463,11 +456,9 @@ impl<'a> Printer<'a> {\n \n             left_size = self.buf[self.left].size;\n         }\n-\n-        Ok(())\n     }\n \n-    pub fn check_stack(&mut self, k: isize) {\n+    crate fn check_stack(&mut self, k: isize) {\n         if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n             match self.buf[x].token {\n@@ -495,20 +486,19 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    pub fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n+    crate fn print_newline(&mut self, amount: isize) {\n         debug!(\"NEWLINE {}\", amount);\n-        let ret = writeln!(self.out);\n+        self.out.push('\\n');\n         self.pending_indentation = 0;\n         self.indent(amount);\n-        ret\n     }\n \n-    pub fn indent(&mut self, amount: isize) {\n+    crate fn indent(&mut self, amount: isize) {\n         debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n \n-    pub fn get_top(&mut self) -> PrintStackElem {\n+    crate fn get_top(&mut self) -> PrintStackElem {\n         match self.print_stack.last() {\n             Some(el) => *el,\n             None => PrintStackElem {\n@@ -518,7 +508,7 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    pub fn print_begin(&mut self, b: BeginToken, l: isize) -> io::Result<()> {\n+    crate fn print_begin(&mut self, b: BeginToken, l: isize) {\n         if l > self.space {\n             let col = self.margin - self.space + b.offset;\n             debug!(\"print Begin -> push broken block at col {}\", col);\n@@ -533,52 +523,46 @@ impl<'a> Printer<'a> {\n                 pbreak: PrintStackBreak::Fits\n             });\n         }\n-        Ok(())\n     }\n \n-    pub fn print_end(&mut self) -> io::Result<()> {\n+    crate fn print_end(&mut self) {\n         debug!(\"print End -> pop End\");\n         let print_stack = &mut self.print_stack;\n         assert!(!print_stack.is_empty());\n         print_stack.pop().unwrap();\n-        Ok(())\n     }\n \n-    pub fn print_break(&mut self, b: BreakToken, l: isize) -> io::Result<()> {\n+    crate fn print_break(&mut self, b: BreakToken, l: isize) {\n         let top = self.get_top();\n         match top.pbreak {\n             PrintStackBreak::Fits => {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n-                Ok(())\n             }\n             PrintStackBreak::Broken(Breaks::Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n-                let ret = self.print_newline(top.offset + b.offset);\n+                self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n-                ret\n             }\n             PrintStackBreak::Broken(Breaks::Inconsistent) => {\n                 if l > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n-                    let ret = self.print_newline(top.offset + b.offset);\n+                    self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n-                    ret\n                 } else {\n                     debug!(\"print Break({}) w/o newline in inconsistent\",\n                            b.blank_space);\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n-                    Ok(())\n                 }\n             }\n         }\n     }\n \n-    pub fn print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+    crate fn print_string(&mut self, s: Cow<'static, str>, len: isize) {\n         debug!(\"print String({})\", s);\n         // assert!(len <= space);\n         self.space -= len;\n@@ -587,23 +571,15 @@ impl<'a> Printer<'a> {\n         //\n         //   write!(self.out, \"{: >n$}\", \"\", n = self.pending_indentation as usize)?;\n         //\n-        // But that is significantly slower than using `SPACES`. This code is\n-        // sufficiently hot, and indents can get sufficiently large, that the\n-        // difference is significant on some workloads.\n-        let spaces_len = SPACES.len() as isize;\n-        while self.pending_indentation >= spaces_len {\n-            self.out.write_all(&SPACES)?;\n-            self.pending_indentation -= spaces_len;\n-        }\n-        if self.pending_indentation > 0 {\n-            self.out.write_all(&SPACES[0..self.pending_indentation as usize])?;\n-            self.pending_indentation = 0;\n-        }\n-\n-        write!(self.out, \"{}\", s)\n+        // But that is significantly slower. This code is sufficiently hot, and indents can get\n+        // sufficiently large, that the difference is significant on some workloads.\n+        self.out.reserve(self.pending_indentation as usize);\n+        self.out.extend(std::iter::repeat(' ').take(self.pending_indentation as usize));\n+        self.pending_indentation = 0;\n+        self.out.push_str(&s);\n     }\n \n-    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n+    crate fn print(&mut self, token: Token, l: isize) {\n         debug!(\"print {} {} (remaining line space={})\", token, l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.buf,\n@@ -616,7 +592,7 @@ impl<'a> Printer<'a> {\n             Token::Break(b) => self.print_break(b, l),\n             Token::String(s, len) => {\n                 assert_eq!(len, l);\n-                self.print_string(s, len)\n+                self.print_string(s, len);\n             }\n             Token::Eof => panic!(), // Eof should never get here.\n         }\n@@ -625,65 +601,61 @@ impl<'a> Printer<'a> {\n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n-    pub fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n+    crate fn rbox(&mut self, indent: usize, b: Breaks) {\n         self.pretty_print_begin(BeginToken {\n             offset: indent as isize,\n             breaks: b\n         })\n     }\n \n     /// Inconsistent breaking box\n-    pub fn ibox(&mut self, indent: usize) -> io::Result<()> {\n+    crate fn ibox(&mut self, indent: usize) {\n         self.rbox(indent, Breaks::Inconsistent)\n     }\n \n     /// Consistent breaking box\n-    pub fn cbox(&mut self, indent: usize) -> io::Result<()> {\n+    pub fn cbox(&mut self, indent: usize) {\n         self.rbox(indent, Breaks::Consistent)\n     }\n \n-    pub fn break_offset(&mut self, n: usize, off: isize) -> io::Result<()> {\n+    pub fn break_offset(&mut self, n: usize, off: isize) {\n         self.pretty_print_break(BreakToken {\n             offset: off,\n             blank_space: n as isize\n         })\n     }\n \n-    pub fn end(&mut self) -> io::Result<()> {\n+    crate fn end(&mut self) {\n         self.pretty_print_end()\n     }\n \n-    pub fn eof(&mut self) -> io::Result<()> {\n+    pub fn eof(&mut self) {\n         self.pretty_print_eof()\n     }\n \n-    pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) -> io::Result<()> {\n+    pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) {\n         let s = wrd.into();\n         let len = s.len() as isize;\n         self.pretty_print_string(s, len)\n     }\n \n-    fn spaces(&mut self, n: usize) -> io::Result<()> {\n+    fn spaces(&mut self, n: usize) {\n         self.break_offset(n, 0)\n     }\n \n-    pub fn zerobreak(&mut self) -> io::Result<()> {\n+    crate fn zerobreak(&mut self) {\n         self.spaces(0)\n     }\n \n-    pub fn space(&mut self) -> io::Result<()> {\n+    pub fn space(&mut self) {\n         self.spaces(1)\n     }\n \n-    pub fn hardbreak(&mut self) -> io::Result<()> {\n+    pub fn hardbreak(&mut self) {\n         self.spaces(SIZE_INFINITY as usize)\n     }\n \n     pub fn hardbreak_tok_offset(off: isize) -> Token {\n         Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n     }\n-\n-    pub fn hardbreak_tok() -> Token {\n-        Self::hardbreak_tok_offset(0)\n-    }\n }"}, {"sha": "67646cce69b4f47d2addf5753ad5c20a98845fba", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1076, "deletions": 1197, "changes": 2273, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0"}, {"sha": "c717f140ca368e36a8536c3debf526873832b7eb", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f119bf2761ab11ca577fac9881678c04d3e7fdb0/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f119bf2761ab11ca577fac9881678c04d3e7fdb0", "patch": "@@ -26,7 +26,6 @@ use crate::mut_visit::{*, ExpectOne};\n use crate::feature_gate::Features;\n use crate::util::map_in_place::MapInPlace;\n use crate::parse::{token, ParseSess};\n-use crate::print::pprust;\n use crate::ast::{self, Ident};\n use crate::ptr::P;\n use crate::symbol::{self, Symbol, kw, sym};"}]}