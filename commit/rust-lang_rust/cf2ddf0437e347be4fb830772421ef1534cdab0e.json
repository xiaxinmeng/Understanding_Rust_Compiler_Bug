{"sha": "cf2ddf0437e347be4fb830772421ef1534cdab0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMmRkZjA0MzdlMzQ3YmU0ZmI4MzA3NzI0MjFlZjE1MzRjZGFiMGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-02-18T06:24:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-02-18T06:24:14Z"}, "message": "Add benchmarks to measure differences in bit vectors", "tree": {"sha": "d33e701089b16257ca0440873fa543da4fe96a8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d33e701089b16257ca0440873fa543da4fe96a8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf2ddf0437e347be4fb830772421ef1534cdab0e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf2ddf0437e347be4fb830772421ef1534cdab0e", "html_url": "https://github.com/rust-lang/rust/commit/cf2ddf0437e347be4fb830772421ef1534cdab0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf2ddf0437e347be4fb830772421ef1534cdab0e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf8ed45adc485e0e8e678e7b43b0c67ff93392f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf8ed45adc485e0e8e678e7b43b0c67ff93392f5", "html_url": "https://github.com/rust-lang/rust/commit/bf8ed45adc485e0e8e678e7b43b0c67ff93392f5"}], "stats": {"total": 272, "additions": 272, "deletions": 0}, "files": [{"sha": "5ba10a9eb14768ff982e26eba9d5f9c7d59ce049", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cf2ddf0437e347be4fb830772421ef1534cdab0e/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2ddf0437e347be4fb830772421ef1534cdab0e/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=cf2ddf0437e347be4fb830772421ef1534cdab0e", "patch": "@@ -869,12 +869,16 @@ priv impl BitvSet {\n #[cfg(test)]\n mod tests {\n     use core::prelude::*;\n+    use std::test::BenchHarness;\n \n     use bitv::*;\n     use bitv;\n \n     use core::uint;\n     use core::vec;\n+    use core::rand;\n+\n+    const bench_bits : uint = 1 << 14;\n \n     #[test]\n     pub fn test_to_str() {\n@@ -1419,6 +1423,94 @@ mod tests {\n         assert a.remove(&1000);\n         assert a.capacity() == uint::bits;\n     }\n+\n+    fn rng() -> rand::Rng {\n+        let seed = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        rand::seeded_rng(&seed)\n+    }\n+\n+    #[bench]\n+    pub fn bench_uint_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = 0 as uint;\n+        do b.iter {\n+            bitv |= (1 << ((r.next() as uint) % uint::bits));\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_small_bitv_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = SmallBitv::new(uint::bits);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % uint::bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_big_bitv_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = BigBitv::new(~[0]);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % uint::bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_big_bitv_big(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut storage = ~[];\n+        storage.grow(bench_bits / uint::bits, &0);\n+        let mut bitv = BigBitv::new(storage);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % bench_bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_big(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = Bitv::new(bench_bits, false);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % bench_bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = Bitv::new(uint::bits, false);\n+        do b.iter {\n+            bitv.set((r.next() as uint) % uint::bits, true);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_set_small(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = BitvSet::new();\n+        do b.iter {\n+            bitv.insert((r.next() as uint) % uint::bits);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_set_big(b: &mut BenchHarness) {\n+        let r = rng();\n+        let mut bitv = BitvSet::new();\n+        do b.iter {\n+            bitv.insert((r.next() as uint) % bench_bits);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_bitv_big_union(b: &mut BenchHarness) {\n+        let mut b1 = Bitv::new(bench_bits, false);\n+        let mut b2 = Bitv::new(bench_bits, false);\n+        do b.iter {\n+            b1.union(&b2);\n+        }\n+    }\n }\n \n //"}, {"sha": "cfb27329174fe72c58c162264250354d4b1165f7", "filename": "src/test/bench/core-set.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/cf2ddf0437e347be4fb830772421ef1534cdab0e/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2ddf0437e347be4fb830772421ef1534cdab0e/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=cf2ddf0437e347be4fb830772421ef1534cdab0e", "patch": "@@ -0,0 +1,180 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod std;\n+use core::hashmap::linear::LinearSet;\n+use std::bitv::BitvSet;\n+use std::treemap::TreeSet;\n+use core::io::WriterUtil;\n+\n+struct Results {\n+    sequential_ints: float,\n+    random_ints: float,\n+    delete_ints: float,\n+\n+    sequential_strings: float,\n+    random_strings: float,\n+    delete_strings: float\n+}\n+\n+fn timed(result: &mut float, op: fn()) {\n+    let start = std::time::precise_time_s();\n+    op();\n+    let end = std::time::precise_time_s();\n+    *result = (end - start);\n+}\n+\n+impl Results {\n+    fn bench_int<T: Set<uint>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+                               rand_cap: uint, f: fn() -> T) {\n+        {\n+            let mut set = f();\n+            do timed(&mut self.sequential_ints) {\n+                for uint::range(0, num_keys) |i| {\n+                    set.insert(i);\n+                }\n+\n+                for uint::range(0, num_keys) |i| {\n+                    assert set.contains(&i);\n+                }\n+            }\n+        }\n+\n+        {\n+            let mut set = f();\n+            do timed(&mut self.random_ints) {\n+                for num_keys.times {\n+                    set.insert((rng.next() as uint) % rand_cap);\n+                }\n+            }\n+        }\n+\n+        {\n+            let mut set = f();\n+            for uint::range(0, num_keys) |i| {\n+                set.insert(i);\n+            }\n+\n+            do timed(&mut self.delete_ints) {\n+                for uint::range(0, num_keys) |i| {\n+                    assert set.remove(&i);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn bench_str<T: Set<~str>>(&mut self, rng: @rand::Rng, num_keys: uint,\n+                               f: fn() -> T) {\n+        {\n+            let mut set = f();\n+            do timed(&mut self.sequential_strings) {\n+                for uint::range(0, num_keys) |i| {\n+                    let s = uint::to_str(i);\n+                    set.insert(s);\n+                }\n+\n+                for uint::range(0, num_keys) |i| {\n+                    let s = uint::to_str(i);\n+                    assert set.contains(&s);\n+                }\n+            }\n+        }\n+\n+        {\n+            let mut set = f();\n+            do timed(&mut self.random_strings) {\n+                for num_keys.times {\n+                    let s = uint::to_str(rng.next() as uint);\n+                    set.insert(s);\n+                }\n+            }\n+        }\n+\n+        {\n+            let mut set = f();\n+            for uint::range(0, num_keys) |i| {\n+                set.insert(uint::to_str(i));\n+            }\n+            do timed(&mut self.delete_strings) {\n+                for uint::range(0, num_keys) |i| {\n+                    assert set.remove(&uint::to_str(i));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn write_header(header: &str) {\n+    io::stdout().write_str(header);\n+    io::stdout().write_str(\"\\n\");\n+}\n+\n+fn write_row(label: &str, value: float) {\n+    io::stdout().write_str(fmt!(\"%30s %f s\\n\", label, value));\n+}\n+\n+fn write_results(label: &str, results: &Results) {\n+    write_header(label);\n+    write_row(\"sequential_ints\", results.sequential_ints);\n+    write_row(\"random_ints\", results.random_ints);\n+    write_row(\"delete_ints\", results.delete_ints);\n+    write_row(\"sequential_strings\", results.sequential_strings);\n+    write_row(\"random_strings\", results.random_strings);\n+    write_row(\"delete_strings\", results.delete_strings);\n+}\n+\n+fn empty_results() -> Results {\n+    Results {\n+        sequential_ints: 0f,\n+        random_ints: 0f,\n+        delete_ints: 0f,\n+\n+        sequential_strings: 0f,\n+        random_strings: 0f,\n+        delete_strings: 0f,\n+    }\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    let num_keys = {\n+        if args.len() == 2 {\n+            uint::from_str(args[1]).get()\n+        } else {\n+            100 // woefully inadequate for any real measurement\n+        }\n+    };\n+\n+    let seed = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let max = 200000;\n+\n+    {\n+        let rng = rand::seeded_rng(&seed);\n+        let mut results = empty_results();\n+        results.bench_int(rng, num_keys, max, || LinearSet::new::<uint>());\n+        results.bench_str(rng, num_keys, || LinearSet::new::<~str>());\n+        write_results(\"core::hashmap::LinearSet\", &results);\n+    }\n+\n+    {\n+        let rng = rand::seeded_rng(&seed);\n+        let mut results = empty_results();\n+        results.bench_int(rng, num_keys, max, || TreeSet::new::<uint>());\n+        results.bench_str(rng, num_keys, || TreeSet::new::<~str>());\n+        write_results(\"std::treemap::TreeSet\", &results);\n+    }\n+\n+    {\n+        let rng = rand::seeded_rng(&seed);\n+        let mut results = empty_results();\n+        results.bench_int(rng, num_keys, max, || BitvSet::new());\n+        write_results(\"std::bitv::BitvSet\", &results);\n+    }\n+}"}]}