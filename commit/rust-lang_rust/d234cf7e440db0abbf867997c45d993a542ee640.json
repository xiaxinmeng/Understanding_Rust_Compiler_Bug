{"sha": "d234cf7e440db0abbf867997c45d993a542ee640", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMzRjZjdlNDQwZGIwYWJiZjg2Nzk5N2M0NWQ5OTNhNTQyZWU2NDA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-06T21:28:16Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T21:52:06Z"}, "message": "core::rt: Make TCP servers work", "tree": {"sha": "7ca85b1c89c68eb3de82f30b63d40d90833b01c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ca85b1c89c68eb3de82f30b63d40d90833b01c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d234cf7e440db0abbf867997c45d993a542ee640", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d234cf7e440db0abbf867997c45d993a542ee640", "html_url": "https://github.com/rust-lang/rust/commit/d234cf7e440db0abbf867997c45d993a542ee640", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d234cf7e440db0abbf867997c45d993a542ee640/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "414f3c7d252fcd54562c0c8a85499d7d07f5e612", "url": "https://api.github.com/repos/rust-lang/rust/commits/414f3c7d252fcd54562c0c8a85499d7d07f5e612", "html_url": "https://github.com/rust-lang/rust/commit/414f3c7d252fcd54562c0c8a85499d7d07f5e612"}], "stats": {"total": 195, "additions": 161, "deletions": 34}, "files": [{"sha": "90f99f8df8b8779490365b43c06638e367ca0f22", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 83, "deletions": 3, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d234cf7e440db0abbf867997c45d993a542ee640/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d234cf7e440db0abbf867997c45d993a542ee640/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=d234cf7e440db0abbf867997c45d993a542ee640", "patch": "@@ -79,7 +79,7 @@ impl Writer for TcpStream {\n }\n \n pub struct TcpListener {\n-    rtlistener: ~RtioTcpListenerObject\n+    rtlistener: ~RtioTcpListenerObject,\n }\n \n impl TcpListener {\n@@ -116,6 +116,8 @@ impl Listener<TcpStream> for TcpListener {\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use int;\n+    use cell::Cell;\n     use rt::test::*;\n     use rt::io::net::ip::Ipv4;\n     use rt::io::*;\n@@ -172,11 +174,11 @@ mod test {\n         }\n     }\n \n-    #[test] #[ignore]\n+    #[test]\n     fn multiple_connect_serial() {\n         do run_in_newsched_task {\n             let addr = next_test_ip4();\n-            let max = 100;\n+            let max = 10;\n \n             do spawntask_immediately {\n                 let mut listener = TcpListener::bind(addr);\n@@ -197,4 +199,82 @@ mod test {\n         }\n     }\n \n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |i| {\n+                    let stream = Cell(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_immediately {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == i as u8);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_immediately {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([i as u8]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule() {\n+        do run_in_newsched_task {\n+            let addr = next_test_ip4();\n+            static MAX: int = 10;\n+\n+            do spawntask_immediately {\n+                let mut listener = TcpListener::bind(addr);\n+                for int::range(0, MAX) |_| {\n+                    let stream = Cell(listener.accept());\n+                    rtdebug!(\"accepted\");\n+                    // Start another task to handle the connection\n+                    do spawntask_later {\n+                        let mut stream = stream.take();\n+                        let mut buf = [0];\n+                        stream.read(buf);\n+                        assert!(buf[0] == 99);\n+                        rtdebug!(\"read\");\n+                    }\n+                }\n+            }\n+\n+            connect(0, addr);\n+\n+            fn connect(i: int, addr: IpAddr) {\n+                if i == MAX { return }\n+\n+                do spawntask_later {\n+                    rtdebug!(\"connecting\");\n+                    let mut stream = TcpStream::connect(addr);\n+                    // Connect again before writing\n+                    connect(i + 1, addr);\n+                    rtdebug!(\"writing\");\n+                    stream.write([99]);\n+                }\n+            }\n+        }\n+    }\n+\n }"}, {"sha": "8d0ae0caf4d62dfa419883a5c667031fda71aab7", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d234cf7e440db0abbf867997c45d993a542ee640/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d234cf7e440db0abbf867997c45d993a542ee640/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=d234cf7e440db0abbf867997c45d993a542ee640", "patch": "@@ -64,6 +64,46 @@ pub fn spawntask_immediately(f: ~fn()) {\n     }\n }\n \n+/// Create a new task and run it right now. Aborts on failure\n+pub fn spawntask_later(f: ~fn()) {\n+    use super::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+\n+    sched.task_queue.push_front(task);\n+    local_sched::put(sched);\n+}\n+\n+/// Spawn a task and either run it immediately or run it later\n+pub fn spawntask_random(f: ~fn()) {\n+    use super::sched::*;\n+    use rand::{Rand, rng};\n+\n+    let mut rng = rng();\n+    let run_now: bool = Rand::rand(&mut rng);\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::with_local(&mut sched.stack_pool,\n+                                 LocalServices::without_unwinding(),\n+                                 f);\n+\n+    if run_now {\n+        do sched.switch_running_tasks_and_then(task) |task| {\n+            let task = Cell(task);\n+            do local_sched::borrow |sched| {\n+                sched.task_queue.push_front(task.take());\n+            }\n+        }\n+    } else {\n+        sched.task_queue.push_front(task);\n+        local_sched::put(sched);\n+    }\n+}\n+\n+\n /// Spawn a task and wait for it to finish, returning whether it completed successfully or failed\n pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     use cell::Cell;"}, {"sha": "2218c0734fbfbfb5dee7ed1762d70bdaa3e05a82", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d234cf7e440db0abbf867997c45d993a542ee640/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d234cf7e440db0abbf867997c45d993a542ee640/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=d234cf7e440db0abbf867997c45d993a542ee640", "patch": "@@ -21,6 +21,7 @@ use rt::uv::idle::IdleWatcher;\n use rt::rtio::*;\n use rt::sched::{Scheduler, local_sched};\n use rt::io::{standard_error, OtherIoError};\n+use rt::tube::Tube;\n \n #[cfg(test)] use uint;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -149,7 +150,7 @@ impl IoFactory for UvIoFactory {\n     fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n-            Ok(_) => Ok(~UvTcpListener { watcher: watcher }),\n+            Ok(_) => Ok(~UvTcpListener::new(watcher)),\n             Err(uverr) => {\n                 // XXX: Should we wait until close completes?\n                 watcher.as_stream().close(||());\n@@ -161,10 +162,20 @@ impl IoFactory for UvIoFactory {\n \n // FIXME #6090: Prefer newtype structs but Drop doesn't work\n pub struct UvTcpListener {\n-    watcher: TcpWatcher\n+    watcher: TcpWatcher,\n+    listening: bool,\n+    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>\n }\n \n impl UvTcpListener {\n+    fn new(watcher: TcpWatcher) -> UvTcpListener {\n+        UvTcpListener {\n+            watcher: watcher,\n+            listening: false,\n+            incoming_streams: Tube::new()\n+        }\n+    }\n+\n     fn watcher(&self) -> TcpWatcher { self.watcher }\n }\n \n@@ -179,41 +190,37 @@ impl RtioTcpListener for UvTcpListener {\n \n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n         rtdebug!(\"entering listen\");\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n-        let server_tcp_watcher = self.watcher();\n+        if self.listening {\n+            return self.incoming_streams.recv();\n+        }\n \n-        let scheduler = local_sched::take();\n-        assert!(scheduler.in_task_context());\n+        self.listening = true;\n \n-        do scheduler.deschedule_running_task_and_then |task| {\n-            let task_cell = Cell(task);\n-            let mut server_tcp_watcher = server_tcp_watcher;\n-            do server_tcp_watcher.listen |server_stream_watcher, status| {\n-                let maybe_stream = if status.is_none() {\n-                    let mut server_stream_watcher = server_stream_watcher;\n-                    let mut loop_ = server_stream_watcher.event_loop();\n-                    let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                    let client_tcp_watcher = client_tcp_watcher.as_stream();\n-                    // XXX: Need's to be surfaced in interface\n-                    server_stream_watcher.accept(client_tcp_watcher);\n-                    Ok(~UvTcpStream { watcher: client_tcp_watcher })\n-                } else {\n-                    Err(standard_error(OtherIoError))\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+        let server_tcp_watcher = self.watcher();\n+        let incoming_streams_cell = Cell(self.incoming_streams.clone());\n+\n+        let incoming_streams_cell = Cell(incoming_streams_cell.take());\n+        let mut server_tcp_watcher = server_tcp_watcher;\n+        do server_tcp_watcher.listen |server_stream_watcher, status| {\n+            let maybe_stream = if status.is_none() {\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = server_stream_watcher.event_loop();\n+                let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let client_tcp_watcher = client_tcp_watcher.as_stream();\n+                // XXX: Need's to be surfaced in interface\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                Ok(~UvTcpStream { watcher: client_tcp_watcher })\n+            } else {\n+                Err(standard_error(OtherIoError))\n+            };\n \n-                rtdebug!(\"resuming task from listen\");\n-                // Context switch\n-                let scheduler = local_sched::take();\n-                scheduler.resume_task_immediately(task_cell.take());\n-            }\n+            let mut incoming_streams = incoming_streams_cell.take();\n+            incoming_streams.send(maybe_stream);\n+            incoming_streams_cell.put_back(incoming_streams);\n         }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+        return self.incoming_streams.recv();\n     }\n }\n "}]}