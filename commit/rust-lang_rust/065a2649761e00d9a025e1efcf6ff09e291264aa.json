{"sha": "065a2649761e00d9a025e1efcf6ff09e291264aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NWEyNjQ5NzYxZTAwZDlhMDI1ZTFlZmNmNmZmMDllMjkxMjY0YWE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-08T21:10:15Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-06-09T12:24:43Z"}, "message": "refactor simplify_cfg and split off simplify_branches", "tree": {"sha": "6f901fb095af1ece8dade3905f0557be18f9fc5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f901fb095af1ece8dade3905f0557be18f9fc5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/065a2649761e00d9a025e1efcf6ff09e291264aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/065a2649761e00d9a025e1efcf6ff09e291264aa", "html_url": "https://github.com/rust-lang/rust/commit/065a2649761e00d9a025e1efcf6ff09e291264aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/065a2649761e00d9a025e1efcf6ff09e291264aa/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ee00e6d9d0deb562602fc78181267032517d279", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ee00e6d9d0deb562602fc78181267032517d279", "html_url": "https://github.com/rust-lang/rust/commit/2ee00e6d9d0deb562602fc78181267032517d279"}], "stats": {"total": 327, "additions": 194, "deletions": 133}, "files": [{"sha": "260f869134974de52b066f3799040fcc32ce8d9d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065a2649761e00d9a025e1efcf6ff09e291264aa/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065a2649761e00d9a025e1efcf6ff09e291264aa/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=065a2649761e00d9a025e1efcf6ff09e291264aa", "patch": "@@ -980,6 +980,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"initial\"));\n             passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n+            passes.push_pass(box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"qualify-consts\"));\n             // And run everything.\n             passes.run_passes(tcx, &mut mir_map);"}, {"sha": "7b707b4adb69ac2aa2a7499a505948c5bb41565e", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065a2649761e00d9a025e1efcf6ff09e291264aa/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065a2649761e00d9a025e1efcf6ff09e291264aa/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=065a2649761e00d9a025e1efcf6ff09e291264aa", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub mod simplify_branches;\n pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;"}, {"sha": "57f9672e2a1f8a0c1526061ffda8b7aea2407ed4", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/065a2649761e00d9a025e1efcf6ff09e291264aa/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065a2649761e00d9a025e1efcf6ff09e291264aa/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=065a2649761e00d9a025e1efcf6ff09e291264aa", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A pass that simplifies branches when their condition is known.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::repr::*;\n+\n+use std::fmt;\n+\n+pub struct SimplifyBranches<'a> { label: &'a str }\n+\n+impl<'a> SimplifyBranches<'a> {\n+    pub fn new(label: &'a str) -> Self {\n+        SimplifyBranches { label: label }\n+    }\n+}\n+\n+impl<'l, 'tcx> MirPass<'tcx> for SimplifyBranches<'l> {\n+    fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n+        for block in mir.basic_blocks_mut() {\n+            let terminator = block.terminator_mut();\n+            terminator.kind = match terminator.kind {\n+                TerminatorKind::If { ref targets, cond: Operand::Constant(Constant {\n+                    literal: Literal::Value {\n+                        value: ConstVal::Bool(cond)\n+                    }, ..\n+                }) } => {\n+                    if cond {\n+                        TerminatorKind::Goto { target: targets.0 }\n+                    } else {\n+                        TerminatorKind::Goto { target: targets.1 }\n+                    }\n+                }\n+\n+                TerminatorKind::Assert { target, cond: Operand::Constant(Constant {\n+                    literal: Literal::Value {\n+                        value: ConstVal::Bool(cond)\n+                    }, ..\n+                }), expected, .. } if cond == expected => {\n+                    TerminatorKind::Goto { target: target }\n+                }\n+\n+                _ => continue\n+            };\n+        }\n+    }\n+}\n+\n+impl<'l> Pass for SimplifyBranches<'l> {\n+    fn name(&self) -> &str { \"simplify-branches\" }\n+    fn disambiguator<'a>(&'a self) -> Option<Box<fmt::Display+'a>> {\n+        Some(Box::new(self.label))\n+    }\n+}"}, {"sha": "21faf095b740d5c66badc563e292ec99d0e06062", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 128, "deletions": 133, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/065a2649761e00d9a025e1efcf6ff09e291264aa/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065a2649761e00d9a025e1efcf6ff09e291264aa/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=065a2649761e00d9a025e1efcf6ff09e291264aa", "patch": "@@ -34,14 +34,11 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::traversal;\n-\n use std::fmt;\n-use std::mem;\n \n pub struct SimplifyCfg<'a> { label: &'a str }\n \n@@ -53,9 +50,7 @@ impl<'a> SimplifyCfg<'a> {\n \n impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n     fn run_pass<'a>(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, _src: MirSource, mir: &mut Mir<'tcx>) {\n-        simplify_branches(mir);\n-        remove_dead_blocks(mir);\n-        merge_consecutive_blocks(mir);\n+        CfgSimplifier::new(mir).simplify();\n         remove_dead_blocks(mir);\n \n         // FIXME: Should probably be moved into some kind of pass manager\n@@ -70,155 +65,155 @@ impl<'l> Pass for SimplifyCfg<'l> {\n     }\n }\n \n-fn merge_consecutive_blocks(mir: &mut Mir) {\n-    let mut pred_count: IndexVec<_, _> =\n-        mir.predecessors().iter().map(|ps| ps.len()).collect();\n-\n-    loop {\n-        let mut changed = false;\n-        let mut seen = BitVector::new(mir.basic_blocks().len());\n-        let mut worklist = vec![START_BLOCK];\n-        while let Some(bb) = worklist.pop() {\n-            // Temporarily take ownership of the terminator we're modifying to keep borrowck happy\n-            let mut terminator = mir[bb].terminator.take().expect(\"invalid terminator state\");\n-\n-            // See if we can merge the target block into this one\n-            loop {\n-                let mut inner_change = false;\n-\n-                if let TerminatorKind::Goto { target } = terminator.kind {\n-                    // Don't bother trying to merge a block into itself\n-                    if target == bb {\n-                        break;\n-                    }\n-\n-                    let num_insts = mir[target].statements.len();\n-                    match mir[target].terminator().kind {\n-                        TerminatorKind::Goto { target: new_target } if num_insts == 0 => {\n-                            inner_change = true;\n-                            terminator.kind = TerminatorKind::Goto { target: new_target };\n-                            pred_count[target] -= 1;\n-                            pred_count[new_target] += 1;\n-                        }\n-                        _ if pred_count[target] == 1 => {\n-                            inner_change = true;\n-                            let mut stmts = Vec::new();\n-                            {\n-                                let target_data = &mut mir[target];\n-                                mem::swap(&mut stmts, &mut target_data.statements);\n-                                mem::swap(&mut terminator, target_data.terminator_mut());\n-                            }\n-\n-                            mir[bb].statements.append(&mut stmts);\n-                        }\n-                        _ => {}\n-                    };\n-                }\n-\n-                for target in terminator.successors_mut() {\n-                    let new_target = match final_target(mir, *target) {\n-                        Some(new_target) => new_target,\n-                        None if mir[bb].statements.is_empty() => bb,\n-                        None => continue\n-                    };\n-                    if *target != new_target {\n-                        inner_change = true;\n-                        pred_count[*target] -= 1;\n-                        pred_count[new_target] += 1;\n-                        *target = new_target;\n-                    }\n-                }\n-\n-                changed |= inner_change;\n-                if !inner_change {\n-                    break;\n-                }\n-            }\n+pub struct CfgSimplifier<'a, 'tcx: 'a> {\n+    basic_blocks: &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    pred_count: IndexVec<BasicBlock, u32>\n+}\n \n-            mir[bb].terminator = Some(terminator);\n+impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n+    fn new(mir: &'a mut Mir<'tcx>) -> Self {\n+        let mut pred_count = IndexVec::from_elem(0u32, mir.basic_blocks());\n \n-            for succ in mir[bb].terminator().successors().iter() {\n-                if seen.insert(succ.index()) {\n-                    worklist.push(*succ);\n+        // we can't use mir.predecessors() here because that counts\n+        // dead blocks, which we don't want to.\n+        for (_, data) in traversal::preorder(mir) {\n+            if let Some(ref term) = data.terminator {\n+                for &tgt in term.successors().iter() {\n+                    pred_count[tgt] += 1;\n                 }\n             }\n         }\n \n-        if !changed {\n-            break;\n+        let basic_blocks = mir.basic_blocks_mut();\n+\n+        CfgSimplifier {\n+            basic_blocks: basic_blocks,\n+            pred_count: pred_count\n         }\n     }\n-}\n \n-// Find the target at the end of the jump chain, return None if there is a loop\n-fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> {\n-    // Keep track of already seen blocks to detect loops\n-    let mut seen: Vec<BasicBlock> = Vec::with_capacity(8);\n-\n-    while mir[target].statements.is_empty() {\n-        // NB -- terminator may have been swapped with `None` in\n-        // merge_consecutive_blocks, in which case we have a cycle and just want\n-        // to stop\n-        match mir[target].terminator {\n-            Some(Terminator { kind: TerminatorKind::Goto { target: next }, .. }) =>  {\n-                if seen.contains(&next) {\n-                    return None;\n+    fn simplify(mut self) {\n+        loop {\n+            let mut changed = false;\n+\n+            for bb in (0..self.basic_blocks.len()).map(BasicBlock::new) {\n+                if self.pred_count[bb] == 0 {\n+                    continue\n+                }\n+\n+                debug!(\"simplifying {:?}\", bb);\n+\n+                let mut terminator = self.basic_blocks[bb].terminator.take()\n+                    .expect(\"invalid terminator state\");\n+\n+                for successor in terminator.successors_mut() {\n+                    self.collapse_goto_chain(successor, &mut changed);\n                 }\n-                seen.push(next);\n-                target = next;\n+\n+                let mut new_stmts = vec![];\n+                let mut inner_changed = true;\n+                while inner_changed {\n+                    inner_changed = false;\n+                    inner_changed |= self.simplify_branch(&mut terminator);\n+                    inner_changed |= self.merge_successor(&mut new_stmts, &mut terminator);\n+                    changed |= inner_changed;\n+                }\n+\n+                self.basic_blocks[bb].statements.extend(new_stmts);\n+                self.basic_blocks[bb].terminator = Some(terminator);\n+\n+                changed |= inner_changed;\n             }\n-            _ => break\n+\n+            if !changed { break }\n         }\n     }\n \n-    Some(target)\n-}\n+    // Collapse a goto chain starting from `start`\n+    fn collapse_goto_chain(&mut self, start: &mut BasicBlock, changed: &mut bool) {\n+        let mut terminator = match self.basic_blocks[*start] {\n+            BasicBlockData {\n+                ref statements,\n+                terminator: ref mut terminator @ Some(Terminator {\n+                    kind: TerminatorKind::Goto { .. }, ..\n+                }), ..\n+            } if statements.is_empty() => terminator.take(),\n+            // if `terminator` is None, this means we are in a loop. In that\n+            // case, let all the loop collapse to its entry.\n+            _ => return\n+        };\n+\n+        let target = match terminator {\n+            Some(Terminator { kind: TerminatorKind::Goto { ref mut target }, .. }) => {\n+                self.collapse_goto_chain(target, changed);\n+                *target\n+            }\n+            _ => unreachable!()\n+        };\n+        self.basic_blocks[*start].terminator = terminator;\n \n-fn simplify_branches(mir: &mut Mir) {\n-    loop {\n-        let mut changed = false;\n+        debug!(\"collapsing goto chain from {:?} to {:?}\", *start, target);\n \n-        for (_, basic_block) in mir.basic_blocks_mut().iter_enumerated_mut() {\n-            let mut terminator = basic_block.terminator_mut();\n-            terminator.kind = match terminator.kind {\n-                TerminatorKind::If { ref targets, .. } if targets.0 == targets.1 => {\n-                    changed = true;\n-                    TerminatorKind::Goto { target: targets.0 }\n-                }\n+        *changed |= *start != target;\n+        self.pred_count[target] += 1;\n+        self.pred_count[*start] -= 1;\n+        *start = target;\n+    }\n \n-                TerminatorKind::If { ref targets, cond: Operand::Constant(Constant {\n-                    literal: Literal::Value {\n-                        value: ConstVal::Bool(cond)\n-                    }, ..\n-                }) } => {\n-                    changed = true;\n-                    if cond {\n-                        TerminatorKind::Goto { target: targets.0 }\n-                    } else {\n-                        TerminatorKind::Goto { target: targets.1 }\n-                    }\n-                }\n+    // merge a block with 1 `goto` predecessor to its parent\n+    fn merge_successor(&mut self,\n+                       new_stmts: &mut Vec<Statement<'tcx>>,\n+                       terminator: &mut Terminator<'tcx>)\n+                       -> bool\n+    {\n+        let target = match terminator.kind {\n+            TerminatorKind::Goto { target }\n+                if self.pred_count[target] == 1\n+                => target,\n+            _ => return false\n+        };\n+\n+        debug!(\"merging block {:?} into {:?}\", target, terminator);\n+        *terminator = match self.basic_blocks[target].terminator.take() {\n+            Some(terminator) => terminator,\n+            None => {\n+                // unreachable loop - this should not be possible, as we\n+                // don't strand blocks, but handle it correctly.\n+                return false\n+            }\n+        };\n+        new_stmts.extend(self.basic_blocks[target].statements.drain(..));\n+        self.pred_count[target] = 0;\n \n-                TerminatorKind::Assert { target, cond: Operand::Constant(Constant {\n-                    literal: Literal::Value {\n-                        value: ConstVal::Bool(cond)\n-                    }, ..\n-                }), expected, .. } if cond == expected => {\n-                    changed = true;\n-                    TerminatorKind::Goto { target: target }\n-                }\n+        true\n+    }\n \n-                TerminatorKind::SwitchInt { ref targets, .. } if targets.len() == 1 => {\n-                    changed = true;\n-                    TerminatorKind::Goto { target: targets[0] }\n+    // turn a branch with all successors identical to a goto\n+    fn simplify_branch(&mut self, terminator: &mut Terminator<'tcx>) -> bool {\n+        match terminator.kind {\n+            TerminatorKind::If { .. } |\n+            TerminatorKind::Switch { .. } |\n+            TerminatorKind::SwitchInt { .. } => {},\n+            _ => return false\n+        };\n+\n+        let first_succ = {\n+            let successors = terminator.successors();\n+            if let Some(&first_succ) = terminator.successors().get(0) {\n+                if successors.iter().all(|s| *s == first_succ) {\n+                    self.pred_count[first_succ] -= (successors.len()-1) as u32;\n+                    first_succ\n+                } else {\n+                    return false\n                 }\n-                _ => continue\n+            } else {\n+                return false\n             }\n-        }\n+        };\n \n-        if !changed {\n-            break;\n-        }\n+        debug!(\"simplifying branch {:?}\", terminator);\n+        terminator.kind = TerminatorKind::Goto { target: first_succ };\n+        true\n     }\n }\n "}]}