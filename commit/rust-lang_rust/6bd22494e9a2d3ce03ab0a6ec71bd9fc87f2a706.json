{"sha": "6bd22494e9a2d3ce03ab0a6ec71bd9fc87f2a706", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZDIyNDk0ZTlhMmQzY2UwM2FiMGE2ZWM3MWJkOWZjODdmMmE3MDY=", "commit": {"author": {"name": "Guillaume Pinot", "email": "texitoi@texitoi.eu", "date": "2013-11-28T19:46:59Z"}, "committer": {"name": "Guillaume Pinot", "email": "texitoi@texitoi.eu", "date": "2013-11-28T19:46:59Z"}, "message": "shootout-spectralnorm resurection with parallelization", "tree": {"sha": "704b9001802c79202616cd3e8adefd61feb1b506", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/704b9001802c79202616cd3e8adefd61feb1b506"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bd22494e9a2d3ce03ab0a6ec71bd9fc87f2a706", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd22494e9a2d3ce03ab0a6ec71bd9fc87f2a706", "html_url": "https://github.com/rust-lang/rust/commit/6bd22494e9a2d3ce03ab0a6ec71bd9fc87f2a706", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bd22494e9a2d3ce03ab0a6ec71bd9fc87f2a706/comments", "author": {"login": "TeXitoi", "id": 5787066, "node_id": "MDQ6VXNlcjU3ODcwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5787066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TeXitoi", "html_url": "https://github.com/TeXitoi", "followers_url": "https://api.github.com/users/TeXitoi/followers", "following_url": "https://api.github.com/users/TeXitoi/following{/other_user}", "gists_url": "https://api.github.com/users/TeXitoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TeXitoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TeXitoi/subscriptions", "organizations_url": "https://api.github.com/users/TeXitoi/orgs", "repos_url": "https://api.github.com/users/TeXitoi/repos", "events_url": "https://api.github.com/users/TeXitoi/events{/privacy}", "received_events_url": "https://api.github.com/users/TeXitoi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TeXitoi", "id": 5787066, "node_id": "MDQ6VXNlcjU3ODcwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5787066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TeXitoi", "html_url": "https://github.com/TeXitoi", "followers_url": "https://api.github.com/users/TeXitoi/followers", "following_url": "https://api.github.com/users/TeXitoi/following{/other_user}", "gists_url": "https://api.github.com/users/TeXitoi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TeXitoi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TeXitoi/subscriptions", "organizations_url": "https://api.github.com/users/TeXitoi/orgs", "repos_url": "https://api.github.com/users/TeXitoi/repos", "events_url": "https://api.github.com/users/TeXitoi/events{/privacy}", "received_events_url": "https://api.github.com/users/TeXitoi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "859c3baf64c167730f4214a736f72a5e2e86d7d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/859c3baf64c167730f4214a736f72a5e2e86d7d9", "html_url": "https://github.com/rust-lang/rust/commit/859c3baf64c167730f4214a736f72a5e2e86d7d9"}], "stats": {"total": 97, "additions": 66, "deletions": 31}, "files": [{"sha": "87cd01f9aad2ef8698c493050722b7c9be0bb2bd", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 66, "deletions": 31, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6bd22494e9a2d3ce03ab0a6ec71bd9fc87f2a706/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bd22494e9a2d3ce03ab0a6ec71bd9fc87f2a706/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=6bd22494e9a2d3ce03ab0a6ec71bd9fc87f2a706", "patch": "@@ -8,59 +8,94 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test reading from os::args()[1] - bogus!\n+extern mod extra;\n \n use std::from_str::FromStr;\n+use std::iter::count;\n+use std::num::min;\n use std::os;\n-use std::vec;\n+use std::vec::from_elem;\n+use extra::arc::Arc;\n+use extra::arc::RWArc;\n \n-#[inline]\n-fn A(i: i32, j: i32) -> i32 {\n-    (i+j) * (i+j+1) / 2 + i + 1\n+fn A(i: uint, j: uint) -> f64 {\n+    ((i + j) * (i + j + 1) / 2 + i + 1) as f64\n }\n \n fn dot(v: &[f64], u: &[f64]) -> f64 {\n     let mut sum = 0.0;\n-    for (i, &v_i) in v.iter().enumerate() {\n-        sum += v_i * u[i];\n+    for (&v_i, &u_i) in v.iter().zip(u.iter()) {\n+        sum += v_i * u_i;\n     }\n     sum\n }\n \n-fn mult_Av(v: &mut [f64], out: &mut [f64]) {\n-    for (i, out_i) in out.mut_iter().enumerate() {\n-        let mut sum = 0.0;\n-        for (j, &v_j) in v.mut_iter().enumerate() {\n-            sum += v_j / (A(i as i32, j as i32) as f64);\n+fn mult(v: RWArc<~[f64]>, out: RWArc<~[f64]>, f: fn(&~[f64], uint) -> f64) {\n+    let wait = Arc::new(());\n+    let len = out.read(|out| out.len());\n+    let chunk = len / 100 + 1;\n+    for chk in count(0, chunk) {\n+        if chk >= len {break;}\n+        let w = wait.clone();\n+        let v = v.clone();\n+        let out = out.clone();\n+        do spawn {\n+            for i in range(chk, min(len, chk + chunk)) {\n+                let val = v.read(|v| f(v, i));\n+                out.write(|out| out[i] = val);\n+            }\n+            let _ = w;\n         }\n-        *out_i = sum;\n     }\n+    let _ = wait.unwrap();\n }\n \n-fn mult_Atv(v: &mut [f64], out: &mut [f64]) {\n-    for (i, out_i) in out.mut_iter().enumerate() {\n-        let mut sum = 0.0;\n-        for (j, &v_j) in v.mut_iter().enumerate() {\n-            sum += v_j / (A(j as i32, i as i32) as f64);\n-        }\n-        *out_i = sum;\n+fn mult_Av_impl(v: &~[f64], i: uint) -> f64 {\n+    let mut sum = 0.;\n+    for (j, &v_j) in v.iter().enumerate() {\n+        sum += v_j / A(i, j);\n     }\n+    sum\n+}\n+\n+fn mult_Av(v: RWArc<~[f64]>, out: RWArc<~[f64]>) {\n+    mult(v, out, mult_Av_impl);\n }\n \n-fn mult_AtAv(v: &mut [f64], out: &mut [f64], tmp: &mut [f64]) {\n-    mult_Av(v, tmp);\n+fn mult_Atv_impl(v: &~[f64], i: uint) -> f64 {\n+    let mut sum = 0.;\n+    for (j, &v_j) in v.iter().enumerate() {\n+        sum += v_j / A(j, i);\n+    }\n+    sum\n+}\n+\n+fn mult_Atv(v: RWArc<~[f64]>, out: RWArc<~[f64]>) {\n+    mult(v, out, mult_Atv_impl);\n+}\n+\n+fn mult_AtAv(v: RWArc<~[f64]>, out: RWArc<~[f64]>, tmp: RWArc<~[f64]>) {\n+    mult_Av(v, tmp.clone());\n     mult_Atv(tmp, out);\n }\n \n fn main() {\n-    let n: uint = FromStr::from_str(os::args()[1]).unwrap();\n-    let mut u = vec::from_elem(n, 1f64);\n-    let mut v = u.clone();\n-    let mut tmp = u.clone();\n-    for _ in range(0, 8u) {\n-        mult_AtAv(u, v, tmp);\n-        mult_AtAv(v, u, tmp);\n+    let args = os::args();\n+    let n = if os::getenv(\"RUST_BENCH\").is_some() {\n+        5500\n+    } else if args.len() < 2 {\n+        2000\n+    } else {\n+        FromStr::from_str(args[1]).unwrap()\n+    };\n+    let u = RWArc::new(from_elem(n, 1.));\n+    let v = RWArc::new(from_elem(n, 1.));\n+    let tmp = RWArc::new(from_elem(n, 1.));\n+    for _ in range(0, 10) {\n+        mult_AtAv(u.clone(), v.clone(), tmp.clone());\n+        mult_AtAv(v.clone(), u.clone(), tmp.clone());\n     }\n-\n-    println!(\"{:.9f}\", (dot(u,v) / dot(v,v)).sqrt() as float);\n+    let u = u.unwrap();\n+    let v = v.unwrap();\n+    println!(\"{:.9f}\", (dot(u,v) / dot(v,v)).sqrt());\n }"}]}