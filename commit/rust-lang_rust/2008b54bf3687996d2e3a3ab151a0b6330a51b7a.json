{"sha": "2008b54bf3687996d2e3a3ab151a0b6330a51b7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMDhiNTRiZjM2ODc5OTZkMmUzYTNhYjE1MWEwYjYzMzBhNTFiN2E=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-03T02:18:12Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-03T05:35:30Z"}, "message": "metadata: Reordered integral tags in the ascending order.\n\nAlso clarified the mysterious `_next_int` method.", "tree": {"sha": "f501f257c519e947f7072f40dd225e133cc4e310", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f501f257c519e947f7072f40dd225e133cc4e310"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2008b54bf3687996d2e3a3ab151a0b6330a51b7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2008b54bf3687996d2e3a3ab151a0b6330a51b7a", "html_url": "https://github.com/rust-lang/rust/commit/2008b54bf3687996d2e3a3ab151a0b6330a51b7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2008b54bf3687996d2e3a3ab151a0b6330a51b7a/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef3c7af172de035f77732f8444ca073154b10307", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3c7af172de035f77732f8444ca073154b10307", "html_url": "https://github.com/rust-lang/rust/commit/ef3c7af172de035f77732f8444ca073154b10307"}], "stats": {"total": 106, "additions": 55, "deletions": 51}, "files": [{"sha": "844d097bdafa95f32b2c166ed25ee56e5d2a6306", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2008b54bf3687996d2e3a3ab151a0b6330a51b7a/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2008b54bf3687996d2e3a3ab151a0b6330a51b7a/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=2008b54bf3687996d2e3a3ab151a0b6330a51b7a", "patch": "@@ -55,29 +55,29 @@\n //!\n //! Predefined tags with an implicit length:\n //!\n-//! - `U64` (`00`): 8-byte big endian unsigned integer.\n-//! - `U32` (`01`): 4-byte big endian unsigned integer.\n-//! - `U16` (`02`): 2-byte big endian unsigned integer.\n-//! - `U8`  (`03`): 1-byte unsigned integer.\n+//! - `U8`  (`00`): 1-byte unsigned integer.\n+//! - `U16` (`01`): 2-byte big endian unsigned integer.\n+//! - `U32` (`02`): 4-byte big endian unsigned integer.\n+//! - `U64` (`03`): 8-byte big endian unsigned integer.\n //!   Any of `U*` tags can be used to encode primitive unsigned integer types,\n //!   as long as it is no greater than the actual size.\n //!   For example, `u8` can only be represented via the `U8` tag.\n //!\n-//! - `I64` (`04`): 8-byte big endian signed integer.\n-//! - `I32` (`05`): 4-byte big endian signed integer.\n-//! - `I16` (`06`): 2-byte big endian signed integer.\n-//! - `I8`  (`07`): 1-byte signed integer.\n+//! - `I8`  (`04`): 1-byte signed integer.\n+//! - `I16` (`05`): 2-byte big endian signed integer.\n+//! - `I32` (`06`): 4-byte big endian signed integer.\n+//! - `I64` (`07`): 8-byte big endian signed integer.\n //!   Similar to `U*` tags. Always uses two's complement encoding.\n //!\n //! - `Bool` (`08`): 1-byte boolean value, `00` for false and `01` for true.\n //!\n //! - `Char` (`09`): 4-byte big endian Unicode scalar value.\n //!   Surrogate pairs or out-of-bound values are invalid.\n //!\n-//! - `F64` (`0a`): 8-byte big endian unsigned integer representing\n-//!   IEEE 754 binary64 floating-point format.\n-//! - `F32` (`0b`): 4-byte big endian unsigned integer representing\n+//! - `F32` (`0a`): 4-byte big endian unsigned integer representing\n //!   IEEE 754 binary32 floating-point format.\n+//! - `F64` (`0b`): 8-byte big endian unsigned integer representing\n+//!   IEEE 754 binary64 floating-point format.\n //!\n //! - `Sub8`  (`0c`): 1-byte unsigned integer for supplementary information.\n //! - `Sub32` (`0d`): 4-byte unsigned integer for supplementary information.\n@@ -87,25 +87,25 @@\n //!\n //! Predefined tags with an explicit length:\n //!\n-//! - `Str` (`0e`): A UTF-8-encoded string.\n+//! - `Str` (`10`): A UTF-8-encoded string.\n //!\n-//! - `Enum` (`0f`): An enum.\n+//! - `Enum` (`11`): An enum.\n //!   The first subdocument should be `Sub*` tags with a variant ID.\n //!   Subsequent subdocuments, if any, encode variant arguments.\n //!\n-//! - `Vec` (`10`): A vector (sequence).\n-//! - `VecElt` (`11`): A vector element.\n+//! - `Vec` (`12`): A vector (sequence).\n+//! - `VecElt` (`13`): A vector element.\n //!   The first subdocument should be `Sub*` tags with the number of elements.\n //!   Subsequent subdocuments should be `VecElt` tag per each element.\n //!\n-//! - `Map` (`12`): A map (associated array).\n-//! - `MapKey` (`13`): A key part of the map entry.\n-//! - `MapVal` (`14`): A value part of the map entry.\n+//! - `Map` (`14`): A map (associated array).\n+//! - `MapKey` (`15`): A key part of the map entry.\n+//! - `MapVal` (`16`): A value part of the map entry.\n //!   The first subdocument should be `Sub*` tags with the number of entries.\n //!   Subsequent subdocuments should be an alternating sequence of\n //!   `MapKey` and `MapVal` tags per each entry.\n //!\n-//! - `Opaque` (`15`): An opaque, custom-format tag.\n+//! - `Opaque` (`17`): An opaque, custom-format tag.\n //!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n //!   Rustc typically uses this to encode type informations.\n //!\n@@ -183,40 +183,41 @@ pub enum EbmlEncoderTag {\n     // tags 00..1f are reserved for auto-serialization.\n     // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n \n-    EsU64      = 0x00, // + 8 bytes\n-    EsU32      = 0x01, // + 4 bytes\n-    EsU16      = 0x02, // + 2 bytes\n-    EsU8       = 0x03, // + 1 byte\n-    EsI64      = 0x04, // + 8 bytes\n-    EsI32      = 0x05, // + 4 bytes\n-    EsI16      = 0x06, // + 2 bytes\n-    EsI8       = 0x07, // + 1 byte\n+    EsU8       = 0x00, // + 1 byte\n+    EsU16      = 0x01, // + 2 bytes\n+    EsU32      = 0x02, // + 4 bytes\n+    EsU64      = 0x03, // + 8 bytes\n+    EsI8       = 0x04, // + 1 byte\n+    EsI16      = 0x05, // + 2 bytes\n+    EsI32      = 0x06, // + 4 bytes\n+    EsI64      = 0x07, // + 8 bytes\n     EsBool     = 0x08, // + 1 byte\n     EsChar     = 0x09, // + 4 bytes\n-    EsF64      = 0x0a, // + 8 bytes\n-    EsF32      = 0x0b, // + 4 bytes\n+    EsF32      = 0x0a, // + 4 bytes\n+    EsF64      = 0x0b, // + 8 bytes\n     EsSub8     = 0x0c, // + 1 byte\n     EsSub32    = 0x0d, // + 4 bytes\n-\n-    EsStr      = 0x0e,\n-    EsEnum     = 0x0f, // encodes the variant id as the first EsSub*\n-    EsVec      = 0x10, // encodes the # of elements as the first EsSub*\n-    EsVecElt   = 0x11,\n-    EsMap      = 0x12, // encodes the # of pairs as the first EsSub*\n-    EsMapKey   = 0x13,\n-    EsMapVal   = 0x14,\n-    EsOpaque   = 0x15,\n+    // 0x0e and 0x0f are reserved\n+\n+    EsStr      = 0x10,\n+    EsEnum     = 0x11, // encodes the variant id as the first EsSub*\n+    EsVec      = 0x12, // encodes the # of elements as the first EsSub*\n+    EsVecElt   = 0x13,\n+    EsMap      = 0x14, // encodes the # of pairs as the first EsSub*\n+    EsMapKey   = 0x15,\n+    EsMapVal   = 0x16,\n+    EsOpaque   = 0x17,\n }\n \n const NUM_TAGS: uint = 0x1000;\n const NUM_IMPLICIT_TAGS: uint = 0x0e;\n \n static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n-    8, 4, 2, 1, // EsU*\n-    8, 4, 2, 1, // ESI*\n+    1, 2, 4, 8, // EsU*\n+    1, 2, 4, 8, // ESI*\n     1, // EsBool\n     4, // EsChar\n-    8, 4, // EsF*\n+    4, 8, // EsF*\n     1, 4, // EsSub*\n ];\n \n@@ -554,7 +555,10 @@ pub mod reader {\n             Ok(r)\n         }\n \n-        // variable-length unsigned integer with different tags\n+        // variable-length unsigned integer with different tags.\n+        // `first_tag` should be a tag for u8 or i8.\n+        // `last_tag` should be the largest allowed integer tag with the matching signedness.\n+        // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n         fn _next_int(&mut self,\n                      first_tag: EbmlEncoderTag,\n                      last_tag: EbmlEncoderTag) -> DecodeResult<u64> {\n@@ -566,7 +570,7 @@ pub mod reader {\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n             let r = if first_tag as uint <= r_tag && r_tag <= last_tag as uint {\n-                match last_tag as uint - r_tag {\n+                match r_tag - first_tag as uint {\n                     0 => doc_as_u8(r_doc) as u64,\n                     1 => doc_as_u16(r_doc) as u64,\n                     2 => doc_as_u32(r_doc) as u64,\n@@ -608,25 +612,25 @@ pub mod reader {\n         type Error = Error;\n         fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n \n-        fn read_u64(&mut self) -> DecodeResult<u64> { self._next_int(EsU64, EsU8) }\n-        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(try!(self._next_int(EsU32, EsU8)) as u32) }\n-        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(try!(self._next_int(EsU16, EsU8)) as u16) }\n+        fn read_u64(&mut self) -> DecodeResult<u64> { self._next_int(EsU8, EsU64) }\n+        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(try!(self._next_int(EsU8, EsU32)) as u32) }\n+        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(try!(self._next_int(EsU8, EsU16)) as u16) }\n         fn read_u8(&mut self) -> DecodeResult<u8> { Ok(doc_as_u8(try!(self.next_doc(EsU8)))) }\n         fn read_uint(&mut self) -> DecodeResult<uint> {\n-            let v = try!(self._next_int(EsU64, EsU8));\n+            let v = try!(self._next_int(EsU8, EsU64));\n             if v > (::std::usize::MAX as u64) {\n                 Err(IntTooBig(v as uint))\n             } else {\n                 Ok(v as uint)\n             }\n         }\n \n-        fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self._next_int(EsI64, EsI8)) as i64) }\n-        fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self._next_int(EsI32, EsI8)) as i32) }\n-        fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self._next_int(EsI16, EsI8)) as i16) }\n+        fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self._next_int(EsI8, EsI64)) as i64) }\n+        fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self._next_int(EsI8, EsI32)) as i32) }\n+        fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self._next_int(EsI8, EsI16)) as i16) }\n         fn read_i8(&mut self) -> DecodeResult<i8> { Ok(doc_as_u8(try!(self.next_doc(EsI8))) as i8) }\n         fn read_int(&mut self) -> DecodeResult<int> {\n-            let v = try!(self._next_int(EsI64, EsI8)) as i64;\n+            let v = try!(self._next_int(EsI8, EsI64)) as i64;\n             if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n                 Err(IntTooBig(v as uint))"}]}