{"sha": "d3258448045d672b0cd273cb1ea9381b470c2ca2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMjU4NDQ4MDQ1ZDY3MmIwY2QyNzNjYjFlYTkzODFiNDcwYzJjYTI=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-28T15:50:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Replaced Codegen field access by trait method", "tree": {"sha": "8c4b20fa7ddb041ede6b9040ee11eeb91f721980", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4b20fa7ddb041ede6b9040ee11eeb91f721980"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3258448045d672b0cd273cb1ea9381b470c2ca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3258448045d672b0cd273cb1ea9381b470c2ca2", "html_url": "https://github.com/rust-lang/rust/commit/d3258448045d672b0cd273cb1ea9381b470c2ca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3258448045d672b0cd273cb1ea9381b470c2ca2/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8714e6bce6b04482723f0b735879533c82c114fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8714e6bce6b04482723f0b735879533c82c114fa", "html_url": "https://github.com/rust-lang/rust/commit/8714e6bce6b04482723f0b735879533c82c114fa"}], "stats": {"total": 494, "additions": 247, "deletions": 247}, "files": [{"sha": "9826976d8195b838598df40ee1a11242a46753fd", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -202,7 +202,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         if self.is_ignore() {\n             return;\n         }\n-        let cx = bx.cx;\n+        let cx = bx.cx();\n         if self.is_sized_indirect() {\n             OperandValue::Ref(val, None, self.layout.align).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n@@ -757,7 +757,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             // by the LLVM verifier.\n             if let layout::Int(..) = scalar.value {\n                 if !scalar.is_bool() {\n-                    let range = scalar.valid_range_exclusive(bx.cx);\n+                    let range = scalar.valid_range_exclusive(bx.cx());\n                     if range.start != range.end {\n                         bx.range_metadata(callsite, range);\n                     }"}, {"sha": "028596950f5b862732ea4dfb7609d9de24c0f8a4", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -44,7 +44,7 @@ pub fn codegen_inline_asm(\n         if out.is_indirect {\n             indirect_outputs.push(place.load(bx).immediate());\n         } else {\n-            output_types.push(place.layout.llvm_type(bx.cx));\n+            output_types.push(place.layout.llvm_type(bx.cx()));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -76,9 +76,9 @@ pub fn codegen_inline_asm(\n     // Depending on how many outputs we have, the return type is different\n     let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n-        0 => Type::void(bx.cx),\n+        0 => Type::void(bx.cx()),\n         1 => output_types[0],\n-        _ => Type::struct_(bx.cx, &output_types, false)\n+        _ => Type::struct_(bx.cx(), &output_types, false)\n     };\n \n     let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n@@ -108,13 +108,13 @@ pub fn codegen_inline_asm(\n     // back to source locations.  See #17552.\n     unsafe {\n         let key = \"srcloc\";\n-        let kind = llvm::LLVMGetMDKindIDInContext(bx.cx.llcx,\n+        let kind = llvm::LLVMGetMDKindIDInContext(bx.cx().llcx,\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: &'ll Value = CodegenCx::c_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n+        let val: &'ll Value = CodegenCx::c_i32(bx.cx(), ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n-            llvm::LLVMMDNodeInContext(bx.cx.llcx, &val, 1));\n+            llvm::LLVMMDNodeInContext(bx.cx().llcx, &val, 1));\n     }\n \n     return true;"}, {"sha": "9fcb7bfd5068882ed4198c3daa1f218298826091", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -233,40 +233,40 @@ pub fn unsize_thin_ptr(\n          &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bx.cx.type_is_sized(a));\n-            let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n+            assert!(bx.cx().type_is_sized(a));\n+            let ptr_ty = bx.cx().layout_of(b).llvm_type(bx.cx()).ptr_to();\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bx.cx.type_is_sized(a));\n-            let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n+            assert!(bx.cx().type_is_sized(a));\n+            let ptr_ty = bx.cx().layout_of(b).llvm_type(bx.cx()).ptr_to();\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            let src_layout = bx.cx.layout_of(src_ty);\n-            let dst_layout = bx.cx.layout_of(dst_ty);\n+            let src_layout = bx.cx().layout_of(src_ty);\n+            let dst_layout = bx.cx().layout_of(dst_ty);\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n-                let src_f = src_layout.field(bx.cx, i);\n+                let src_f = src_layout.field(bx.cx(), i);\n                 assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n                 assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n                 if src_f.is_zst() {\n                     continue;\n                 }\n                 assert_eq!(src_layout.size, src_f.size);\n \n-                let dst_f = dst_layout.field(bx.cx, i);\n+                let dst_f = dst_layout.field(bx.cx(), i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n                 result = Some(unsize_thin_ptr(bx, src, src_f.ty, dst_f.ty));\n             }\n             let (lldata, llextra) = result.unwrap();\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            (bx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bx.cx, 0, true)),\n-             bx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bx.cx, 1, true)))\n+            (bx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bx.cx(), 0, true)),\n+             bx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bx.cx(), 1, true)))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n@@ -288,8 +288,8 @@ pub fn coerce_unsized_into(\n                 // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n                 // the types match up.\n-                let thin_ptr = dst.layout.field(bx.cx, abi::FAT_PTR_ADDR);\n-                (bx.pointercast(base, thin_ptr.llvm_type(bx.cx)), info)\n+                let thin_ptr = dst.layout.field(bx.cx(), abi::FAT_PTR_ADDR);\n+                (bx.pointercast(base, thin_ptr.llvm_type(bx.cx())), info)\n             }\n             OperandValue::Immediate(base) => {\n                 unsize_thin_ptr(bx, base, src_ty, dst_ty)\n@@ -384,7 +384,7 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n }\n \n pub fn call_assume(bx: &Builder<'_, 'll, '_>, val: &'ll Value) {\n-    let assume_intrinsic = bx.cx.get_intrinsic(\"llvm.assume\");\n+    let assume_intrinsic = bx.cx().get_intrinsic(\"llvm.assume\");\n     bx.call(assume_intrinsic, &[val], None);\n }\n \n@@ -416,7 +416,7 @@ pub fn to_immediate_scalar(\n     scalar: &layout::Scalar,\n ) -> &'ll Value {\n     if scalar.is_bool() {\n-        return bx.trunc(val, Type::i1(bx.cx));\n+        return bx.trunc(val, Type::i1(bx.cx()));\n     }\n     val\n }\n@@ -470,10 +470,10 @@ pub fn call_memset(\n     align: &'ll Value,\n     volatile: bool,\n ) -> &'ll Value {\n-    let ptr_width = &bx.cx.sess().target.target.target_pointer_width;\n+    let ptr_width = &bx.cx().sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-    let llintrinsicfn = bx.cx.get_intrinsic(&intrinsic_key);\n-    let volatile = CodegenCx::c_bool(bx.cx, volatile);\n+    let llintrinsicfn = bx.cx().get_intrinsic(&intrinsic_key);\n+    let volatile = CodegenCx::c_bool(bx.cx(), volatile);\n     bx.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n "}, {"sha": "00bc9adf5c39973e17136e339e3ae5ef09a57a30", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -193,14 +193,14 @@ impl Funclet<'ll> {\n     }\n }\n \n-impl Backend for CodegenCx<'ll, 'tcx, &'ll Value> {\n+impl Backend for CodegenCx<'ll, 'tcx> {\n     type Value = &'ll Value;\n     type BasicBlock = &'ll BasicBlock;\n     type Type = &'ll Type;\n     type Context = &'ll llvm::Context;\n }\n \n-impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx, &'ll Value> {\n+impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     fn val_ty(v: &'ll Value) -> &'ll Type {\n         unsafe {\n             llvm::LLVMTypeOf(v)"}, {"sha": "13392a64c7b4935d2f9876fc22401befe8af5844", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -26,11 +26,11 @@ use syntax::attr;\n /// Inserts a side-effect free instruction sequence that makes sure that the\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &Builder) {\n-    if needs_gdb_debug_scripts_section(bx.cx) {\n-        let gdb_debug_scripts_section = get_or_insert_gdb_debug_scripts_section_global(bx.cx);\n+    if needs_gdb_debug_scripts_section(bx.cx()) {\n+        let gdb_debug_scripts_section = get_or_insert_gdb_debug_scripts_section_global(bx.cx());\n         // Load just the first byte as that's all that's necessary to force\n         // LLVM to keep around the reference to the global.\n-        let indices = [CodegenCx::c_i32(bx.cx, 0), CodegenCx::c_i32(bx.cx, 0)];\n+        let indices = [CodegenCx::c_i32(bx.cx(), 0), CodegenCx::c_i32(bx.cx(), 0)];\n         let element = bx.inbounds_gep(gdb_debug_scripts_section, &indices);\n         let volative_load_instruction = bx.volatile_load(element);\n         unsafe {"}, {"sha": "0ee51f1956b8bb1defa65c29a3de70322fd4470e", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -494,7 +494,7 @@ pub fn declare_local(\n     span: Span,\n ) {\n     assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n-    let cx = bx.cx;\n+    let cx = bx.cx();\n \n     let file = span_start(cx, span).file;\n     let file_metadata = file_metadata(cx,"}, {"sha": "96d22ea1d15bc7d5a22488eaee24b095243d9c13", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -42,7 +42,7 @@ pub fn set_source_location(\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n         debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n-        let loc = span_start(bx.cx, span);\n+        let loc = span_start(bx.cx(), span);\n         InternalDebugLocation::new(scope.unwrap(), loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n@@ -88,7 +88,7 @@ pub fn set_debug_location(\n             // For MSVC, set the column number to zero.\n             // Otherwise, emit it. This mimics clang behaviour.\n             // See discussion in https://github.com/rust-lang/rust/issues/42921\n-            let col_used =  if bx.cx.sess().target.target.options.is_like_msvc {\n+            let col_used =  if bx.cx().sess().target.target.options.is_like_msvc {\n                 UNKNOWN_COLUMN_NUMBER\n             } else {\n                 col as c_uint\n@@ -97,7 +97,7 @@ pub fn set_debug_location(\n \n             unsafe {\n                 Some(llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                    debug_context(bx.cx).llcontext,\n+                    debug_context(bx.cx()).llcontext,\n                     line as c_uint,\n                     col_used,\n                     scope,"}, {"sha": "b2d2e3798986610f0e34ac55938df812d57c8710", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -30,12 +30,12 @@ pub fn size_and_align_of_dst(\n ) -> (&'ll Value, &'ll Value) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, info);\n-    if bx.cx.type_is_sized(t) {\n-        let (size, align) = bx.cx.size_and_align_of(t);\n+    if bx.cx().type_is_sized(t) {\n+        let (size, align) = bx.cx().size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, info, size, align);\n-        let size = CodegenCx::c_usize(bx.cx, size.bytes());\n-        let align = CodegenCx::c_usize(bx.cx, align.abi());\n+        let size = CodegenCx::c_usize(bx.cx(), size.bytes());\n+        let align = CodegenCx::c_usize(bx.cx(), align.abi());\n         return (size, align);\n     }\n     match t.sty {\n@@ -48,12 +48,12 @@ pub fn size_and_align_of_dst(\n             let unit = t.sequence_element_type(bx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let (size, align) = bx.cx.size_and_align_of(unit);\n-            (bx.mul(info.unwrap(), CodegenCx::c_usize(bx.cx, size.bytes())),\n-             CodegenCx::c_usize(bx.cx, align.abi()))\n+            let (size, align) = bx.cx().size_and_align_of(unit);\n+            (bx.mul(info.unwrap(), CodegenCx::c_usize(bx.cx(), size.bytes())),\n+             CodegenCx::c_usize(bx.cx(), align.abi()))\n         }\n         _ => {\n-            let cx = bx.cx;\n+            let cx = bx.cx();\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n             // want to avoid, as the unsized field's alignment could be smaller.\n@@ -116,7 +116,7 @@ pub fn size_and_align_of_dst(\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bx.sub(align, CodegenCx::c_usize(bx.cx, 1));\n+            let addend = bx.sub(align, CodegenCx::c_usize(bx.cx(), 1));\n             let size = bx.and(bx.add(size, addend), bx.neg(align));\n \n             (size, align)"}, {"sha": "cce3f59cecb7c7e7da1b4399d463b1f061c7f6b2", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -98,7 +98,7 @@ pub fn codegen_intrinsic_call(\n     llresult: &'ll Value,\n     span: Span,\n ) {\n-    let cx = bx.cx;\n+    let cx = bx.cx();\n     let tcx = cx.tcx;\n \n     let (def_id, substs) = match callee_ty.sty {\n@@ -210,7 +210,7 @@ pub fn codegen_intrinsic_call(\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            CodegenCx::c_bool(cx, bx.cx.type_needs_drop(tp_ty))\n+            CodegenCx::c_bool(cx, bx.cx().type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = args[0].immediate();\n@@ -266,12 +266,12 @@ pub fn codegen_intrinsic_call(\n             to_immediate(bx, load, cx.layout_of(tp_ty))\n         },\n         \"volatile_store\" => {\n-            let dst = args[0].deref(bx.cx);\n+            let dst = args[0].deref(bx.cx());\n             args[1].val.volatile_store(bx, dst);\n             return;\n         },\n         \"unaligned_volatile_store\" => {\n-            let dst = args[0].deref(bx.cx);\n+            let dst = args[0].deref(bx.cx());\n             args[1].val.unaligned_volatile_store(bx, dst);\n             return;\n         },\n@@ -302,12 +302,12 @@ pub fn codegen_intrinsic_call(\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n-                            let y = CodegenCx::c_bool(bx.cx, false);\n+                            let y = CodegenCx::c_bool(bx.cx(), false);\n                             let llfn = cx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n                             bx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n-                            let y = CodegenCx::c_bool(bx.cx, true);\n+                            let y = CodegenCx::c_bool(bx.cx(), true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n                             let llfn = cx.get_intrinsic(llvm_name);\n                             bx.call(llfn, &[args[0].immediate(), y], None)\n@@ -330,7 +330,7 @@ pub fn codegen_intrinsic_call(\n                             let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n                                                     if signed { 's' } else { 'u' },\n                                                     &name[..3], width);\n-                            let llfn = bx.cx.get_intrinsic(&intrinsic);\n+                            let llfn = bx.cx().get_intrinsic(&intrinsic);\n \n                             // Convert `i1` to a `bool`, and write it to the out parameter\n                             let pair = bx.call(llfn, &[\n@@ -431,7 +431,7 @@ pub fn codegen_intrinsic_call(\n         },\n \n         \"discriminant_value\" => {\n-            args[0].deref(bx.cx).codegen_get_discr(bx, ret_ty)\n+            args[0].deref(bx.cx()).codegen_get_discr(bx, ret_ty)\n         }\n \n         name if name.starts_with(\"simd_\") => {\n@@ -495,7 +495,7 @@ pub fn codegen_intrinsic_call(\n                             failorder,\n                             weak);\n                         let val = bx.extract_value(pair, 0);\n-                        let success = bx.zext(bx.extract_value(pair, 1), Type::bool(bx.cx));\n+                        let success = bx.zext(bx.extract_value(pair, 1), Type::bool(bx.cx()));\n \n                         let dest = result.project_field(bx, 0);\n                         bx.store(val, dest.llval, dest.align);\n@@ -566,7 +566,7 @@ pub fn codegen_intrinsic_call(\n         }\n \n         \"nontemporal_store\" => {\n-            let dst = args[0].deref(bx.cx);\n+            let dst = args[0].deref(bx.cx());\n             args[1].val.nontemporal_store(bx, dst);\n             return;\n         }\n@@ -634,7 +634,7 @@ pub fn codegen_intrinsic_call(\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bx.cx.type_needs_drop(arg.layout.ty));\n+                        assert!(!bx.cx().type_needs_drop(arg.layout.ty));\n                         let (ptr, align) = match arg.val {\n                             OperandValue::Ref(ptr, None, align) => (ptr, align),\n                             _ => bug!()\n@@ -645,11 +645,11 @@ pub fn codegen_intrinsic_call(\n                         }).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n-                        let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n+                        let llvm_elem = one(ty_to_type(bx.cx(), llvm_elem));\n                         vec![bx.pointercast(arg.immediate(), llvm_elem.ptr_to())]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n-                        let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n+                        let llvm_elem = one(ty_to_type(bx.cx(), llvm_elem));\n                         vec![\n                             bx.bitcast(arg.immediate(),\n                             Type::vector(llvm_elem, length as u64))\n@@ -659,7 +659,7 @@ pub fn codegen_intrinsic_call(\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so\n                         // we have to trim it down here.\n-                        vec![bx.trunc(arg.immediate(), Type::ix(bx.cx, llvm_width as u64))]\n+                        vec![bx.trunc(arg.immediate(), Type::ix(bx.cx(), llvm_width as u64))]\n                     }\n                     _ => vec![arg.immediate()],\n                 }\n@@ -723,7 +723,7 @@ fn copy_intrinsic(\n     src: &'ll Value,\n     count: &'ll Value,\n ) -> &'ll Value {\n-    let cx = bx.cx;\n+    let cx = bx.cx();\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = CodegenCx::c_usize(cx, size.bytes());\n     let align = align.abi();\n@@ -744,7 +744,7 @@ fn memset_intrinsic(\n     val: &'ll Value,\n     count: &'ll Value\n ) -> &'ll Value {\n-    let cx = bx.cx;\n+    let cx = bx.cx();\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = CodegenCx::c_usize(cx, size.bytes());\n     let align = CodegenCx::c_i32(cx, align.abi() as i32);\n@@ -763,7 +763,7 @@ fn try_intrinsic(\n     if bx.sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        bx.store(CodegenCx::c_null(Type::i8p(&bx.cx)), dest, ptr_align);\n+        bx.store(CodegenCx::c_null(Type::i8p(&bx.cx())), dest, ptr_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n@@ -787,9 +787,9 @@ fn codegen_msvc_try(\n     dest: &'ll Value,\n ) {\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n-        let cx = bx.cx;\n+        let cx = bx.cx();\n \n-        bx.set_personality_fn(bx.cx.eh_personality());\n+        bx.set_personality_fn(bx.cx().eh_personality());\n \n         let normal = bx.build_sibling_block(\"normal\");\n         let catchswitch = bx.build_sibling_block(\"catchswitch\");\n@@ -896,7 +896,7 @@ fn codegen_gnu_try(\n     dest: &'ll Value,\n ) {\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n-        let cx = bx.cx;\n+        let cx = bx.cx();\n \n         // Codegens the shims described above:\n         //\n@@ -931,7 +931,7 @@ fn codegen_gnu_try(\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n         let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false);\n-        let vals = catch.landing_pad(lpad_ty, bx.cx.eh_personality(), 1);\n+        let vals = catch.landing_pad(lpad_ty, bx.cx().eh_personality(), 1);\n         catch.add_clause(vals, CodegenCx::c_null(Type::i8p(cx)));\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n@@ -1125,7 +1125,7 @@ fn generic_simd_intrinsic(\n                                     arg_idx, total_len);\n                         None\n                     }\n-                    Some(idx) => Some(CodegenCx::c_i32(bx.cx, idx as i32)),\n+                    Some(idx) => Some(CodegenCx::c_i32(bx.cx(), idx as i32)),\n                 }\n             })\n             .collect();\n@@ -1167,7 +1167,7 @@ fn generic_simd_intrinsic(\n             _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty)\n         }\n         // truncate the mask to a vector of i1s\n-        let i1 = Type::i1(bx.cx);\n+        let i1 = Type::i1(bx.cx());\n         let i1xn = Type::vector(i1, m_len as u64);\n         let m_i1s = bx.trunc(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n@@ -1229,7 +1229,7 @@ fn generic_simd_intrinsic(\n         };\n \n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", name, in_len, ety);\n-        let intrinsic = bx.cx.get_intrinsic(&llvm_name);\n+        let intrinsic = bx.cx().get_intrinsic(&llvm_name);\n         let c = bx.call(intrinsic,\n                         &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                         None);\n@@ -1386,27 +1386,27 @@ fn generic_simd_intrinsic(\n         }\n \n         // Alignment of T, must be a constant integer value:\n-        let alignment_ty = Type::i32(bx.cx);\n-        let alignment = CodegenCx::c_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+        let alignment_ty = Type::i32(bx.cx());\n+        let alignment = CodegenCx::c_i32(bx.cx(), bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n-            let i1 = Type::i1(bx.cx);\n+            let i1 = Type::i1(bx.cx());\n             let i1xn = Type::vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n         // Type of the vector of pointers:\n-        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count);\n+        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count);\n         let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n \n         // Type of the vector of elements:\n-        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count - 1);\n+        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count - 1);\n         let llvm_elem_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count - 1);\n \n         let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n+        let f = declare::declare_cfn(bx.cx(), &llvm_intrinsic,\n                                      Type::func(&[\n                                          llvm_pointer_vec_ty,\n                                          alignment_ty,\n@@ -1486,29 +1486,29 @@ fn generic_simd_intrinsic(\n         }\n \n         // Alignment of T, must be a constant integer value:\n-        let alignment_ty = Type::i32(bx.cx);\n-        let alignment = CodegenCx::c_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+        let alignment_ty = Type::i32(bx.cx());\n+        let alignment = CodegenCx::c_i32(bx.cx(), bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n-            let i1 = Type::i1(bx.cx);\n+            let i1 = Type::i1(bx.cx());\n             let i1xn = Type::vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n-        let ret_t = Type::void(bx.cx);\n+        let ret_t = Type::void(bx.cx());\n \n         // Type of the vector of pointers:\n-        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count);\n+        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count);\n         let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n \n         // Type of the vector of elements:\n-        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count - 1);\n+        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count - 1);\n         let llvm_elem_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count - 1);\n \n         let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n-        let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n+        let f = declare::declare_cfn(bx.cx(), &llvm_intrinsic,\n                                      Type::func(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,\n@@ -1565,8 +1565,8 @@ fn generic_simd_intrinsic(\n                         } else {\n                             // unordered arithmetic reductions do not:\n                             match f.bit_width() {\n-                                32 => CodegenCx::c_undef(Type::f32(bx.cx)),\n-                                64 => CodegenCx::c_undef(Type::f64(bx.cx)),\n+                                32 => CodegenCx::c_undef(Type::f32(bx.cx())),\n+                                64 => CodegenCx::c_undef(Type::f64(bx.cx())),\n                                 v => {\n                                     return_error!(r#\"\n unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n@@ -1643,7 +1643,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n-                    let i1 = Type::i1(bx.cx);\n+                    let i1 = Type::i1(bx.cx());\n                     let i1xn = Type::vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n@@ -1654,7 +1654,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                             if !$boolean {\n                                 r\n                             } else {\n-                                bx.zext(r, Type::bool(bx.cx))\n+                                bx.zext(r, Type::bool(bx.cx()))\n                             }\n                         )\n                     },"}, {"sha": "e58139a3e9d6f60b896b219eb68139d9e889c283", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -41,10 +41,10 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, fn_ty.ptr_to_llvm_type(bx.cx).ptr_to());\n+        let llvtable = bx.pointercast(llvtable, fn_ty.ptr_to_llvm_type(bx.cx()).ptr_to());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(\n-            bx.inbounds_gep(llvtable, &[CodegenCx::c_usize(bx.cx, self.0)]),\n+            bx.inbounds_gep(llvtable, &[CodegenCx::c_usize(bx.cx(), self.0)]),\n             ptr_align\n         );\n         bx.nonnull_metadata(ptr);\n@@ -61,10 +61,10 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, Type::isize(bx.cx).ptr_to());\n+        let llvtable = bx.pointercast(llvtable, Type::isize(bx.cx()).ptr_to());\n         let usize_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(\n-            bx.inbounds_gep(llvtable, &[CodegenCx::c_usize(bx.cx, self.0)]),\n+            bx.inbounds_gep(llvtable, &[CodegenCx::c_usize(bx.cx(), self.0)]),\n             usize_align\n         );\n         // Vtable loads are invariant"}, {"sha": "65930c264b39da0e283bc9f5b73e1c1741476f92", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -177,15 +177,15 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         lp = bx.insert_value(lp, lp1, 1);\n                         bx.resume(lp);\n                     } else {\n-                        bx.call(bx.cx.eh_unwind_resume(), &[lp0], cleanup_bundle);\n+                        bx.call(bx.cx().eh_unwind_resume(), &[lp0], cleanup_bundle);\n                         bx.unreachable();\n                     }\n                 }\n             }\n \n             mir::TerminatorKind::Abort => {\n                 // Call core::intrinsics::abort()\n-                let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n+                let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                 bx.call(fnname, &[], None);\n                 bx.unreachable();\n             }\n@@ -209,7 +209,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             bx.cond_br(discr.immediate(), lltrue, llfalse);\n                         }\n                     } else {\n-                        let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n+                        let switch_llty = bx.cx().layout_of(switch_ty).immediate_llvm_type(bx.cx());\n                         let llval = CodegenCx::c_uint_big(switch_llty, values[0]);\n                         let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                         bx.cond_br(cmp, lltrue, llfalse);\n@@ -219,7 +219,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let switch = bx.switch(discr.immediate(),\n                                            llblock(self, *otherwise),\n                                            values.len());\n-                    let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n+                    let switch_llty = bx.cx().layout_of(switch_ty).immediate_llvm_type(bx.cx());\n                     for (&value, target) in values.iter().zip(targets) {\n                         let llval = CodegenCx::c_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);\n@@ -269,7 +269,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             }\n                         };\n                         bx.load(\n-                            bx.pointercast(llslot, cast_ty.llvm_type(bx.cx).ptr_to()),\n+                            bx.pointercast(llslot, cast_ty.llvm_type(bx.cx()).ptr_to()),\n                             self.fn_ty.ret.layout.align)\n                     }\n                 };\n@@ -283,7 +283,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bx.cx.tcx, ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bx.cx().tcx, ty);\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n@@ -302,19 +302,19 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 };\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::Dynamic(..) => {\n-                        let sig = drop_fn.fn_sig(bx.cx.tcx);\n+                        let sig = drop_fn.fn_sig(bx.tcx());\n                         let sig = bx.tcx().normalize_erasing_late_bound_regions(\n                             ty::ParamEnv::reveal_all(),\n                             &sig,\n                         );\n-                        let fn_ty = FnType::new_vtable(bx.cx, sig, &[]);\n+                        let fn_ty = FnType::new_vtable(bx.cx(), sig, &[]);\n                         let vtable = args[1];\n                         args = &args[..1];\n                         (meth::DESTRUCTOR.get_fn(&bx, vtable, &fn_ty), fn_ty)\n                     }\n                     _ => {\n-                        (callee::get_fn(bx.cx, drop_fn),\n-                         FnType::of_instance(bx.cx, &drop_fn))\n+                        (callee::get_fn(bx.cx(), drop_fn),\n+                         FnType::of_instance(bx.cx(), &drop_fn))\n                     }\n                 };\n                 do_call(self, bx, fn_ty, drop_fn, args,\n@@ -333,7 +333,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // NOTE: Unlike binops, negation doesn't have its own\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n-                if !bx.cx.check_overflow {\n+                if !bx.cx().check_overflow {\n                     if let mir::interpret::EvalErrorKind::OverflowNeg = *msg {\n                         const_cond = Some(expected);\n                     }\n@@ -346,8 +346,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 }\n \n                 // Pass the condition through llvm.expect for branch hinting.\n-                let expect = bx.cx.get_intrinsic(&\"llvm.expect.i1\");\n-                let cond = bx.call(expect, &[cond, CodegenCx::c_bool(bx.cx, expected)], None);\n+                let expect = bx.cx().get_intrinsic(&\"llvm.expect.i1\");\n+                let cond = bx.call(expect, &[cond, CodegenCx::c_bool(bx.cx(), expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n@@ -365,9 +365,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // Get the location information.\n                 let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                let filename = CodegenCx::c_str_slice(bx.cx, filename);\n-                let line = CodegenCx::c_u32(bx.cx, loc.line as u32);\n-                let col = CodegenCx::c_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n+                let filename = CodegenCx::c_str_slice(bx.cx(), filename);\n+                let line = CodegenCx::c_u32(bx.cx(), loc.line as u32);\n+                let col = CodegenCx::c_u32(bx.cx(), loc.col.to_usize() as u32 + 1);\n                 let align = tcx.data_layout.aggregate_align\n                     .max(tcx.data_layout.i32_align)\n                     .max(tcx.data_layout.pointer_align);\n@@ -378,9 +378,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let len = self.codegen_operand(&mut bx, len).immediate();\n                         let index = self.codegen_operand(&mut bx, index).immediate();\n \n-                        let file_line_col = CodegenCx::c_struct(bx.cx,\n+                        let file_line_col = CodegenCx::c_struct(bx.cx(),\n                              &[filename, line, col], false);\n-                        let file_line_col = consts::addr_of(bx.cx,\n+                        let file_line_col = consts::addr_of(bx.cx(),\n                                                             file_line_col,\n                                                             align,\n                                                             Some(\"panic_bounds_check_loc\"));\n@@ -390,13 +390,13 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     _ => {\n                         let str = msg.description();\n                         let msg_str = Symbol::intern(str).as_str();\n-                        let msg_str = CodegenCx::c_str_slice(bx.cx, msg_str);\n+                        let msg_str = CodegenCx::c_str_slice(bx.cx(), msg_str);\n                         let msg_file_line_col = CodegenCx::c_struct(\n-                            bx.cx,\n+                            bx.cx(),\n                             &[msg_str, filename, line, col],\n                             false\n                         );\n-                        let msg_file_line_col = consts::addr_of(bx.cx,\n+                        let msg_file_line_col = consts::addr_of(bx.cx(),\n                                                                 msg_file_line_col,\n                                                                 align,\n                                                                 Some(\"panic_loc\"));\n@@ -408,8 +408,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_ty = FnType::of_instance(bx.cx, &instance);\n-                let llfn = callee::get_fn(bx.cx, instance);\n+                let fn_ty = FnType::of_instance(bx.cx(), &instance);\n+                let llfn = callee::get_fn(bx.cx(), instance);\n \n                 // Codegen the actual panic invoke/call.\n                 do_call(self, bx, fn_ty, llfn, &args, None, cleanup);\n@@ -431,7 +431,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n-                        (Some(ty::Instance::resolve(bx.cx.tcx,\n+                        (Some(ty::Instance::resolve(bx.cx().tcx,\n                                                     ty::ParamEnv::reveal_all(),\n                                                     def_id,\n                                                     substs).unwrap()),\n@@ -470,7 +470,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // we can do what we like. Here, we declare that transmuting\n                         // into an uninhabited type is impossible, so anything following\n                         // it must be unreachable.\n-                        assert_eq!(bx.cx.layout_of(sig.output()).abi, layout::Abi::Uninhabited);\n+                        assert_eq!(bx.cx().layout_of(sig.output()).abi, layout::Abi::Uninhabited);\n                         bx.unreachable();\n                     }\n                     return;\n@@ -484,15 +484,15 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 let fn_ty = match def {\n                     Some(ty::InstanceDef::Virtual(..)) => {\n-                        FnType::new_vtable(bx.cx, sig, &extra_args)\n+                        FnType::new_vtable(bx.cx(), sig, &extra_args)\n                     }\n                     Some(ty::InstanceDef::DropGlue(_, None)) => {\n                         // empty drop glue - a nop.\n                         let &(_, target) = destination.as_ref().unwrap();\n                         funclet_br(self, bx, target);\n                         return;\n                     }\n-                    _ => FnType::new(bx.cx, sig, &extra_args)\n+                    _ => FnType::new(bx.cx(), sig, &extra_args)\n                 };\n \n                 // emit a panic instead of instantiating an uninhabited type\n@@ -563,7 +563,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            CodegenCx::c_undef(fn_ty.ret.memory_ty(bx.cx).ptr_to())\n+                            CodegenCx::c_undef(fn_ty.ret.memory_ty(bx.cx()).ptr_to())\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -597,7 +597,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                     );\n                                     return OperandRef {\n                                         val: Immediate(llval),\n-                                        layout: bx.cx.layout_of(ty),\n+                                        layout: bx.cx().layout_of(ty),\n                                     };\n \n                                 },\n@@ -615,7 +615,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                     );\n                                     return OperandRef {\n                                         val: Immediate(llval),\n-                                        layout: bx.cx.layout_of(ty)\n+                                        layout: bx.cx().layout_of(ty)\n                                     };\n                                 }\n                             }\n@@ -625,7 +625,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     }).collect();\n \n \n-                    let callee_ty = instance.as_ref().unwrap().ty(bx.cx.tcx);\n+                    let callee_ty = instance.as_ref().unwrap().ty(bx.cx().tcx);\n                     codegen_intrinsic_call(&bx, callee_ty, &fn_ty, &args, dest,\n                                            terminator.source_info.span);\n \n@@ -722,7 +722,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 let fn_ptr = match (llfn, instance) {\n                     (Some(llfn), _) => llfn,\n-                    (None, Some(instance)) => callee::get_fn(bx.cx, instance),\n+                    (None, Some(instance)) => callee::get_fn(bx.cx(), instance),\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n@@ -744,7 +744,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                       arg: &ArgType<'tcx, Ty<'tcx>>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(CodegenCx::c_undef(ty.llvm_type(bx.cx)));\n+            llargs.push(CodegenCx::c_undef(ty.llvm_type(bx.cx())));\n         }\n \n         if arg.is_ignore() {\n@@ -804,7 +804,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                llval = bx.load(bx.pointercast(llval, ty.llvm_type(bx.cx).ptr_to()),\n+                llval = bx.load(bx.pointercast(llval, ty.llvm_type(bx.cx()).ptr_to()),\n                                 align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n@@ -855,7 +855,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         &mut self,\n         bx: &Builder<'a, 'll, 'tcx>\n     ) -> PlaceRef<'tcx, &'ll Value> {\n-        let cx = bx.cx;\n+        let cx = bx.cx();\n         if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n@@ -992,7 +992,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n-                    let dst_layout = bx.cx.layout_of(self.monomorphized_place_ty(dst));\n+                    let dst_layout = bx.cx().layout_of(self.monomorphized_place_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n                     let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n                     place.storage_live(bx);\n@@ -1016,7 +1016,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                               src: &mir::Operand<'tcx>,\n                               dst: PlaceRef<'tcx, &'ll Value>) {\n         let src = self.codegen_operand(bx, src);\n-        let llty = src.layout.llvm_type(bx.cx);\n+        let llty = src.layout.llvm_type(bx.cx());\n         let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());\n         let align = src.layout.align.min(dst.layout.align);\n         src.val.store(bx, PlaceRef::new_sized(cast_ptr, src.layout, align));"}, {"sha": "fb6bc0ec7c7bbd4b8a392c3155e6cf17df8c9cdc", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -194,20 +194,20 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         c,\n                     )?;\n                     if let Some(prim) = field.val.try_to_scalar() {\n-                        let layout = bx.cx.layout_of(field_ty);\n+                        let layout = bx.cx().layout_of(field_ty);\n                         let scalar = match layout.abi {\n                             layout::Abi::Scalar(ref x) => x,\n                             _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                         };\n                         Ok(scalar_to_llvm(\n-                            bx.cx, prim, scalar,\n-                            layout.immediate_llvm_type(bx.cx),\n+                            bx.cx(), prim, scalar,\n+                            layout.immediate_llvm_type(bx.cx()),\n                         ))\n                     } else {\n                         bug!(\"simd shuffle field {:?}\", field)\n                     }\n                 }).collect();\n-                let llval = CodegenCx::c_struct(bx.cx, &values?, false);\n+                let llval = CodegenCx::c_struct(bx.cx(), &values?, false);\n                 Ok((llval, c.ty))\n             })\n             .unwrap_or_else(|_| {\n@@ -217,7 +217,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 );\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(&ty);\n-                let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n+                let llty = bx.cx().layout_of(ty).llvm_type(bx.cx());\n                 (CodegenCx::c_undef(llty), ty)\n             })\n     }"}, {"sha": "06b1026dca9673dec4f0dc5abecc29dc034515ad", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -275,7 +275,7 @@ pub fn codegen_mir(\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.cx.layout_of(fx.monomorphize(&decl.ty));\n+            let layout = bx.cx().layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if let Some(name) = decl.name {\n@@ -285,7 +285,7 @@ pub fn codegen_mir(\n \n                 if !memory_locals.contains(local) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(bx.cx, layout);\n+                    return LocalRef::new_operand(bx.cx(), layout);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n@@ -327,7 +327,7 @@ pub fn codegen_mir(\n                     // alloca in advance. Instead we wait until we see the\n                     // definition and update the operand there.\n                     debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(bx.cx, layout)\n+                    LocalRef::new_operand(bx.cx(), layout)\n                 }\n             }\n         };\n@@ -420,8 +420,8 @@ fn create_funclets(\n                 // C++ personality function, but `catch (...)` has no type so\n                 // it's null. The 64 here is actually a bitfield which\n                 // represents that this is a catch-all block.\n-                let null = CodegenCx::c_null(Type::i8p(bx.cx));\n-                let sixty_four = CodegenCx::c_i32(bx.cx, 64);\n+                let null = CodegenCx::c_null(Type::i8p(bx.cx()));\n+                let sixty_four = CodegenCx::c_i32(bx.cx(), 64);\n                 cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                 cp_bx.br(llbb);\n             }\n@@ -480,7 +480,7 @@ fn arg_local_refs(\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let place = PlaceRef::alloca(bx, bx.cx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bx, bx.cx().layout_of(arg_ty), &name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n@@ -523,7 +523,7 @@ fn arg_local_refs(\n             let local = |op| LocalRef::Operand(Some(op));\n             match arg.mode {\n                 PassMode::Ignore => {\n-                    return local(OperandRef::new_zst(bx.cx, arg.layout));\n+                    return local(OperandRef::new_zst(bx.cx(), arg.layout));\n                 }\n                 PassMode::Direct(_) => {\n                     let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n@@ -602,7 +602,7 @@ fn arg_local_refs(\n             // Or is it the closure environment?\n             let (closure_layout, env_ref) = match arg.layout.ty.sty {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n-                ty::Ref(_, ty, _)  => (bx.cx.layout_of(ty), true),\n+                ty::Ref(_, ty, _)  => (bx.cx().layout_of(ty), true),\n                 _ => (arg.layout, false)\n             };\n \n@@ -624,7 +624,7 @@ fn arg_local_refs(\n             let env_alloca = !env_ref && llvm_util::get_major_version() < 6;\n             let env_ptr = if env_alloca {\n                 let scratch = PlaceRef::alloca(bx,\n-                    bx.cx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n+                    bx.cx().layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n                     \"__debuginfo_env_ptr\");\n                 bx.store(place.llval, scratch.llval, scratch.align);\n                 scratch.llval"}, {"sha": "ab70f897b80223a692abaafff0e5f3ffcc2e2d3f", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -81,10 +81,10 @@ impl OperandRef<'tcx, &'ll Value> {\n     pub fn from_const(bx: &Builder<'a, 'll, 'tcx>,\n                       val: &'tcx ty::Const<'tcx>)\n                       -> Result<OperandRef<'tcx, &'ll Value>, ErrorHandled> {\n-        let layout = bx.cx.layout_of(val.ty);\n+        let layout = bx.cx().layout_of(val.ty);\n \n         if layout.is_zst() {\n-            return Ok(OperandRef::new_zst(bx.cx, layout));\n+            return Ok(OperandRef::new_zst(bx.cx(), layout));\n         }\n \n         let val = match val.val {\n@@ -95,10 +95,10 @@ impl OperandRef<'tcx, &'ll Value> {\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                 };\n                 let llval = scalar_to_llvm(\n-                    bx.cx,\n+                    bx.cx(),\n                     x,\n                     scalar,\n-                    layout.immediate_llvm_type(bx.cx),\n+                    layout.immediate_llvm_type(bx.cx()),\n                 );\n                 OperandValue::Immediate(llval)\n             },\n@@ -108,14 +108,14 @@ impl OperandRef<'tcx, &'ll Value> {\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n                 let a_llval = scalar_to_llvm(\n-                    bx.cx,\n+                    bx.cx(),\n                     a,\n                     a_scalar,\n-                    layout.scalar_pair_element_llvm_type(bx.cx, 0, true),\n+                    layout.scalar_pair_element_llvm_type(bx.cx(), 0, true),\n                 );\n-                let b_layout = layout.scalar_pair_element_llvm_type(bx.cx, 1, true);\n+                let b_layout = layout.scalar_pair_element_llvm_type(bx.cx(), 1, true);\n                 let b_llval = scalar_to_llvm(\n-                    bx.cx,\n+                    bx.cx(),\n                     b,\n                     b_scalar,\n                     b_layout,\n@@ -163,7 +163,7 @@ impl OperandRef<'tcx, &'ll Value> {\n     /// For other cases, see `immediate`.\n     pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'll, 'tcx>) -> &'ll Value {\n         if let OperandValue::Pair(a, b) = self.val {\n-            let llty = self.layout.llvm_type(bx.cx);\n+            let llty = self.layout.llvm_type(bx.cx());\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n@@ -200,13 +200,13 @@ impl OperandRef<'tcx, &'ll Value> {\n         bx: &Builder<'a, 'll, 'tcx>,\n         i: usize,\n     ) -> OperandRef<'tcx, &'ll Value> {\n-        let field = self.layout.field(bx.cx, i);\n+        let field = self.layout.field(bx.cx(), i);\n         let offset = self.layout.fields.offset(i);\n \n         let mut val = match (self.val, &self.layout.abi) {\n             // If the field is ZST, it has no data.\n             _ if field.is_zst() => {\n-                return OperandRef::new_zst(bx.cx, field);\n+                return OperandRef::new_zst(bx.cx(), field);\n             }\n \n             // Newtype of a scalar, scalar pair or vector.\n@@ -219,20 +219,20 @@ impl OperandRef<'tcx, &'ll Value> {\n             // Extract a scalar component from a pair.\n             (OperandValue::Pair(a_llval, b_llval), &layout::Abi::ScalarPair(ref a, ref b)) => {\n                 if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(bx.cx));\n+                    assert_eq!(field.size, a.value.size(bx.cx()));\n                     OperandValue::Immediate(a_llval)\n                 } else {\n-                    assert_eq!(offset, a.value.size(bx.cx)\n-                        .abi_align(b.value.align(bx.cx)));\n-                    assert_eq!(field.size, b.value.size(bx.cx));\n+                    assert_eq!(offset, a.value.size(bx.cx())\n+                        .abi_align(b.value.align(bx.cx())));\n+                    assert_eq!(field.size, b.value.size(bx.cx()));\n                     OperandValue::Immediate(b_llval)\n                 }\n             }\n \n             // `#[repr(simd)]` types are also immediate.\n             (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n                 OperandValue::Immediate(\n-                    bx.extract_element(llval, CodegenCx::c_usize(bx.cx, i as u64)))\n+                    bx.extract_element(llval, CodegenCx::c_usize(bx.cx(), i as u64)))\n             }\n \n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n@@ -241,11 +241,11 @@ impl OperandRef<'tcx, &'ll Value> {\n         // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n         match val {\n             OperandValue::Immediate(ref mut llval) => {\n-                *llval = bx.bitcast(*llval, field.immediate_llvm_type(bx.cx));\n+                *llval = bx.bitcast(*llval, field.immediate_llvm_type(bx.cx()));\n             }\n             OperandValue::Pair(ref mut a, ref mut b) => {\n-                *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx, 0, true));\n-                *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx, 1, true));\n+                *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx(), 0, true));\n+                *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx(), 1, true));\n             }\n             OperandValue::Ref(..) => bug!()\n         }\n@@ -349,7 +349,7 @@ impl OperandValue<&'ll Value> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(Type::i8(bx.cx), llsize, \"unsized_tmp\", max_align);\n+        let lldst = bx.array_alloca(Type::i8(bx.cx()), llsize, \"unsized_tmp\", max_align);\n         base::call_memcpy(bx, lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n@@ -394,9 +394,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // ZSTs don't require any actual memory access.\n                         // FIXME(eddyb) deduplicate this with the identical\n                         // checks in `codegen_consume` and `extract_field`.\n-                        let elem = o.layout.field(bx.cx, 0);\n+                        let elem = o.layout.field(bx.cx(), 0);\n                         if elem.is_zst() {\n-                            return Some(OperandRef::new_zst(bx.cx, elem));\n+                            return Some(OperandRef::new_zst(bx.cx(), elem));\n                         }\n                     }\n                     _ => {}\n@@ -415,11 +415,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         debug!(\"codegen_consume(place={:?})\", place);\n \n         let ty = self.monomorphized_place_ty(place);\n-        let layout = bx.cx.layout_of(ty);\n+        let layout = bx.cx().layout_of(ty);\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n-            return OperandRef::new_zst(bx.cx, layout);\n+            return OperandRef::new_zst(bx.cx(), layout);\n         }\n \n         if let Some(o) = self.maybe_codegen_consume_direct(bx, place) {\n@@ -458,12 +458,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         }\n                         // Allow RalfJ to sleep soundly knowing that even refactorings that remove\n                         // the above error (or silence it under some conditions) will not cause UB\n-                        let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n+                        let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n                         // We've errored, so we don't have to produce working code.\n-                        let layout = bx.cx.layout_of(ty);\n+                        let layout = bx.cx().layout_of(ty);\n                         PlaceRef::new_sized(\n-                            CodegenCx::c_undef(layout.llvm_type(bx.cx).ptr_to()),\n+                            CodegenCx::c_undef(layout.llvm_type(bx.cx()).ptr_to()),\n                             layout,\n                             layout.align,\n                         ).load(bx)"}, {"sha": "ae421c6b97da037b171ea6a12efef904064f0122", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -64,23 +64,23 @@ impl PlaceRef<'tcx, &'ll Value> {\n         alloc: &mir::interpret::Allocation,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n-        let init = const_alloc_to_llvm(bx.cx, alloc);\n-        let base_addr = consts::addr_of(bx.cx, init, layout.align, None);\n+        let init = const_alloc_to_llvm(bx.cx(), alloc);\n+        let base_addr = consts::addr_of(bx.cx(), init, layout.align, None);\n \n         let llval = unsafe { LLVMConstInBoundsGEP(\n-            consts::bitcast(base_addr, Type::i8p(bx.cx)),\n-            &CodegenCx::c_usize(bx.cx, offset.bytes()),\n+            consts::bitcast(base_addr, Type::i8p(bx.cx())),\n+            &CodegenCx::c_usize(bx.cx(), offset.bytes()),\n             1,\n         )};\n-        let llval = consts::bitcast(llval, layout.llvm_type(bx.cx).ptr_to());\n+        let llval = consts::bitcast(llval, layout.llvm_type(bx.cx()).ptr_to());\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n \n     pub fn alloca(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'tcx, &'ll Value> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n-        let tmp = bx.alloca(layout.llvm_type(bx.cx), name, layout.align);\n+        let tmp = bx.alloca(layout.llvm_type(bx.cx()), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n@@ -92,8 +92,8 @@ impl PlaceRef<'tcx, &'ll Value> {\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n-        let ptr_ty = bx.cx.tcx.mk_mut_ptr(layout.ty);\n-        let ptr_layout = bx.cx.layout_of(ptr_ty);\n+        let ptr_ty = bx.cx().tcx.mk_mut_ptr(layout.ty);\n+        let ptr_layout = bx.cx().layout_of(ptr_ty);\n         Self::alloca(bx, ptr_layout, name)\n     }\n \n@@ -116,14 +116,14 @@ impl PlaceRef<'tcx, &'ll Value> {\n         assert_eq!(self.llextra.is_some(), self.layout.is_unsized());\n \n         if self.layout.is_zst() {\n-            return OperandRef::new_zst(bx.cx, self.layout);\n+            return OperandRef::new_zst(bx.cx(), self.layout);\n         }\n \n         let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n             let vr = scalar.valid_range.clone();\n             match scalar.value {\n                 layout::Int(..) => {\n-                    let range = scalar.valid_range_exclusive(bx.cx);\n+                    let range = scalar.valid_range_exclusive(bx.cx());\n                     if range.start != range.end {\n                         bx.range_metadata(load, range);\n                     }\n@@ -160,7 +160,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 let load = bx.load(llptr, self.align);\n                 scalar_load_metadata(load, scalar);\n                 if scalar.is_bool() {\n-                    bx.trunc(load, Type::i1(bx.cx))\n+                    bx.trunc(load, Type::i1(bx.cx()))\n                 } else {\n                     load\n                 }\n@@ -179,7 +179,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n         bx: &Builder<'a, 'll, 'tcx>,\n         ix: usize,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n-        let cx = bx.cx;\n+        let cx = bx.cx();\n         let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n         let effective_field_align = self.align.restrict_for_offset(offset);\n@@ -287,15 +287,15 @@ impl PlaceRef<'tcx, &'ll Value> {\n         bx: &Builder<'a, 'll, 'tcx>,\n         cast_to: Ty<'tcx>\n     ) -> &'ll Value {\n-        let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n+        let cast_to = bx.cx().layout_of(cast_to).immediate_llvm_type(bx.cx());\n         if self.layout.abi.is_uninhabited() {\n             return CodegenCx::c_undef(cast_to);\n         }\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = self.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n-                    |def| def.discriminant_for_variant(bx.cx.tcx, index).val);\n+                    |def| def.discriminant_for_variant(bx.cx().tcx, index).val);\n                 return CodegenCx::c_uint_big(cast_to, discr_val);\n             }\n             layout::Variants::Tagged { .. } |\n@@ -323,7 +323,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 niche_start,\n                 ..\n             } => {\n-                let niche_llty = discr.layout.immediate_llvm_type(bx.cx);\n+                let niche_llty = discr.layout.immediate_llvm_type(bx.cx());\n                 if niche_variants.start() == niche_variants.end() {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n@@ -352,7 +352,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: VariantIdx) {\n-        if self.layout.for_variant(bx.cx, variant_index).abi.is_uninhabited() {\n+        if self.layout.for_variant(bx.cx(), variant_index).abi.is_uninhabited() {\n             return;\n         }\n         match self.layout.variants {\n@@ -365,7 +365,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n                     .val;\n                 bx.store(\n-                    CodegenCx::c_uint_big(ptr.layout.llvm_type(bx.cx), to),\n+                    CodegenCx::c_uint_big(ptr.layout.llvm_type(bx.cx()), to),\n                     ptr.llval,\n                     ptr.align);\n             }\n@@ -380,16 +380,16 @@ impl PlaceRef<'tcx, &'ll Value> {\n                        bx.sess().target.target.arch == \"aarch64\" {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n-                        let llptr = bx.pointercast(self.llval, Type::i8(bx.cx).ptr_to());\n-                        let fill_byte = CodegenCx::c_u8(bx.cx, 0);\n+                        let llptr = bx.pointercast(self.llval, Type::i8(bx.cx()).ptr_to());\n+                        let fill_byte = CodegenCx::c_u8(bx.cx(), 0);\n                         let (size, align) = self.layout.size_and_align();\n-                        let size = CodegenCx::c_usize(bx.cx, size.bytes());\n-                        let align = CodegenCx::c_u32(bx.cx, align.abi() as u32);\n+                        let size = CodegenCx::c_usize(bx.cx(), size.bytes());\n+                        let align = CodegenCx::c_u32(bx.cx(), align.abi() as u32);\n                         base::call_memset(bx, llptr, fill_byte, size, align, false);\n                     }\n \n                     let niche = self.project_field(bx, 0);\n-                    let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n+                    let niche_llty = niche.layout.immediate_llvm_type(bx.cx());\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128)\n                         .wrapping_add(niche_start);\n@@ -409,20 +409,20 @@ impl PlaceRef<'tcx, &'ll Value> {\n     pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: &'ll Value)\n                          -> PlaceRef<'tcx, &'ll Value> {\n         PlaceRef {\n-            llval: bx.inbounds_gep(self.llval, &[CodegenCx::c_usize(bx.cx, 0), llindex]),\n+            llval: bx.inbounds_gep(self.llval, &[CodegenCx::c_usize(bx.cx(), 0), llindex]),\n             llextra: None,\n-            layout: self.layout.field(bx.cx, 0),\n+            layout: self.layout.field(bx.cx(), 0),\n             align: self.align\n         }\n     }\n \n     pub fn project_downcast(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: VariantIdx)\n                             -> PlaceRef<'tcx, &'ll Value> {\n         let mut downcast = *self;\n-        downcast.layout = self.layout.for_variant(bx.cx, variant_index);\n+        downcast.layout = self.layout.for_variant(bx.cx(), variant_index);\n \n         // Cast to the appropriate variant struct type.\n-        let variant_ty = downcast.layout.llvm_type(bx.cx);\n+        let variant_ty = downcast.layout.llvm_type(bx.cx());\n         downcast.llval = bx.pointercast(downcast.llval, variant_ty.ptr_to());\n \n         downcast\n@@ -444,7 +444,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         -> PlaceRef<'tcx, &'ll Value> {\n         debug!(\"codegen_place(place={:?})\", place);\n \n-        let cx = bx.cx;\n+        let cx = bx.cx();\n         let tcx = cx.tcx;\n \n         if let mir::Place::Local(index) = *place {\n@@ -482,9 +482,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // and compile-time agree on values\n                         // With floats that won't always be true\n                         // so we generate an abort\n-                        let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n+                        let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n-                        let llval = CodegenCx::c_undef(layout.llvm_type(bx.cx).ptr_to());\n+                        let llval = CodegenCx::c_undef(layout.llvm_type(bx.cx()).ptr_to());\n                         PlaceRef::new_sized(llval, layout, layout.align)\n                     }\n                 }\n@@ -498,7 +498,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n-                self.codegen_consume(bx, base).deref(bx.cx)\n+                self.codegen_consume(bx, base).deref(bx.cx())\n             }\n             mir::Place::Projection(ref projection) => {\n                 let cg_base = self.codegen_place(bx, &projection.base);\n@@ -517,34 +517,34 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = CodegenCx::c_usize(bx.cx, offset as u64);\n+                        let lloffset = CodegenCx::c_usize(bx.cx(), offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = CodegenCx::c_usize(bx.cx, offset as u64);\n-                        let lllen = cg_base.len(bx.cx);\n+                        let lloffset = CodegenCx::c_usize(bx.cx(), offset as u64);\n+                        let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n-                            CodegenCx::c_usize(bx.cx, from as u64));\n+                            CodegenCx::c_usize(bx.cx(), from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n                             .projection_ty(tcx, &projection.elem)\n                             .to_ty(bx.tcx());\n-                        subslice.layout = bx.cx.layout_of(self.monomorphize(&projected_ty));\n+                        subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n-                                CodegenCx::c_usize(bx.cx, (from as u64) + (to as u64))));\n+                                CodegenCx::c_usize(bx.cx(), (from as u64) + (to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n                         subslice.llval = bx.pointercast(subslice.llval,\n-                            subslice.layout.llvm_type(bx.cx).ptr_to());\n+                            subslice.layout.llvm_type(bx.cx()).ptr_to());\n \n                         subslice\n                     }"}, {"sha": "c15bc6a970466bb26b323249218ef901e3059a3a", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3258448045d672b0cd273cb1ea9381b470c2ca2/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=d3258448045d672b0cd273cb1ea9381b470c2ca2", "patch": "@@ -103,28 +103,28 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     return bx;\n                 }\n \n-                let start = dest.project_index(&bx, CodegenCx::c_usize(bx.cx, 0)).llval;\n+                let start = dest.project_index(&bx, CodegenCx::c_usize(bx.cx(), 0)).llval;\n \n                 if let OperandValue::Immediate(v) = cg_elem.val {\n-                    let align = CodegenCx::c_i32(bx.cx, dest.align.abi() as i32);\n-                    let size = CodegenCx::c_usize(bx.cx, dest.layout.size.bytes());\n+                    let align = CodegenCx::c_i32(bx.cx(), dest.align.abi() as i32);\n+                    let size = CodegenCx::c_usize(bx.cx(), dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if CodegenCx::is_const_integral(v) && CodegenCx::const_to_uint(v) == 0 {\n-                        let fill = CodegenCx::c_u8(bx.cx, 0);\n+                        let fill = CodegenCx::c_u8(bx.cx(), 0);\n                         base::call_memset(&bx, start, fill, size, align, false);\n                         return bx;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = base::from_immediate(&bx, v);\n-                    if CodegenCx::val_ty(v) == Type::i8(bx.cx) {\n+                    if CodegenCx::val_ty(v) == Type::i8(bx.cx()) {\n                         base::call_memset(&bx, start, v, size, align, false);\n                         return bx;\n                     }\n                 }\n \n-                let count = CodegenCx::c_usize(bx.cx, count);\n+                let count = CodegenCx::c_usize(bx.cx(), count);\n                 let end = dest.project_index(&bx, count).llval;\n \n                 let header_bx = bx.build_sibling_block(\"repeat_loop_header\");\n@@ -140,7 +140,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 cg_elem.val.store(&body_bx,\n                     PlaceRef::new_sized(current, cg_elem.layout, dest.align));\n \n-                let next = body_bx.inbounds_gep(current, &[CodegenCx::c_usize(bx.cx, 1)]);\n+                let next = body_bx.inbounds_gep(current, &[CodegenCx::c_usize(bx.cx(), 1)]);\n                 body_bx.br(header_bx.llbb());\n                 header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n \n@@ -210,18 +210,18 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n                 let operand = self.codegen_operand(&bx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n-                let cast = bx.cx.layout_of(self.monomorphize(&mir_cast_ty));\n+                let cast = bx.cx().layout_of(self.monomorphize(&mir_cast_ty));\n \n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.layout.ty.sty {\n                             ty::FnDef(def_id, substs) => {\n-                                if bx.cx.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+                                if bx.cx().tcx.has_attr(def_id, \"rustc_args_required_const\") {\n                                     bug!(\"reifying a fn ptr that requires \\\n                                           const arguments\");\n                                 }\n                                 OperandValue::Immediate(\n-                                    callee::resolve_and_get_fn(bx.cx, def_id, substs))\n+                                    callee::resolve_and_get_fn(bx.cx(), def_id, substs))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.layout.ty)\n@@ -232,8 +232,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         match operand.layout.ty.sty {\n                             ty::Closure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n-                                    bx.cx.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n-                                OperandValue::Immediate(callee::get_fn(bx.cx, instance))\n+                                    bx.cx().tcx, def_id, substs, ty::ClosureKind::FnOnce);\n+                                OperandValue::Immediate(callee::get_fn(bx.cx(), instance))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.layout.ty)\n@@ -256,7 +256,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                 // HACK(eddyb) have to bitcast pointers\n                                 // until LLVM removes pointee types.\n                                 let lldata = bx.pointercast(lldata,\n-                                    cast.scalar_pair_element_llvm_type(bx.cx, 0, true));\n+                                    cast.scalar_pair_element_llvm_type(bx.cx(), 0, true));\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n@@ -275,12 +275,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n                             if cast.is_llvm_scalar_pair() {\n                                 let data_cast = bx.pointercast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(bx.cx, 0, true));\n+                                    cast.scalar_pair_element_llvm_type(bx.cx(), 0, true));\n                                 OperandValue::Pair(data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = cast.immediate_llvm_type(bx.cx);\n+                                let llcast_ty = cast.immediate_llvm_type(bx.cx());\n                                 let llval = bx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n@@ -290,7 +290,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     }\n                     mir::CastKind::Misc => {\n                         assert!(cast.is_llvm_immediate());\n-                        let ll_t_out = cast.immediate_llvm_type(bx.cx);\n+                        let ll_t_out = cast.immediate_llvm_type(bx.cx());\n                         if operand.layout.abi.is_uninhabited() {\n                             return (bx, OperandRef {\n                                 val: OperandValue::Immediate(CodegenCx::c_undef(ll_t_out)),\n@@ -300,12 +300,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let r_t_in = CastTy::from_ty(operand.layout.ty)\n                             .expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = operand.layout.immediate_llvm_type(bx.cx);\n+                        let ll_t_in = operand.layout.immediate_llvm_type(bx.cx());\n                         match operand.layout.variants {\n                             layout::Variants::Single { index } => {\n                                 if let Some(def) = operand.layout.ty.ty_adt_def() {\n                                     let discr_val = def\n-                                        .discriminant_for_variant(bx.cx.tcx, index)\n+                                        .discriminant_for_variant(bx.cx().tcx, index)\n                                         .val;\n                                     let discr = CodegenCx::c_uint_big(ll_t_out, discr_val);\n                                     return (bx, OperandRef {\n@@ -328,7 +328,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                 // then `i1 1` (i.e. E::B) is effectively `i8 -1`.\n                                 signed = !scalar.is_bool() && s;\n \n-                                let er = scalar.valid_range_exclusive(bx.cx);\n+                                let er = scalar.valid_range_exclusive(bx.cx());\n                                 if er.end != er.start &&\n                                    scalar.valid_range.end() > scalar.valid_range.start() {\n                                     // We want `table[e as usize]` to not\n@@ -367,7 +367,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             (CastTy::FnPtr, CastTy::Int(_)) =>\n                                 bx.ptrtoint(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                let usize_llval = bx.intcast(llval, bx.cx.isize_ty, signed);\n+                                let usize_llval = bx.intcast(llval, bx.cx().isize_ty, signed);\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Int(_), CastTy::Float) =>\n@@ -394,7 +394,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 // Note: places are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                let val = if !bx.cx.type_has_metadata(ty) {\n+                let val = if !bx.cx().type_has_metadata(ty) {\n                     OperandValue::Immediate(cg_place.llval)\n                 } else {\n                     OperandValue::Pair(cg_place.llval, cg_place.llextra.unwrap())\n@@ -412,7 +412,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 let size = self.evaluate_array_len(&bx, place);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n-                    layout: bx.cx.layout_of(bx.tcx().types.usize),\n+                    layout: bx.cx().layout_of(bx.tcx().types.usize),\n                 };\n                 (bx, operand)\n             }\n@@ -438,7 +438,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    layout: bx.cx.layout_of(\n+                    layout: bx.cx().layout_of(\n                         op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty)),\n                 };\n                 (bx, operand)\n@@ -453,7 +453,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 let operand_ty = bx.tcx().intern_tup(&[val_ty, bx.tcx().types.bool]);\n                 let operand = OperandRef {\n                     val: result,\n-                    layout: bx.cx.layout_of(operand_ty)\n+                    layout: bx.cx().layout_of(operand_ty)\n                 };\n \n                 (bx, operand)\n@@ -488,8 +488,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(bx.cx.type_is_sized(ty));\n-                let val = CodegenCx::c_usize(bx.cx, bx.cx.size_of(ty).bytes());\n+                assert!(bx.cx().type_is_sized(ty));\n+                let val = CodegenCx::c_usize(bx.cx(), bx.cx().size_of(ty).bytes());\n                 let tcx = bx.tcx();\n                 (bx, OperandRef {\n                     val: OperandValue::Immediate(val),\n@@ -499,11 +499,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let (size, align) = bx.cx.size_and_align_of(content_ty);\n-                let llsize = CodegenCx::c_usize(bx.cx, size.bytes());\n-                let llalign = CodegenCx::c_usize(bx.cx, align.abi());\n-                let box_layout = bx.cx.layout_of(bx.tcx().mk_box(content_ty));\n-                let llty_ptr = box_layout.llvm_type(bx.cx);\n+                let (size, align) = bx.cx().size_and_align_of(content_ty);\n+                let llsize = CodegenCx::c_usize(bx.cx(), size.bytes());\n+                let llalign = CodegenCx::c_usize(bx.cx(), align.abi());\n+                let box_layout = bx.cx().layout_of(bx.tcx().mk_box(content_ty));\n+                let llty_ptr = box_layout.llvm_type(bx.cx());\n \n                 // Allocate space:\n                 let def_id = match bx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n@@ -513,7 +513,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     }\n                 };\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let r = callee::get_fn(bx.cx, instance);\n+                let r = callee::get_fn(bx.cx(), instance);\n                 let val = bx.pointercast(bx.call(r, &[llsize, llalign], None), llty_ptr);\n \n                 let operand = OperandRef {\n@@ -547,14 +547,14 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {\n-                    let n = n.unwrap_usize(bx.cx.tcx);\n-                    return CodegenCx::c_usize(bx.cx, n);\n+                    let n = n.unwrap_usize(bx.cx().tcx);\n+                    return CodegenCx::c_usize(bx.cx(), n);\n                 }\n             }\n         }\n         // use common size calculation for non zero-sized types\n         let cg_value = self.codegen_place(&bx, place);\n-        return cg_value.len(bx.cx);\n+        return cg_value.len(bx.cx());\n     }\n \n     pub fn codegen_scalar_binop(\n@@ -606,7 +606,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::BinOp::Shr => common::build_unchecked_rshift(bx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_unit {\n-                CodegenCx::c_bool(bx.cx, match op {\n+                CodegenCx::c_bool(bx.cx(), match op {\n                     mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n                     mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n                     _ => unreachable!()\n@@ -683,9 +683,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n-        if !bx.cx.check_overflow {\n+        if !bx.cx().check_overflow {\n             let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, CodegenCx::c_bool(bx.cx, false));\n+            return OperandValue::Pair(val, CodegenCx::c_bool(bx.cx(), false));\n         }\n \n         let (val, of) = match op {\n@@ -817,7 +817,7 @@ fn get_overflow_intrinsic(\n         },\n     };\n \n-    bx.cx.get_intrinsic(&name)\n+    bx.cx().get_intrinsic(&name)\n }\n \n fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n@@ -838,7 +838,7 @@ fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n                                             << (Single::MAX_EXP - Single::PRECISION as i16);\n         let max = CodegenCx::c_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bx.icmp(IntPredicate::IntUGE, x, max);\n-        let infinity_bits = CodegenCx::c_u32(bx.cx, ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity_bits = CodegenCx::c_u32(bx.cx(), ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);\n         bx.select(overflow, infinity, bx.uitofp(x, float_ty))\n     } else {\n@@ -907,8 +907,8 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     }\n     let float_bits_to_llval = |bits| {\n         let bits_llval = match float_ty.float_width() {\n-            32 => CodegenCx::c_u32(bx.cx, bits as u32),\n-            64 => CodegenCx::c_u64(bx.cx, bits as u64),\n+            32 => CodegenCx::c_u32(bx.cx(), bits as u32),\n+            64 => CodegenCx::c_u64(bx.cx(), bits as u64),\n             n => bug!(\"unsupported float width {}\", n),\n         };\n         consts::bitcast(bits_llval, float_ty)"}]}