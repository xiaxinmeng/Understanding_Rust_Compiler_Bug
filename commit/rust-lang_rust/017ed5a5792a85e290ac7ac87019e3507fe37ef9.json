{"sha": "017ed5a5792a85e290ac7ac87019e3507fe37ef9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxN2VkNWE1NzkyYTg1ZTI5MGFjN2FjODcwMTllMzUwN2ZlMzdlZjk=", "commit": {"author": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-08-28T02:32:28Z"}, "committer": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-08-28T02:32:28Z"}, "message": "Improvements to `LineWriter::write_all`\n\n`LineWriter::write_all` now only emits a single write when writing a\nnewline when there's already buffered data.", "tree": {"sha": "41169dc616349fe3dcaa4be7d32c8b202cf70a20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41169dc616349fe3dcaa4be7d32c8b202cf70a20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/017ed5a5792a85e290ac7ac87019e3507fe37ef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/017ed5a5792a85e290ac7ac87019e3507fe37ef9", "html_url": "https://github.com/rust-lang/rust/commit/017ed5a5792a85e290ac7ac87019e3507fe37ef9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/017ed5a5792a85e290ac7ac87019e3507fe37ef9/comments", "author": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aa233d3dc0ad43f8693e4638e33e81ddf03b96b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aa233d3dc0ad43f8693e4638e33e81ddf03b96b", "html_url": "https://github.com/rust-lang/rust/commit/3aa233d3dc0ad43f8693e4638e33e81ddf03b96b"}], "stats": {"total": 105, "additions": 79, "deletions": 26}, "files": [{"sha": "20eaeb57ad6d38a24779ca1001a0990837d49e02", "filename": "library/std/src/io/buffered.rs", "status": "modified", "additions": 79, "deletions": 26, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/017ed5a5792a85e290ac7ac87019e3507fe37ef9/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/017ed5a5792a85e290ac7ac87019e3507fe37ef9/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs?ref=017ed5a5792a85e290ac7ac87019e3507fe37ef9", "patch": "@@ -527,7 +527,8 @@ impl<W: Write> BufWriter<W> {\n     /// errors from this method.\n     fn flush_buf(&mut self) -> io::Result<()> {\n         /// Helper struct to ensure the buffer is updated after all the writes\n-        /// are complete\n+        /// are complete. It tracks the number of written bytes and drains them\n+        /// all from the front of the buffer when dropped.\n         struct BufGuard<'a> {\n             buffer: &'a mut Vec<u8>,\n             written: usize,\n@@ -942,12 +943,13 @@ impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n     /// success, the remaining data will be buffered.\n     ///\n     /// Because this function attempts to send completed lines to the underlying\n-    /// writer, it will also flush the existing buffer if it contains any\n-    /// newlines, even if the incoming data does not contain any newlines.\n+    /// writer, it will also flush the existing buffer if it ends with a\n+    /// newline, even if the incoming data does not contain any newlines.\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let newline_idx = match memchr::memrchr(b'\\n', buf) {\n             // If there are no new newlines (that is, if this write is less than\n-            // one line), just do a regular buffered write\n+            // one line), just do a regular buffered write (which may flush if\n+            // we exceed the inner buffer's size)\n             None => {\n                 self.flush_if_completed_line()?;\n                 return self.buffer.write(buf);\n@@ -957,7 +959,11 @@ impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n             Some(newline_idx) => newline_idx + 1,\n         };\n \n-        // Flush existing content to prepare for our write\n+        // Flush existing content to prepare for our write. We have to do this\n+        // before attempting to write `buf` in order to maintain consistency;\n+        // if we add `buf` to the buffer then try to flush it all at once,\n+        // we're obligated to return Ok(), which would mean supressing any\n+        // errors that occur during flush.\n         self.buffer.flush_buf()?;\n \n         // This is what we're going to try to write directly to the inner\n@@ -1121,32 +1127,33 @@ impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n     /// writer, it will also flush the existing buffer if it contains any\n     /// newlines, even if the incoming data does not contain any newlines.\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n+        match memchr::memrchr(b'\\n', buf) {\n             // If there are no new newlines (that is, if this write is less than\n-            // one line), just do a regular buffered write\n+            // one line), just do a regular buffered write (which may flush if\n+            // we exceed the inner buffer's size)\n             None => {\n                 self.flush_if_completed_line()?;\n-                return self.buffer.write_all(buf);\n+                self.buffer.write_all(buf)\n             }\n-            // Otherwise, arrange for the lines to be written directly to the\n-            // inner writer.\n-            Some(newline_idx) => newline_idx,\n-        };\n-\n-        // Flush existing content to prepare for our write\n-        self.buffer.flush_buf()?;\n+            Some(newline_idx) => {\n+                let (lines, tail) = buf.split_at(newline_idx + 1);\n \n-        // This is what we're going to try to write directly to the inner\n-        // writer. The rest will be buffered, if nothing goes wrong.\n-        let (lines, tail) = buf.split_at(newline_idx + 1);\n-\n-        // Write `lines` directly to the inner writer, bypassing the buffer.\n-        self.inner_mut().write_all(lines)?;\n+                if self.buffered().is_empty() {\n+                    self.inner_mut().write_all(lines)?;\n+                } else {\n+                    // If there is any buffered data, we add the incoming lines\n+                    // to that buffer before flushing, which saves us at lease\n+                    // one write call. We can't really do this with `write`,\n+                    // since we can't do this *and* not suppress errors *and*\n+                    // report a consistent state to the caller in a return\n+                    // value, but here in write_all it's fine.\n+                    self.buffer.write_all(lines)?;\n+                    self.buffer.flush_buf()?;\n+                }\n \n-        // Now that the write has succeeded, buffer the rest with\n-        // BufWriter::write_all. This will buffer as much as possible, but\n-        // continue flushing as necessary if our tail is huge.\n-        self.buffer.write_all(tail)\n+                self.buffer.write_all(tail)\n+            }\n+        }\n     }\n }\n \n@@ -1401,7 +1408,11 @@ mod tests {\n     // rustfmt-on-save.\n     impl Read for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-            if self.lengths.is_empty() { Ok(0) } else { Ok(self.lengths.remove(0)) }\n+            if self.lengths.is_empty() {\n+                Ok(0)\n+            } else {\n+                Ok(self.lengths.remove(0))\n+            }\n         }\n     }\n \n@@ -2260,4 +2271,46 @@ mod tests {\n         writer.flush().unwrap();\n         assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\");\n     }\n+\n+    #[derive(Debug, Clone, PartialEq, Eq)]\n+    enum RecordedEvent {\n+        Write(String),\n+        Flush,\n+    }\n+\n+    #[derive(Debug, Clone, Default)]\n+    struct WriteRecorder {\n+        pub events: Vec<RecordedEvent>,\n+    }\n+\n+    impl Write for WriteRecorder {\n+        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+            use crate::str::from_utf8;\n+\n+            self.events.push(RecordedEvent::Write(from_utf8(buf).unwrap().to_string()));\n+            Ok(buf.len())\n+        }\n+\n+        fn flush(&mut self) -> io::Result<()> {\n+            self.events.push(RecordedEvent::Flush);\n+            Ok(())\n+        }\n+    }\n+\n+    /// Test that a normal, formatted writeln only results in a single write\n+    /// call to the underlying writer. A naive implementaton of\n+    /// LineWriter::write_all results in two writes: one of the buffered data,\n+    /// and another of the final substring in the formatted set\n+    #[test]\n+    fn single_formatted_write() {\n+        let writer = WriteRecorder::default();\n+        let mut writer = LineWriter::new(writer);\n+\n+        // Under a naive implementation of LineWriter, this will result in two\n+        // writes: \"hello, world\" and \"!\\n\", because write() has to flush the\n+        // buffer before attempting to write the last \"!\\n\". write_all shouldn't\n+        // have this limitation.\n+        writeln!(&mut writer, \"{}, {}!\", \"hello\", \"world\").unwrap();\n+        assert_eq!(writer.get_ref().events, [RecordedEvent::Write(\"hello, world!\\n\".to_string())]);\n+    }\n }"}]}