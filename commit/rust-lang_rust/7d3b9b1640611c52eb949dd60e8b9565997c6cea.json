{"sha": "7d3b9b1640611c52eb949dd60e8b9565997c6cea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkM2I5YjE2NDA2MTFjNTJlYjk0OWRkNjBlOGI5NTY1OTk3YzZjZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-14T22:15:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-14T22:15:35Z"}, "message": "Auto merge of #55939 - alexcrichton:path-regression-again, r=sfackler\n\nstd: Synchronize access to global env during `exec`\n\nThis commit, after reverting #55359, applies a different fix for #46775\nwhile also fixing #55775. The basic idea was to go back to pre-#55359\nlibstd, and then fix #46775 in a way that doesn't expose #55775.\n\nThe issue described in #46775 boils down to two problems:\n\n* First, the global environment is reset during `exec` but, but if the\n  `exec` call fails then the global environment was a dangling pointer\n  into free'd memory as the block of memory was deallocated when\n  `Command` is dropped. This is fixed in this commit by installing a\n  `Drop` stack object which ensures that the `environ` pointer is\n  preserved on a failing `exec`.\n\n* Second, the global environment was accessed in an unsynchronized\n  fashion during `exec`. This was fixed by ensuring that the\n  Rust-specific environment lock is acquired for these system-level\n  operations.\n\nThanks to Alex Gaynor for pioneering the solution here!\n\nCloses #55775", "tree": {"sha": "d3552eba9d6620737255fbd531988b7908b03c53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3552eba9d6620737255fbd531988b7908b03c53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d3b9b1640611c52eb949dd60e8b9565997c6cea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d3b9b1640611c52eb949dd60e8b9565997c6cea", "html_url": "https://github.com/rust-lang/rust/commit/7d3b9b1640611c52eb949dd60e8b9565997c6cea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d3b9b1640611c52eb949dd60e8b9565997c6cea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f93e93af6f823948cc13d2938957757c6486d88", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f93e93af6f823948cc13d2938957757c6486d88", "html_url": "https://github.com/rust-lang/rust/commit/6f93e93af6f823948cc13d2938957757c6486d88"}, {"sha": "4032b7a429462ece781629cab9f785742991ebef", "url": "https://api.github.com/repos/rust-lang/rust/commits/4032b7a429462ece781629cab9f785742991ebef", "html_url": "https://github.com/rust-lang/rust/commit/4032b7a429462ece781629cab9f785742991ebef"}], "stats": {"total": 189, "additions": 83, "deletions": 106}, "files": [{"sha": "b387a8d59a56d1b10b028cc1f8f423d5e657877c", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b9b1640611c52eb949dd60e8b9565997c6cea/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b9b1640611c52eb949dd60e8b9565997c6cea/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=7d3b9b1640611c52eb949dd60e8b9565997c6cea", "patch": "@@ -27,15 +27,12 @@ use path::{self, PathBuf};\n use ptr;\n use slice;\n use str;\n-use sys_common::mutex::Mutex;\n+use sys_common::mutex::{Mutex, MutexGuard};\n use sys::cvt;\n use sys::fd;\n use vec;\n \n const TMPBUF_SZ: usize = 128;\n-// We never call `ENV_LOCK.init()`, so it is UB to attempt to\n-// acquire this mutex reentrantly!\n-static ENV_LOCK: Mutex = Mutex::new();\n \n \n extern {\n@@ -408,11 +405,18 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n+pub unsafe fn env_lock() -> MutexGuard<'static> {\n+    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n+    // acquire this mutex reentrantly!\n+    static ENV_LOCK: Mutex = Mutex::new();\n+    ENV_LOCK.lock()\n+}\n+\n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n     unsafe {\n-        let _guard = ENV_LOCK.lock();\n+        let _guard = env_lock();\n         let mut environ = *environ();\n         let mut result = Vec::new();\n         while environ != ptr::null() && *environ != ptr::null() {\n@@ -448,7 +452,7 @@ pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     // always None as well\n     let k = CString::new(k.as_bytes())?;\n     unsafe {\n-        let _guard = ENV_LOCK.lock();\n+        let _guard = env_lock();\n         let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n         let ret = if s.is_null() {\n             None\n@@ -464,7 +468,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let v = CString::new(v.as_bytes())?;\n \n     unsafe {\n-        let _guard = ENV_LOCK.lock();\n+        let _guard = env_lock();\n         cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(|_| ())\n     }\n }\n@@ -473,7 +477,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let nbuf = CString::new(n.as_bytes())?;\n \n     unsafe {\n-        let _guard = ENV_LOCK.lock();\n+        let _guard = env_lock();\n         cvt(libc::unsetenv(nbuf.as_ptr())).map(|_| ())\n     }\n }"}, {"sha": "77f125f3c5b569b2b9597592f09a53a116149cd9", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b9b1640611c52eb949dd60e8b9565997c6cea/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b9b1640611c52eb949dd60e8b9565997c6cea/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=7d3b9b1640611c52eb949dd60e8b9565997c6cea", "patch": "@@ -141,10 +141,6 @@ impl Command {\n     pub fn get_argv(&self) -> &Vec<*const c_char> {\n         &self.argv.0\n     }\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn get_program(&self) -> &CString {\n-        return &self.program;\n-    }\n \n     #[allow(dead_code)]\n     pub fn get_cwd(&self) -> &Option<CString> {\n@@ -248,10 +244,6 @@ impl CStringArray {\n     pub fn as_ptr(&self) -> *const *const c_char {\n         self.ptrs.as_ptr()\n     }\n-    #[cfg(not(target_os = \"fuchsia\"))]\n-    pub fn get_items(&self) -> &[CString] {\n-        return &self.items;\n-    }\n }\n \n fn construct_envp(env: BTreeMap<DefaultEnvKey, OsString>, saw_nul: &mut bool) -> CStringArray {"}, {"sha": "bfbf12f34ee37d261b7ff90a8efad1fa0c32b00c", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 47, "deletions": 90, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b9b1640611c52eb949dd60e8b9565997c6cea/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b9b1640611c52eb949dd60e8b9565997c6cea/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=7d3b9b1640611c52eb949dd60e8b9565997c6cea", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use env;\n-use ffi::CString;\n use io::{self, Error, ErrorKind};\n use libc::{self, c_int, gid_t, pid_t, uid_t};\n use ptr;\n-\n use sys::cvt;\n use sys::process::process_common::*;\n+use sys;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -24,8 +22,6 @@ use sys::process::process_common::*;\n impl Command {\n     pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n-        use sys;\n-\n         const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n         let envp = self.capture_env();\n@@ -41,15 +37,26 @@ impl Command {\n             return Ok((ret, ours))\n         }\n \n-        let possible_paths = self.compute_possible_paths(envp.as_ref());\n-\n         let (input, output) = sys::pipe::anon_pipe()?;\n \n+        // Whatever happens after the fork is almost for sure going to touch or\n+        // look at the environment in one way or another (PATH in `execvp` or\n+        // accessing the `environ` pointer ourselves). Make sure no other thread\n+        // is accessing the environment when we do the fork itself.\n+        //\n+        // Note that as soon as we're done with the fork there's no need to hold\n+        // a lock any more because the parent won't do anything and the child is\n+        // in its own process.\n+        let result = unsafe {\n+            let _env_lock = sys::os::env_lock();\n+            cvt(libc::fork())?\n+        };\n+\n         let pid = unsafe {\n-            match cvt(libc::fork())? {\n+            match result {\n                 0 => {\n                     drop(input);\n-                    let err = self.do_exec(theirs, envp.as_ref(), possible_paths);\n+                    let err = self.do_exec(theirs, envp.as_ref());\n                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n@@ -117,46 +124,19 @@ impl Command {\n                                   \"nul byte found in provided data\")\n         }\n \n-        let possible_paths = self.compute_possible_paths(envp.as_ref());\n         match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs, envp.as_ref(), possible_paths) },\n-            Err(e) => e,\n-        }\n-    }\n+            Ok((_, theirs)) => {\n+                unsafe {\n+                    // Similar to when forking, we want to ensure that access to\n+                    // the environment is synchronized, so make sure to grab the\n+                    // environment lock before we try to exec.\n+                    let _lock = sys::os::env_lock();\n \n-    fn compute_possible_paths(&self, maybe_envp: Option<&CStringArray>) -> Option<Vec<CString>> {\n-        let program = self.get_program().as_bytes();\n-        if program.contains(&b'/') {\n-            return None;\n-        }\n-        // Outside the match so we can borrow it for the lifetime of the function.\n-        let parent_path = env::var(\"PATH\").ok();\n-        let paths = match maybe_envp {\n-            Some(envp) => {\n-                match envp.get_items().iter().find(|var| var.as_bytes().starts_with(b\"PATH=\")) {\n-                    Some(p) => &p.as_bytes()[5..],\n-                    None => return None,\n-                }\n-            },\n-            // maybe_envp is None if the process isn't changing the parent's env at all.\n-            None => {\n-                match parent_path.as_ref() {\n-                    Some(p) => p.as_bytes(),\n-                    None => return None,\n+                    self.do_exec(theirs, envp.as_ref())\n                 }\n-            },\n-        };\n-\n-        let mut possible_paths = vec![];\n-        for path in paths.split(|p| *p == b':') {\n-            let mut binary_path = Vec::with_capacity(program.len() + path.len() + 1);\n-            binary_path.extend_from_slice(path);\n-            binary_path.push(b'/');\n-            binary_path.extend_from_slice(program);\n-            let c_binary_path = CString::new(binary_path).unwrap();\n-            possible_paths.push(c_binary_path);\n+            }\n+            Err(e) => e,\n         }\n-        return Some(possible_paths);\n     }\n \n     // And at this point we've reached a special time in the life of the\n@@ -192,8 +172,7 @@ impl Command {\n     unsafe fn do_exec(\n         &mut self,\n         stdio: ChildPipes,\n-        maybe_envp: Option<&CStringArray>,\n-        maybe_possible_paths: Option<Vec<CString>>,\n+        maybe_envp: Option<&CStringArray>\n     ) -> io::Error {\n         use sys::{self, cvt_r};\n \n@@ -269,53 +248,29 @@ impl Command {\n             t!(callback());\n         }\n \n-        // If the program isn't an absolute path, and our environment contains a PATH var, then we\n-        // implement the PATH traversal ourselves so that it honors the child's PATH instead of the\n-        // parent's. This mirrors the logic that exists in glibc's execvpe, except using the\n-        // child's env to fetch PATH.\n-        match maybe_possible_paths {\n-            Some(possible_paths) => {\n-                let mut pending_error = None;\n-                for path in possible_paths {\n-                    libc::execve(\n-                        path.as_ptr(),\n-                        self.get_argv().as_ptr(),\n-                        maybe_envp.map(|envp| envp.as_ptr()).unwrap_or_else(|| *sys::os::environ())\n-                    );\n-                    let err = io::Error::last_os_error();\n-                    match err.kind() {\n-                        io::ErrorKind::PermissionDenied => {\n-                            // If we saw a PermissionDenied, and none of the other entries in\n-                            // $PATH are successful, then we'll return the first EACCESS we see.\n-                            if pending_error.is_none() {\n-                                pending_error = Some(err);\n-                            }\n-                        },\n-                        // Errors which indicate we failed to find a file are ignored and we try\n-                        // the next entry in the path.\n-                        io::ErrorKind::NotFound | io::ErrorKind::TimedOut => {\n-                            continue\n-                        },\n-                        // Any other error means we found a file and couldn't execute it.\n-                        _ => {\n-                            return err;\n-                        }\n+        // Although we're performing an exec here we may also return with an\n+        // error from this function (without actually exec'ing) in which case we\n+        // want to be sure to restore the global environment back to what it\n+        // once was, ensuring that our temporary override, when free'd, doesn't\n+        // corrupt our process's environment.\n+        let mut _reset = None;\n+        if let Some(envp) = maybe_envp {\n+            struct Reset(*const *const libc::c_char);\n+\n+            impl Drop for Reset {\n+                fn drop(&mut self) {\n+                    unsafe {\n+                        *sys::os::environ() = self.0;\n                     }\n                 }\n-                if let Some(err) = pending_error {\n-                    return err;\n-                }\n-                return io::Error::from_raw_os_error(libc::ENOENT);\n-            },\n-            _ => {\n-                libc::execve(\n-                    self.get_argv()[0],\n-                    self.get_argv().as_ptr(),\n-                    maybe_envp.map(|envp| envp.as_ptr()).unwrap_or_else(|| *sys::os::environ())\n-                );\n-                return io::Error::last_os_error()\n             }\n+\n+            _reset = Some(Reset(*sys::os::environ()));\n+            *sys::os::environ() = envp.as_ptr();\n         }\n+\n+        libc::execvp(self.get_argv()[0], self.get_argv().as_ptr());\n+        io::Error::last_os_error()\n     }\n \n     #[cfg(not(any(target_os = \"macos\", target_os = \"freebsd\",\n@@ -413,6 +368,8 @@ impl Command {\n                 libc::POSIX_SPAWN_SETSIGMASK;\n             cvt(libc::posix_spawnattr_setflags(&mut attrs.0, flags as _))?;\n \n+            // Make sure we synchronize access to the global `environ` resource\n+            let _env_lock = sys::os::env_lock();\n             let envp = envp.map(|c| c.as_ptr())\n                 .unwrap_or_else(|| *sys::os::environ() as *const _);\n             let ret = libc::posix_spawnp("}, {"sha": "f662945c0cf3df600f1475332dc68b650357b10d", "filename": "src/test/run-pass/command-exec.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d3b9b1640611c52eb949dd60e8b9565997c6cea/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3b9b1640611c52eb949dd60e8b9565997c6cea/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-exec.rs?ref=7d3b9b1640611c52eb949dd60e8b9565997c6cea", "patch": "@@ -55,6 +55,16 @@ fn main() {\n                 println!(\"passed\");\n             }\n \n+            \"exec-test6\" => {\n+                let err = Command::new(\"echo\").arg(\"passed\").env_clear().exec();\n+                panic!(\"failed to spawn: {}\", err);\n+            }\n+\n+            \"exec-test7\" => {\n+                let err = Command::new(\"echo\").arg(\"passed\").env_remove(\"PATH\").exec();\n+                panic!(\"failed to spawn: {}\", err);\n+            }\n+\n             _ => panic!(\"unknown argument: {}\", arg),\n         }\n         return\n@@ -84,4 +94,18 @@ fn main() {\n     assert!(output.status.success());\n     assert!(output.stderr.is_empty());\n     assert_eq!(output.stdout, b\"passed\\n\");\n+\n+    if cfg!(target_os = \"linux\") {\n+        let output = Command::new(&me).arg(\"exec-test6\").output().unwrap();\n+        println!(\"{:?}\", output);\n+        assert!(output.status.success());\n+        assert!(output.stderr.is_empty());\n+        assert_eq!(output.stdout, b\"passed\\n\");\n+\n+        let output = Command::new(&me).arg(\"exec-test7\").output().unwrap();\n+        println!(\"{:?}\", output);\n+        assert!(output.status.success());\n+        assert!(output.stderr.is_empty());\n+        assert_eq!(output.stdout, b\"passed\\n\");\n+    }\n }"}]}