{"sha": "a736acc80459734a7c5490f25c70600eff802961", "node_id": "C_kwDOAAsO6NoAKGE3MzZhY2M4MDQ1OTczNGE3YzU0OTBmMjVjNzA2MDBlZmY4MDI5NjE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-06T12:34:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-06T12:34:55Z"}, "message": "Rollup merge of #97312 - cjgillot:no-path-in-scope, r=compiler-errors\n\nCompute lifetimes in scope at diagnostic time\n\nThe set of available lifetimes is currently computed during lifetime resolution on HIR.  It is only used for one diagnostic.\n\nIn this PR, HIR lifetime resolution just reports whether elided lifetimes are well-defined at the place of use.  The diagnostic code is responsible for building a list of lifetime names if elision is not allowed.\n\nThis will allow to remove lifetime resolution on HIR eventually.", "tree": {"sha": "9d085359293763adfa1aeb4003bdac88ef1a3eb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d085359293763adfa1aeb4003bdac88ef1a3eb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a736acc80459734a7c5490f25c70600eff802961", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJinfRvCRBK7hj4Ov3rIwAAUn4IAE0KaxmtusnPfz9zH+K8Q/wz\nVqZRxyYhsCfy4vHjXA4BpXPyrOuaRNF1xCnF6AsKn99hK/2dJDrtAK4TE9yqGJ++\nTeyJuQ23prWDudzxjntcJmhSXJQJ9IZhC0KBfB1ztXMRWv6TOS/hkwjYMA++vlkH\nMud36h7ZOeMioeUs7HWX35lG3D9iS5jUVscrsMvvK3+7jKgba0zrRGWDbsoEe3MQ\nsWGTQ1AWRuwYpRxvVtvWY7SsmuEWQZVMNSCxglCS+VYov3LASsyvk3+6GVXlphTR\n0qBmezFEAEG0dTLQcLOOIWBELWZT5C/eyGfDgXvmxeZR4wxmn71XZIeNJgMbRPo=\n=2Li5\n-----END PGP SIGNATURE-----\n", "payload": "tree 9d085359293763adfa1aeb4003bdac88ef1a3eb1\nparent e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd\nparent f71ad2f9920817b24a0253566f528bda845d9374\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1654518895 +0200\ncommitter GitHub <noreply@github.com> 1654518895 +0200\n\nRollup merge of #97312 - cjgillot:no-path-in-scope, r=compiler-errors\n\nCompute lifetimes in scope at diagnostic time\n\nThe set of available lifetimes is currently computed during lifetime resolution on HIR.  It is only used for one diagnostic.\n\nIn this PR, HIR lifetime resolution just reports whether elided lifetimes are well-defined at the place of use.  The diagnostic code is responsible for building a list of lifetime names if elision is not allowed.\n\nThis will allow to remove lifetime resolution on HIR eventually.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a736acc80459734a7c5490f25c70600eff802961", "html_url": "https://github.com/rust-lang/rust/commit/a736acc80459734a7c5490f25c70600eff802961", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a736acc80459734a7c5490f25c70600eff802961/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd", "html_url": "https://github.com/rust-lang/rust/commit/e70c60d34b9783a2fd3171d88d248c2e0ec8ecdd"}, {"sha": "f71ad2f9920817b24a0253566f528bda845d9374", "url": "https://api.github.com/repos/rust-lang/rust/commits/f71ad2f9920817b24a0253566f528bda845d9374", "html_url": "https://github.com/rust-lang/rust/commit/f71ad2f9920817b24a0253566f528bda845d9374"}], "stats": {"total": 333, "additions": 127, "deletions": 206}, "files": [{"sha": "4da09c4ef486ee55c0c5fd8ffbf4d2ba8685c4e3", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -313,6 +313,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_assoc_type_binding(&mut self, type_binding: &'hir TypeBinding<'hir>) {\n+        self.insert(type_binding.span, type_binding.hir_id, Node::TypeBinding(type_binding));\n+        self.with_parent(type_binding.hir_id, |this| {\n+            intravisit::walk_assoc_type_binding(this, type_binding)\n+        })\n+    }\n+\n     fn visit_trait_item_ref(&mut self, ii: &'hir TraitItemRef) {\n         // Do not visit the duplicate information in TraitItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref."}, {"sha": "9c314f67651501c3a96df15a0667551378091afc", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -3302,6 +3302,7 @@ pub enum Node<'hir> {\n     Stmt(&'hir Stmt<'hir>),\n     PathSegment(&'hir PathSegment<'hir>),\n     Ty(&'hir Ty<'hir>),\n+    TypeBinding(&'hir TypeBinding<'hir>),\n     TraitRef(&'hir TraitRef<'hir>),\n     Binding(&'hir Pat<'hir>),\n     Pat(&'hir Pat<'hir>),\n@@ -3347,6 +3348,7 @@ impl<'hir> Node<'hir> {\n             | Node::PathSegment(PathSegment { ident, .. }) => Some(*ident),\n             Node::Lifetime(lt) => Some(lt.name.ident()),\n             Node::GenericParam(p) => Some(p.name.ident()),\n+            Node::TypeBinding(b) => Some(b.ident),\n             Node::Param(..)\n             | Node::AnonConst(..)\n             | Node::Expr(..)"}, {"sha": "fb40008d60b5d1d04e761bee7b1e8785c3811ba5", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -85,6 +85,7 @@ impl<'a> State<'a> {\n             Node::Stmt(a) => self.print_stmt(&a),\n             Node::PathSegment(a) => self.print_path_segment(&a),\n             Node::Ty(a) => self.print_type(&a),\n+            Node::TypeBinding(a) => self.print_type_binding(&a),\n             Node::TraitRef(a) => self.print_trait_ref(&a),\n             Node::Binding(a) | Node::Pat(a) => self.print_pat(&a),\n             Node::Arm(a) => self.print_arm(&a),\n@@ -1703,21 +1704,7 @@ impl<'a> State<'a> {\n \n             for binding in generic_args.bindings.iter() {\n                 start_or_comma(self);\n-                self.print_ident(binding.ident);\n-                self.print_generic_args(binding.gen_args, false, false);\n-                self.space();\n-                match generic_args.bindings[0].kind {\n-                    hir::TypeBindingKind::Equality { ref term } => {\n-                        self.word_space(\"=\");\n-                        match term {\n-                            Term::Ty(ref ty) => self.print_type(ty),\n-                            Term::Const(ref c) => self.print_anon_const(c),\n-                        }\n-                    }\n-                    hir::TypeBindingKind::Constraint { bounds } => {\n-                        self.print_bounds(\":\", bounds);\n-                    }\n-                }\n+                self.print_type_binding(binding);\n             }\n \n             if !empty.get() {\n@@ -1726,6 +1713,24 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_type_binding(&mut self, binding: &hir::TypeBinding<'_>) {\n+        self.print_ident(binding.ident);\n+        self.print_generic_args(binding.gen_args, false, false);\n+        self.space();\n+        match binding.kind {\n+            hir::TypeBindingKind::Equality { ref term } => {\n+                self.word_space(\"=\");\n+                match term {\n+                    Term::Ty(ref ty) => self.print_type(ty),\n+                    Term::Const(ref c) => self.print_anon_const(c),\n+                }\n+            }\n+            hir::TypeBindingKind::Constraint { bounds } => {\n+                self.print_bounds(\":\", bounds);\n+            }\n+        }\n+    }\n+\n     pub fn print_pat(&mut self, pat: &hir::Pat<'_>) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));"}, {"sha": "ebda9f7588d5d48c40125a0c521a83b2d1aac33a", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -298,6 +298,7 @@ impl<'hir> Map<'hir> {\n             Node::Stmt(_)\n             | Node::PathSegment(_)\n             | Node::Ty(_)\n+            | Node::TypeBinding(_)\n             | Node::Infer(_)\n             | Node::TraitRef(_)\n             | Node::Pat(_)\n@@ -323,7 +324,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n-        self.find_parent_node(hir_id).unwrap()\n+        self.find_parent_node(hir_id)\n+            .unwrap_or_else(|| bug!(\"No parent for node {:?}\", self.node_to_string(hir_id)))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n@@ -973,6 +975,7 @@ impl<'hir> Map<'hir> {\n                     .with_hi(seg.args.map_or_else(|| ident_span.hi(), |args| args.span_ext.hi()))\n             }\n             Node::Ty(ty) => ty.span,\n+            Node::TypeBinding(tb) => tb.span,\n             Node::TraitRef(tr) => tr.path.span,\n             Node::Binding(pat) => pat.span,\n             Node::Pat(pat) => pat.span,\n@@ -1205,6 +1208,7 @@ fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n         Some(Node::Stmt(_)) => node_str(\"stmt\"),\n         Some(Node::PathSegment(_)) => node_str(\"path segment\"),\n         Some(Node::Ty(_)) => node_str(\"type\"),\n+        Some(Node::TypeBinding(_)) => node_str(\"type binding\"),\n         Some(Node::TraitRef(_)) => node_str(\"trait ref\"),\n         Some(Node::Binding(_)) => node_str(\"local\"),\n         Some(Node::Pat(_)) => node_str(\"pat\"),"}, {"sha": "c71ba7b175313b380419aefc385250b89e51c99e", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -16,20 +16,6 @@ pub enum Region {\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n-/// This is used in diagnostics to improve suggestions for missing generic arguments.\n-/// It gives information on the type of lifetimes that are in scope for a particular `PathSegment`,\n-/// so that we can e.g. suggest elided-lifetimes-in-paths of the form <'_, '_> e.g.\n-#[derive(Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n-pub enum LifetimeScopeForPath {\n-    /// Contains all lifetime names that are in scope and could possibly be used in generics\n-    /// arguments of path.\n-    NonElided(Vec<LocalDefId>),\n-\n-    /// Information that allows us to suggest args of the form `<'_>` in case\n-    /// no generic arguments were provided for a path.\n-    Elided,\n-}\n-\n /// A set containing, at most, one known element.\n /// If two distinct values are inserted into a set, then it\n /// becomes `Many`, which can be used to detect ambiguities."}, {"sha": "5b48f164016f7e2ea97eab165447f32583aab378", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -1599,11 +1599,6 @@ rustc_queries! {\n         desc { \"looking up late bound vars\" }\n     }\n \n-    query lifetime_scope_map(_: LocalDefId) -> Option<FxHashMap<ItemLocalId, LifetimeScopeForPath>> {\n-        storage(ArenaCacheSelector<'tcx>)\n-        desc { \"finds the lifetime scope for an HirId of a PathSegment\" }\n-    }\n-\n     query visibility(def_id: DefId) -> ty::Visibility {\n         desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern"}, {"sha": "041e5fb4bc6a9b1c0431454b3cc8c862e1f33525", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -6,7 +6,7 @@ use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath};\n+use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation, ConstValue, Scalar};\n use crate::mir::{\n@@ -2821,10 +2821,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n-    pub fn lifetime_scope(self, id: HirId) -> Option<&'tcx LifetimeScopeForPath> {\n-        self.lifetime_scope_map(id.owner).as_ref().and_then(|map| map.get(&id.local_id))\n-    }\n-\n     /// Whether the `def_id` counts as const fn in the current crate, considering all active\n     /// feature gates\n     pub fn is_const_fn(self, def_id: DefId) -> bool {"}, {"sha": "3d662ed5de4baa1e42feccd224b9b98c93cabbb0", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -6,9 +6,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::AccessLevels;\n-use crate::middle::resolve_lifetime::{\n-    LifetimeScopeForPath, ObjectLifetimeDefault, Region, ResolveLifetimes,\n-};\n+use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;"}, {"sha": "447f4174c10d5f6a0affc09459ea38b16263222a", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 97, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -8,12 +8,11 @@\n \n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc_ast::walk_list;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n-use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node};\n use rustc_hir::{GenericParamKind, HirIdMap};\n@@ -141,9 +140,6 @@ struct NamedRegionMap {\n     // - trait refs\n     // - bound types (like `T` in `for<'a> T<'a>: Foo`)\n     late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n-\n-    // maps `PathSegment` `HirId`s to lifetime scopes.\n-    scope_for_path: Option<FxHashMap<LocalDefId, FxHashMap<ItemLocalId, LifetimeScopeForPath>>>,\n }\n \n pub(crate) struct LifetimeContext<'a, 'tcx> {\n@@ -362,10 +358,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n             _ => None,\n         },\n         late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n-        lifetime_scope_map: |tcx, id| {\n-            let item_id = item_for(tcx, id);\n-            do_resolve(tcx, item_id, false, true).scope_for_path.unwrap().remove(&id)\n-        },\n \n         ..*providers\n     };\n@@ -406,29 +398,25 @@ fn resolve_lifetimes_trait_definition(\n     tcx: TyCtxt<'_>,\n     local_def_id: LocalDefId,\n ) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, true, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, true))\n }\n \n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[tracing::instrument(level = \"debug\", skip(tcx))]\n fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, false, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, false))\n }\n \n fn do_resolve(\n     tcx: TyCtxt<'_>,\n     local_def_id: LocalDefId,\n     trait_definition_only: bool,\n-    with_scope_for_path: bool,\n ) -> NamedRegionMap {\n     let item = tcx.hir().expect_item(local_def_id);\n-    let mut named_region_map = NamedRegionMap {\n-        defs: Default::default(),\n-        late_bound_vars: Default::default(),\n-        scope_for_path: with_scope_for_path.then(|| Default::default()),\n-    };\n+    let mut named_region_map =\n+        NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n     let mut visitor = LifetimeContext {\n         tcx,\n         map: &mut named_region_map,\n@@ -524,38 +512,6 @@ fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::\n     }\n }\n \n-#[tracing::instrument(level = \"debug\")]\n-fn get_lifetime_scopes_for_path(mut scope: &Scope<'_>) -> LifetimeScopeForPath {\n-    let mut available_lifetimes = vec![];\n-    loop {\n-        match scope {\n-            Scope::Binder { lifetimes, s, .. } => {\n-                available_lifetimes.extend(lifetimes.keys());\n-                scope = s;\n-            }\n-            Scope::Body { s, .. } => {\n-                scope = s;\n-            }\n-            Scope::Elision { elide, s } => {\n-                if let Elide::Exact(_) = elide {\n-                    return LifetimeScopeForPath::Elided;\n-                } else {\n-                    scope = s;\n-                }\n-            }\n-            Scope::ObjectLifetimeDefault { s, .. } => {\n-                scope = s;\n-            }\n-            Scope::Root => {\n-                return LifetimeScopeForPath::NonElided(available_lifetimes);\n-            }\n-            Scope::Supertrait { s, .. } | Scope::TraitRefBoundary { s, .. } => {\n-                scope = s;\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n     fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n@@ -1202,53 +1158,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_assoc_type_binding(&mut self, type_binding: &'tcx hir::TypeBinding<'_>) {\n-        let scope = self.scope;\n-        if let Some(scope_for_path) = self.map.scope_for_path.as_mut() {\n-            // We add lifetime scope information for `Ident`s in associated type bindings and use\n-            // the `HirId` of the type binding as the key in `LifetimeMap`\n-            let lifetime_scope = get_lifetime_scopes_for_path(scope);\n-            let map = scope_for_path.entry(type_binding.hir_id.owner).or_default();\n-            map.insert(type_binding.hir_id.local_id, lifetime_scope);\n-        }\n-        hir::intravisit::walk_assoc_type_binding(self, type_binding);\n-    }\n-\n     fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(ref args) = segment.args {\n                 self.visit_segment_args(path.res, depth, args);\n             }\n-\n-            let scope = self.scope;\n-            if let Some(scope_for_path) = self.map.scope_for_path.as_mut() {\n-                // Add lifetime scope information to path segment. Note we cannot call `visit_path_segment`\n-                // here because that call would yield to resolution problems due to `walk_path_segment`\n-                // being called, which processes the path segments generic args, which we have already\n-                // processed using `visit_segment_args`.\n-                let lifetime_scope = get_lifetime_scopes_for_path(scope);\n-                if let Some(hir_id) = segment.hir_id {\n-                    let map = scope_for_path.entry(hir_id.owner).or_default();\n-                    map.insert(hir_id.local_id, lifetime_scope);\n-                }\n-            }\n         }\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'tcx hir::PathSegment<'tcx>) {\n-        let scope = self.scope;\n-        if let Some(scope_for_path) = self.map.scope_for_path.as_mut() {\n-            let lifetime_scope = get_lifetime_scopes_for_path(scope);\n-            if let Some(hir_id) = path_segment.hir_id {\n-                let map = scope_for_path.entry(hir_id.owner).or_default();\n-                map.insert(hir_id.local_id, lifetime_scope);\n-            }\n-        }\n-\n-        intravisit::walk_path_segment(self, path_span, path_segment);\n-    }\n-\n     fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl<'tcx>) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n@@ -2227,6 +2145,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n             Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => None,\n+\n+            Node::TypeBinding(_) if let Node::TraitRef(_) = self.tcx.hir().get(self.tcx.hir().get_parent_node(parent)) => None,\n+\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {\n@@ -2548,16 +2469,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        // If we specifically need the `scope_for_path` map, then we're in the\n-        // diagnostic pass and we don't want to emit more errors.\n-        if self.map.scope_for_path.is_some() {\n-            self.tcx.sess.delay_span_bug(\n-                rustc_span::DUMMY_SP,\n-                \"Encountered unexpected errors during diagnostics related part\",\n-            );\n-            return;\n-        }\n-\n         let mut spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n         spans.sort();\n         let mut spans_dedup = spans.clone();"}, {"sha": "58b63804b4a4ed18cb53db0b81cf70d4a8d6de5c", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -249,6 +249,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n                 | hir::Node::Stmt(..)\n                 | hir::Node::PathSegment(..)\n                 | hir::Node::Ty(..)\n+                | hir::Node::TypeBinding(..)\n                 | hir::Node::TraitRef(..)\n                 | hir::Node::Binding(..)\n                 | hir::Node::Pat(..)"}, {"sha": "2433401b7f0f5f5502ffc4eff0370a285832a7ee", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -450,21 +450,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     .discr_type()\n                     .to_ty(tcx),\n \n-                Node::TraitRef(trait_ref @ &TraitRef {\n-                  path, ..\n-                }) if let Some((binding, seg)) =\n-                  path\n-                      .segments\n-                      .iter()\n-                      .find_map(|seg| {\n-                          seg.args?.bindings\n-                              .iter()\n-                              .find_map(|binding| if binding.opt_const()?.hir_id == hir_id {\n-                                Some((binding, seg))\n-                              } else {\n-                                None\n-                              })\n-                      }) =>\n+                Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, ..  })\n+                    if let Node::TraitRef(trait_ref) = tcx.hir().get(\n+                        tcx.hir().get_parent_node(binding_id)\n+                    ) =>\n                 {\n                   let Some(trait_def_id) = trait_ref.trait_def_id() else {\n                     return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");"}, {"sha": "c440e93fe0af1fdd3b516663b7faea8224113173", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 67, "deletions": 40, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -5,7 +5,6 @@ use rustc_errors::{\n };\n use rustc_hir as hir;\n use rustc_middle::hir::map::fn_sig;\n-use rustc_middle::middle::resolve_lifetime::LifetimeScopeForPath;\n use rustc_middle::ty::{self as ty, AssocItems, AssocKind, TyCtxt};\n use rustc_session::Session;\n use rustc_span::def_id::DefId;\n@@ -291,7 +290,69 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     }\n \n     // Creates lifetime name suggestions from the lifetime parameter names\n-    fn get_lifetime_args_suggestions_from_param_names(&self, num_params_to_take: usize) -> String {\n+    fn get_lifetime_args_suggestions_from_param_names(\n+        &self,\n+        path_hir_id: Option<hir::HirId>,\n+        num_params_to_take: usize,\n+    ) -> String {\n+        debug!(?path_hir_id);\n+\n+        if let Some(path_hir_id) = path_hir_id {\n+            let mut ret = Vec::new();\n+            for (id, node) in self.tcx.hir().parent_iter(path_hir_id) {\n+                debug!(?id);\n+                let params = if let Some(generics) = node.generics() {\n+                    generics.params\n+                } else if let hir::Node::Ty(ty) = node\n+                    && let hir::TyKind::BareFn(bare_fn) = ty.kind\n+                {\n+                    bare_fn.generic_params\n+                } else {\n+                    &[]\n+                };\n+                ret.extend(params.iter().filter_map(|p| {\n+                    let hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit }\n+                        = p.kind\n+                    else { return None };\n+                    let hir::ParamName::Plain(name) = p.name else { return None };\n+                    Some(name.to_string())\n+                }));\n+                // Suggest `'static` when in const/static item-like.\n+                if let hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Static { .. } | hir::ItemKind::Const { .. },\n+                    ..\n+                })\n+                | hir::Node::TraitItem(hir::TraitItem {\n+                    kind: hir::TraitItemKind::Const { .. },\n+                    ..\n+                })\n+                | hir::Node::ImplItem(hir::ImplItem {\n+                    kind: hir::ImplItemKind::Const { .. },\n+                    ..\n+                })\n+                | hir::Node::ForeignItem(hir::ForeignItem {\n+                    kind: hir::ForeignItemKind::Static { .. },\n+                    ..\n+                })\n+                | hir::Node::AnonConst(..) = node\n+                {\n+                    ret.extend(\n+                        std::iter::repeat(\"'static\".to_owned())\n+                            .take(num_params_to_take.saturating_sub(ret.len())),\n+                    );\n+                }\n+                if ret.len() >= num_params_to_take {\n+                    return ret[..num_params_to_take].join(\", \");\n+                }\n+                // We cannot refer to lifetimes defined in an outer function.\n+                if let hir::Node::Item(_) = node {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // We could not gather enough lifetime parameters in the scope.\n+        // We use the parameter names from the target type's definition instead.\n         self.gen_params\n             .params\n             .iter()\n@@ -501,44 +562,10 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         let num_params_to_take = num_missing_args;\n         let msg = format!(\"add missing {} argument{}\", self.kind(), pluralize!(num_missing_args));\n \n-        // we first try to get lifetime name suggestions from scope or elision information. If none is\n-        // available we use the parameter definitions\n-        let suggested_args = if let Some(hir_id) = self.path_segment.hir_id {\n-            if let Some(lifetimes_in_scope) = self.tcx.lifetime_scope(hir_id) {\n-                match lifetimes_in_scope {\n-                    LifetimeScopeForPath::NonElided(param_names) => {\n-                        debug!(\"NonElided(param_names: {:?})\", param_names);\n-\n-                        if param_names.len() >= num_params_to_take {\n-                            // use lifetime parameters in scope for suggestions\n-                            param_names\n-                                .iter()\n-                                .take(num_params_to_take)\n-                                .map(|def_id| {\n-                                    self.tcx.item_name(def_id.to_def_id()).to_ident_string()\n-                                })\n-                                .collect::<Vec<_>>()\n-                                .join(\", \")\n-                        } else {\n-                            // Not enough lifetime arguments in scope -> create suggestions from\n-                            // lifetime parameter names in definition. An error for the incorrect\n-                            // lifetime scope will be output later.\n-                            self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-                        }\n-                    }\n-                    LifetimeScopeForPath::Elided => {\n-                        debug!(\"Elided\");\n-                        // use suggestions of the form `<'_, '_>` in case lifetime can be elided\n-                        [\"'_\"].repeat(num_params_to_take).join(\",\")\n-                    }\n-                }\n-            } else {\n-                self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-            }\n-        } else {\n-            self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-        };\n-\n+        let suggested_args = self.get_lifetime_args_suggestions_from_param_names(\n+            self.path_segment.hir_id,\n+            num_params_to_take,\n+        );\n         debug!(\"suggested_args: {:?}\", &suggested_args);\n \n         match self.angle_brackets {"}, {"sha": "b395a1cfd8a62c6afdc0be95c5e3d3e8fd8da104", "filename": "src/test/ui/generic-associated-types/elided-in-expr-position.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/src%2Ftest%2Fui%2Fgeneric-associated-types%2Felided-in-expr-position.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/src%2Ftest%2Fui%2Fgeneric-associated-types%2Felided-in-expr-position.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Felided-in-expr-position.stderr?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -11,7 +11,7 @@ LL |     type Assoc<'a> where Self: 'a;\n    |          ^^^^^ --\n help: add missing lifetime argument\n    |\n-LL |     fn g(&self) -> Self::Assoc<'_>;\n+LL |     fn g(&self) -> Self::Assoc<'a>;\n    |                          ~~~~~~~~~\n \n error[E0107]: missing generics for associated type `Trait::Assoc`\n@@ -27,7 +27,7 @@ LL |     type Assoc<'a> where Self: 'a;\n    |          ^^^^^ --\n help: add missing lifetime argument\n    |\n-LL |     fn g(&self) -> Self::Assoc<'_> {\n+LL |     fn g(&self) -> Self::Assoc<'a> {\n    |                          ~~~~~~~~~\n \n error: aborting due to 2 previous errors"}, {"sha": "c664b3ee6683b4473c3be23e7629492865a1c1db", "filename": "src/test/ui/generic-associated-types/issue-81862.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81862.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81862.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-81862.stderr?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -11,7 +11,7 @@ LL |     type Item<'a>;\n    |          ^^^^ --\n help: add missing lifetime argument\n    |\n-LL |     fn next(&mut self) -> Option<Self::Item<'_>>;\n+LL |     fn next(&mut self) -> Option<Self::Item<'a>>;\n    |                                        ~~~~~~~~\n \n error: aborting due to previous error"}, {"sha": "1498337549d81f2f976ba5050cace6126002087f", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a736acc80459734a7c5490f25c70600eff802961/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a736acc80459734a7c5490f25c70600eff802961/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr?ref=a736acc80459734a7c5490f25c70600eff802961", "patch": "@@ -171,8 +171,8 @@ LL | pub union Qux<'t, 'k, I> {\n    |           ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                       ++++\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                       +++++++++\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/missing-lifetime-specifier.rs:43:44\n@@ -243,8 +243,8 @@ LL | pub union Qux<'t, 'k, I> {\n    |           ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                       ++++\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                       +++++++++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/missing-lifetime-specifier.rs:51:45\n@@ -261,8 +261,8 @@ LL | trait Tar<'t, 'k, I> {}\n    |       ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                        ++++\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                        +++++++++\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lifetime-specifier.rs:51:44\n@@ -360,8 +360,8 @@ LL | trait Tar<'t, 'k, I> {}\n    |       ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                        ++++\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                        +++++++++\n \n error: aborting due to 24 previous errors\n "}]}