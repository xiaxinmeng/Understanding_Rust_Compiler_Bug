{"sha": "1caa8755e523d2c4d3d8d4cfd7be86f86cac3810", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYWE4NzU1ZTUyM2QyYzRkM2Q4ZDRjZmQ3YmU4NmY4NmNhYzM4MTA=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-01-16T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-02-05T22:30:38Z"}, "message": "Apply LLVM sanitize attributes to generated entry wrapper", "tree": {"sha": "4a4e9c10fafce81a3817a8f886c0e7580b524ba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a4e9c10fafce81a3817a8f886c0e7580b524ba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810", "html_url": "https://github.com/rust-lang/rust/commit/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b846b42c8dcf052eabda71d416a986a7891093f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b846b42c8dcf052eabda71d416a986a7891093f7", "html_url": "https://github.com/rust-lang/rust/commit/b846b42c8dcf052eabda71d416a986a7891093f7"}], "stats": {"total": 75, "additions": 43, "deletions": 32}, "files": [{"sha": "a9e4fdba030366ee60a2d104da1290cdcd68ae14", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=1caa8755e523d2c4d3d8d4cfd7be86f86cac3810", "patch": "@@ -46,6 +46,31 @@ fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n     };\n }\n \n+/// Apply LLVM sanitize attributes.\n+#[inline]\n+pub fn sanitize(cx: &CodegenCx<'ll, '_>, codegen_fn_flags: CodegenFnAttrFlags, llfn: &'ll Value) {\n+    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {\n+        match *sanitizer {\n+            Sanitizer::Address => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_ADDRESS) {\n+                    llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Memory => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_MEMORY) {\n+                    llvm::Attribute::SanitizeMemory.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Thread => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_THREAD) {\n+                    llvm::Attribute::SanitizeThread.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Leak => {}\n+        }\n+    }\n+}\n+\n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n@@ -288,26 +313,7 @@ pub fn from_fn_attrs(\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::ALLOCATOR) {\n         Attribute::NoAlias.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n     }\n-    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {\n-        match *sanitizer {\n-            Sanitizer::Address => {\n-                if !codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_ADDRESS) {\n-                    llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n-                }\n-            }\n-            Sanitizer::Memory => {\n-                if !codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_MEMORY) {\n-                    llvm::Attribute::SanitizeMemory.apply_llfn(Function, llfn);\n-                }\n-            }\n-            Sanitizer::Thread => {\n-                if !codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_THREAD) {\n-                    llvm::Attribute::SanitizeThread.apply_llfn(Function, llfn);\n-                }\n-            }\n-            Sanitizer::Leak => {}\n-        }\n-    }\n+    sanitize(cx, codegen_fn_attrs.flags, llfn);\n \n     unwind(\n         llfn,"}, {"sha": "04c084e459eab662f2b441eafcc2ba5715b76ca4", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=1caa8755e523d2c4d3d8d4cfd7be86f86cac3810", "patch": "@@ -15,6 +15,7 @@\n \n use super::ModuleLlvm;\n \n+use crate::attributes;\n use crate::builder::Builder;\n use crate::common;\n use crate::context::CodegenCx;\n@@ -23,7 +24,7 @@ use crate::metadata;\n use crate::value::Value;\n \n use rustc::dep_graph;\n-use rustc::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::exported_symbols;\n use rustc::mir::mono::{Linkage, Visibility};\n@@ -131,7 +132,9 @@ pub fn compile_codegen_unit(\n \n             // If this codegen unit contains the main function, also create the\n             // wrapper here\n-            maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx);\n+            if let Some(entry) = maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx) {\n+                attributes::sanitize(&cx, CodegenFnAttrFlags::empty(), entry);\n+            }\n \n             // Run replace-all-uses-with for statics that need it\n             for &(old_g, new_g) in cx.statics_to_rauw().borrow().iter() {"}, {"sha": "900150913842c5f20e76aaa9d031463491358264", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1caa8755e523d2c4d3d8d4cfd7be86f86cac3810/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=1caa8755e523d2c4d3d8d4cfd7be86f86cac3810", "patch": "@@ -391,36 +391,36 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n /// Creates the `main` function which will initialize the rust runtime and call\n /// users main function.\n-pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'a Bx::CodegenCx) {\n+pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+) -> Option<Bx::Function> {\n     let (main_def_id, span) = match cx.tcx().entry_fn(LOCAL_CRATE) {\n         Some((def_id, _)) => (def_id, cx.tcx().def_span(def_id)),\n-        None => return,\n+        None => return None,\n     };\n \n     let instance = Instance::mono(cx.tcx(), main_def_id);\n \n     if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n-        return;\n+        return None;\n     }\n \n     let main_llfn = cx.get_fn_addr(instance);\n \n-    let et = cx.tcx().entry_fn(LOCAL_CRATE).map(|e| e.1);\n-    match et {\n-        Some(EntryFnType::Main) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, true),\n-        Some(EntryFnType::Start) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, false),\n-        None => {} // Do nothing.\n-    }\n+    return cx.tcx().entry_fn(LOCAL_CRATE).map(|(_, et)| {\n+        let use_start_lang_item = EntryFnType::Start != et;\n+        create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, use_start_lang_item)\n+    });\n \n     fn create_entry_fn<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx: &'a Bx::CodegenCx,\n         sp: Span,\n         rust_main: Bx::Value,\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n-    ) {\n+    ) -> Bx::Function {\n         // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,\n         // depending on whether the target needs `argc` and `argv` to be passed in.\n         let llfty = if cx.sess().target.target.options.main_needs_argc_argv {\n@@ -481,6 +481,8 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         let result = bx.call(start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n+\n+        llfn\n     }\n }\n "}]}