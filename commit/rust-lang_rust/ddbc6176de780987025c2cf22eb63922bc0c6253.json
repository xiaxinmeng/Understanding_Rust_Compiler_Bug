{"sha": "ddbc6176de780987025c2cf22eb63922bc0c6253", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYmM2MTc2ZGU3ODA5ODcwMjVjMmNmMjJlYjYzOTIyYmMwYzYyNTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-16T06:26:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-16T06:26:51Z"}, "message": "Auto merge of #79607 - DrMeepster:maybe_uninit_write_slice, r=m-ou-se\n\nMaybeUninit::copy/clone_from_slice\n\nThis PR adds 2 new methods to MaybeUninit under the feature of `maybe_uninit_write_slice`: `copy_from_slice` and `clone_from_slice`.\n\nThese are useful for initializing uninitialized buffers (such as the one returned by `Vec::spare_capacity_mut` for example) with initialized data.\n\nThe methods behave similarly to the methods on slices, but the destination is uninitialized and they return the destination slice as an initialized slice.", "tree": {"sha": "244de97a8de00a2b7e4608c0358a514540b69ca6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/244de97a8de00a2b7e4608c0358a514540b69ca6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddbc6176de780987025c2cf22eb63922bc0c6253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddbc6176de780987025c2cf22eb63922bc0c6253", "html_url": "https://github.com/rust-lang/rust/commit/ddbc6176de780987025c2cf22eb63922bc0c6253", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddbc6176de780987025c2cf22eb63922bc0c6253/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90f4b52961e83752da88704d8e2e1ac94457ebd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/90f4b52961e83752da88704d8e2e1ac94457ebd5", "html_url": "https://github.com/rust-lang/rust/commit/90f4b52961e83752da88704d8e2e1ac94457ebd5"}, {"sha": "4652a13f44b89193dc163991485b7638fa0f9ea7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4652a13f44b89193dc163991485b7638fa0f9ea7", "html_url": "https://github.com/rust-lang/rust/commit/4652a13f44b89193dc163991485b7638fa0f9ea7"}], "stats": {"total": 276, "additions": 276, "deletions": 0}, "files": [{"sha": "57e0bb1499bdef0b1333ce9a100da3d608d60d8a", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ddbc6176de780987025c2cf22eb63922bc0c6253/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbc6176de780987025c2cf22eb63922bc0c6253/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=ddbc6176de780987025c2cf22eb63922bc0c6253", "patch": "@@ -860,4 +860,154 @@ impl<T> MaybeUninit<T> {\n     pub const fn slice_as_mut_ptr(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this.as_mut_ptr() as *mut T\n     }\n+\n+    /// Copies the elements from `src` to `this`, returning a mutable reference to the now initalized contents of `this`.\n+    ///\n+    /// If `T` does not implement `Copy`, use [`write_slice_cloned`]\n+    ///\n+    /// This is similar to [`slice::copy_from_slice`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_write_slice)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut dst = [MaybeUninit::uninit(); 32];\n+    /// let src = [0; 32];\n+    ///\n+    /// let init = MaybeUninit::write_slice(&mut dst, &src);\n+    ///\n+    /// assert_eq!(init, src);\n+    /// ```\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_write_slice, vec_spare_capacity)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut vec = Vec::with_capacity(32);\n+    /// let src = [0; 16];\n+    ///\n+    /// MaybeUninit::write_slice(&mut vec.spare_capacity_mut()[..src.len()], &src);\n+    ///\n+    /// // SAFETY: we have just copied all the elements of len into the spare capacity\n+    /// // the first src.len() elements of the vec are valid now.\n+    /// unsafe {\n+    ///     vec.set_len(src.len());\n+    /// }\n+    ///\n+    /// assert_eq!(vec, src);\n+    /// ```\n+    ///\n+    /// [`write_slice_cloned`]: MaybeUninit::write_slice_cloned\n+    /// [`slice::copy_from_slice`]: ../../std/primitive.slice.html#method.copy_from_slice\n+    #[unstable(feature = \"maybe_uninit_write_slice\", issue = \"79995\")]\n+    pub fn write_slice<'a>(this: &'a mut [MaybeUninit<T>], src: &[T]) -> &'a mut [T]\n+    where\n+        T: Copy,\n+    {\n+        // SAFETY: &[T] and &[MaybeUninit<T>] have the same layout\n+        let uninit_src: &[MaybeUninit<T>] = unsafe { super::transmute(src) };\n+\n+        this.copy_from_slice(uninit_src);\n+\n+        // SAFETY: Valid elements have just been copied into `this` so it is initalized\n+        unsafe { MaybeUninit::slice_assume_init_mut(this) }\n+    }\n+\n+    /// Clones the elements from `src` to `this`, returning a mutable reference to the now initalized contents of `this`.\n+    /// Any already initalized elements will not be dropped.\n+    ///\n+    /// If `T` implements `Copy`, use [`write_slice`]\n+    ///\n+    /// This is similar to [`slice::clone_from_slice`] but does not drop existing elements.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths, or if the implementation of `Clone` panics.\n+    ///\n+    /// If there is a panic, the already cloned elements will be dropped.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_write_slice)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut dst = [MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit(), MaybeUninit::uninit()];\n+    /// let src = [\"wibbly\".to_string(), \"wobbly\".to_string(), \"timey\".to_string(), \"wimey\".to_string(), \"stuff\".to_string()];\n+    ///\n+    /// let init = MaybeUninit::write_slice_cloned(&mut dst, &src);\n+    ///\n+    /// assert_eq!(init, src);\n+    /// ```\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_write_slice, vec_spare_capacity)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut vec = Vec::with_capacity(32);\n+    /// let src = [\"rust\", \"is\", \"a\", \"pretty\", \"cool\", \"language\"];\n+    ///\n+    /// MaybeUninit::write_slice_cloned(&mut vec.spare_capacity_mut()[..src.len()], &src);\n+    ///\n+    /// // SAFETY: we have just cloned all the elements of len into the spare capacity\n+    /// // the first src.len() elements of the vec are valid now.\n+    /// unsafe {\n+    ///     vec.set_len(src.len());\n+    /// }\n+    ///\n+    /// assert_eq!(vec, src);\n+    /// ```\n+    ///\n+    /// [`write_slice`]: MaybeUninit::write_slice\n+    /// [`slice::clone_from_slice`]: ../../std/primitive.slice.html#method.clone_from_slice\n+    #[unstable(feature = \"maybe_uninit_write_slice\", issue = \"79995\")]\n+    pub fn write_slice_cloned<'a>(this: &'a mut [MaybeUninit<T>], src: &[T]) -> &'a mut [T]\n+    where\n+        T: Clone,\n+    {\n+        // unlike copy_from_slice this does not call clone_from_slice on the slice\n+        // this is because `MaybeUninit<T: Clone>` does not implement Clone.\n+\n+        struct Guard<'a, T> {\n+            slice: &'a mut [MaybeUninit<T>],\n+            initialized: usize,\n+        }\n+\n+        impl<'a, T> Drop for Guard<'a, T> {\n+            fn drop(&mut self) {\n+                let initialized_part = &mut self.slice[..self.initialized];\n+                // SAFETY: this raw slice will contain only initialized objects\n+                // that's why, it is allowed to drop it.\n+                unsafe {\n+                    crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(initialized_part));\n+                }\n+            }\n+        }\n+\n+        assert_eq!(this.len(), src.len(), \"destination and source slices have different lengths\");\n+        // NOTE: We need to explicitly slice them to the same length\n+        // for bounds checking to be elided, and the optimizer will\n+        // generate memcpy for simple cases (for example T = u8).\n+        let len = this.len();\n+        let src = &src[..len];\n+\n+        // guard is needed b/c panic might happen during a clone\n+        let mut guard = Guard { slice: this, initialized: 0 };\n+\n+        for i in 0..len {\n+            guard.slice[i].write(src[i].clone());\n+            guard.initialized += 1;\n+        }\n+\n+        super::forget(guard);\n+\n+        // SAFETY: Valid elements have just been written into `this` so it is initalized\n+        unsafe { MaybeUninit::slice_assume_init_mut(this) }\n+    }\n }"}, {"sha": "2828235c3e38deb237f572f949f359421d0aedaf", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddbc6176de780987025c2cf22eb63922bc0c6253/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbc6176de780987025c2cf22eb63922bc0c6253/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=ddbc6176de780987025c2cf22eb63922bc0c6253", "patch": "@@ -8,6 +8,7 @@\n #![feature(bound_cloned)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n+#![feature(cfg_panic)]\n #![feature(cfg_target_has_atomic)]\n #![feature(const_assume)]\n #![feature(const_cell_into_inner)]\n@@ -33,6 +34,7 @@\n #![feature(raw)]\n #![feature(sort_internals)]\n #![feature(slice_partition_at_index)]\n+#![feature(maybe_uninit_write_slice)]\n #![feature(min_specialization)]\n #![feature(step_trait)]\n #![feature(step_trait_ext)]"}, {"sha": "5e24fa690ef52d696422e5635d55926908a13065", "filename": "library/core/tests/mem.rs", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ddbc6176de780987025c2cf22eb63922bc0c6253/library%2Fcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbc6176de780987025c2cf22eb63922bc0c6253/library%2Fcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fmem.rs?ref=ddbc6176de780987025c2cf22eb63922bc0c6253", "patch": "@@ -1,5 +1,7 @@\n use core::mem::*;\n \n+use std::rc::Rc;\n+\n #[test]\n fn size_of_basic() {\n     assert_eq!(size_of::<u8>(), 1);\n@@ -137,3 +139,125 @@ fn assume_init_good() {\n \n     assert!(TRUE);\n }\n+\n+#[test]\n+fn uninit_write_slice() {\n+    let mut dst = [MaybeUninit::new(255); 64];\n+    let src = [0; 64];\n+\n+    assert_eq!(MaybeUninit::write_slice(&mut dst, &src), &src);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"source slice length (32) does not match destination slice length (64)\")]\n+fn uninit_write_slice_panic_lt() {\n+    let mut dst = [MaybeUninit::uninit(); 64];\n+    let src = [0; 32];\n+\n+    MaybeUninit::write_slice(&mut dst, &src);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"source slice length (128) does not match destination slice length (64)\")]\n+fn uninit_write_slice_panic_gt() {\n+    let mut dst = [MaybeUninit::uninit(); 64];\n+    let src = [0; 128];\n+\n+    MaybeUninit::write_slice(&mut dst, &src);\n+}\n+\n+#[test]\n+fn uninit_clone_from_slice() {\n+    let mut dst = [MaybeUninit::new(255); 64];\n+    let src = [0; 64];\n+\n+    assert_eq!(MaybeUninit::write_slice_cloned(&mut dst, &src), &src);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"destination and source slices have different lengths\")]\n+fn uninit_write_slice_cloned_panic_lt() {\n+    let mut dst = [MaybeUninit::uninit(); 64];\n+    let src = [0; 32];\n+\n+    MaybeUninit::write_slice_cloned(&mut dst, &src);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"destination and source slices have different lengths\")]\n+fn uninit_write_slice_cloned_panic_gt() {\n+    let mut dst = [MaybeUninit::uninit(); 64];\n+    let src = [0; 128];\n+\n+    MaybeUninit::write_slice_cloned(&mut dst, &src);\n+}\n+\n+#[test]\n+#[cfg(panic = \"unwind\")]\n+fn uninit_write_slice_cloned_mid_panic() {\n+    use std::panic;\n+\n+    enum IncrementOrPanic {\n+        Increment(Rc<()>),\n+        ExpectedPanic,\n+        UnexpectedPanic,\n+    }\n+\n+    impl Clone for IncrementOrPanic {\n+        fn clone(&self) -> Self {\n+            match self {\n+                Self::Increment(rc) => Self::Increment(rc.clone()),\n+                Self::ExpectedPanic => panic!(\"expected panic on clone\"),\n+                Self::UnexpectedPanic => panic!(\"unexpected panic on clone\"),\n+            }\n+        }\n+    }\n+\n+    let rc = Rc::new(());\n+\n+    let mut dst = [\n+        MaybeUninit::uninit(),\n+        MaybeUninit::uninit(),\n+        MaybeUninit::uninit(),\n+        MaybeUninit::uninit(),\n+    ];\n+\n+    let src = [\n+        IncrementOrPanic::Increment(rc.clone()),\n+        IncrementOrPanic::Increment(rc.clone()),\n+        IncrementOrPanic::ExpectedPanic,\n+        IncrementOrPanic::UnexpectedPanic,\n+    ];\n+\n+    let err = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        MaybeUninit::write_slice_cloned(&mut dst, &src);\n+    }));\n+\n+    drop(src);\n+\n+    match err {\n+        Ok(_) => unreachable!(),\n+        Err(payload) => {\n+            payload\n+                .downcast::<&'static str>()\n+                .and_then(|s| if *s == \"expected panic on clone\" { Ok(s) } else { Err(s) })\n+                .unwrap_or_else(|p| panic::resume_unwind(p));\n+\n+            assert_eq!(Rc::strong_count(&rc), 1)\n+        }\n+    }\n+}\n+\n+#[test]\n+fn uninit_write_slice_cloned_no_drop() {\n+    let rc = Rc::new(());\n+\n+    let mut dst = [MaybeUninit::uninit()];\n+    let src = [rc.clone()];\n+\n+    MaybeUninit::write_slice_cloned(&mut dst, &src);\n+\n+    drop(src);\n+\n+    assert_eq!(Rc::strong_count(&rc), 2);\n+}"}]}