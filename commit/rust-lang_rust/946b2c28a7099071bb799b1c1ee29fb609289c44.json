{"sha": "946b2c28a7099071bb799b1c1ee29fb609289c44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NmIyYzI4YTcwOTkwNzFiYjc5OWIxYzFlZTI5ZmI2MDkyODljNDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-24T15:45:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-24T15:45:39Z"}, "message": "Merge #5038\n\n5038: Make `iterate_method_candidates` non-generic r=jonas-schievink a=jonas-schievink\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/4975\r\n\r\nbors r+ :robot: ;)\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "2cff733c1da442f7b06fdacfb1aa008a654cfb4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cff733c1da442f7b06fdacfb1aa008a654cfb4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/946b2c28a7099071bb799b1c1ee29fb609289c44", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe83UjCRBK7hj4Ov3rIwAAdHIIAGBr6vbDT05yBQzPPHLOdYn/\nfQjdSWgr0pJqSz1NO2W/WguRT3iaQbn5FeLIU1MJ1gwIEDTpQJNFWtlwcZ38A4LV\nuXa93znwZyY6py9hkVsnCPnaeFHZ9Uns4/SBFuOj+KyIOJcO2WkTPWBKyBf1JG/G\nXL5DNSaIvM3sVs+FzTLA3fmcIYbP1trXmJ6WiewLE5CErFrfn7PSHC8LY4vFAR7p\nruSuoHqkB6sfi/r61l3Vf4CmbY/Fsb7vPKSHc4kVNN/2ESQcxQX9OP+qojl3O4ek\nl9OV3ByDWEVjwLvA/k9KJwIatJa+9S0vnotLycnLRth7/o4i/bSVOzkmKpGp/G0=\n=8R/1\n-----END PGP SIGNATURE-----\n", "payload": "tree 2cff733c1da442f7b06fdacfb1aa008a654cfb4f\nparent 7e61f4c59ee5d0b960c5fd5221b7a129afc89133\nparent cefb2204cb109529fd9d138d9b21dddd8c30ff3d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593013539 +0000\ncommitter GitHub <noreply@github.com> 1593013539 +0000\n\nMerge #5038\n\n5038: Make `iterate_method_candidates` non-generic r=jonas-schievink a=jonas-schievink\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/4975\r\n\r\nbors r+ :robot: ;)\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/946b2c28a7099071bb799b1c1ee29fb609289c44", "html_url": "https://github.com/rust-lang/rust/commit/946b2c28a7099071bb799b1c1ee29fb609289c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/946b2c28a7099071bb799b1c1ee29fb609289c44/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e61f4c59ee5d0b960c5fd5221b7a129afc89133", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e61f4c59ee5d0b960c5fd5221b7a129afc89133", "html_url": "https://github.com/rust-lang/rust/commit/7e61f4c59ee5d0b960c5fd5221b7a129afc89133"}, {"sha": "cefb2204cb109529fd9d138d9b21dddd8c30ff3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefb2204cb109529fd9d138d9b21dddd8c30ff3d", "html_url": "https://github.com/rust-lang/rust/commit/cefb2204cb109529fd9d138d9b21dddd8c30ff3d"}], "stats": {"total": 129, "additions": 73, "deletions": 56}, "files": [{"sha": "8b59a8bd6e2bf3291ef40e7de729cf0212607c39", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 73, "deletions": 56, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/946b2c28a7099071bb799b1c1ee29fb609289c44/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946b2c28a7099071bb799b1c1ee29fb609289c44/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=946b2c28a7099071bb799b1c1ee29fb609289c44", "patch": "@@ -271,6 +271,33 @@ pub fn iterate_method_candidates<T>(\n     mode: LookupMode,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n+    let mut slot = None;\n+    iterate_method_candidates_impl(\n+        ty,\n+        db,\n+        env,\n+        krate,\n+        traits_in_scope,\n+        name,\n+        mode,\n+        &mut |ty, item| {\n+            slot = callback(ty, item);\n+            slot.is_some()\n+        },\n+    );\n+    slot\n+}\n+\n+pub fn iterate_method_candidates_impl(\n+    ty: &Canonical<Ty>,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    krate: CrateId,\n+    traits_in_scope: &FxHashSet<TraitId>,\n+    name: Option<&Name>,\n+    mode: LookupMode,\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n     match mode {\n         LookupMode::MethodCall => {\n             // For method calls, rust first does any number of autoderef, and then one\n@@ -298,19 +325,19 @@ pub fn iterate_method_candidates<T>(\n \n             let deref_chain = autoderef_method_receiver(db, krate, ty);\n             for i in 0..deref_chain.len() {\n-                if let Some(result) = iterate_method_candidates_with_autoref(\n+                if iterate_method_candidates_with_autoref(\n                     &deref_chain[i..],\n                     db,\n                     env.clone(),\n                     krate,\n                     traits_in_scope,\n                     name,\n-                    &mut callback,\n+                    callback,\n                 ) {\n-                    return Some(result);\n+                    return true;\n                 }\n             }\n-            None\n+            false\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n@@ -321,22 +348,22 @@ pub fn iterate_method_candidates<T>(\n                 krate,\n                 traits_in_scope,\n                 name,\n-                &mut callback,\n+                callback,\n             )\n         }\n     }\n }\n \n-fn iterate_method_candidates_with_autoref<T>(\n+fn iterate_method_candidates_with_autoref(\n     deref_chain: &[Canonical<Ty>],\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n-    if let Some(result) = iterate_method_candidates_by_receiver(\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n+    if iterate_method_candidates_by_receiver(\n         &deref_chain[0],\n         &deref_chain[1..],\n         db,\n@@ -346,13 +373,13 @@ fn iterate_method_candidates_with_autoref<T>(\n         name,\n         &mut callback,\n     ) {\n-        return Some(result);\n+        return true;\n     }\n     let refed = Canonical {\n         num_vars: deref_chain[0].num_vars,\n         value: Ty::apply_one(TypeCtor::Ref(Mutability::Shared), deref_chain[0].value.clone()),\n     };\n-    if let Some(result) = iterate_method_candidates_by_receiver(\n+    if iterate_method_candidates_by_receiver(\n         &refed,\n         deref_chain,\n         db,\n@@ -362,13 +389,13 @@ fn iterate_method_candidates_with_autoref<T>(\n         name,\n         &mut callback,\n     ) {\n-        return Some(result);\n+        return true;\n     }\n     let ref_muted = Canonical {\n         num_vars: deref_chain[0].num_vars,\n         value: Ty::apply_one(TypeCtor::Ref(Mutability::Mut), deref_chain[0].value.clone()),\n     };\n-    if let Some(result) = iterate_method_candidates_by_receiver(\n+    if iterate_method_candidates_by_receiver(\n         &ref_muted,\n         deref_chain,\n         db,\n@@ -378,33 +405,31 @@ fn iterate_method_candidates_with_autoref<T>(\n         name,\n         &mut callback,\n     ) {\n-        return Some(result);\n+        return true;\n     }\n-    None\n+    false\n }\n \n-fn iterate_method_candidates_by_receiver<T>(\n+fn iterate_method_candidates_by_receiver(\n     receiver_ty: &Canonical<Ty>,\n     rest_of_deref_chain: &[Canonical<Ty>],\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n     for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n-        if let Some(result) =\n-            iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback)\n-        {\n-            return Some(result);\n+        if iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback) {\n+            return true;\n         }\n     }\n     for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n-        if let Some(result) = iterate_trait_method_candidates(\n+        if iterate_trait_method_candidates(\n             self_ty,\n             db,\n             env.clone(),\n@@ -414,49 +439,37 @@ fn iterate_method_candidates_by_receiver<T>(\n             Some(receiver_ty),\n             &mut callback,\n         ) {\n-            return Some(result);\n+            return true;\n         }\n     }\n-    None\n+    false\n }\n \n-fn iterate_method_candidates_for_self_ty<T>(\n+fn iterate_method_candidates_for_self_ty(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n-    if let Some(result) = iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n-        return Some(result);\n-    }\n-    if let Some(result) = iterate_trait_method_candidates(\n-        self_ty,\n-        db,\n-        env,\n-        krate,\n-        traits_in_scope,\n-        name,\n-        None,\n-        &mut callback,\n-    ) {\n-        return Some(result);\n+    mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n+    if iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n+        return true;\n     }\n-    None\n+    iterate_trait_method_candidates(self_ty, db, env, krate, traits_in_scope, name, None, callback)\n }\n \n-fn iterate_trait_method_candidates<T>(\n+fn iterate_trait_method_candidates(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n@@ -489,23 +502,27 @@ fn iterate_trait_method_candidates<T>(\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&self_ty.value, *item) {\n-                return Some(result);\n+            if callback(&self_ty.value, *item) {\n+                return true;\n             }\n         }\n     }\n-    None\n+    false\n }\n \n-fn iterate_inherent_methods<T>(\n+fn iterate_inherent_methods(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n-    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n-) -> Option<T> {\n-    for krate in self_ty.value.def_crates(db, krate)? {\n+    callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n+) -> bool {\n+    let def_crates = match self_ty.value.def_crates(db, krate) {\n+        Some(k) => k,\n+        None => return false,\n+    };\n+    for krate in def_crates {\n         let impls = db.impls_in_crate(krate);\n \n         for impl_def in impls.lookup_impl_defs(&self_ty.value) {\n@@ -521,13 +538,13 @@ fn iterate_inherent_methods<T>(\n                     test_utils::mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n-                if let Some(result) = callback(&self_ty.value, item) {\n-                    return Some(result);\n+                if callback(&self_ty.value, item) {\n+                    return true;\n                 }\n             }\n         }\n     }\n-    None\n+    false\n }\n \n /// Returns the self type for the index trait call."}]}