{"sha": "8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYzIyZTdlYzdlZDBkYTJhZGQwNzYzZDIzOWU3N2M1NDc0ZjNkNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-25T14:40:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-25T14:40:22Z"}, "message": "Auto merge of #55347 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 22 pull requests\n\nSuccessful merges:\n\n - #53507 (Add doc for impl From for Waker)\n - #53931 (Gradually expanding libstd's keyword documentation)\n - #54965 (update tcp stream documentation)\n - #54977 (Accept `Option<Box<$t:ty>>` in macro argument)\n - #55138 (in which unused-parens suggestions heed what the user actually wrote)\n - #55173 (Suggest appropriate syntax on missing lifetime specifier in return type)\n - #55200 (Documents `From` implementations for `Stdio`)\n - #55245 (submodules: update clippy from 5afdf8b7 to b1d03437)\n - #55247 (Clarified code example in char primitive doc)\n - #55251 (Fix a typo in the documentation of RangeInclusive)\n - #55253 (only issue \"variant of the expected type\" suggestion for enums)\n - #55254 (Correct trailing ellipsis in name_from_pat)\n - #55269 (fix typos in various places)\n - #55282 (Remove redundant clone)\n - #55285 (Do some copy editing on the release notes)\n - #55291 (Update stdsimd submodule)\n - #55296 (Set RUST_BACKTRACE=0 for rustdoc-ui/failed-doctest-output.rs)\n - #55306 (Regression test for #54478.)\n - #55328 (Fix doc for new copysign functions)\n - #55340 (Operands no longer appear in places)\n - #55345 (Remove is_null)\n - #55348 (Update RELEASES.md after destabilization of non_modrs_mods)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "138c3333919a3f7f83a5c7e57fde97ca5d11eee2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/138c3333919a3f7f83a5c7e57fde97ca5d11eee2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "html_url": "https://github.com/rust-lang/rust/commit/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3476ac0bee4042653ecb00207ceb9e02d2b647d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3476ac0bee4042653ecb00207ceb9e02d2b647d0", "html_url": "https://github.com/rust-lang/rust/commit/3476ac0bee4042653ecb00207ceb9e02d2b647d0"}, {"sha": "ea5aad66b4fcfe34c5beb75004b79cc87bd7255c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea5aad66b4fcfe34c5beb75004b79cc87bd7255c", "html_url": "https://github.com/rust-lang/rust/commit/ea5aad66b4fcfe34c5beb75004b79cc87bd7255c"}], "stats": {"total": 1441, "additions": 1159, "deletions": 282}, "files": [{"sha": "70a7dab72272f63ccbd368fde14d3db34e5ae630", "filename": "RELEASES.md", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -4,34 +4,31 @@ Version 1.30.0 (2018-10-25)\n Language\n --------\n - [Procedural macros are now available.][52081] These kinds of macros allow for\n-  more powerful code generation, there is a [new chapter available][proc-macros]\n-  in Rust Programming Language book that goes further in depth.\n+  more powerful code generation. There is a [new chapter available][proc-macros]\n+  in the Rust Programming Language book that goes further in depth.\n - [You can now use keywords as identifiers using the raw identifiers\n-  syntax (`r#`).][53236] e.g. `let r#for = true;`\n+  syntax (`r#`),][53236] e.g. `let r#for = true;`\n - [Using anonymous parameters in traits is now deprecated with a warning and\n   will be a hard error in the 2018 edition.][53272]\n - [You can now use `crate` in paths.][54404] This allows you to refer to the\n-  crate root in the path. e.g. `use crate::foo;` refers to `foo` in `src/lib.rs`.\n-- [Using a external crate now no longer requires being prefixed with `::`.][54404]\n-  e.g. previously using a external crate in a module without a use statement\n-  required `let json = ::serde_json::from_str(foo);` can now be written\n+  crate root in the path, e.g. `use crate::foo;` refers to `foo` in `src/lib.rs`.\n+- [Using a external crate no longer requires being prefixed with `::`.][54404]\n+  Previously, using a external crate in a module without a use statement\n+  required `let json = ::serde_json::from_str(foo);` but can now be written\n   as `let json = serde_json::from_str(foo);`.\n - [You can now apply the `#[used]` attribute to static items to prevent the\n-  compiler from optimising them away even if they appear to be unused.][51363]\n+  compiler from optimising them away, even if they appear to be unused,][51363]\n   e.g. `#[used] static FOO: u32 = 1;`\n - [You can now import and reexport macros from other crates with the `use`\n   syntax.][50911] Macros exported with `#[macro_export]` are now placed into\n   the root module of the crate. If your macro relies on calling other local\n-  macros it is recommended to export with the\n-  `#[macro_export(local_inner_macros)]` attribute so that users won't have to\n-  import those macros.\n-- [`mod.rs` files are now optional.][54146] Previously if you had a `foo` module\n-  with a `bar` submodule, you would have `src/foo/mod.rs` and `src/foo/bar.rs`.\n-  Now you can have `src/foo.rs` and `src/foo/bar.rs` to achieve the same effect.\n+  macros, it is recommended to export with the\n+  `#[macro_export(local_inner_macros)]` attribute so users won't have to import\n+  those macros.\n - [You can now catch visibility keywords (e.g. `pub`, `pub(crate)`) in macros\n   using the `vis` specifier.][53370]\n-- [Non-macro attributes now allow all forms of literals not just\n-  strings.][53044] e.g. Previously you would write `#[attr(\"true\")]` you can now\n+- [Non-macro attributes now allow all forms of literals, not just\n+  strings.][53044] Previously, you would write `#[attr(\"true\")]`, and you can now\n   write `#[attr(true)]`.\n - [You can now specify a function to handle a panic in the Rust runtime with the\n   `#[panic_handler]` attribute.][51366]\n@@ -54,9 +51,9 @@ Stabilized APIs\n - [`Ipv6Addr::UNSPECIFIED`]\n - [`Iterator::find_map`]\n \n-  The following methods are a replacement methods for `trim_left`, `trim_right`,\n-  `trim_left_matches`, and `trim_right_matches`. Which will be deprecated\n-  in 1.33.0.\n+  The following methods are replacement methods for `trim_left`, `trim_right`,\n+  `trim_left_matches`, and `trim_right_matches`, which will be deprecated\n+  in 1.33.0:\n - [`str::trim_end_matches`]\n - [`str::trim_end`]\n - [`str::trim_start_matches`]\n@@ -76,12 +73,12 @@ Misc\n ----\n - [`rustdoc` allows you to specify what edition to treat your code as with the\n   `--edition` option.][54057]\n-- [`rustdoc` now has the `--color` (Specify whether to output color) and\n-  `--error-format` (Specify error format e.g. `json`) options.][53003]\n+- [`rustdoc` now has the `--color` (specify whether to output color) and\n+  `--error-format` (specify error format, e.g. `json`) options.][53003]\n - [We now distribute a `rust-gdbgui` script that invokes `gdbgui` with Rust\n   debug symbols.][53774]\n - [Attributes from Rust tools such as `rustfmt` or `clippy` are now\n-  available.][53459] e.g. `#[rustfmt::skip]` will skip formatting the next item.\n+  available,][53459] e.g. `#[rustfmt::skip]` will skip formatting the next item.\n \n [50911]: https://github.com/rust-lang/rust/pull/50911/\n [51363]: https://github.com/rust-lang/rust/pull/51363/\n@@ -153,7 +150,7 @@ Compiler\n \n Libraries\n ---------\n-- [`Once::call_once` now no longer requires `Once` to be `'static`.][52239]\n+- [`Once::call_once` no longer requires `Once` to be `'static`.][52239]\n - [`BuildHasherDefault` now implements `PartialEq` and `Eq`.][52402]\n - [`Box<CStr>`, `Box<OsStr>`, and `Box<Path>` now implement `Clone`.][51912]\n - [Implemented `PartialEq<&str>` for `OsString` and `PartialEq<OsString>`\n@@ -169,10 +166,10 @@ Stabilized APIs\n \n Cargo\n -----\n-- [Cargo can silently fix some bad lockfiles ][cargo/5831] You can use\n-  `--locked` to disable this behaviour.\n+- [Cargo can silently fix some bad lockfiles.][cargo/5831] You can use\n+  `--locked` to disable this behavior.\n - [`cargo-install` will now allow you to cross compile an install\n-  using `--target`][cargo/5614]\n+  using `--target`.][cargo/5614]\n - [Added the `cargo-fix` subcommand to automatically move project code from\n   2015 edition to 2018.][cargo/5723]\n - [`cargo doc` can now optionally document private types using the\n@@ -184,15 +181,15 @@ Misc\n   the specified level to that level.][52354] For example `--cap-lints warn`\n   will demote `deny` and `forbid` lints to `warn`.\n - [`rustc` and `rustdoc` will now have the exit code of `1` if compilation\n-  fails, and `101` if there is a panic.][52197]\n+  fails and `101` if there is a panic.][52197]\n - [A preview of clippy has been made available through rustup.][51122]\n-  You can install the preview with `rustup component add clippy-preview`\n+  You can install the preview with `rustup component add clippy-preview`.\n \n Compatibility Notes\n -------------------\n - [`str::{slice_unchecked, slice_unchecked_mut}` are now deprecated.][51807]\n   Use `str::get_unchecked(begin..end)` instead.\n-- [`std::env::home_dir` is now deprecated for its unintuitive behaviour.][51656]\n+- [`std::env::home_dir` is now deprecated for its unintuitive behavior.][51656]\n   Consider using the `home_dir` function from\n   https://crates.io/crates/dirs instead.\n - [`rustc` will no longer silently ignore invalid data in target spec.][52330]\n@@ -432,7 +429,7 @@ Language\n   be used as an identifier.\n - [The dyn syntax is now available.][49968] This syntax is equivalent to the\n   bare `Trait` syntax, and should make it clearer when being used in tandem with\n-  `impl Trait`. Since it is equivalent to the following syntax:\n+  `impl Trait` because it is equivalent to the following syntax:\n   `&Trait == &dyn Trait`, `&mut Trait == &mut dyn Trait`, and\n   `Box<Trait> == Box<dyn Trait>`.\n - [Attributes on generic parameters such as types and lifetimes are\n@@ -495,10 +492,10 @@ Cargo\n   a different directory than `target` for placing compilation artifacts.\n - [Cargo will be adding automatic target inference for binaries, benchmarks,\n   examples, and tests in the Rust 2018 edition.][cargo/5335] If your project specifies\n-  specific targets e.g. using `[[bin]]` and have other binaries in locations\n+  specific targets, e.g. using `[[bin]]`, and have other binaries in locations\n   where cargo would infer a binary, Cargo will produce a warning. You can\n-  disable this feature ahead of time by setting any of the following `autobins`,\n-  `autobenches`, `autoexamples`, `autotests` to false.\n+  disable this feature ahead of time by setting any of the following to false:\n+  `autobins`, `autobenches`, `autoexamples`, `autotests`.\n - [Cargo will now cache compiler information.][cargo/5359] This can be disabled by\n   setting `CARGO_CACHE_RUSTC_INFO=0` in your environment.\n \n@@ -514,8 +511,8 @@ Compatibility Notes\n   work.][49896] e.g. `::core::prelude::v1::StrExt::is_empty(\"\")` will not\n   compile, `\"\".is_empty()` will still compile.\n - [`Debug` output on `atomic::{AtomicBool, AtomicIsize, AtomicPtr, AtomicUsize}`\n-  will only print the inner type.][48553] e.g.\n-  `print!(\"{:?}\", AtomicBool::new(true))` will print `true`\n+  will only print the inner type.][48553] E.g.\n+  `print!(\"{:?}\", AtomicBool::new(true))` will print `true`,\n   not `AtomicBool(true)`.\n - [The maximum number for `repr(align(N))` is now 2\u00b2\u2079.][50378] Previously you\n   could enter higher numbers but they were not supported by LLVM. Up to 512MB\n@@ -578,7 +575,7 @@ Version 1.26.2 (2018-06-05)\n Compatibility Notes\n -------------------\n \n-- [The borrow checker was fixed to avoid unsoundness when using match ergonomics][51117]\n+- [The borrow checker was fixed to avoid unsoundness when using match ergonomics.][51117]\n \n [51117]: https://github.com/rust-lang/rust/issues/51117\n \n@@ -589,18 +586,18 @@ Version 1.26.1 (2018-05-29)\n Tools\n -----\n \n-- [RLS now works on Windows][50646]\n-- [Rustfmt stopped badly formatting text in some cases][rustfmt/2695]\n+- [RLS now works on Windows.][50646]\n+- [Rustfmt stopped badly formatting text in some cases.][rustfmt/2695]\n \n \n Compatibility Notes\n --------\n \n - [`fn main() -> impl Trait` no longer works for non-Termination\n-  trait][50656]\n+  trait.][50656]\n   This reverts an accidental stabilization.\n-- [`NaN > NaN` no longer returns true in const-fn contexts][50812]\n-- [Prohibit using turbofish for `impl Trait` in method arguments][50950]\n+- [`NaN > NaN` no longer returns true in const-fn contexts.][50812]\n+- [Prohibit using turbofish for `impl Trait` in method arguments.][50950]\n \n [50646]: https://github.com/rust-lang/rust/issues/50646\n [50656]: https://github.com/rust-lang/rust/pull/50656\n@@ -616,18 +613,18 @@ Language\n - [Closures now implement `Copy` and/or `Clone` if all captured variables\n   implement either or both traits.][49299]\n - [The inclusive range syntax e.g. `for x in 0..=10` is now stable.][47813]\n-- [The `'_` lifetime is now stable. The underscore lifetime can be used anywhere where a\n+- [The `'_` lifetime is now stable. The underscore lifetime can be used anywhere a\n   lifetime can be elided.][49458]\n - [`impl Trait` is now stable allowing you to have abstract types in returns\n-   or in function parameters.][49255] e.g. `fn foo() -> impl Iterator<Item=u8>` or\n+   or in function parameters.][49255] E.g. `fn foo() -> impl Iterator<Item=u8>` or\n   `fn open(path: impl AsRef<Path>)`.\n - [Pattern matching will now automatically apply dereferences.][49394]\n - [128-bit integers in the form of `u128` and `i128` are now stable.][49101]\n - [`main` can now return `Result<(), E: Debug>`][49162] in addition to `()`.\n - [A lot of operations are now available in a const context.][46882] E.g. You\n   can now index into constant arrays, reference and dereference into constants,\n-  and use Tuple struct constructors.\n-- [Fixed entry slice patterns are now stable.][48516] e.g.\n+  and use tuple struct constructors.\n+- [Fixed entry slice patterns are now stable.][48516] E.g.\n   ```rust\n   let points = [1, 2, 3, 4];\n   match points {\n@@ -1052,7 +1049,7 @@ Language\n Compiler\n --------\n - [Enabled `TrapUnreachable` in LLVM which should mitigate the impact of\n-  undefined behaviour.][45920]\n+  undefined behavior.][45920]\n - [rustc now suggests renaming import if names clash.][45660]\n - [Display errors/warnings correctly when there are zero-width or\n   wide characters.][45711]"}, {"sha": "dd211083527922861f13b5b6bb884151a50604d8", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -349,6 +349,7 @@ dependencies = [\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 2.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "ffc5adbebb34f76658714abb6af3c22f9593493b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -594,7 +594,7 @@ def exe_suffix():\n         return ''\n \n     def bootstrap_binary(self):\n-        \"\"\"Return the path of the boostrap binary\n+        \"\"\"Return the path of the bootstrap binary\n \n         >>> rb = RustBuild()\n         >>> rb.build_dir = \"build\""}, {"sha": "2bbd4372721cbc2f724dada47454f68f02573bba", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -277,7 +277,7 @@ def print_std_string_val(val, internal_dict):\n #=--------------------------------------------------------------------------------------------------\n \n def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n-    \"\"\"Prints a contigous memory range, interpreting it as values of the\n+    \"\"\"Prints a contiguous memory range, interpreting it as values of the\n        pointee-type of data_ptr_val.\"\"\"\n \n     data_ptr_type = data_ptr_val.type"}, {"sha": "24c8fd3a969ca3e1bde035f6531cf3c6456d7bb2", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -77,7 +77,7 @@ use self::Entry::*;\n /// movie_reviews.insert(\"Office Space\",       \"Deals with real issues in the workplace.\");\n /// movie_reviews.insert(\"Pulp Fiction\",       \"Masterpiece.\");\n /// movie_reviews.insert(\"The Godfather\",      \"Very enjoyable.\");\n-/// movie_reviews.insert(\"The Blues Brothers\", \"Eye lyked it alot.\");\n+/// movie_reviews.insert(\"The Blues Brothers\", \"Eye lyked it a lot.\");\n ///\n /// // check for a specific one.\n /// if !movie_reviews.contains_key(\"Les Mis\u00e9rables\") {"}, {"sha": "4efcaae59b012ce1a192c4a51379d8d9a0c20c53", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -518,7 +518,7 @@ pub unsafe trait GlobalAlloc {\n     /// The block is described by the given `ptr` pointer and `layout`.\n     ///\n     /// If this returns a non-null pointer, then ownership of the memory block\n-    /// referenced by `ptr` has been transferred to this alloctor.\n+    /// referenced by `ptr` has been transferred to this allocator.\n     /// The memory may or may not have been deallocated,\n     /// and should be considered unusable (unless of course it was\n     /// transferred back to the caller again via the return value of"}, {"sha": "cceae9249e45626a6642c366242bdc177232f2df", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1025,7 +1025,7 @@ extern \"rust-intrinsic\" {\n     ///         // to avoid problems in case something further down panics.\n     ///         src.set_len(0);\n     ///\n-    ///         // The two regions cannot overlap becuase mutable references do\n+    ///         // The two regions cannot overlap because mutable references do\n     ///         // not alias, and two different vectors cannot own the same\n     ///         // memory.\n     ///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);"}, {"sha": "fd3e50998fe8c5e5909f7d4fb60f63a7c1f96551", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -304,7 +304,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     }\n }\n \n-/// An range bounded inclusively below and above (`start..=end`).\n+/// A range bounded inclusively below and above (`start..=end`).\n ///\n /// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n /// and `x <= end`.  It is empty unless `start <= end`."}, {"sha": "a03c080fb3f3418fad92dba5a06c1390f168de3a", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -102,7 +102,7 @@ pub use marker::Unpin;\n /// value in place, preventing the value referenced by that pointer from being moved\n /// unless it implements [`Unpin`].\n ///\n-/// See the [`pin` module] documentation for furthur explanation on pinning.\n+/// See the [`pin` module] documentation for further explanation on pinning.\n ///\n /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n /// [`pin` module]: ../../std/pin/index.html"}, {"sha": "b699cb028842be995604f77a605c34c7c8a82124", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -38,7 +38,7 @@\n //!   underlying object is live and no reference (just raw pointers) is used to\n //!   access the same memory.\n //!\n-//! These axioms, along with careful use of [`offset`] for pointer arithmentic,\n+//! These axioms, along with careful use of [`offset`] for pointer arithmetic,\n //! are enough to correctly implement many useful things in unsafe code. Stronger guarantees\n //! will be provided eventually, as the [aliasing] rules are being determined. For more\n //! information, see the [book] as well as the section in the reference devoted"}, {"sha": "c9fb22e0080dd1c2efc2531e8fcdfaed53336e19", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -188,6 +188,11 @@ impl LocalWaker {\n }\n \n impl From<LocalWaker> for Waker {\n+    /// Converts a `LocalWaker` into a `Waker`.\n+    ///\n+    /// This conversion turns a `!Sync` `LocalWaker` into a `Sync` `Waker`, allowing a wakeup\n+    /// object to be sent to another thread, but giving up its ability to do specialized\n+    /// thread-local wakeup behavior.\n     #[inline]\n     fn from(local_waker: LocalWaker) -> Self {\n         local_waker.0"}, {"sha": "e378e1b8be0e922b6b8e56c52330b4ef411c6f34", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -40,7 +40,7 @@ impl ::std::fmt::Debug for CrateNum {\n         match self {\n             CrateNum::Index(id) => write!(fmt, \"crate{}\", id.private),\n             CrateNum::Invalid => write!(fmt, \"invalid crate\"),\n-            CrateNum::BuiltinMacros => write!(fmt, \"bultin macros crate\"),\n+            CrateNum::BuiltinMacros => write!(fmt, \"builtin macros crate\"),\n             CrateNum::ReservedForIncrCompCache => write!(fmt, \"crate for decoding incr comp cache\"),\n         }\n     }\n@@ -101,7 +101,7 @@ impl fmt::Display for CrateNum {\n         match self {\n             CrateNum::Index(id) => fmt::Display::fmt(&id.private, f),\n             CrateNum::Invalid => write!(f, \"invalid crate\"),\n-            CrateNum::BuiltinMacros => write!(f, \"bultin macros crate\"),\n+            CrateNum::BuiltinMacros => write!(f, \"builtin macros crate\"),\n             CrateNum::ReservedForIncrCompCache => write!(f, \"crate for decoding incr comp cache\"),\n         }\n     }"}, {"sha": "afb5f23db5b83d0c7a089632163dc059d90837f6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1147,7 +1147,7 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n-                let span = t.span.shrink_to_lo();\n+                let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n                     None => self.elided_ref_lifetime(span),"}, {"sha": "ad2fa48610b0ea650ca55e38b96a5facbeb92619", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -180,7 +180,7 @@ impl<'a> State<'a> {\n         State {\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n-            comments: comments.clone(),\n+            comments,\n             literals: literals.unwrap_or_default().into_iter().peekable(),\n             cur_cmnt: 0,\n             boxes: Vec::new(),"}, {"sha": "fbf4297222f9bd9109374f432b1cd5f25a744b34", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -44,7 +44,7 @@ impl<'cm> CachingSourceMapView<'cm> {\n \n         CachingSourceMapView {\n             source_map,\n-            line_cache: [entry.clone(), entry.clone(), entry.clone()],\n+            line_cache: [entry.clone(), entry.clone(), entry],\n             time_stamp: 0,\n         }\n     }"}, {"sha": "361abb1689619e1cd92ee0557b54cfef1f17b292", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -2235,21 +2235,46 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         let mut err = report_missing_lifetime_specifiers(self.tcx.sess, span, lifetime_refs.len());\n+        let mut add_label = true;\n \n         if let Some(params) = error {\n             if lifetime_refs.len() == 1 {\n-                self.report_elision_failure(&mut err, params);\n+                add_label = add_label && self.report_elision_failure(&mut err, params, span);\n             }\n         }\n+        if add_label {\n+            add_missing_lifetime_specifiers_label(&mut err, span, lifetime_refs.len());\n+        }\n \n         err.emit();\n     }\n \n+    fn suggest_lifetime(&self, db: &mut DiagnosticBuilder<'_>, span: Span, msg: &str) -> bool {\n+        match self.tcx.sess.source_map().span_to_snippet(span) {\n+            Ok(ref snippet) => {\n+                let (sugg, applicability) = if snippet == \"&\" {\n+                    (\"&'static \".to_owned(), Applicability::MachineApplicable)\n+                } else if snippet == \"'_\" {\n+                    (\"'static\".to_owned(), Applicability::MachineApplicable)\n+                } else {\n+                    (format!(\"{} + 'static\", snippet), Applicability::MaybeIncorrect)\n+                };\n+                db.span_suggestion_with_applicability(span, msg, sugg, applicability);\n+                false\n+            }\n+            Err(_) => {\n+                db.help(msg);\n+                true\n+            }\n+        }\n+    }\n+\n     fn report_elision_failure(\n         &mut self,\n         db: &mut DiagnosticBuilder<'_>,\n         params: &[ElisionFailureInfo],\n-    ) {\n+        span: Span,\n+    ) -> bool {\n         let mut m = String::new();\n         let len = params.len();\n \n@@ -2304,33 +2329,32 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 \"this function's return type contains a borrowed value, but \\\n                  there is no value for it to be borrowed from\"\n             );\n-            help!(db, \"consider giving it a 'static lifetime\");\n+            self.suggest_lifetime(db, span, \"consider giving it a 'static lifetime\")\n         } else if elided_len == 0 {\n             help!(\n                 db,\n                 \"this function's return type contains a borrowed value with \\\n                  an elided lifetime, but the lifetime cannot be derived from \\\n                  the arguments\"\n             );\n-            help!(\n-                db,\n-                \"consider giving it an explicit bounded or 'static \\\n-                 lifetime\"\n-            );\n+            let msg = \"consider giving it an explicit bounded or 'static lifetime\";\n+            self.suggest_lifetime(db, span, msg)\n         } else if elided_len == 1 {\n             help!(\n                 db,\n                 \"this function's return type contains a borrowed value, but \\\n                  the signature does not say which {} it is borrowed from\",\n                 m\n             );\n+            true\n         } else {\n             help!(\n                 db,\n                 \"this function's return type contains a borrowed value, but \\\n                  the signature does not say whether it is borrowed from {}\",\n                 m\n             );\n+            true\n         }\n     }\n \n@@ -2744,26 +2768,28 @@ fn insert_late_bound_lifetimes(\n     }\n }\n \n-pub fn report_missing_lifetime_specifiers(\n+fn report_missing_lifetime_specifiers(\n     sess: &Session,\n     span: Span,\n     count: usize,\n ) -> DiagnosticBuilder<'_> {\n-    let mut err = struct_span_err!(\n+    struct_span_err!(\n         sess,\n         span,\n         E0106,\n         \"missing lifetime specifier{}\",\n         if count > 1 { \"s\" } else { \"\" }\n-    );\n+    )\n+}\n \n-    let msg: Cow<'static, str> = if count > 1 {\n-        format!(\"expected {} lifetime parameters\", count).into()\n+fn add_missing_lifetime_specifiers_label(\n+    err: &mut DiagnosticBuilder<'_>,\n+    span: Span,\n+    count: usize,\n+) {\n+    if count > 1 {\n+        err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n     } else {\n-        \"expected lifetime parameter\".into()\n+        err.span_label(span, \"expected lifetime parameter\");\n     };\n-\n-    err.span_label(span, msg);\n-\n-    err\n }"}, {"sha": "5054f522778706305bf9cdbb653f71f4ac3530e4", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -632,7 +632,7 @@ pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Methods to faciliate working with signed integers stored in a u128\n+// Methods to facilitate working with signed integers stored in a u128\n ////////////////////////////////////////////////////////////////////////////////\n \n pub fn sign_extend(value: u128, size: Size) -> u128 {"}, {"sha": "4304f08a78f0c56b757f8fb0c9f8927f2918d52c", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -181,22 +181,14 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn is_null_ptr(self, cx: impl HasDataLayout) -> bool {\n         match self {\n-            Scalar::Bits { bits, size } =>  {\n+            Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n                 bits == 0\n             },\n             Scalar::Ptr(_) => false,\n         }\n     }\n \n-    #[inline]\n-    pub fn is_null(self) -> bool {\n-        match self {\n-            Scalar::Bits { bits, .. } => bits == 0,\n-            Scalar::Ptr(_) => false\n-        }\n-    }\n-\n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n         Scalar::Bits { bits: b as u128, size: 1 }"}, {"sha": "9d296e67da1aee0e1771aa9d05379c9d5760d708", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -469,7 +469,7 @@ pub enum BorrowKind {\n     ///     }\n     ///\n     /// This can't be a shared borrow because mutably borrowing (*x as Some).0\n-    /// should not prevent `if let None = x { ... }`, for example, becase the\n+    /// should not prevent `if let None = x { ... }`, for example, because the\n     /// mutating `(*x as Some).0` can't affect the discriminant of `x`.\n     /// We can also report errors with this kind of borrow differently.\n     Shallow,\n@@ -2065,9 +2065,8 @@ pub struct SourceScopeLocalData {\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n \n-/// These are values that can appear inside an rvalue (or an index\n-/// place). They are intentionally limited to prevent rvalues from\n-/// being nested in one another.\n+/// These are values that can appear inside an rvalue. They are intentionally\n+/// limited to prevent rvalues from being nested in one another.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Operand<'tcx> {\n     /// Copy: The value must be available for use afterwards."}, {"sha": "ea30752a820ee430cab1e2a01557f6f41198de8d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -412,7 +412,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             flags.push((\"crate_local\".to_owned(), None));\n         }\n \n-        // Allow targetting all integers using `{integral}`, even if the exact type was resolved\n+        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n         if self_ty.is_integral() {\n             flags.push((\"_Self\".to_owned(), Some(\"{integral}\".to_owned())));\n         }"}, {"sha": "b266fbe0d11458e08829a3c721407eb82b78343f", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n         let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n \n         if !value.has_projections() {\n-            value.clone()\n+            value\n         } else {\n             value.fold_with(self)\n         }"}, {"sha": "62e38ad9bfa662a84ecd25a2356fce2828332e74", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -967,7 +967,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n     }\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|fn_sig| fn_sig.output().clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.output())\n     }\n     pub fn variadic(&self) -> bool {\n         self.skip_binder().variadic"}, {"sha": "2fe6a0377f81b14803ab93feae7a03795b3795bb", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -761,7 +761,7 @@ impl Builder<'a, 'll, 'tcx> {\n                     fty, asm, cons, volatile, alignstack, dia);\n                 Some(self.call(v, inputs, None))\n             } else {\n-                // LLVM has detected an issue with our constaints, bail out\n+                // LLVM has detected an issue with our constraints, bail out\n                 None\n             }\n         }"}, {"sha": "96d04253cc48549f3fd981e0a774ee922a21ab44", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -284,8 +284,13 @@ impl UnusedParens {\n                 parser::contains_exterior_struct_lit(&inner)\n             };\n             if !necessary {\n-                let pattern = pprust::expr_to_string(value);\n-                Self::remove_outer_parens(cx, value.span, &pattern, msg);\n+                let expr_text = if let Ok(snippet) = cx.sess().source_map()\n+                    .span_to_snippet(value.span) {\n+                        snippet\n+                    } else {\n+                        pprust::expr_to_string(value)\n+                    };\n+                Self::remove_outer_parens(cx, value.span, &expr_text, msg);\n             }\n         }\n     }\n@@ -295,8 +300,13 @@ impl UnusedParens {\n                                 value: &ast::Pat,\n                                 msg: &str) {\n         if let ast::PatKind::Paren(_) = value.node {\n-            let pattern = pprust::pat_to_string(value);\n-            Self::remove_outer_parens(cx, value.span, &pattern, msg);\n+            let pattern_text = if let Ok(snippet) = cx.sess().source_map()\n+                .span_to_snippet(value.span) {\n+                    snippet\n+                } else {\n+                    pprust::pat_to_string(value)\n+                };\n+            Self::remove_outer_parens(cx, value.span, &pattern_text, msg);\n         }\n     }\n "}, {"sha": "e6e1367b592df79360ce3061cf30c4de1e3839f3", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -68,7 +68,7 @@ macro_rules! provide {\n \n                 let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n-                    .expect(\"CrateStore crated ata is not a CrateMetadata\");\n+                    .expect(\"CrateStore created data is not a CrateMetadata\");\n                 $compute\n             })*\n "}, {"sha": "9702e94a9e0f0ffae84c155cec25e5a0d7a77e1d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -129,7 +129,7 @@ pub fn op_to_const<'tcx>(\n             assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= op.layout.size.bytes());\n             let mut alloc = alloc.clone();\n             alloc.align = align;\n-            // FIXME shouldnt it be the case that `mark_static_initialized` has already\n+            // FIXME shouldn't it be the case that `mark_static_initialized` has already\n             // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n             let alloc = ecx.tcx.intern_const_alloc(alloc);\n             ConstValue::ByRef(ptr.alloc_id, alloc, ptr.offset)"}, {"sha": "56a9daf84f768905faedee6d096ea7f99260f143", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -2279,7 +2279,7 @@ fn demo<'a>(s: &'a mut S<'a>) -> &'a mut String { let p = &mut *(*s).data; p }\n \n Note that this approach needs a reference to S with lifetime `'a`.\n Nothing shorter than `'a` will suffice: a shorter lifetime would imply\n-that after `demo` finishes excuting, something else (such as the\n+that after `demo` finishes executing, something else (such as the\n destructor!) could access `s.data` after the end of that shorter\n lifetime, which would again violate the `&mut`-borrow's exclusive\n access."}, {"sha": "77483ad184ba6cda0688d9e17336c7bc18804ea9", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1048,7 +1048,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n         debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n         split_grouped_constructors(cx.tcx, constructors, matrix, pcx.ty).into_iter().map(|c|\n-            is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n+            is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n         ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n@@ -1096,7 +1096,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n         if missing_ctors.is_empty() && !is_non_exhaustive {\n             split_grouped_constructors(cx.tcx, all_ctors, matrix, pcx.ty).into_iter().map(|c| {\n-                is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n+                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {"}, {"sha": "64ad4c2eec1e1343da2b8cba38f91368e68d717c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -556,7 +556,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 )?;\n             }\n         } else {\n-            // Uh, that shouln't happen... the function did not intend to return\n+            // Uh, that shouldn't happen... the function did not intend to return\n             return err!(Unreachable);\n         }\n "}, {"sha": "6fe490c6efc8ffa8434ce9b97a7ff9cc475aac40", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n     }\n }\n \n-// FIXME: Really we shouldnt clone memory, ever. Snapshot machinery should instad\n+// FIXME: Really we shouldn't clone memory, ever. Snapshot machinery should instead\n // carefully copy only the reachable parts.\n impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n     Clone for Memory<'a, 'mir, 'tcx, M>\n@@ -658,7 +658,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n-    /// However, this still checks that there are no relocations on the *egdes*.\n+    /// However, this still checks that there are no relocations on the *edges*.\n     #[inline]\n     fn get_bytes_with_undef_and_ptr(\n         &self,\n@@ -1098,7 +1098,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Error if there are relocations overlapping with the egdes of the\n+    /// Error if there are relocations overlapping with the edges of the\n     /// given memory range.\n     #[inline]\n     fn check_relocation_edges(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {"}, {"sha": "021e2d58f84b1d4556ec8e2950ac8abf286408da", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -357,14 +357,14 @@ fn from_known_layout<'tcx>(\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Try reading a value in memory; this is interesting particularily for ScalarPair.\n+    /// Try reading a value in memory; this is interesting particularly for ScalarPair.\n     /// Return None if the layout does not permit loading this as a value.\n     pub(super) fn try_read_value_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, Option<Value<M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n-            // Dont touch unsized\n+            // Don't touch unsized\n             return Ok(None);\n         }\n         let (ptr, ptr_align) = mplace.to_scalar_ptr_align();"}, {"sha": "ac1ba0edc3b3b850a242a50c9efc5f4ff84805c7", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -230,7 +230,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                                 ),\n                         }\n                     }\n-                    // non-ZST also have to be dereferencable\n+                    // non-ZST also have to be dereferenceable\n                     if size != Size::ZERO {\n                         let ptr = try_validation!(place.ptr.to_ptr(),\n                             \"integer pointer in non-ZST reference\", path);\n@@ -272,7 +272,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // FIXME: Check if the signature matches\n             }\n             // This should be all the primitive types\n-            ty::Never => bug!(\"Uninhabited type should have been catched earlier\"),\n+            ty::Never => bug!(\"Uninhabited type should have been caught earlier\"),\n             _ => bug!(\"Unexpected primitive type {}\", value.layout.ty)\n         }\n         Ok(())"}, {"sha": "0e9596244cd581cb818c89f33d681002edde192f", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -166,12 +166,12 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    /// With eRFC 2497, we need to check whether an expression is ambigious and warn or error\n+    /// With eRFC 2497, we need to check whether an expression is ambiguous and warn or error\n     /// depending on the edition, this function handles that.\n     fn while_if_let_ambiguity(&self, expr: &P<Expr>) {\n         if let Some((span, op_kind)) = self.while_if_let_expr_ambiguity(&expr) {\n             let mut err = self.err_handler().struct_span_err(\n-                span, &format!(\"ambigious use of `{}`\", op_kind.to_string())\n+                span, &format!(\"ambiguous use of `{}`\", op_kind.to_string())\n             );\n \n             err.note(\n@@ -193,22 +193,22 @@ impl<'a> AstValidator<'a> {\n     }\n \n     /// With eRFC 2497 adding if-let chains, there is a requirement that the parsing of\n-    /// `&&` and `||` in a if-let statement be unambigious. This function returns a span and\n-    /// a `BinOpKind` (either `&&` or `||` depending on what was ambigious) if it is determined\n-    /// that the current expression parsed is ambigious and will break in future.\n+    /// `&&` and `||` in a if-let statement be unambiguous. This function returns a span and\n+    /// a `BinOpKind` (either `&&` or `||` depending on what was ambiguous) if it is determined\n+    /// that the current expression parsed is ambiguous and will break in future.\n     fn while_if_let_expr_ambiguity(&self, expr: &P<Expr>) -> Option<(Span, BinOpKind)> {\n         debug!(\"while_if_let_expr_ambiguity: expr.node: {:?}\", expr.node);\n         match &expr.node {\n             ExprKind::Binary(op, _, _) if op.node == BinOpKind::And || op.node == BinOpKind::Or => {\n                 Some((expr.span, op.node))\n             },\n             ExprKind::Range(ref lhs, ref rhs, _) => {\n-                let lhs_ambigious = lhs.as_ref()\n+                let lhs_ambiguous = lhs.as_ref()\n                     .and_then(|lhs| self.while_if_let_expr_ambiguity(lhs));\n-                let rhs_ambigious = rhs.as_ref()\n+                let rhs_ambiguous = rhs.as_ref()\n                     .and_then(|rhs| self.while_if_let_expr_ambiguity(rhs));\n \n-                lhs_ambigious.or(rhs_ambigious)\n+                lhs_ambiguous.or(rhs_ambiguous)\n             }\n             _ => None,\n         }"}, {"sha": "1a5d2801af0c5d1b2a6c7be416c99d0368c43494", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -430,7 +430,7 @@ impl Align {\n     }\n \n     /// Lower the alignment, if necessary, such that the given offset\n-    /// is aligned to it (the offset is a multiple of the aligment).\n+    /// is aligned to it (the offset is a multiple of the alignment).\n     pub fn restrict_for_offset(self, offset: Size) -> Align {\n         self.min(Align::max_for_offset(offset))\n     }"}, {"sha": "7773e2d570844b892d2157b0941d05580c7e7e26", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -111,34 +111,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n         let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n \n-        // If the expected type is an enum with any variants whose sole\n-        // field is of the found type, suggest such variants. See Issue\n-        // #42764.\n+        // If the expected type is an enum (Issue #55250) with any variants whose\n+        // sole field is of the found type, suggest such variants. (Issue #42764)\n         if let ty::Adt(expected_adt, substs) = expected.sty {\n-            let mut compatible_variants = expected_adt.variants\n-                                                  .iter()\n-                                                  .filter(|variant| variant.fields.len() == 1)\n-                                                  .filter_map(|variant| {\n-                let sole_field = &variant.fields[0];\n-                let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                if self.can_coerce(expr_ty, sole_field_ty) {\n-                    let variant_path = self.tcx.item_path_str(variant.did);\n-                    Some(variant_path.trim_left_matches(\"std::prelude::v1::\").to_string())\n-                } else {\n-                    None\n+            if expected_adt.is_enum() {\n+                let mut compatible_variants = expected_adt.variants\n+                    .iter()\n+                    .filter(|variant| variant.fields.len() == 1)\n+                    .filter_map(|variant| {\n+                        let sole_field = &variant.fields[0];\n+                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                        if self.can_coerce(expr_ty, sole_field_ty) {\n+                            let variant_path = self.tcx.item_path_str(variant.did);\n+                            Some(variant_path.trim_left_matches(\"std::prelude::v1::\").to_string())\n+                        } else {\n+                            None\n+                        }\n+                    }).peekable();\n+\n+                if compatible_variants.peek().is_some() {\n+                    let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n+                    let suggestions = compatible_variants\n+                        .map(|v| format!(\"{}({})\", v, expr_text)).collect::<Vec<_>>();\n+                    err.span_suggestions_with_applicability(\n+                        expr.span,\n+                        \"try using a variant of the expected type\",\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n-            }).peekable();\n-\n-            if compatible_variants.peek().is_some() {\n-                let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n-                let suggestions = compatible_variants.map(|v|\n-                    format!(\"{}({})\", v, expr_text)).collect::<Vec<_>>();\n-                err.span_suggestions_with_applicability(\n-                     expr.span,\n-                     \"try using a variant of the expected type\",\n-                     suggestions,\n-                     Applicability::MaybeIncorrect,\n-                );\n             }\n         }\n "}, {"sha": "77151351d08a1e5522ddd0b1ef88f9d1f30a7e1f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -5198,7 +5198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n                             // This case also occurs as a result of some malformed input, e.g.\n-                            // a lifetime argument being given instead of a type paramter.\n+                            // a lifetime argument being given instead of a type parameter.\n                             // Using inference instead of `Error` gives better error messages.\n                             self.var_for_def(span, param)\n                         }"}, {"sha": "9990d2ee2b6769d386f3e0b6a32ffc7ba69806c5", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -674,7 +674,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                     } // if may_define_existential_type\n \n                     // now register the bounds on the parameters of the existential type\n-                    // so the parameters given by the function need to fulfil them\n+                    // so the parameters given by the function need to fulfill them\n                     // ```rust\n                     // existential type Foo<T: Bar>: 'static;\n                     // fn foo<U>() -> Foo<U> { .. *}"}, {"sha": "05a83dd307c38047e7bb2e76a6f7dab2603f6388", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -269,7 +269,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                 // exactly one (non-phantom) field has changed its\n                 // type, which we will expect to be the pointer that\n                 // is becoming fat (we could probably generalize this\n-                // to mutiple thin pointers of the same type becoming\n+                // to multiple thin pointers of the same type becoming\n                 // fat, but we don't). In this case:\n                 //\n                 // - `extra` has type `T` before and type `T` after"}, {"sha": "2e6cc4bd54c6194d92fbea4505dc7819f298ad2b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -3632,7 +3632,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n                                   format!(\"{}: {}\", fp.ident, name_from_pat(&*fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n-                if etc { \", ...\" } else { \"\" }\n+                if etc { \", ..\" } else { \"\" }\n             )\n         }\n         PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))"}, {"sha": "7d17aaf2f261b24e723e9012c88390e62d6ad052", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -198,12 +198,12 @@ impl f32 {\n         }\n     }\n \n-    /// Returns a number composed of the magnitude of one number and the sign of\n-    /// another.\n+    /// Returns a number composed of the magnitude of `self` and the sign of\n+    /// `y`.\n     ///\n     /// Equal to `self` if the sign of `self` and `y` are the same, otherwise\n-    /// equal to `-y`. If `self` is a `NAN`, then a `NAN` with the sign of `y`\n-    /// is returned.\n+    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n+    /// `y` is returned.\n     ///\n     /// # Examples\n     ///"}, {"sha": "ecaaf8323ab91a0b1105353a399af7182dca682a", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -176,12 +176,12 @@ impl f64 {\n         }\n     }\n \n-    /// Returns a number composed of the magnitude of one number and the sign of\n-    /// another.\n+    /// Returns a number composed of the magnitude of `self` and the sign of\n+    /// `y`.\n     ///\n     /// Equal to `self` if the sign of `self` and `y` are the same, otherwise\n-    /// equal to `-y`. If `self` is a `NAN`, then a `NAN` with the sign of `y`\n-    /// is returned.\n+    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n+    /// `y` is returned.\n     ///\n     /// # Examples\n     ///"}, {"sha": "6c95854c66cbf096fa2b29daa7b5425f2e3ef92d", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 669, "deletions": 28, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -8,72 +8,713 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[doc(keyword = \"as\")]\n+//\n+/// The keyword for casting a value to a type.\n+///\n+/// `as` is most commonly used to turn primitive types into other primitive types, but it has other\n+/// uses that include turning pointers into addresses, addresses into pointers, and pointers into\n+/// other pointers.\n+///\n+/// ```rust\n+/// let thing1: u8 = 89.0 as u8;\n+/// assert_eq!('B' as u32, 66);\n+/// assert_eq!(thing1 as char, 'Y');\n+/// let thing2: f32 = thing1 as f32 + 10.5;\n+/// assert_eq!(true as u8 + thing2 as u8, 100);\n+/// ```\n+///\n+/// In general, any cast that can be performed via ascribing the type can also be done using `as`,\n+/// so instead of writing `let x: u32 = 123`, you can write `let x = 123 as u32` (Note: `let x: u32\n+/// = 123` would be best in that situation). The same is not true in the other direction, however,\n+/// explicitly using `as` allows a few more coercions that aren't allowed implicitly, such as\n+/// changing the type of a raw pointer or turning closures into raw pointers.\n+///\n+/// Other places `as` is used include as extra syntax for [`crate`] and `use`, to change the name\n+/// something is imported as.\n+///\n+/// For more information on what `as` is capable of, see the [Reference]\n+///\n+/// [Reference]:\n+/// https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\n+/// [`crate`]: keyword.crate.html\n+mod as_keyword { }\n+\n+#[doc(keyword = \"const\")]\n+//\n+/// The keyword for defining constants.\n+///\n+/// Sometimes a certain value is used many times throughout a program, and it can become\n+/// inconvenient to copy it over and over. What's more, it's not always possible or desirable to\n+/// make it a variable that gets carried around to each function that needs it. In these cases, the\n+/// `const` keyword provides a convenient alternative to code duplication.\n+///\n+/// ```rust\n+/// const THING: u32 = 0xABAD1DEA;\n+///\n+/// let foo = 123 + THING;\n+/// ```\n+///\n+/// Constants must be explicitly typed, unlike with `let` you can't ignore its type and let the\n+/// compiler figure it out. Any constant value can be defined in a const, which in practice happens\n+/// to be most things that would be reasonable to have a constant (barring `const fn`s, coming\n+/// soon). For example, you can't have a File as a `const`.\n+///\n+/// The only lifetime allowed in a constant is `'static`, which is the lifetime that encompasses\n+/// all others in a Rust program. For example, if you wanted to define a constant string, it would\n+/// look like this:\n+///\n+/// ```rust\n+/// const WORDS: &'static str = \"hello rust!\";\n+/// ```\n+///\n+/// Thanks to static lifetime elision, you usually don't have to explicitly use 'static:\n+///\n+/// ```rust\n+/// const WORDS: &str = \"hello convenience!\";\n+/// ```\n+///\n+/// `const` items looks remarkably similar to `static` items, which introduces some confusion as\n+/// to which one should be used at which times. To put it simply, constants are inlined wherever\n+/// they're used, making using them identical to simply replacing the name of the const with its\n+/// value. Static variables on the other hand point to a single location in memory, which all\n+/// accesses share. This means that, unlike with constants, they can't have destructors, and act as\n+/// a single value across the entire codebase.\n+///\n+/// Constants, as with statics, should always be in SCREAMING_SNAKE_CASE.\n+///\n+/// The `const` keyword is also used in raw pointers in combination with `mut`, as seen in `*const\n+/// T` and `*mut T`. More about that can be read at the [pointer] primitive part of the Rust docs.\n+///\n+/// For more detail on `const`, see the [Rust Book] or the [Reference]\n+///\n+/// [pointer]: primitive.pointer.html\n+/// [Rust Book]:\n+/// https://doc.rust-lang.org/stable/book/2018-edition/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants\n+/// [Reference]: https://doc.rust-lang.org/reference/items/constant-items.html\n+mod const_keyword { }\n+\n+#[doc(keyword = \"crate\")]\n+//\n+/// The `crate` keyword.\n+///\n+/// The primary use of the `crate` keyword is as a part of `extern crate` declarations, which are\n+/// used to specify a dependency on a crate external to the one it's declared in. Crates are the\n+/// fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can\n+/// be read about crates in the [Reference].\n+///\n+/// ```rust ignore\n+/// extern crate rand;\n+/// extern crate my_crate as thing;\n+/// extern crate std; // implicitly added to the root of every Rust project\n+/// ```\n+///\n+/// The `as` keyword can be used to change what the crate is referred to as in your project. If a\n+/// crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.\n+///\n+/// `crate` is also used as in conjunction with `pub` to signify that the item it's attached to\n+/// is public only to other members of the same crate it's in.\n+///\n+/// ```rust\n+/// # #[allow(unused_imports)]\n+/// pub(crate) use std::io::Error as IoError;\n+/// pub(crate) enum CoolMarkerType { }\n+/// pub struct PublicThing {\n+///     pub(crate) semi_secret_thing: bool,\n+/// }\n+/// ```\n+///\n+/// [Reference]: https://doc.rust-lang.org/reference/items/extern-crates.html\n+mod crate_keyword { }\n+\n+#[doc(keyword = \"enum\")]\n+//\n+/// For defining enumerations.\n+///\n+/// Enums in Rust are similar to those of other compiled languages like C, but have important\n+/// differences that make them considerably more powerful. What Rust calls enums are more commonly\n+/// known as [Algebraic Data Types] if you're coming from a functional programming background. The\n+/// important detail is that each enum variant can have data to go along with it.\n+///\n+/// ```rust\n+/// # struct Coord;\n+/// enum SimpleEnum {\n+///     FirstVariant,\n+///     SecondVariant,\n+///     ThirdVariant,\n+/// }\n+///\n+/// enum Location {\n+///     Unknown,\n+///     Anonymous,\n+///     Known(Coord),\n+/// }\n+///\n+/// enum ComplexEnum {\n+///     Nothing,\n+///     Something(u32),\n+///     LotsOfThings {\n+///         usual_struct_stuff: bool,\n+///         blah: String,\n+///     }\n+/// }\n+///\n+/// enum EmptyEnum { }\n+/// ```\n+///\n+/// The first enum shown is the usual kind of enum you'd find in a C-style language. The second\n+/// shows off a hypothetical example of something storing location data, with `Coord` being any\n+/// other type that's needed, for example a struct. The third example demonstrates the kind of\n+/// data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.\n+///\n+/// Instantiating enum variants involves explicitly using the enum's name as its namespace,\n+/// followed by one of its variants. `SimpleEnum::SecondVariant` would be an example from above.\n+/// When data follows along with a variant, such as with rust's built-in [`Option`] type, the data\n+/// is added as the type describes, for example `Option::Some(123)`. The same follows with\n+/// struct-like variants, with things looking like `ComplexEnum::LotsOfThings { usual_struct_stuff:\n+/// true, blah: \"hello!\".to_string(), }`. Empty Enums are similar to () in that they cannot be\n+/// instantiated at all, and are used mainly to mess with the type system in interesting ways.\n+///\n+/// For more information, take a look at the [Rust Book] or the [Reference]\n+///\n+/// [Algebraic Data Types]: https://en.wikipedia.org/wiki/Algebraic_data_type\n+/// [`Option`]: option/enum.Option.html\n+/// [Rust Book]: https://doc.rust-lang.org/book/second-edition/ch06-01-defining-an-enum.html\n+/// [Reference]: https://doc.rust-lang.org/reference/items/enumerations.html\n+mod enum_keyword { }\n+\n+#[doc(keyword = \"extern\")]\n+//\n+/// For external connections in Rust code.\n+///\n+/// The `extern` keyword is used in two places in Rust. One is in conjunction with the [`crate`]\n+/// keyword to make your Rust code aware of other Rust crates in your project, i.e. `extern crate\n+/// lazy_static;`. The other use is in foreign function interfaces (FFI).\n+///\n+/// `extern` is used in two different contexts within FFI. The first is in the form of external\n+/// blocks, for declaring function interfaces that Rust code can call foreign code by.\n+///\n+/// ```rust ignore\n+/// #[link(name = \"my_c_library\")]\n+/// extern \"C\" {\n+///     fn my_c_function(x: i32) -> bool;\n+/// }\n+/// ```\n+///\n+/// This code would attempt to link with `libmy_c_library.so` on unix-like systems and\n+/// `my_c_library.dll` on Windows at runtime, and panic if it can't find something to link to. Rust\n+/// code could then use `my_c_function` as if it were any other unsafe Rust function. Working with\n+/// non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.\n+///\n+/// The mirror use case of FFI is also done via the `extern` keyword:\n+///\n+/// ```rust\n+/// #[no_mangle]\n+/// pub extern fn callable_from_c(x: i32) -> bool {\n+///     x % 3 == 0\n+/// }\n+/// ```\n+///\n+/// If compiled as a dylib, the resulting .so could then be linked to from a C library, and the\n+/// function could be used as if it was from any other library.\n+///\n+/// For more information on FFI, check the [Rust book] or the [Reference].\n+///\n+/// [Rust book]:\n+/// https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code\n+/// [Reference]: https://doc.rust-lang.org/reference/items/external-blocks.html\n+mod extern_keyword { }\n+\n #[doc(keyword = \"fn\")]\n //\n-/// The `fn` keyword.\n+/// The keyword for defining functions.\n ///\n-/// The `fn` keyword is used to declare a function.\n+/// Functions are the primary way code is executed within Rust. Function blocks, usually just\n+/// called functions, can be defined in a variety of different places and be assigned many\n+/// different attributes and modifiers.\n ///\n-/// Example:\n+/// Standalone functions that just sit within a module not attached to anything else are common,\n+/// but most functions will end up being inside [`impl`] blocks, either on another type itself, or\n+/// as a trait impl for that type.\n ///\n /// ```rust\n-/// fn some_function() {\n-///     // code goes in here\n+/// fn standalone_function() {\n+///     // code\n+/// }\n+///\n+/// pub fn public_thing(argument: bool) -> String {\n+///     // code\n+///     # \"\".to_string()\n+/// }\n+///\n+/// struct Thing {\n+///     foo: i32,\n+/// }\n+///\n+/// impl Thing {\n+///     pub fn new() -> Self {\n+///         Self {\n+///             foo: 42,\n+///         }\n+///     }\n /// }\n /// ```\n ///\n-/// For more information about functions, take a look at the [Rust Book][book].\n+/// In addition to presenting fixed types in the form of `fn name(arg: type, ..) -> return_type`,\n+/// functions can also declare a list of type parameters along with trait bounds that they fall\n+/// into.\n ///\n-/// [book]: https://doc.rust-lang.org/book/second-edition/ch03-03-how-functions-work.html\n+/// ```rust\n+/// fn generic_function<T: Clone>(x: T) -> (T, T, T) {\n+///     (x.clone(), x.clone(), x.clone())\n+/// }\n+///\n+/// fn generic_where<T>(x: T) -> T\n+///     where T: std::ops::Add<Output=T> + Copy\n+/// {\n+///     x + x + x\n+/// }\n+/// ```\n+///\n+/// Declaring trait bounds in the angle brackets is functionally identical to using a `where`\n+/// clause. It's up to the programmer to decide which works better in each situation, but `where`\n+/// tends to be better when things get longer than one line.\n+///\n+/// Along with being made public via `pub`, `fn` can also have an [`extern`] added for use in\n+/// FFI.\n+///\n+/// For more information on the various types of functions and how they're used, consult the [Rust\n+/// book] or the [Reference].\n+///\n+/// [`impl`]: keyword.impl.html\n+/// [`extern`]: keyword.extern.html\n+/// [Rust book]: https://doc.rust-lang.org/book/second-edition/ch03-03-how-functions-work.html\n+/// [Reference]: https://doc.rust-lang.org/reference/items/functions.html\n mod fn_keyword { }\n \n-#[doc(keyword = \"let\")]\n+#[doc(keyword = \"for\")]\n //\n-/// The `let` keyword.\n+/// The `for` keyword.\n+///\n+/// `for` is primarily used in for-in-loops, but it has a few other pieces of syntactic uses such as\n+/// `impl Trait for Type` (see [`impl`] for more info on that). for-in-loops, or to be more\n+/// precise, iterator loops, are a simple syntactic sugar over an exceedingly common practice\n+/// within Rust, which is to loop over an iterator until that iterator returns None (or `break`\n+/// is called).\n+///\n+/// ```rust\n+/// for i in 0..5 {\n+///     println!(\"{}\", i * 2);\n+/// }\n ///\n-/// The `let` keyword is used to declare a variable.\n+/// for i in std::iter::repeat(5) {\n+///     println!(\"turns out {} never stops being 5\", i);\n+///     break; // would loop forever otherwise\n+/// }\n ///\n-/// Example:\n+/// 'outer: for x in 5..50 {\n+///     for y in 0..10 {\n+///         if x == y {\n+///             break 'outer;\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// As shown in the example above, `for` loops (along with all other loops) can be tagged, using\n+/// similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the\n+/// same tag to `break` breaks the tagged loop, which is useful for inner loops. It is definitely\n+/// not a goto.\n+///\n+/// A `for` loop expands as shown:\n ///\n /// ```rust\n-/// # #![allow(unused_assignments)]\n-/// let x = 3; // We create a variable named `x` with the value `3`.\n+/// # fn code() { }\n+/// # let iterator = 0..2;\n+/// for loop_variable in iterator {\n+///     code()\n+/// }\n+/// ```\n+///\n+/// ```rust\n+/// # fn code() { }\n+/// # let iterator = 0..2;\n+/// {\n+///     let mut _iter = std::iter::IntoIterator::into_iter(iterator);\n+///     loop {\n+///         match _iter.next() {\n+///             Some(loop_variable) => {\n+///                 code()\n+///             },\n+///             None => break,\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// More details on the functionality shown can be seen at the [`IntoIterator`] docs.\n+///\n+/// For more information on for-loops, see the [Rust book] or the [Reference].\n+///\n+/// [`impl`]: keyword.impl.html\n+/// [`IntoIterator`]: iter/trait.IntoIterator.html\n+/// [Rust book]:\n+/// https://doc.rust-lang.org/book/2018-edition/ch03-05-control-flow.html#looping-through-a-collection-with-for\n+/// [Reference]: https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops\n+mod for_keyword { }\n+\n+#[doc(keyword = \"if\")]\n+//\n+/// If statements and expressions.\n+///\n+/// `if` is a familiar construct to most programmers, and is the main way you'll often do logic in\n+/// your code. However, unlike in most languages, `if` blocks can also act as expressions.\n+///\n+/// ```rust\n+/// # let rude = true;\n+/// if 1 == 2 {\n+///     println!(\"whoops, mathematics broke\");\n+/// } else {\n+///     println!(\"everything's fine!\");\n+/// }\n+///\n+/// let greeting = if rude {\n+///     \"sup nerd.\"\n+/// } else {\n+///     \"hello, friend!\"\n+/// };\n+///\n+/// if let Ok(x) = \"123\".parse::<i32>() {\n+///     println!(\"{} double that and you get {}!\", greeting, x * 2);\n+/// }\n+/// ```\n+///\n+/// Shown above are the three typical forms an `if` block comes in. First is the usual kind of\n+/// thing you'd see in many languages, with an optional `else` block. Second uses `if` as an\n+/// expression, which is only possible if all branches return the same type. An `if` expression can\n+/// be used everywhere you'd expect. The third kind of `if` block is an `if let` block, which\n+/// behaves similarly to using a `match` expression:\n+///\n+/// ```rust\n+/// if let Some(x) = Some(123) {\n+///     // code\n+///     # let _ = x;\n+/// } else {\n+///     // something else\n+/// }\n+///\n+/// match Some(123) {\n+///     Some(x) => {\n+///         // code\n+///         # let _ = x;\n+///     },\n+///     _ => {\n+///         // something else\n+///     },\n+/// }\n+/// ```\n+///\n+/// Each kind of `if` expression can be mixed and matched as needed.\n+///\n+/// ```rust\n+/// if true == false {\n+///     println!(\"oh no\");\n+/// } else if \"something\" == \"other thing\" {\n+///     println!(\"oh dear\");\n+/// } else if let Some(200) = \"blarg\".parse::<i32>().ok() {\n+///     println!(\"uh oh\");\n+/// } else {\n+///     println!(\"phew, nothing's broken\");\n+/// }\n+/// ```\n+///\n+/// The `if` keyword is used in one other place in Rust, namely as a part of pattern matching\n+/// itself, allowing patterns such as `Some(x) if x > 200` to be used.\n+///\n+/// For more information on `if` expressions, see the [Rust book] or the [Reference].\n+///\n+/// [Rust book]:\n+/// https://doc.rust-lang.org/stable/book/2018-edition/ch03-05-control-flow.html#if-expressions\n+/// [Reference]: https://doc.rust-lang.org/reference/expressions/if-expr.html\n+mod if_keyword { }\n+\n+#[doc(keyword = \"impl\")]\n+//\n+/// The implementation-defining keyword.\n+///\n+/// The `impl` keyword is primarily used to define implementations on types. Inherent\n+/// implementations are standalone, while trait implementations are used to implement traits for\n+/// types, or other traits.\n+///\n+/// Functions and consts can both be defined in an implementation. A function defined in an\n+/// `impl` block can be standalone, meaning it would be called like `Foo::bar()`. If the function\n+/// takes `self`, `&self`, or `&mut self` as its first argument, it can also be called using\n+/// method-call syntax, a familiar feature to any object oriented programmer, like `foo.bar()`.\n+///\n+/// ```rust\n+/// struct Example {\n+///     number: i32,\n+/// }\n+///\n+/// impl Example {\n+///     fn boo() {\n+///         println!(\"boo! Example::boo() was called!\");\n+///     }\n+///\n+///     fn answer(&mut self) {\n+///         self.number += 42;\n+///     }\n+///\n+///     fn get_number(&self) -> i32 {\n+///         self.number\n+///     }\n+/// }\n+///\n+/// trait Thingy {\n+///     fn do_thingy(&self);\n+/// }\n+///\n+/// impl Thingy for Example {\n+///     fn do_thingy(&self) {\n+///         println!(\"doing a thing! also, number is {}!\", self.number);\n+///     }\n+/// }\n /// ```\n ///\n-/// By default, all variables are **not** mutable. If you want a mutable variable,\n-/// you'll have to use the `mut` keyword.\n+/// For more information on implementations, see the [Rust book][book1] or the [Reference].\n ///\n-/// Example:\n+/// The other use of the `impl` keyword is in `impl Trait` syntax, which can be seen as a shorthand\n+/// for \"a concrete type that implements this trait\". Its primary use is working with closures,\n+/// which have type definitions generated at compile time that can't be simply typed out.\n+///\n+/// ```rust\n+/// fn thing_returning_closure() -> impl Fn(i32) -> bool {\n+///     println!(\"here's a closure for you!\");\n+///     |x: i32| x % 3 == 0\n+/// }\n+/// ```\n+///\n+/// For more information on `impl Trait` syntax, see the [Rust book][book2].\n+///\n+/// [book1]: https://doc.rust-lang.org/stable/book/2018-edition/ch05-03-method-syntax.html\n+/// [Reference]: https://doc.rust-lang.org/reference/items/implementations.html\n+/// [book2]:\n+/// https://doc.rust-lang.org/stable/book/2018-edition/ch10-02-traits.html#returning-traits\n+mod impl_keyword { }\n+\n+#[doc(keyword = \"let\")]\n+//\n+/// The variable binding keyword.\n+///\n+/// The primary use for the `let` keyword is in `let` statements, which are used to introduce a new\n+/// set of variables into the current scope, as given by a pattern.\n ///\n /// ```rust\n /// # #![allow(unused_assignments)]\n-/// let mut x = 3; // We create a mutable variable named `x` with the value `3`.\n+/// let thing1: i32 = 100;\n+/// let thing2 = 200 + thing1;\n+///\n+/// let mut changing_thing = true;\n+/// changing_thing = false;\n ///\n-/// x += 4; // `x` is now equal to `7`.\n+/// let (part1, part2) = (\"first\", \"second\");\n+///\n+/// struct Example {\n+///     a: bool,\n+///     b: u64,\n+/// }\n+///\n+/// let Example { a, b: _ } = Example {\n+///     a: true,\n+///     b: 10004,\n+/// };\n+/// assert!(a);\n+/// ```\n+///\n+/// The pattern is most commonly a single variable, which means no pattern matching is done and\n+/// the expression given is bound to the variable. Apart from that, patterns used in `let` bindings\n+/// can be as complicated as needed, given that the pattern is exhaustive. See the [Rust\n+/// book][book1] for more information on pattern matching. The type of the pattern is optionally\n+/// given afterwards, but if left blank is automatically inferred by the compiler if possible.\n+///\n+/// Variables in Rust are immutable by default, and require the `mut` keyword to be made mutable.\n+///\n+/// Multiple variables can be defined with the same name, known as shadowing. This doesn't affect\n+/// the original variable in any way beyond being unable to directly access it beyond the point of\n+/// shadowing. It continues to remain in scope, getting dropped only when it falls out of scope.\n+/// Shadowed variables don't need to have the same type as the variables shadowing them.\n+///\n+/// ```rust\n+/// let shadowing_example = true;\n+/// let shadowing_example = 123.4;\n+/// let shadowing_example = shadowing_example as u32;\n+/// let mut shadowing_example = format!(\"cool! {}\", shadowing_example);\n+/// shadowing_example += \" something else!\"; // not shadowing\n /// ```\n ///\n-/// For more information about the `let` keyword, take a look at the [Rust Book][book].\n+/// Other places the `let` keyword is used include along with [`if`], in the form of `if let`\n+/// expressions. They're useful if the pattern being matched isn't exhaustive, such as with\n+/// enumerations. `while let` also exists, which runs a loop with a pattern matched value until\n+/// that pattern can't be matched.\n ///\n-/// [book]: https://doc.rust-lang.org/book/second-edition/ch03-01-variables-and-mutability.html\n+/// For more information on the `let` keyword, see the [Rust book] or the [Reference]\n+///\n+/// [book1]: https://doc.rust-lang.org/stable/book/2018-edition/ch06-02-match.html\n+/// [`if`]: keyword.if.html\n+/// [book2]:\n+/// https://doc.rust-lang.org/stable/book/2018-edition/ch18-01-all-the-places-for-patterns.html#let-statements\n+/// [Reference]: https://doc.rust-lang.org/reference/statements.html#let-statements\n mod let_keyword { }\n \n-#[doc(keyword = \"struct\")]\n+#[doc(keyword = \"loop\")]\n //\n-/// The `struct` keyword.\n+/// The loop-defining keyword.\n ///\n-/// The `struct` keyword is used to define a struct type.\n+/// `loop` is used to define the simplest kind of loop supported in Rust. It runs the code inside\n+/// it until the code uses `break` or the program exits.\n ///\n-/// Example:\n+/// ```rust\n+/// loop {\n+///     println!(\"hello world forever!\");\n+///     # break;\n+/// }\n ///\n+/// let mut i = 0;\n+/// loop {\n+///     println!(\"i is {}\", i);\n+///     if i > 10 {\n+///         break;\n+///     }\n+///     i += 1;\n+/// }\n /// ```\n-/// struct Foo {\n-///     field1: u32,\n+///\n+/// Unlike the other kinds of loops in Rust (`while`, `while let`, and `for`), loops can be used as\n+/// expressions that return values via `break`.\n+///\n+/// ```rust\n+/// let mut i = 1;\n+/// let something = loop {\n+///     i *= 2;\n+///     if i > 100 {\n+///         break i;\n+///     }\n+/// };\n+/// assert_eq!(something, 128);\n+/// ```\n+///\n+/// Every `break` in a loop has to have the same type. When it's not explicitly giving something,\n+/// `break;` returns `()`.\n+///\n+/// For more information on `loop` and loops in general, see the [Reference].\n+///\n+/// [Reference]: https://doc.rust-lang.org/reference/expressions/loop-expr.html\n+mod loop_keyword { }\n+\n+#[doc(keyword = \"struct\")]\n+//\n+/// The keyword used to define structs.\n+///\n+/// Structs in Rust come in three flavours: Structs with named fields, tuple structs, and unit\n+/// structs.\n+///\n+/// ```rust\n+/// struct Regular {\n+///     field1: f32,\n ///     field2: String,\n+///     pub field3: bool\n+/// }\n+///\n+/// struct Tuple(u32, String);\n+///\n+/// struct Unit;\n+/// ```\n+///\n+/// Regular structs are the most commonly used. Each field defined within them has a name and a\n+/// type, and once defined can be accessed using `example_struct.field` syntax. The fields of a\n+/// struct share its mutability, so `foo.bar = 2;` would only be valid if `foo` was mutable. Adding\n+/// `pub` to a field makes it visible to code in other modules, as well as allowing it to be\n+/// directly accessed and modified.\n+///\n+/// Tuple structs are similar to regular structs, but its fields have no names. They are used like\n+/// tuples, with deconstruction possible via `let TupleStruct(x, y) = foo;` syntax.  For accessing\n+/// individual variables, the same syntax is used as with regular tuples, namely `foo.0`, `foo.1`,\n+/// etc, starting at zero.\n+///\n+/// Unit structs are most commonly used as marker. They have a size of zero bytes, but unlike empty\n+/// enums they can be instantiated, making them isomorphic to the unit type `()`. Unit structs are\n+/// useful when you need to implement a trait on something, but don't need to store any data inside\n+/// it.\n+///\n+/// # Instantiation\n+///\n+/// Structs can be instantiated in different ways, all of which can be mixed and\n+/// matched as needed. The most common way to make a new struct is via a constructor method such as\n+/// `new()`, but when that isn't available (or you're writing the constructor itself), struct\n+/// literal syntax is used:\n+///\n+/// ```rust\n+/// # struct Foo { field1: f32, field2: String, etc: bool }\n+/// let example = Foo {\n+///     field1: 42.0,\n+///     field2: \"blah\".to_string(),\n+///     etc: true,\n+/// };\n+/// ```\n+///\n+/// It's only possible to directly instantiate a struct using struct literal syntax when all of its\n+/// fields are visible to you.\n+///\n+/// There are a handful of shortcuts provided to make writing constructors more convenient, most\n+/// common of which is the Field Init shorthand. When there is a variable and a field of the same\n+/// name, the assignment can be simplified from `field: field` into simply `field`. The following\n+/// example of a hypothetical constructor demonstrates this:\n+///\n+/// ```rust\n+/// struct User {\n+///     name: String,\n+///     admin: bool,\n+/// }\n+///\n+/// impl User {\n+///     pub fn new(name: String) -> Self {\n+///         Self {\n+///             name,\n+///             admin: false,\n+///         }\n+///     }\n /// }\n /// ```\n ///\n-/// There are different kinds of structs. For more information, take a look at the\n-/// [Rust Book][book].\n+/// Another shortcut for struct instantiation is available, used when you need to make a new\n+/// struct that has the same values as most of a previous struct of the same type, called struct\n+/// update syntax:\n+///\n+/// ```rust\n+/// # struct Foo { field1: String, field2: () }\n+/// # let thing = Foo { field1: \"\".to_string(), field2: () };\n+/// let updated_thing = Foo {\n+///     field1: \"a new value\".to_string(),\n+///     ..thing\n+/// };\n+/// ```\n+///\n+/// Tuple structs are instantiated in the same way as tuples themselves, except with the struct's\n+/// name as a prefix: `Foo(123, false, 0.1)`.\n+///\n+/// Empty structs are instantiated with just their name, and don't need anything else. `let thing =\n+/// EmptyStruct;`\n+///\n+/// # Style conventions\n+///\n+/// Structs are always written in CamelCase, with few exceptions. While the trailing comma on a\n+/// struct's list of fields can be omitted, it's usually kept for convenience in adding and\n+/// removing fields down the line.\n+///\n+/// For more information on structs, take a look at the [Rust Book][book] or the\n+/// [Reference][reference].\n ///\n+/// [`PhantomData`]: marker/struct.PhantomData.html\n /// [book]: https://doc.rust-lang.org/book/second-edition/ch05-01-defining-structs.html\n+/// [reference]: https://doc.rust-lang.org/reference/items/structs.html\n mod struct_keyword { }"}, {"sha": "ad212a547579ba21df935237c4f8b16fa236e511", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -43,12 +43,12 @@ use time::Duration;\n /// use std::io::prelude::*;\n /// use std::net::TcpStream;\n ///\n-/// {\n-///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+/// fn main() -> std::io::Result<()> {\n+///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\")?;\n ///\n-///     // ignore the Result\n-///     let _ = stream.write(&[1]);\n-///     let _ = stream.read(&mut [0; 128]); // ignore here too\n+///     stream.write(&[1])?;\n+///     stream.read(&mut [0; 128])?;\n+///     Ok(())\n /// } // the stream is closed here\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c2a16122a0dd1a2bb3383d351f8081b9276b2522", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -323,8 +323,8 @@ mod prim_never { }\n /// let s = String::from(\"love: \u2764\ufe0f\");\n /// let v: Vec<char> = s.chars().collect();\n ///\n-/// assert_eq!(12, s.len() * std::mem::size_of::<u8>());\n-/// assert_eq!(32, v.len() * std::mem::size_of::<char>());\n+/// assert_eq!(12, std::mem::size_of_val(&s[..]));\n+/// assert_eq!(32, std::mem::size_of_val(&v[..]));\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_char { }"}, {"sha": "a9219f75362db4dddb74cb879b98b305d05d5731", "filename": "src/libstd/process.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1016,27 +1016,115 @@ impl fmt::Debug for Stdio {\n \n #[stable(feature = \"stdio_from\", since = \"1.20.0\")]\n impl From<ChildStdin> for Stdio {\n+    /// Converts a `ChildStdin` into a `Stdio`\n+    ///\n+    /// # Examples\n+    ///\n+    /// `ChildStdin` will be converted to `Stdio` using `Stdio::from` under the hood.\n+    ///\n+    /// ```rust\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let reverse = Command::new(\"rev\")\n+    ///     .stdin(Stdio::piped())\n+    ///     .spawn()\n+    ///     .expect(\"failed reverse command\");\n+    ///\n+    /// let _echo = Command::new(\"echo\")\n+    ///     .arg(\"Hello, world!\")\n+    ///     .stdout(reverse.stdin.unwrap()) // Converted into a Stdio here\n+    ///     .output()\n+    ///     .expect(\"failed echo command\");\n+    ///\n+    /// // \"!dlrow ,olleH\" echoed to console\n+    /// ```\n     fn from(child: ChildStdin) -> Stdio {\n         Stdio::from_inner(child.into_inner().into())\n     }\n }\n \n #[stable(feature = \"stdio_from\", since = \"1.20.0\")]\n impl From<ChildStdout> for Stdio {\n+    /// Converts a `ChildStdout` into a `Stdio`\n+    ///\n+    /// # Examples\n+    ///\n+    /// `ChildStdout` will be converted to `Stdio` using `Stdio::from` under the hood.\n+    ///\n+    /// ```rust\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let hello = Command::new(\"echo\")\n+    ///     .arg(\"Hello, world!\")\n+    ///     .stdout(Stdio::piped())\n+    ///     .spawn()\n+    ///     .expect(\"failed echo command\");\n+    ///\n+    /// let reverse = Command::new(\"rev\")\n+    ///     .stdin(hello.stdout.unwrap())  // Converted into a Stdio here\n+    ///     .output()\n+    ///     .expect(\"failed reverse command\");\n+    ///\n+    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\\n\");\n+    /// ```\n     fn from(child: ChildStdout) -> Stdio {\n         Stdio::from_inner(child.into_inner().into())\n     }\n }\n \n #[stable(feature = \"stdio_from\", since = \"1.20.0\")]\n impl From<ChildStderr> for Stdio {\n+    /// Converts a `ChildStderr` into a `Stdio`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// let reverse = Command::new(\"rev\")\n+    ///     .arg(\"non_existing_file.txt\")\n+    ///     .stderr(Stdio::piped())\n+    ///     .spawn()\n+    ///     .expect(\"failed reverse command\");\n+    ///\n+    /// let cat = Command::new(\"cat\")\n+    ///     .arg(\"-\")\n+    ///     .stdin(reverse.stderr.unwrap()) // Converted into a Stdio here\n+    ///     .output()\n+    ///     .expect(\"failed echo command\");\n+    ///\n+    /// assert_eq!(\n+    ///     String::from_utf8_lossy(&cat.stdout),\n+    ///     \"rev: cannot open non_existing_file.txt: No such file or directory\\n\"\n+    /// );\n+    /// ```\n     fn from(child: ChildStderr) -> Stdio {\n         Stdio::from_inner(child.into_inner().into())\n     }\n }\n \n #[stable(feature = \"stdio_from\", since = \"1.20.0\")]\n impl From<fs::File> for Stdio {\n+    /// Converts a `File` into a `Stdio`\n+    ///\n+    /// # Examples\n+    ///\n+    /// `File` will be converted to `Stdio` using `Stdio::from` under the hood.\n+    ///\n+    /// ```rust,no_run\n+    /// use std::fs::File;\n+    /// use std::process::Command;\n+    ///\n+    /// // With the `foo.txt` file containing `Hello, world!\"\n+    /// let file = File::open(\"foo.txt\").unwrap();\n+    ///\n+    /// let reverse = Command::new(\"rev\")\n+    ///     .stdin(file)  // Implicit File convertion into a Stdio\n+    ///     .output()\n+    ///     .expect(\"failed reverse command\");\n+    ///\n+    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\");\n+    /// ```\n     fn from(file: fs::File) -> Stdio {\n         Stdio::from_inner(file.into_inner().into())\n     }"}, {"sha": "a7db372a0e20a86a42cf326c78d4949f4531fc2c", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -97,7 +97,7 @@\n //! - A **multiprocessor** system executing multiple hardware threads\n //!   at the same time: In multi-threaded scenarios, you can use two\n //!   kinds of primitives to deal with synchronization:\n-//!   - [memory fences] to ensure memory accesses are made visibile to\n+//!   - [memory fences] to ensure memory accesses are made visible to\n //!   other CPUs in the right order.\n //!   - [atomic operations] to ensure simultaneous access to the same\n //!   memory location doesn't lead to undefined behavior."}, {"sha": "cf9698cb2a9712b6a2439314503c0aef40e63ffd", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -290,8 +290,8 @@ impl Once {\n     }\n \n     /// Returns true if some `call_once` call has completed\n-    /// successfuly. Specifically, `is_completed` will return false in\n-    /// the following situtations:\n+    /// successfully. Specifically, `is_completed` will return false in\n+    /// the following situations:\n     ///   * `call_once` was not called at all,\n     ///   * `call_once` was called, but has not yet completed,\n     ///   * the `Once` instance is poisoned"}, {"sha": "d8fb20d425008e44fbec4d40019a0e77f9eb34a7", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -96,7 +96,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// when the configuration predicate is true, or otherwise expand into an\n     /// empty list of attributes.\n     ///\n-    /// Gives a compiler warning when the `cfg_attr` contains no attribtes and\n+    /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect\n     fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Vec<ast::Attribute> {\n@@ -138,7 +138,7 @@ impl<'a> StripUnconfigured<'a> {\n         };\n \n         // Check feature gate and lint on zero attributes in source. Even if the feature is gated,\n-        // we still compute as if it wasn't, since the emitted error will stop compilation futher\n+        // we still compute as if it wasn't, since the emitted error will stop compilation further\n         // along the compilation.\n         match (expanded_attrs.len(), gate_cfg_attr_multi) {\n             (0, false) => {"}, {"sha": "805aa9bef227d1d1b524e41c0074a281c1a079d1", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -905,7 +905,8 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n             \"path\" | \"ty\" => match *tok {\n                 TokenTree::Token(_, ref tok) => match *tok {\n                     OpenDelim(token::DelimToken::Brace) | OpenDelim(token::DelimToken::Bracket) |\n-                    Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n+                    Comma | FatArrow | Colon | Eq | Gt | BinOp(token::Shr) | Semi |\n+                    BinOp(token::Or) => Ok(true),\n                     Ident(i, false) if i.name == \"as\" || i.name == \"where\" => Ok(true),\n                     _ => Ok(false)\n                 },"}, {"sha": "18d5970462f63ccd6aaf582f9c5c3362a28eaacf", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -965,7 +965,7 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             polarity,\n             defaultness,\n             folder.fold_generics(generics),\n-            ifce.map(|trait_ref| folder.fold_trait_ref(trait_ref.clone())),\n+            ifce.map(|trait_ref| folder.fold_trait_ref(trait_ref)),\n             folder.fold_ty(ty),\n             impl_items.move_flat_map(|item| folder.fold_impl_item(item)),\n         ),"}, {"sha": "431766a3fbcfb6dafb2d5a3866c1609bf44ee554", "filename": "src/stdsimd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdsimd?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1 +1 @@\n-Subproject commit 307650500de5b44dc1047dc9d15e449e09d92b57\n+Subproject commit 431766a3fbcfb6dafb2d5a3866c1609bf44ee554"}, {"sha": "2abcd4b7ba99c49eb2ad6b4c1c88e228de7818ac", "filename": "src/test/run-pass/issues/issue-18804/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18804%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18804%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18804%2Fmain.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // run-pass\n-// Test for issue #18804, #[linkage] does not propagate thorugh generic\n+// Test for issue #18804, #[linkage] does not propagate through generic\n // functions. Failure results in a linker error.\n \n // ignore-asmjs no weak symbol support"}, {"sha": "e81b2c7a7233b197eb8112d698dfca596bae84d1", "filename": "src/test/run-pass/macros/issue-25274.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frun-pass%2Fmacros%2Fissue-25274.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frun-pass%2Fmacros%2Fissue-25274.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros%2Fissue-25274.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -0,0 +1,16 @@\n+macro_rules! test {\n+    (\n+        fn fun() -> Option<Box<$t:ty>>;\n+    ) => {\n+        fn fun(x: $t) -> Option<Box<$t>>\n+        { Some(Box::new(x)) }\n+    }\n+}\n+\n+test! {\n+    fn fun() -> Option<Box<i32>>;\n+}\n+\n+fn main() {\n+    println!(\"{}\", fun(0).unwrap());\n+}"}, {"sha": "932fe1c8eb0b2a400f28aae56be0a25837670e6d", "filename": "src/test/rustdoc-ui/failed-doctest-output.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -15,6 +15,7 @@\n // compile-flags:--test\n // normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n // failure-status: 101\n+// rustc-env:RUST_BACKTRACE=0\n \n // doctest fails at runtime\n /// ```"}, {"sha": "876f6c0a80b1da7485360a9f62dbb118f3759c08", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1,22 +1,22 @@\n \n running 2 tests\n-test $DIR/failed-doctest-output.rs - OtherStruct (line 26) ... FAILED\n-test $DIR/failed-doctest-output.rs - SomeStruct (line 20) ... FAILED\n+test $DIR/failed-doctest-output.rs - OtherStruct (line 27) ... FAILED\n+test $DIR/failed-doctest-output.rs - SomeStruct (line 21) ... FAILED\n \n failures:\n \n----- $DIR/failed-doctest-output.rs - OtherStruct (line 26) stdout ----\n+---- $DIR/failed-doctest-output.rs - OtherStruct (line 27) stdout ----\n error[E0425]: cannot find value `no` in this scope\n- --> $DIR/failed-doctest-output.rs:27:1\n+ --> $DIR/failed-doctest-output.rs:28:1\n   |\n 3 | no\n   | ^^ not found in this scope\n \n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 26)' panicked at 'couldn't compile the test', librustdoc/test.rs:332:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 27)' panicked at 'couldn't compile the test', librustdoc/test.rs:332:13\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n----- $DIR/failed-doctest-output.rs - SomeStruct (line 20) stdout ----\n-thread '$DIR/failed-doctest-output.rs - SomeStruct (line 20)' panicked at 'test executable failed:\n+---- $DIR/failed-doctest-output.rs - SomeStruct (line 21) stdout ----\n+thread '$DIR/failed-doctest-output.rs - SomeStruct (line 21)' panicked at 'test executable failed:\n \n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n@@ -25,8 +25,8 @@ note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n \n failures:\n-    $DIR/failed-doctest-output.rs - OtherStruct (line 26)\n-    $DIR/failed-doctest-output.rs - SomeStruct (line 20)\n+    $DIR/failed-doctest-output.rs - OtherStruct (line 27)\n+    $DIR/failed-doctest-output.rs - SomeStruct (line 21)\n \n test result: FAILED. 0 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "4811f363bc97a388a395941cae7248ce9a5a12f3", "filename": "src/test/rustdoc/issue-54478-demo-allocator.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frustdoc%2Fissue-54478-demo-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Frustdoc%2Fissue-54478-demo-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-54478-demo-allocator.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -0,0 +1,42 @@\n+// Issue #54478: regression test showing that we can demonstrate\n+// `#[global_allocator]` in code blocks built by `rustdoc`.\n+//\n+// ## Background\n+//\n+// Changes in lang-item visibility injected failures that were only\n+// exposed when compiling with `-C prefer-dynamic`. But `rustdoc` used\n+// `-C prefer-dynamic` (and had done so for years, for reasons we did\n+// not document at that time).\n+//\n+// Rather than try to revise the visbility semanics, we instead\n+// decided to change `rustdoc` to behave more like the compiler's\n+// default setting, by leaving off `-C prefer-dynamic`.\n+\n+// compile-flags:--test\n+\n+//! This is a doc comment\n+//!\n+//! ```rust\n+//! use std::alloc::*;\n+//!\n+//! #[global_allocator]\n+//! static ALLOC: A = A;\n+//!\n+//! static mut HIT: bool = false;\n+//!\n+//! struct A;\n+//!\n+//! unsafe impl GlobalAlloc for A {\n+//!     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+//!         HIT = true;\n+//!         System.alloc(layout)\n+//!     }\n+//!     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+//!         System.dealloc(ptr, layout);\n+//!     }\n+//! }\n+//!\n+//! fn main() {\n+//!     assert!(unsafe { HIT });\n+//! }\n+//! ```"}, {"sha": "6b9d4ebb2987dd3f53376c99909d0c3e09041e7c", "filename": "src/test/ui/associated-types/bound-lifetime-in-binding-only.elision.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.elision.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -2,10 +2,9 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/bound-lifetime-in-binding-only.rs:62:23\n    |\n LL | fn elision<T: Fn() -> &i32>() {\n-   |                       ^ expected lifetime parameter\n+   |                       ^ help: consider giving it a 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = help: consider giving it a 'static lifetime\n \n error: aborting due to previous error\n "}, {"sha": "7906f0a30e4eb33a33306e9db4b2a1b9c0f6a303", "filename": "src/test/ui/associated-types/bound-lifetime-in-return-only.elision.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.elision.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -2,10 +2,9 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/bound-lifetime-in-return-only.rs:44:23\n    |\n LL | fn elision(_: fn() -> &i32) {\n-   |                       ^ expected lifetime parameter\n+   |                       ^ help: consider giving it a 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = help: consider giving it a 'static lifetime\n \n error: aborting due to previous error\n "}, {"sha": "b116888d63c1008c627dc772f585260ff4a396b1", "filename": "src/test/ui/block-result/unexpected-return-on-unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fblock-result%2Funexpected-return-on-unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fblock-result%2Funexpected-return-on-unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Funexpected-return-on-unit.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we do some basic error correcton in the tokeniser (and don't spew\n+// Test that we do some basic error correction in the tokeniser (and don't spew\n // too many bogus errors).\n \n fn foo() -> usize {"}, {"sha": "ec4ee80b498a57c6d8a31ff9bff4833a1106eec0", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-false.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-false.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-false.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-false.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1,5 +1,5 @@\n // Test that cfg_attr doesn't emit any attributes when the\n-// configuation variable is false. This mirrors `cfg-attr-multi-true.rs`\n+// configuration variable is false. This mirrors `cfg-attr-multi-true.rs`\n \n // compile-pass\n "}, {"sha": "1c79499ba590276610c31e1b179e6dcc5dc35bb7", "filename": "src/test/ui/did_you_mean/issue-42764.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -20,4 +20,20 @@ fn main() {\n     let n: usize = 42;\n     this_function_expects_a_double_option(n);\n     //~^ ERROR mismatched types\n+    //~| HELP try using a variant of the expected type\n+}\n+\n+\n+// But don't issue the \"try using a variant\" help if the one-\"variant\" ADT is\n+// actually a one-field struct.\n+\n+struct Payload;\n+\n+struct Wrapper { payload: Payload }\n+\n+struct Context { wrapper: Wrapper }\n+\n+fn overton() {\n+    let _c = Context { wrapper: Payload{} };\n+    //~^ ERROR mismatched types\n }"}, {"sha": "e256a436affbad2bc4ad8bfe793d39bf835979ec", "filename": "src/test/ui/did_you_mean/issue-42764.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -13,6 +13,15 @@ LL |     this_function_expects_a_double_option(DoubleOption::FirstSome(n));\n LL |     this_function_expects_a_double_option(DoubleOption::AlternativeSome(n));\n    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-42764.rs:37:33\n+   |\n+LL |     let _c = Context { wrapper: Payload{} };\n+   |                                 ^^^^^^^^^ expected struct `Wrapper`, found struct `Payload`\n+   |\n+   = note: expected type `Wrapper`\n+              found type `Payload`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "9fc35eae7052f694483ade5c2f33d843d6b037fd", "filename": "src/test/ui/foreign-fn-return-lifetime.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.fixed?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-rustfix\n+\n+extern \"C\" {\n+    pub fn g(_: &u8) -> &u8; // OK\n+    pub fn f() -> &'static u8; //~ ERROR missing lifetime specifier\n+}\n+\n+fn main() {}"}, {"sha": "941e7e05a3635f47d4f7d381fa42e8e3abc12a0a", "filename": "src/test/ui/foreign-fn-return-lifetime.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// run-rustfix\n+\n extern \"C\" {\n-    fn g(_: &u8) -> &u8; // OK\n-    fn f() -> &u8; //~ ERROR missing lifetime specifier\n+    pub fn g(_: &u8) -> &u8; // OK\n+    pub fn f() -> &u8; //~ ERROR missing lifetime specifier\n }\n \n fn main() {}"}, {"sha": "583487656f24d714fa9f2bdcd6f85b5acb80e4b1", "filename": "src/test/ui/foreign-fn-return-lifetime.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign-fn-return-lifetime.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1,11 +1,10 @@\n error[E0106]: missing lifetime specifier\n-  --> $DIR/foreign-fn-return-lifetime.rs:13:15\n+  --> $DIR/foreign-fn-return-lifetime.rs:15:19\n    |\n-LL |     fn f() -> &u8; //~ ERROR missing lifetime specifier\n-   |               ^ expected lifetime parameter\n+LL |     pub fn f() -> &u8; //~ ERROR missing lifetime specifier\n+   |                   ^ help: consider giving it a 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = help: consider giving it a 'static lifetime\n \n error: aborting due to previous error\n "}, {"sha": "e592452b899444676d4825e976716455949fa724", "filename": "src/test/ui/issues/issue-13497.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13497.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -2,10 +2,9 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/issue-13497.rs:12:5\n    |\n LL |     &str //~ ERROR missing lifetime specifier\n-   |     ^ expected lifetime parameter\n+   |     ^ help: consider giving it a 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = help: consider giving it a 'static lifetime\n \n error: aborting due to previous error\n "}, {"sha": "0ac6316f0dcf8da9a96d6930cb0f7a4385d25e32", "filename": "src/test/ui/issues/issue-26638.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fissues%2Fissue-26638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fissues%2Fissue-26638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26638.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -10,19 +10,17 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/issue-26638.rs:14:40\n    |\n LL | fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n-   |                                        ^ expected lifetime parameter\n+   |                                        ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n-   = help: consider giving it an explicit bounded or 'static lifetime\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-26638.rs:17:22\n    |\n LL | fn parse_type_3() -> &str { unimplemented!() }\n-   |                      ^ expected lifetime parameter\n+   |                      ^ help: consider giving it a 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = help: consider giving it a 'static lifetime\n \n error: aborting due to 3 previous errors\n "}, {"sha": "4c7a1b5ea9ff046c5b3168e8c9ee57a308890c1f", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-requires-explicit-lifetime.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-requires-explicit-lifetime.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -2,10 +2,9 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:12:11\n    |\n LL | fn f() -> &isize {    //~ ERROR missing lifetime specifier\n-   |           ^ expected lifetime parameter\n+   |           ^ help: consider giving it a 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = help: consider giving it a 'static lifetime\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:17:33\n@@ -27,28 +26,25 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:31:20\n    |\n LL | fn i(_x: isize) -> &isize { //~ ERROR missing lifetime specifier\n-   |                    ^ expected lifetime parameter\n+   |                    ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n-   = help: consider giving it an explicit bounded or 'static lifetime\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:44:24\n    |\n LL | fn j(_x: StaticStr) -> &isize { //~ ERROR missing lifetime specifier\n-   |                        ^ expected lifetime parameter\n+   |                        ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n-   = help: consider giving it an explicit bounded or 'static lifetime\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/lifetime-elision-return-type-requires-explicit-lifetime.rs:50:49\n    |\n LL | fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &isize {\n-   |                                                 ^ expected lifetime parameter\n+   |                                                 ^ help: consider giving it an explicit bounded or 'static lifetime: `&'static`\n    |\n    = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n-   = help: consider giving it an explicit bounded or 'static lifetime\n \n error: aborting due to 6 previous errors\n "}, {"sha": "eb959bfbcb533a706e632794ee6e35055e9efc80", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -0,0 +1,12 @@\n+trait Future {\n+    type Item;\n+    type Error;\n+}\n+\n+use std::error::Error;\n+\n+fn foo() -> impl Future<Item=(), Error=Box<Error>> {\n+    Ok(())\n+}\n+\n+fn main() {}"}, {"sha": "b2a3d9a94361fdfb73f767c29248ddd8989c8ef7", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -0,0 +1,11 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/lifetime-elision-return-type-trait.rs:8:44\n+   |\n+LL | fn foo() -> impl Future<Item=(), Error=Box<Error>> {\n+   |                                            ^^^^^ help: consider giving it a 'static lifetime: `Error + 'static`\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "77d546a00ecd47fd8b2df908227a8191f475f68d", "filename": "src/test/ui/lint/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flint%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flint%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsuggestions.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -56,7 +56,7 @@ fn main() {\n     while true {\n     //~^ WARN denote infinite loops\n     //~| HELP use `loop`\n-        let mut a = (1);\n+        let mut registry_no = (format!(\"NX-{}\", 74205));\n         //~^ WARN does not need to be mutable\n         //~| HELP remove this `mut`\n         //~| WARN unnecessary parentheses\n@@ -72,6 +72,6 @@ fn main() {\n             //~^ WARN this pattern is redundant\n             //~| HELP remove this\n         }\n-        println!(\"{} {}\", a, b);\n+        println!(\"{} {}\", registry_no, b);\n     }\n }"}, {"sha": "73704614815bed69407bed2750f4603dc042b3d1", "filename": "src/test/ui/lint/suggestions.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1,8 +1,8 @@\n warning: unnecessary parentheses around assigned value\n-  --> $DIR/suggestions.rs:59:21\n+  --> $DIR/suggestions.rs:59:31\n    |\n-LL |         let mut a = (1);\n-   |                     ^^^ help: remove these parentheses\n+LL |         let mut registry_no = (format!(\"NX-{}\", 74205));\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n    |\n note: lint level defined here\n   --> $DIR/suggestions.rs:13:21\n@@ -21,8 +21,8 @@ LL | #[no_debug] // should suggest removal of deprecated attribute\n warning: variable does not need to be mutable\n   --> $DIR/suggestions.rs:59:13\n    |\n-LL |         let mut a = (1);\n-   |             ----^\n+LL |         let mut registry_no = (format!(\"NX-{}\", 74205));\n+   |             ----^^^^^^^^^^^\n    |             |\n    |             help: remove this `mut`\n    |"}, {"sha": "186ecc54827208e0634c7edbbd6c3b02efa784de", "filename": "src/test/ui/nll/issue-21232-partial-init-and-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -66,7 +66,7 @@ impl<F> R<F> { fn new(f: F) -> Self { R { w: 0, f } } }\n // It got pretty monotonous writing the same code over and over, and I\n // feared I would forget details. So I abstracted some desiderata into\n // macros. But I left the initialization code inline, because that's\n-// where the errors for #54986 will be emited.\n+// where the errors for #54986 will be emitted.\n \n macro_rules! use_fully {\n     (struct $s:expr) => { {"}, {"sha": "eaa809d2b37069da325023851cbc788138b237aa", "filename": "src/test/ui/nll/issue-52059-report-when-borrow-and-drop-conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52059-report-when-borrow-and-drop-conflict.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1,5 +1,5 @@\n // rust-lang/rust#52059: Regardless of whether you are moving out of a\n-// Drop type or just introducing an inadvertant alias via a borrow of\n+// Drop type or just introducing an inadvertent alias via a borrow of\n // one of its fields, it is useful to be reminded of the significance\n // of the fact that the type implements Drop.\n "}, {"sha": "55803e4034bf4b69d2aefded16cf82ecd4049092", "filename": "src/test/ui/resolve/token-error-correct-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-2.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we do some basic error correcton in the tokeniser (and don't ICE).\n+// Test that we do some basic error correction in the tokeniser (and don't ICE).\n \n fn main() {\n     if foo {"}, {"sha": "fd4bbde28660e5823dd1bcca012918a8651c19ab", "filename": "src/test/ui/resolve/token-error-correct-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-cloudabi no std::fs support\n \n-// Test that we do some basic error correcton in the tokeniser (and don't spew\n+// Test that we do some basic error correction in the tokeniser (and don't spew\n // too many bogus errors).\n \n pub mod raw {"}, {"sha": "099ead93beb0679b15b198d77d94d7e748f2fb8f", "filename": "src/test/ui/resolve/token-error-correct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we do some basic error correcton in the tokeniser.\n+// Test that we do some basic error correction in the tokeniser.\n \n fn main() {\n     foo(bar(;"}, {"sha": "31a34a9e6fbbb528eb0d7a64138701d30c4236cb", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2015.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -19,22 +19,22 @@ fn main() {\n     use std::ops::Range;\n \n     if let Range { start: _, end: _ } = true..true && false { }\n-    //~^ ERROR ambigious use of `&&`\n+    //~^ ERROR ambiguous use of `&&`\n \n     if let Range { start: _, end: _ } = true..true || false { }\n-    //~^ ERROR ambigious use of `||`\n+    //~^ ERROR ambiguous use of `||`\n \n     while let Range { start: _, end: _ } = true..true && false { }\n-    //~^ ERROR ambigious use of `&&`\n+    //~^ ERROR ambiguous use of `&&`\n \n     while let Range { start: _, end: _ } = true..true || false { }\n-    //~^ ERROR ambigious use of `||`\n+    //~^ ERROR ambiguous use of `||`\n \n     if let true = false && false { }\n-    //~^ ERROR ambigious use of `&&`\n+    //~^ ERROR ambiguous use of `&&`\n \n     while let true = (1 == 2) && false { }\n-    //~^ ERROR ambigious use of `&&`\n+    //~^ ERROR ambiguous use of `&&`\n \n     // The following cases are not an error as parenthesis are used to\n     // clarify intent:"}, {"sha": "411cb99fbca19ae57c1f8c4bc635f9651095a684", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2015.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2015.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1,4 +1,4 @@\n-error: ambigious use of `&&`\n+error: ambiguous use of `&&`\n   --> $DIR/syntax-ambiguity-2015.rs:21:47\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false { }\n@@ -7,7 +7,7 @@ LL |     if let Range { start: _, end: _ } = true..true && false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `||`\n+error: ambiguous use of `||`\n   --> $DIR/syntax-ambiguity-2015.rs:24:47\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false { }\n@@ -16,7 +16,7 @@ LL |     if let Range { start: _, end: _ } = true..true || false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `&&`\n+error: ambiguous use of `&&`\n   --> $DIR/syntax-ambiguity-2015.rs:27:50\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false { }\n@@ -25,7 +25,7 @@ LL |     while let Range { start: _, end: _ } = true..true && false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `||`\n+error: ambiguous use of `||`\n   --> $DIR/syntax-ambiguity-2015.rs:30:50\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false { }\n@@ -34,7 +34,7 @@ LL |     while let Range { start: _, end: _ } = true..true || false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `&&`\n+error: ambiguous use of `&&`\n   --> $DIR/syntax-ambiguity-2015.rs:33:19\n    |\n LL |     if let true = false && false { }\n@@ -43,7 +43,7 @@ LL |     if let true = false && false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `&&`\n+error: ambiguous use of `&&`\n   --> $DIR/syntax-ambiguity-2015.rs:36:22\n    |\n LL |     while let true = (1 == 2) && false { }"}, {"sha": "99495717c3a896d7213a03d1164a0d49a11f1392", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2018.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -19,22 +19,22 @@ fn main() {\n     use std::ops::Range;\n \n     if let Range { start: _, end: _ } = true..true && false { }\n-    //~^ ERROR ambigious use of `&&`\n+    //~^ ERROR ambiguous use of `&&`\n \n     if let Range { start: _, end: _ } = true..true || false { }\n-    //~^ ERROR ambigious use of `||`\n+    //~^ ERROR ambiguous use of `||`\n \n     while let Range { start: _, end: _ } = true..true && false { }\n-    //~^ ERROR ambigious use of `&&`\n+    //~^ ERROR ambiguous use of `&&`\n \n     while let Range { start: _, end: _ } = true..true || false { }\n-    //~^ ERROR ambigious use of `||`\n+    //~^ ERROR ambiguous use of `||`\n \n     if let true = false && false { }\n-    //~^ ERROR ambigious use of `&&`\n+    //~^ ERROR ambiguous use of `&&`\n \n     while let true = (1 == 2) && false { }\n-    //~^ ERROR ambigious use of `&&`\n+    //~^ ERROR ambiguous use of `&&`\n \n     // The following cases are not an error as parenthesis are used to\n     // clarify intent:"}, {"sha": "bd49abeb7b247c3950bdbbc7a7d0fc3cdbdcc237", "filename": "src/test/ui/rfc-2497-if-let-chains/syntax-ambiguity-2018.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fsyntax-ambiguity-2018.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1,4 +1,4 @@\n-error: ambigious use of `&&`\n+error: ambiguous use of `&&`\n   --> $DIR/syntax-ambiguity-2018.rs:21:47\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false { }\n@@ -7,7 +7,7 @@ LL |     if let Range { start: _, end: _ } = true..true && false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `||`\n+error: ambiguous use of `||`\n   --> $DIR/syntax-ambiguity-2018.rs:24:47\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false { }\n@@ -16,7 +16,7 @@ LL |     if let Range { start: _, end: _ } = true..true || false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `&&`\n+error: ambiguous use of `&&`\n   --> $DIR/syntax-ambiguity-2018.rs:27:50\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false { }\n@@ -25,7 +25,7 @@ LL |     while let Range { start: _, end: _ } = true..true && false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `||`\n+error: ambiguous use of `||`\n   --> $DIR/syntax-ambiguity-2018.rs:30:50\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false { }\n@@ -34,7 +34,7 @@ LL |     while let Range { start: _, end: _ } = true..true || false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `&&`\n+error: ambiguous use of `&&`\n   --> $DIR/syntax-ambiguity-2018.rs:33:19\n    |\n LL |     if let true = false && false { }\n@@ -43,7 +43,7 @@ LL |     if let true = false && false { }\n    = note: this will be a error until the `let_chains` feature is stabilized\n    = note: see rust-lang/rust#53668 for more information\n \n-error: ambigious use of `&&`\n+error: ambiguous use of `&&`\n   --> $DIR/syntax-ambiguity-2018.rs:36:22\n    |\n LL |     while let true = (1 == 2) && false { }"}, {"sha": "f13f8ef2bb4cf55edefa5354553ce872704eb4ed", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -24,7 +24,7 @@ use std::fmt::{Debug, Display};\n // \u2022 one generic parameter (T) bound inline\n // \u2022 one parameter (T) with a where clause\n // \u2022 two parameters (T and U), both bound inline\n-// \u2022 two paramters (T and U), one bound inline, one with a where clause\n+// \u2022 two parameters (T and U), one bound inline, one with a where clause\n // \u2022 two parameters (T and U), both with where clauses\n //\n // \u2014and for every permutation of 0, 1, or 2 lifetimes to outlive and 0 or 1"}, {"sha": "f47b3fcb9be9a3dde601ae5bac30f6d3a7673f7d", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -24,7 +24,7 @@ use std::fmt::{Debug, Display};\n // \u2022 one generic parameter (T) bound inline\n // \u2022 one parameter (T) with a where clause\n // \u2022 two parameters (T and U), both bound inline\n-// \u2022 two paramters (T and U), one bound inline, one with a where clause\n+// \u2022 two parameters (T and U), one bound inline, one with a where clause\n // \u2022 two parameters (T and U), both with where clauses\n //\n // \u2014and for every permutation of 0, 1, or 2 lifetimes to outlive and 0 or 1"}, {"sha": "00d8d126e0573d6011e6259ebb72198066751952", "filename": "src/test/ui/specialization/issue-52050.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-52050.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -12,7 +12,7 @@\n \n // Regression test for #52050: when inserting the blanket impl `I`\n // into the tree, we had to replace the child node for `Foo`, which\n-// led to the struture of the tree being messed up.\n+// led to the structure of the tree being messed up.\n \n use std::iter::Iterator;\n "}, {"sha": "e56d008d2665f9e6a06b442ea89839584d026569", "filename": "src/test/ui/underscore-lifetime/underscore-lifetime-binders.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Funderscore-lifetime-binders.stderr?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -20,10 +20,9 @@ error[E0106]: missing lifetime specifier\n   --> $DIR/underscore-lifetime-binders.rs:20:29\n    |\n LL | fn meh() -> Box<for<'_> Meh<'_>> //~ ERROR cannot be used here\n-   |                             ^^ expected lifetime parameter\n+   |                             ^^ help: consider giving it a 'static lifetime: `'static`\n    |\n    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-   = help: consider giving it a 'static lifetime\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/underscore-lifetime-binders.rs:26:35"}, {"sha": "b1d0343749bdc87e5cbbe7f1aeaa9d2a2c9dbc5b", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -1 +1 @@\n-Subproject commit 5afdf8b78507ddf015d192858aef56e72c17de16\n+Subproject commit b1d0343749bdc87e5cbbe7f1aeaa9d2a2c9dbc5b"}, {"sha": "3d5e18e37b070c1aeaa93a693639bbf4bce68cf9", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ec22e7ec7ed0da2add0763d239e77c5474f3d4a/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=8ec22e7ec7ed0da2add0763d239e77c5474f3d4a", "patch": "@@ -163,7 +163,7 @@ fn check_cfgs(contents: &mut String, file: &Path,\n \n fn find_test_mod(contents: &str) -> usize {\n     if let Some(mod_tests_idx) = contents.find(\"mod tests\") {\n-        // Also capture a previos line indicating \"mod tests\" in cfg-ed out\n+        // Also capture a previous line indicating \"mod tests\" in cfg-ed out\n         let prev_newline_idx = contents[..mod_tests_idx].rfind('\\n').unwrap_or(mod_tests_idx);\n         let prev_newline_idx = contents[..prev_newline_idx].rfind('\\n');\n         if let Some(nl) = prev_newline_idx {"}]}