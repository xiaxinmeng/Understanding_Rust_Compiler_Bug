{"sha": "11c94a197726b6a981828cb1837d7c3eed1b841d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYzk0YTE5NzcyNmI2YTk4MTgyOGNiMTgzN2Q3YzNlZWQxYjg0MWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-21T13:12:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-21T13:12:36Z"}, "message": "Auto merge of #79270 - RalfJung:array-repeat-consts, r=oli-obk\n\nAcknowledge that `[CONST; N]` is stable\n\nWhen `const_in_array_repeat_expressions` (RFC 2203) got unstably implemented as part of https://github.com/rust-lang/rust/pull/61749, accidentally, the special case of repeating a *constant* got stabilized immediately. That is why the following code works on stable:\n\n```rust\nconst EMPTY: Vec<i32> = Vec::new();\n\npub const fn bar() -> [Vec<i32>; 2] {\n    [EMPTY; 2]\n}\n\nfn main() {\n    let x = bar();\n}\n```\n\nIn contrast, if we had written `[expr; 2]` for some expression that is not *literally* a constant but could be evaluated at compile-time (e.g. `(EMPTY,).0`), this would have failed.\n\nWe could take back this stabilization as it was clearly accidental. However, I propose we instead just officially accept this and stabilize a small subset of RFC 2203, while leaving the more complex case of general expressions that could be evaluated at compile-time unstable. Making that case work well is pretty much blocked on inline `const` expressions (to avoid relying too much on [implicit promotion](https://github.com/rust-lang/const-eval/blob/master/promotion.md)), so it could take a bit until it comes to full fruition. `[CONST; N]` is an uncontroversial subset of this feature that has no semantic ambiguities, does not rely on promotion, and basically provides the full expressive power of RFC 2203 but without the convenience (people have to define constants to repeat them, possibly using associated consts if generics are involved).\n\nWell, I said \"no semantic ambiguities\", that is only almost true... the one point I am not sure about is `[CONST; 0]`. There are two possible behaviors here: either this is equivalent to `let x = CONST; [x; 0]`, or it is a NOP (if we argue that the constant is never actually instantiated). The difference between the two is that if `CONST` has a destructor, it should run in the former case (but currently doesn't, due to https://github.com/rust-lang/rust/issues/74836); but should not run if it is considered a NOP. For regular `[x; 0]` there seems to be consensus on running drop (there isn't really an alternative); any opinions for the `CONST` special case? Should this instantiate the const only to immediately run its destructors? That seems somewhat silly to me. After all, the `let`-expansion does *not* work in general, for `N > 1`.\n\nCc `@rust-lang/lang` `@rust-lang/wg-const-eval`\nCc https://github.com/rust-lang/rust/issues/49147", "tree": {"sha": "aadfc20fe40382f2d1471c8cddba700080d93bf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aadfc20fe40382f2d1471c8cddba700080d93bf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11c94a197726b6a981828cb1837d7c3eed1b841d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11c94a197726b6a981828cb1837d7c3eed1b841d", "html_url": "https://github.com/rust-lang/rust/commit/11c94a197726b6a981828cb1837d7c3eed1b841d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11c94a197726b6a981828cb1837d7c3eed1b841d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e88a1769f69f944e16cba13ba174c1d6e494b36", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e88a1769f69f944e16cba13ba174c1d6e494b36", "html_url": "https://github.com/rust-lang/rust/commit/1e88a1769f69f944e16cba13ba174c1d6e494b36"}, {"sha": "7f3e18cc2b24214e10df5434972f4f7cd461fa98", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3e18cc2b24214e10df5434972f4f7cd461fa98", "html_url": "https://github.com/rust-lang/rust/commit/7f3e18cc2b24214e10df5434972f4f7cd461fa98"}], "stats": {"total": 105, "additions": 68, "deletions": 37}, "files": [{"sha": "42cd050abc5dd47e92701c13f96e41a45bb841f3", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/11c94a197726b6a981828cb1837d7c3eed1b841d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11c94a197726b6a981828cb1837d7c3eed1b841d/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=11c94a197726b6a981828cb1837d7c3eed1b841d", "patch": "@@ -1988,44 +1988,48 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // If the length is larger than 1, the repeat expression will need to copy the\n                 // element, so we require the `Copy` trait.\n                 if len.try_eval_usize(tcx, self.param_env).map_or(true, |len| len > 1) {\n-                    if let Operand::Move(_) = operand {\n-                        // While this is located in `nll::typeck` this error is not an NLL error, it's\n-                        // a required check to make sure that repeated elements implement `Copy`.\n-                        let span = body.source_info(location).span;\n-                        let ty = operand.ty(body, tcx);\n-                        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n-                            let ccx = ConstCx::new_with_param_env(tcx, body, self.param_env);\n-                            // To determine if `const_in_array_repeat_expressions` feature gate should\n-                            // be mentioned, need to check if the rvalue is promotable.\n-                            let should_suggest =\n-                                should_suggest_const_in_array_repeat_expressions_attribute(\n-                                    &ccx, operand,\n-                                );\n-                            debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n-\n-                            let def_id = body.source.def_id().expect_local();\n-                            self.infcx.report_selection_error(\n-                                &traits::Obligation::new(\n-                                    ObligationCause::new(\n-                                        span,\n-                                        self.tcx().hir().local_def_id_to_hir_id(def_id),\n-                                        traits::ObligationCauseCode::RepeatVec(should_suggest),\n-                                    ),\n-                                    self.param_env,\n-                                    ty::Binder::bind(ty::TraitRef::new(\n-                                        self.tcx().require_lang_item(\n-                                            LangItem::Copy,\n-                                            Some(self.last_span),\n+                    match operand {\n+                        Operand::Copy(..) | Operand::Constant(..) => {\n+                            // These are always okay: direct use of a const, or a value that can evidently be copied.\n+                        }\n+                        Operand::Move(_) => {\n+                            // Make sure that repeated elements implement `Copy`.\n+                            let span = body.source_info(location).span;\n+                            let ty = operand.ty(body, tcx);\n+                            if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n+                                let ccx = ConstCx::new_with_param_env(tcx, body, self.param_env);\n+                                // To determine if `const_in_array_repeat_expressions` feature gate should\n+                                // be mentioned, need to check if the rvalue is promotable.\n+                                let should_suggest =\n+                                    should_suggest_const_in_array_repeat_expressions_attribute(\n+                                        &ccx, operand,\n+                                    );\n+                                debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n+\n+                                let def_id = body.source.def_id().expect_local();\n+                                self.infcx.report_selection_error(\n+                                    &traits::Obligation::new(\n+                                        ObligationCause::new(\n+                                            span,\n+                                            self.tcx().hir().local_def_id_to_hir_id(def_id),\n+                                            traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                         ),\n-                                        tcx.mk_substs_trait(ty, &[]),\n-                                    ))\n-                                    .without_const()\n-                                    .to_predicate(self.tcx()),\n-                                ),\n-                                &traits::SelectionError::Unimplemented,\n-                                false,\n-                                false,\n-                            );\n+                                        self.param_env,\n+                                        ty::Binder::bind(ty::TraitRef::new(\n+                                            self.tcx().require_lang_item(\n+                                                LangItem::Copy,\n+                                                Some(self.last_span),\n+                                            ),\n+                                            tcx.mk_substs_trait(ty, &[]),\n+                                        ))\n+                                        .without_const()\n+                                        .to_predicate(self.tcx()),\n+                                    ),\n+                                    &traits::SelectionError::Unimplemented,\n+                                    false,\n+                                    false,\n+                                );\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "65d02317d34c57a0482fef35d2d35f94166b861d", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/const-repeat.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/11c94a197726b6a981828cb1837d7c3eed1b841d/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11c94a197726b6a981828cb1837d7c3eed1b841d/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-repeat.rs?ref=11c94a197726b6a981828cb1837d7c3eed1b841d", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+\n+// Repeating a *constant* of non-Copy type (not just a constant expression) is already stable.\n+\n+const EMPTY: Vec<i32> = Vec::new();\n+\n+pub fn bar() -> [Vec<i32>; 2] {\n+    [EMPTY; 2]\n+}\n+\n+struct Bomb;\n+\n+impl Drop for Bomb {\n+    fn drop(&mut self) {\n+        panic!(\"BOOM!\");\n+    }\n+}\n+\n+const BOOM: Bomb = Bomb;\n+\n+fn main() {\n+    let _x = bar();\n+\n+    // Make sure the destructor does not get called for empty arrays. `[CONST; N]` should\n+    // instantiate (and then later drop) the const exactly `N` times.\n+    let _x = [BOOM; 0];\n+}"}]}