{"sha": "2909b33a243591cec6a5d6d51dc6e1684809aeac", "node_id": "C_kwDOAAsO6NoAKDI5MDliMzNhMjQzNTkxY2VjNmE1ZDZkNTFkYzZlMTY4NDgwOWFlYWM", "commit": {"author": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-03-16T08:26:56Z"}, "committer": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-03-16T08:26:56Z"}, "message": "quick fix of issue#8542 for lint `[needless_match]`\nremove `ref`/`ref mut` check", "tree": {"sha": "eee296a44abbff6db56e33bc53222e51f0185434", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eee296a44abbff6db56e33bc53222e51f0185434"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2909b33a243591cec6a5d6d51dc6e1684809aeac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2909b33a243591cec6a5d6d51dc6e1684809aeac", "html_url": "https://github.com/rust-lang/rust/commit/2909b33a243591cec6a5d6d51dc6e1684809aeac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2909b33a243591cec6a5d6d51dc6e1684809aeac/comments", "author": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b83c6323c7d788fe4b6921b000324fb09945e12b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b83c6323c7d788fe4b6921b000324fb09945e12b", "html_url": "https://github.com/rust-lang/rust/commit/b83c6323c7d788fe4b6921b000324fb09945e12b"}], "stats": {"total": 408, "additions": 257, "deletions": 151}, "files": [{"sha": "d9544e18b18b5161759cd0c099294b8909e988a9", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2909b33a243591cec6a5d6d51dc6e1684809aeac/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2909b33a243591cec6a5d6d51dc6e1684809aeac/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=2909b33a243591cec6a5d6d51dc6e1684809aeac", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{eq_expr_value, get_parent_expr, higher, is_else_clause, is_lang_ctor, peel_blocks_with_stmt};\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, Path, PathSegment, QPath, UnOp};\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, Pat, PatKind, Path, PathSegment, QPath};\n use rustc_lint::LateContext;\n use rustc_span::sym;\n \n@@ -21,7 +21,7 @@ pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n             if !eq_expr_value(cx, ex, ret_expr) {\n                 return;\n             }\n-        } else if !pat_same_as_expr(arm.pat, arm.body) {\n+        } else if !pat_same_as_expr(arm.pat, peel_blocks_with_stmt(arm.body)) {\n             return;\n         }\n     }\n@@ -92,6 +92,9 @@ fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n \n         if matches!(if_else.kind, ExprKind::Block(..)) {\n             let else_expr = peel_blocks_with_stmt(if_else);\n+            if matches!(else_expr.kind, ExprKind::Block(..)) {\n+                return false;\n+            }\n             let ret = strip_return(else_expr);\n             let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n             if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n@@ -120,40 +123,25 @@ fn pat_same_as_expr(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n     let expr = strip_return(expr);\n     match (&pat.kind, &expr.kind) {\n         // Example: `Some(val) => Some(val)`\n-        (\n-            PatKind::TupleStruct(QPath::Resolved(_, path), [first_pat, ..], _),\n-            ExprKind::Call(call_expr, [first_param, ..]),\n-        ) => {\n+        (PatKind::TupleStruct(QPath::Resolved(_, path), tuple_params, _), ExprKind::Call(call_expr, call_params)) => {\n             if let ExprKind::Path(QPath::Resolved(_, call_path)) = call_expr.kind {\n-                if has_identical_segments(path.segments, call_path.segments)\n-                    && has_same_non_ref_symbol(first_pat, first_param)\n-                {\n-                    return true;\n-                }\n+                return has_identical_segments(path.segments, call_path.segments)\n+                    && has_same_non_ref_symbols(tuple_params, call_params);\n             }\n         },\n-        // Example: `val => val`, or `ref val => *val`\n-        (PatKind::Binding(annot, _, pat_ident, _), _) => {\n-            let new_expr = if let (\n-                BindingAnnotation::Ref | BindingAnnotation::RefMut,\n-                ExprKind::Unary(UnOp::Deref, operand_expr),\n-            ) = (annot, &expr.kind)\n-            {\n-                operand_expr\n-            } else {\n-                expr\n-            };\n-\n-            if let ExprKind::Path(QPath::Resolved(\n+        // Example: `val => val`\n+        (\n+            PatKind::Binding(annot, _, pat_ident, _),\n+            ExprKind::Path(QPath::Resolved(\n                 _,\n                 Path {\n                     segments: [first_seg, ..],\n                     ..\n                 },\n-            )) = new_expr.kind\n-            {\n-                return pat_ident.name == first_seg.ident.name;\n-            }\n+            )),\n+        ) => {\n+            return !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut)\n+                && pat_ident.name == first_seg.ident.name;\n         },\n         // Example: `Custom::TypeA => Custom::TypeB`, or `None => None`\n         (PatKind::Path(QPath::Resolved(_, p_path)), ExprKind::Path(QPath::Resolved(_, e_path))) => {\n@@ -183,15 +171,16 @@ fn has_identical_segments(left_segs: &[PathSegment<'_>], right_segs: &[PathSegme\n     true\n }\n \n-fn has_same_non_ref_symbol(pat: &Pat<'_>, expr: &Expr<'_>) -> bool {\n-    if_chain! {\n-        if let PatKind::Binding(annot, _, pat_ident, _) = pat.kind;\n-        if !matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-        if let ExprKind::Path(QPath::Resolved(_, Path {segments: [first_seg, ..], .. })) = expr.kind;\n-        then {\n-            return pat_ident.name == first_seg.ident.name;\n+fn has_same_non_ref_symbols(pats: &[Pat<'_>], exprs: &[Expr<'_>]) -> bool {\n+    if pats.len() != exprs.len() {\n+        return false;\n+    }\n+\n+    for i in 0..pats.len() {\n+        if !pat_same_as_expr(&pats[i], &exprs[i]) {\n+            return false;\n         }\n     }\n \n-    false\n+    true\n }"}, {"sha": "6a518f839253392243e05cb5cbf2254091e7d15b", "filename": "tests/ui/needless_match.fixed", "status": "modified", "additions": 90, "deletions": 26, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2909b33a243591cec6a5d6d51dc6e1684809aeac/tests%2Fui%2Fneedless_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2909b33a243591cec6a5d6d51dc6e1684809aeac/tests%2Fui%2Fneedless_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.fixed?ref=2909b33a243591cec6a5d6d51dc6e1684809aeac", "patch": "@@ -4,38 +4,35 @@\n #![allow(dead_code)]\n \n #[derive(Clone, Copy)]\n-enum Choice {\n+enum Simple {\n     A,\n     B,\n     C,\n     D,\n }\n \n-#[allow(unused_mut)]\n fn useless_match() {\n-    let mut i = 10;\n+    let i = 10;\n     let _: i32 = i;\n-    let _: i32 = i;\n-    let mut _i_mut = i;\n-\n     let s = \"test\";\n     let _: &str = s;\n }\n \n-fn custom_type_match(se: Choice) {\n-    let _: Choice = se;\n+fn custom_type_match() {\n+    let se = Simple::A;\n+    let _: Simple = se;\n     // Don't trigger\n-    let _: Choice = match se {\n-        Choice::A => Choice::A,\n-        Choice::B => Choice::B,\n-        _ => Choice::C,\n+    let _: Simple = match se {\n+        Simple::A => Simple::A,\n+        Simple::B => Simple::B,\n+        _ => Simple::C,\n     };\n     // Mingled, don't trigger\n-    let _: Choice = match se {\n-        Choice::A => Choice::B,\n-        Choice::B => Choice::C,\n-        Choice::C => Choice::D,\n-        Choice::D => Choice::A,\n+    let _: Simple = match se {\n+        Simple::A => Simple::B,\n+        Simple::B => Simple::C,\n+        Simple::C => Simple::D,\n+        Simple::D => Simple::A,\n     };\n }\n \n@@ -55,29 +52,96 @@ fn func_ret_err<T>(err: T) -> Result<i32, T> {\n fn result_match() {\n     let _: Result<i32, i32> = Ok(1);\n     let _: Result<i32, i32> = func_ret_err(0_i32);\n+    // as ref, don't trigger\n+    let res = &func_ret_err(0_i32);\n+    let _: Result<&i32, &i32> = match *res {\n+        Ok(ref x) => Ok(x),\n+        Err(ref x) => Err(x),\n+    };\n }\n \n fn if_let_option() -> Option<i32> {\n     Some(1)\n }\n \n-fn if_let_result(x: Result<(), i32>) {\n-    let _: Result<(), i32> = x;\n-    let _: Result<(), i32> = x;\n+fn if_let_result() {\n+    let x: Result<i32, i32> = Ok(1);\n+    let _: Result<i32, i32> = x;\n+    let _: Result<i32, i32> = x;\n     // Input type mismatch, don't trigger\n-    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n+    let _: Result<i32, i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n }\n \n-fn if_let_custom_enum(x: Choice) {\n-    let _: Choice = x;\n+fn if_let_custom_enum(x: Simple) {\n+    let _: Simple = x;\n+\n     // Don't trigger\n-    let _: Choice = if let Choice::A = x {\n-        Choice::A\n+    let _: Simple = if let Simple::A = x {\n+        Simple::A\n     } else if true {\n-        Choice::B\n+        Simple::B\n     } else {\n         x\n     };\n }\n \n+mod issue8542 {\n+    #[derive(Clone, Copy)]\n+    enum E {\n+        VariantA(u8, u8),\n+        VariantB(u8, bool),\n+    }\n+\n+    enum Complex {\n+        A(u8),\n+        B(u8, bool),\n+        C(u8, i32, f64),\n+        D(E, bool),\n+    }\n+\n+    fn match_test() {\n+        let ce = Complex::B(8, false);\n+        let aa = 0_u8;\n+        let bb = false;\n+\n+        let _: Complex = ce;\n+\n+        // Don't trigger\n+        let _: Complex = match ce {\n+            Complex::A(_) => Complex::A(aa),\n+            Complex::B(_, b) => Complex::B(aa, b),\n+            Complex::C(_, b, _) => Complex::C(aa, b, 64_f64),\n+            Complex::D(e, b) => Complex::D(e, b),\n+        };\n+\n+        // Don't trigger\n+        let _: Complex = match ce {\n+            Complex::A(a) => Complex::A(a),\n+            Complex::B(a, _) => Complex::B(a, bb),\n+            Complex::C(a, _, _) => Complex::C(a, 32_i32, 64_f64),\n+            _ => ce,\n+        };\n+    }\n+\n+    fn if_let_test() {\n+        fn do_something() {}\n+\n+        // Don't trigger\n+        let _ = if let Some(a) = Some(1) {\n+            Some(a)\n+        } else {\n+            do_something();\n+            None\n+        };\n+\n+        // Don't trigger\n+        let _ = if let Some(a) = Some(1) {\n+            do_something();\n+            Some(a)\n+        } else {\n+            None\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "ffc6a291a157a29591530f284bed86c4a356e4c4", "filename": "tests/ui/needless_match.rs", "status": "modified", "additions": 105, "deletions": 43, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/2909b33a243591cec6a5d6d51dc6e1684809aeac/tests%2Fui%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2909b33a243591cec6a5d6d51dc6e1684809aeac/tests%2Fui%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.rs?ref=2909b33a243591cec6a5d6d51dc6e1684809aeac", "patch": "@@ -4,33 +4,21 @@\n #![allow(dead_code)]\n \n #[derive(Clone, Copy)]\n-enum Choice {\n+enum Simple {\n     A,\n     B,\n     C,\n     D,\n }\n \n-#[allow(unused_mut)]\n fn useless_match() {\n-    let mut i = 10;\n+    let i = 10;\n     let _: i32 = match i {\n         0 => 0,\n         1 => 1,\n         2 => 2,\n         _ => i,\n     };\n-    let _: i32 = match i {\n-        0 => 0,\n-        1 => 1,\n-        ref i => *i,\n-    };\n-    let mut _i_mut = match i {\n-        0 => 0,\n-        1 => 1,\n-        ref mut i => *i,\n-    };\n-\n     let s = \"test\";\n     let _: &str = match s {\n         \"a\" => \"a\",\n@@ -39,25 +27,26 @@ fn useless_match() {\n     };\n }\n \n-fn custom_type_match(se: Choice) {\n-    let _: Choice = match se {\n-        Choice::A => Choice::A,\n-        Choice::B => Choice::B,\n-        Choice::C => Choice::C,\n-        Choice::D => Choice::D,\n+fn custom_type_match() {\n+    let se = Simple::A;\n+    let _: Simple = match se {\n+        Simple::A => Simple::A,\n+        Simple::B => Simple::B,\n+        Simple::C => Simple::C,\n+        Simple::D => Simple::D,\n     };\n     // Don't trigger\n-    let _: Choice = match se {\n-        Choice::A => Choice::A,\n-        Choice::B => Choice::B,\n-        _ => Choice::C,\n+    let _: Simple = match se {\n+        Simple::A => Simple::A,\n+        Simple::B => Simple::B,\n+        _ => Simple::C,\n     };\n     // Mingled, don't trigger\n-    let _: Choice = match se {\n-        Choice::A => Choice::B,\n-        Choice::B => Choice::C,\n-        Choice::C => Choice::D,\n-        Choice::D => Choice::A,\n+    let _: Simple = match se {\n+        Simple::A => Simple::B,\n+        Simple::B => Simple::C,\n+        Simple::C => Simple::D,\n+        Simple::D => Simple::A,\n     };\n }\n \n@@ -86,37 +75,110 @@ fn result_match() {\n         Err(err) => Err(err),\n         Ok(a) => Ok(a),\n     };\n+    // as ref, don't trigger\n+    let res = &func_ret_err(0_i32);\n+    let _: Result<&i32, &i32> = match *res {\n+        Ok(ref x) => Ok(x),\n+        Err(ref x) => Err(x),\n+    };\n }\n \n fn if_let_option() -> Option<i32> {\n     if let Some(a) = Some(1) { Some(a) } else { None }\n }\n \n-fn if_let_result(x: Result<(), i32>) {\n-    let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n-    let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n+fn if_let_result() {\n+    let x: Result<i32, i32> = Ok(1);\n+    let _: Result<i32, i32> = if let Err(e) = x { Err(e) } else { x };\n+    let _: Result<i32, i32> = if let Ok(val) = x { Ok(val) } else { x };\n     // Input type mismatch, don't trigger\n-    let _: Result<(), i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n+    let _: Result<i32, i32> = if let Err(e) = Ok(1) { Err(e) } else { x };\n }\n \n-fn if_let_custom_enum(x: Choice) {\n-    let _: Choice = if let Choice::A = x {\n-        Choice::A\n-    } else if let Choice::B = x {\n-        Choice::B\n-    } else if let Choice::C = x {\n-        Choice::C\n+fn if_let_custom_enum(x: Simple) {\n+    let _: Simple = if let Simple::A = x {\n+        Simple::A\n+    } else if let Simple::B = x {\n+        Simple::B\n+    } else if let Simple::C = x {\n+        Simple::C\n     } else {\n         x\n     };\n+\n     // Don't trigger\n-    let _: Choice = if let Choice::A = x {\n-        Choice::A\n+    let _: Simple = if let Simple::A = x {\n+        Simple::A\n     } else if true {\n-        Choice::B\n+        Simple::B\n     } else {\n         x\n     };\n }\n \n+mod issue8542 {\n+    #[derive(Clone, Copy)]\n+    enum E {\n+        VariantA(u8, u8),\n+        VariantB(u8, bool),\n+    }\n+\n+    enum Complex {\n+        A(u8),\n+        B(u8, bool),\n+        C(u8, i32, f64),\n+        D(E, bool),\n+    }\n+\n+    fn match_test() {\n+        let ce = Complex::B(8, false);\n+        let aa = 0_u8;\n+        let bb = false;\n+\n+        let _: Complex = match ce {\n+            Complex::A(a) => Complex::A(a),\n+            Complex::B(a, b) => Complex::B(a, b),\n+            Complex::C(a, b, c) => Complex::C(a, b, c),\n+            Complex::D(E::VariantA(ea, eb), b) => Complex::D(E::VariantA(ea, eb), b),\n+            Complex::D(E::VariantB(ea, eb), b) => Complex::D(E::VariantB(ea, eb), b),\n+        };\n+\n+        // Don't trigger\n+        let _: Complex = match ce {\n+            Complex::A(_) => Complex::A(aa),\n+            Complex::B(_, b) => Complex::B(aa, b),\n+            Complex::C(_, b, _) => Complex::C(aa, b, 64_f64),\n+            Complex::D(e, b) => Complex::D(e, b),\n+        };\n+\n+        // Don't trigger\n+        let _: Complex = match ce {\n+            Complex::A(a) => Complex::A(a),\n+            Complex::B(a, _) => Complex::B(a, bb),\n+            Complex::C(a, _, _) => Complex::C(a, 32_i32, 64_f64),\n+            _ => ce,\n+        };\n+    }\n+\n+    fn if_let_test() {\n+        fn do_something() {}\n+\n+        // Don't trigger\n+        let _ = if let Some(a) = Some(1) {\n+            Some(a)\n+        } else {\n+            do_something();\n+            None\n+        };\n+\n+        // Don't trigger\n+        let _ = if let Some(a) = Some(1) {\n+            do_something();\n+            Some(a)\n+        } else {\n+            None\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "67bd84d6bbc723a9b41fd77d3ad265e718cc42ac", "filename": "tests/ui/needless_match.stderr", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2909b33a243591cec6a5d6d51dc6e1684809aeac/tests%2Fui%2Fneedless_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2909b33a243591cec6a5d6d51dc6e1684809aeac/tests%2Fui%2Fneedless_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.stderr?ref=2909b33a243591cec6a5d6d51dc6e1684809aeac", "patch": "@@ -1,5 +1,5 @@\n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:17:18\n+  --> $DIR/needless_match.rs:16:18\n    |\n LL |       let _: i32 = match i {\n    |  __________________^\n@@ -13,29 +13,7 @@ LL | |     };\n    = note: `-D clippy::needless-match` implied by `-D warnings`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:23:18\n-   |\n-LL |       let _: i32 = match i {\n-   |  __________________^\n-LL | |         0 => 0,\n-LL | |         1 => 1,\n-LL | |         ref i => *i,\n-LL | |     };\n-   | |_____^ help: replace it with: `i`\n-\n-error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:28:22\n-   |\n-LL |       let mut _i_mut = match i {\n-   |  ______________________^\n-LL | |         0 => 0,\n-LL | |         1 => 1,\n-LL | |         ref mut i => *i,\n-LL | |     };\n-   | |_____^ help: replace it with: `i`\n-\n-error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:35:19\n+  --> $DIR/needless_match.rs:23:19\n    |\n LL |       let _: &str = match s {\n    |  ___________________^\n@@ -46,19 +24,19 @@ LL | |     };\n    | |_____^ help: replace it with: `s`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:43:21\n+  --> $DIR/needless_match.rs:32:21\n    |\n-LL |       let _: Choice = match se {\n+LL |       let _: Simple = match se {\n    |  _____________________^\n-LL | |         Choice::A => Choice::A,\n-LL | |         Choice::B => Choice::B,\n-LL | |         Choice::C => Choice::C,\n-LL | |         Choice::D => Choice::D,\n+LL | |         Simple::A => Simple::A,\n+LL | |         Simple::B => Simple::B,\n+LL | |         Simple::C => Simple::C,\n+LL | |         Simple::D => Simple::D,\n LL | |     };\n    | |_____^ help: replace it with: `se`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:65:26\n+  --> $DIR/needless_match.rs:54:26\n    |\n LL |       let _: Option<i32> = match x {\n    |  __________________________^\n@@ -68,7 +46,7 @@ LL | |     };\n    | |_____^ help: replace it with: `x`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:81:31\n+  --> $DIR/needless_match.rs:70:31\n    |\n LL |       let _: Result<i32, i32> = match Ok(1) {\n    |  _______________________________^\n@@ -78,7 +56,7 @@ LL | |     };\n    | |_____^ help: replace it with: `Ok(1)`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:85:31\n+  --> $DIR/needless_match.rs:74:31\n    |\n LL |       let _: Result<i32, i32> = match func_ret_err(0_i32) {\n    |  _______________________________^\n@@ -88,35 +66,48 @@ LL | |     };\n    | |_____^ help: replace it with: `func_ret_err(0_i32)`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:92:5\n+  --> $DIR/needless_match.rs:87:5\n    |\n LL |     if let Some(a) = Some(1) { Some(a) } else { None }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:96:30\n+  --> $DIR/needless_match.rs:92:31\n    |\n-LL |     let _: Result<(), i32> = if let Err(e) = x { Err(e) } else { x };\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+LL |     let _: Result<i32, i32> = if let Err(e) = x { Err(e) } else { x };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:97:30\n+  --> $DIR/needless_match.rs:93:31\n    |\n-LL |     let _: Result<(), i32> = if let Ok(val) = x { Ok(val) } else { x };\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n+LL |     let _: Result<i32, i32> = if let Ok(val) = x { Ok(val) } else { x };\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:103:21\n+  --> $DIR/needless_match.rs:99:21\n    |\n-LL |       let _: Choice = if let Choice::A = x {\n+LL |       let _: Simple = if let Simple::A = x {\n    |  _____________________^\n-LL | |         Choice::A\n-LL | |     } else if let Choice::B = x {\n-LL | |         Choice::B\n+LL | |         Simple::A\n+LL | |     } else if let Simple::B = x {\n+LL | |         Simple::B\n ...  |\n LL | |         x\n LL | |     };\n    | |_____^ help: replace it with: `x`\n \n-error: aborting due to 12 previous errors\n+error: this match expression is unnecessary\n+  --> $DIR/needless_match.rs:138:26\n+   |\n+LL |           let _: Complex = match ce {\n+   |  __________________________^\n+LL | |             Complex::A(a) => Complex::A(a),\n+LL | |             Complex::B(a, b) => Complex::B(a, b),\n+LL | |             Complex::C(a, b, c) => Complex::C(a, b, c),\n+LL | |             Complex::D(E::VariantA(ea, eb), b) => Complex::D(E::VariantA(ea, eb), b),\n+LL | |             Complex::D(E::VariantB(ea, eb), b) => Complex::D(E::VariantB(ea, eb), b),\n+LL | |         };\n+   | |_________^ help: replace it with: `ce`\n+\n+error: aborting due to 11 previous errors\n "}]}