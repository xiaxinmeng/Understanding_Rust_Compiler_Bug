{"sha": "d24ead0f93799c7c6646739396daf68ac46d7309", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNGVhZDBmOTM3OTljN2M2NjQ2NzM5Mzk2ZGFmNjhhYzQ2ZDczMDk=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-05T18:59:16Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-09T20:17:00Z"}, "message": "trans: Make various trans::collector functions independent of CrateContext.", "tree": {"sha": "e15f56f3ec1eefdf63ba29455f7b039960c1b793", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e15f56f3ec1eefdf63ba29455f7b039960c1b793"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d24ead0f93799c7c6646739396daf68ac46d7309", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d24ead0f93799c7c6646739396daf68ac46d7309", "html_url": "https://github.com/rust-lang/rust/commit/d24ead0f93799c7c6646739396daf68ac46d7309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d24ead0f93799c7c6646739396daf68ac46d7309/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2564199d8f50e1f6e5c915bf258999354c6f1262", "url": "https://api.github.com/repos/rust-lang/rust/commits/2564199d8f50e1f6e5c915bf258999354c6f1262", "html_url": "https://github.com/rust-lang/rust/commit/2564199d8f50e1f6e5c915bf258999354c6f1262"}], "stats": {"total": 101, "additions": 49, "deletions": 52}, "files": [{"sha": "2fb8c9737fa219ac1bf1a8fd917b39972f30716a", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d24ead0f93799c7c6646739396daf68ac46d7309/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d24ead0f93799c7c6646739396daf68ac46d7309/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=d24ead0f93799c7c6646739396daf68ac46d7309", "patch": "@@ -397,7 +397,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n-            recursion_depth_reset = Some(check_recursion_limit(ccx,\n+            recursion_depth_reset = Some(check_recursion_limit(ccx.tcx(),\n                                                                instance,\n                                                                recursion_depths));\n \n@@ -420,7 +420,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    record_references(ccx, starting_point, &neighbors[..], reference_map);\n+    record_references(ccx.tcx(), starting_point, &neighbors[..], reference_map);\n \n     for neighbour in neighbors {\n         collect_items_rec(ccx, neighbour, visited, recursion_depths, reference_map);\n@@ -433,23 +433,23 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx.tcx()));\n }\n \n-fn record_references<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               caller: TransItem<'tcx>,\n-                               callees: &[TransItem<'tcx>],\n-                               reference_map: &mut ReferenceMap<'tcx>) {\n+fn record_references<'tcx>(tcx: &TyCtxt<'tcx>,\n+                           caller: TransItem<'tcx>,\n+                           callees: &[TransItem<'tcx>],\n+                           reference_map: &mut ReferenceMap<'tcx>) {\n     let iter = callees.into_iter()\n                       .map(|callee| {\n                         let is_inlining_candidate = callee.is_from_extern_crate() ||\n-                                                    callee.requests_inline(ccx.tcx());\n+                                                    callee.requests_inline(tcx);\n                         (*callee, is_inlining_candidate)\n                       });\n     reference_map.record_references(caller, iter);\n }\n \n-fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n-                                       instance: Instance<'tcx>,\n-                                       recursion_depths: &mut DefIdMap<usize>)\n-                                       -> (DefId, usize) {\n+fn check_recursion_limit<'tcx>(tcx: &TyCtxt<'tcx>,\n+                               instance: Instance<'tcx>,\n+                               recursion_depths: &mut DefIdMap<usize>)\n+                               -> (DefId, usize) {\n     let recursion_depth = recursion_depths.get(&instance.def)\n                                           .map(|x| *x)\n                                           .unwrap_or(0);\n@@ -458,13 +458,13 @@ fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     // Code that needs to instantiate the same function recursively\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n-    if recursion_depth > ccx.sess().recursion_limit.get() {\n+    if recursion_depth > tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n-        if let Some(node_id) = ccx.tcx().map.as_local_node_id(instance.def) {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(node_id), &error);\n+        if let Some(node_id) = tcx.map.as_local_node_id(instance.def) {\n+            tcx.sess.span_fatal(tcx.map.span(node_id), &error);\n         } else {\n-            ccx.sess().fatal(&error);\n+            tcx.sess.fatal(&error);\n         }\n     }\n \n@@ -488,8 +488,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *rvalue {\n             mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n                                                                ref substs), _) => {\n-                assert!(can_have_local_instance(self.ccx, def_id));\n-                let trans_item = create_fn_trans_item(self.ccx,\n+                assert!(can_have_local_instance(self.ccx.tcx(), def_id));\n+                let trans_item = create_fn_trans_item(self.ccx.tcx(),\n                                                       def_id,\n                                                       substs.func_substs,\n                                                       self.param_substs);\n@@ -527,9 +527,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         .require(ExchangeMallocFnLangItem)\n                         .unwrap_or_else(|e| self.ccx.sess().fatal(&e));\n \n-                assert!(can_have_local_instance(self.ccx, exchange_malloc_fn_def_id));\n+                assert!(can_have_local_instance(self.ccx.tcx(), exchange_malloc_fn_def_id));\n                 let exchange_malloc_fn_trans_item =\n-                    create_fn_trans_item(self.ccx,\n+                    create_fn_trans_item(self.ccx.tcx(),\n                                          exchange_malloc_fn_def_id,\n                                          &Substs::empty(),\n                                          self.param_substs);\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 // result in a translation item ...\n                 if can_result_in_trans_item(self.ccx, callee_def_id) {\n                     // ... and create one if it does.\n-                    let trans_item = create_fn_trans_item(self.ccx,\n+                    let trans_item = create_fn_trans_item(self.ccx.tcx(),\n                                                           callee_def_id,\n                                                           callee_substs,\n                                                           self.param_substs);\n@@ -631,18 +631,18 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 return false;\n             }\n \n-            can_have_local_instance(ccx, def_id)\n+            can_have_local_instance(ccx.tcx(), def_id)\n         }\n     }\n }\n \n-fn can_have_local_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> bool {\n+fn can_have_local_instance<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                 def_id: DefId)\n+                                 -> bool {\n     // Take a look if we have the definition available. If not, we\n     // will not emit code for this item in the local crate, and thus\n     // don't create a translation item for it.\n-    def_id.is_local() || ccx.sess().cstore.is_item_mir_available(def_id)\n+    def_id.is_local() || tcx.sess.cstore.is_item_mir_available(def_id)\n }\n \n fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -667,9 +667,9 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                          .require(ExchangeFreeFnLangItem)\n                                          .unwrap_or_else(|e| ccx.sess().fatal(&e));\n \n-        assert!(can_have_local_instance(ccx, exchange_free_fn_def_id));\n+        assert!(can_have_local_instance(ccx.tcx(), exchange_free_fn_def_id));\n         let exchange_free_fn_trans_item =\n-            create_fn_trans_item(ccx,\n+            create_fn_trans_item(ccx.tcx(),\n                                  exchange_free_fn_def_id,\n                                  &Substs::empty(),\n                                  &Substs::empty());\n@@ -706,8 +706,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             _ => bug!()\n         };\n \n-        if can_have_local_instance(ccx, destructor_did) {\n-            let trans_item = create_fn_trans_item(ccx,\n+        if can_have_local_instance(ccx.tcx(), destructor_did) {\n+            let trans_item = create_fn_trans_item(ccx.tcx(),\n                                                   destructor_did,\n                                                   substs,\n                                                   &Substs::empty());\n@@ -961,29 +961,27 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                  def_id: DefId,\n-                                  fn_substs: &Substs<'tcx>,\n-                                  param_substs: &Substs<'tcx>)\n-                                  -> TransItem<'tcx>\n-{\n+fn create_fn_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n+                              def_id: DefId,\n+                              fn_substs: &Substs<'tcx>,\n+                              param_substs: &Substs<'tcx>)\n+                              -> TransItem<'tcx> {\n     debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n-            def_id_to_string(ccx.tcx(), def_id),\n+            def_id_to_string(tcx, def_id),\n             fn_substs,\n             param_substs);\n \n     // We only get here, if fn_def_id either designates a local item or\n     // an inlineable external item. Non-inlineable external items are\n     // ignored because we don't want to generate any code for them.\n-    let concrete_substs = monomorphize::apply_param_substs(ccx.tcx(),\n+    let concrete_substs = monomorphize::apply_param_substs(tcx,\n                                                            param_substs,\n                                                            fn_substs);\n-    let concrete_substs = ccx.tcx().erase_regions(&concrete_substs);\n+    let concrete_substs = tcx.erase_regions(&concrete_substs);\n \n     let trans_item =\n         TransItem::Fn(Instance::new(def_id,\n-                                    &ccx.tcx().mk_substs(concrete_substs)));\n-\n+                                    &tcx.mk_substs(concrete_substs)));\n     return trans_item;\n }\n \n@@ -1014,8 +1012,8 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                         .filter_map(|opt_impl_method| opt_impl_method)\n                         // create translation items\n                         .filter_map(|impl_method| {\n-                            if can_have_local_instance(ccx, impl_method.method.def_id) {\n-                                Some(create_fn_trans_item(ccx,\n+                            if can_have_local_instance(ccx.tcx(), impl_method.method.def_id) {\n+                                Some(create_fn_trans_item(ccx.tcx(),\n                                                           impl_method.method.def_id,\n                                                           &impl_method.substs,\n                                                           &Substs::empty()))\n@@ -1063,7 +1061,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n \n             hir::ItemImpl(..) => {\n                 if self.mode == TransItemCollectionMode::Eager {\n-                    create_trans_items_for_default_impls(self.ccx,\n+                    create_trans_items_for_default_impls(self.ccx.tcx(),\n                                                          item,\n                                                          self.output);\n                 }\n@@ -1149,9 +1147,9 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                  item: &'tcx hir::Item,\n-                                                  output: &mut Vec<TransItem<'tcx>>) {\n+fn create_trans_items_for_default_impls<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                              item: &'tcx hir::Item,\n+                                              output: &mut Vec<TransItem<'tcx>>) {\n     match item.node {\n         hir::ItemImpl(_,\n                       _,\n@@ -1163,11 +1161,10 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 return\n             }\n \n-            let tcx = ccx.tcx();\n             let impl_def_id = tcx.map.local_def_id(item.id);\n \n             debug!(\"create_trans_items_for_default_impls(item={})\",\n-                   def_id_to_string(ccx.tcx(), impl_def_id));\n+                   def_id_to_string(tcx, impl_def_id));\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n@@ -1194,13 +1191,13 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     assert!(mth.is_provided);\n \n                     let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                    if !normalize_and_test_predicates(ccx.tcx(), predicates.into_vec()) {\n+                    if !normalize_and_test_predicates(tcx, predicates.into_vec()) {\n                         continue;\n                     }\n \n-                    if can_have_local_instance(ccx, default_impl.def_id) {\n-                        let empty_substs = ccx.tcx().mk_substs(ccx.tcx().erase_regions(mth.substs));\n-                        let item = create_fn_trans_item(ccx,\n+                    if can_have_local_instance(tcx, default_impl.def_id) {\n+                        let empty_substs = tcx.mk_substs(tcx.erase_regions(mth.substs));\n+                        let item = create_fn_trans_item(tcx,\n                                                         default_impl.def_id,\n                                                         callee_substs,\n                                                         empty_substs);"}]}