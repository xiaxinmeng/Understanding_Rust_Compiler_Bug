{"sha": "fb084a48e2ca663de41b316dc6ece2dceb93e24e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMDg0YTQ4ZTJjYTY2M2RlNDFiMzE2ZGM2ZWNlMmRjZWI5M2UyNGU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-08T03:21:18Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-12T23:29:22Z"}, "message": "Pass a `Symbol` to `check_name`, `emit_feature_err`, and related functions.", "tree": {"sha": "b78379f996dceee6039ea4880c66e7fe30b3efad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b78379f996dceee6039ea4880c66e7fe30b3efad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb084a48e2ca663de41b316dc6ece2dceb93e24e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb084a48e2ca663de41b316dc6ece2dceb93e24e", "html_url": "https://github.com/rust-lang/rust/commit/fb084a48e2ca663de41b316dc6ece2dceb93e24e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb084a48e2ca663de41b316dc6ece2dceb93e24e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79602c87b561e26fa1a8fe58b9130cca37375f90", "url": "https://api.github.com/repos/rust-lang/rust/commits/79602c87b561e26fa1a8fe58b9130cca37375f90", "html_url": "https://github.com/rust-lang/rust/commit/79602c87b561e26fa1a8fe58b9130cca37375f90"}], "stats": {"total": 1290, "additions": 670, "deletions": 620}, "files": [{"sha": "23c8a671ec5b3563252430c95218d114b461035b", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -12,6 +12,7 @@ use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use std::fmt::{self, Display};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -95,18 +96,18 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n             self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n-        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n+        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(sym::target_feature)) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")\n                 .emit();\n         }\n \n         for attr in &item.attrs {\n-            if attr.check_name(\"inline\") {\n+            if attr.check_name(sym::inline) {\n                 self.check_inline(attr, &item.span, target)\n-            } else if attr.check_name(\"non_exhaustive\") {\n+            } else if attr.check_name(sym::non_exhaustive) {\n                 self.check_non_exhaustive(attr, item, target)\n-            } else if attr.check_name(\"marker\") {\n+            } else if attr.check_name(sym::marker) {\n                 self.check_marker(attr, item, target)\n             }\n         }\n@@ -166,7 +167,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // ```\n         let hints: Vec<_> = item.attrs\n             .iter()\n-            .filter(|attr| attr.check_name(\"repr\"))\n+            .filter(|attr| attr.check_name(sym::repr))\n             .filter_map(|attr| attr.meta_item_list())\n             .flatten()\n             .collect();\n@@ -268,10 +269,10 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // When checking statements ignore expressions, they will be checked later\n         if let hir::StmtKind::Local(ref l) = stmt.node {\n             for attr in l.attrs.iter() {\n-                if attr.check_name(\"inline\") {\n+                if attr.check_name(sym::inline) {\n                     self.check_inline(attr, &stmt.span, Target::Statement);\n                 }\n-                if attr.check_name(\"repr\") {\n+                if attr.check_name(sym::repr) {\n                     self.emit_repr_error(\n                         attr.span,\n                         stmt.span,\n@@ -289,10 +290,10 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n             _ => Target::Expression,\n         };\n         for attr in expr.attrs.iter() {\n-            if attr.check_name(\"inline\") {\n+            if attr.check_name(sym::inline) {\n                 self.check_inline(attr, &expr.span, target);\n             }\n-            if attr.check_name(\"repr\") {\n+            if attr.check_name(sym::repr) {\n                 self.emit_repr_error(\n                     attr.span,\n                     expr.span,\n@@ -305,7 +306,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_used(&self, item: &hir::Item, target: Target) {\n         for attr in &item.attrs {\n-            if attr.check_name(\"used\") && target != Target::Static {\n+            if attr.check_name(sym::used) && target != Target::Static {\n                 self.tcx.sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n             }"}, {"sha": "0d80a0874e63f3a6bafcc397d17134b0ea85c22c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -64,7 +64,7 @@ use syntax::ptr::P;\n use syntax::source_map::{respan, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::{keywords, Symbol, sym};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n@@ -2727,7 +2727,7 @@ impl<'a> LoweringContext<'a> {\n                         self.lower_ty(x, ImplTraitContext::disallowed())\n                     }),\n                     synthetic: param.attrs.iter()\n-                                          .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                                          .filter(|attr| attr.check_name(sym::rustc_synthetic))\n                                           .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n                                           .next(),\n                 };\n@@ -2745,7 +2745,7 @@ impl<'a> LoweringContext<'a> {\n             hir_id: self.lower_node_id(param.id),\n             name,\n             span: param.ident.span,\n-            pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n+            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n             attrs: self.lower_attrs(&param.attrs),\n             bounds,\n             kind,\n@@ -3773,8 +3773,8 @@ impl<'a> LoweringContext<'a> {\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n         if let ItemKind::MacroDef(ref def) = i.node {\n-            if !def.legacy || attr::contains_name(&i.attrs, \"macro_export\") ||\n-                              attr::contains_name(&i.attrs, \"rustc_doc_only_macro\") {\n+            if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) ||\n+                              attr::contains_name(&i.attrs, sym::rustc_doc_only_macro) {\n                 let body = self.lower_token_stream(def.stream());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {"}, {"sha": "8be610e8bf7af715691b4dd36bcd7fe1f432af6f", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -28,7 +28,7 @@ use smallvec::SmallVec;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n     debug_assert!(ich::IGNORED_ATTRIBUTES.len() > 0);\n-    ich::IGNORED_ATTRIBUTES.iter().map(|&s| Symbol::intern(s)).collect()\n+    ich::IGNORED_ATTRIBUTES.iter().map(|&s| s).collect()\n }\n \n /// This is the context state available during incr. comp. hashing. It contains"}, {"sha": "f3fc7ec8fda1530b4d9fe6295e01ce1967c818d0", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -4,6 +4,8 @@ crate use rustc_data_structures::fingerprint::Fingerprint;\n pub use self::caching_source_map_view::CachingSourceMapView;\n pub use self::hcx::{StableHashingContextProvider, StableHashingContext, NodeIdHashingMode,\n                     hash_stable_trait_impls};\n+use syntax::symbol::{Symbol, sym};\n+\n mod caching_source_map_view;\n mod hcx;\n \n@@ -12,16 +14,16 @@ mod impls_misc;\n mod impls_ty;\n mod impls_syntax;\n \n-pub const ATTR_DIRTY: &str = \"rustc_dirty\";\n-pub const ATTR_CLEAN: &str = \"rustc_clean\";\n-pub const ATTR_IF_THIS_CHANGED: &str = \"rustc_if_this_changed\";\n-pub const ATTR_THEN_THIS_WOULD_NEED: &str = \"rustc_then_this_would_need\";\n-pub const ATTR_PARTITION_REUSED: &str = \"rustc_partition_reused\";\n-pub const ATTR_PARTITION_CODEGENED: &str = \"rustc_partition_codegened\";\n-pub const ATTR_EXPECTED_CGU_REUSE: &str = \"rustc_expected_cgu_reuse\";\n+pub const ATTR_DIRTY: Symbol = sym::rustc_dirty;\n+pub const ATTR_CLEAN: Symbol = sym::rustc_clean;\n+pub const ATTR_IF_THIS_CHANGED: Symbol = sym::rustc_if_this_changed;\n+pub const ATTR_THEN_THIS_WOULD_NEED: Symbol = sym::rustc_then_this_would_need;\n+pub const ATTR_PARTITION_REUSED: Symbol = sym::rustc_partition_reused;\n+pub const ATTR_PARTITION_CODEGENED: Symbol = sym::rustc_partition_codegened;\n+pub const ATTR_EXPECTED_CGU_REUSE: Symbol = sym::rustc_expected_cgu_reuse;\n \n-pub const IGNORED_ATTRIBUTES: &[&str] = &[\n-    \"cfg\",\n+pub const IGNORED_ATTRIBUTES: &[Symbol] = &[\n+    sym::cfg,\n     ATTR_IF_THIS_CHANGED,\n     ATTR_THEN_THIS_WOULD_NEED,\n     ATTR_DIRTY,"}, {"sha": "a69758e33baba6e1bf71128e1be14f08f3dd1e76", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n use syntax::source_map::MultiSpan;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n \n pub struct LintLevelSets {\n     list: Vec<LintSet>,\n@@ -230,7 +230,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                                 if !self.sess.features_untracked().lint_reasons {\n                                     feature_gate::emit_feature_err(\n                                         &self.sess.parse_sess,\n-                                        \"lint_reasons\",\n+                                        sym::lint_reasons,\n                                         item.span,\n                                         feature_gate::GateIssue::Language,\n                                         \"lint reasons are experimental\""}, {"sha": "2a9928567f4dcfa2fed79a3dd44afba6ed765089", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::fx::FxHashMap;\n \n use syntax::{ast, source_map};\n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos;\n \n // Any local node that may call something in its body block should be\n@@ -304,22 +305,22 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n                                     id: hir::HirId,\n                                     attrs: &[ast::Attribute]) -> bool {\n-    if attr::contains_name(attrs, \"lang\") {\n+    if attr::contains_name(attrs, sym::lang) {\n         return true;\n     }\n \n     // Stable attribute for #[lang = \"panic_impl\"]\n-    if attr::contains_name(attrs, \"panic_handler\") {\n+    if attr::contains_name(attrs, sym::panic_handler) {\n         return true;\n     }\n \n     // (To be) stable attribute for #[lang = \"oom\"]\n-    if attr::contains_name(attrs, \"alloc_error_handler\") {\n+    if attr::contains_name(attrs, sym::alloc_error_handler) {\n         return true;\n     }\n \n     // Don't lint about global allocators\n-    if attr::contains_name(attrs, \"global_allocator\") {\n+    if attr::contains_name(attrs, sym::global_allocator) {\n         return true;\n     }\n "}, {"sha": "e2e76e69dc4edb889596b39ba53a1e084f36ed25", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -4,6 +4,7 @@ use crate::session::{config, Session};\n use crate::session::config::EntryFnType;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use crate::hir::{HirId, Item, ItemKind, ImplItem, TraitItem};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n@@ -58,7 +59,7 @@ fn entry_fn(tcx: TyCtxt<'_, '_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnTy\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(&tcx.hir().krate().attrs, \"no_main\") {\n+    if attr::contains_name(&tcx.hir().krate().attrs, sym::no_main) {\n         return None;\n     }\n \n@@ -81,9 +82,9 @@ fn entry_fn(tcx: TyCtxt<'_, '_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnTy\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n     match item.node {\n         ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, \"start\") {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, \"main\") {\n+            } else if attr::contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == \"main\" {\n                 if at_root {"}, {"sha": "103580a598fcd9cea61e1c2804894fc985bf3d46", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -18,7 +18,7 @@ use crate::middle::weak_lang_items;\n use crate::util::nodemap::FxHashMap;\n \n use syntax::ast;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n use rustc_macros::HashStable;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n@@ -209,9 +209,9 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n /// are also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     attrs.iter().find_map(|attr| Some(match attr {\n-        _ if attr.check_name(\"lang\") => (attr.value_str()?, attr.span),\n-        _ if attr.check_name(\"panic_handler\") => (Symbol::intern(\"panic_impl\"), attr.span),\n-        _ if attr.check_name(\"alloc_error_handler\") => (Symbol::intern(\"oom\"), attr.span),\n+        _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n+        _ if attr.check_name(sym::panic_handler) => (Symbol::intern(\"panic_impl\"), attr.span),\n+        _ if attr.check_name(sym::alloc_error_handler) => (Symbol::intern(\"oom\"), attr.span),\n         _ => return None,\n     }))\n }"}, {"sha": "cb333b5b0cba23e808ed1d3f6257c5aaef1ac081", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -112,7 +112,7 @@ use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -362,7 +362,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir().get_parent_item(id);\n         if let Some(Node::Item(i)) = ir.tcx.hir().find_by_hir_id(parent) {\n-            if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n+            if i.attrs.iter().any(|a| a.check_name(sym::automatically_derived)) {\n                 return;\n             }\n         }"}, {"sha": "c7f8cf684e6b16c28c56408e92bc55b1999da574", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -72,6 +72,7 @@ use crate::hir::{MutImmutable, MutMutable, PatKind};\n use crate::hir::pat_util::EnumerateAndAdjustIterator;\n use crate::hir;\n use syntax::ast::{self, Name};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n@@ -714,7 +715,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // they also cannot be moved out of.\n                 let is_thread_local = self.tcx.get_attrs(def_id)[..]\n                     .iter()\n-                    .any(|attr| attr.check_name(\"thread_local\"));\n+                    .any(|attr| attr.check_name(sym::thread_local));\n \n                 let cat = if is_thread_local {\n                     let re = self.temporary_scope(hir_id.local_id);"}, {"sha": "5f355d17072b8705682073bd7377fdd681e26405", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -7,15 +7,16 @@\n \n use crate::session::Session;\n use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n \n use rustc_data_structures::sync::Once;\n \n pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n-    update_limit(krate, &sess.recursion_limit, \"recursion_limit\", 64);\n-    update_limit(krate, &sess.type_length_limit, \"type_length_limit\", 1048576);\n+    update_limit(krate, &sess.recursion_limit, sym::recursion_limit, 64);\n+    update_limit(krate, &sess.type_length_limit, sym::type_length_limit, 1048576);\n }\n \n-fn update_limit(krate: &ast::Crate, limit: &Once<usize>, name: &str, default: usize) {\n+fn update_limit(krate: &ast::Crate, limit: &Once<usize>, name: Symbol, default: usize) {\n     for attr in &krate.attrs {\n         if !attr.check_name(name) {\n             continue;"}, {"sha": "2402d0eefde4886e0bdc5e8e077a487753b58c8b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -23,7 +23,7 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -1285,7 +1285,7 @@ fn compute_object_lifetime_defaults(\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n-                if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n+                if attr::contains_name(&item.attrs, sym::rustc_object_lifetime_default) {\n                     let object_lifetime_default_reprs: String = result\n                         .iter()\n                         .map(|set| match *set {"}, {"sha": "c608c72430cbe7a92e6830c59eecb668313784f1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -11,7 +11,7 @@ use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::ty::query::Providers;\n use crate::middle::privacy::AccessLevels;\n use crate::session::{DiagnosticMessageId, Session};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast::Attribute;\n use syntax::errors::Applicability;\n@@ -669,7 +669,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         match stability {\n             Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n-                if span.allows_unstable(&feature.as_str()) {\n+                if span.allows_unstable(feature) {\n                     debug!(\"stability: skipping span={:?} since it is internal\", span);\n                     return EvalResult::Allow;\n                 }\n@@ -739,7 +739,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n                 let fresh = self.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n                 if fresh {\n-                    emit_feature_err(&self.sess.parse_sess, &feature.as_str(), span,\n+                    emit_feature_err(&self.sess.parse_sess, feature, span,\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n@@ -802,13 +802,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 if adt_def.has_dtor(self.tcx) {\n                     emit_feature_err(&self.tcx.sess.parse_sess,\n-                                     \"untagged_unions\", item.span, GateIssue::Language,\n+                                     sym::untagged_unions, item.span, GateIssue::Language,\n                                      \"unions with `Drop` implementations are unstable\");\n                 } else {\n                     let param_env = self.tcx.param_env(def_id);\n                     if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n                         emit_feature_err(&self.tcx.sess.parse_sess,\n-                                         \"untagged_unions\", item.span, GateIssue::Language,\n+                                         sym::untagged_unions, item.span, GateIssue::Language,\n                                          \"unions with non-`Copy` fields are unstable\");\n                     }\n                 }"}, {"sha": "2fff4c3f109b103565cbcd910653252f57758d5e", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1052,7 +1052,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<String>>> {\n+        query target_features_whitelist(_: CrateNum) -> Lrc<FxHashMap<String, Option<Symbol>>> {\n             eval_always\n             desc { \"looking up the whitelist of target features\" }\n         }"}, {"sha": "4d47491661e8639fba50b6752de90e7eaa5bae4d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -29,6 +29,7 @@ use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;\n use syntax::parse::{self, ParseSess};\n+use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n use crate::util::profiling::SelfProfiler;\n \n@@ -86,7 +87,7 @@ pub struct Session {\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n-    pub plugin_attributes: Lock<Vec<(String, AttributeType)>>,\n+    pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n     pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The crate_disambiguator is constructed out of all the `-C metadata`"}, {"sha": "afbce5a4f0a49170e83fd41347281b9eeca6e368", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -4,17 +4,16 @@\n //! [trait-resolution]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n //! [trait-specialization]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n-use crate::infer::CombinedSnapshot;\n+use crate::infer::{CombinedSnapshot, InferOk};\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n-use syntax_pos::DUMMY_SP;\n use crate::traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n use crate::traits::IntercrateMode;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::Subst;\n-\n-use crate::infer::{InferOk};\n+use syntax::symbol::sym;\n+use syntax_pos::DUMMY_SP;\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -233,7 +232,7 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                          trait_ref: ty::TraitRef<'tcx>)\n                                                          -> bool {\n-    trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, \"fundamental\")\n+    trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n }\n \n pub enum OrphanCheckErr<'tcx> {"}, {"sha": "df2688397102299ab0c1602a27fd53a27e714cea", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -35,6 +35,7 @@ use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnFormat};\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -329,7 +330,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return None\n         };\n \n-        if tcx.has_attr(impl_def_id, \"rustc_on_unimplemented\") {\n+        if tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented) {\n             Some(impl_def_id)\n         } else {\n             None"}, {"sha": "7ba7429f465a6642604d307dc05bd0b30b40d3a1", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -7,6 +7,7 @@ use crate::util::nodemap::FxHashMap;\n \n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n \n@@ -84,25 +85,25 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         let mut note = None;\n         let mut subcommands = vec![];\n         for item in item_iter {\n-            if item.check_name(\"message\") && message.is_none() {\n+            if item.check_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n                     message = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, message_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"label\") && label.is_none() {\n+            } else if item.check_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n                     label = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, label_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"note\") && note.is_none() {\n+            } else if item.check_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n                     note = Some(OnUnimplementedFormatString::try_parse(\n                         tcx, trait_def_id, note_.as_str(), span)?);\n                     continue;\n                 }\n-            } else if item.check_name(\"on\") && is_root &&\n+            } else if item.check_name(sym::on) && is_root &&\n                 message.is_none() && label.is_none() && note.is_none()\n             {\n                 if let Some(items) = item.meta_item_list() {\n@@ -139,7 +140,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     {\n         let attrs = tcx.get_attrs(impl_def_id);\n \n-        let attr = if let Some(item) = attr::find_by_name(&attrs, \"rustc_on_unimplemented\") {\n+        let attr = if let Some(item) = attr::find_by_name(&attrs, sym::rustc_on_unimplemented) {\n             item\n         } else {\n             return Ok(None);"}, {"sha": "c9fee02f66bbdf19970bd270fddf25bbfda9bda0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -74,7 +74,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n use syntax::feature_gate;\n-use syntax::symbol::{Symbol, keywords, InternedString};\n+use syntax::symbol::{Symbol, keywords, InternedString, sym};\n use syntax_pos::Span;\n \n use crate::hir;\n@@ -1213,7 +1213,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n             span_bug!(attr.span, \"no arguments to `rustc_layout_scalar_valid_range` attribute\");\n         };\n-        (get(\"rustc_layout_scalar_valid_range_start\"), get(\"rustc_layout_scalar_valid_range_end\"))\n+        (get(sym::rustc_layout_scalar_valid_range_start),\n+         get(sym::rustc_layout_scalar_valid_range_end))\n     }\n \n     pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n@@ -3102,10 +3103,10 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), \"panic_runtime\")\n+        attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)\n     };\n     providers.is_compiler_builtins = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), \"compiler_builtins\")\n+        attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n     };\n }"}, {"sha": "2f71861d4dc0df57d8de5e9e87da1036af49eec2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -47,7 +47,7 @@ use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{keywords, Symbol, LocalInternedString, InternedString};\n+use syntax::symbol::{keywords, sym, Symbol, LocalInternedString, InternedString};\n use syntax_pos::Span;\n \n use smallvec;\n@@ -1875,11 +1875,11 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         );\n \n         let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n-        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, \"non_exhaustive\") {\n+        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, sym::non_exhaustive) {\n             debug!(\"found non-exhaustive field list for {:?}\", parent_did);\n             flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n         } else if let Some(variant_did) = variant_did {\n-            if tcx.has_attr(variant_did, \"non_exhaustive\") {\n+            if tcx.has_attr(variant_did, sym::non_exhaustive) {\n                 debug!(\"found non-exhaustive field list for {:?}\", variant_did);\n                 flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n             }\n@@ -2156,7 +2156,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n \n-        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n+        if kind == AdtKind::Enum && tcx.has_attr(did, sym::non_exhaustive) {\n             debug!(\"found non-exhaustive variant list for {:?}\", did);\n             flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n         }\n@@ -2172,7 +2172,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n \n         let attrs = tcx.get_attrs(did);\n-        if attr::contains_name(&attrs, \"fundamental\") {\n+        if attr::contains_name(&attrs, sym::fundamental) {\n             flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {\n@@ -3030,7 +3030,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Determines whether an item is annotated with an attribute.\n-    pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n+    pub fn has_attr(self, did: DefId, attr: Symbol) -> bool {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n "}, {"sha": "926c0f8b949193cc9376b75259d7bf936df00bca", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -22,6 +22,7 @@ use rustc_macros::HashStable;\n use std::{cmp, fmt};\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug)]\n@@ -447,7 +448,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Such access can be in plain sight (e.g., dereferencing\n         // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n         // (e.g., calling `foo.0.clone()` of `Foo<T:Clone>`).\n-        if self.has_attr(dtor, \"unsafe_destructor_blind_to_params\") {\n+        if self.has_attr(dtor, sym::unsafe_destructor_blind_to_params) {\n             debug!(\"destructor_constraint({:?}) - blind\", def.did);\n             return vec![];\n         }"}, {"sha": "0200e6c53b69cc1742bdbfae1379654e8ff1a218", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n     ptr::P,\n-    symbol::Symbol\n+    symbol::{Symbol, sym}\n };\n use syntax_pos::Span;\n \n@@ -58,7 +58,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n     fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n         debug!(\"in submodule {}\", self.in_submod);\n \n-        let name = if attr::contains_name(&item.attrs, \"global_allocator\") {\n+        let name = if attr::contains_name(&item.attrs, sym::global_allocator) {\n             \"global_allocator\"\n         } else {\n             return mut_visit::noop_flat_map_item(item, self);"}, {"sha": "f26684d9ef04ae4a46c4ee87f1884a1f33af350b", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -321,12 +321,12 @@ pub fn provide(providers: &mut Providers<'_>) {\n             // rustdoc needs to be able to document functions that use all the features, so\n             // whitelist them all\n             Lrc::new(llvm_util::all_known_features()\n-                .map(|(a, b)| (a.to_string(), b.map(|s| s.to_string())))\n+                .map(|(a, b)| (a.to_string(), b))\n                 .collect())\n         } else {\n             Lrc::new(llvm_util::target_feature_whitelist(tcx.sess)\n                 .iter()\n-                .map(|&(a, b)| (a.to_string(), b.map(|s| s.to_string())))\n+                .map(|&(a, b)| (a.to_string(), b))\n                 .collect())\n         }\n     };"}, {"sha": "5f47108309fbfdac3749da165bba96e0682c90c5", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::interpret::{ConstValue, Allocation, read_target_uint,\n use rustc::hir::Node;\n use syntax_pos::Span;\n use rustc_target::abi::HasDataLayout;\n+use syntax::symbol::sym;\n use syntax_pos::symbol::LocalInternedString;\n use rustc::ty::{self, Ty};\n use rustc_codegen_ssa::traits::*;\n@@ -248,7 +249,7 @@ impl CodegenCx<'ll, 'tcx> {\n             debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n \n             for attr in attrs {\n-                if attr.check_name(\"thread_local\") {\n+                if attr.check_name(sym::thread_local) {\n                     llvm::set_thread_local_mode(g, self.tls_model);\n                 }\n             }"}, {"sha": "04c9e93c7a527cf79c41c18d035706cc740ca987", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -9,6 +9,7 @@ use rustc::session::config::DebugInfo;\n use rustc_codegen_ssa::traits::*;\n \n use syntax::attr;\n+use syntax::symbol::sym;\n \n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n@@ -66,8 +67,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&cx.tcx.hir().krate_attrs(),\n-                            \"omit_gdb_pretty_printer_section\");\n+        attr::contains_name(&cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     !omit_gdb_pretty_printer_section &&\n     cx.sess().opts.debuginfo != DebugInfo::None &&"}, {"sha": "274c89659628d207125710f69cc65b72af37eb0a", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 68, "deletions": 67, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -7,6 +7,7 @@ use rustc_target::spec::MergeFunctions;\n use libc::c_int;\n use std::ffi::CString;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::sym;\n \n use std::str;\n use std::slice;\n@@ -93,114 +94,114 @@ unsafe fn configure_llvm(sess: &Session) {\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n \n-const ARM_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"aclass\", Some(\"arm_target_feature\")),\n-    (\"mclass\", Some(\"arm_target_feature\")),\n-    (\"rclass\", Some(\"arm_target_feature\")),\n-    (\"dsp\", Some(\"arm_target_feature\")),\n-    (\"neon\", Some(\"arm_target_feature\")),\n-    (\"v5te\", Some(\"arm_target_feature\")),\n-    (\"v6\", Some(\"arm_target_feature\")),\n-    (\"v6k\", Some(\"arm_target_feature\")),\n-    (\"v6t2\", Some(\"arm_target_feature\")),\n-    (\"v7\", Some(\"arm_target_feature\")),\n-    (\"v8\", Some(\"arm_target_feature\")),\n-    (\"vfp2\", Some(\"arm_target_feature\")),\n-    (\"vfp3\", Some(\"arm_target_feature\")),\n-    (\"vfp4\", Some(\"arm_target_feature\")),\n+const ARM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"aclass\", Some(sym::arm_target_feature)),\n+    (\"mclass\", Some(sym::arm_target_feature)),\n+    (\"rclass\", Some(sym::arm_target_feature)),\n+    (\"dsp\", Some(sym::arm_target_feature)),\n+    (\"neon\", Some(sym::arm_target_feature)),\n+    (\"v5te\", Some(sym::arm_target_feature)),\n+    (\"v6\", Some(sym::arm_target_feature)),\n+    (\"v6k\", Some(sym::arm_target_feature)),\n+    (\"v6t2\", Some(sym::arm_target_feature)),\n+    (\"v7\", Some(sym::arm_target_feature)),\n+    (\"v8\", Some(sym::arm_target_feature)),\n+    (\"vfp2\", Some(sym::arm_target_feature)),\n+    (\"vfp3\", Some(sym::arm_target_feature)),\n+    (\"vfp4\", Some(sym::arm_target_feature)),\n ];\n \n-const AARCH64_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"fp\", Some(\"aarch64_target_feature\")),\n-    (\"neon\", Some(\"aarch64_target_feature\")),\n-    (\"sve\", Some(\"aarch64_target_feature\")),\n-    (\"crc\", Some(\"aarch64_target_feature\")),\n-    (\"crypto\", Some(\"aarch64_target_feature\")),\n-    (\"ras\", Some(\"aarch64_target_feature\")),\n-    (\"lse\", Some(\"aarch64_target_feature\")),\n-    (\"rdm\", Some(\"aarch64_target_feature\")),\n-    (\"fp16\", Some(\"aarch64_target_feature\")),\n-    (\"rcpc\", Some(\"aarch64_target_feature\")),\n-    (\"dotprod\", Some(\"aarch64_target_feature\")),\n-    (\"v8.1a\", Some(\"aarch64_target_feature\")),\n-    (\"v8.2a\", Some(\"aarch64_target_feature\")),\n-    (\"v8.3a\", Some(\"aarch64_target_feature\")),\n+const AARCH64_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"fp\", Some(sym::aarch64_target_feature)),\n+    (\"neon\", Some(sym::aarch64_target_feature)),\n+    (\"sve\", Some(sym::aarch64_target_feature)),\n+    (\"crc\", Some(sym::aarch64_target_feature)),\n+    (\"crypto\", Some(sym::aarch64_target_feature)),\n+    (\"ras\", Some(sym::aarch64_target_feature)),\n+    (\"lse\", Some(sym::aarch64_target_feature)),\n+    (\"rdm\", Some(sym::aarch64_target_feature)),\n+    (\"fp16\", Some(sym::aarch64_target_feature)),\n+    (\"rcpc\", Some(sym::aarch64_target_feature)),\n+    (\"dotprod\", Some(sym::aarch64_target_feature)),\n+    (\"v8.1a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.2a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.3a\", Some(sym::aarch64_target_feature)),\n ];\n \n-const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"adx\", Some(\"adx_target_feature\")),\n+const X86_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"adx\", Some(sym::adx_target_feature)),\n     (\"aes\", None),\n     (\"avx\", None),\n     (\"avx2\", None),\n-    (\"avx512bw\", Some(\"avx512_target_feature\")),\n-    (\"avx512cd\", Some(\"avx512_target_feature\")),\n-    (\"avx512dq\", Some(\"avx512_target_feature\")),\n-    (\"avx512er\", Some(\"avx512_target_feature\")),\n-    (\"avx512f\", Some(\"avx512_target_feature\")),\n-    (\"avx512ifma\", Some(\"avx512_target_feature\")),\n-    (\"avx512pf\", Some(\"avx512_target_feature\")),\n-    (\"avx512vbmi\", Some(\"avx512_target_feature\")),\n-    (\"avx512vl\", Some(\"avx512_target_feature\")),\n-    (\"avx512vpopcntdq\", Some(\"avx512_target_feature\")),\n+    (\"avx512bw\", Some(sym::avx512_target_feature)),\n+    (\"avx512cd\", Some(sym::avx512_target_feature)),\n+    (\"avx512dq\", Some(sym::avx512_target_feature)),\n+    (\"avx512er\", Some(sym::avx512_target_feature)),\n+    (\"avx512f\", Some(sym::avx512_target_feature)),\n+    (\"avx512ifma\", Some(sym::avx512_target_feature)),\n+    (\"avx512pf\", Some(sym::avx512_target_feature)),\n+    (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n+    (\"avx512vl\", Some(sym::avx512_target_feature)),\n+    (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n     (\"bmi1\", None),\n     (\"bmi2\", None),\n-    (\"cmpxchg16b\", Some(\"cmpxchg16b_target_feature\")),\n-    (\"f16c\", Some(\"f16c_target_feature\")),\n+    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n+    (\"f16c\", Some(sym::f16c_target_feature)),\n     (\"fma\", None),\n     (\"fxsr\", None),\n     (\"lzcnt\", None),\n-    (\"mmx\", Some(\"mmx_target_feature\")),\n-    (\"movbe\", Some(\"movbe_target_feature\")),\n+    (\"mmx\", Some(sym::mmx_target_feature)),\n+    (\"movbe\", Some(sym::movbe_target_feature)),\n     (\"pclmulqdq\", None),\n     (\"popcnt\", None),\n     (\"rdrand\", None),\n     (\"rdseed\", None),\n-    (\"rtm\", Some(\"rtm_target_feature\")),\n+    (\"rtm\", Some(sym::rtm_target_feature)),\n     (\"sha\", None),\n     (\"sse\", None),\n     (\"sse2\", None),\n     (\"sse3\", None),\n     (\"sse4.1\", None),\n     (\"sse4.2\", None),\n-    (\"sse4a\", Some(\"sse4a_target_feature\")),\n+    (\"sse4a\", Some(sym::sse4a_target_feature)),\n     (\"ssse3\", None),\n-    (\"tbm\", Some(\"tbm_target_feature\")),\n+    (\"tbm\", Some(sym::tbm_target_feature)),\n     (\"xsave\", None),\n     (\"xsavec\", None),\n     (\"xsaveopt\", None),\n     (\"xsaves\", None),\n ];\n \n-const HEXAGON_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"hvx\", Some(\"hexagon_target_feature\")),\n-    (\"hvx-double\", Some(\"hexagon_target_feature\")),\n+const HEXAGON_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"hvx\", Some(sym::hexagon_target_feature)),\n+    (\"hvx-double\", Some(sym::hexagon_target_feature)),\n ];\n \n-const POWERPC_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power8-altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power9-altivec\", Some(\"powerpc_target_feature\")),\n-    (\"power8-vector\", Some(\"powerpc_target_feature\")),\n-    (\"power9-vector\", Some(\"powerpc_target_feature\")),\n-    (\"vsx\", Some(\"powerpc_target_feature\")),\n+const POWERPC_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-vector\", Some(sym::powerpc_target_feature)),\n+    (\"power9-vector\", Some(sym::powerpc_target_feature)),\n+    (\"vsx\", Some(sym::powerpc_target_feature)),\n ];\n \n-const MIPS_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"fp64\", Some(\"mips_target_feature\")),\n-    (\"msa\", Some(\"mips_target_feature\")),\n+const MIPS_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"fp64\", Some(sym::mips_target_feature)),\n+    (\"msa\", Some(sym::mips_target_feature)),\n ];\n \n-const WASM_WHITELIST: &[(&str, Option<&str>)] = &[\n-    (\"simd128\", Some(\"wasm_target_feature\")),\n-    (\"atomics\", Some(\"wasm_target_feature\")),\n+const WASM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"simd128\", Some(sym::wasm_target_feature)),\n+    (\"atomics\", Some(sym::wasm_target_feature)),\n ];\n \n /// When rustdoc is running, provide a list of all known features so that all their respective\n /// primitives may be documented.\n ///\n /// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n /// iterator!\n-pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<&'static str>)> {\n+pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<Symbol>)> {\n     ARM_WHITELIST.iter().cloned()\n         .chain(AARCH64_WHITELIST.iter().cloned())\n         .chain(X86_WHITELIST.iter().cloned())\n@@ -247,7 +248,7 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n }\n \n pub fn target_feature_whitelist(sess: &Session)\n-    -> &'static [(&'static str, Option<&'static str>)]\n+    -> &'static [(&'static str, Option<Symbol>)]\n {\n     match &*sess.target.target.arch {\n         \"arm\" => ARM_WHITELIST,"}, {"sha": "204ca59efc8d35bc70fa1367a64de09ec247bc48", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -28,7 +28,7 @@ use rustc_target::spec::MergeFunctions;\n use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n \n use std::any::Any;\n@@ -382,9 +382,9 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n-    let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, \"no_builtins\");\n+    let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, sym::no_builtins);\n     let subsystem = attr::first_attr_value_str_by_name(&tcx.hir().krate().attrs,\n-                                                       \"windows_subsystem\");\n+                                                       sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n         if subsystem != \"windows\" && subsystem != \"console\" {\n             tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\"}, {"sha": "586db5cfabea44c83c1e4bafdeffca034818b86d", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -5,6 +5,7 @@ use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n use std::{u128, i128};\n+use syntax::symbol::sym;\n \n use crate::base;\n use crate::MemFlags;\n@@ -181,9 +182,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n                         match operand.layout.ty.sty {\n                             ty::FnDef(def_id, substs) => {\n-                                if bx.cx().tcx().has_attr(def_id, \"rustc_args_required_const\") {\n-                                    bug!(\"reifying a fn ptr that requires \\\n-                                          const arguments\");\n+                                if bx.cx().tcx().has_attr(def_id, sym::rustc_args_required_const) {\n+                                    bug!(\"reifying a fn ptr that requires const arguments\");\n                                 }\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bx.cx(), def_id, substs))"}, {"sha": "b4ba90c61f65054fb2242d9825eba54466f96227", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -23,6 +23,7 @@ extern crate rustc;\n \n use rustc::ty::TyCtxt;\n use rustc::hir::def_id::LOCAL_CRATE;\n+use syntax::symbol::sym;\n \n pub mod link;\n pub mod codegen_backend;\n@@ -35,7 +36,7 @@ pub mod symbol_names_test;\n /// reporting an error.\n pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_, '_, '_>) {\n     if let Some((def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-        if tcx.has_attr(def_id, \"rustc_error\") {\n+        if tcx.has_attr(def_id, sym::rustc_error) {\n             tcx.sess.span_fatal(tcx.def_span(def_id), \"compilation successful\");\n         }\n     }"}, {"sha": "30f37fefa7cf7506cd6a5c2dd5b6079a0f775cbf", "filename": "src/librustc_codegen_utils/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flink.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -2,6 +2,7 @@ use rustc::session::config::{self, OutputFilenames, Input, OutputType};\n use rustc::session::Session;\n use std::path::{Path, PathBuf};\n use syntax::{ast, attr};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn out_filename(sess: &Session,\n@@ -49,7 +50,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n     // as used. After doing this, however, we still prioritize a crate name from\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n-    let attr_crate_name = attr::find_by_name(attrs, \"crate_name\")\n+    let attr_crate_name = attr::find_by_name(attrs, sym::crate_name)\n         .and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(sess) = sess {"}, {"sha": "27ae0b97e59452f406c34d87ecfb133f74d7e8c4", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -6,11 +6,11 @@\n \n use rustc::hir;\n use rustc::ty::TyCtxt;\n-\n use rustc_mir::monomorphize::Instance;\n+use syntax::symbol::{Symbol, sym};\n \n-const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n-const DEF_PATH: &'static str = \"rustc_def_path\";\n+const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n+const DEF_PATH: Symbol = sym::rustc_def_path;\n \n pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the"}, {"sha": "04dad9c5355c5b6028416a6a8cac8633660d8335", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -27,12 +27,13 @@ use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::TyCtxt;\n use std::collections::BTreeSet;\n use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED,\n                  ATTR_EXPECTED_CGU_REUSE};\n \n-const MODULE: &str = \"module\";\n-const CFG: &str = \"cfg\";\n-const KIND: &str = \"kind\";\n+const MODULE: Symbol = sym::module;\n+const CFG: Symbol = sym::cfg;\n+const KIND: Symbol = sym::kind;\n \n pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n@@ -146,7 +147,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n                                                         comp_kind);\n     }\n \n-    fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n+    fn field(&self, attr: &ast::Attribute, name: Symbol) -> ast::Name {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {"}, {"sha": "f404a4f82e672a1e76958d45b3b72bb31ddac777", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -23,14 +23,15 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit;\n use rustc::ich::{ATTR_DIRTY, ATTR_CLEAN};\n-use syntax::ast::{self, Attribute, NestedMetaItem};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n+use syntax::ast::{self, Attribute, NestedMetaItem};\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n-use rustc::ty::TyCtxt;\n \n-const EXCEPT: &str = \"except\";\n-const LABEL: &str = \"label\";\n-const CFG: &str = \"cfg\";\n+const EXCEPT: Symbol = sym::except;\n+const LABEL: Symbol = sym::label;\n+const CFG: Symbol = sym::cfg;\n \n // Base and Extra labels to build up the labels\n \n@@ -591,7 +592,7 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> as\n // nodes.\n pub struct FindAllAttrs<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    attr_names: Vec<&'static str>,\n+    attr_names: Vec<Symbol>,\n     found_attrs: Vec<&'tcx Attribute>,\n }\n "}, {"sha": "c5ac8860ccd9b079db0146dc386df0c92fa398f8", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -230,7 +230,7 @@ impl BoxedResolver {\n \n pub struct PluginInfo {\n     syntax_exts: Vec<NamedSyntaxExtension>,\n-    attributes: Vec<(String, AttributeType)>,\n+    attributes: Vec<(Symbol, AttributeType)>,\n }\n \n pub fn register_plugins<'a>("}, {"sha": "e9f2f0410d440bb7889e27bcdc0eee798dfc3d52", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -4,6 +4,7 @@ use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n use syntax::attr;\n+use syntax::symbol::sym;\n \n pub fn find<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Option<DefId> {\n     tcx.proc_macro_decls_static(LOCAL_CRATE)\n@@ -27,7 +28,7 @@ struct Finder {\n \n impl<'v> ItemLikeVisitor<'v> for Finder {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if attr::contains_name(&item.attrs, \"rustc_proc_macro_decls\") {\n+        if attr::contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n             self.decls = Some(item.hir_id);\n         }\n     }"}, {"sha": "2b1a993d1cc2c6d865922b4c88f924e48d718301", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -35,7 +35,7 @@ use syntax::mut_visit::{*, MutVisitor, visit_clobber};\n use syntax::ast::BlockCheckMode;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::source_map::{FileLoader, RealFileLoader, SourceMap};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::{self, ast, attr};\n #[cfg(not(parallel_compiler))]\n use std::{thread, panic};\n@@ -495,7 +495,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     let attr_types: Vec<config::CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n-            if a.check_name(\"crate_type\") {\n+            if a.check_name(sym::crate_type) {\n                 match a.value_str() {\n                     Some(ref n) if *n == \"rlib\" => Some(config::CrateType::Rlib),\n                     Some(ref n) if *n == \"dylib\" => Some(config::CrateType::Dylib),"}, {"sha": "af4f1b88b0fb0ac8e8e6938c545f58d8b70b3f2e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -42,7 +42,7 @@ use syntax::edition::Edition;\n use syntax::feature_gate::{AttributeGate, AttributeTemplate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n use syntax::visit::FnKind;\n@@ -207,7 +207,7 @@ impl UnsafeCode {\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n-        if attr.check_name(\"allow_internal_unsafe\") {\n+        if attr.check_name(sym::allow_internal_unsafe) {\n             self.report_unsafe(cx, attr.span, \"`allow_internal_unsafe` allows defining \\\n                                                macros using unsafe without triggering \\\n                                                the `unsafe_code` lint at their call site\");\n@@ -285,7 +285,7 @@ pub struct MissingDoc {\n impl_lint_pass!(MissingDoc => [MISSING_DOCS]);\n \n fn has_doc(attr: &ast::Attribute) -> bool {\n-    if !attr.check_name(\"doc\") {\n+    if !attr.check_name(sym::doc) {\n         return false;\n     }\n \n@@ -295,7 +295,7 @@ fn has_doc(attr: &ast::Attribute) -> bool {\n \n     if let Some(list) = attr.meta_item_list() {\n         for meta in list {\n-            if meta.check_name(\"include\") || meta.check_name(\"hidden\") {\n+            if meta.check_name(sym::include) || meta.check_name(sym::hidden) {\n                 return true;\n             }\n         }\n@@ -355,10 +355,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'_, '_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() ||\n                          attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") &&\n+            attr.check_name(sym::doc) &&\n             match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::list_contains_name(&l, \"hidden\"),\n+                Some(l) => attr::list_contains_name(&l, sym::hidden),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -723,7 +723,7 @@ impl UnusedDocComment {\n \n             let span = sugared_span.take().unwrap_or_else(|| attr.span);\n \n-            if attr.check_name(\"doc\") {\n+            if attr.check_name(sym::doc) {\n                 let mut err = cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, \"unused doc comment\");\n \n                 err.span_label(\n@@ -829,7 +829,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, \"no_mangle\") {\n+                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     for param in &generics.params {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n@@ -856,7 +856,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if attr::contains_name(&it.attrs, \"no_mangle\") {\n+                if attr::contains_name(&it.attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     let msg = \"const items should never be #[no_mangle]\";\n@@ -947,7 +947,7 @@ declare_lint_pass!(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n-        if attr.check_name(\"feature\") {\n+        if attr.check_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n                     ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n@@ -1382,7 +1382,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n             return;\n         }\n \n-        if let Some(attr) = attr::find_by_name(&it.attrs, \"rustc_test_marker\") {\n+        if let Some(attr) = attr::find_by_name(&it.attrs, sym::rustc_test_marker) {\n             cx.struct_span_lint(\n                 UNNAMEABLE_TEST_ITEMS,\n                 attr.span,"}, {"sha": "551eded9858a35021fb31d24ccf9a6bdc860f442", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -9,6 +9,7 @@ use lint::{EarlyLintPass, LintPass, LateLintPass};\n use syntax::ast;\n use syntax::attr;\n use syntax::errors::Applicability;\n+use syntax::symbol::sym;\n use syntax_pos::{BytePos, symbol::Ident, Span};\n \n #[derive(PartialEq)]\n@@ -253,7 +254,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), \"crate_name\")\n+            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n@@ -315,7 +316,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n             }\n             FnKind::ItemFn(ident, _, header, _, attrs) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n-                if header.abi != Abi::Rust && attr::contains_name(attrs, \"no_mangle\") {\n+                if header.abi != Abi::Rust && attr::contains_name(attrs, sym::no_mangle) {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", ident);\n@@ -390,7 +391,7 @@ impl NonUpperCaseGlobals {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n-            hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, \"no_mangle\") => {\n+            hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "93af7a1cd8f285a9c013daaf642c7622616d5234", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -12,7 +12,7 @@ use syntax::attr;\n use syntax::errors::Applicability;\n use syntax::feature_gate::{AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use syntax::print::pprust;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::symbol::Symbol;\n use syntax::util::parser;\n use syntax_pos::Span;\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n-                if attr.check_name(\"must_use\") {\n+                if attr.check_name(sym::must_use) {\n                     let msg = format!(\"unused {}`{}`{} that must be used\",\n                         descr_pre_path, cx.tcx.def_path_str(def_id), descr_post_path);\n                     let mut err = cx.struct_span_lint(UNUSED_MUST_USE, sp, &msg);\n@@ -243,8 +243,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n         }\n \n         let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n-        for &(ref name, ty) in plugin_attributes.iter() {\n-            if ty == AttributeType::Whitelisted && attr.check_name(&**name) {\n+        for &(name, ty) in plugin_attributes.iter() {\n+            if ty == AttributeType::Whitelisted && attr.check_name(name) {\n                 debug!(\"{:?} (plugin attr) is whitelisted with ty {:?}\", name, ty);\n                 break;\n             }"}, {"sha": "20caad70f2b57dffdefbc3b514ab28b022c22502", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -27,7 +27,7 @@ use std::{cmp, fs};\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::visit;\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -704,7 +704,7 @@ impl<'a> CrateLoader<'a> {\n         let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n-                                                          \"needs_panic_runtime\");\n+                                                          sym::needs_panic_runtime);\n \n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n@@ -898,7 +898,7 @@ impl<'a> CrateLoader<'a> {\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n-                                                      \"needs_allocator\");\n+                                                      sym::needs_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             needs_allocator = needs_allocator || data.root.needs_allocator;\n         });\n@@ -964,7 +964,7 @@ impl<'a> CrateLoader<'a> {\n         // allocator. At this point our allocator request is typically fulfilled\n         // by the standard library, denoted by the `#![default_lib_allocator]`\n         // attribute.\n-        let mut has_default = attr::contains_name(&krate.attrs, \"default_lib_allocator\");\n+        let mut has_default = attr::contains_name(&krate.attrs, sym::default_lib_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             if data.root.has_default_lib_allocator {\n                 has_default = true;\n@@ -987,7 +987,7 @@ impl<'a> CrateLoader<'a> {\n \n             impl<'ast> visit::Visitor<'ast> for Finder {\n                 fn visit_item(&mut self, i: &'ast ast::Item) {\n-                    if attr::contains_name(&i.attrs, \"global_allocator\") {\n+                    if attr::contains_name(&i.attrs, sym::global_allocator) {\n                         self.0 = true;\n                     }\n                     visit::walk_item(self, i)\n@@ -1065,7 +1065,7 @@ impl<'a> CrateLoader<'a> {\n                     }\n                     None => item.ident.name,\n                 };\n-                let dep_kind = if attr::contains_name(&item.attrs, \"no_link\") {\n+                let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n                     DepKind::UnexportedMacrosOnly\n                 } else {\n                     DepKind::Explicit"}, {"sha": "e950c2815e9b4547f60a0ecf25b4a9b0964bad76", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -29,7 +29,7 @@ use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{InternedString, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::Mark;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n@@ -841,7 +841,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                 // for other constructors correct visibilities\n                                 // were already encoded in metadata.\n                                 let attrs = self.get_item_attrs(def_id.index, sess);\n-                                if attr::contains_name(&attrs, \"non_exhaustive\") {\n+                                if attr::contains_name(&attrs, sym::non_exhaustive) {\n                                     let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n                                 }"}, {"sha": "0ac03526832b7506c969c00e20318f4008c64157", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -33,7 +33,7 @@ use std::u32;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::{self, hygiene, FileName, SourceFile, Span};\n use log::{debug, trace};\n \n@@ -469,7 +469,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let attrs = tcx.hir().krate_attrs();\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n-        let has_default_lib_allocator = attr::contains_name(&attrs, \"default_lib_allocator\");\n+        let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n@@ -496,13 +496,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            compiler_builtins: attr::contains_name(&attrs, \"compiler_builtins\"),\n-            needs_allocator: attr::contains_name(&attrs, \"needs_allocator\"),\n-            needs_panic_runtime: attr::contains_name(&attrs, \"needs_panic_runtime\"),\n-            no_builtins: attr::contains_name(&attrs, \"no_builtins\"),\n-            panic_runtime: attr::contains_name(&attrs, \"panic_runtime\"),\n-            profiler_runtime: attr::contains_name(&attrs, \"profiler_runtime\"),\n-            sanitizer_runtime: attr::contains_name(&attrs, \"sanitizer_runtime\"),\n+            compiler_builtins: attr::contains_name(&attrs, sym::compiler_builtins),\n+            needs_allocator: attr::contains_name(&attrs, sym::needs_allocator),\n+            needs_panic_runtime: attr::contains_name(&attrs, sym::needs_panic_runtime),\n+            no_builtins: attr::contains_name(&attrs, sym::no_builtins),\n+            panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n+            profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n+            sanitizer_runtime: attr::contains_name(&attrs, sym::sanitizer_runtime),\n \n             crate_deps,\n             dylib_dependency_formats,"}, {"sha": "cd5951f0e0e3c26f5d22ce7b97510149d6350b60", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -2,6 +2,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n+use syntax::symbol::sym;\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n     let mut collector = Collector {\n@@ -37,7 +38,7 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n         }\n \n         // First, add all of the custom #[link_args] attributes\n-        for m in it.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n+        for m in it.attrs.iter().filter(|a| a.check_name(sym::link_args)) {\n             if let Some(linkarg) = m.value_str() {\n                 self.add_link_args(&linkarg.as_str());\n             }"}, {"sha": "3e7e740a15c04fc0b43c85d04367fb598b11abc2", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -8,7 +8,7 @@ use rustc_target::spec::abi::Abi;\n use syntax::attr;\n use syntax::source_map::Span;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, struct_span_err};\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n         }\n \n         // Process all of the #[link(..)]-style arguments\n-        for m in it.attrs.iter().filter(|a| a.check_name(\"link\")) {\n+        for m in it.attrs.iter().filter(|a| a.check_name(sym::link)) {\n             let items = match m.meta_item_list() {\n                 Some(item) => item,\n                 None => continue,\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n             let mut kind_specified = false;\n \n             for item in items.iter() {\n-                if item.check_name(\"kind\") {\n+                if item.check_name(sym::kind) {\n                     kind_specified = true;\n                     let kind = match item.value_str() {\n                         Some(name) => name,\n@@ -81,9 +81,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                             cstore::NativeUnknown\n                         }\n                     };\n-                } else if item.check_name(\"name\") {\n+                } else if item.check_name(sym::name) {\n                     lib.name = item.value_str();\n-                } else if item.check_name(\"cfg\") {\n+                } else if item.check_name(sym::cfg) {\n                     let cfg = match item.meta_item_list() {\n                         Some(list) => list,\n                         None => continue, // skip like historical compilers\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                     } else {\n                         self.tcx.sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n                     }\n-                } else if item.check_name(\"wasm_import_module\") {\n+                } else if item.check_name(sym::wasm_import_module) {\n                     match item.value_str() {\n                         Some(s) => lib.wasm_import_module = Some(s),\n                         None => {\n@@ -156,15 +156,15 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n         }\n         if lib.cfg.is_some() && !self.tcx.features().link_cfg {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"link_cfg\",\n+                                           sym::link_cfg,\n                                            span.unwrap(),\n                                            GateIssue::Language,\n                                            \"is feature gated\");\n         }\n         if lib.kind == cstore::NativeStaticNobundle &&\n            !self.tcx.features().static_nobundle {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"static_nobundle\",\n+                                           sym::static_nobundle,\n                                            span.unwrap_or_else(|| syntax_pos::DUMMY_SP),\n                                            GateIssue::Language,\n                                            \"kind=\\\"static-nobundle\\\" is feature gated\");"}, {"sha": "1068305a1134c2b6b5f936ab9b3bd5f3a12aceac", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -20,6 +20,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n use syntax::source_map::CompilerDesugaringKind;\n+use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::{MirBorrowckCtxt};\n@@ -1839,7 +1840,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })\n         ) = place {\n             let attrs = self.infcx.tcx.get_attrs(*def_id);\n-            let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n+            let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n \n             debug!(\n                 \"is_place_thread_local: attrs={:?} is_thread_local={:?}\","}, {"sha": "fa490c108c8965f647caaa8a6c7509834d45fc14", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -20,6 +20,7 @@ use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n+use syntax::symbol::sym;\n \n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n@@ -280,7 +281,7 @@ fn dump_annotation<'a, 'gcx, 'tcx>(\n ) {\n     let tcx = infcx.tcx;\n     let base_def_id = tcx.closure_base_def_id(mir_def_id);\n-    if !tcx.has_attr(base_def_id, \"rustc_regions\") {\n+    if !tcx.has_attr(base_def_id, sym::rustc_regions) {\n         return;\n     }\n "}, {"sha": "a9d23a0afeabcc3a6ef79a0fd9ddd1ccea0ac1ad", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1,4 +1,5 @@\n use syntax::ast::{self, MetaItem};\n+use syntax::symbol::{Symbol, sym};\n \n use rustc_data_structures::bit_set::{BitSet, BitSetOperator, HybridBitSet};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -100,9 +101,9 @@ where\n     fn propagate(&mut self) { self.flow_state.propagate(); }\n }\n \n-pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n+pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Option<MetaItem> {\n     for attr in attrs {\n-        if attr.check_name(\"rustc_mir\") {\n+        if attr.check_name(sym::rustc_mir) {\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n                 match item.meta_item() {\n@@ -158,10 +159,8 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n             return None;\n         };\n \n-        let print_preflow_to =\n-            name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n-        let print_postflow_to =\n-            name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n+        let print_preflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_preflow);\n+        let print_postflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_postflow);\n \n         let mut mbcx = DataflowBuilder {\n             def_id,"}, {"sha": "e8070b21bb8c7d9e0350fc244b391ca9439dae6a", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::subst::{Kind, InternalSubsts};\n use rustc::ty::layout::VariantIdx;\n use syntax::ast;\n use syntax::attr;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use rustc::hir;\n use crate::hair::constant::{lit_to_const, LitToConstError};\n \n@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are codegened in.\n-        let mut check_overflow = attr::contains_name(attrs, \"rustc_inherit_overflow_checks\");\n+        let mut check_overflow = attr::contains_name(attrs, sym::rustc_inherit_overflow_checks);\n \n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();"}, {"sha": "0576bb53d8f4219268ff2e1eb02dd97abe500723", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -27,6 +27,7 @@ use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n@@ -978,7 +979,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatternKind::Wild\n             }\n-            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 let path = self.tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n@@ -990,7 +991,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Wild\n             }\n             ty::Ref(_, ty::TyS { sty: ty::Adt(adt_def, _), .. }, _)\n-            if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n                 // would be wrong. Returnging `PatternKind::Wild` is not technically correct.\n                 let path = self.tcx.def_path_str(adt_def.did);"}, {"sha": "2512525b4bb7e56ffff5caf4384f65870625d77d", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -2,6 +2,7 @@ use rustc::ty::{self, Ty, TypeAndMut};\n use rustc::ty::layout::{self, TyLayout, Size};\n use rustc::ty::adjustment::{PointerCast};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n+use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n@@ -76,9 +77,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n-                        if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n-                            bug!(\"reifying a fn ptr that requires \\\n-                                    const arguments\");\n+                        if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n+                            bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n                         let instance: EvalResult<'tcx, _> = ty::Instance::resolve(\n                             *self.tcx,"}, {"sha": "fab07a2290eb5a31efc5bebf8a33aede8a6c7269", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -12,7 +12,7 @@ use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSA\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n \n use std::ops::Bound;\n \n@@ -612,7 +612,7 @@ fn report_unused_unsafe(tcx: TyCtxt<'_, '_, '_>,\n fn builtin_derive_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     debug!(\"builtin_derive_def_id({:?})\", def_id);\n     if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-        if tcx.has_attr(impl_def_id, \"automatically_derived\") {\n+        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n             debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n             Some(impl_def_id)\n         } else {"}, {"sha": "579f75ba516571a9ece7da2a60285c10efd77191", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n use syntax::ast::LitKind;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n@@ -380,8 +381,8 @@ impl Qualif for IsNotPromotable {\n \n                 !allowed ||\n                     cx.tcx.get_attrs(def_id).iter().any(\n-                        |attr| attr.check_name(\"thread_local\"\n-                    ))\n+                        |attr| attr.check_name(sym::thread_local)\n+                    )\n             }\n         }\n     }\n@@ -939,7 +940,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 if self.tcx\n                        .get_attrs(def_id)\n                        .iter()\n-                       .any(|attr| attr.check_name(\"thread_local\")) {\n+                       .any(|attr| attr.check_name(sym::thread_local)) {\n                     if self.mode != Mode::Fn {\n                         span_err!(self.tcx.sess, self.span, E0625,\n                                   \"thread-local statics cannot be \\\n@@ -994,7 +995,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 if let ty::RawPtr(_) = base_ty.sty {\n                                     if !self.tcx.features().const_raw_ptr_deref {\n                                         emit_feature_err(\n-                                            &self.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n+                                            &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n                                             self.span, GateIssue::Language,\n                                             &format!(\n                                                 \"dereferencing raw pointers in {}s is unstable\",\n@@ -1018,7 +1019,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     Mode::ConstFn => {\n                                         if !self.tcx.features().const_fn_union {\n                                             emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, \"const_fn_union\",\n+                                                &self.tcx.sess.parse_sess, sym::const_fn_union,\n                                                 self.span, GateIssue::Language,\n                                                 \"unions in const fn are unstable\",\n                                             );\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                             // in const fn and constants require the feature gate\n                             // FIXME: make it unsafe inside const fn and constants\n                             emit_feature_err(\n-                                &self.tcx.sess.parse_sess, \"const_raw_ptr_to_usize_cast\",\n+                                &self.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n                                 self.span, GateIssue::Language,\n                                 &format!(\n                                     \"casting pointers to integers in {}s is unstable\",\n@@ -1149,7 +1150,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n                             &self.tcx.sess.parse_sess,\n-                            \"const_compare_raw_pointers\",\n+                            sym::const_compare_raw_pointers,\n                             self.span,\n                             GateIssue::Language,\n                             &format!(\"comparing raw pointers inside {}\", self.mode),\n@@ -1210,7 +1211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n                                             emit_feature_err(\n-                                                &self.tcx.sess.parse_sess, \"const_transmute\",\n+                                                &self.tcx.sess.parse_sess, sym::const_transmute,\n                                                 self.span, GateIssue::Language,\n                                                 &format!(\"The use of std::mem::transmute() \\\n                                                 is gated in {}s\", self.mode));\n@@ -1249,7 +1250,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                         // Don't allow panics in constants without the feature gate.\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess,\n-                                            \"const_panic\",\n+                                            sym::const_panic,\n                                             self.span,\n                                             GateIssue::Language,\n                                             &format!(\"panicking in {}s is unstable\", self.mode),\n@@ -1260,7 +1261,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n                                     // functions without the feature gate active in this crate in\n                                     // order to report a better error message than the one below.\n-                                    if !self.span.allows_unstable(&feature.as_str()) {\n+                                    if !self.span.allows_unstable(feature) {\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n                                                     self.tcx.def_path_str(def_id)));\n@@ -1592,7 +1593,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         if mode == Mode::Static {\n             // `#[thread_local]` statics don't have to be `Sync`.\n             for attr in &tcx.get_attrs(def_id)[..] {\n-                if attr.check_name(\"thread_local\") {\n+                if attr.check_name(sym::thread_local) {\n                     return;\n                 }\n             }\n@@ -1616,7 +1617,7 @@ impl MirPass for QualifyAndPromoteConstants {\n \n fn args_required_const(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| a.check_name(\"rustc_args_required_const\"))?;\n+    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n     let mut ret = FxHashSet::default();\n     for meta in attr.meta_item_list()? {\n         match meta.literal()?.node {"}, {"sha": "815821f6ff0337eb6bf72906485e398917d9d41a", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1,5 +1,6 @@\n use rustc_target::spec::abi::{Abi};\n use syntax::ast;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n@@ -27,7 +28,7 @@ impl MirPass for SanityCheck {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id();\n-        if !tcx.has_attr(def_id, \"rustc_mir\") {\n+        if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n             return;\n         } else {\n@@ -52,16 +53,16 @@ impl MirPass for SanityCheck {\n                         DefinitelyInitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n \n-        if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_init\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_inits);\n         }\n-        if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_uninit\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_uninits);\n         }\n-        if has_rustc_mir_with(&attributes, \"rustc_peek_definite_init\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_def_inits);\n         }\n-        if has_rustc_mir_with(&attributes, \"stop_after_dataflow\").is_some() {\n+        if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n     }"}, {"sha": "7adf0af31c66191d151f585a3353e47ed131af22", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::source_map::Spanned;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n@@ -565,7 +565,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, \"global_allocator\") {\n+        if attr::contains_name(&item.attrs, sym::global_allocator) {\n             self.has_global_allocator = true;\n         }\n \n@@ -676,8 +676,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n-                if attr::contains_name(&item.attrs, \"warn_directory_ownership\") {\n+                attr::first_attr_value_str_by_name(&item.attrs, sym::path);\n+                if attr::contains_name(&item.attrs, sym::warn_directory_ownership) {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n                     self.session.buffer_lint(lint, item.id, item.span, msg);"}, {"sha": "c865845b5e367e2a86344f43e83d299103f2ad58", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -12,6 +12,7 @@ use rustc::ty::ParamEnv;\n use rustc::ty::Ty;\n use rustc::ty::TyCtxt;\n use syntax::ast::Attribute;\n+use syntax::symbol::sym;\n \n pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     if tcx.features().rustc_attrs {\n@@ -32,7 +33,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n \n         if let ItemKind::Ty(..) = item.node {\n             for attr in self.tcx.get_attrs(item_def_id).iter() {\n-                if attr.check_name(\"rustc_layout\") {\n+                if attr.check_name(sym::rustc_layout) {\n                     self.dump_layout_of(item_def_id, item, attr);\n                 }\n             }"}, {"sha": "37917aaa4a80f4c2c7b39adcf6a2edee2319d60f", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -25,6 +25,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n use rustc::hir;\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n use log::debug;\n use Promotability::*;\n@@ -335,7 +336,7 @@ fn check_expr_kind<'a, 'tcx>(\n \n                     if v.in_static {\n                         for attr in &v.tcx.get_attrs(did)[..] {\n-                            if attr.check_name(\"thread_local\") {\n+                            if attr.check_name(sym::thread_local) {\n                                 debug!(\"Reference to Static(id={:?}) is unpromotable \\\n                                        due to a #[thread_local] attribute\", did);\n                                 return NotPromotable;"}, {"sha": "8259419c64aeb17d67baed9a87ce70d6e243b374", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1,6 +1,7 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n use syntax::attr;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n@@ -15,8 +16,7 @@ struct RegistrarFinder {\n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Fn(..) = item.node {\n-            if attr::contains_name(&item.attrs,\n-                                   \"plugin_registrar\") {\n+            if attr::contains_name(&item.attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.hir_id, item.span));\n             }\n         }"}, {"sha": "43eddbb653fee5b1e194b0b6ce86ab6c1d6a2d0c", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -11,6 +11,7 @@ use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::span_err;\n+use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n /// Pointer to a registrar function.\n@@ -45,7 +46,7 @@ pub fn load_plugins(sess: &Session,\n     // the feature enabled will result in an error later...\n     if sess.features_untracked().plugin {\n         for attr in &krate.attrs {\n-            if !attr.check_name(\"plugin\") {\n+            if !attr.check_name(sym::plugin) {\n                 continue;\n             }\n "}, {"sha": "913657b2934e47c9e8cb4d30f5cf669248965ac3", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -49,7 +49,7 @@ pub struct Registry<'a> {\n     pub llvm_passes: Vec<String>,\n \n     #[doc(hidden)]\n-    pub attributes: Vec<(String, AttributeType)>,\n+    pub attributes: Vec<(Symbol, AttributeType)>,\n }\n \n impl<'a> Registry<'a> {\n@@ -169,7 +169,7 @@ impl<'a> Registry<'a> {\n     /// Registered attributes will bypass the `custom_attribute` feature gate.\n     /// `Whitelisted` attributes will additionally not trigger the `unused_attribute`\n     /// lint. `CrateLevel` attributes will not be allowed on anything other than a crate.\n-    pub fn register_attribute(&mut self, name: String, ty: AttributeType) {\n+    pub fn register_attribute(&mut self, name: Symbol, ty: AttributeType) {\n         self.attributes.push((name, ty));\n     }\n }"}, {"sha": "cd21713cddf97364da7657f09c16a375b416f452", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -27,7 +27,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use syntax::attr;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n \n use std::{cmp, fmt, mem};\n@@ -260,7 +260,8 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                 ctor_vis = ty::Visibility::Restricted(\n                                     DefId::local(CRATE_DEF_INDEX));\n                                 let attrs = tcx.get_attrs(variant.def_id);\n-                                span = attr::find_by_name(&attrs, \"non_exhaustive\").unwrap().span;\n+                                span = attr::find_by_name(&attrs, sym::non_exhaustive)\n+                                    .unwrap().span;\n                                 descr = \"crate-visible\";\n                             }\n \n@@ -291,7 +292,7 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                 if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n                                     ctor_vis =\n                                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                    span = attr::find_by_name(&item.attrs, \"non_exhaustive\")\n+                                    span = attr::find_by_name(&item.attrs, sym::non_exhaustive)\n                                                 .unwrap().span;\n                                     descr = \"crate-visible\";\n                                 }"}, {"sha": "cf09e31bb6282dded7d0874b81338600f83e9b87", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -37,7 +37,7 @@ use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::span_err;\n use syntax::std_inject::injected_crate_name;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -257,7 +257,7 @@ impl<'a> Resolver<'a> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let subclass = GlobImport {\n-                    is_prelude: attr::contains_name(&item.attrs, \"prelude_import\"),\n+                    is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import_directive(\n@@ -427,7 +427,7 @@ impl<'a> Resolver<'a> {\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n                 let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n-                        attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n+                        attr::contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n                     ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n@@ -456,12 +456,12 @@ impl<'a> Resolver<'a> {\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                if attr::contains_name(&item.attrs, \"proc_macro\") ||\n-                   attr::contains_name(&item.attrs, \"proc_macro_attribute\") {\n+                if attr::contains_name(&item.attrs, sym::proc_macro) ||\n+                   attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n                     let res = Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), res.def_id());\n                     self.define(parent, ident, MacroNS, (res, vis, sp, expansion));\n                 }\n-                if let Some(attr) = attr::find_by_name(&item.attrs, \"proc_macro_derive\") {\n+                if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n                     if let Some(trait_attr) =\n                             attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                         if let Some(ident) = trait_attr.ident() {\n@@ -518,7 +518,7 @@ impl<'a> Resolver<'a> {\n \n                 let mut ctor_vis = vis;\n \n-                let has_non_exhaustive = attr::contains_name(&item.attrs, \"non_exhaustive\");\n+                let has_non_exhaustive = attr::contains_name(&item.attrs, sym::non_exhaustive);\n \n                 // If the structure is marked as non_exhaustive then lower the visibility\n                 // to within the crate.\n@@ -599,7 +599,7 @@ impl<'a> Resolver<'a> {\n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n         let mut ctor_vis = vis;\n-        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, \"non_exhaustive\");\n+        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, sym::non_exhaustive);\n         if has_non_exhaustive && vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n@@ -825,7 +825,7 @@ impl<'a> Resolver<'a> {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n-            if attr.check_name(\"macro_use\") {\n+            if attr.check_name(sym::macro_use) {\n                 if self.current_module.parent.is_some() {\n                     span_err!(self.session, item.span, E0468,\n                         \"an `extern crate` loading macros must be at the crate root\");\n@@ -908,15 +908,15 @@ impl<'a> Resolver<'a> {\n     /// Returns `true` if this attribute list contains `macro_use`.\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n-            if attr.check_name(\"macro_escape\") {\n+            if attr.check_name(sym::macro_escape) {\n                 let msg = \"macro_escape is a deprecated synonym for macro_use\";\n                 let mut err = self.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n                 } else {\n                     err.emit();\n                 }\n-            } else if !attr.check_name(\"macro_use\") {\n+            } else if !attr.check_name(sym::macro_use) {\n                 continue;\n             }\n "}, {"sha": "0dd6f378730f99511118bdfa25df5916ba4485a0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -43,7 +43,7 @@ use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n@@ -1964,7 +1964,7 @@ impl<'a> Resolver<'a> {\n             keywords::Invalid.name(),\n         );\n         let graph_root = arenas.alloc_module(ModuleData {\n-            no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n+            no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n         });\n         let mut module_map = FxHashMap::default();\n@@ -1978,9 +1978,9 @@ impl<'a> Resolver<'a> {\n             session.opts.externs.iter().map(|kv| (Ident::from_str(kv.0), Default::default()))\n                                        .collect();\n \n-        if !attr::contains_name(&krate.attrs, \"no_core\") {\n+        if !attr::contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::from_str(\"core\"), Default::default());\n-            if !attr::contains_name(&krate.attrs, \"no_std\") {\n+            if !attr::contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::from_str(\"std\"), Default::default());\n                 if session.rust_2018() {\n                     extern_prelude.insert(Ident::from_str(\"meta\"), Default::default());"}, {"sha": "62f2768888ad7eace5f64da429ce683905582d5f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -22,7 +22,7 @@ use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{\n     feature_err, is_builtin_attr_name, AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES,\n };\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::visit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -313,7 +313,8 @@ impl<'a> Resolver<'a> {\n                             if !features.rustc_attrs {\n                                 let msg = \"unless otherwise specified, attributes with the prefix \\\n                                            `rustc_` are reserved for internal compiler diagnostics\";\n-                                self.report_unknown_attribute(path.span, &name, msg, \"rustc_attrs\");\n+                                self.report_unknown_attribute(path.span, &name, msg,\n+                                                              sym::rustc_attrs);\n                             }\n                         } else if !features.custom_attribute {\n                             let msg = format!(\"The attribute `{}` is currently unknown to the \\\n@@ -323,7 +324,7 @@ impl<'a> Resolver<'a> {\n                                 path.span,\n                                 &name,\n                                 &msg,\n-                                \"custom_attribute\",\n+                                sym::custom_attribute,\n                             );\n                         }\n                     }\n@@ -345,7 +346,7 @@ impl<'a> Resolver<'a> {\n         Ok((res, self.get_macro(res)))\n     }\n \n-    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: &str) {\n+    fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: Symbol) {\n         let mut err = feature_err(\n             &self.session.parse_sess,\n             feature,\n@@ -693,7 +694,7 @@ impl<'a> Resolver<'a> {\n                 WhereToResolve::LegacyPluginHelpers => {\n                     if (use_prelude || rust_2015) &&\n                        self.session.plugin_attributes.borrow().iter()\n-                                                     .any(|(name, _)| ident.name == &**name) {\n+                                                     .any(|(name, _)| ident.name == *name) {\n                         let binding = (Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n                                        ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n@@ -1106,7 +1107,7 @@ impl<'a> Resolver<'a> {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n             let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n-            let is_macro_export = attr::contains_name(&item.attrs, \"macro_export\");\n+            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1124,7 +1125,7 @@ impl<'a> Resolver<'a> {\n                 self.define(module, ident, MacroNS,\n                             (res, vis, item.span, expansion, IsMacroExport));\n             } else {\n-                if !attr::contains_name(&item.attrs, \"rustc_doc_only_macro\") {\n+                if !attr::contains_name(&item.attrs, sym::rustc_doc_only_macro) {\n                     self.check_reserved_macro_name(ident, MacroNS);\n                 }\n                 self.unused_macros.insert(def_id);"}, {"sha": "cb2454aa4b56e3ab0aab1779b54e4ea5229db5ba", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -879,7 +879,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let mut result = String::new();\n \n         for attr in attrs {\n-            if attr.check_name(\"doc\") {\n+            if attr.check_name(sym::doc) {\n                 if let Some(val) = attr.value_str() {\n                     if attr.is_sugared_doc {\n                         result.push_str(&strip_doc_comment_decoration(&val.as_str()));\n@@ -889,10 +889,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     result.push('\\n');\n                 } else if let Some(meta_list) = attr.meta_item_list() {\n                     meta_list.into_iter()\n-                             .filter(|it| it.check_name(\"include\"))\n+                             .filter(|it| it.check_name(sym::include))\n                              .filter_map(|it| it.meta_item_list().map(|l| l.to_owned()))\n                              .flat_map(|it| it)\n-                             .filter(|meta| meta.check_name(\"contents\"))\n+                             .filter(|meta| meta.check_name(sym::contents))\n                              .filter_map(|meta| meta.value_str())\n                              .for_each(|val| {\n                                  result.push_str(&val.as_str());"}, {"sha": "580b1571e52bb1dd55bc5254ecf05e87806b9e20", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, List, TyCtxt};\n use rustc::ty::subst::{Subst, InternalSubsts};\n use syntax::ast;\n+use syntax::symbol::sym;\n \n use std::iter;\n \n@@ -640,11 +641,11 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n         for attr in attrs {\n             let mut clauses = None;\n \n-            if attr.check_name(\"rustc_dump_program_clauses\") {\n+            if attr.check_name(sym::rustc_dump_program_clauses) {\n                 clauses = Some(self.tcx.program_clauses_for(def_id));\n             }\n \n-            if attr.check_name(\"rustc_dump_env_program_clauses\") {\n+            if attr.check_name(sym::rustc_dump_env_program_clauses) {\n                 let environment = self.tcx.environment(def_id);\n                 clauses = Some(self.tcx.program_clauses_for_env(environment));\n             }"}, {"sha": "caefe1242115508ddec3ef0c70499a83e6f1ea3e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -25,6 +25,7 @@ use syntax::ast;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n@@ -802,7 +803,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             } else {\n                 \"parenthetical notation is only stable when used with `Fn`-family traits\"\n             };\n-            emit_feature_err(&self.tcx().sess.parse_sess, \"unboxed_closures\",\n+            emit_feature_err(&self.tcx().sess.parse_sess, sym::unboxed_closures,\n                              span, GateIssue::Language, msg);\n         }\n "}, {"sha": "90b2643d165bea7f2ab6e23cfacbb56ae5a53a85", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -68,6 +68,7 @@ use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n use syntax::feature_gate;\n use syntax::ptr::P;\n+use syntax::symbol::sym;\n use syntax_pos;\n \n struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -620,7 +621,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         if has_unsized_tuple_coercion && !self.tcx.features().unsized_tuple_coercion {\n             feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n-                                           \"unsized_tuple_coercion\",\n+                                           sym::unsized_tuple_coercion,\n                                            self.cause.span,\n                                            feature_gate::GateIssue::Language,\n                                            feature_gate::EXPLAIN_UNSIZED_TUPLE_COERCION);"}, {"sha": "8d68179b495c6015738344919f05b2af1a07daca", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -2,6 +2,7 @@ use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n \n+use syntax::symbol::sym;\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n@@ -197,7 +198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME? Other potential candidate methods: `as_ref` and\n                 // `as_mut`?\n-                .find(|a| a.check_name(\"rustc_conversion_suggestion\")).is_some()\n+                .find(|a| a.check_name(sym::rustc_conversion_suggestion)).is_some()\n         });\n \n         methods"}, {"sha": "a184a2daeb6ad058444e22a479ffe46999f22b00", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -123,7 +123,7 @@ use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::source_map::{DUMMY_SP, original_sp};\n-use syntax::symbol::{Symbol, LocalInternedString, keywords};\n+use syntax::symbol::{Symbol, LocalInternedString, keywords, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n@@ -1840,7 +1840,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if vs.is_empty() {\n         let attributes = tcx.get_attrs(def_id);\n-        if let Some(attr) = attr::find_by_name(&attributes, \"repr\") {\n+        if let Some(attr) = attr::find_by_name(&attributes, sym::repr) {\n             struct_span_err!(\n                 tcx.sess, attr.span, E0084,\n                 \"unsupported representation for zero-variant enum\")\n@@ -1853,7 +1853,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n         if !tcx.features().repr128 {\n             emit_feature_err(&tcx.sess.parse_sess,\n-                             \"repr128\",\n+                             sym::repr128,\n                              sp,\n                              GateIssue::Language,\n                              \"repr with 128-bit type is unstable\");\n@@ -5499,7 +5499,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       span: Span) {\n         // We're only interested in functions tagged with\n         // #[rustc_args_required_const], so ignore anything that's not.\n-        if !self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+        if !self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n             return\n         }\n "}, {"sha": "b009c8ea6dce17a3d28b22da83ac9f2eb1fab053", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -13,6 +13,7 @@ use rustc::infer::opaque_types::may_define_existential_type;\n use syntax::ast;\n use syntax::feature_gate::{self, GateIssue};\n use syntax_pos::Span;\n+use syntax::symbol::sym;\n use errors::{DiagnosticBuilder, DiagnosticId};\n \n use rustc::hir::itemlikevisit::ParItemLikeVisitor;\n@@ -796,7 +797,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                 // report error, would have worked with arbitrary_self_types\n                 feature_gate::feature_err(\n                     &fcx.tcx.sess.parse_sess,\n-                    \"arbitrary_self_types\",\n+                    sym::arbitrary_self_types,\n                     span,\n                     GateIssue::Language,\n                     &format!("}, {"sha": "ecb8e09ec2461ee918e4d6295aa84b15ae366ee1", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -16,6 +16,7 @@ use rustc::mir::interpret::ConstValue;\n use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -36,8 +37,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n-        // in the form of errors, which is used for unit tests.\n-        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, \"rustc_dump_user_substs\");\n+        // in the form of errors, which is uSymbolfor unit tests.\n+        let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n         for arg in &body.arguments {"}, {"sha": "29b4708940955d6e5a8d48153f43356bdc5d3ac2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -39,7 +39,7 @@ use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n use syntax::source_map::Spanned;\n use syntax::feature_gate;\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::{keywords, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Res, DefKind};\n@@ -750,7 +750,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n         _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n-    let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n+    let paren_sugar = tcx.has_attr(def_id, sym::rustc_paren_sugar);\n     if paren_sugar && !tcx.features().unboxed_closures {\n         let mut err = tcx.sess.struct_span_err(\n             item.span,\n@@ -765,7 +765,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n         err.emit();\n     }\n \n-    let is_marker = tcx.has_attr(def_id, \"marker\");\n+    let is_marker = tcx.has_attr(def_id, sym::marker);\n     let def_path_hash = tcx.def_path_hash(def_id);\n     let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, is_auto, is_marker, def_path_hash);\n     tcx.alloc_trait_def(def)\n@@ -2382,7 +2382,7 @@ fn from_target_feature(\n     tcx: TyCtxt<'_, '_, '_>,\n     id: DefId,\n     attr: &ast::Attribute,\n-    whitelist: &FxHashMap<String, Option<String>>,\n+    whitelist: &FxHashMap<String, Option<Symbol>>,\n     target_features: &mut Vec<Symbol>,\n ) {\n     let list = match attr.meta_item_list() {\n@@ -2392,7 +2392,7 @@ fn from_target_feature(\n     let rust_features = tcx.features();\n     for item in list {\n         // Only `enable = ...` is accepted in the meta item list\n-        if !item.check_name(\"enable\") {\n+        if !item.check_name(sym::enable) {\n             let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n                        currently\";\n             tcx.sess.span_err(item.span(), &msg);\n@@ -2435,29 +2435,29 @@ fn from_target_feature(\n             };\n \n             // Only allow features whose feature gates have been enabled\n-            let allowed = match feature_gate.as_ref().map(|s| &**s) {\n-                Some(\"arm_target_feature\") => rust_features.arm_target_feature,\n-                Some(\"aarch64_target_feature\") => rust_features.aarch64_target_feature,\n-                Some(\"hexagon_target_feature\") => rust_features.hexagon_target_feature,\n-                Some(\"powerpc_target_feature\") => rust_features.powerpc_target_feature,\n-                Some(\"mips_target_feature\") => rust_features.mips_target_feature,\n-                Some(\"avx512_target_feature\") => rust_features.avx512_target_feature,\n-                Some(\"mmx_target_feature\") => rust_features.mmx_target_feature,\n-                Some(\"sse4a_target_feature\") => rust_features.sse4a_target_feature,\n-                Some(\"tbm_target_feature\") => rust_features.tbm_target_feature,\n-                Some(\"wasm_target_feature\") => rust_features.wasm_target_feature,\n-                Some(\"cmpxchg16b_target_feature\") => rust_features.cmpxchg16b_target_feature,\n-                Some(\"adx_target_feature\") => rust_features.adx_target_feature,\n-                Some(\"movbe_target_feature\") => rust_features.movbe_target_feature,\n-                Some(\"rtm_target_feature\") => rust_features.rtm_target_feature,\n-                Some(\"f16c_target_feature\") => rust_features.f16c_target_feature,\n+            let allowed = match feature_gate.as_ref().map(|s| *s) {\n+                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n+                Some(sym::aarch64_target_feature) => rust_features.aarch64_target_feature,\n+                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n+                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n+                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n+                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n+                Some(sym::mmx_target_feature) => rust_features.mmx_target_feature,\n+                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n+                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n+                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n+                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n+                Some(sym::adx_target_feature) => rust_features.adx_target_feature,\n+                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n+                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n+                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n                 Some(name) => bug!(\"unknown target feature gate {}\", name),\n                 None => true,\n             };\n             if !allowed && id.is_local() {\n                 feature_gate::emit_feature_err(\n                     &tcx.sess.parse_sess,\n-                    feature_gate.as_ref().unwrap(),\n+                    feature_gate.unwrap(),\n                     item.span(),\n                     feature_gate::GateIssue::Language,\n                     &format!(\"the target feature `{}` is currently unstable\", feature),\n@@ -2512,13 +2512,13 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n \n     let mut inline_span = None;\n     for attr in attrs.iter() {\n-        if attr.check_name(\"cold\") {\n+        if attr.check_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.check_name(\"allocator\") {\n+        } else if attr.check_name(sym::allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.check_name(\"unwind\") {\n+        } else if attr.check_name(sym::unwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::UNWIND;\n-        } else if attr.check_name(\"ffi_returns_twice\") {\n+        } else if attr.check_name(sym::ffi_returns_twice) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n@@ -2530,21 +2530,21 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                     \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n                 ).emit();\n             }\n-        } else if attr.check_name(\"rustc_allocator_nounwind\") {\n+        } else if attr.check_name(sym::rustc_allocator_nounwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n-        } else if attr.check_name(\"naked\") {\n+        } else if attr.check_name(sym::naked) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.check_name(\"no_mangle\") {\n+        } else if attr.check_name(sym::no_mangle) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.check_name(\"rustc_std_internal_symbol\") {\n+        } else if attr.check_name(sym::rustc_std_internal_symbol) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.check_name(\"no_debug\") {\n+        } else if attr.check_name(sym::no_debug) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_DEBUG;\n-        } else if attr.check_name(\"used\") {\n+        } else if attr.check_name(sym::used) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-        } else if attr.check_name(\"thread_local\") {\n+        } else if attr.check_name(sym::thread_local) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.check_name(\"export_name\") {\n+        } else if attr.check_name(sym::export_name) {\n             if let Some(s) = attr.value_str() {\n                 if s.as_str().contains(\"\\0\") {\n                     // `#[export_name = ...]` will be converted to a null-terminated string,\n@@ -2558,7 +2558,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 }\n                 codegen_fn_attrs.export_name = Some(s);\n             }\n-        } else if attr.check_name(\"target_feature\") {\n+        } else if attr.check_name(sym::target_feature) {\n             if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n                 let msg = \"#[target_feature(..)] can only be applied to \\\n                            `unsafe` function\";\n@@ -2571,11 +2571,11 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 &whitelist,\n                 &mut codegen_fn_attrs.target_features,\n             );\n-        } else if attr.check_name(\"linkage\") {\n+        } else if attr.check_name(sym::linkage) {\n             if let Some(val) = attr.value_str() {\n                 codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n             }\n-        } else if attr.check_name(\"link_section\") {\n+        } else if attr.check_name(sym::link_section) {\n             if let Some(val) = attr.value_str() {\n                 if val.as_str().bytes().any(|b| b == 0) {\n                     let msg = format!(\n@@ -2588,7 +2588,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                     codegen_fn_attrs.link_section = Some(val);\n                 }\n             }\n-        } else if attr.check_name(\"link_name\") {\n+        } else if attr.check_name(sym::link_name) {\n             codegen_fn_attrs.link_name = attr.value_str();\n         }\n     }\n@@ -2613,9 +2613,9 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                         \"expected one argument\"\n                     );\n                     InlineAttr::None\n-                } else if list_contains_name(&items[..], \"always\") {\n+                } else if list_contains_name(&items[..], sym::always) {\n                     InlineAttr::Always\n-                } else if list_contains_name(&items[..], \"never\") {\n+                } else if list_contains_name(&items[..], sym::never) {\n                     InlineAttr::Never\n                 } else {\n                     span_err!(\n@@ -2649,9 +2649,9 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 if items.len() != 1 {\n                     err(attr.span, \"expected one argument\");\n                     OptimizeAttr::None\n-                } else if list_contains_name(&items[..], \"size\") {\n+                } else if list_contains_name(&items[..], sym::size) {\n                     OptimizeAttr::Size\n-                } else if list_contains_name(&items[..], \"speed\") {\n+                } else if list_contains_name(&items[..], sym::speed) {\n                     OptimizeAttr::Speed\n                 } else {\n                     err(items[0].span(), \"invalid argument\");"}, {"sha": "a6b5b99982ec6b5ba8a4cb72b36446268a17999c", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -5,6 +5,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n+use syntax::symbol::sym;\n \n mod explicit;\n mod implicit_infer;\n@@ -40,7 +41,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n                     .map(|p| *p)\n                     .unwrap_or(&[]);\n \n-                if tcx.has_attr(item_def_id, \"rustc_outlives\") {\n+                if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|out_pred| match out_pred {"}, {"sha": "54fd4fad1d1956c95284e8a2a5287f8c2c8008ac", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n+use syntax::symbol::sym;\n \n pub fn test_inferred_outlives<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir()\n@@ -18,7 +19,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'a, 'tcx> {\n \n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, \"rustc_outlives\") {\n+        if self.tcx.has_attr(item_def_id, sym::rustc_outlives) {\n             let inferred_outlives_of = self.tcx.inferred_outlives_of(item_def_id);\n             span_err!(\n                 self.tcx.sess,"}, {"sha": "b5195826b8631a4a6278660107442ff309c14590", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n+use syntax::symbol::sym;\n \n pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir().krate().visit_all_item_likes(&mut VarianceTest { tcx });\n@@ -16,7 +17,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n \n         // For unit testing: check for a special \"rustc_variance\"\n         // attribute and report an error with various results if found.\n-        if self.tcx.has_attr(item_def_id, \"rustc_variance\") {\n+        if self.tcx.has_attr(item_def_id, sym::rustc_variance) {\n             let variances_of = self.tcx.variances_of(item_def_id);\n             span_err!(self.tcx.sess,\n                       item.span,"}, {"sha": "15108a7dbb91c392836ea59e926961ce55f79721", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -4,6 +4,7 @@ use std::iter::once;\n \n use syntax::ast;\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -186,7 +187,7 @@ pub fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n     let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n-    let is_spotlight = load_attrs(cx, did).has_doc_flag(\"spotlight\");\n+    let is_spotlight = load_attrs(cx, did).has_doc_flag(sym::spotlight);\n     let is_auto = cx.tcx.trait_is_auto(did);\n     clean::Trait {\n         auto: auto_trait,"}, {"sha": "6790b13dbf8d58fa79ed4185b353a44191f64a35", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -32,6 +32,7 @@ use syntax::ext::base::MacroKind;\n use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n+use syntax::symbol::{Symbol, sym};\n use syntax::symbol::InternedString;\n use syntax_pos::{self, Pos, FileName};\n \n@@ -170,7 +171,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     // `compiler_builtins` should be masked too, but we can't apply\n                     // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n                     if it.is_extern_crate()\n-                        && (it.attrs.has_doc_flag(\"masked\")\n+                        && (it.attrs.has_doc_flag(sym::masked)\n                             || self.cx.tcx.is_compiler_builtins(it.def_id.krate))\n                     {\n                         masked_crates.insert(it.def_id.krate);\n@@ -261,9 +262,9 @@ impl Clean<ExternalCrate> for CrateNum {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut prim = None;\n-                for attr in attrs.lists(\"doc\") {\n+                for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(\"primitive\") {\n+                        if attr.check_name(sym::primitive) {\n                             prim = PrimitiveType::from_str(&v.as_str());\n                             if prim.is_some() {\n                                 break;\n@@ -305,9 +306,9 @@ impl Clean<ExternalCrate> for CrateNum {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut keyword = None;\n-                for attr in attrs.lists(\"doc\") {\n+                for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n-                        if attr.check_name(\"keyword\") {\n+                        if attr.check_name(sym::keyword) {\n                             keyword = Keyword::from_str(&v.as_str()).ok()\n                                                                     .map(|x| x.name().to_string());\n                             if keyword.is_some() {\n@@ -501,7 +502,7 @@ impl Item {\n \n     pub fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter()\n-            .any(|a| a.check_name(\"non_exhaustive\"))\n+            .any(|a| a.check_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n@@ -669,7 +670,7 @@ impl Clean<Item> for doctree::Module {\n pub struct ListAttributesIter<'a> {\n     attrs: slice::Iter<'a, ast::Attribute>,\n     current_list: vec::IntoIter<ast::NestedMetaItem>,\n-    name: &'a str\n+    name: Symbol,\n }\n \n impl<'a> Iterator for ListAttributesIter<'a> {\n@@ -702,11 +703,11 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n \n pub trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a>;\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a>;\n }\n \n impl AttributesExt for [ast::Attribute] {\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a> {\n         ListAttributesIter {\n             attrs: self.iter(),\n             current_list: Vec::new().into_iter(),\n@@ -717,11 +718,11 @@ impl AttributesExt for [ast::Attribute] {\n \n pub trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `Word`\n-    fn has_word(self, word: &str) -> bool;\n+    fn has_word(self, word: Symbol) -> bool;\n }\n \n impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n-    fn has_word(self, word: &str) -> bool {\n+    fn has_word(self, word: Symbol) -> bool {\n         self.into_iter().any(|attr| attr.is_word() && attr.check_name(word))\n     }\n }\n@@ -803,7 +804,7 @@ impl Attributes {\n         if let ast::MetaItemKind::List(ref nmis) = mi.node {\n             if nmis.len() == 1 {\n                 if let MetaItem(ref cfg_mi) = nmis[0] {\n-                    if cfg_mi.check_name(\"cfg\") {\n+                    if cfg_mi.check_name(sym::cfg) {\n                         if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n                             if cfg_nmis.len() == 1 {\n                                 if let MetaItem(ref content_mi) = cfg_nmis[0] {\n@@ -827,7 +828,7 @@ impl Attributes {\n     {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n-                if meta.check_name(\"include\") {\n+                if meta.check_name(sym::include) {\n                     // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n                     // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n                     // look for that instead\n@@ -836,11 +837,11 @@ impl Attributes {\n                         let mut contents: Option<String> = None;\n \n                         for it in list {\n-                            if it.check_name(\"file\") {\n+                            if it.check_name(sym::file) {\n                                 if let Some(name) = it.value_str() {\n                                     filename = Some(name.to_string());\n                                 }\n-                            } else if it.check_name(\"contents\") {\n+                            } else if it.check_name(sym::contents) {\n                                 if let Some(docs) = it.value_str() {\n                                     contents = Some(docs.to_string());\n                                 }\n@@ -860,9 +861,9 @@ impl Attributes {\n         })\n     }\n \n-    pub fn has_doc_flag(&self, flag: &str) -> bool {\n+    pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n-            if !attr.check_name(\"doc\") { continue; }\n+            if !attr.check_name(sym::doc) { continue; }\n \n             if let Some(items) = attr.meta_item_list() {\n                 if items.iter().filter_map(|i| i.meta_item()).any(|it| it.check_name(flag)) {\n@@ -883,7 +884,7 @@ impl Attributes {\n \n         let other_attrs = attrs.iter().filter_map(|attr| {\n             attr.with_desugared_doc(|attr| {\n-                if attr.check_name(\"doc\") {\n+                if attr.check_name(sym::doc) {\n                     if let Some(mi) = attr.meta() {\n                         if let Some(value) = mi.value_str() {\n                             // Extracted #[doc = \"...\"]\n@@ -925,8 +926,8 @@ impl Attributes {\n \n         // treat #[target_feature(enable = \"feat\")] attributes as if they were\n         // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n-        for attr in attrs.lists(\"target_feature\") {\n-            if attr.check_name(\"enable\") {\n+        for attr in attrs.lists(sym::target_feature) {\n+            if attr.check_name(sym::enable) {\n                 if let Some(feat) = attr.value_str() {\n                     let meta = attr::mk_name_value_item_str(Ident::from_str(\"target_feature\"),\n                                                             dummy_spanned(feat));\n@@ -938,7 +939,7 @@ impl Attributes {\n         }\n \n         let inner_docs = attrs.iter()\n-                              .filter(|a| a.check_name(\"doc\"))\n+                              .filter(|a| a.check_name(sym::doc))\n                               .next()\n                               .map_or(true, |a| a.style == AttrStyle::Inner);\n \n@@ -1039,7 +1040,7 @@ impl Hash for Attributes {\n }\n \n impl AttributesExt for Attributes {\n-    fn lists<'a>(&'a self, name: &'a str) -> ListAttributesIter<'a> {\n+    fn lists<'a>(&'a self, name: Symbol) -> ListAttributesIter<'a> {\n         self.other_attrs.lists(name)\n     }\n }\n@@ -2133,7 +2134,7 @@ pub struct Trait {\n impl Clean<Item> for doctree::Trait {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n-        let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n+        let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: attrs,\n@@ -3893,8 +3894,8 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n-            a.check_name(\"doc\") && match a.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, \"inline\"),\n+            a.check_name(sym::doc) && match a.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym::inline),\n                 None => false,\n             }\n         });\n@@ -3935,15 +3936,15 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let mut denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n-            a.check_name(\"doc\") && match a.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n-                           attr::list_contains_name(&l, \"hidden\"),\n+            a.check_name(sym::doc) && match a.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym::no_inline) ||\n+                           attr::list_contains_name(&l, sym::hidden),\n                 None => false,\n             }\n         });\n         // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n         // crate in Rust 2018+\n-        let please_inline = self.attrs.lists(\"doc\").has_word(\"inline\");\n+        let please_inline = self.attrs.lists(sym::doc).has_word(sym::inline);\n         let path = self.path.clean(cx);\n         let inner = if self.glob {\n             if !denied {"}, {"sha": "1b099fbd91d1ed27c3ed0f220bb1cdcae018d592", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -18,6 +18,7 @@ use rustc_target::spec::TargetTriple;\n use syntax::source_map;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n+use syntax::symbol::sym;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n use parking_lot::ReentrantMutex;\n@@ -415,7 +416,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n             // Process all of the crate attributes, extracting plugin metadata along\n             // with the passes which we are supposed to run.\n-            for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n+            for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n                 let diag = ctxt.sess().diagnostic();\n \n                 let name = attr.name_or_empty();"}, {"sha": "cbaa911eccca5d7256ff81bc5e919a3c2f9c1dca", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -50,6 +50,7 @@ use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::FileName;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::sym;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n@@ -571,7 +572,7 @@ pub fn run(mut krate: clean::Crate,\n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n-        for attr in attrs.lists(\"doc\") {\n+        for attr in attrs.lists(sym::doc) {\n             match (attr.name_or_empty().get(), attr.value_str()) {\n                 (\"html_favicon_url\", Some(s)) => {\n                     scx.layout.favicon = s.to_string();\n@@ -1388,8 +1389,8 @@ fn extern_location(e: &clean::ExternalCrate, extern_url: Option<&str>, dst: &Pat\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    e.attrs.lists(\"doc\")\n-     .filter(|a| a.check_name(\"html_root_url\"))\n+    e.attrs.lists(sym::doc)\n+     .filter(|a| a.check_name(sym::html_root_url))\n      .filter_map(|a| a.value_str())\n      .map(|url| {\n         let mut url = url.to_string();\n@@ -1779,8 +1780,8 @@ impl<'a> Cache {\n             let path = self.paths.get(&item.def_id)\n                                  .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n                                  .unwrap_or(\"std\".to_owned());\n-            for alias in item.attrs.lists(\"doc\")\n-                                   .filter(|a| a.check_name(\"alias\"))\n+            for alias in item.attrs.lists(sym::doc)\n+                                   .filter(|a| a.check_name(sym::alias))\n                                    .filter_map(|a| a.value_str()\n                                                     .map(|s| s.to_string().replace(\"\\\"\", \"\")))\n                                    .filter(|v| !v.is_empty())"}, {"sha": "4ee09f7096b6163a90162d7057085d80b3aa658f", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -5,6 +5,7 @@ use crate::passes::Pass;\n \n use syntax::attr;\n use syntax_pos::FileName;\n+use syntax::symbol::sym;\n \n use std::collections::BTreeMap;\n use std::ops;\n@@ -131,7 +132,7 @@ impl fold::DocFolder for CoverageCalculator {\n                 return Some(i);\n             }\n             clean::ImplItem(ref impl_)\n-                if attr::contains_name(&i.attrs.other_attrs, \"automatically_derived\")\n+                if attr::contains_name(&i.attrs.other_attrs, sym::automatically_derived)\n                     || impl_.synthetic || impl_.blanket_impl.is_some() =>\n             {\n                 // built-in derives get the `#[automatically_derived]` attribute, and"}, {"sha": "70cd4b72199bca2f73a97531f38fd02c9201032b", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -5,6 +5,7 @@ use super::Pass;\n \n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::def_id::DefId;\n+use syntax::symbol::sym;\n \n pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     name: \"collect-trait-impls\",\n@@ -68,7 +69,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n             inline::build_impl(cx, def_id, &mut new_items);\n \n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !cx.tcx.get_attrs(def_id).lists(\"doc\").has_word(\"hidden\") {\n+            if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n                 let self_ty = cx.tcx.type_of(def_id);\n                 let impls = get_auto_trait_and_blanket_impls(cx, self_ty, def_id);\n                 let mut renderinfo = cx.renderinfo.borrow_mut();\n@@ -154,7 +155,7 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n-            if !self.cx.tcx.get_attrs(i.def_id).lists(\"doc\").has_word(\"hidden\") {\n+            if !self.cx.tcx.get_attrs(i.def_id).lists(sym::doc).has_word(sym::hidden) {\n                 self.impls.extend(get_auto_trait_and_blanket_impls(\n                     self.cx,\n                     self.cx.tcx.type_of(i.def_id),"}, {"sha": "da8977544f64bc17da8a968c0252ad2f03581607", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1,5 +1,6 @@\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n+use syntax::symbol::sym;\n \n use crate::clean::{self, AttributesExt, NestedAttributesExt};\n use crate::clean::Item;\n@@ -37,7 +38,7 @@ struct Stripper<'a> {\n \n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if i.attrs.lists(\"doc\").has_word(\"hidden\") {\n+        if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n             debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n             match i.inner {"}, {"sha": "e40dbe52ffe6423ecb9e259e7bfcd8b931a98088", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -11,10 +11,6 @@ use syntax::ast;\n use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n-use tempfile::Builder as TempFileBuilder;\n-use testing;\n-\n use std::env;\n use std::io::prelude::*;\n use std::io;\n@@ -23,6 +19,10 @@ use std::path::PathBuf;\n use std::process::Command;\n use std::str;\n use std::sync::{Arc, Mutex};\n+use syntax::symbol::sym;\n+use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n+use tempfile::Builder as TempFileBuilder;\n+use testing;\n \n use crate::clean::Attributes;\n use crate::config::Options;\n@@ -137,17 +137,17 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     };\n \n     let test_attrs: Vec<_> = krate.attrs.iter()\n-        .filter(|a| a.check_name(\"doc\"))\n+        .filter(|a| a.check_name(sym::doc))\n         .flat_map(|a| a.meta_item_list().unwrap_or_else(Vec::new))\n-        .filter(|a| a.check_name(\"test\"))\n+        .filter(|a| a.check_name(sym::test))\n         .collect();\n     let attrs = test_attrs.iter().flat_map(|a| a.meta_item_list().unwrap_or(&[]));\n \n     for attr in attrs {\n-        if attr.check_name(\"no_crate_inject\") {\n+        if attr.check_name(sym::no_crate_inject) {\n             opts.no_crate_inject = true;\n         }\n-        if attr.check_name(\"attr\") {\n+        if attr.check_name(sym::attr) {\n             if let Some(l) = attr.meta_item_list() {\n                 for item in l {\n                     opts.attrs.push(pprust::meta_list_item_to_string(item));"}, {"sha": "eb9de43e388618ab67736d4812da305bf3832817", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -10,6 +10,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::MacroKind;\n use syntax::source_map::Spanned;\n+use syntax::symbol::sym;\n use syntax_pos::{self, Span};\n \n use std::mem;\n@@ -165,11 +166,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     body: hir::BodyId) {\n         debug!(\"Visiting fn\");\n         let macro_kind = item.attrs.iter().filter_map(|a| {\n-            if a.check_name(\"proc_macro\") {\n+            if a.check_name(sym::proc_macro) {\n                 Some(MacroKind::Bang)\n-            } else if a.check_name(\"proc_macro_derive\") {\n+            } else if a.check_name(sym::proc_macro_derive) {\n                 Some(MacroKind::Derive)\n-            } else if a.check_name(\"proc_macro_attribute\") {\n+            } else if a.check_name(sym::proc_macro_attribute) {\n                 Some(MacroKind::Attr)\n             } else {\n                 None\n@@ -178,7 +179,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         match macro_kind {\n             Some(kind) => {\n                 let name = if kind == MacroKind::Derive {\n-                    item.attrs.lists(\"proc_macro_derive\")\n+                    item.attrs.lists(sym::proc_macro_derive)\n                               .filter_map(|mi| mi.ident())\n                               .next()\n                               .expect(\"proc-macro derives require a name\")\n@@ -188,8 +189,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n \n                 let mut helpers = Vec::new();\n-                for mi in item.attrs.lists(\"proc_macro_derive\") {\n-                    if !mi.check_name(\"attributes\") {\n+                for mi in item.attrs.lists(sym::proc_macro_derive) {\n+                    if !mi.check_name(sym::attributes) {\n                         continue;\n                     }\n \n@@ -274,7 +275,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.hir().attrs_by_hir_id(node).lists(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.hir().attrs_by_hir_id(node)\n+                    .lists(sym::doc).has_word(sym::hidden) {\n                     return true;\n                 }\n                 if node == hir::CRATE_HIR_ID {\n@@ -295,16 +297,16 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         let use_attrs = tcx.hir().attrs_by_hir_id(id);\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n-        let is_no_inline = use_attrs.lists(\"doc\").has_word(\"no_inline\") ||\n-                           use_attrs.lists(\"doc\").has_word(\"hidden\");\n+        let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline) ||\n+                           use_attrs.lists(sym::doc).has_word(sym::hidden);\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n         if !res_did.is_local() && !is_no_inline {\n             let attrs = clean::inline::load_attrs(self.cx, res_did);\n-            let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n+            let self_is_hidden = attrs.lists(sym::doc).has_word(sym::hidden);\n             match res {\n                 Res::Def(DefKind::Trait, did) |\n                 Res::Def(DefKind::Struct, did) |\n@@ -432,8 +434,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if item.vis.node.is_pub() && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n-                            Some(ref list) if item.check_name(\"doc\") => {\n-                                list.iter().any(|i| i.check_name(\"inline\"))\n+                            Some(ref list) if item.check_name(sym::doc) => {\n+                                list.iter().any(|i| i.check_name(sym::inline))\n                             }\n                             _ => false,\n                         }"}, {"sha": "2547e3a06e9efbbe71b1e309c23cc9ecb1679fe0", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -3,6 +3,7 @@ use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty::Visibility;\n use rustc::util::nodemap::FxHashSet;\n+use syntax::symbol::sym;\n \n use std::cell::RefMut;\n \n@@ -42,7 +43,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n     // Updates node level and returns the updated level\n     fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let is_hidden = self.cx.tcx.get_attrs(did).lists(\"doc\").has_word(\"hidden\");\n+        let is_hidden = self.cx.tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden);\n \n         let old_level = self.access_levels.map.get(&did).cloned();\n         // Accessibility levels can only grow"}, {"sha": "a8310c48b96270ca2e75260fd7ecd6cb7964c9c3", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -5,7 +5,7 @@ use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n use errors::{Applicability, Handler};\n-use syntax_pos::{symbol::Symbol, Span};\n+use syntax_pos::{symbol::Symbol, symbol::sym, Span};\n \n use super::{mark_used, MetaItemKind};\n \n@@ -80,13 +80,13 @@ pub enum UnwindAttr {\n /// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n     attrs.iter().fold(None, |ia, attr| {\n-        if attr.check_name(\"unwind\") {\n+        if attr.check_name(sym::unwind) {\n             if let Some(meta) = attr.meta() {\n                 if let MetaItemKind::List(items) = meta.node {\n                     if items.len() == 1 {\n-                        if items[0].check_name(\"allowed\") {\n+                        if items[0].check_name(sym::allowed) {\n                             return Some(UnwindAttr::Allowed);\n-                        } else if items[0].check_name(\"aborts\") {\n+                        } else if items[0].check_name(sym::aborts) {\n                             return Some(UnwindAttr::Aborts);\n                         }\n                     }\n@@ -153,9 +153,9 @@ pub struct RustcDeprecation {\n \n /// Checks if `attrs` contains an attribute like `#![feature(feature_name)]`.\n /// This will not perform any \"sanity checks\" on the form of the attributes.\n-pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n+pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool {\n     attrs.iter().any(|item| {\n-        item.check_name(\"feature\") &&\n+        item.check_name(sym::feature) &&\n         item.meta_item_list().map(|list| {\n             list.iter().any(|mi| mi.is_word() && mi.check_name(feature_name))\n         }).unwrap_or(false)\n@@ -482,7 +482,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n }\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n-    super::first_attr_value_str_by_name(attrs, \"crate_name\")\n+    super::first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n@@ -593,7 +593,7 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n     let diagnostic = &sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n-        if !attr.check_name(\"deprecated\") {\n+        if !attr.check_name(sym::deprecated) {\n             continue;\n         }\n \n@@ -790,7 +790,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.check_name(\"align\") {\n+                        if meta_item.check_name(sym::align) {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.node {\n                                 recognised = true;\n                                 let mut err = struct_span_err!(diagnostic, item.span(), E0693,"}, {"sha": "c0defa1c6e019a24365b2fa7d281af01c474ddad", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -81,10 +81,7 @@ impl NestedMetaItem {\n     }\n \n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n     }\n \n@@ -154,10 +151,7 @@ impl Attribute {\n     /// attribute is marked as used.\n     ///\n     /// To check the attribute name without marking it used, use the `path` field directly.\n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         let matches = self.path == name;\n         if matches {\n             mark_used(self);\n@@ -250,10 +244,7 @@ impl MetaItem {\n         }\n     }\n \n-    pub fn check_name<T>(&self, name: T) -> bool\n-    where\n-        Path: PartialEq<T>,\n-    {\n+    pub fn check_name(&self, name: Symbol) -> bool {\n         self.path == name\n     }\n \n@@ -430,28 +421,28 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     }\n }\n \n-pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n+pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| {\n         item.check_name(name)\n     })\n }\n \n-pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n+pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n     attrs.iter().any(|item| {\n         item.check_name(name)\n     })\n }\n \n-pub fn find_by_name<'a>(attrs: &'a [Attribute], name: &str) -> Option<&'a Attribute> {\n+pub fn find_by_name<'a>(attrs: &'a [Attribute], name: Symbol) -> Option<&'a Attribute> {\n     attrs.iter().find(|attr| attr.check_name(name))\n }\n \n-pub fn filter_by_name<'a>(attrs: &'a [Attribute], name: &'a str)\n+pub fn filter_by_name<'a>(attrs: &'a [Attribute], name: Symbol)\n     -> impl Iterator<Item = &'a Attribute> {\n     attrs.iter().filter(move |attr| attr.check_name(name))\n }\n \n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<Symbol> {\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n     attrs.iter()\n         .find(|at| at.check_name(name))\n         .and_then(|at| at.value_str())"}, {"sha": "c82936afa3d9f0f96d815a36eddb05c326901a2c", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -12,6 +12,7 @@ use crate::edition::Edition;\n use crate::mut_visit::*;\n use crate::parse::{token, ParseSess};\n use crate::ptr::P;\n+use crate::symbol::sym;\n use crate::util::map_in_place::MapInPlace;\n \n use errors::Applicability;\n@@ -90,7 +91,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n     fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Vec<ast::Attribute> {\n-        if !attr.check_name(\"cfg_attr\") {\n+        if !attr.check_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n \n@@ -205,7 +206,7 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn maybe_emit_expr_attr_err(&self, attr: &ast::Attribute) {\n         if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n             let mut err = feature_err(self.sess,\n-                                      \"stmt_expr_attributes\",\n+                                      sym::stmt_expr_attributes,\n                                       attr.span,\n                                       GateIssue::Language,\n                                       EXPLAIN_STMT_ATTR_SYNTAX);\n@@ -285,9 +286,9 @@ impl<'a> StripUnconfigured<'a> {\n     /// See issue #51279.\n     pub fn disallow_cfg_on_generic_param(&mut self, param: &ast::GenericParam) {\n         for attr in param.attrs() {\n-            let offending_attr = if attr.check_name(\"cfg\") {\n+            let offending_attr = if attr.check_name(sym::cfg) {\n                 \"cfg\"\n-            } else if attr.check_name(\"cfg_attr\") {\n+            } else if attr.check_name(sym::cfg_attr) {\n                 \"cfg_attr\"\n             } else {\n                 continue;\n@@ -350,5 +351,5 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n }\n \n fn is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.check_name(\"cfg\")\n+    attr.check_name(sym::cfg)\n }"}, {"sha": "267f863ce35e4a622b2ba2a0301fcae7bccc9d94", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1,5 +1,6 @@\n use crate::attr;\n use crate::ast::{Item, ItemKind};\n+use crate::symbol::sym;\n \n pub enum EntryPointType {\n     None,\n@@ -14,9 +15,9 @@ pub enum EntryPointType {\n pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n     match item.node {\n         ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, \"start\") {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, \"main\") {\n+            } else if attr::contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == \"main\" {\n                 if depth == 1 {"}, {"sha": "7ebfcfd176adb791d51d27b8fa599867d2907480", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -14,7 +14,7 @@ use crate::parse::token::{self, Token};\n use crate::parse::parser::Parser;\n use crate::ptr::P;\n use crate::symbol::Symbol;\n-use crate::symbol::keywords;\n+use crate::symbol::{keywords, sym};\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::visit::{self, Visitor};\n use crate::util::map_in_place::MapInPlace;\n@@ -356,7 +356,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.collect_invocations(fragment, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n                     if !item.derive_allowed() {\n-                        let attr = attr::find_by_name(item.attrs(), \"derive\")\n+                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n                             .expect(\"`derive` attribute should exist\");\n                         let span = attr.span;\n                         let mut err = self.cx.mut_span_err(span,\n@@ -510,7 +510,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n            !self.cx.ecfg.macros_in_extern_enabled() {\n             if let SyntaxExtension::NonMacroAttr { .. } = *ext {} else {\n-                emit_feature_err(&self.cx.parse_sess, \"macros_in_extern\",\n+                emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n                                  invoc.span(), GateIssue::Language,\n                                  \"macro invocations in `extern {}` blocks are experimental\");\n             }\n@@ -636,7 +636,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             Annotatable::Item(ref item) => {\n                 match item.node {\n                     ItemKind::Mod(_) if self.cx.ecfg.proc_macro_hygiene() => return,\n-                    ItemKind::Mod(_) => (\"modules\", \"proc_macro_hygiene\"),\n+                    ItemKind::Mod(_) => (\"modules\", sym::proc_macro_hygiene),\n                     _ => return,\n                 }\n             }\n@@ -645,8 +645,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             Annotatable::ForeignItem(_) => return,\n             Annotatable::Stmt(_) |\n             Annotatable::Expr(_) if self.cx.ecfg.proc_macro_hygiene() => return,\n-            Annotatable::Stmt(_) => (\"statements\", \"proc_macro_hygiene\"),\n-            Annotatable::Expr(_) => (\"expressions\", \"proc_macro_hygiene\"),\n+            Annotatable::Stmt(_) => (\"statements\", sym::proc_macro_hygiene),\n+            Annotatable::Expr(_) => (\"expressions\", sym::proc_macro_hygiene),\n         };\n         emit_feature_err(\n             self.cx.parse_sess,\n@@ -681,7 +681,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 if let ast::ItemKind::MacroDef(_) = i.node {\n                     emit_feature_err(\n                         self.parse_sess,\n-                        \"proc_macro_hygiene\",\n+                        sym::proc_macro_hygiene,\n                         self.span,\n                         GateIssue::Language,\n                         \"procedural macros cannot expand to macro definitions\",\n@@ -724,13 +724,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 // don't stability-check macros in the same crate\n                 // (the only time this is null is for syntax extensions registered as macros)\n                 if def_site_span.map_or(false, |def_span| !crate_span.contains(def_span))\n-                    && !span.allows_unstable(&feature.as_str())\n+                    && !span.allows_unstable(feature)\n                     && this.cx.ecfg.features.map_or(true, |feats| {\n                     // macro features will count as lib features\n                     !feats.declared_lib_features.iter().any(|&(feat, _)| feat == feature)\n                 }) {\n                     let explain = format!(\"macro {}! is unstable\", path);\n-                    emit_feature_err(this.cx.parse_sess, &*feature.as_str(), span,\n+                    emit_feature_err(this.cx.parse_sess, feature, span,\n                                      GateIssue::Library(Some(issue)), &explain);\n                     this.cx.trace_macros_diag();\n                 }\n@@ -885,7 +885,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n         emit_feature_err(\n             self.cx.parse_sess,\n-            \"proc_macro_hygiene\",\n+            sym::proc_macro_hygiene,\n             span,\n             GateIssue::Language,\n             &format!(\"procedural macros cannot be expanded to {}\", kind),\n@@ -1118,7 +1118,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         if let Some(attr) = &attr {\n             if !self.cx.ecfg.enable_custom_inner_attributes() &&\n                attr.style == ast::AttrStyle::Inner && attr.path != \"test\" {\n-                emit_feature_err(&self.cx.parse_sess, \"custom_inner_attributes\",\n+                emit_feature_err(&self.cx.parse_sess, sym::custom_inner_attributes,\n                                  attr.span, GateIssue::Language,\n                                  \"non-builtin inner attributes are unstable\");\n             }\n@@ -1352,7 +1352,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 let inline_module = item.span.contains(inner) || inner.is_dummy();\n \n                 if inline_module {\n-                    if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {\n+                    if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, sym::path) {\n                         self.cx.current_expansion.directory_ownership =\n                             DirectoryOwnership::Owned { relative: None };\n                         module.directory.push(&*path.as_str());\n@@ -1485,19 +1485,19 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn visit_attribute(&mut self, at: &mut ast::Attribute) {\n         // turn `#[doc(include=\"filename\")]` attributes into `#[doc(include(file=\"filename\",\n         // contents=\"file contents\")]` attributes\n-        if !at.check_name(\"doc\") {\n+        if !at.check_name(sym::doc) {\n             return noop_visit_attribute(at, self);\n         }\n \n         if let Some(list) = at.meta_item_list() {\n-            if !list.iter().any(|it| it.check_name(\"include\")) {\n+            if !list.iter().any(|it| it.check_name(sym::include)) {\n                 return noop_visit_attribute(at, self);\n             }\n \n             let mut items = vec![];\n \n             for mut it in list {\n-                if !it.check_name(\"include\") {\n+                if !it.check_name(sym::include) {\n                     items.push({ noop_visit_meta_list_item(&mut it, self); it });\n                     continue;\n                 }"}, {"sha": "e1cb90d9e71d652033ad2bb4c250516d0e34b055", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -4,7 +4,7 @@ use crate::ext::build::AstBuilder;\n use crate::parse::{self, token, DirectoryOwnership};\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::symbol::Symbol;\n+use crate::symbol::{Symbol, sym};\n use crate::tokenstream;\n \n use smallvec::SmallVec;\n@@ -44,7 +44,7 @@ pub fn expand_column(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTr\n /* __rust_unstable_column!(): expands to the current column number */\n pub fn expand_column_gated(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<dyn base::MacResult+'static> {\n-    if sp.allows_unstable(\"__rust_unstable_column\") {\n+    if sp.allows_unstable(sym::__rust_unstable_column) {\n         expand_column(cx, sp, tts)\n     } else {\n         cx.span_fatal(sp, \"the __rust_unstable_column macro is unstable\");"}, {"sha": "55596210093693a53fcdf797d9e8e31a0c3277ca", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -13,7 +13,7 @@ use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::Parser;\n use crate::parse::token::{self, NtTT};\n use crate::parse::token::Token::*;\n-use crate::symbol::Symbol;\n+use crate::symbol::{Symbol, sym};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n use errors::FatalError;\n@@ -376,7 +376,7 @@ pub fn compile(\n     });\n \n     if body.legacy {\n-        let allow_internal_unstable = attr::find_by_name(&def.attrs, \"allow_internal_unstable\")\n+        let allow_internal_unstable = attr::find_by_name(&def.attrs, sym::allow_internal_unstable)\n             .map(|attr| attr\n                 .meta_item_list()\n                 .map(|list| list.iter()\n@@ -399,11 +399,11 @@ pub fn compile(\n                     vec![Symbol::intern(\"allow_internal_unstable_backcompat_hack\")].into()\n                 })\n             );\n-        let allow_internal_unsafe = attr::contains_name(&def.attrs, \"allow_internal_unsafe\");\n+        let allow_internal_unsafe = attr::contains_name(&def.attrs, sym::allow_internal_unsafe);\n         let mut local_inner_macros = false;\n-        if let Some(macro_export) = attr::find_by_name(&def.attrs, \"macro_export\") {\n+        if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n             if let Some(l) = macro_export.meta_item_list() {\n-                local_inner_macros = attr::list_contains_name(&l, \"local_inner_macros\");\n+                local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n             }\n         }\n \n@@ -426,7 +426,7 @@ pub fn compile(\n             edition,\n         }\n     } else {\n-        let is_transparent = attr::contains_name(&def.attrs, \"rustc_transparent_macro\");\n+        let is_transparent = attr::contains_name(&def.attrs, sym::rustc_transparent_macro);\n \n         SyntaxExtension::DeclMacro {\n             expander,"}, {"sha": "53ecb0762ab441f1178fadff4b082eaf4af9ab08", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -48,8 +48,8 @@ macro_rules! declare_features {\n         /// Represents active features that are currently being implemented or\n         /// currently being considered for addition/removal.\n         const ACTIVE_FEATURES:\n-            &[(&str, &str, Option<u32>, Option<Edition>, fn(&mut Features, Span))] =\n-            &[$((stringify!($feature), $ver, $issue, $edition, set!($feature))),+];\n+            &[(Symbol, &str, Option<u32>, Option<Edition>, fn(&mut Features, Span))] =\n+            &[$((sym::$feature, $ver, $issue, $edition, set!($feature))),+];\n \n         /// A set of features to be used by later passes.\n         #[derive(Clone)]\n@@ -80,22 +80,22 @@ macro_rules! declare_features {\n \n     ($((removed, $feature: ident, $ver: expr, $issue: expr, None, $reason: expr),)+) => {\n         /// Represents unstable features which have since been removed (it was once Active)\n-        const REMOVED_FEATURES: &[(&str, &str, Option<u32>, Option<&str>)] = &[\n-            $((stringify!($feature), $ver, $issue, $reason)),+\n+        const REMOVED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, $reason)),+\n         ];\n     };\n \n     ($((stable_removed, $feature: ident, $ver: expr, $issue: expr, None),)+) => {\n         /// Represents stable features which have since been removed (it was once Accepted)\n-        const STABLE_REMOVED_FEATURES: &[(&str, &str, Option<u32>, Option<&str>)] = &[\n-            $((stringify!($feature), $ver, $issue, None)),+\n+        const STABLE_REMOVED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, None)),+\n         ];\n     };\n \n     ($((accepted, $feature: ident, $ver: expr, $issue: expr, None),)+) => {\n         /// Those language feature has since been Accepted (it was once Active)\n-        const ACCEPTED_FEATURES: &[(&str, &str, Option<u32>, Option<&str>)] = &[\n-            $((stringify!($feature), $ver, $issue, None)),+\n+        const ACCEPTED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, None)),+\n         ];\n     }\n }\n@@ -860,7 +860,7 @@ pub enum AttributeType {\n pub enum AttributeGate {\n     /// Is gated by a given feature gate, reason\n     /// and function to check if enabled\n-    Gated(Stability, &'static str, &'static str, fn(&Features) -> bool),\n+    Gated(Stability, Symbol, &'static str, fn(&Features) -> bool),\n \n     /// Ungated attribute, can be used on all release channels\n     Ungated,\n@@ -1010,7 +1010,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     (sym::no_implicit_prelude, Normal, template!(Word), Ungated),\n     (sym::reexport_test_harness_main, Normal, template!(NameValueStr: \"name\"), Ungated),\n     (sym::link_args, Normal, template!(NameValueStr: \"args\"), Gated(Stability::Unstable,\n-                                \"link_args\",\n+                                sym::link_args,\n                                 \"the `link_args` attribute is experimental and not \\\n                                 portable across platforms, it is recommended to \\\n                                 use `#[link(name = \\\"foo\\\")] instead\",\n@@ -1019,46 +1019,46 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // RFC #1445.\n     (sym::structural_match, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"structural_match\",\n+                                            sym::structural_match,\n                                             \"the semantics of constant patterns is \\\n                                             not yet settled\",\n                                             cfg_fn!(structural_match))),\n \n     // RFC #2008\n     (sym::non_exhaustive, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"non_exhaustive\",\n+                                        sym::non_exhaustive,\n                                         \"non exhaustive is an experimental feature\",\n                                         cfg_fn!(non_exhaustive))),\n \n     // RFC #1268\n     (sym::marker, Normal, template!(Word), Gated(Stability::Unstable,\n-                            \"marker_trait_attr\",\n+                            sym::marker_trait_attr,\n                             \"marker traits is an experimental feature\",\n                             cfg_fn!(marker_trait_attr))),\n \n     (sym::plugin, CrateLevel, template!(List: \"name|name(args)\"), Gated(Stability::Unstable,\n-                                \"plugin\",\n+                                sym::plugin,\n                                 \"compiler plugins are experimental \\\n                                 and possibly buggy\",\n                                 cfg_fn!(plugin))),\n \n     (sym::no_std, CrateLevel, template!(Word), Ungated),\n     (sym::no_core, CrateLevel, template!(Word), Gated(Stability::Unstable,\n-                                \"no_core\",\n+                                sym::no_core,\n                                 \"no_core is experimental\",\n                                 cfg_fn!(no_core))),\n     (sym::lang, Normal, template!(NameValueStr: \"name\"), Gated(Stability::Unstable,\n-                        \"lang_items\",\n+                        sym::lang_items,\n                         \"language items are subject to change\",\n                         cfg_fn!(lang_items))),\n     (sym::linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n                                 Gated(Stability::Unstable,\n-                                \"linkage\",\n+                                sym::linkage,\n                                 \"the `linkage` attribute is experimental \\\n                                     and not portable across platforms\",\n                                 cfg_fn!(linkage))),\n     (sym::thread_local, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"thread_local\",\n+                                        sym::thread_local,\n                                         \"`#[thread_local]` is an experimental feature, and does \\\n                                          not currently handle destructors\",\n                                         cfg_fn!(thread_local))),\n@@ -1067,116 +1067,116 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                         r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n                         NameValueStr: \"message\"),\n                                             Gated(Stability::Unstable,\n-                                            \"on_unimplemented\",\n+                                            sym::on_unimplemented,\n                                             \"the `#[rustc_on_unimplemented]` attribute \\\n                                             is an experimental feature\",\n                                             cfg_fn!(on_unimplemented))),\n     (sym::rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#),\n                                             Gated(Stability::Unstable,\n-                                            \"rustc_const_unstable\",\n+                                            sym::rustc_const_unstable,\n                                             \"the `#[rustc_const_unstable]` attribute \\\n                                             is an internal feature\",\n                                             cfg_fn!(rustc_const_unstable))),\n     (sym::global_allocator, Normal, template!(Word), Ungated),\n     (sym::default_lib_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"allocator_internals\",\n+                                            sym::allocator_internals,\n                                             \"the `#[default_lib_allocator]` \\\n                                             attribute is an experimental feature\",\n                                             cfg_fn!(allocator_internals))),\n     (sym::needs_allocator, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"allocator_internals\",\n+                                    sym::allocator_internals,\n                                     \"the `#[needs_allocator]` \\\n                                     attribute is an experimental \\\n                                     feature\",\n                                     cfg_fn!(allocator_internals))),\n     (sym::panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"panic_runtime\",\n+                                        sym::panic_runtime,\n                                         \"the `#[panic_runtime]` attribute is \\\n                                         an experimental feature\",\n                                         cfg_fn!(panic_runtime))),\n     (sym::needs_panic_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"needs_panic_runtime\",\n+                                            sym::needs_panic_runtime,\n                                             \"the `#[needs_panic_runtime]` \\\n                                                 attribute is an experimental \\\n                                                 feature\",\n                                             cfg_fn!(needs_panic_runtime))),\n     (sym::rustc_outlives, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_outlives]` attribute \\\n                                     is just used for rustc unit tests \\\n                                     and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_variance, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_variance]` attribute \\\n                                     is just used for rustc unit tests \\\n                                     and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_layout, Normal, template!(List: \"field1, field2, ...\"),\n     Gated(Stability::Unstable,\n-        \"rustc_attrs\",\n+        sym::rustc_attrs,\n         \"the `#[rustc_layout]` attribute \\\n             is just used for rustc unit tests \\\n             and will never be stable\",\n         cfg_fn!(rustc_attrs))),\n     (sym::rustc_layout_scalar_valid_range_start, Whitelisted, template!(List: \"value\"),\n     Gated(Stability::Unstable,\n-        \"rustc_attrs\",\n+        sym::rustc_attrs,\n         \"the `#[rustc_layout_scalar_valid_range_start]` attribute \\\n             is just used to enable niche optimizations in libcore \\\n             and will never be stable\",\n         cfg_fn!(rustc_attrs))),\n     (sym::rustc_layout_scalar_valid_range_end, Whitelisted, template!(List: \"value\"),\n     Gated(Stability::Unstable,\n-        \"rustc_attrs\",\n+        sym::rustc_attrs,\n         \"the `#[rustc_layout_scalar_valid_range_end]` attribute \\\n             is just used to enable niche optimizations in libcore \\\n             and will never be stable\",\n         cfg_fn!(rustc_attrs))),\n     (sym::rustc_regions, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_regions]` attribute \\\n                                     is just used for rustc unit tests \\\n                                     and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_error, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_error]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_dump_user_substs, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"this attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\"),\n                                                 Gated(Stability::Unstable,\n-                                                \"rustc_attrs\",\n+                                                sym::rustc_attrs,\n                                                 \"the `#[rustc_if_this_changed]` attribute \\\n                                                 is just used for rustc unit tests \\\n                                                 and will never be stable\",\n                                                 cfg_fn!(rustc_attrs))),\n     (sym::rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\"),\n                                                     Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+                                                    sym::rustc_attrs,\n                                                     \"the `#[rustc_if_this_changed]` attribute \\\n                                                     is just used for rustc unit tests \\\n                                                     and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_dirty, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n                                                     /*opt*/ except = \"...\"\"#),\n                                     Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_dirty]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_clean, Whitelisted, template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\",\n                                                     /*opt*/ except = \"...\"\"#),\n                                     Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_clean]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n@@ -1187,7 +1187,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n         Gated(\n             Stability::Unstable,\n-            \"rustc_attrs\",\n+            sym::rustc_attrs,\n             \"this attribute \\\n             is just used for rustc unit tests \\\n             and will never be stable\",\n@@ -1200,7 +1200,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n         Gated(\n             Stability::Unstable,\n-            \"rustc_attrs\",\n+            sym::rustc_attrs,\n             \"this attribute \\\n             is just used for rustc unit tests \\\n             and will never be stable\",\n@@ -1210,27 +1210,27 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     (sym::rustc_expected_cgu_reuse, Whitelisted, template!(List: r#\"cfg = \"...\", module = \"...\",\n                                                             kind = \"...\"\"#),\n                                                     Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+                                                    sym::rustc_attrs,\n                                                     \"this attribute \\\n                                                     is just used for rustc unit tests \\\n                                                     and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_synthetic, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+                                                    sym::rustc_attrs,\n                                                     \"this attribute \\\n                                                     is just used for rustc unit tests \\\n                                                     and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_symbol_name, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"rustc_attrs\",\n+                                            sym::rustc_attrs,\n                                             \"internal rustc attributes will never be stable\",\n                                             cfg_fn!(rustc_attrs))),\n     (sym::rustc_def_path, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"rustc_attrs\",\n+                                        sym::rustc_attrs,\n                                         \"internal rustc attributes will never be stable\",\n                                         cfg_fn!(rustc_attrs))),\n     (sym::rustc_mir, Whitelisted, template!(List: \"arg1, arg2, ...\"), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_mir]` attribute \\\n                                     is just used for rustc unit tests \\\n                                     and will never be stable\",\n@@ -1241,7 +1241,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(Word),\n         Gated(\n             Stability::Unstable,\n-            \"rustc_attrs\",\n+            sym::rustc_attrs,\n             \"the `#[rustc_inherit_overflow_checks]` \\\n             attribute is just used to control \\\n             overflow checking behavior of several \\\n@@ -1252,35 +1252,35 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n \n     (sym::rustc_dump_program_clauses, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+                                                    sym::rustc_attrs,\n                                                     \"the `#[rustc_dump_program_clauses]` \\\n                                                     attribute is just used for rustc unit \\\n                                                     tests and will never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_test_marker, Normal, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"the `#[rustc_test_marker]` attribute \\\n                                     is used internally to track tests\",\n                                     cfg_fn!(rustc_attrs))),\n     (sym::rustc_transparent_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                \"rustc_attrs\",\n+                                                sym::rustc_attrs,\n                                                 \"used internally for testing macro hygiene\",\n                                                     cfg_fn!(rustc_attrs))),\n     (sym::compiler_builtins, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"compiler_builtins\",\n+                                            sym::compiler_builtins,\n                                             \"the `#[compiler_builtins]` attribute is used to \\\n                                             identify the `compiler_builtins` crate which \\\n                                             contains compiler-rt intrinsics and will never be \\\n                                             stable\",\n                                         cfg_fn!(compiler_builtins))),\n     (sym::sanitizer_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"sanitizer_runtime\",\n+                                            sym::sanitizer_runtime,\n                                             \"the `#[sanitizer_runtime]` attribute is used to \\\n                                             identify crates that contain the runtime of a \\\n                                             sanitizer and will never be stable\",\n                                             cfg_fn!(sanitizer_runtime))),\n     (sym::profiler_runtime, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                            \"profiler_runtime\",\n+                                            sym::profiler_runtime,\n                                             \"the `#[profiler_runtime]` attribute is used to \\\n                                             identify the `profiler_builtins` crate which \\\n                                             contains the profiler runtime and will never be \\\n@@ -1289,17 +1289,17 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     (sym::allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n                                             Gated(Stability::Unstable,\n-                                            \"allow_internal_unstable\",\n+                                            sym::allow_internal_unstable,\n                                             EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n                                             cfg_fn!(allow_internal_unstable))),\n \n     (sym::allow_internal_unsafe, Normal, template!(Word), Gated(Stability::Unstable,\n-                                            \"allow_internal_unsafe\",\n+                                            sym::allow_internal_unsafe,\n                                             EXPLAIN_ALLOW_INTERNAL_UNSAFE,\n                                             cfg_fn!(allow_internal_unsafe))),\n \n     (sym::fundamental, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    \"fundamental\",\n+                                    sym::fundamental,\n                                     \"the `#[fundamental]` attribute \\\n                                         is an experimental feature\",\n                                     cfg_fn!(fundamental))),\n@@ -1309,7 +1309,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                     Ungated),\n \n     (sym::rustc_copy_clone_marker, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                \"rustc_attrs\",\n+                                                sym::rustc_attrs,\n                                                 \"internal implementation detail\",\n                                                 cfg_fn!(rustc_attrs))),\n \n@@ -1325,12 +1325,12 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // lint pass\n     (sym::cold, Whitelisted, template!(Word), Ungated),\n     (sym::naked, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                \"naked_functions\",\n+                                sym::naked_functions,\n                                 \"the `#[naked]` attribute \\\n                                 is an experimental feature\",\n                                 cfg_fn!(naked_functions))),\n     (sym::ffi_returns_twice, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                \"ffi_returns_twice\",\n+                                sym::ffi_returns_twice,\n                                 \"the `#[ffi_returns_twice]` attribute \\\n                                 is an experimental feature\",\n                                 cfg_fn!(ffi_returns_twice))),\n@@ -1344,7 +1344,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     (sym::no_builtins, Whitelisted, template!(Word), Ungated),\n     (sym::no_debug, Whitelisted, template!(Word), Gated(\n         Stability::Deprecated(\"https://github.com/rust-lang/rust/issues/29721\", None),\n-        \"no_debug\",\n+        sym::no_debug,\n         \"the `#[no_debug]` attribute was an experimental feature that has been \\\n         deprecated due to lack of demand\",\n         cfg_fn!(no_debug))),\n@@ -1354,7 +1354,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(Word),\n         Gated(\n             Stability::Unstable,\n-            \"omit_gdb_pretty_printer_section\",\n+            sym::omit_gdb_pretty_printer_section,\n             \"the `#[omit_gdb_pretty_printer_section]` \\\n                 attribute is just used for the Rust test \\\n                 suite\",\n@@ -1366,26 +1366,26 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     template!(Word),\n     Gated(Stability::Deprecated(\"https://github.com/rust-lang/rust/issues/34761\",\n                                 Some(\"replace this attribute with `#[may_dangle]`\")),\n-        \"dropck_parametricity\",\n+        sym::dropck_parametricity,\n         \"unsafe_destructor_blind_to_params has been replaced by \\\n             may_dangle and will be removed in the future\",\n         cfg_fn!(dropck_parametricity))),\n     (sym::may_dangle,\n     Normal,\n     template!(Word),\n     Gated(Stability::Unstable,\n-        \"dropck_eyepatch\",\n+        sym::dropck_eyepatch,\n         \"may_dangle has unstable semantics and may be removed in the future\",\n         cfg_fn!(dropck_eyepatch))),\n     (sym::unwind, Whitelisted, template!(List: \"allowed|aborts\"), Gated(Stability::Unstable,\n-                                \"unwind_attributes\",\n+                                sym::unwind_attributes,\n                                 \"#[unwind] is experimental\",\n                                 cfg_fn!(unwind_attributes))),\n     (sym::used, Whitelisted, template!(Word), Ungated),\n \n     // used in resolve\n     (sym::prelude_import, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                        \"prelude_import\",\n+                                        sym::prelude_import,\n                                         \"`#[prelude_import]` is for use by rustc only\",\n                                         cfg_fn!(prelude_import))),\n \n@@ -1421,7 +1421,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n \n     (sym::rustc_paren_sugar, Normal, template!(Word), Gated(Stability::Unstable,\n-                                        \"unboxed_closures\",\n+                                        sym::unboxed_closures,\n                                         \"unboxed_closures are still evolving\",\n                                         cfg_fn!(unboxed_closures))),\n \n@@ -1431,24 +1431,24 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     (sym::proc_macro, Normal, template!(Word), Ungated),\n \n     (sym::rustc_proc_macro_decls, Normal, template!(Word), Gated(Stability::Unstable,\n-                                            \"rustc_attrs\",\n+                                            sym::rustc_attrs,\n                                             \"used internally by rustc\",\n                                             cfg_fn!(rustc_attrs))),\n \n     (sym::allow_fail, Normal, template!(Word), Gated(Stability::Unstable,\n-                                \"allow_fail\",\n+                                sym::allow_fail,\n                                 \"allow_fail attribute is currently unstable\",\n                                 cfg_fn!(allow_fail))),\n \n     (sym::rustc_std_internal_symbol, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                    \"rustc_attrs\",\n+                                    sym::rustc_attrs,\n                                     \"this is an internal attribute that will \\\n                                     never be stable\",\n                                     cfg_fn!(rustc_attrs))),\n \n     // whitelists \"identity-like\" conversion methods to suggest on type mismatch\n     (sym::rustc_conversion_suggestion, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                    \"rustc_attrs\",\n+                                                    sym::rustc_attrs,\n                                                     \"this is an internal attribute that will \\\n                                                         never be stable\",\n                                                     cfg_fn!(rustc_attrs))),\n@@ -1457,19 +1457,20 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         sym::rustc_args_required_const,\n         Whitelisted,\n         template!(List: \"N\"),\n-        Gated(Stability::Unstable, \"rustc_attrs\", \"never will be stable\", cfg_fn!(rustc_attrs))\n+        Gated(Stability::Unstable, sym::rustc_attrs, \"never will be stable\",\n+           cfg_fn!(rustc_attrs))\n     ),\n     // RFC 2070\n     (sym::panic_handler, Normal, template!(Word), Ungated),\n \n     (sym::alloc_error_handler, Normal, template!(Word), Gated(Stability::Unstable,\n-                        \"alloc_error_handler\",\n+                        sym::alloc_error_handler,\n                         \"#[alloc_error_handler] is an unstable feature\",\n                         cfg_fn!(alloc_error_handler))),\n \n     // RFC 2412\n     (sym::optimize, Whitelisted, template!(List: \"size|speed\"), Gated(Stability::Unstable,\n-                            \"optimize_attribute\",\n+                            sym::optimize_attribute,\n                             \"#[optimize] attribute is an unstable feature\",\n                             cfg_fn!(optimize_attribute))),\n \n@@ -1483,7 +1484,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     (sym::recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n     (sym::type_length_limit, CrateLevel, template!(NameValueStr: \"N\"), Ungated),\n     (sym::test_runner, CrateLevel, template!(List: \"path\"), Gated(Stability::Unstable,\n-                    \"custom_test_frameworks\",\n+                    sym::custom_test_frameworks,\n                     EXPLAIN_CUSTOM_TEST_FRAMEWORKS,\n                     cfg_fn!(custom_test_frameworks))),\n ];\n@@ -1503,11 +1504,11 @@ lazy_static! {\n }\n \n // cfg(...)'s that are feature gated\n-const GATED_CFGS: &[(&str, &str, fn(&Features) -> bool)] = &[\n+const GATED_CFGS: &[(Symbol, Symbol, fn(&Features) -> bool)] = &[\n     // (name in cfg, feature, function to check if the feature is enabled)\n-    (\"target_thread_local\", \"cfg_target_thread_local\", cfg_fn!(cfg_target_thread_local)),\n-    (\"target_has_atomic\", \"cfg_target_has_atomic\", cfg_fn!(cfg_target_has_atomic)),\n-    (\"rustdoc\", \"doc_cfg\", cfg_fn!(doc_cfg)),\n+    (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n+    (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n ];\n \n #[derive(Debug)]\n@@ -1540,7 +1541,7 @@ impl GatedCfg {\n struct Context<'a> {\n     features: &'a Features,\n     parse_sess: &'a ParseSess,\n-    plugin_attributes: &'a [(String, AttributeType)],\n+    plugin_attributes: &'a [(Symbol, AttributeType)],\n }\n \n macro_rules! gate_feature_fn {\n@@ -1559,11 +1560,11 @@ macro_rules! gate_feature_fn {\n macro_rules! gate_feature {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n         gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n-                         stringify!($feature), $explain, GateStrength::Hard)\n+                         sym::$feature, $explain, GateStrength::Hard)\n     };\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {\n         gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n-                         stringify!($feature), $explain, $level)\n+                         sym::$feature, $explain, $level)\n     };\n }\n \n@@ -1594,8 +1595,8 @@ impl<'a> Context<'a> {\n             debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n             return;\n         }\n-        for &(ref n, ref ty) in self.plugin_attributes {\n-            if attr.path == &**n {\n+        for &(n, ty) in self.plugin_attributes {\n+            if attr.path == n {\n                 // Plugins can't gate attributes, so we don't check for it\n                 // unlike the code above; we only use this loop to\n                 // short-circuit to avoid the checks below.\n@@ -1629,7 +1630,7 @@ pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features:\n     );\n }\n \n-fn find_lang_feature_issue(feature: &str) -> Option<u32> {\n+fn find_lang_feature_issue(feature: Symbol) -> Option<u32> {\n     if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n         let issue = info.2;\n         // FIXME (#28244): enforce that active features have issue numbers\n@@ -1661,7 +1662,7 @@ pub enum GateStrength {\n \n pub fn emit_feature_err(\n     sess: &ParseSess,\n-    feature: &str,\n+    feature: Symbol,\n     span: Span,\n     issue: GateIssue,\n     explain: &str,\n@@ -1671,7 +1672,7 @@ pub fn emit_feature_err(\n \n pub fn feature_err<'a>(\n     sess: &'a ParseSess,\n-    feature: &str,\n+    feature: Symbol,\n     span: Span,\n     issue: GateIssue,\n     explain: &str,\n@@ -1681,7 +1682,7 @@ pub fn feature_err<'a>(\n \n fn leveled_feature_err<'a>(\n     sess: &'a ParseSess,\n-    feature: &str,\n+    feature: Symbol,\n     span: Span,\n     issue: GateIssue,\n     explain: &str,\n@@ -1769,13 +1770,13 @@ struct PostExpansionVisitor<'a> {\n macro_rules! gate_feature_post {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n         let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable(stringify!($feature)) {\n+        if !span.allows_unstable(sym::$feature) {\n             gate_feature!(cx.context, $feature, span, $explain)\n         }\n     }};\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n         let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable(stringify!($feature)) {\n+        if !span.allows_unstable(sym::$feature) {\n             gate_feature!(cx.context, $feature, span, $explain, $level)\n         }\n     }}\n@@ -1957,17 +1958,17 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if attr::contains_name(&i.attrs[..], \"plugin_registrar\") {\n+                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n                     gate_feature_post!(&self, plugin_registrar, i.span,\n                                        \"compiler plugins are experimental and possibly buggy\");\n                 }\n-                if attr::contains_name(&i.attrs[..], \"start\") {\n+                if attr::contains_name(&i.attrs[..], sym::start) {\n                     gate_feature_post!(&self, start, i.span,\n                                       \"a #[start] function is an experimental \\\n                                        feature whose signature may change \\\n                                        over time\");\n                 }\n-                if attr::contains_name(&i.attrs[..], \"main\") {\n+                if attr::contains_name(&i.attrs[..], sym::main) {\n                     gate_feature_post!(&self, main, i.span,\n                                        \"declaration of a nonstandard #[main] \\\n                                         function may change over time, for now \\\n@@ -1976,7 +1977,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in attr::filter_by_name(&i.attrs[..], \"repr\") {\n+                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n                         if item.check_name(sym::simd) {\n                             gate_feature_post!(&self, repr_simd, attr.span,\n@@ -1987,7 +1988,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Enum(..) => {\n-                for attr in attr::filter_by_name(&i.attrs[..], \"repr\") {\n+                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n                         if item.check_name(sym::align) {\n                             gate_feature_post!(&self, repr_align_enum, attr.span,\n@@ -2051,7 +2052,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match i.node {\n             ast::ForeignItemKind::Fn(..) |\n             ast::ForeignItemKind::Static(..) => {\n-                let link_name = attr::first_attr_value_str_by_name(&i.attrs, \"link_name\");\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm = match link_name {\n                     Some(val) => val.as_str().starts_with(\"llvm.\"),\n                     _ => false\n@@ -2311,7 +2312,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n         if let Some(f_edition) = f_edition {\n             if f_edition <= crate_edition {\n                 set(&mut features, DUMMY_SP);\n-                edition_enabled_features.insert(Symbol::intern(name), crate_edition);\n+                edition_enabled_features.insert(name, crate_edition);\n             }\n         }\n     }\n@@ -2355,7 +2356,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n                             // FIXME(Manishearth) there is currently no way to set\n                             // lib features by edition\n                             set(&mut features, DUMMY_SP);\n-                            edition_enabled_features.insert(Symbol::intern(name), *edition);\n+                            edition_enabled_features.insert(name, *edition);\n                         }\n                     }\n                 }\n@@ -2438,7 +2439,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n pub fn check_crate(krate: &ast::Crate,\n                    sess: &ParseSess,\n                    features: &Features,\n-                   plugin_attributes: &[(String, AttributeType)],\n+                   plugin_attributes: &[(Symbol, AttributeType)],\n                    unstable: UnstableFeatures) {\n     maybe_stage_features(&sess.span_diagnostic, krate, unstable);\n     let ctx = Context {"}, {"sha": "64f3704e8083f8656ee55ac58e22948fbf11ebd3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -575,13 +575,15 @@ mod tests {\n \n     #[test] fn crlf_doc_comments() {\n         with_globals(|| {\n+            use crate::symbol::sym;\n+\n             let sess = ParseSess::new(FilePathMapping::empty());\n \n             let name_1 = FileName::Custom(\"crlf_source_1\".to_string());\n             let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n             let item = parse_item_from_source_str(name_1, source, &sess)\n                 .unwrap().unwrap();\n-            let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n+            let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n             assert_eq!(doc, \"/// doc comment\");\n \n             let name_2 = FileName::Custom(\"crlf_source_2\".to_string());\n@@ -596,7 +598,7 @@ mod tests {\n             let name_3 = FileName::Custom(\"clrf_source_3\".to_string());\n             let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n             let item = parse_item_from_source_str(name_3, source, &sess).unwrap().unwrap();\n-            let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n+            let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n             assert_eq!(doc, \"/** doc comment\\n *  with CRLF */\");\n         });\n     }"}, {"sha": "d3dd6bb1e01a9e79b97e3b6dafa12cdc7c3770b1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -46,7 +46,7 @@ use crate::ptr::P;\n use crate::parse::PResult;\n use crate::ThinVec;\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n-use crate::symbol::{keywords, Symbol};\n+use crate::symbol::{keywords, sym, Symbol};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n@@ -7263,7 +7263,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n-        if let Some(path) = attr::first_attr_value_str_by_name(attrs, \"path\") {\n+        if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n             self.directory.path.to_mut().push(&path.as_str());\n             self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n         } else {\n@@ -7283,7 +7283,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        if let Some(s) = attr::first_attr_value_str_by_name(attrs, \"path\") {\n+        if let Some(s) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n             let s = s.as_str();\n \n             // On windows, the base path might have the form"}, {"sha": "42ca8b7c23cb0efa60e010ae13ce218d82fa092b", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -2,7 +2,7 @@ use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n use crate::ext::hygiene::{Mark, SyntaxContext};\n-use crate::symbol::{Symbol, keywords};\n+use crate::symbol::{Symbol, keywords, sym};\n use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n use crate::ptr::P;\n use crate::tokenstream::TokenStream;\n@@ -46,10 +46,10 @@ pub fn maybe_inject_crates_ref(\n     let rust_2018 = edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[&str] = if attr::contains_name(&krate.attrs, \"no_core\") {\n+    let names: &[&str] = if attr::contains_name(&krate.attrs, sym::no_core) {\n         return krate;\n-    } else if attr::contains_name(&krate.attrs, \"no_std\") {\n-        if attr::contains_name(&krate.attrs, \"compiler_builtins\") {\n+    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n+        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[\"core\"]\n         } else {\n             &[\"core\", \"compiler_builtins\"]"}, {"sha": "8e5e594ce9aa5ee9802005fb2927d7a692be60ad", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -29,7 +29,7 @@ use crate::parse::{token, ParseSess};\n use crate::print::pprust;\n use crate::ast::{self, Ident};\n use crate::ptr::P;\n-use crate::symbol::{self, Symbol, keywords};\n+use crate::symbol::{self, Symbol, keywords, sym};\n use crate::ThinVec;\n \n struct Test {\n@@ -65,8 +65,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(&krate.attrs,\n-                                           \"reexport_test_harness_main\");\n+        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n@@ -185,7 +184,7 @@ impl MutVisitor for EntryPointCleaner {\n                         ident,\n                         attrs: attrs.into_iter()\n                             .filter(|attr| {\n-                                !attr.check_name(\"main\") && !attr.check_name(\"start\")\n+                                !attr.check_name(sym::main) && !attr.check_name(sym::start)\n                             })\n                             .chain(iter::once(allow_dead_code))\n                             .collect(),\n@@ -428,11 +427,11 @@ fn visible_path(cx: &TestCtxt<'_>, path: &[Ident]) -> Vec<Ident>{\n }\n \n fn is_test_case(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"rustc_test_marker\")\n+    attr::contains_name(&i.attrs, sym::rustc_test_marker)\n }\n \n fn get_test_runner(sd: &errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n-    let test_attr = attr::find_by_name(&krate.attrs, \"test_runner\")?;\n+    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n     test_attr.meta_item_list().map(|meta_list| {\n         if meta_list.len() != 1 {\n             sd.span_fatal(test_attr.span,"}, {"sha": "6213736ed5f46cf5beff58282f32de0f5205a096", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -11,7 +11,7 @@ use syntax::ext::base::{self, *};\n use syntax::feature_gate;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ast::AsmDialect;\n use syntax_pos::Span;\n use syntax::tokenstream;\n@@ -47,7 +47,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        -> Box<dyn base::MacResult + 'cx> {\n     if !cx.ecfg.enable_asm() {\n         feature_gate::emit_feature_err(&cx.parse_sess,\n-                                       \"asm\",\n+                                       sym::asm,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_ASM);"}, {"sha": "77c53f402cc9f03b7f21bdea386aa457ac368d2d", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -6,7 +6,7 @@ use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{Symbol, sym};\n use syntax::tokenstream::TokenTree;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n@@ -15,7 +15,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               -> Box<dyn base::MacResult + 'cx> {\n     if !cx.ecfg.enable_concat_idents() {\n         feature_gate::emit_feature_err(&cx.parse_sess,\n-                                       \"concat_idents\",\n+                                       sym::concat_idents,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_CONCAT_IDENTS);"}, {"sha": "1b0d572324a7924dada216e2d413e2dfd9aedee6", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -7,7 +7,7 @@ use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax_pos::Span;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n@@ -37,7 +37,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n-                    if attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") &&\n+                    if attr::contains_name(&annitem.attrs, sym::rustc_copy_clone_marker) &&\n                         !params.iter().any(|param| match param.kind {\n                             ast::GenericParamKind::Type { .. } => true,\n                             _ => false,"}, {"sha": "228862c830fd8e665d6bc5d57f8e4002d42f2105", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -191,7 +191,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::source_map::{self, respan};\n use syntax::util::map_in_place::MapInPlace;\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, keywords};\n+use syntax::symbol::{Symbol, keywords, sym};\n use syntax::parse::ParseSess;\n use syntax_pos::{DUMMY_SP, Span};\n \n@@ -426,7 +426,7 @@ impl<'a> TraitDef<'a> {\n                     }\n                 };\n                 let is_always_copy =\n-                    attr::contains_name(&item.attrs, \"rustc_copy_clone_marker\") &&\n+                    attr::contains_name(&item.attrs, sym::rustc_copy_clone_marker) &&\n                     has_no_type_params;\n                 let use_temporaries = is_packed && is_always_copy;\n "}, {"sha": "9e54c0634b666b43a4bae4f333f27bc8fe774646", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -12,7 +12,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::tokenstream;\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n@@ -711,12 +711,12 @@ pub fn expand_format_args_nl<'cx>(\n     //if !ecx.ecfg.enable_allow_internal_unstable() {\n \n     // For some reason, the only one that actually works for `println` is the first check\n-    if !sp.allows_unstable(\"format_args_nl\") // the span is marked as `#[allow_insternal_unsable]`\n+    if !sp.allows_unstable(sym::format_args_nl) // the span is marked `#[allow_insternal_unsable]`\n         && !ecx.ecfg.enable_allow_internal_unstable()  // NOTE: when is this enabled?\n         && !ecx.ecfg.enable_format_args_nl()  // enabled using `#[feature(format_args_nl]`\n     {\n         feature_gate::emit_feature_err(&ecx.parse_sess,\n-                                       \"format_args_nl\",\n+                                       sym::format_args_nl,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_FORMAT_ARGS_NL);"}, {"sha": "3f2853e4b0e20b3025d411eed2d8ddb8a2ea7ffc", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -16,12 +16,12 @@ use syntax::ext::base::{self, *};\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n use syntax::tokenstream;\n use smallvec::smallvec;\n \n-pub const MACRO: &str = \"global_asm\";\n+pub const MACRO: Symbol = sym::global_asm;\n \n pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               sp: Span,"}, {"sha": "1be3990837cfe3cd6950e79307db6f1a7b6a3fa2", "filename": "src/libsyntax_ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flog_syntax.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -2,6 +2,7 @@ use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::print;\n use syntax::tokenstream;\n+use syntax::symbol::sym;\n use syntax_pos;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt<'_>,\n@@ -10,7 +11,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt<'_>,\n                               -> Box<dyn base::MacResult + 'cx> {\n     if !cx.ecfg.enable_log_syntax() {\n         feature_gate::emit_feature_err(&cx.parse_sess,\n-                                       \"log_syntax\",\n+                                       sym::log_syntax,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_LOG_SYNTAX);"}, {"sha": "5ced1400acb0ec66b110119749cdd518d032e93e", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -13,12 +13,16 @@ use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-const PROC_MACRO_KINDS: [&str; 3] = [\"proc_macro_derive\", \"proc_macro_attribute\", \"proc_macro\"];\n+const PROC_MACRO_KINDS: [Symbol; 3] = [\n+    sym::proc_macro_derive,\n+    sym::proc_macro_attribute,\n+    sym::proc_macro\n+];\n \n struct ProcMacroDerive {\n     trait_name: ast::Name,\n@@ -139,7 +143,7 @@ impl<'a> CollectProcMacros<'a> {\n \n         let attributes_attr = list.get(1);\n         let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n-            if !attr.check_name(\"attributes\") {\n+            if !attr.check_name(sym::attributes) {\n                 self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n             }\n             attr.meta_item_list().unwrap_or_else(|| {\n@@ -231,7 +235,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.node {\n-            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, \"macro_export\") {\n+            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(item.span, msg);\n@@ -304,11 +308,11 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             return;\n         }\n \n-        if attr.check_name(\"proc_macro_derive\") {\n+        if attr.check_name(sym::proc_macro_derive) {\n             self.collect_custom_derive(item, attr);\n-        } else if attr.check_name(\"proc_macro_attribute\") {\n+        } else if attr.check_name(sym::proc_macro_attribute) {\n             self.collect_attr_proc_macro(item);\n-        } else if attr.check_name(\"proc_macro\") {\n+        } else if attr.check_name(sym::proc_macro) {\n             self.collect_bang_proc_macro(item);\n         };\n "}, {"sha": "86ae6ab5fece5cbef9b2ae6be24e8dabed05799b", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -7,7 +7,7 @@ use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n use syntax::attr;\n use syntax::ast;\n use syntax::print::pprust;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{DUMMY_SP, Span};\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use std::iter;\n@@ -206,23 +206,23 @@ enum ShouldPanic {\n }\n \n fn should_ignore(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"ignore\")\n+    attr::contains_name(&i.attrs, sym::ignore)\n }\n \n fn should_fail(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"allow_fail\")\n+    attr::contains_name(&i.attrs, sym::allow_fail)\n }\n \n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n-    match attr::find_by_name(&i.attrs, \"should_panic\") {\n+    match attr::find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {\n             let ref sd = cx.parse_sess.span_diagnostic;\n \n             match attr.meta_item_list() {\n                 // Handle #[should_panic(expected = \"foo\")]\n                 Some(list) => {\n                     let msg = list.iter()\n-                        .find(|mi| mi.check_name(\"expected\"))\n+                        .find(|mi| mi.check_name(sym::expected))\n                         .and_then(|mi| mi.meta_item())\n                         .and_then(|mi| mi.value_str());\n                     if list.len() != 1 || msg.is_none() {\n@@ -247,7 +247,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n }\n \n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_should_panic_attr = attr::contains_name(&i.attrs, \"should_panic\");\n+    let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let ref sd = cx.parse_sess.span_diagnostic;\n     if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.node {\n         if header.unsafety == ast::Unsafety::Unsafe {"}, {"sha": "802037f6d22bbb16f7211268d6a91c9bca497213", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -14,7 +14,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n use syntax::ast;\n use syntax::source_map::respan;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax_pos::{DUMMY_SP, Span};\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use syntax::feature_gate;\n@@ -27,7 +27,7 @@ pub fn expand(\n ) -> Vec<Annotatable> {\n     if !ecx.ecfg.enable_custom_test_frameworks() {\n         feature_gate::emit_feature_err(&ecx.parse_sess,\n-                                       \"custom_test_frameworks\",\n+                                       sym::custom_test_frameworks,\n                                        attr_sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_CUSTOM_TEST_FRAMEWORKS);"}, {"sha": "eca658cb5473e2fb30d3a24ca5c43edda152d2e3", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -1,6 +1,6 @@\n use syntax::ext::base::{self, ExtCtxt};\n use syntax::feature_gate;\n-use syntax::symbol::keywords;\n+use syntax::symbol::{keywords, sym};\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n \n@@ -10,7 +10,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt<'_>,\n                            -> Box<dyn base::MacResult + 'static> {\n     if !cx.ecfg.enable_trace_macros() {\n         feature_gate::emit_feature_err(&cx.parse_sess,\n-                                       \"trace_macros\",\n+                                       sym::trace_macros,\n                                        sp,\n                                        feature_gate::GateIssue::Language,\n                                        feature_gate::EXPLAIN_TRACE_MACROS);"}, {"sha": "c5d6da74eb618e572c1403d014e06b237c16cfb9", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -33,7 +33,7 @@ mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n \n pub mod symbol;\n-pub use symbol::sym;\n+pub use symbol::{Symbol, sym};\n \n mod analyze_source_file;\n \n@@ -388,7 +388,7 @@ impl Span {\n     /// Checks if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n-    pub fn allows_unstable(&self, feature: &str) -> bool {\n+    pub fn allows_unstable(&self, feature: Symbol) -> bool {\n         match self.ctxt().outer().expn_info() {\n             Some(info) => info\n                 .allow_internal_unstable"}, {"sha": "c6b33fbc75ee23dbd29e30c3a5c2ff325eea6a95", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-plugin-attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{Symbol, sym};\n use syntax::ptr::P;\n use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n@@ -71,7 +71,7 @@ fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     };\n \n     fields.iter().fold(cx.expr_isize(trait_span, 0), |acc, ref item| {\n-        if attr::contains_name(&item.attrs, \"ignore\") {\n+        if attr::contains_name(&item.attrs, sym::ignore) {\n             acc\n         } else {\n             cx.expr_binary(item.span, ast::BinOpKind::Add, acc,"}, {"sha": "40e0115c623eeca63f4858335bc8d0874b5f636e", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -23,7 +23,7 @@ use syntax::{ast, source_map};\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box MissingWhitelistedAttrPass);\n-    reg.register_attribute(\"whitelisted_attr\".to_string(), Whitelisted);\n+    reg.register_attribute(Symbol::intern(\"whitelisted_attr\"), Whitelisted);\n }\n \n declare_lint! {\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n             _ => cx.tcx.hir().expect_item_by_hir_id(cx.tcx.hir().get_parent_item(id)),\n         };\n \n-        if !attr::contains_name(&item.attrs, \"whitelisted_attr\") {\n+        if !attr::contains_name(&item.attrs, Symbol::intern(\"whitelisted_attr\")) {\n             cx.span_lint(MISSING_WHITELISTED_ATTR, span,\n                          \"Missing 'whitelisted_attr' attribute\");\n         }"}, {"sha": "8c7bd7222e73cb5294594c32fa854d10f4b8c863", "filename": "src/test/run-pass-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -11,6 +11,7 @@ use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPass\n use rustc_plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n+use syntax::symbol::Symbol;\n \n macro_rules! fake_lint_pass {\n     ($struct:ident, $lints:expr, $($attr:expr),*) => {\n@@ -49,19 +50,19 @@ declare_lint!(CRATE_NOT_GREEN, Warn, \"crate not marked with #![crate_green]\");\n fake_lint_pass! {\n     PassOkay,\n     lint_array!(CRATE_NOT_OKAY), // Single lint\n-    \"rustc_crate_okay\"\n+    Symbol::intern(\"rustc_crate_okay\")\n }\n \n fake_lint_pass! {\n     PassRedBlue,\n     lint_array!(CRATE_NOT_RED, CRATE_NOT_BLUE), // Multiple lints\n-    \"rustc_crate_red\", \"rustc_crate_blue\"\n+    Symbol::intern(\"rustc_crate_red\"), Symbol::intern(\"rustc_crate_blue\")\n }\n \n fake_lint_pass! {\n     PassGreyGreen,\n     lint_array!(CRATE_NOT_GREY, CRATE_NOT_GREEN, ), // Trailing comma\n-    \"rustc_crate_grey\", \"rustc_crate_green\"\n+    Symbol::intern(\"rustc_crate_grey\"), Symbol::intern(\"rustc_crate_green\")\n }\n \n #[plugin_registrar]"}, {"sha": "039124f31ff4233bb59dfdc01652ff3f4eaae38b", "filename": "src/test/ui-fulldeps/auxiliary/attr-plugin-test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -8,14 +8,14 @@ extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n \n+use syntax::symbol::Symbol;\n use syntax::feature_gate::AttributeType;\n use rustc_plugin::Registry;\n \n \n-\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_attribute(\"foo\".to_owned(), AttributeType::Normal);\n-    reg.register_attribute(\"bar\".to_owned(), AttributeType::CrateLevel);\n-    reg.register_attribute(\"baz\".to_owned(), AttributeType::Whitelisted);\n+    reg.register_attribute(Symbol::intern(\"foo\"), AttributeType::Normal);\n+    reg.register_attribute(Symbol::intern(\"bar\"), AttributeType::CrateLevel);\n+    reg.register_attribute(Symbol::intern(\"baz\"), AttributeType::Whitelisted);\n }"}, {"sha": "7656b15721adafb03db8ff576d84d1b5c1c745dc", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb084a48e2ca663de41b316dc6ece2dceb93e24e/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=fb084a48e2ca663de41b316dc6ece2dceb93e24e", "patch": "@@ -11,6 +11,7 @@ use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPass\n use rustc_plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n+use syntax::symbol::Symbol;\n \n declare_lint! {\n     CRATE_NOT_OKAY,\n@@ -22,7 +23,7 @@ declare_lint_pass!(Pass => [CRATE_NOT_OKAY]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n-        if !attr::contains_name(&krate.attrs, \"crate_okay\") {\n+        if !attr::contains_name(&krate.attrs, Symbol::intern(\"crate_okay\")) {\n             cx.span_lint(CRATE_NOT_OKAY, krate.span,\n                          \"crate is not marked with #![crate_okay]\");\n         }"}]}