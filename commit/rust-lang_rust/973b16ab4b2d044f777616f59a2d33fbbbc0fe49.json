{"sha": "973b16ab4b2d044f777616f59a2d33fbbbc0fe49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3M2IxNmFiNGIyZDA0NGY3Nzc2MTZmNTlhMmQzM2ZiYmJjMGZlNDk=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-30T00:19:58Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-15T18:33:32Z"}, "message": "Enable standalone const-checking with `Validator`\n\nUnlike the original pass, we check *every* non-cleanup basic block\ninstead of stopping at `SwitchInt`. We use the `is_cfg_cyclic` function\nto check for loops unlike the original checker which could not differentiate\nbetween true cycles and basic blocks with more than two predecessors.\n\nThe last three functions are all copied verbatim from `qualify_consts`.", "tree": {"sha": "fd976d4b585d47e17bf5482c7b9b21d1fc754cd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd976d4b585d47e17bf5482c7b9b21d1fc754cd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/973b16ab4b2d044f777616f59a2d33fbbbc0fe49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/973b16ab4b2d044f777616f59a2d33fbbbc0fe49", "html_url": "https://github.com/rust-lang/rust/commit/973b16ab4b2d044f777616f59a2d33fbbbc0fe49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/973b16ab4b2d044f777616f59a2d33fbbbc0fe49/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48811048f853128ad87bc62bb611ecb73522be41", "url": "https://api.github.com/repos/rust-lang/rust/commits/48811048f853128ad87bc62bb611ecb73522be41", "html_url": "https://github.com/rust-lang/rust/commit/48811048f853128ad87bc62bb611ecb73522be41"}], "stats": {"total": 127, "additions": 126, "deletions": 1}, "files": [{"sha": "6687618b7485949854e772a5b3ba90f9d4f715c1", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 126, "deletions": 1, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/973b16ab4b2d044f777616f59a2d33fbbbc0fe49/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/973b16ab4b2d044f777616f59a2d33fbbbc0fe49/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=973b16ab4b2d044f777616f59a2d33fbbbc0fe49", "patch": "@@ -1,14 +1,19 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n+use rustc::hir::HirId;\n+use rustc::middle::lang_items;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n+use rustc::traits::{self, TraitEngine};\n use rustc::ty::cast::CastTy;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc_index::bit_set::BitSet;\n use rustc_target::spec::abi::Abi;\n+use rustc_error_codes::*;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n+use std::borrow::Cow;\n use std::fmt;\n use std::ops::Deref;\n \n@@ -222,6 +227,52 @@ impl Validator<'a, 'mir, 'tcx> {\n         }\n     }\n \n+    pub fn check_body(&mut self) {\n+        let Item { tcx, body, def_id, const_kind, ..  } = *self.item;\n+\n+        let use_min_const_fn_checks =\n+            tcx.is_min_const_fn(def_id)\n+            && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n+\n+        if use_min_const_fn_checks {\n+            // Enforce `min_const_fn` for stable `const fn`s.\n+            use crate::transform::qualify_min_const_fn::is_min_const_fn;\n+            if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n+                error_min_const_fn_violation(tcx, span, err);\n+                return;\n+            }\n+        }\n+\n+        check_short_circuiting_in_const_local(self.item);\n+\n+        // FIXME: give a span for the loop\n+        if body.is_cfg_cyclic() {\n+            // FIXME: make this the `emit_error` impl of `ops::Loop` once the const\n+            // checker is no longer run in compatability mode.\n+            if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                self.tcx.sess.delay_span_bug(\n+                    self.span,\n+                    \"complex control flow is forbidden in a const context\",\n+                );\n+            }\n+        }\n+\n+        self.visit_body(body);\n+\n+        // Ensure that the end result is `Sync` in a non-thread local `static`.\n+        let should_check_for_sync = const_kind == Some(ConstKind::Static)\n+            && !tcx.has_attr(def_id, sym::thread_local);\n+\n+        if should_check_for_sync {\n+            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+            check_return_ty_is_sync(tcx, body, hir_id);\n+        }\n+    }\n+\n+    pub fn qualifs_in_return_place(&mut self) -> QualifSet {\n+        self.qualifs.in_return_place(self.item)\n+    }\n+\n     pub fn take_errors(&mut self) -> Vec<(Span, String)> {\n         std::mem::replace(&mut self.errors, vec![])\n     }\n@@ -264,6 +315,25 @@ impl Validator<'a, 'mir, 'tcx> {\n }\n \n impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n+    fn visit_basic_block_data(\n+        &mut self,\n+        bb: BasicBlock,\n+        block: &BasicBlockData<'tcx>,\n+    ) {\n+        trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n+\n+        // Just as the old checker did, we skip const-checking basic blocks on the unwind path.\n+        // These blocks often drop locals that would otherwise be returned from the function.\n+        //\n+        // FIXME: This shouldn't be unsound since a panic at compile time will cause a compiler\n+        // error anyway, but maybe we should do more here?\n+        if block.is_cleanup {\n+            return;\n+        }\n+\n+        self.super_basic_block_data(bb, block);\n+    }\n+\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n \n@@ -608,3 +678,58 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n }\n+\n+fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>) {\n+    struct_span_err!(tcx.sess, span, E0723, \"{}\", msg)\n+        .note(\"for more information, see issue https://github.com/rust-lang/rust/issues/57563\")\n+        .help(\"add `#![feature(const_fn)]` to the crate attributes to enable\")\n+        .emit();\n+}\n+\n+fn check_short_circuiting_in_const_local(item: &Item<'_, 'tcx>) {\n+    let body = item.body;\n+\n+    if body.control_flow_destroyed.is_empty() {\n+        return;\n+    }\n+\n+    let mut locals = body.vars_iter();\n+    if let Some(local) = locals.next() {\n+        let span = body.local_decls[local].source_info.span;\n+        let mut error = item.tcx.sess.struct_span_err(\n+            span,\n+            &format!(\n+                \"new features like let bindings are not permitted in {}s \\\n+                which also use short circuiting operators\",\n+                item.const_kind(),\n+            ),\n+        );\n+        for (span, kind) in body.control_flow_destroyed.iter() {\n+            error.span_note(\n+                *span,\n+                &format!(\"use of {} here does not actually short circuit due to \\\n+                the const evaluator presently not being able to do control flow. \\\n+                See https://github.com/rust-lang/rust/issues/49146 for more \\\n+                information.\", kind),\n+            );\n+        }\n+        for local in locals {\n+            let span = body.local_decls[local].source_info.span;\n+            error.span_note(span, \"more locals defined here\");\n+        }\n+        error.emit();\n+    }\n+}\n+\n+fn check_return_ty_is_sync(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, hir_id: HirId) {\n+    let ty = body.return_ty();\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let cause = traits::ObligationCause::new(body.span, hir_id, traits::SharedStatic);\n+        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let sync_def_id = tcx.require_lang_item(lang_items::SyncTraitLangItem, Some(body.span));\n+        fulfillment_cx.register_bound(&infcx, ty::ParamEnv::empty(), ty, sync_def_id, cause);\n+        if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(&err, None, false);\n+        }\n+    });\n+}"}]}