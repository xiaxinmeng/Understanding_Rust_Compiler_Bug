{"sha": "1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhOGY1ZWZhYjhjY2Q5ZDVmNmFjNzk0YWIxYmNmOTBiNWVmYTUzNmE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-08T17:24:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-09T14:39:23Z"}, "message": "rustc_codegen_ssa: only \"spill\" SSA-like values to the stack for debuginfo.", "tree": {"sha": "c9c2c60a0e93b808668970645fa9013ae2c38b12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9c2c60a0e93b808668970645fa9013ae2c38b12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "html_url": "https://github.com/rust-lang/rust/commit/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef63e88a9dad54539e1b8510e98e4ed951518c05", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef63e88a9dad54539e1b8510e98e4ed951518c05", "html_url": "https://github.com/rust-lang/rust/commit/ef63e88a9dad54539e1b8510e98e4ed951518c05"}], "stats": {"total": 68, "additions": 35, "deletions": 33}, "files": [{"sha": "7bf222f4701b7ea70a8d1a52b44b929df7a7782b", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "patch": "@@ -8,7 +8,6 @@ use rustc::mir::visit::{\n     MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext, Visitor,\n };\n use rustc::mir::{self, Location, TerminatorKind};\n-use rustc::session::config::DebugInfo;\n use rustc::ty;\n use rustc::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_data_structures::graph::dominators::Dominators;\n@@ -24,15 +23,6 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     analyzer.visit_body(mir);\n \n     for (local, decl) in mir.local_decls.iter_enumerated() {\n-        // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n-        // of putting everything in allocas just so we can use llvm.dbg.declare.\n-        if fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n-            if fx.mir.local_kind(local) == mir::LocalKind::Arg {\n-                analyzer.not_ssa(local);\n-                continue;\n-            }\n-        }\n-\n         let ty = fx.monomorphize(&decl.ty);\n         debug!(\"local {:?} has type `{}`\", local, ty);\n         let layout = fx.cx.spanned_layout_of(ty, decl.source_info.span);\n@@ -281,15 +271,6 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                 self.assign(local, location);\n             }\n \n-            PlaceContext::NonUse(NonUseContext::VarDebugInfo) => {\n-                // We need to keep locals in `alloca`s for debuginfo.\n-                // FIXME(eddyb): We should figure out how to use `llvm.dbg.value` instead\n-                // of putting everything in allocas just so we can use `llvm.dbg.declare`.\n-                if self.fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n-                    self.not_ssa(local);\n-                }\n-            }\n-\n             PlaceContext::NonUse(_) | PlaceContext::MutatingUse(MutatingUseContext::Retag) => {}\n \n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy)"}, {"sha": "e5f21013ce3e32a487c0edd88bafab024c6f65c3", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "patch": "@@ -9,7 +9,8 @@ use rustc_index::vec::IndexVec;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n \n-use super::OperandValue;\n+use super::operand::OperandValue;\n+use super::place::PlaceRef;\n use super::{FunctionCx, LocalRef};\n \n pub struct FunctionDebugContext<D> {\n@@ -111,8 +112,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     /// Apply debuginfo and/or name, after creating the `alloca` for a local,\n     /// or initializing the local with an operand (whichever applies).\n-    // FIXME(eddyb) use `llvm.dbg.value` (which would work for operands),\n-    // not just `llvm.dbg.declare` (which requires `alloca`).\n     pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n         let full_debug_info = bx.sess().opts.debuginfo == DebugInfo::Full;\n \n@@ -180,38 +179,60 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let local_ref = &self.locals[local];\n \n-        if !bx.sess().fewer_names() {\n-            let name = match whole_local_var.or(fallback_var) {\n+        let name = if bx.sess().fewer_names() {\n+            None\n+        } else {\n+            Some(match whole_local_var.or(fallback_var) {\n                 Some(var) if var.name != kw::Invalid => var.name.to_string(),\n                 _ => format!(\"{:?}\", local),\n-            };\n+            })\n+        };\n+\n+        if let Some(name) = &name {\n             match local_ref {\n                 LocalRef::Place(place) | LocalRef::UnsizedPlace(place) => {\n-                    bx.set_var_name(place.llval, &name);\n+                    bx.set_var_name(place.llval, name);\n                 }\n                 LocalRef::Operand(Some(operand)) => match operand.val {\n                     OperandValue::Ref(x, ..) | OperandValue::Immediate(x) => {\n-                        bx.set_var_name(x, &name);\n+                        bx.set_var_name(x, name);\n                     }\n                     OperandValue::Pair(a, b) => {\n                         // FIXME(eddyb) these are scalar components,\n                         // maybe extract the high-level fields?\n                         bx.set_var_name(a, &(name.clone() + \".0\"));\n-                        bx.set_var_name(b, &(name + \".1\"));\n+                        bx.set_var_name(b, &(name.clone() + \".1\"));\n                     }\n                 },\n                 LocalRef::Operand(None) => {}\n             }\n         }\n \n-        if !full_debug_info {\n+        if !full_debug_info || vars.is_empty() && fallback_var.is_none() {\n             return;\n         }\n \n-        // FIXME(eddyb) add debuginfo for unsized places too.\n         let base = match local_ref {\n-            LocalRef::Place(place) => place,\n-            _ => return,\n+            LocalRef::Operand(None) => return,\n+\n+            LocalRef::Operand(Some(operand)) => {\n+                // \"Spill\" the value onto the stack, for debuginfo,\n+                // without forcing non-debuginfo uses of the local\n+                // to also load from the stack every single time.\n+                // FIXME(#68817) use `llvm.dbg.value` instead,\n+                // at least for the cases which LLVM handles correctly.\n+                let spill_slot = PlaceRef::alloca(bx, operand.layout);\n+                if let Some(name) = name {\n+                    bx.set_var_name(spill_slot.llval, &(name + \".dbg.spill\"));\n+                }\n+                operand.val.store(bx, spill_slot);\n+                spill_slot\n+            }\n+\n+            LocalRef::Place(place) => *place,\n+\n+            // FIXME(eddyb) add debuginfo for unsized places too.\n+            LocalRef::UnsizedPlace(_) => return,\n         };\n \n         let vars = vars.iter().copied().chain(fallback_var);"}, {"sha": "389221cbbf15104c64c7a962fe322c7726722f04", "filename": "src/test/debuginfo/issue-12886.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a/src%2Ftest%2Fdebuginfo%2Fissue-12886.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a/src%2Ftest%2Fdebuginfo%2Fissue-12886.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue-12886.rs?ref=1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "patch": "@@ -6,7 +6,7 @@\n \n // gdb-command:run\n // gdb-command:next\n-// gdb-check:[...]25[...]s\n+// gdb-check:[...]24[...]let s = Some(5).unwrap(); // #break\n // gdb-command:continue\n \n #![feature(omit_gdb_pretty_printer_section)]"}]}