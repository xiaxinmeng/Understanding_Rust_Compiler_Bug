{"sha": "ce0d64e03ef9875e0935bb60e989542b7ec29579", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMGQ2NGUwM2VmOTg3NWUwOTM1YmI2MGU5ODk1NDJiN2VjMjk1Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-28T08:49:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-28T08:49:48Z"}, "message": "Auto merge of #85546 - hyd-dev:unwind, r=RalfJung\n\nconst-eval: disallow unwinding across functions that `!fn_can_unwind()`\n\nFollowing https://github.com/rust-lang/miri/pull/1776#discussion_r633074343, so r? `@RalfJung`\n\nThis PR turns `unwind` in `StackPopCleanup::Goto` into a new enum `StackPopUnwind`, with a `NotAllowed` variant to indicate that unwinding is not allowed. This variant is chosen based on `rustc_middle::ty::layout::fn_can_unwind()` in `eval_fn_call()` when pushing the frame. A check is added in `unwind_to_block()` to report UB if unwinding happens across a `StackPopUnwind::NotAllowed` frame.\n\nTested with Miri `HEAD` with [minor changes](https://github.com/rust-lang/miri/compare/HEAD..9cf3c7f0d86325a586fbcbf2acdc9232b861f1d8) and the rust-lang/miri#1776 branch with [these changes](https://github.com/rust-lang/miri/compare/d866c1c52f48bf562720383455b75c257bb1ad92..626638fbfe2fff34648dda29a34d59db498a6e52).", "tree": {"sha": "759e3bb5281ff07fc4fbf0d182a44afb9471b970", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/759e3bb5281ff07fc4fbf0d182a44afb9471b970"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce0d64e03ef9875e0935bb60e989542b7ec29579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce0d64e03ef9875e0935bb60e989542b7ec29579", "html_url": "https://github.com/rust-lang/rust/commit/ce0d64e03ef9875e0935bb60e989542b7ec29579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce0d64e03ef9875e0935bb60e989542b7ec29579/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18135ec85be45df013ecd0d1eb4a49128d043e20", "url": "https://api.github.com/repos/rust-lang/rust/commits/18135ec85be45df013ecd0d1eb4a49128d043e20", "html_url": "https://github.com/rust-lang/rust/commit/18135ec85be45df013ecd0d1eb4a49128d043e20"}, {"sha": "f6348f1924626ea15bc6c4e6be3f525f891767e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6348f1924626ea15bc6c4e6be3f525f891767e3", "html_url": "https://github.com/rust-lang/rust/commit/f6348f1924626ea15bc6c4e6be3f525f891767e3"}], "stats": {"total": 262, "additions": 168, "deletions": 94}, "files": [{"sha": "03a026500d70259c0db2ae0620362e532253427d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=ce0d64e03ef9875e0935bb60e989542b7ec29579", "patch": "@@ -2579,7 +2579,7 @@ where\n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n }\n \n-fn fn_can_unwind(\n+pub fn fn_can_unwind(\n     panic_strategy: PanicStrategy,\n     codegen_fn_attr_flags: CodegenFnAttrFlags,\n     call_conv: Conv,\n@@ -2641,6 +2641,43 @@ fn fn_can_unwind(\n     }\n }\n \n+pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n+    use rustc_target::spec::abi::Abi::*;\n+    match tcx.sess.target.adjust_abi(abi) {\n+        RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n+\n+        // It's the ABI's job to select this, not ours.\n+        System { .. } => bug!(\"system abi should be selected elsewhere\"),\n+        EfiApi => bug!(\"eficall abi should be selected elsewhere\"),\n+\n+        Stdcall { .. } => Conv::X86Stdcall,\n+        Fastcall => Conv::X86Fastcall,\n+        Vectorcall => Conv::X86VectorCall,\n+        Thiscall { .. } => Conv::X86ThisCall,\n+        C { .. } => Conv::C,\n+        Unadjusted => Conv::C,\n+        Win64 => Conv::X86_64Win64,\n+        SysV64 => Conv::X86_64SysV,\n+        Aapcs => Conv::ArmAapcs,\n+        CCmseNonSecureCall => Conv::CCmseNonSecureCall,\n+        PtxKernel => Conv::PtxKernel,\n+        Msp430Interrupt => Conv::Msp430Intr,\n+        X86Interrupt => Conv::X86Intr,\n+        AmdGpuKernel => Conv::AmdGpuKernel,\n+        AvrInterrupt => Conv::AvrInterrupt,\n+        AvrNonBlockingInterrupt => Conv::AvrNonBlockingInterrupt,\n+        Wasm => Conv::C,\n+\n+        // These API constants ought to be more specific...\n+        Cdecl => Conv::C,\n+    }\n+}\n+\n+pub fn fn_ptr_codegen_fn_attr_flags() -> CodegenFnAttrFlags {\n+    // Assume that fn pointers may always unwind\n+    CodegenFnAttrFlags::UNWIND\n+}\n+\n impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n     C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n@@ -2650,10 +2687,7 @@ where\n         + HasParamEnv<'tcx>,\n {\n     fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        // Assume that fn pointers may always unwind\n-        let codegen_fn_attr_flags = CodegenFnAttrFlags::UNWIND;\n-\n-        call::FnAbi::new_internal(cx, sig, extra_args, None, codegen_fn_attr_flags, false)\n+        call::FnAbi::new_internal(cx, sig, extra_args, None, fn_ptr_codegen_fn_attr_flags(), false)\n     }\n \n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n@@ -2689,35 +2723,7 @@ where\n \n         let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n \n-        use rustc_target::spec::abi::Abi::*;\n-        let conv = match cx.tcx().sess.target.adjust_abi(sig.abi) {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n-\n-            // It's the ABI's job to select this, not ours.\n-            System { .. } => bug!(\"system abi should be selected elsewhere\"),\n-            EfiApi => bug!(\"eficall abi should be selected elsewhere\"),\n-\n-            Stdcall { .. } => Conv::X86Stdcall,\n-            Fastcall => Conv::X86Fastcall,\n-            Vectorcall => Conv::X86VectorCall,\n-            Thiscall { .. } => Conv::X86ThisCall,\n-            C { .. } => Conv::C,\n-            Unadjusted => Conv::C,\n-            Win64 => Conv::X86_64Win64,\n-            SysV64 => Conv::X86_64SysV,\n-            Aapcs => Conv::ArmAapcs,\n-            CCmseNonSecureCall => Conv::CCmseNonSecureCall,\n-            PtxKernel => Conv::PtxKernel,\n-            Msp430Interrupt => Conv::Msp430Intr,\n-            X86Interrupt => Conv::X86Intr,\n-            AmdGpuKernel => Conv::AmdGpuKernel,\n-            AvrInterrupt => Conv::AvrInterrupt,\n-            AvrNonBlockingInterrupt => Conv::AvrNonBlockingInterrupt,\n-            Wasm => Conv::C,\n-\n-            // These API constants ought to be more specific...\n-            Cdecl => Conv::C,\n-        };\n+        let conv = conv_from_spec_abi(cx.tcx(), sig.abi);\n \n         let mut inputs = sig.inputs();\n         let extra_args = if sig.abi == RustCall {\n@@ -2753,6 +2759,7 @@ where\n             target.os == \"linux\" && target.arch == \"sparc64\" && target_env_gnu_like;\n         let linux_powerpc_gnu_like =\n             target.os == \"linux\" && target.arch == \"powerpc\" && target_env_gnu_like;\n+        use SpecAbi::*;\n         let rust_abi = matches!(sig.abi, RustIntrinsic | PlatformIntrinsic | Rust | RustCall);\n \n         // Handle safe Rust thin and fat pointers."}, {"sha": "773df7d7b60c14f2f1142837d05aa0778fe16a50", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=ce0d64e03ef9875e0935bb60e989542b7ec29579", "patch": "@@ -17,7 +17,7 @@ use rustc_target::spec::abi::Abi;\n \n use crate::interpret::{\n     self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, InterpCx, InterpResult, Memory,\n-    OpTy, PlaceTy, Pointer, Scalar,\n+    OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n };\n \n use super::error::*;\n@@ -223,7 +223,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _abi: Abi,\n         args: &[OpTy<'tcx>],\n         _ret: Option<(&PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n+        _unwind: StackPopUnwind, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n \n@@ -263,7 +263,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         ret: Option<(&PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>,\n+        _unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n         // Shared intrinsics.\n         if ecx.emulate_intrinsic(instance, args, ret)? {"}, {"sha": "6f7519e61561b6acb0125ab81a8ea25782f0390d", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=ce0d64e03ef9875e0935bb60e989542b7ec29579", "patch": "@@ -134,14 +134,25 @@ pub struct FrameInfo<'tcx> {\n     pub lint_root: Option<hir::HirId>,\n }\n \n-#[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n+/// Unwind information.\n+#[derive(Clone, Copy, Eq, PartialEq, Debug, HashStable)]\n+pub enum StackPopUnwind {\n+    /// The cleanup block.\n+    Cleanup(mir::BasicBlock),\n+    /// No cleanup needs to be done.\n+    Skip,\n+    /// Unwinding is not allowed (UB).\n+    NotAllowed,\n+}\n+\n+#[derive(Clone, Copy, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n     /// we can validate it at that layout.\n     /// `ret` stores the block we jump to on a normal return, while `unwind`\n     /// stores the block used for cleanup during unwinding.\n-    Goto { ret: Option<mir::BasicBlock>, unwind: Option<mir::BasicBlock> },\n+    Goto { ret: Option<mir::BasicBlock>, unwind: StackPopUnwind },\n     /// Just do nothing: Used by Main and for the `box_alloc` hook in miri.\n     /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n@@ -746,13 +757,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// *Unwind* to the given `target` basic block.\n     /// Do *not* use for returning! Use `return_to_block` instead.\n     ///\n-    /// If `target` is `None`, that indicates the function does not need cleanup during\n-    /// unwinding, and we will just keep propagating that upwards.\n-    pub fn unwind_to_block(&mut self, target: Option<mir::BasicBlock>) {\n+    /// If `target` is `StackPopUnwind::Skip`, that indicates the function does not need cleanup\n+    /// during unwinding, and we will just keep propagating that upwards.\n+    ///\n+    /// If `target` is `StackPopUnwind::NotAllowed`, that indicates the function does not allow\n+    /// unwinding, and doing so is UB.\n+    pub fn unwind_to_block(&mut self, target: StackPopUnwind) -> InterpResult<'tcx> {\n         self.frame_mut().loc = match target {\n-            Some(block) => Ok(mir::Location { block, statement_index: 0 }),\n-            None => Err(self.frame_mut().body.span),\n+            StackPopUnwind::Cleanup(block) => Ok(mir::Location { block, statement_index: 0 }),\n+            StackPopUnwind::Skip => Err(self.frame_mut().body.span),\n+            StackPopUnwind::NotAllowed => {\n+                throw_ub_format!(\"unwinding past a stack frame that does not allow unwinding\")\n+            }\n         };\n+        Ok(())\n     }\n \n     /// Pops the current frame from the stack, deallocating the\n@@ -801,21 +819,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n+        let return_to_block = frame.return_to_block;\n+\n         // Now where do we jump next?\n \n         // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n         // In that case, we return early. We also avoid validation in that case,\n         // because this is CTFE and the final value will be thoroughly validated anyway.\n-        let (cleanup, next_block) = match frame.return_to_block {\n-            StackPopCleanup::Goto { ret, unwind } => {\n-                (true, Some(if unwinding { unwind } else { ret }))\n-            }\n-            StackPopCleanup::None { cleanup, .. } => (cleanup, None),\n+        let cleanup = match return_to_block {\n+            StackPopCleanup::Goto { .. } => true,\n+            StackPopCleanup::None { cleanup, .. } => cleanup,\n         };\n \n         if !cleanup {\n             assert!(self.stack().is_empty(), \"only the topmost frame should ever be leaked\");\n-            assert!(next_block.is_none(), \"tried to skip cleanup when we have a next block!\");\n             assert!(!unwinding, \"tried to skip cleanup during unwinding\");\n             // Leak the locals, skip validation, skip machine hook.\n             return Ok(());\n@@ -834,16 +851,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Normal return, figure out where to jump.\n         if unwinding {\n             // Follow the unwind edge.\n-            let unwind = next_block.expect(\"Encountered StackPopCleanup::None when unwinding!\");\n-            self.unwind_to_block(unwind);\n+            let unwind = match return_to_block {\n+                StackPopCleanup::Goto { unwind, .. } => unwind,\n+                StackPopCleanup::None { .. } => {\n+                    panic!(\"Encountered StackPopCleanup::None when unwinding!\")\n+                }\n+            };\n+            self.unwind_to_block(unwind)\n         } else {\n             // Follow the normal return edge.\n-            if let Some(ret) = next_block {\n-                self.return_to_block(ret)?;\n+            match return_to_block {\n+                StackPopCleanup::Goto { ret, .. } => self.return_to_block(ret),\n+                StackPopCleanup::None { .. } => Ok(()),\n             }\n         }\n-\n-        Ok(())\n     }\n \n     /// Mark a storage as live, killing the previous content."}, {"sha": "0d01dc3c219bc908931de3fc686326cb9f07aa9b", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=ce0d64e03ef9875e0935bb60e989542b7ec29579", "patch": "@@ -14,7 +14,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     AllocId, Allocation, CheckInAllocMsg, Frame, ImmTy, InterpCx, InterpResult, LocalValue,\n-    MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar,\n+    MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar, StackPopUnwind,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -163,7 +163,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         abi: Abi,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n-        unwind: Option<mir::BasicBlock>,\n+        unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n     /// Execute `fn_val`.  It is the hook's responsibility to advance the instruction\n@@ -174,7 +174,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         abi: Abi,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n-        unwind: Option<mir::BasicBlock>,\n+        unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx>;\n \n     /// Directly process an intrinsic without pushing a stack frame. It is the hook's\n@@ -184,7 +184,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n-        unwind: Option<mir::BasicBlock>,\n+        unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx>;\n \n     /// Called to evaluate `Assert` MIR terminators that trigger a panic.\n@@ -456,7 +456,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         _abi: Abi,\n         _args: &[OpTy<$tcx>],\n         _ret: Option<(&PlaceTy<$tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>,\n+        _unwind: StackPopUnwind,\n     ) -> InterpResult<$tcx> {\n         match fn_val {}\n     }"}, {"sha": "2b9fe56599715b6fd87db2f9104242b507d485f0", "filename": "compiler/rustc_mir/src/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs?ref=ce0d64e03ef9875e0935bb60e989542b7ec29579", "patch": "@@ -18,7 +18,9 @@ mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n-pub use self::eval_context::{Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup};\n+pub use self::eval_context::{\n+    Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup, StackPopUnwind,\n+};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n pub use self::memory::{AllocCheck, AllocRef, AllocRefMut, FnVal, Memory, MemoryKind};"}, {"sha": "a5bdeb55e781402d0685a382acea085a3af67776", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 73, "deletions": 30, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=ce0d64e03ef9875e0935bb60e989542b7ec29579", "patch": "@@ -1,7 +1,8 @@\n use std::borrow::Cow;\n use std::convert::TryFrom;\n \n-use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::Instance;\n use rustc_middle::{\n     mir,\n@@ -12,9 +13,19 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, StackPopCleanup,\n+    StackPopUnwind,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    fn fn_can_unwind(&self, attrs: CodegenFnAttrFlags, abi: Abi) -> bool {\n+        layout::fn_can_unwind(\n+            self.tcx.sess.panic_strategy(),\n+            attrs,\n+            layout::conv_from_spec_abi(*self.tcx, abi),\n+            abi,\n+        )\n+    }\n+\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -58,12 +69,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n-                let (fn_val, abi) = match *func.layout.ty.kind() {\n+                let (fn_val, abi, caller_can_unwind) = match *func.layout.ty.kind() {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n                         let fn_ptr = self.read_scalar(&func)?.check_init()?;\n                         let fn_val = self.memory.get_fn(fn_ptr)?;\n-                        (fn_val, caller_abi)\n+                        (\n+                            fn_val,\n+                            caller_abi,\n+                            self.fn_can_unwind(layout::fn_ptr_codegen_fn_attr_flags(), caller_abi),\n+                        )\n                     }\n                     ty::FnDef(def_id, substs) => {\n                         let sig = func.layout.ty.fn_sig(*self.tcx);\n@@ -72,6 +87,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 self.resolve(ty::WithOptConstParam::unknown(def_id), substs)?,\n                             ),\n                             sig.abi(),\n+                            self.fn_can_unwind(self.tcx.codegen_fn_attrs(def_id).flags, sig.abi()),\n                         )\n                     }\n                     _ => span_bug!(\n@@ -89,7 +105,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     None => None,\n                 };\n-                self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n+                self.eval_fn_call(\n+                    fn_val,\n+                    abi,\n+                    &args[..],\n+                    ret,\n+                    match (cleanup, caller_can_unwind) {\n+                        (Some(cleanup), true) => StackPopUnwind::Cleanup(*cleanup),\n+                        (None, true) => StackPopUnwind::Skip,\n+                        (_, false) => StackPopUnwind::NotAllowed,\n+                    },\n+                )?;\n                 // Sanity-check that `eval_fn_call` either pushed a new frame or\n                 // did a jump to another block.\n                 if self.frame_idx() == old_stack && self.frame().loc == old_loc {\n@@ -219,7 +245,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         ret: Option<(&PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n-        unwind: Option<mir::BasicBlock>,\n+        mut unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n \n@@ -230,37 +256,38 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         };\n \n+        let get_abi = |this: &Self, instance_ty: Ty<'tcx>| match instance_ty.kind() {\n+            ty::FnDef(..) => instance_ty.fn_sig(*this.tcx).abi(),\n+            ty::Closure(..) => Abi::RustCall,\n+            ty::Generator(..) => Abi::Rust,\n+            _ => span_bug!(this.cur_span(), \"unexpected callee ty: {:?}\", instance_ty),\n+        };\n+\n         // ABI check\n-        let check_abi = |this: &Self, instance_ty: Ty<'tcx>| -> InterpResult<'tcx> {\n-            if M::enforce_abi(this) {\n-                let callee_abi = match instance_ty.kind() {\n-                    ty::FnDef(..) => instance_ty.fn_sig(*this.tcx).abi(),\n-                    ty::Closure(..) => Abi::RustCall,\n-                    ty::Generator(..) => Abi::Rust,\n-                    _ => span_bug!(this.cur_span(), \"unexpected callee ty: {:?}\", instance_ty),\n-                };\n-                let normalize_abi = |abi| match abi {\n-                    Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic =>\n-                    // These are all the same ABI, really.\n-                    {\n-                        Abi::Rust\n-                    }\n-                    abi => abi,\n-                };\n-                if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                    throw_ub_format!(\n-                        \"calling a function with ABI {} using caller ABI {}\",\n-                        callee_abi.name(),\n-                        caller_abi.name()\n-                    )\n+        let check_abi = |callee_abi: Abi| -> InterpResult<'tcx> {\n+            let normalize_abi = |abi| match abi {\n+                Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic =>\n+                // These are all the same ABI, really.\n+                {\n+                    Abi::Rust\n                 }\n+                abi => abi,\n+            };\n+            if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n+                throw_ub_format!(\n+                    \"calling a function with ABI {} using caller ABI {}\",\n+                    callee_abi.name(),\n+                    caller_abi.name()\n+                )\n             }\n             Ok(())\n         };\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n-                check_abi(self, instance.ty(*self.tcx, self.param_env))?;\n+                if M::enforce_abi(self) {\n+                    check_abi(get_abi(self, instance.ty(*self.tcx, self.param_env)))?;\n+                }\n                 assert!(caller_abi == Abi::RustIntrinsic || caller_abi == Abi::PlatformIntrinsic);\n                 M::call_intrinsic(self, instance, args, ret, unwind)\n             }\n@@ -281,7 +308,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Check against the ABI of the MIR body we are calling (not the ABI of `instance`;\n                 // these can differ when `find_mir_or_eval_fn` does something clever like resolve\n                 // exported symbol names).\n-                check_abi(self, self.tcx.type_of(body.source.def_id()))?;\n+                let callee_def_id = body.source.def_id();\n+                let callee_abi = get_abi(self, self.tcx.type_of(callee_def_id));\n+\n+                if M::enforce_abi(self) {\n+                    check_abi(callee_abi)?;\n+                }\n+\n+                if !matches!(unwind, StackPopUnwind::NotAllowed)\n+                    && !self\n+                        .fn_can_unwind(self.tcx.codegen_fn_attrs(callee_def_id).flags, callee_abi)\n+                {\n+                    // The callee cannot unwind.\n+                    unwind = StackPopUnwind::NotAllowed;\n+                }\n \n                 self.push_stack_frame(\n                     instance,\n@@ -471,7 +511,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Abi::Rust,\n             &[arg.into()],\n             Some((&dest.into(), target)),\n-            unwind,\n+            match unwind {\n+                Some(cleanup) => StackPopUnwind::Cleanup(cleanup),\n+                None => StackPopUnwind::Skip,\n+            },\n         )\n     }\n }"}, {"sha": "681d63c6fc9664c7116368a79fb9b5e49ec29717", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0d64e03ef9875e0935bb60e989542b7ec29579/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=ce0d64e03ef9875e0935bb60e989542b7ec29579", "patch": "@@ -33,6 +33,7 @@ use crate::interpret::{\n     self, compile_time_machine, AllocId, Allocation, ConstValue, CtfeValidationMode, Frame, ImmTy,\n     Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy,\n     Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup,\n+    StackPopUnwind,\n };\n use crate::transform::MirPass;\n \n@@ -198,7 +199,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _abi: Abi,\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n-        _unwind: Option<BasicBlock>,\n+        _unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n         Ok(None)\n     }\n@@ -208,7 +209,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n-        _unwind: Option<BasicBlock>,\n+        _unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n         throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n     }"}]}