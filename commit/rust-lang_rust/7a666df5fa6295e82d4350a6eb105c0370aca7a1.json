{"sha": "7a666df5fa6295e82d4350a6eb105c0370aca7a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNjY2ZGY1ZmE2Mjk1ZTgyZDQzNTBhNmViMTA1YzAzNzBhY2E3YTE=", "commit": {"author": {"name": "Colin Sherratt", "email": "colin.sherratt@gmail.com", "date": "2014-10-19T20:19:07Z"}, "committer": {"name": "Colin Sherratt", "email": "colin.sherratt@gmail.com", "date": "2014-11-14T08:41:07Z"}, "message": "Expand the benchmarking and unit test suite for ring_buf.\n-Adds unit tests for fn get() and fn get_mut() which are currently untested\n-Adds unit tests to verify growth of the ringbuffer when reserve is called.\n-Adds unit tests to confirm that dropping of items is correct\nMove ringbuf to use a raw buffer instead of Option<T>", "tree": {"sha": "0fe1336d655e265cf4c3bf2bfe455a8b4a659f62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fe1336d655e265cf4c3bf2bfe455a8b4a659f62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a666df5fa6295e82d4350a6eb105c0370aca7a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a666df5fa6295e82d4350a6eb105c0370aca7a1", "html_url": "https://github.com/rust-lang/rust/commit/7a666df5fa6295e82d4350a6eb105c0370aca7a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a666df5fa6295e82d4350a6eb105c0370aca7a1/comments", "author": {"login": "csherratt", "id": 26073376, "node_id": "MDQ6VXNlcjI2MDczMzc2", "avatar_url": "https://avatars.githubusercontent.com/u/26073376?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csherratt", "html_url": "https://github.com/csherratt", "followers_url": "https://api.github.com/users/csherratt/followers", "following_url": "https://api.github.com/users/csherratt/following{/other_user}", "gists_url": "https://api.github.com/users/csherratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/csherratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csherratt/subscriptions", "organizations_url": "https://api.github.com/users/csherratt/orgs", "repos_url": "https://api.github.com/users/csherratt/repos", "events_url": "https://api.github.com/users/csherratt/events{/privacy}", "received_events_url": "https://api.github.com/users/csherratt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csherratt", "id": 26073376, "node_id": "MDQ6VXNlcjI2MDczMzc2", "avatar_url": "https://avatars.githubusercontent.com/u/26073376?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csherratt", "html_url": "https://github.com/csherratt", "followers_url": "https://api.github.com/users/csherratt/followers", "following_url": "https://api.github.com/users/csherratt/following{/other_user}", "gists_url": "https://api.github.com/users/csherratt/gists{/gist_id}", "starred_url": "https://api.github.com/users/csherratt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csherratt/subscriptions", "organizations_url": "https://api.github.com/users/csherratt/orgs", "repos_url": "https://api.github.com/users/csherratt/repos", "events_url": "https://api.github.com/users/csherratt/events{/privacy}", "received_events_url": "https://api.github.com/users/csherratt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f7081fad5889c7b41460103fc8abc98f3285c60", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f7081fad5889c7b41460103fc8abc98f3285c60", "html_url": "https://github.com/rust-lang/rust/commit/6f7081fad5889c7b41460103fc8abc98f3285c60"}], "stats": {"total": 685, "additions": 486, "deletions": 199}, "files": [{"sha": "fcf9e33cc9d9e7a93b15925cd13d49d45d656ee6", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 486, "deletions": 199, "changes": 685, "blob_url": "https://github.com/rust-lang/rust/blob/7a666df5fa6295e82d4350a6eb105c0370aca7a1/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a666df5fa6295e82d4350a6eb105c0370aca7a1/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=7a666df5fa6295e82d4350a6eb105c0370aca7a1", "patch": "@@ -15,14 +15,19 @@\n \n use core::prelude::*;\n \n-use core::cmp;\n use core::default::Default;\n use core::fmt;\n use core::iter;\n-use core::slice;\n+use core::raw::Slice as RawSlice;\n+use core::ptr;\n+use core::kinds::marker;\n+use core::mem;\n+use core::num;\n+\n use std::hash::{Writer, Hash};\n+use std::cmp;\n \n-use vec::Vec;\n+use alloc::heap;\n \n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n@@ -33,18 +38,68 @@ static MINIMUM_CAPACITY: uint = 2u;\n \n \n /// `RingBuf` is a circular buffer that implements `Deque`.\n-#[deriving(Clone)]\n pub struct RingBuf<T> {\n-    nelts: uint,\n-    lo: uint,\n-    elts: Vec<Option<T>>\n+    // tail and head are pointers into the buffer. Tail always points\n+    // to the first element that could be read, Head always points\n+    // to where data should be written.\n+    // If tail == head the buffer is empty. The length of the ringbuf\n+    // is defined as the distance between the two.\n+\n+    tail: uint,\n+    head: uint,\n+    cap: uint,\n+    ptr: *mut T\n+}\n+\n+impl<T: Clone> Clone for RingBuf<T> {\n+    fn clone(&self) -> RingBuf<T> {\n+        self.iter().map(|t| t.clone()).collect()\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for RingBuf<T> {\n+    fn drop(&mut self) {\n+        self.clear();\n+        unsafe {\n+            if mem::size_of::<T>() != 0 {\n+                heap::deallocate(self.ptr as *mut u8,\n+                                 self.cap * mem::size_of::<T>(),\n+                                 mem::min_align_of::<T>())\n+            }\n+        }\n+    }\n }\n \n impl<T> Default for RingBuf<T> {\n     #[inline]\n     fn default() -> RingBuf<T> { RingBuf::new() }\n }\n \n+impl<T> RingBuf<T> {\n+    /// Turn ptr into a slice\n+    #[inline]\n+    unsafe fn buffer_as_slice(&self) -> &[T] {\n+        mem::transmute(RawSlice { data: self.ptr as *const T, len: self.cap })\n+    }\n+\n+    /// Moves an element out of the buffer\n+    #[inline]\n+    unsafe fn buffer_read(&mut self, off: uint) -> T {\n+        ptr::read(self.ptr.offset(off as int) as *const T)\n+    }\n+\n+    /// Writes an element into the buffer, moving it.\n+    #[inline]\n+    unsafe fn buffer_write(&mut self, off: uint, t: T) {\n+        ptr::write(self.ptr.offset(off as int), t);\n+    }\n+\n+    /// Returns true iff the buffer is at capacity\n+    #[inline]\n+    fn is_full(&self) -> bool { self.cap - self.len() == 1 }\n+}\n+\n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n@@ -55,8 +110,21 @@ impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n-        RingBuf{nelts: 0, lo: 0,\n-              elts: Vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n+        // +1 since the ringbuffer always leaves one space empty\n+        let cap = num::next_power_of_two(cmp::max(n + 1, MINIMUM_CAPACITY));\n+        let size = cap.checked_mul(&mem::size_of::<T>())\n+                      .expect(\"capacity overflow\");\n+\n+        RingBuf {\n+            tail: 0,\n+            head: 0,\n+            cap: cap,\n+            ptr: if mem::size_of::<T>() != 0 {\n+                unsafe { heap::allocate(size, mem::min_align_of::<T>()) as *mut T }\n+            } else {\n+                heap::EMPTY as *mut T\n+            }\n+        }\n     }\n \n     /// Retrieves an element in the `RingBuf` by index.\n@@ -74,9 +142,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn get(&self, i: uint) -> Option<&T> {\n-        match self.elts.get(i) {\n-            None => None,\n-            Some(opt) => opt.as_ref(),\n+        if i < self.len() {\n+            let idx = wrap_index(self.tail + i, self.cap);\n+            unsafe { Some(&*self.ptr.offset(idx as int)) }\n+        } else {\n+            None\n         }\n     }\n \n@@ -102,9 +172,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n-        match self.elts.get_mut(i) {\n-            None => None,\n-            Some(opt) => opt.as_mut(),\n+        if i < self.len() {\n+            let idx = wrap_index(self.tail + i, self.cap);\n+            unsafe { Some(&mut *self.ptr.offset(idx as int)) }\n+        } else {\n+            None\n         }\n     }\n \n@@ -130,15 +202,11 @@ impl<T> RingBuf<T> {\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n-        let ri = self.raw_index(i);\n-        let rj = self.raw_index(j);\n-        self.elts.as_mut_slice().swap(ri, rj);\n-    }\n-\n-    /// Returns the index in the underlying `Vec` for a given logical element\n-    /// index.\n-    fn raw_index(&self, idx: uint) -> uint {\n-        raw_index(self.lo, self.elts.len(), idx)\n+        let ri = wrap_index(self.tail + i, self.cap);\n+        let rj = wrap_index(self.tail + j, self.cap);\n+        unsafe {\n+            ptr::swap(self.ptr.offset(ri as int), self.ptr.offset(rj as int))\n+        }\n     }\n \n     /// Returns the number of elements the `RingBuf` can hold without\n@@ -150,14 +218,11 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let buf: RingBuf<int> = RingBuf::with_capacity(10);\n-    /// assert_eq!(buf.capacity(), 10);\n+    /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn capacity(&self) -> uint {\n-        // FXIME(Gankro): not the actual usable capacity if you use reserve/reserve_exact\n-        self.elts.capacity()\n-    }\n+    pub fn capacity(&self) -> uint { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n@@ -181,8 +246,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) {\n-        // FIXME(Gankro): this is just wrong. The ringbuf won't actually use this space\n-        self.elts.reserve_exact(additional);\n+        self.reserve(additional);\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n@@ -203,8 +267,63 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n-        // FIXME(Gankro): this is just wrong. The ringbuf won't actually use this space\n-        self.elts.reserve(additional);\n+        let new_len = self.len() + additional;\n+        assert!(new_len + 1 > self.len(), \"capacity overflow\");\n+        if new_len > self.capacity() {\n+            let count = num::next_power_of_two(new_len + 1);\n+            assert!(count >= new_len + 1);\n+\n+            if mem::size_of::<T>() != 0 {\n+                let old = self.cap * mem::size_of::<T>();\n+                let new = count.checked_mul(&mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n+                unsafe {\n+                    self.ptr = heap::reallocate(self.ptr as *mut u8,\n+                                                old,\n+                                                new,\n+                                                mem::min_align_of::<T>()) as *mut T;\n+                }\n+            }\n+\n+            // Move the shortest contiguous section of the ring buffer\n+            //    T             H\n+            //   [o o o o o o o . ]\n+            //    T             H\n+            // A [o o o o o o o . . . . . . . . . ]\n+            //        H T\n+            //   [o o . o o o o o ]\n+            //          T             H\n+            // B [. . . o o o o o o o . . . . . . ]\n+            //              H T\n+            //   [o o o o o . o o ]\n+            //              H                 T\n+            // C [o o o o o . . . . . . . . . o o ]\n+\n+            let oldcap = self.cap;\n+            self.cap = count;\n+\n+            if self.tail <= self.head { // A\n+                // Nop\n+            } else if self.head < oldcap - self.tail { // B\n+                unsafe {\n+                    ptr::copy_nonoverlapping_memory(\n+                        self.ptr.offset(oldcap as int),\n+                        self.ptr as *const T,\n+                        self.head\n+                    );\n+                }\n+                self.head += oldcap;\n+            } else { // C\n+                unsafe {\n+                    ptr::copy_nonoverlapping_memory(\n+                        self.ptr.offset((count - (oldcap - self.tail)) as int),\n+                        self.ptr.offset(self.tail as int) as *const T,\n+                        oldcap - self.tail\n+                    );\n+                }\n+                self.tail = count - (oldcap - self.tail);\n+            }\n+        }\n     }\n \n     /// Returns a front-to-back iterator.\n@@ -223,7 +342,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Items<T> {\n-        Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n+        Items {\n+            tail: self.tail,\n+            head: self.head,\n+            ring: unsafe { self.buffer_as_slice() }\n+        }\n     }\n \n     /// Returns a front-to-back iterator which returns mutable references.\n@@ -244,32 +367,14 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn iter_mut(&mut self) -> MutItems<T> {\n-        let start_index = raw_index(self.lo, self.elts.len(), 0);\n-        let end_index = raw_index(self.lo, self.elts.len(), self.nelts);\n-\n-        // Divide up the array\n-        if end_index <= start_index {\n-            // Items to iterate goes from:\n-            //    start_index to self.elts.len()\n-            // and then\n-            //    0 to end_index\n-            let (temp, remaining1) = self.elts.split_at_mut(start_index);\n-            let (remaining2, _) = temp.split_at_mut(end_index);\n-            MutItems {\n-                remaining1: remaining1.iter_mut(),\n-                remaining2: remaining2.iter_mut(),\n-                nelts: self.nelts,\n-            }\n-        } else {\n-            // Items to iterate goes from start_index to end_index:\n-            let (empty, elts) = self.elts.split_at_mut(0);\n-            let remaining1 = elts[mut start_index..end_index];\n-            MutItems {\n-                remaining1: remaining1.iter_mut(),\n-                remaining2: empty.iter_mut(),\n-                nelts: self.nelts,\n-            }\n+    pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+        MutItems {\n+            tail: self.tail,\n+            head: self.head,\n+            cap: self.cap,\n+            ptr: self.ptr,\n+            marker: marker::ContravariantLifetime::<'a>,\n+            marker2: marker::NoCopy\n         }\n     }\n \n@@ -286,7 +391,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn len(&self) -> uint { self.nelts }\n+    pub fn len(&self) -> uint { count(self.tail, self.head, self.cap) }\n \n     /// Returns true if the buffer contains no elements\n     ///\n@@ -317,9 +422,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n-        for x in self.elts.iter_mut() { *x = None }\n-        self.nelts = 0;\n-        self.lo = 0;\n+        while !self.is_empty() {\n+            self.pop_front();\n+        }\n+        self.head = 0;\n+        self.tail = 0;\n     }\n \n     /// Provides a reference to the front element, or `None` if the sequence is\n@@ -339,7 +446,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn front(&self) -> Option<&T> {\n-        if self.nelts > 0 { Some(&self[0]) } else { None }\n+        if !self.is_empty() { Some(&self[0]) } else { None }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the\n@@ -363,7 +470,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        if self.nelts > 0 { Some(&mut self[0]) } else { None }\n+        if !self.is_empty() { Some(&mut self[0]) } else { None }\n     }\n \n     /// Provides a reference to the back element, or `None` if the sequence is\n@@ -383,7 +490,7 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn back(&self) -> Option<&T> {\n-        if self.nelts > 0 { Some(&self[self.nelts - 1]) } else { None }\n+        if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n@@ -407,8 +514,8 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        let nelts = self.nelts;\n-        if nelts > 0 { Some(&mut self[nelts - 1]) } else { None }\n+        let len = self.len();\n+        if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n     }\n \n     /// Removes the first element and returns it, or `None` if the sequence is\n@@ -429,12 +536,13 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop_front(&mut self) -> Option<T> {\n-        let result = self.elts[self.lo].take();\n-        if result.is_some() {\n-            self.lo = (self.lo + 1u) % self.elts.len();\n-            self.nelts -= 1u;\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let tail = self.tail;\n+            self.tail = wrap_index(self.tail + 1, self.cap);\n+            unsafe { Some(self.buffer_read(tail)) }\n         }\n-        result\n     }\n \n     /// Inserts an element first in the sequence.\n@@ -451,14 +559,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push_front(&mut self, t: T) {\n-        if self.nelts == self.elts.len() {\n-            grow(self.nelts, &mut self.lo, &mut self.elts);\n-        }\n-        if self.lo == 0u {\n-            self.lo = self.elts.len() - 1u;\n-        } else { self.lo -= 1u; }\n-        self.elts[self.lo] = Some(t);\n-        self.nelts += 1u;\n+        if self.is_full() { self.reserve(1) }\n+\n+        self.tail = wrap_index(self.tail - 1, self.cap);\n+        let tail = self.tail;\n+        unsafe { self.buffer_write(tail, t); }\n     }\n \n     /// Deprecated: Renamed to `push_back`.\n@@ -481,12 +586,11 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push_back(&mut self, t: T) {\n-        if self.nelts == self.elts.len() {\n-            grow(self.nelts, &mut self.lo, &mut self.elts);\n-        }\n-        let hi = self.raw_index(self.nelts);\n-        self.elts[hi] = Some(t);\n-        self.nelts += 1u;\n+        if self.is_full() { self.reserve(1) }\n+\n+        let head = self.head;\n+        self.head = wrap_index(self.head + 1, self.cap);\n+        unsafe { self.buffer_write(head, t) }\n     }\n \n     /// Deprecated: Renamed to `pop_back`.\n@@ -511,168 +615,139 @@ impl<T> RingBuf<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop_back(&mut self) -> Option<T> {\n-        if self.nelts > 0 {\n-            self.nelts -= 1;\n-            let hi = self.raw_index(self.nelts);\n-            self.elts[hi].take()\n-        } else {\n+        if self.is_empty() {\n             None\n+        } else {\n+            self.head = wrap_index(self.head - 1, self.cap);\n+            let head = self.head;\n+            unsafe { Some(self.buffer_read(head)) }\n         }\n     }\n }\n \n+/// Returns the index in the underlying buffer for a given logical element index.\n+#[inline]\n+fn wrap_index(index: uint, size: uint) -> uint {\n+    // size is always a power of 2\n+    index & (size - 1)\n+}\n+\n+/// Calculate the number of elements left to be read in the buffer\n+#[inline]\n+fn count(tail: uint, head: uint, size: uint) -> uint {\n+    // size is always a power of 2\n+    (head - tail) & (size - 1)\n+}\n+\n /// `RingBuf` iterator.\n pub struct Items<'a, T:'a> {\n-    lo: uint,\n-    index: uint,\n-    rindex: uint,\n-    elts: &'a [Option<T>],\n+    ring: &'a [T],\n+    tail: uint,\n+    head: uint\n }\n \n impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n-        if self.index == self.rindex {\n+        if self.tail == self.head {\n             return None;\n         }\n-        let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n-        self.index += 1;\n-        Some(self.elts[raw_index].as_ref().unwrap())\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail + 1, self.ring.len());\n+        unsafe { Some(self.ring.unsafe_get(tail)) }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        let len = self.rindex - self.index;\n+        let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n }\n \n impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n-        if self.index == self.rindex {\n+        if self.tail == self.head {\n             return None;\n         }\n-        self.rindex -= 1;\n-        let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n-        Some(self.elts[raw_index].as_ref().unwrap())\n+        self.head = wrap_index(self.head - 1, self.ring.len());\n+        unsafe { Some(self.ring.unsafe_get(self.head)) }\n     }\n }\n \n+\n impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n \n impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint { self.rindex - self.index }\n+    fn indexable(&self) -> uint {\n+        let (len, _) = self.size_hint();\n+        len\n+    }\n \n     #[inline]\n     fn idx(&mut self, j: uint) -> Option<&'a T> {\n         if j >= self.indexable() {\n             None\n         } else {\n-            let raw_index = raw_index(self.lo, self.elts.len(), self.index + j);\n-            Some(self.elts[raw_index].as_ref().unwrap())\n+            let idx = wrap_index(self.tail + j, self.ring.len());\n+            unsafe { Some(self.ring.unsafe_get(idx)) }\n         }\n     }\n }\n \n+// FIXME This was implemented differently from Items because of a problem\n+//       with returning the mutable reference. I couldn't find a way to\n+//       make the lifetime checker happy so, but there should be a way.\n /// `RingBuf` mutable iterator.\n pub struct MutItems<'a, T:'a> {\n-    remaining1: slice::MutItems<'a, Option<T>>,\n-    remaining2: slice::MutItems<'a, Option<T>>,\n-    nelts: uint,\n+    ptr: *mut T,\n+    tail: uint,\n+    head: uint,\n+    cap: uint,\n+    marker: marker::ContravariantLifetime<'a>,\n+    marker2: marker::NoCopy\n }\n \n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n-        if self.nelts == 0 {\n+        if self.tail == self.head {\n             return None;\n         }\n-        self.nelts -= 1;\n-        match self.remaining1.next() {\n-            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n-            None => {}\n-        }\n-        match self.remaining2.next() {\n-            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n-            None => unreachable!(),\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail + 1, self.cap);\n+        if mem::size_of::<T>() != 0 {\n+            unsafe { Some(&mut *self.ptr.offset(tail as int)) }\n+        } else {\n+            // use a none zero pointer\n+            Some(unsafe { mem::transmute(1u) })\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.nelts, Some(self.nelts))\n+        let len = count(self.tail, self.head, self.cap);\n+        (len, Some(len))\n     }\n }\n \n impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n-        if self.nelts == 0 {\n+        if self.tail == self.head {\n             return None;\n         }\n-        self.nelts -= 1;\n-        match self.remaining2.next_back() {\n-            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n-            None => {}\n-        }\n-        match self.remaining1.next_back() {\n-            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n-            None => unreachable!(),\n-        }\n+        self.head = wrap_index(self.head - 1, self.cap);\n+        unsafe { Some(&mut *self.ptr.offset(self.head as int)) }\n     }\n }\n \n impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n-/// Grow is only called on full elts, so nelts is also len(elts), unlike\n-/// elsewhere.\n-fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut Vec<Option<T>>) {\n-    assert_eq!(nelts, elts.len());\n-    let lo = *loptr;\n-    elts.reserve_exact(nelts);\n-    let newlen = elts.capacity();\n-\n-    /* fill with None */\n-    for _ in range(elts.len(), newlen) {\n-        elts.push(None);\n-    }\n-\n-    /*\n-      Move the shortest half into the newly reserved area.\n-      lo ---->|\n-      nelts ----------->|\n-        [o o o|o o o o o]\n-      A [. . .|o o o o o o o o|. . . . .]\n-      B [o o o|. . . . . . . .|o o o o o]\n-     */\n-\n-    assert!(newlen - nelts/2 >= nelts);\n-    if lo <= (nelts - lo) { // A\n-        for i in range(0u, lo) {\n-            elts.as_mut_slice().swap(i, nelts + i);\n-        }\n-    } else {                // B\n-        for i in range(lo, nelts) {\n-            elts.as_mut_slice().swap(i, newlen - nelts + i);\n-        }\n-        *loptr += newlen - nelts;\n-    }\n-}\n-\n-/// Returns the index in the underlying `Vec` for a given logical element index.\n-fn raw_index(lo: uint, len: uint, index: uint) -> uint {\n-    if lo >= len - index {\n-        lo + index - len\n-    } else {\n-        lo + index\n-    }\n-}\n-\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {\n-        self.nelts == other.nelts &&\n+        self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n     fn ne(&self, other: &RingBuf<A>) -> bool {\n@@ -707,22 +782,14 @@ impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n impl<A> Index<uint, A> for RingBuf<A> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a A {\n-        let idx = self.raw_index(*i);\n-        match self.elts[idx] {\n-            None => panic!(),\n-            Some(ref v) => v,\n-        }\n+        self.get(*i).expect(\"Out of bounds access\")\n     }\n }\n \n impl<A> IndexMut<uint, A> for RingBuf<A> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A {\n-        let idx = self.raw_index(*i);\n-        match *(&mut self.elts[idx]) {\n-            None => panic!(),\n-            Some(ref mut v) => v\n-        }\n+        self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n }\n \n@@ -893,31 +960,86 @@ mod tests {\n     }\n \n     #[bench]\n-    fn bench_push_back(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::new();\n+    fn bench_push_back_100(b: &mut test::Bencher) {\n+        let mut deq = RingBuf::with_capacity(100);\n         b.iter(|| {\n-            deq.push_back(0i);\n+            for i in range(0i, 100) {\n+                deq.push_back(i);\n+            }\n+            deq.clear();\n         })\n     }\n \n     #[bench]\n-    fn bench_push_front(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::new();\n+    fn bench_push_front_100(b: &mut test::Bencher) {\n+        let mut deq = RingBuf::with_capacity(100);\n         b.iter(|| {\n-            deq.push_front(0i);\n+            for i in range(0i, 100) {\n+                deq.push_front(i);\n+            }\n+            deq.clear();\n         })\n     }\n \n     #[bench]\n-    fn bench_grow(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::new();\n+    fn bench_pop_100(b: &mut test::Bencher) {\n+        let mut deq = RingBuf::with_capacity(100);\n+\n+        b.iter(|| {\n+            for i in range(0i, 100) {\n+                deq.push_back(i);\n+            }\n+            while None != deq.pop_back() {}\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_pop_front_100(b: &mut test::Bencher) {\n+        let mut deq = RingBuf::with_capacity(100);\n+\n+        b.iter(|| {\n+            for i in range(0i, 100) {\n+                deq.push_back(i);\n+            }\n+            while None != deq.pop_front() {}\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_grow_1025(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            let mut deq = RingBuf::new();\n+            for i in range(0i, 1025) {\n+                deq.push_front(i);\n+            }\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_iter_1000(b: &mut test::Bencher) {\n+        let ring: RingBuf<int> = range(0i, 1000).collect();\n+\n         b.iter(|| {\n-            for _ in range(0i, 65) {\n-                deq.push_front(1i);\n+            let mut sum = 0;\n+            for &i in ring.iter() {\n+                sum += i;\n             }\n+            sum\n         })\n     }\n \n+    #[bench]\n+    fn bench_mut_iter_1000(b: &mut test::Bencher) {\n+        let mut ring: RingBuf<int> = range(0i, 1000).collect();\n+\n+        b.iter(|| {\n+            for i in ring.iter_mut() {\n+                *i += 1;\n+            }\n+        })\n+    }\n+\n+\n     #[deriving(Clone, PartialEq, Show)]\n     enum Taggy {\n         One(int),\n@@ -1034,11 +1156,11 @@ mod tests {\n         let mut d = RingBuf::new();\n         d.push_back(0u64);\n         d.reserve(50);\n-        assert!(d.capacity() >= 64);\n+        assert!(d.capacity() >= 51);\n         let mut d = RingBuf::new();\n         d.push_back(0u32);\n         d.reserve(50);\n-        assert!(d.capacity() >= 64);\n+        assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n@@ -1257,4 +1379,169 @@ mod tests {\n                                                                         .collect();\n         assert!(format!(\"{}\", ringbuf).as_slice() == \"[just, one, test, more]\");\n     }\n+\n+    #[test]\n+    fn test_drop() {\n+        static mut drops: uint = 0;\n+        struct Elem;\n+        impl Drop for Elem {\n+            fn drop(&mut self) {\n+                unsafe { drops += 1; }\n+            }\n+        }\n+\n+        let mut ring = RingBuf::new();\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        drop(ring);\n+\n+        assert_eq!(unsafe {drops}, 4);\n+    }\n+\n+    #[test]\n+    fn test_drop_with_pop() {\n+        static mut drops: uint = 0;\n+        struct Elem;\n+        impl Drop for Elem {\n+            fn drop(&mut self) {\n+                unsafe { drops += 1; }\n+            }\n+        }\n+\n+        let mut ring = RingBuf::new();\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+\n+        drop(ring.pop_back());\n+        drop(ring.pop_front());\n+        assert_eq!(unsafe {drops}, 2);\n+\n+        drop(ring);\n+        assert_eq!(unsafe {drops}, 4);\n+    }\n+\n+    #[test]\n+    fn test_drop_clear() {\n+        static mut drops: uint = 0;\n+        struct Elem;\n+        impl Drop for Elem {\n+            fn drop(&mut self) {\n+                unsafe { drops += 1; }\n+            }\n+        }\n+\n+        let mut ring = RingBuf::new();\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        ring.push_back(Elem);\n+        ring.push_front(Elem);\n+        ring.clear();\n+        assert_eq!(unsafe {drops}, 4);\n+\n+        drop(ring);\n+        assert_eq!(unsafe {drops}, 4);\n+    }\n+\n+    #[test]\n+    fn test_reserve_grow() {\n+        // test growth path A\n+        // [T o o H] -> [T o o H . . . . ]\n+        let mut ring = RingBuf::with_capacity(4);\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+        }\n+        ring.reserve(7);\n+        for i in range(0i, 3) {\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+\n+        // test growth path B\n+        // [H T o o] -> [. T o o H . . . ]\n+        let mut ring = RingBuf::with_capacity(4);\n+        for i in range(0i, 1) {\n+            ring.push_back(i);\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+        }\n+        ring.reserve(7);\n+        for i in range(0i, 3) {\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+\n+        // test growth path C\n+        // [o o H T] -> [o o H . . . . T ]\n+        let mut ring = RingBuf::with_capacity(4);\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+        }\n+        ring.reserve(7);\n+        for i in range(0i, 3) {\n+            assert_eq!(ring.pop_front(), Some(i));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get() {\n+        let mut ring = RingBuf::new();\n+        ring.push_back(0i);\n+        assert_eq!(ring.get(0), Some(&0));\n+        assert_eq!(ring.get(1), None);\n+\n+        ring.push_back(1);\n+        assert_eq!(ring.get(0), Some(&0));\n+        assert_eq!(ring.get(1), Some(&1));\n+        assert_eq!(ring.get(2), None);\n+\n+        ring.push_back(2);\n+        assert_eq!(ring.get(0), Some(&0));\n+        assert_eq!(ring.get(1), Some(&1));\n+        assert_eq!(ring.get(2), Some(&2));\n+        assert_eq!(ring.get(3), None);\n+\n+        assert_eq!(ring.pop_front(), Some(0));\n+        assert_eq!(ring.get(0), Some(&1));\n+        assert_eq!(ring.get(1), Some(&2));\n+        assert_eq!(ring.get(2), None);\n+\n+        assert_eq!(ring.pop_front(), Some(1));\n+        assert_eq!(ring.get(0), Some(&2));\n+        assert_eq!(ring.get(1), None);\n+\n+        assert_eq!(ring.pop_front(), Some(2));\n+        assert_eq!(ring.get(0), None);\n+        assert_eq!(ring.get(1), None);\n+    }\n+\n+    #[test]\n+    fn test_get_mut() {\n+        let mut ring = RingBuf::new();\n+        for i in range(0i, 3) {\n+            ring.push_back(i);\n+        }\n+\n+        match ring.get_mut(1) {\n+            Some(x) => *x = -1,\n+            None => ()\n+        };\n+\n+        assert_eq!(ring.get_mut(0), Some(&mut 0));\n+        assert_eq!(ring.get_mut(1), Some(&mut -1));\n+        assert_eq!(ring.get_mut(2), Some(&mut 2));\n+        assert_eq!(ring.get_mut(3), None);\n+\n+        assert_eq!(ring.pop_front(), Some(0));\n+        assert_eq!(ring.get_mut(0), Some(&mut -1));\n+        assert_eq!(ring.get_mut(1), Some(&mut 2));\n+        assert_eq!(ring.get_mut(2), None);\n+    }\n }"}]}