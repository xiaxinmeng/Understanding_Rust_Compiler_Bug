{"sha": "4886ec86651a5eaae1ddc834a941842904a5db61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ODZlYzg2NjUxYTVlYWFlMWRkYzgzNGE5NDE4NDI5MDRhNWRiNjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-12T16:50:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-07-28T17:47:01Z"}, "message": "syntax: Capture a `TokenStream` when parsing items\n\nThis is then later used by `proc_macro` to generate a new\n`proc_macro::TokenTree` which preserves span information. Unfortunately this\nisn't a bullet-proof approach as it doesn't handle the case when there's still\nother attributes on the item, especially inner attributes.\n\nDespite this the intention here is to solve the primary use case for procedural\nattributes, attached to functions as outer attributes, likely bare. In this\nsituation we should be able to now yield a lossless stream of tokens to preserve\nspan information.", "tree": {"sha": "b936eddcf2b8ca4d656ae1d93e6ab86e8774f298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b936eddcf2b8ca4d656ae1d93e6ab86e8774f298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4886ec86651a5eaae1ddc834a941842904a5db61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4886ec86651a5eaae1ddc834a941842904a5db61", "html_url": "https://github.com/rust-lang/rust/commit/4886ec86651a5eaae1ddc834a941842904a5db61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4886ec86651a5eaae1ddc834a941842904a5db61/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "036300aadd5b6eb309de32c1b07f57f3aa2a13cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/036300aadd5b6eb309de32c1b07f57f3aa2a13cd", "html_url": "https://github.com/rust-lang/rust/commit/036300aadd5b6eb309de32c1b07f57f3aa2a13cd"}], "stats": {"total": 418, "additions": 398, "deletions": 20}, "files": [{"sha": "1bffffd6c9e711834416617ad236917115386154", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -510,15 +510,38 @@ impl TokenTree {\n             Literal(..) | DocComment(..) => TokenNode::Literal(self::Literal(token)),\n \n             Interpolated(ref nt) => {\n-                let mut node = None;\n-                if let Nonterminal::NtItem(ref item) = nt.0 {\n-                    if let Some(ref tokens) = item.tokens {\n-                        node = Some(TokenNode::Group(Delimiter::None,\n-                                                     TokenStream(tokens.clone())));\n+                // An `Interpolated` token means that we have a `Nonterminal`\n+                // which is often a parsed AST item. At this point we now need\n+                // to convert the parsed AST to an actual token stream, e.g.\n+                // un-parse it basically.\n+                //\n+                // Unfortunately there's not really a great way to do that in a\n+                // guaranteed lossless fashion right now. The fallback here is\n+                // to just stringify the AST node and reparse it, but this loses\n+                // all span information.\n+                //\n+                // As a result, some AST nodes are annotated with the token\n+                // stream they came from. Attempt to extract these lossless\n+                // token streams before we fall back to the stringification.\n+                let mut tokens = None;\n+\n+                match nt.0 {\n+                    Nonterminal::NtItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n                     }\n+                    Nonterminal::NtTraitItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n+                    }\n+                    Nonterminal::NtImplItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n+                    }\n+                    _ => {}\n                 }\n \n-                node.unwrap_or_else(|| {\n+                tokens.map(|tokens| {\n+                    TokenNode::Group(Delimiter::None,\n+                                     TokenStream(tokens.clone()))\n+                }).unwrap_or_else(|| {\n                     __internal::with_sess(|(sess, _)| {\n                         TokenNode::Group(Delimiter::None, TokenStream(nt.1.force(|| {\n                             // FIXME(jseyfried): Avoid this pretty-print + reparse hack\n@@ -592,6 +615,34 @@ impl TokenTree {\n     }\n }\n \n+fn prepend_attrs(attrs: &[ast::Attribute],\n+                 tokens: Option<&tokenstream::TokenStream>,\n+                 span: syntax_pos::Span)\n+    -> Option<tokenstream::TokenStream>\n+{\n+    let tokens = match tokens {\n+        Some(tokens) => tokens,\n+        None => return None,\n+    };\n+    if attrs.len() == 0 {\n+        return Some(tokens.clone())\n+    }\n+    let mut builder = tokenstream::TokenStreamBuilder::new();\n+    for attr in attrs {\n+        assert_eq!(attr.style, ast::AttrStyle::Outer,\n+                   \"inner attributes should prevent cached tokens from existing\");\n+        let stream = __internal::with_sess(|(sess, _)| {\n+            // FIXME: Avoid this pretty-print + reparse hack as bove\n+            let name = \"<macro expansion>\".to_owned();\n+            let source = pprust::attr_to_string(attr);\n+            parse_stream_from_source_str(name, source, sess, Some(span))\n+        });\n+        builder.push(stream);\n+    }\n+    builder.push(tokens.clone());\n+    Some(builder.build())\n+}\n+\n /// Permanently unstable internal implementation details of this crate. This\n /// should not be used.\n ///"}, {"sha": "fb7915415245320b5ece76ee8e8b3340bd339224", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -1149,6 +1149,8 @@ pub struct TraitItem {\n     pub attrs: Vec<Attribute>,\n     pub node: TraitItemKind,\n     pub span: Span,\n+    /// See `Item::tokens` for what this is\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1168,6 +1170,8 @@ pub struct ImplItem {\n     pub attrs: Vec<Attribute>,\n     pub node: ImplItemKind,\n     pub span: Span,\n+    /// See `Item::tokens` for what this is\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1817,6 +1821,9 @@ pub struct Item {\n     /// available for all items, although over time more and more items should\n     /// have this be `Some`. Right now this is primarily used for procedural\n     /// macros, notably custom attributes.\n+    ///\n+    /// Note that the tokens here do not include the outer attributes, but will\n+    /// include inner attributes.\n     pub tokens: Option<TokenStream>,\n }\n "}, {"sha": "e3377c1d8deefa05b4428a528a349a03cc653e8a", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -51,11 +51,13 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n         ExpansionKind::TraitItems => Expansion::TraitItems(SmallVector::one(ast::TraitItem {\n             id: id, span: span, ident: ident, attrs: attrs,\n             node: ast::TraitItemKind::Macro(mac_placeholder()),\n+            tokens: None,\n         })),\n         ExpansionKind::ImplItems => Expansion::ImplItems(SmallVector::one(ast::ImplItem {\n             id: id, span: span, ident: ident, vis: vis, attrs: attrs,\n             node: ast::ImplItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n+            tokens: None,\n         })),\n         ExpansionKind::Pat => Expansion::Pat(P(ast::Pat {\n             id: id, span: span, node: ast::PatKind::Mac(mac_placeholder()),"}, {"sha": "279f63d13a4f47837c66eda820d708d3f57db109", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -957,7 +957,8 @@ pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T)\n                 TraitItemKind::Macro(folder.fold_mac(mac))\n             }\n         },\n-        span: folder.new_span(i.span)\n+        span: folder.new_span(i.span),\n+        tokens: i.tokens,\n     })\n }\n \n@@ -980,7 +981,8 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n             ast::ImplItemKind::Type(ty) => ast::ImplItemKind::Type(folder.fold_ty(ty)),\n             ast::ImplItemKind::Macro(mac) => ast::ImplItemKind::Macro(folder.fold_mac(mac))\n         },\n-        span: folder.new_span(i.span)\n+        span: folder.new_span(i.span),\n+        tokens: i.tokens,\n     })\n }\n \n@@ -1042,9 +1044,10 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span,\n         attrs: fold_attrs(attrs, folder),\n         node: folder.fold_item_kind(node),\n         span: folder.new_span(span),\n-        tokens: tokens.map(|tokens| {\n-            folder.fold_tts(tokens.into()).into()\n-        }),\n+\n+        // FIXME: if this is replaced with a call to `folder.fold_tts` it causes\n+        //        an ICE during resolve... odd!\n+        tokens: tokens,\n     }\n }\n "}, {"sha": "45e0b8404cc7e98e3d2f4ed11dd59c225f825cba", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -843,11 +843,18 @@ mod tests {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"i32\"\n-        assert_eq!(string_to_item(\"fn a (b : i32) { b; }\".to_string()),\n+        let item = string_to_item(\"fn a (b : i32) { b; }\".to_string()).map(|m| {\n+            m.map(|mut m| {\n+                m.tokens = None;\n+                m\n+            })\n+        });\n+        assert_eq!(item,\n                   Some(\n                       P(ast::Item{ident:Ident::from_str(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n+                            tokens: None,\n                             node: ast::ItemKind::Fn(P(ast::FnDecl {\n                                 inputs: vec![ast::Arg{\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,"}, {"sha": "1a10aa9d621be0f31b26ae50ecff25e794d46fdc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 125, "deletions": 5, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -216,6 +216,30 @@ struct TokenCursorFrame {\n     open_delim: bool,\n     tree_cursor: tokenstream::Cursor,\n     close_delim: bool,\n+    last_token: LastToken,\n+}\n+\n+/// This is used in `TokenCursorFrame` above to track tokens that are consumed\n+/// by the parser, and then that's transitively used to record the tokens that\n+/// each parse AST item is created with.\n+///\n+/// Right now this has two states, either collecting tokens or not collecting\n+/// tokens. If we're collecting tokens we just save everything off into a local\n+/// `Vec`. This should eventually though likely save tokens from the original\n+/// token stream and just use slicing of token streams to avoid creation of a\n+/// whole new vector.\n+///\n+/// The second state is where we're passively not recording tokens, but the last\n+/// token is still tracked for when we want to start recording tokens. This\n+/// \"last token\" means that when we start recording tokens we'll want to ensure\n+/// that this, the first token, is included in the output.\n+///\n+/// You can find some more example usage of this in the `collect_tokens` method\n+/// on the parser.\n+#[derive(Clone)]\n+enum LastToken {\n+    Collecting(Vec<TokenTree>),\n+    Was(Option<TokenTree>),\n }\n \n impl TokenCursorFrame {\n@@ -226,6 +250,7 @@ impl TokenCursorFrame {\n             open_delim: delimited.delim == token::NoDelim,\n             tree_cursor: delimited.stream().into_trees(),\n             close_delim: delimited.delim == token::NoDelim,\n+            last_token: LastToken::Was(None),\n         }\n     }\n }\n@@ -250,6 +275,11 @@ impl TokenCursor {\n                 return TokenAndSpan { tok: token::Eof, sp: syntax_pos::DUMMY_SP }\n             };\n \n+            match self.frame.last_token {\n+                LastToken::Collecting(ref mut v) => v.push(tree.clone()),\n+                LastToken::Was(ref mut t) => *t = Some(tree.clone()),\n+            }\n+\n             match tree {\n                 TokenTree::Token(sp, tok) => return TokenAndSpan { tok: tok, sp: sp },\n                 TokenTree::Delimited(sp, ref delimited) => {\n@@ -1209,7 +1239,20 @@ impl<'a> Parser<'a> {\n     /// Parse the items in a trait declaration\n     pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n         maybe_whole!(self, NtTraitItem, |x| x);\n-        let mut attrs = self.parse_outer_attributes()?;\n+        let attrs = self.parse_outer_attributes()?;\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            this.parse_trait_item_(at_end, attrs)\n+        })?;\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n+\n+    fn parse_trait_item_(&mut self,\n+                         at_end: &mut bool,\n+                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n         let lo = self.span;\n \n         let (name, node) = if self.eat_keyword(keywords::Type) {\n@@ -1304,6 +1347,7 @@ impl<'a> Parser<'a> {\n             attrs: attrs,\n             node: node,\n             span: lo.to(self.prev_span),\n+            tokens: None,\n         })\n     }\n \n@@ -4653,7 +4697,7 @@ impl<'a> Parser<'a> {\n             node: node,\n             vis: vis,\n             span: span,\n-            tokens: None, // TODO: fill this in\n+            tokens: None,\n         })\n     }\n \n@@ -4709,8 +4753,21 @@ impl<'a> Parser<'a> {\n     /// Parse an impl item.\n     pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n         maybe_whole!(self, NtImplItem, |x| x);\n+        let attrs = self.parse_outer_attributes()?;\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            this.parse_impl_item_(at_end, attrs)\n+        })?;\n+\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n \n-        let mut attrs = self.parse_outer_attributes()?;\n+    fn parse_impl_item_(&mut self,\n+                        at_end: &mut bool,\n+                        mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n         let lo = self.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness()?;\n@@ -4742,7 +4799,8 @@ impl<'a> Parser<'a> {\n             vis: vis,\n             defaultness: defaultness,\n             attrs: attrs,\n-            node: node\n+            node: node,\n+            tokens: None,\n         })\n     }\n \n@@ -6018,9 +6076,71 @@ impl<'a> Parser<'a> {\n         Ok(None)\n     }\n \n+    fn collect_tokens<F, R>(&mut self, f: F) -> PResult<'a, (R, TokenStream)>\n+        where F: FnOnce(&mut Self) -> PResult<'a, R>\n+    {\n+        // Record all tokens we parse when parsing this item.\n+        let mut tokens = Vec::new();\n+        match self.token_cursor.frame.last_token {\n+            LastToken::Collecting(_) => {\n+                panic!(\"cannot collect tokens recursively yet\")\n+            }\n+            LastToken::Was(ref mut last) => tokens.extend(last.take()),\n+        }\n+        self.token_cursor.frame.last_token = LastToken::Collecting(tokens);\n+        let prev = self.token_cursor.stack.len();\n+        let ret = f(self);\n+        let last_token = if self.token_cursor.stack.len() == prev {\n+            &mut self.token_cursor.frame.last_token\n+        } else {\n+            &mut self.token_cursor.stack[prev].last_token\n+        };\n+        let mut tokens = match *last_token {\n+            LastToken::Collecting(ref mut v) => mem::replace(v, Vec::new()),\n+            LastToken::Was(_) => panic!(\"our vector went away?\"),\n+        };\n+\n+        // If we're not at EOF our current token wasn't actually consumed by\n+        // `f`, but it'll still be in our list that we pulled out. In that case\n+        // put it back.\n+        if self.token == token::Eof {\n+            *last_token = LastToken::Was(None);\n+        } else {\n+            *last_token = LastToken::Was(tokens.pop());\n+        }\n+\n+        Ok((ret?, tokens.into_iter().collect()))\n+    }\n+\n     pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n         let attrs = self.parse_outer_attributes()?;\n-        self.parse_item_(attrs, true, false)\n+\n+        let (ret, tokens) = self.collect_tokens(|this| {\n+            this.parse_item_(attrs, true, false)\n+        })?;\n+\n+        // Once we've parsed an item and recorded the tokens we got while\n+        // parsing we may want to store `tokens` into the item we're about to\n+        // return. Note, though, that we specifically didn't capture tokens\n+        // related to outer attributes. The `tokens` field here may later be\n+        // used with procedural macros to convert this item back into a token\n+        // stream, but during expansion we may be removing attributes as we go\n+        // along.\n+        //\n+        // If we've got inner attributes then the `tokens` we've got above holds\n+        // these inner attributes. If an inner attribute is expanded we won't\n+        // actually remove it from the token stream, so we'll just keep yielding\n+        // it (bad!). To work around this case for now we just avoid recording\n+        // `tokens` if we detect any inner attributes. This should help keep\n+        // expansion correct, but we should fix this bug one day!\n+        Ok(ret.map(|item| {\n+            item.map(|mut i| {\n+                if !i.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+                    i.tokens = Some(tokens);\n+                }\n+                i\n+            })\n+        }))\n     }\n \n     fn parse_path_list_items(&mut self) -> PResult<'a, Vec<ast::PathListItem>> {"}, {"sha": "3cbc7938bde0c0a46362f679d205d19cf47f5f9d", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -504,6 +504,7 @@ impl<'a> TraitDef<'a> {\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 node: ast::ImplItemKind::Type(type_def.to_ty(cx, self.span, type_ident, generics)),\n+                tokens: None,\n             }\n         });\n \n@@ -930,6 +931,7 @@ impl<'a> MethodDef<'a> {\n                                                 decl: fn_decl,\n                                             },\n                                             body_block),\n+            tokens: None,\n         }\n     }\n "}, {"sha": "65f4b6350c4eed4f578d9d78bc61949360b66a4f", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute-with-error.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -14,12 +14,38 @@\n \n extern crate attribute_with_error;\n \n-#[attribute_with_error::foo]\n-fn test() {\n+use attribute_with_error::foo;\n+\n+#[foo]\n+fn test1() {\n     let a: i32 = \"foo\";\n     //~^ ERROR: mismatched types\n }\n \n+fn test2() {\n+    #![foo]\n+\n+    // FIXME: should have a type error here and assert it works but it doesn't\n+}\n+\n+trait A {\n+    // FIXME: should have a #[foo] attribute here and assert that it works\n+    fn foo(&self) {\n+        let a: i32 = \"foo\";\n+        //~^ ERROR: mismatched types\n+    }\n+}\n+\n+struct B;\n+\n+impl A for B {\n+    #[foo]\n+    fn foo(&self) {\n+        let a: i32 = \"foo\";\n+        //~^ ERROR: mismatched types\n+    }\n+}\n+\n+#[foo]\n fn main() {\n-    test();\n }"}, {"sha": "508f8dac5711939f75f13bfbac6b1b0645378eba", "filename": "src/test/compile-fail-fulldeps/proc-macro/attributes-included.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attributes-included.rs\n+\n+#![feature(proc_macro, rustc_attrs)]\n+\n+extern crate attributes_included;\n+\n+#[attributes_included::bar]\n+#[inline]\n+/// doc\n+#[attributes_included::foo]\n+#[inline]\n+/// doc\n+fn foo() {\n+    let a: i32 = \"foo\"; //~ WARN: unused variable\n+}\n+\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n+    foo()\n+}"}, {"sha": "a1efbb88a4d2e26dc1e9c1ef274452a259e9cb59", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attributes-included.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4886ec86651a5eaae1ddc834a941842904a5db61/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs?ref=4886ec86651a5eaae1ddc834a941842904a5db61", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenTree, TokenNode, Delimiter, Literal};\n+\n+#[proc_macro_attribute]\n+pub fn foo(attr: TokenStream, input: TokenStream) -> TokenStream {\n+    assert!(attr.is_empty());\n+    let input = input.into_iter().collect::<Vec<_>>();\n+    {\n+        let mut cursor = &input[..];\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_foo(&mut cursor);\n+        assert!(cursor.is_empty());\n+    }\n+    fold_stream(input.into_iter().collect())\n+}\n+\n+#[proc_macro_attribute]\n+pub fn bar(attr: TokenStream, input: TokenStream) -> TokenStream {\n+    assert!(attr.is_empty());\n+    let input = input.into_iter().collect::<Vec<_>>();\n+    {\n+        let mut cursor = &input[..];\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_invoc(&mut cursor);\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_foo(&mut cursor);\n+        assert!(cursor.is_empty());\n+    }\n+    input.into_iter().collect()\n+}\n+\n+fn assert_inline(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Op('#', _) => {}\n+        _ => panic!(\"expected '#' char\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Group(Delimiter::Bracket, _) => {}\n+        _ => panic!(\"expected brackets\"),\n+    }\n+    *slice = &slice[2..];\n+}\n+\n+fn assert_doc(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Literal(_) => {}\n+        _ => panic!(\"expected literal doc comment got other\"),\n+    }\n+    *slice = &slice[1..];\n+}\n+\n+fn assert_invoc(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Op('#', _) => {}\n+        _ => panic!(\"expected '#' char\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Group(Delimiter::Bracket, _) => {}\n+        _ => panic!(\"expected brackets\"),\n+    }\n+    *slice = &slice[2..];\n+}\n+\n+fn assert_foo(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Term(ref name) => assert_eq!(name.as_str(), \"fn\"),\n+        _ => panic!(\"expected fn\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Term(ref name) => assert_eq!(name.as_str(), \"foo\"),\n+        _ => panic!(\"expected foo\"),\n+    }\n+    match slice[2].kind {\n+        TokenNode::Group(Delimiter::Parenthesis, ref s) => assert!(s.is_empty()),\n+        _ => panic!(\"expected parens\"),\n+    }\n+    match slice[3].kind {\n+        TokenNode::Group(Delimiter::Brace, _) => {}\n+        _ => panic!(\"expected braces\"),\n+    }\n+    *slice = &slice[4..];\n+}\n+\n+fn fold_stream(input: TokenStream) -> TokenStream {\n+    input.into_iter().map(fold_tree).collect()\n+}\n+\n+fn fold_tree(input: TokenTree) -> TokenTree {\n+    TokenTree {\n+        span: input.span,\n+        kind: fold_node(input.kind),\n+    }\n+}\n+\n+fn fold_node(input: TokenNode) -> TokenNode {\n+    match input {\n+        TokenNode::Group(a, b) => TokenNode::Group(a, fold_stream(b)),\n+        TokenNode::Op(a, b) => TokenNode::Op(a, b),\n+        TokenNode::Term(a) => TokenNode::Term(a),\n+        TokenNode::Literal(a) => {\n+            if a.to_string() != \"\\\"foo\\\"\" {\n+                TokenNode::Literal(a)\n+            } else {\n+                TokenNode::Literal(Literal::integer(3))\n+            }\n+        }\n+    }\n+}"}]}