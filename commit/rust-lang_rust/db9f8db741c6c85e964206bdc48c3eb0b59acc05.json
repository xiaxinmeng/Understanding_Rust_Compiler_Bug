{"sha": "db9f8db741c6c85e964206bdc48c3eb0b59acc05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiOWY4ZGI3NDFjNmM4NWU5NjQyMDZiZGM0OGMzZWIwYjU5YWNjMDU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-13T01:38:41Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-13T18:37:58Z"}, "message": "librustc: Implement deriving with a unit return type. r=tjc", "tree": {"sha": "b52aa4a3150280460378041fa06396f82f61e612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b52aa4a3150280460378041fa06396f82f61e612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db9f8db741c6c85e964206bdc48c3eb0b59acc05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db9f8db741c6c85e964206bdc48c3eb0b59acc05", "html_url": "https://github.com/rust-lang/rust/commit/db9f8db741c6c85e964206bdc48c3eb0b59acc05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db9f8db741c6c85e964206bdc48c3eb0b59acc05/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6d0117bf658701608eeff646345adb5cce3f8b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d0117bf658701608eeff646345adb5cce3f8b1", "html_url": "https://github.com/rust-lang/rust/commit/c6d0117bf658701608eeff646345adb5cce3f8b1"}], "stats": {"total": 302, "additions": 235, "deletions": 67}, "files": [{"sha": "ddc027f618ee97d5aa4e64b71b63d7fe50bd1050", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=db9f8db741c6c85e964206bdc48c3eb0b59acc05", "patch": "@@ -2275,6 +2275,8 @@ fn register_deriving_method(ccx: @crate_ctxt,\n     }\n \n     let path = vec::append(*path, ~[\n+        ast_map::path_mod(\n+            ccx.sess.parse_sess.interner.intern(@fmt!(\"__derived%d__\", id))),\n         ast_map::path_name(derived_method_info.method_info.ident)\n     ]);\n     let mty = ty::lookup_item_type(ccx.tcx, local_def(id)).ty;"}, {"sha": "6865680ec52648957dbd009e1ff7692824de5516", "filename": "src/librustc/middle/trans/deriving.rs", "status": "modified", "additions": 160, "deletions": 54, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=db9f8db741c6c85e964206bdc48c3eb0b59acc05", "patch": "@@ -21,6 +21,38 @@ use syntax::ast_map::path;\n use syntax::ast_util;\n use syntax::ast_util::local_def;\n \n+/// The kind of deriving method this is.\n+enum DerivingKind {\n+\tBoolKind,\t// fn f(&self, other: &other) -> bool\n+\tUnitKind,\t// fn f(&self) -> ()\n+}\n+\n+impl DerivingKind {\n+    static fn of_item(ccx: @crate_ctxt, method_did: ast::def_id)\n+                   -> DerivingKind {\n+        let item_type = ty::lookup_item_type(ccx.tcx, method_did).ty;\n+        match ty::get(item_type).sty {\n+            ty::ty_fn(ref f) => {\n+                match ty::get(f.sig.output).sty {\n+                    ty::ty_bool => BoolKind,\n+                    ty::ty_nil => UnitKind,\n+                    _ => {\n+                        // FIXME (#3957): Report this earlier.\n+                        ccx.tcx.sess.fatal(~\"attempt to automatically derive \\\n+                                             derive an implementation of a \\\n+                                             function returning something \\\n+                                             other than bool or ()\");\n+                    }\n+                }\n+            }\n+            _ => {\n+                ccx.tcx.sess.bug(~\"DerivingKind::of_item(): method def ID \\\n+                                   didn't have a function type\");\n+            }\n+        }\n+    }\n+}\n+\n /// The main \"translation\" pass for automatically-derived impls. Generates\n /// code for monomorphic methods only. Other methods will be generated when\n /// they are invoked with specific type parameters; see\n@@ -36,15 +68,16 @@ pub fn trans_deriving_impl(ccx: @crate_ctxt, _path: path, _name: ident,\n         impl_def_id);\n \n     for method_dids.each |method_did| {\n+        let kind = DerivingKind::of_item(ccx, *method_did);\n         let llfn = get_item_val(ccx, method_did.node);\n         match ty::get(self_ty.ty).sty {\n             ty::ty_class(*) => {\n                 trans_deriving_struct_method(ccx, llfn, impl_def_id,\n-                                             self_ty.ty);\n+                                             self_ty.ty, kind);\n             }\n             ty::ty_enum(*) => {\n                 trans_deriving_enum_method(ccx, llfn, impl_def_id,\n-                                           self_ty.ty);\n+                                           self_ty.ty, kind);\n             }\n             _ => {\n                 ccx.tcx.sess.bug(~\"translation of non-struct deriving \\\n@@ -54,8 +87,11 @@ pub fn trans_deriving_impl(ccx: @crate_ctxt, _path: path, _name: ident,\n     }\n }\n \n-fn trans_deriving_struct_method(ccx: @crate_ctxt, llfn: ValueRef,\n-                                impl_did: def_id, self_ty: ty::t) {\n+fn trans_deriving_struct_method(ccx: @crate_ctxt,\n+                                llfn: ValueRef,\n+                                impl_did: def_id,\n+                                self_ty: ty::t,\n+                                kind: DerivingKind) {\n     let _icx = ccx.insn_ctxt(\"trans_deriving_struct_method\");\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n     let top_bcx = top_scope_block(fcx, None);\n@@ -64,7 +100,14 @@ fn trans_deriving_struct_method(ccx: @crate_ctxt, llfn: ValueRef,\n \n     let llselfty = type_of(ccx, self_ty);\n     let llselfval = PointerCast(bcx, fcx.llenv, T_ptr(llselfty));\n-    let llotherval = llvm::LLVMGetParam(llfn, 2);\n+\n+    // If there is an \"other\" value, then get it. The \"other\" value is the\n+    // value we're comparing against in the case of Eq and Ord.\n+    let llotherval_opt;\n+    match kind {\n+        BoolKind => llotherval_opt = Some(llvm::LLVMGetParam(llfn, 2)),\n+        UnitKind => llotherval_opt = None\n+    }\n \n     let struct_field_tys;\n     match ty::get(self_ty).sty {\n@@ -82,27 +125,45 @@ fn trans_deriving_struct_method(ccx: @crate_ctxt, llfn: ValueRef,\n     for ccx.tcx.deriving_struct_methods.get(impl_did).eachi\n             |i, derived_method_info| {\n         let llselfval = GEPi(bcx, llselfval, [0, 0, i]);\n-        let llotherval = GEPi(bcx, llotherval, [0, 0, i]);\n+\n+        let llotherval_opt = llotherval_opt.map(\n+            |llotherval| GEPi(bcx, *llotherval, [0, 0, i]));\n \n         let self_ty = struct_field_tys[i].mt.ty;\n         bcx = call_substructure_method(bcx, derived_method_info, self_ty,\n-                                       llselfval, llotherval);\n+                                       llselfval, llotherval_opt);\n+\n+        // If this derived method is of boolean kind, return immediately if\n+        // the call to the substructure method returned false.\n+        match kind {\n+            BoolKind => {\n+                let next_block = sub_block(top_bcx, ~\"next\");\n+                let llcond = Load(bcx, fcx.llretptr);\n+                CondBr(bcx, llcond, next_block.llbb, fcx.llreturn);\n+                bcx = next_block;\n+            }\n+            UnitKind => {}  // Unconditionally continue.\n+        }\n+    }\n \n-        // Return immediately if the call returned false.\n-        let next_block = sub_block(top_bcx, ~\"next\");\n-        let llcond = Load(bcx, fcx.llretptr);\n-        CondBr(bcx, llcond, next_block.llbb, fcx.llreturn);\n-        bcx = next_block;\n+    // Store true if necessary.\n+    match kind {\n+        BoolKind => Store(bcx, C_bool(true), fcx.llretptr),\n+        UnitKind => {}\n     }\n \n-    Store(bcx, C_bool(true), fcx.llretptr);\n     Br(bcx, fcx.llreturn);\n \n     finish_fn(fcx, lltop);\n }\n \n-fn trans_deriving_enum_method(ccx: @crate_ctxt, llfn: ValueRef,\n-                              impl_did: def_id, self_ty: ty::t) {\n+// This could have been combined with trans_deriving_struct_method, but it\n+// would probably be too big and hard to understand.\n+fn trans_deriving_enum_method(ccx: @crate_ctxt,\n+                              llfn: ValueRef,\n+                              impl_did: def_id,\n+                              self_ty: ty::t,\n+                              kind: DerivingKind) {\n     let _icx = ccx.insn_ctxt(\"trans_deriving_enum_method\");\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n     let top_bcx = top_scope_block(fcx, None);\n@@ -111,7 +172,12 @@ fn trans_deriving_enum_method(ccx: @crate_ctxt, llfn: ValueRef,\n \n     let llselfty = type_of(ccx, self_ty);\n     let llselfval = PointerCast(bcx, fcx.llenv, T_ptr(llselfty));\n-    let llotherval = llvm::LLVMGetParam(llfn, 2);\n+\n+    let llotherval_opt;\n+    match kind {\n+        UnitKind => llotherval_opt = None,\n+        BoolKind => llotherval_opt = Some(llvm::LLVMGetParam(llfn, 2))\n+    }\n \n     let enum_id, enum_substs, enum_variant_infos;\n     match ty::get(self_ty).sty {\n@@ -127,11 +193,18 @@ fn trans_deriving_enum_method(ccx: @crate_ctxt, llfn: ValueRef,\n         }\n     }\n \n-    // Create the \"no match\" basic block. This is a basic block that does\n-    // nothing more than return false.\n-    let nomatch_bcx = sub_block(top_bcx, ~\"no_match\");\n-    Store(nomatch_bcx, C_bool(false), fcx.llretptr);\n-    Br(nomatch_bcx, fcx.llreturn);\n+    // Create the \"no match\" basic block, if necessary. This is a basic block\n+    // that does nothing more than return false.\n+    let nomatch_bcx_opt;\n+    match kind {\n+        BoolKind => {\n+            let nomatch_bcx = sub_block(top_bcx, ~\"no_match\");\n+            Store(nomatch_bcx, C_bool(false), fcx.llretptr);\n+            Br(nomatch_bcx, fcx.llreturn);\n+            nomatch_bcx_opt = Some(nomatch_bcx);\n+        }\n+        UnitKind => nomatch_bcx_opt = None\n+    }\n \n     // Create the \"unreachable\" basic block.\n     let unreachable_bcx = sub_block(top_bcx, ~\"unreachable\");\n@@ -144,11 +217,13 @@ fn trans_deriving_enum_method(ccx: @crate_ctxt, llfn: ValueRef,\n     if n_variants != 1 {\n         // Grab the two discriminants.\n         let llselfdiscrim = Load(bcx, GEPi(bcx, llselfval, [0, 0]));\n-        let llotherdiscrim = Load(bcx, GEPi(bcx, llotherval, [0, 0]));\n+        let llotherdiscrim_opt = llotherval_opt.map(\n+            |llotherval| Load(bcx, GEPi(bcx, *llotherval, [0, 0])));\n \n         // Skip over the discriminants and compute the address of the payload.\n         let llselfpayload = GEPi(bcx, llselfval, [0, 1]);\n-        let llotherpayload = GEPi(bcx, llotherval, [0, 1]);\n+        let llotherpayload_opt = llotherval_opt.map(\n+            |llotherval| GEPi(bcx, *llotherval, [0, 1]));\n \n         // Create basic blocks for the outer switch.\n         let outer_bcxs = vec::from_fn(\n@@ -169,46 +244,71 @@ fn trans_deriving_enum_method(ccx: @crate_ctxt, llfn: ValueRef,\n                         enum_variant_infos[self_variant_index].id;\n                 let llselfval = GEP_enum(match_bcx, llselfpayload, enum_id,\n                                          variant_def_id, enum_substs.tps, i);\n-                let llotherval = GEP_enum(match_bcx, llotherpayload,\n-                                          enum_id, variant_def_id,\n-                                          enum_substs.tps, i);\n+\n+                let llotherval_opt = llotherpayload_opt.map(|llotherpayload|\n+                    GEP_enum(match_bcx, *llotherpayload, enum_id,\n+                             variant_def_id, enum_substs.tps, i));\n \n                 let self_ty = enum_variant_infos[self_variant_index].args[i];\n                 match_bcx = call_substructure_method(match_bcx,\n                                                      derived_method_info,\n                                                      self_ty,\n                                                      llselfval,\n-                                                     llotherval);\n-\n-                // Return immediately if the call to the substructure returned\n-                // false.\n-                let next_bcx = sub_block(\n-                    top_bcx, fmt!(\"next_%u_%u\", self_variant_index, i));\n-                let llcond = Load(match_bcx, fcx.llretptr);\n-                CondBr(match_bcx, llcond, next_bcx.llbb, fcx.llreturn);\n-                match_bcx = next_bcx;\n+                                                     llotherval_opt);\n+\n+                // If this is a boolean-kind deriving method, then return\n+                // immediately if the call to the substructure returned false.\n+                match kind {\n+                    BoolKind => {\n+                        let next_bcx = sub_block(top_bcx,\n+                                                 fmt!(\"next_%u_%u\",\n+                                                      self_variant_index,\n+                                                      i));\n+                        let llcond = Load(match_bcx, fcx.llretptr);\n+                        CondBr(match_bcx,\n+                               llcond,\n+                               next_bcx.llbb,\n+                               fcx.llreturn);\n+                        match_bcx = next_bcx;\n+                    }\n+                    UnitKind => {}\n+                }\n+            }\n+\n+            // Store true in the return pointer if this is a boolean-kind\n+            // deriving method.\n+            match kind {\n+                BoolKind => Store(match_bcx, C_bool(true), fcx.llretptr),\n+                UnitKind => {}\n             }\n \n             // Finish up the matching block.\n-            Store(match_bcx, C_bool(true), fcx.llretptr);\n             Br(match_bcx, fcx.llreturn);\n \n-            // Build the inner switch.\n-            let llswitch = Switch(\n-                *bcx, llotherdiscrim, unreachable_bcx.llbb, n_variants);\n-            for uint::range(0, n_variants) |other_variant_index| {\n-                let discriminant =\n-                    enum_variant_infos[other_variant_index].disr_val;\n-                if self_variant_index == other_variant_index {\n-                    // This is the potentially-matching case.\n-                    AddCase(llswitch,\n-                            C_int(ccx, discriminant),\n-                            top_match_bcx.llbb);\n-                } else {\n-                    // This is always a non-matching case.\n-                    AddCase(llswitch,\n-                            C_int(ccx, discriminant),\n-                            nomatch_bcx.llbb);\n+            // If this is a boolean-kind derived method, build the inner\n+            // switch. Otherwise, just jump to the matching case.\n+            match llotherdiscrim_opt {\n+                None => Br(*bcx, top_match_bcx.llbb),\n+                Some(copy llotherdiscrim) => {\n+                    let llswitch = Switch(*bcx,\n+                                          llotherdiscrim,\n+                                          unreachable_bcx.llbb,\n+                                          n_variants);\n+                    for uint::range(0, n_variants) |other_variant_index| {\n+                        let discriminant =\n+                            enum_variant_infos[other_variant_index].disr_val;\n+                        if self_variant_index == other_variant_index {\n+                            // This is the potentially-matching case.\n+                            AddCase(llswitch,\n+                                    C_int(ccx, discriminant),\n+                                    top_match_bcx.llbb);\n+                        } else {\n+                            // This is always a non-matching case.\n+                            AddCase(llswitch,\n+                                    C_int(ccx, discriminant),\n+                                    nomatch_bcx_opt.get().llbb);\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -233,7 +333,7 @@ fn call_substructure_method(bcx: block,\n                             derived_field_info: &DerivedFieldInfo,\n                             self_ty: ty::t,\n                             llselfval: ValueRef,\n-                            llotherval: ValueRef) -> block {\n+                            llotherval_opt: Option<ValueRef>) -> block {\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n@@ -273,12 +373,18 @@ fn call_substructure_method(bcx: block,\n         }\n     };\n \n+    let arg_values;\n+    match llotherval_opt {\n+        None => arg_values = ArgVals(~[]),\n+        Some(copy llotherval) => arg_values = ArgVals(~[llotherval])\n+    }\n+\n     callee::trans_call_inner(bcx,\n                              None,\n                              fn_expr_tpbt.ty,\n                              ty::mk_bool(ccx.tcx),\n                              cb,\n-                             ArgVals(~[llotherval]),\n+                             move arg_values,\n                              SaveIn(fcx.llretptr),\n                              DontAutorefArg)\n }"}, {"sha": "7a863b0cc39bfc4d96d69d31b580cf6c789aa44f", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=db9f8db741c6c85e964206bdc48c3eb0b59acc05", "patch": "@@ -262,6 +262,9 @@ impl CoherenceChecker {\n             }\n         }\n \n+        // We only want to generate one Impl structure. When we generate one,\n+        // we store it here so that we don't recreate it.\n+        let mut implementation_opt = None;\n         for associated_traits.each |associated_trait| {\n             let trait_did =\n                 self.trait_ref_to_trait_def_id(*associated_trait);\n@@ -273,8 +276,14 @@ impl CoherenceChecker {\n                     self.crate_context.tcx.sess.str_of(item.ident));\n \n             self.instantiate_default_methods(item.id, trait_did);\n-            let implementation = self.create_impl_from_item(item);\n-            self.add_trait_method(trait_did, implementation);\n+\n+            let implementation;\n+            if implementation_opt.is_none() {\n+                implementation = self.create_impl_from_item(item);\n+                implementation_opt = Some(implementation);\n+            }\n+\n+            self.add_trait_method(trait_did, implementation_opt.get());\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -288,7 +297,15 @@ impl CoherenceChecker {\n             }\n             Some(base_type_def_id) => {\n                 // XXX: Gather up default methods?\n-                let implementation = self.create_impl_from_item(item);\n+                let implementation;\n+                match implementation_opt {\n+                    None => {\n+                        implementation = self.create_impl_from_item(item);\n+                    }\n+                    Some(copy existing_implementation) => {\n+                        implementation = existing_implementation;\n+                    }\n+                }\n                 self.add_inherent_method(base_type_def_id, implementation);\n \n                 self.base_type_def_ids.insert(local_def(item.id),\n@@ -620,6 +637,7 @@ impl CoherenceChecker {\n                 method_info: method_info,\n                 containing_impl: impl_did\n             };\n+\n             tcx.automatically_derived_methods.insert(new_def_id,\n                                                      derived_method_info);\n \n@@ -666,18 +684,21 @@ impl CoherenceChecker {\n                         }\n                     }\n                     None => {\n-                        // This is a \"deriving\" impl. For each trait, collect\n-                        // all the \"required\" methods and add them to the\n-                        // Impl structure.\n+                        // This is a \"deriving\" impl. For each trait,\n+                        // collect all the \"required\" methods and add\n+                        // them to the Impl structure.\n                         let tcx = self.crate_context.tcx;\n-                        let self_ty =\n-                            ty::lookup_item_type(tcx, local_def(item.id));\n+                        let self_ty = ty::lookup_item_type(\n+                            tcx, local_def(item.id));\n                         for trait_refs.each |trait_ref| {\n                             let trait_did =\n-                                self.trait_ref_to_trait_def_id(*trait_ref);\n+                                self.trait_ref_to_trait_def_id(\n+                                    *trait_ref);\n                             self.add_automatically_derived_methods_from_trait(\n-                                &mut methods, trait_did, self_ty.ty,\n-                                local_def(item.id));\n+                                    &mut methods,\n+                                    trait_did,\n+                                    self_ty.ty,\n+                                    local_def(item.id));\n                         }\n                     }\n                 }"}, {"sha": "c2e255cad149ee7e4138af9d14b08d809c031cc6", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=db9f8db741c6c85e964206bdc48c3eb0b59acc05", "patch": "@@ -207,8 +207,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         let impl_did = ast_util::local_def(i.id);\n         for ms_opt.each |ms| {\n             for ms.each |m| {\n-                map_method(impl_did, extend(cx, i.ident), *m,\n-                           cx);\n+                map_method(impl_did, extend(cx, i.ident), *m, cx);\n             }\n         }\n       }"}, {"sha": "ed399b998cea88e347f25a907bdfcba6fa8eb08a", "filename": "src/test/run-pass/deriving-returning-nil.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db9f8db741c6c85e964206bdc48c3eb0b59acc05/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-returning-nil.rs?ref=db9f8db741c6c85e964206bdc48c3eb0b59acc05", "patch": "@@ -0,0 +1,40 @@\n+trait Show {\n+    fn show();\n+}\n+\n+impl int : Show {\n+    fn show() {\n+        io::println(self.to_str());\n+    }\n+}\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+    z: int,\n+}\n+\n+impl Foo : Show;\n+\n+enum Bar {\n+    Baz(int, int),\n+    Boo(Foo),\n+}\n+\n+impl Bar : Show;\n+\n+fn main() {\n+    let foo = Foo { x: 1, y: 2, z: 3 };\n+    foo.show();\n+\n+    io::println(\"---\");\n+\n+    let baz = Baz(4, 5);\n+    baz.show();\n+\n+    io::println(\"---\");\n+\n+    let boo = Boo(Foo { x: 6, y: 7, z: 8 });\n+    boo.show();\n+}\n+"}]}