{"sha": "3b49ad3814ba36d55273ab0a0dba085b8953c960", "node_id": "C_kwDOAAsO6NoAKDNiNDlhZDM4MTRiYTM2ZDU1MjczYWIwYTBkYmEwODViODk1M2M5NjA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-25T02:37:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-25T02:37:12Z"}, "message": "Rollup merge of #109545 - compiler-errors:rpitit-wf, r=eholk\n\nDeeply check well-formedness of return-position `impl Trait` in trait\n\nWalk the bounds of RPITITs to see if we find any more RPITITs \ud83d\ude38", "tree": {"sha": "30c24ace5f8fe4cb210496be4f5b3e3d4517dc73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30c24ace5f8fe4cb210496be4f5b3e3d4517dc73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b49ad3814ba36d55273ab0a0dba085b8953c960", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkHl5YCRBK7hj4Ov3rIwAAPw8IAGFeTZkaZtL72/j5+v9w/Cj0\nP/UskwHAedypmmRFX04aewPIvKZ6MSusoh9disUgFDE78Rs2WsWViU/+1C72bIdu\nSPNJalmA3TZciDE7L8Tb0D34b59Nzb2LS2SYALeYMemrOSwAMrfGrNHo3RosGoqP\noX4C9c9uUzo0WngyxshQHma69g1gcZwKP//FN3zQHzX+aNrkGFuSe7VLOZw1DuDK\n09ZZbqnykRuGG/6ROQSsVAzmVloBlF/AHUVujg+KzDT9FMU0HkF8wmHtE0B/Ugpo\nIsyRzhhvMezdapYSSQRLhds+PXEGfVY4LcE6+4CIqJ5hlyFBnUpdFu54311gKbk=\n=RYJ1\n-----END PGP SIGNATURE-----\n", "payload": "tree 30c24ace5f8fe4cb210496be4f5b3e3d4517dc73\nparent 8c8305843bd9f80acc871a41ea6e04f5e1760526\nparent b605d0740fff80fad27ef4dcfb2c33866202a6e1\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679711832 +0100\ncommitter GitHub <noreply@github.com> 1679711832 +0100\n\nRollup merge of #109545 - compiler-errors:rpitit-wf, r=eholk\n\nDeeply check well-formedness of return-position `impl Trait` in trait\n\nWalk the bounds of RPITITs to see if we find any more RPITITs \ud83d\ude38\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b49ad3814ba36d55273ab0a0dba085b8953c960", "html_url": "https://github.com/rust-lang/rust/commit/3b49ad3814ba36d55273ab0a0dba085b8953c960", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b49ad3814ba36d55273ab0a0dba085b8953c960/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c8305843bd9f80acc871a41ea6e04f5e1760526", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c8305843bd9f80acc871a41ea6e04f5e1760526", "html_url": "https://github.com/rust-lang/rust/commit/8c8305843bd9f80acc871a41ea6e04f5e1760526"}, {"sha": "b605d0740fff80fad27ef4dcfb2c33866202a6e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b605d0740fff80fad27ef4dcfb2c33866202a6e1", "html_url": "https://github.com/rust-lang/rust/commit/b605d0740fff80fad27ef4dcfb2c33866202a6e1"}], "stats": {"total": 152, "additions": 108, "deletions": 44}, "files": [{"sha": "491bd04f346bd2b7d90ebbc0652c7d6dbe1edba6", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 72, "deletions": 33, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/3b49ad3814ba36d55273ab0a0dba085b8953c960/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b49ad3814ba36d55273ab0a0dba085b8953c960/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=3b49ad3814ba36d55273ab0a0dba085b8953c960", "patch": "@@ -1544,42 +1544,81 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     span: Span,\n ) {\n     let tcx = wfcx.tcx();\n-    if let Some(assoc_item) = tcx.opt_associated_item(fn_def_id.to_def_id())\n-        && assoc_item.container == ty::AssocItemContainer::TraitContainer\n-    {\n-        // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): Even with the new lowering\n-        // strategy, we can't just call `check_associated_item` on the new RPITITs,\n-        // because tests like `tests/ui/async-await/in-trait/implied-bounds.rs` will fail.\n-        // That's because we need to check that the bounds of the RPITIT hold using\n-        // the special substs that we create during opaque type lowering, otherwise we're\n-        // getting a bunch of early bound and free regions mixed up... Haven't looked too\n-        // deep into this, though.\n-        for arg in fn_output.walk() {\n-            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                // RPITITs are always eagerly normalized into opaques, so always look for an\n-                // opaque here.\n-                && let ty::Alias(ty::Opaque, opaque_ty) = ty.kind()\n-                && let Some(opaque_def_id) = opaque_ty.def_id.as_local()\n-                && let opaque = tcx.hir().expect_item(opaque_def_id).expect_opaque_ty()\n-                && let hir::OpaqueTyOrigin::FnReturn(source) | hir::OpaqueTyOrigin::AsyncFn(source) = opaque.origin\n-                && source == fn_def_id\n+    let Some(assoc_item) = tcx.opt_associated_item(fn_def_id.to_def_id()) else {\n+        return;\n+    };\n+    if assoc_item.container != ty::AssocItemContainer::TraitContainer {\n+        return;\n+    }\n+    fn_output.visit_with(&mut ImplTraitInTraitFinder {\n+        wfcx,\n+        fn_def_id,\n+        depth: ty::INNERMOST,\n+        seen: FxHashSet::default(),\n+    });\n+}\n+\n+// FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): Even with the new lowering\n+// strategy, we can't just call `check_associated_item` on the new RPITITs,\n+// because tests like `tests/ui/async-await/in-trait/implied-bounds.rs` will fail.\n+// That's because we need to check that the bounds of the RPITIT hold using\n+// the special substs that we create during opaque type lowering, otherwise we're\n+// getting a bunch of early bound and free regions mixed up... Haven't looked too\n+// deep into this, though.\n+struct ImplTraitInTraitFinder<'a, 'tcx> {\n+    wfcx: &'a WfCheckingCtxt<'a, 'tcx>,\n+    fn_def_id: LocalDefId,\n+    depth: ty::DebruijnIndex,\n+    seen: FxHashSet<DefId>,\n+}\n+impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n+    type BreakTy = !;\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<!> {\n+        let tcx = self.wfcx.tcx();\n+        if let ty::Alias(ty::Opaque, unshifted_opaque_ty) = *ty.kind()\n+            && self.seen.insert(unshifted_opaque_ty.def_id)\n+            && let Some(opaque_def_id) = unshifted_opaque_ty.def_id.as_local()\n+            && let opaque = tcx.hir().expect_item(opaque_def_id).expect_opaque_ty()\n+            && let hir::OpaqueTyOrigin::FnReturn(source) | hir::OpaqueTyOrigin::AsyncFn(source) = opaque.origin\n+            && source == self.fn_def_id\n+        {\n+            let opaque_ty = tcx.fold_regions(unshifted_opaque_ty, |re, depth| {\n+                if let ty::ReLateBound(index, bv) = re.kind() {\n+                    if depth != ty::INNERMOST {\n+                        return tcx.mk_re_error_with_message(\n+                            DUMMY_SP,\n+                            \"we shouldn't walk non-predicate binders with `impl Trait`...\",\n+                        );\n+                    }\n+                    tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n+                } else {\n+                    re\n+                }\n+            });\n+            for (bound, bound_span) in tcx\n+                .bound_explicit_item_bounds(opaque_ty.def_id)\n+                .subst_iter_copied(tcx, opaque_ty.substs)\n             {\n-                let span = tcx.def_span(opaque_ty.def_id);\n-                let bounds = wfcx.tcx().explicit_item_bounds(opaque_ty.def_id);\n-                let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-                    let bound = ty::EarlyBinder(bound).subst(tcx, opaque_ty.substs);\n-                    let normalized_bound = wfcx.normalize(span, None, bound);\n-                    traits::wf::predicate_obligations(\n-                        wfcx.infcx,\n-                        wfcx.param_env,\n-                        wfcx.body_def_id,\n-                        normalized_bound,\n-                        bound_span,\n-                    )\n-                });\n-                wfcx.register_obligations(wf_obligations);\n+                let bound = self.wfcx.normalize(bound_span, None, bound);\n+                self.wfcx.register_obligations(traits::wf::predicate_obligations(\n+                    self.wfcx.infcx,\n+                    self.wfcx.param_env,\n+                    self.wfcx.body_def_id,\n+                    bound,\n+                    bound_span,\n+                ));\n+                // Set the debruijn index back to innermost here, since we already eagerly\n+                // shifted the substs that we use to generate these bounds. This is unfortunately\n+                // subtly different behavior than the `ImplTraitInTraitFinder` we use in `param_env`,\n+                // but that function doesn't actually need to normalize the bound it's visiting\n+                // (whereas we have to do so here)...\n+                let old_depth = std::mem::replace(&mut self.depth, ty::INNERMOST);\n+                bound.visit_with(self);\n+                self.depth = old_depth;\n             }\n         }\n+        ty.super_visit_with(self)\n     }\n }\n "}, {"sha": "1a70716123cfb08afb62f59f0ae2c9d8c3b15da1", "filename": "tests/ui/impl-trait/in-trait/wf-bounds.current.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b49ad3814ba36d55273ab0a0dba085b8953c960/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b49ad3814ba36d55273ab0a0dba085b8953c960/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.current.stderr?ref=3b49ad3814ba36d55273ab0a0dba085b8953c960", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/wf-bounds.rs:11:22\n+  --> $DIR/wf-bounds.rs:13:22\n    |\n LL |     fn nya() -> impl Wf<Vec<[u8]>>;\n    |                      ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n@@ -9,7 +9,7 @@ note: required by a bound in `Vec`\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/wf-bounds.rs:14:23\n+  --> $DIR/wf-bounds.rs:16:23\n    |\n LL |     fn nya2() -> impl Wf<[u8]>;\n    |                       ^^^^^^^^ doesn't have a size known at compile-time\n@@ -18,13 +18,23 @@ LL |     fn nya2() -> impl Wf<[u8]>;\n note: required by a bound in `Wf`\n   --> $DIR/wf-bounds.rs:8:10\n    |\n-LL | trait Wf<T> {}\n+LL | trait Wf<T> {\n    |          ^ required by this bound in `Wf`\n help: consider relaxing the implicit `Sized` restriction\n    |\n-LL | trait Wf<T: ?Sized> {}\n+LL | trait Wf<T: ?Sized> {\n    |           ++++++++\n \n-error: aborting due to 2 previous errors\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/wf-bounds.rs:19:44\n+   |\n+LL |     fn nya3() -> impl Wf<(), Output = impl Wf<Vec<[u8]>>>;\n+   |                                            ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[u8]`\n+note: required by a bound in `Vec`\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "1a70716123cfb08afb62f59f0ae2c9d8c3b15da1", "filename": "tests/ui/impl-trait/in-trait/wf-bounds.next.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b49ad3814ba36d55273ab0a0dba085b8953c960/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b49ad3814ba36d55273ab0a0dba085b8953c960/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.next.stderr?ref=3b49ad3814ba36d55273ab0a0dba085b8953c960", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/wf-bounds.rs:11:22\n+  --> $DIR/wf-bounds.rs:13:22\n    |\n LL |     fn nya() -> impl Wf<Vec<[u8]>>;\n    |                      ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n@@ -9,7 +9,7 @@ note: required by a bound in `Vec`\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/wf-bounds.rs:14:23\n+  --> $DIR/wf-bounds.rs:16:23\n    |\n LL |     fn nya2() -> impl Wf<[u8]>;\n    |                       ^^^^^^^^ doesn't have a size known at compile-time\n@@ -18,13 +18,23 @@ LL |     fn nya2() -> impl Wf<[u8]>;\n note: required by a bound in `Wf`\n   --> $DIR/wf-bounds.rs:8:10\n    |\n-LL | trait Wf<T> {}\n+LL | trait Wf<T> {\n    |          ^ required by this bound in `Wf`\n help: consider relaxing the implicit `Sized` restriction\n    |\n-LL | trait Wf<T: ?Sized> {}\n+LL | trait Wf<T: ?Sized> {\n    |           ++++++++\n \n-error: aborting due to 2 previous errors\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/wf-bounds.rs:19:44\n+   |\n+LL |     fn nya3() -> impl Wf<(), Output = impl Wf<Vec<[u8]>>>;\n+   |                                            ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `[u8]`\n+note: required by a bound in `Vec`\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "1c9590bd853d122b1c24001392cce618941f3415", "filename": "tests/ui/impl-trait/in-trait/wf-bounds.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b49ad3814ba36d55273ab0a0dba085b8953c960/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b49ad3814ba36d55273ab0a0dba085b8953c960/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwf-bounds.rs?ref=3b49ad3814ba36d55273ab0a0dba085b8953c960", "patch": "@@ -5,14 +5,19 @@\n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n \n-trait Wf<T> {}\n+trait Wf<T> {\n+    type Output;\n+}\n \n trait Uwu {\n     fn nya() -> impl Wf<Vec<[u8]>>;\n     //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n \n     fn nya2() -> impl Wf<[u8]>;\n     //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n+\n+    fn nya3() -> impl Wf<(), Output = impl Wf<Vec<[u8]>>>;\n+    //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n }\n \n fn main() {}"}]}