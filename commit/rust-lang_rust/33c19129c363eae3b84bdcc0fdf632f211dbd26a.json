{"sha": "33c19129c363eae3b84bdcc0fdf632f211dbd26a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYzE5MTI5YzM2M2VhZTNiODRiZGNjMGZkZjYzMmYyMTFkYmQyNmE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T12:13:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-25T12:13:25Z"}, "message": "Rollup merge of #39980 - arielb1:privately-uninhabited, r=nikomatsakis\n\ncheck_match: don't treat privately uninhabited types as uninhabited\n\nFixes #38972, which is a regression in 1.16 from @canndrew's patchset.\n\nr? @nikomatsakis\n\nbeta-nominating because regression.", "tree": {"sha": "194265bf8f890eabd02a94afcac327e70a3d552b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/194265bf8f890eabd02a94afcac327e70a3d552b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33c19129c363eae3b84bdcc0fdf632f211dbd26a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33c19129c363eae3b84bdcc0fdf632f211dbd26a", "html_url": "https://github.com/rust-lang/rust/commit/33c19129c363eae3b84bdcc0fdf632f211dbd26a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33c19129c363eae3b84bdcc0fdf632f211dbd26a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef043a7c43070e125361e6609c85ea8a67631e0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef043a7c43070e125361e6609c85ea8a67631e0d", "html_url": "https://github.com/rust-lang/rust/commit/ef043a7c43070e125361e6609c85ea8a67631e0d"}, {"sha": "87e544bca5ae1bd187f11239abcab1f73c836049", "url": "https://api.github.com/repos/rust-lang/rust/commits/87e544bca5ae1bd187f11239abcab1f73c836049", "html_url": "https://github.com/rust-lang/rust/commit/87e544bca5ae1bd187f11239abcab1f73c836049"}], "stats": {"total": 191, "additions": 154, "deletions": 37}, "files": [{"sha": "5a9f885719c8fd8ab52e425218d1621600bb513a", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=33c19129c363eae3b84bdcc0fdf632f211dbd26a", "patch": "@@ -196,6 +196,28 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             }\n         }).clone()\n     }\n+\n+    fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n+        if self.tcx.sess.features.borrow().never_type {\n+            ty.is_uninhabited_from(self.module, self.tcx)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn is_variant_uninhabited(&self,\n+                              variant: &'tcx ty::VariantDef,\n+                              substs: &'tcx ty::subst::Substs<'tcx>) -> bool\n+    {\n+        if self.tcx.sess.features.borrow().never_type {\n+            let forest = variant.uninhabited_from(\n+                &mut FxHashMap::default(), self.tcx, substs, AdtKind::Enum\n+            );\n+            forest.contains(self.tcx, self.module)\n+        } else {\n+            false\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -379,48 +401,32 @@ impl<'tcx> Witness<'tcx> {\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>) -> Vec<Constructor>\n {\n-    let check_inhabited = cx.tcx.sess.features.borrow().never_type;\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(ref sub_ty) => {\n-            if sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n-                && check_inhabited\n-            {\n+            if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n         ty::TyArray(ref sub_ty, length) => {\n-            if length == 0 || !(sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n-                                && check_inhabited)\n-            {\n-                vec![Slice(length)]\n-            } else {\n+            if length > 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n+            } else {\n+                vec![Slice(length)]\n             }\n         }\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n-            def.variants.iter().filter_map(|v| {\n-                let mut visited = FxHashMap::default();\n-                let forest = v.uninhabited_from(&mut visited,\n-                                                cx.tcx, substs,\n-                                                AdtKind::Enum);\n-                if forest.contains(cx.tcx, cx.module)\n-                    && check_inhabited\n-                {\n-                    None\n-                } else {\n-                    Some(Variant(v.did))\n-                }\n-            }).collect()\n+            def.variants.iter()\n+                .filter(|v| !cx.is_variant_uninhabited(v, substs))\n+                .map(|v| Variant(v.did))\n+                .collect()\n         }\n         _ => {\n-            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx)\n-                    && check_inhabited\n-            {\n+            if cx.is_uninhabited(pcx.ty) {\n                 vec![]\n             } else {\n                 vec![Single]\n@@ -564,7 +570,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-\n     let pcx = PatternContext {\n         ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error())\n             .unwrap_or(v[0].ty),\n@@ -590,7 +595,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n             !used_ctors.contains(*c)\n         }).cloned().collect();\n-        debug!(\"missing_ctors = {:?}\", missing_ctors);\n \n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n@@ -599,8 +603,23 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // Therefore, if there is some pattern that is unmatched by `matrix`,\n         // it will still be unmatched if the first constructor is replaced by\n         // any of the constructors in `missing_ctors`\n-\n-        if missing_ctors.is_empty() {\n+        //\n+        // However, if our scrutinee is *privately* an empty enum, we\n+        // must treat it as though it had an \"unknown\" constructor (in\n+        // that case, all other patterns obviously can't be variants)\n+        // to avoid exposing its emptyness. See the `match_privately_empty`\n+        // test for details.\n+        //\n+        // FIXME: currently the only way I know of something can\n+        // be a privately-empty enum is when the never_type\n+        // feature flag is not present, so this is only\n+        // needed for that case.\n+\n+        let is_privately_empty =\n+            all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+        debug!(\"missing_ctors={:?} is_privately_empty={:?}\", missing_ctors,\n+               is_privately_empty);\n+        if missing_ctors.is_empty() && !is_privately_empty {\n             all_ctors.into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n@@ -649,6 +668,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n+    debug!(\"is_useful_specialized({:?}, {:?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n         Pattern {\n@@ -754,7 +774,19 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n         ty::TyAdt(adt, substs) => {\n             adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n-                field.ty(cx.tcx, substs)\n+                let is_visible = adt.is_enum()\n+                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                if is_visible {\n+                    field.ty(cx.tcx, substs)\n+                } else {\n+                    // Treat all non-visible fields as nil. They\n+                    // can't appear in any other pattern from\n+                    // this match (because they are private),\n+                    // so their type does not matter - but\n+                    // we don't want to know they are\n+                    // uninhabited.\n+                    cx.tcx.mk_nil()\n+                }\n             }).collect()\n         }\n         _ => vec![],"}, {"sha": "9b30946c0bebbc1d834cd9cdd045352dbd76be28", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=33c19129c363eae3b84bdcc0fdf632f211dbd26a", "patch": "@@ -177,6 +177,31 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Fourth, check for unreachable arms.\n             check_arms(cx, &inlined_arms, source);\n \n+            // Then, if the match has no arms, check whether the scrutinee\n+            // is uninhabited.\n+            let pat_ty = self.tables.node_id_to_type(scrut.id);\n+            let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(scrut.id));\n+            if inlined_arms.is_empty() {\n+                let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n+                    pat_ty.is_uninhabited_from(module, self.tcx)\n+                } else {\n+                    self.conservative_is_uninhabited(pat_ty)\n+                };\n+                if !scrutinee_is_uninhabited {\n+                    // We know the type is inhabited, so this must be wrong\n+                    let mut err = create_e0004(self.tcx.sess, scrut.span,\n+                                               format!(\"non-exhaustive patterns: type {} \\\n+                                                        is non-empty\",\n+                                                       pat_ty));\n+                    span_help!(&mut err, scrut.span,\n+                               \"Please ensure that all possible cases are being handled; \\\n+                                possibly adding wildcards or more match arms.\");\n+                    err.emit();\n+                }\n+                // If the type *is* uninhabited, it's vacuously exhaustive\n+                return;\n+            }\n+\n             let matrix: Matrix = inlined_arms\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n@@ -188,6 +213,15 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         })\n     }\n \n+    fn conservative_is_uninhabited(&self, scrutinee_ty: Ty<'tcx>) -> bool {\n+        // \"rustc-1.0-style\" uncontentious uninhabitableness check\n+        match scrutinee_ty.sty {\n+            ty::TyNever => true,\n+            ty::TyAdt(def, _) => def.variants.is_empty(),\n+            _ => false\n+        }\n+    }\n+\n     fn check_irrefutable(&self, pat: &Pat, is_fn_arg: bool) {\n         let origin = if is_fn_arg {\n             \"function argument\""}, {"sha": "3affb1c03e952ab3bc8276794cbcb2acd8299148", "filename": "src/test/compile-fail/match-privately-empty.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-privately-empty.rs?ref=33c19129c363eae3b84bdcc0fdf632f211dbd26a", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(never_type)]\n+\n+mod private {\n+    pub struct Private {\n+        _bot: !,\n+        pub misc: bool,\n+    }\n+    pub const DATA: Option<Private> = None;\n+}\n+\n+fn main() {\n+    match private::DATA {\n+    //~^ ERROR non-exhaustive patterns: `Some(Private { misc: true, .. })` not covered\n+        None => {}\n+        Some(private::Private {\n+            misc: false,\n+            ..\n+        }) => {}\n+    }\n+}"}, {"sha": "0c3ea53a903ae9062c03098e6ee2838a975b4a1a", "filename": "src/test/compile-fail/uninhabited-matches-feature-gated.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs?ref=33c19129c363eae3b84bdcc0fdf632f211dbd26a", "patch": "@@ -19,16 +19,13 @@ fn main() {\n     };\n \n     let x: &Void = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; //~ ERROR non-exhaustive\n \n     let x: (Void,) = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; //~ ERROR non-exhaustive\n \n     let x: [Void; 1] = unsafe { std::mem::uninitialized() };\n-    let _ = match x {};\n-    //~^ ERROR non-exhaustive\n+    let _ = match x {}; //~ ERROR non-exhaustive\n \n     let x: &[Void] = unsafe { std::mem::uninitialized() };\n     let _ = match x {   //~ ERROR non-exhaustive\n@@ -47,4 +44,3 @@ fn main() {\n     let Ok(x) = x;\n     //~^ ERROR refutable\n }\n-"}, {"sha": "d5df84e0fb083d9f51952cdb11341ce84706cb5c", "filename": "src/test/run-pass/issue-38972.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Ftest%2Frun-pass%2Fissue-38972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c19129c363eae3b84bdcc0fdf632f211dbd26a/src%2Ftest%2Frun-pass%2Fissue-38972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-38972.rs?ref=33c19129c363eae3b84bdcc0fdf632f211dbd26a", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This issue tracks a regression (a new warning) without\n+// feature(never_type). When we make that the default, please\n+// remove this test.\n+\n+enum Foo { }\n+\n+fn make_foo() -> Option<Foo> { None }\n+\n+#[deny(warnings)]\n+fn main() {\n+    match make_foo() {\n+        None => {},\n+        Some(_) => {}\n+    }\n+}"}]}