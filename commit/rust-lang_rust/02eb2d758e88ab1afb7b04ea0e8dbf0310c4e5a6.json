{"sha": "02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "node_id": "C_kwDOAAsO6NoAKDAyZWIyZDc1OGU4OGFiMWFmYjdiMDRlYTBlOGRiZjAzMTBjNGU1YTY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T15:44:25Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T15:52:09Z"}, "message": "Distinguish between expected and final type in CoerceMany", "tree": {"sha": "635bf2237ce5b8a99a36cc3589f04da2fa683906", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/635bf2237ce5b8a99a36cc3589f04da2fa683906"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "html_url": "https://github.com/rust-lang/rust/commit/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c229a836e8397afba3fddfb062aa764a620a8098", "url": "https://api.github.com/repos/rust-lang/rust/commits/c229a836e8397afba3fddfb062aa764a620a8098", "html_url": "https://github.com/rust-lang/rust/commit/c229a836e8397afba3fddfb062aa764a620a8098"}], "stats": {"total": 275, "additions": 187, "deletions": 88}, "files": [{"sha": "d3e7f6e7dcafcaa8ea5fd52e53572bd3a02df915", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "patch": "@@ -66,8 +66,10 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n     let mut ctx = InferenceContext::new(db, def, &body, resolver);\n \n     match def {\n+        DefWithBodyId::FunctionId(f) => {\n+            ctx.collect_fn(f);\n+        }\n         DefWithBodyId::ConstId(c) => ctx.collect_const(&db.const_data(c)),\n-        DefWithBodyId::FunctionId(f) => ctx.collect_fn(f),\n         DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n         DefWithBodyId::VariantId(v) => {\n             ctx.return_ty = TyBuilder::builtin(match db.enum_data(v.parent).variant_body_type() {\n@@ -392,9 +394,12 @@ pub(crate) struct InferenceContext<'a> {\n     /// currently within one.\n     ///\n     /// We might consider using a nested inference context for checking\n-    /// closures, but currently this is the only field that will change there,\n-    /// so it doesn't make sense.\n+    /// closures so we can swap all shared things out at once.\n     return_ty: Ty,\n+    /// If `Some`, this stores coercion information for returned\n+    /// expressions. If `None`, this is in a context where return is\n+    /// inappropriate, such as a const expression.\n+    return_coercion: Option<CoerceMany>,\n     /// The resume type and the yield type, respectively, of the generator being inferred.\n     resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n@@ -462,6 +467,7 @@ impl<'a> InferenceContext<'a> {\n             trait_env,\n             return_ty: TyKind::Error.intern(Interner), // set in collect_* calls\n             resume_yield_tys: None,\n+            return_coercion: None,\n             db,\n             owner,\n             body,\n@@ -595,10 +601,19 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         self.return_ty = self.normalize_associated_types_in(return_ty);\n+        self.return_coercion = Some(CoerceMany::new(self.return_ty.clone()));\n     }\n \n     fn infer_body(&mut self) {\n-        self.infer_expr_coerce(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n+        match self.return_coercion {\n+            Some(_) => self.infer_return(self.body.body_expr),\n+            None => {\n+                _ = self.infer_expr_coerce(\n+                    self.body.body_expr,\n+                    &Expectation::has_type(self.return_ty.clone()),\n+                )\n+            }\n+        }\n     }\n \n     fn write_expr_ty(&mut self, expr: ExprId, ty: Ty) {"}, {"sha": "8bce47d71cba64b9f2a376fb24d856d11380216e", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "patch": "@@ -50,11 +50,44 @@ fn success(\n #[derive(Clone, Debug)]\n pub(super) struct CoerceMany {\n     expected_ty: Ty,\n+    final_ty: Option<Ty>,\n }\n \n impl CoerceMany {\n     pub(super) fn new(expected: Ty) -> Self {\n-        CoerceMany { expected_ty: expected }\n+        CoerceMany { expected_ty: expected, final_ty: None }\n+    }\n+\n+    /// Returns the \"expected type\" with which this coercion was\n+    /// constructed. This represents the \"downward propagated\" type\n+    /// that was given to us at the start of typing whatever construct\n+    /// we are typing (e.g., the match expression).\n+    ///\n+    /// Typically, this is used as the expected type when\n+    /// type-checking each of the alternative expressions whose types\n+    /// we are trying to merge.\n+    pub(super) fn expected_ty(&self) -> Ty {\n+        self.expected_ty.clone()\n+    }\n+\n+    /// Returns the current \"merged type\", representing our best-guess\n+    /// at the LUB of the expressions we've seen so far (if any). This\n+    /// isn't *final* until you call `self.complete()`, which will return\n+    /// the merged type.\n+    pub(super) fn merged_ty(&self) -> Ty {\n+        self.final_ty.clone().unwrap_or_else(|| self.expected_ty.clone())\n+    }\n+\n+    pub(super) fn complete(self, ctx: &mut InferenceContext<'_>) -> Ty {\n+        if let Some(final_ty) = self.final_ty {\n+            final_ty\n+        } else {\n+            ctx.result.standard_types.never.clone()\n+        }\n+    }\n+\n+    pub(super) fn coerce_forced_unit(&mut self, ctx: &mut InferenceContext<'_>) {\n+        self.coerce(ctx, None, &ctx.result.standard_types.unit.clone())\n     }\n \n     /// Merge two types from different branches, with possible coercion.\n@@ -76,51 +109,46 @@ impl CoerceMany {\n         // Special case: two function types. Try to coerce both to\n         // pointers to have a chance at getting a match. See\n         // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n-        let sig = match (self.expected_ty.kind(Interner), expr_ty.kind(Interner)) {\n+        let sig = match (self.merged_ty().kind(Interner), expr_ty.kind(Interner)) {\n             (TyKind::FnDef(..) | TyKind::Closure(..), TyKind::FnDef(..) | TyKind::Closure(..)) => {\n                 // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n                 // we should be coercing the closure to a fn pointer of the safety of the FnDef\n                 cov_mark::hit!(coerce_fn_reification);\n                 let sig =\n-                    self.expected_ty.callable_sig(ctx.db).expect(\"FnDef without callable sig\");\n+                    self.merged_ty().callable_sig(ctx.db).expect(\"FnDef without callable sig\");\n                 Some(sig)\n             }\n             _ => None,\n         };\n         if let Some(sig) = sig {\n             let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(Interner);\n-            let result1 = ctx.table.coerce_inner(self.expected_ty.clone(), &target_ty);\n+            let result1 = ctx.table.coerce_inner(self.merged_ty(), &target_ty);\n             let result2 = ctx.table.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n                 ctx.table.register_infer_ok(result1);\n                 ctx.table.register_infer_ok(result2);\n-                return self.expected_ty = target_ty;\n+                return self.final_ty = Some(target_ty);\n             }\n         }\n \n         // It might not seem like it, but order is important here: If the expected\n         // type is a type variable and the new one is `!`, trying it the other\n         // way around first would mean we make the type variable `!`, instead of\n         // just marking it as possibly diverging.\n-        if ctx.coerce(expr, &expr_ty, &self.expected_ty).is_ok() {\n-            /* self.expected_ty is already correct */\n-        } else if ctx.coerce(expr, &self.expected_ty, &expr_ty).is_ok() {\n-            self.expected_ty = expr_ty;\n+        if let Ok(res) = ctx.coerce(expr, &expr_ty, &self.merged_ty()) {\n+            self.final_ty = Some(res);\n+        } else if let Ok(res) = ctx.coerce(expr, &self.merged_ty(), &expr_ty) {\n+            self.final_ty = Some(res);\n         } else {\n             if let Some(id) = expr {\n                 ctx.result.type_mismatches.insert(\n                     id.into(),\n-                    TypeMismatch { expected: self.expected_ty.clone(), actual: expr_ty },\n+                    TypeMismatch { expected: self.merged_ty().clone(), actual: expr_ty.clone() },\n                 );\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);\n-            /* self.expected_ty is already correct */\n         }\n     }\n-\n-    pub(super) fn complete(self) -> Ty {\n-        self.expected_ty\n-    }\n }\n \n pub fn could_coerce("}, {"sha": "b650afe9963c1d7bd31d75390e2c8b90685bae69", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 125, "deletions": 69, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "patch": "@@ -60,6 +60,10 @@ impl<'a> InferenceContext<'a> {\n         ty\n     }\n \n+    pub(crate) fn infer_expr_no_expect(&mut self, tgt_expr: ExprId) -> Ty {\n+        self.infer_expr_inner(tgt_expr, &Expectation::None)\n+    }\n+\n     /// Infer type of expression with possibly implicit coerce to the expected type.\n     /// Return the type after possible coercion.\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n@@ -99,17 +103,20 @@ impl<'a> InferenceContext<'a> {\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut coerce = CoerceMany::new(expected.coercion_target_type(&mut self.table));\n                 coerce.coerce(self, Some(then_branch), &then_ty);\n-                let else_ty = match else_branch {\n-                    Some(else_branch) => self.infer_expr_inner(else_branch, expected),\n-                    None => TyBuilder::unit(),\n-                };\n+                match else_branch {\n+                    Some(else_branch) => {\n+                        let else_ty = self.infer_expr_inner(else_branch, expected);\n+                        coerce.coerce(self, Some(else_branch), &else_ty);\n+                    }\n+                    None => {\n+                        coerce.coerce_forced_unit(self);\n+                    }\n+                }\n                 both_arms_diverge &= self.diverges;\n-                // FIXME: create a synthetic `else {}` so we have something to refer to here instead of None?\n-                coerce.coerce(self, else_branch, &else_ty);\n \n                 self.diverges = condition_diverges | both_arms_diverge;\n \n-                coerce.complete()\n+                coerce.complete(self)\n             }\n             &Expr::Let { pat, expr } => {\n                 let input_ty = self.infer_expr(expr, &Expectation::none());\n@@ -172,6 +179,8 @@ impl<'a> InferenceContext<'a> {\n                 let ret_ty = self.table.new_type_var();\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_ret_coercion =\n+                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n \n                 let (_, inner_ty) =\n                     self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n@@ -180,6 +189,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.return_coercion = prev_ret_coercion;\n \n                 // Use the first type parameter as the output type of future.\n                 // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n@@ -303,17 +313,21 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n \n+                // FIXME: lift these out into a struct\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_ret_coercion =\n+                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n                 let prev_resume_yield_tys =\n                     mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n                 self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n-                    this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                    this.infer_return(*body);\n                 });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.return_coercion = prev_ret_coercion;\n                 self.resume_yield_tys = prev_resume_yield_tys;\n \n                 ty\n@@ -413,7 +427,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.diverges = matchee_diverges | all_arms_diverge;\n \n-                coerce.complete()\n+                coerce.complete(self)\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -431,7 +445,12 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = *expr {\n-                    self.infer_expr(expr, &Expectation::none())\n+                    let opt_coerce_to = find_breakable(&mut self.breakables, label.as_ref())\n+                        .map(|ctxt| ctxt.coerce.expected_ty());\n+                    self.infer_expr_inner(\n+                        expr,\n+                        &Expectation::HasType(opt_coerce_to.unwrap_or_else(|| self.err_ty())),\n+                    )\n                 } else {\n                     TyBuilder::unit()\n                 };\n@@ -461,15 +480,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 self.result.standard_types.never.clone()\n             }\n-            Expr::Return { expr } => {\n-                if let Some(expr) = expr {\n-                    self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n-                } else {\n-                    let unit = TyBuilder::unit();\n-                    let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n-                }\n-                self.result.standard_types.never.clone()\n-            }\n+            &Expr::Return { expr } => self.infer_expr_return(expr),\n             Expr::Yield { expr } => {\n                 if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n                     if let Some(expr) = expr {\n@@ -486,7 +497,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Yeet { expr } => {\n                 if let &Some(expr) = expr {\n-                    self.infer_expr_inner(expr, &Expectation::None);\n+                    self.infer_expr_no_expect(expr);\n                 }\n                 self.result.standard_types.never.clone()\n             }\n@@ -614,7 +625,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::Cast { expr, type_ref } => {\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME: propagate the \"castable to\" expectation\n-                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::None);\n+                let _inner_ty = self.infer_expr_no_expect(*expr);\n                 // FIXME check the cast...\n                 cast_ty\n             }\n@@ -810,53 +821,7 @@ impl<'a> InferenceContext<'a> {\n \n                 TyKind::Tuple(tys.len(), Substitution::from_iter(Interner, tys)).intern(Interner)\n             }\n-            Expr::Array(array) => {\n-                let elem_ty =\n-                    match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(Interner)) {\n-                        Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n-                        _ => self.table.new_type_var(),\n-                    };\n-                let mut coerce = CoerceMany::new(elem_ty.clone());\n-\n-                let expected = Expectation::has_type(elem_ty.clone());\n-                let len = match array {\n-                    Array::ElementList { elements, .. } => {\n-                        for &expr in elements.iter() {\n-                            let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n-                            coerce.coerce(self, Some(expr), &cur_elem_ty);\n-                        }\n-                        consteval::usize_const(\n-                            self.db,\n-                            Some(elements.len() as u128),\n-                            self.resolver.krate(),\n-                        )\n-                    }\n-                    &Array::Repeat { initializer, repeat } => {\n-                        self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n-                        self.infer_expr(\n-                            repeat,\n-                            &Expectation::HasType(\n-                                TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n-                            ),\n-                        );\n-\n-                        if let Some(g_def) = self.owner.as_generic_def_id() {\n-                            let generics = generics(self.db.upcast(), g_def);\n-                            consteval::eval_to_const(\n-                                repeat,\n-                                ParamLoweringMode::Placeholder,\n-                                self,\n-                                || generics,\n-                                DebruijnIndex::INNERMOST,\n-                            )\n-                        } else {\n-                            consteval::usize_const(self.db, None, self.resolver.krate())\n-                        }\n-                    }\n-                };\n-\n-                TyKind::Array(coerce.complete(), len).intern(Interner)\n-            }\n+            Expr::Array(array) => self.infer_expr_array(array, expected),\n             Expr::Literal(lit) => match lit {\n                 Literal::Bool(..) => self.result.standard_types.bool_.clone(),\n                 Literal::String(..) => {\n@@ -915,6 +880,97 @@ impl<'a> InferenceContext<'a> {\n         ty\n     }\n \n+    fn infer_expr_array(\n+        &mut self,\n+        array: &Array,\n+        expected: &Expectation,\n+    ) -> chalk_ir::Ty<Interner> {\n+        let elem_ty = match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(Interner)) {\n+            Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n+            _ => self.table.new_type_var(),\n+        };\n+\n+        let krate = self.resolver.krate();\n+\n+        let expected = Expectation::has_type(elem_ty.clone());\n+        let (elem_ty, len) = match array {\n+            Array::ElementList { elements, .. } if elements.is_empty() => {\n+                (elem_ty, consteval::usize_const(self.db, Some(0), krate))\n+            }\n+            Array::ElementList { elements, .. } => {\n+                let mut coerce = CoerceMany::new(elem_ty.clone());\n+                for &expr in elements.iter() {\n+                    let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n+                    coerce.coerce(self, Some(expr), &cur_elem_ty);\n+                }\n+                (\n+                    coerce.complete(self),\n+                    consteval::usize_const(self.db, Some(elements.len() as u128), krate),\n+                )\n+            }\n+            &Array::Repeat { initializer, repeat } => {\n+                self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty.clone()));\n+                self.infer_expr(\n+                    repeat,\n+                    &Expectation::HasType(\n+                        TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n+                    ),\n+                );\n+\n+                (\n+                    elem_ty,\n+                    if let Some(g_def) = self.owner.as_generic_def_id() {\n+                        let generics = generics(self.db.upcast(), g_def);\n+                        consteval::eval_to_const(\n+                            repeat,\n+                            ParamLoweringMode::Placeholder,\n+                            self,\n+                            || generics,\n+                            DebruijnIndex::INNERMOST,\n+                        )\n+                    } else {\n+                        consteval::usize_const(self.db, None, krate)\n+                    },\n+                )\n+            }\n+        };\n+\n+        TyKind::Array(elem_ty, len).intern(Interner)\n+    }\n+\n+    pub(super) fn infer_return(&mut self, expr: ExprId) {\n+        let ret_ty = self\n+            .return_coercion\n+            .as_mut()\n+            .expect(\"infer_return called outside function body\")\n+            .expected_ty();\n+        let return_expr_ty = self.infer_expr_inner(expr, &Expectation::HasType(ret_ty));\n+        let mut coerce_many = self.return_coercion.take().unwrap();\n+        coerce_many.coerce(self, Some(expr), &return_expr_ty);\n+        self.return_coercion = Some(coerce_many);\n+    }\n+\n+    fn infer_expr_return(&mut self, expr: Option<ExprId>) -> Ty {\n+        match self.return_coercion {\n+            Some(_) => {\n+                if let Some(expr) = expr {\n+                    self.infer_return(expr);\n+                } else {\n+                    let mut coerce = self.return_coercion.take().unwrap();\n+                    coerce.coerce_forced_unit(self);\n+                    self.return_coercion = Some(coerce);\n+                }\n+            }\n+            None => {\n+                // FIXME: diagnose return outside of function\n+                if let Some(expr) = expr {\n+                    self.infer_expr_no_expect(expr);\n+                }\n+            }\n+        }\n+        self.result.standard_types.never.clone()\n+    }\n+\n     fn infer_expr_box(&mut self, inner_expr: ExprId, expected: &Expectation) -> Ty {\n         if let Some(box_id) = self.resolve_boxed_box() {\n             let table = &mut self.table;\n@@ -1666,6 +1722,6 @@ impl<'a> InferenceContext<'a> {\n         });\n         let res = cb(self);\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n-        (ctx.may_break.then(|| ctx.coerce.complete()), res)\n+        (ctx.may_break.then(|| ctx.coerce.complete(self)), res)\n     }\n }"}]}