{"sha": "34b359be1ec89383baff1dba5f74f5bfe8beedd7", "node_id": "C_kwDOAAsO6NoAKDM0YjM1OWJlMWVjODkzODNiYWZmMWRiYTVmNzRmNWJmZThiZWVkZDc", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-05T18:31:44Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-05T18:36:49Z"}, "message": "more spin-loop-tests", "tree": {"sha": "ae150e7a9a45d47cf51b889bd070105a0df16793", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae150e7a9a45d47cf51b889bd070105a0df16793"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34b359be1ec89383baff1dba5f74f5bfe8beedd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34b359be1ec89383baff1dba5f74f5bfe8beedd7", "html_url": "https://github.com/rust-lang/rust/commit/34b359be1ec89383baff1dba5f74f5bfe8beedd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34b359be1ec89383baff1dba5f74f5bfe8beedd7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47745380cd3928779361d34327b622e3813cda93", "url": "https://api.github.com/repos/rust-lang/rust/commits/47745380cd3928779361d34327b622e3813cda93", "html_url": "https://github.com/rust-lang/rust/commit/47745380cd3928779361d34327b622e3813cda93"}], "stats": {"total": 67, "additions": 59, "deletions": 8}, "files": [{"sha": "a6fceb03638dd873dc404f4a27ec00e38cf85d8b", "filename": "tests/pass/concurrency/spin_loops.rs", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/34b359be1ec89383baff1dba5f74f5bfe8beedd7/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b359be1ec89383baff1dba5f74f5bfe8beedd7/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs?ref=34b359be1ec89383baff1dba5f74f5bfe8beedd7", "patch": "@@ -1,16 +1,17 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n \n use std::thread;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+use std::sync::mpsc;\n+use std::cell::Cell;\n \n-static FLAG: AtomicUsize = AtomicUsize::new(0);\n+/// When a thread yields, Miri's scheduler used to pick the thread with the lowest ID\n+/// that can run. IDs are assigned in thread creation order.\n+/// This means we could make 2 threads infinitely ping-pong with each other while\n+/// really there is a 3rd thread that we should schedule to make progress.\n+fn two_player_ping_pong() {\n+    static FLAG: AtomicUsize = AtomicUsize::new(0);\n \n-// When a thread yields, Miri's scheduler used to pick the thread with the lowest ID\n-// that can run. IDs are assigned in thread creation order.\n-// This means we could make 2 threads infinitely ping-pong with each other while\n-// really there is a 3rd thread that we should schedule to make progress.\n-\n-fn main() {\n     let waiter1 = thread::spawn(|| {\n         while FLAG.load(Ordering::Acquire) == 0 {\n             // spin and wait\n@@ -31,3 +32,51 @@ fn main() {\n     waiter2.join().unwrap();\n     progress.join().unwrap();\n }\n+\n+/// Based on a test by @jethrogb.\n+fn launcher() {\n+    static THREAD2_LAUNCHED: AtomicBool = AtomicBool::new(false);\n+\n+    for _ in 0..10 {\n+        let (tx, rx) = mpsc::sync_channel(0);\n+        THREAD2_LAUNCHED.store(false, Ordering::SeqCst);\n+\n+        let jh = thread::spawn(move || {\n+            struct RecvOnDrop(Cell<Option<mpsc::Receiver<()>>>);\n+\n+            impl Drop for RecvOnDrop {\n+                fn drop(&mut self) {\n+                    let rx = self.0.take().unwrap();\n+                    while !THREAD2_LAUNCHED.load(Ordering::SeqCst) {\n+                        thread::yield_now();\n+                    }\n+                    rx.recv().unwrap();\n+                }\n+            }\n+\n+            let tl_rx: RecvOnDrop = RecvOnDrop(Cell::new(None));\n+            tl_rx.0.set(Some(rx));\n+        });\n+\n+        let tx_clone = tx.clone();\n+        let jh2 = thread::spawn(move || {\n+            THREAD2_LAUNCHED.store(true, Ordering::SeqCst);\n+            jh.join().unwrap();\n+            tx_clone.send(()).expect_err(\n+                \"Expecting channel to be closed because thread 1 TLS destructors must've run\",\n+            );\n+        });\n+\n+        while !THREAD2_LAUNCHED.load(Ordering::SeqCst) {\n+            thread::yield_now();\n+        }\n+        thread::yield_now();\n+        tx.send(()).expect(\"Expecting channel to be live because thread 2 must block on join\");\n+        jh2.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    two_player_ping_pong();\n+    launcher();\n+}"}, {"sha": "03676519d4f1c052581dee9227a650c2a4b8d782", "filename": "tests/pass/concurrency/spin_loops.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34b359be1ec89383baff1dba5f74f5bfe8beedd7/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34b359be1ec89383baff1dba5f74f5bfe8beedd7/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr?ref=34b359be1ec89383baff1dba5f74f5bfe8beedd7", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+"}]}