{"sha": "2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYTljOGRmMGY3YzllZTcyOTEzODgzMTI4YjM3ZDBhODBkMmY0ZjY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-12T06:42:26Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-12T23:52:26Z"}, "message": "Accept prefix notation for writing the types of str/~ and friends.", "tree": {"sha": "b3e4acbf2912f804cb45f87e8819a5e4847ec213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3e4acbf2912f804cb45f87e8819a5e4847ec213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "html_url": "https://github.com/rust-lang/rust/commit/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acb86921a62ba01726fd922f55d0176fa6c1df7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/acb86921a62ba01726fd922f55d0176fa6c1df7c", "html_url": "https://github.com/rust-lang/rust/commit/acb86921a62ba01726fd922f55d0176fa6c1df7c"}], "stats": {"total": 345, "additions": 198, "deletions": 147}, "files": [{"sha": "3f5c22f340413aaea87c8a64d20b20042b3f7289", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -1347,7 +1347,7 @@ imply ownership. Pointers may be borrowed from any type, in which case\n the pointer is guaranteed not to outlive the value it points to.\n \n ~~~~\n-# fn work_with_foo_by_pointer(f: &str) { }\n+# fn work_with_foo_by_pointer(f: &str/~) { }\n let foo = \"foo\";\n work_with_foo_by_pointer(&foo);\n ~~~~"}, {"sha": "a0621bf257f4d84a3d3f9bb48a683886b7ff8b81", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -418,7 +418,7 @@ fn check_compiling(filename: str) -> happiness {\n }\n \n \n-fn parse_and_print(code: @str) -> str {\n+fn parse_and_print(code: @str/~) -> str {\n     let filename = \"tmp.rs\";\n     let sess = parse::new_parse_sess(option::none);\n     write_file(filename, *code);\n@@ -501,7 +501,7 @@ fn file_might_not_converge(filename: str) -> bool {\n     ret false;\n }\n \n-fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n+fn check_roundtrip_convergence(code: @str/~, maxIters: uint) {\n \n     let mut i = 0u;\n     let mut newv = code;"}, {"sha": "3ba11243155e1f7290a29a4671202750db49695b", "filename": "src/libcore/task.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -1300,7 +1300,7 @@ fn test_unkillable_nested() {\n \n #[test]\n fn test_tls_multitask() unsafe {\n-    fn my_key(+_x: @str) { }\n+    fn my_key(+_x: @str/~) { }\n     local_data_set(my_key, @\"parent data\");\n     do task::spawn {\n         assert local_data_get(my_key) == none; // TLS shouldn't carry over.\n@@ -1316,15 +1316,15 @@ fn test_tls_multitask() unsafe {\n \n #[test]\n fn test_tls_overwrite() unsafe {\n-    fn my_key(+_x: @str) { }\n+    fn my_key(+_x: @str/~) { }\n     local_data_set(my_key, @\"first data\");\n     local_data_set(my_key, @\"next data\"); // Shouldn't leak.\n     assert *(local_data_get(my_key).get()) == \"next data\";\n }\n \n #[test]\n fn test_tls_pop() unsafe {\n-    fn my_key(+_x: @str) { }\n+    fn my_key(+_x: @str/~) { }\n     local_data_set(my_key, @\"weasel\");\n     assert *(local_data_pop(my_key).get()) == \"weasel\";\n     // Pop must remove the data from the map.\n@@ -1333,7 +1333,7 @@ fn test_tls_pop() unsafe {\n \n #[test]\n fn test_tls_modify() unsafe {\n-    fn my_key(+_x: @str) { }\n+    fn my_key(+_x: @str/~) { }\n     local_data_modify(my_key, |data| {\n         alt data {\n             some(@val) { fail \"unwelcome value: \" + val }\n@@ -1357,15 +1357,15 @@ fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // jump over to the rust stack, which causes next_c_sp to get recorded as\n     // something within a rust stack segment. Then a subsequent upcall (esp.\n     // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n-    fn my_key(+_x: @str) { }\n+    fn my_key(+_x: @str/~) { }\n     do task::spawn {\n         unsafe { local_data_set(my_key, @\"hax\"); }\n     }\n }\n \n #[test]\n fn test_tls_multiple_types() unsafe {\n-    fn str_key(+_x: @str) { }\n+    fn str_key(+_x: @str/~) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n     do task::spawn {\n@@ -1377,7 +1377,7 @@ fn test_tls_multiple_types() unsafe {\n \n #[test]\n fn test_tls_overwrite_multiple_types() unsafe {\n-    fn str_key(+_x: @str) { }\n+    fn str_key(+_x: @str/~) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n     do task::spawn {\n@@ -1393,7 +1393,7 @@ fn test_tls_overwrite_multiple_types() unsafe {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_tls_cleanup_on_failure() unsafe {\n-    fn str_key(+_x: @str) { }\n+    fn str_key(+_x: @str/~) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n     local_data_set(str_key, @\"parent data\");"}, {"sha": "3c56a6fd4f1c031218e8edcd545425796962aa0b", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -14,6 +14,6 @@ impl of to_bytes for str {\n     fn to_bytes() -> ~[u8] { str::bytes(self) }\n }\n \n-impl of to_bytes for @str {\n+impl of to_bytes for @(str/~) {\n     fn to_bytes() -> ~[u8] { str::bytes(*self) }\n }"}, {"sha": "0a62e77c410e066326b822d55959930d6a25dfeb", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -61,8 +61,8 @@ mod tests {\n             let box = @\"box box box\";       // refcount 1\n             bump_box_refcount(box);         // refcount 2\n             let ptr: *int = transmute(box); // refcount 2\n-            let _box1: @str = reinterpret_cast(ptr);\n-            let _box2: @str = reinterpret_cast(ptr);\n+            let _box1: @str/~ = reinterpret_cast(ptr);\n+            let _box2: @str/~ = reinterpret_cast(ptr);\n             assert *_box1 == \"box box box\";\n             assert *_box2 == \"box box box\";\n             // Will destroy _box1 and _box2. Without the bump, this would"}, {"sha": "da86b9d4df038104e9ff6f78632e73d2d464fa58", "filename": "src/libstd/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -29,7 +29,7 @@ export null;\n /// Represents a json value\n enum json {\n     num(float),\n-    string(@str),\n+    string(@str/~),\n     boolean(bool),\n     list(@~[json]),\n     dict(map::hashmap<str, json>),\n@@ -39,7 +39,7 @@ enum json {\n type error = {\n     line: uint,\n     col: uint,\n-    msg: @str,\n+    msg: @str/~,\n };\n \n /// Serializes a json value into a io::writer\n@@ -324,7 +324,7 @@ impl parser for parser {\n         ok(res)\n     }\n \n-    fn parse_str() -> result<@str, error> {\n+    fn parse_str() -> result<@str/~, error> {\n         let mut escape = false;\n         let mut res = \"\";\n \n@@ -579,7 +579,7 @@ impl of to_json for str {\n     fn to_json() -> json { string(@copy self) }\n }\n \n-impl of to_json for @str {\n+impl of to_json for @str/~ {\n     fn to_json() -> json { string(self) }\n }\n "}, {"sha": "cc88a91bcf240d7cebafe56f154aa604e295a417", "filename": "src/libstd/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -310,8 +310,8 @@ fn str_hash<V: copy>() -> hashmap<str, V> {\n }\n \n /// Construct a hashmap for boxed string keys\n-fn box_str_hash<V: copy>() -> hashmap<@str, V> {\n-    ret hashmap(|x: @str| str::hash(*x), |x,y| str::eq(*x,*y));\n+fn box_str_hash<V: copy>() -> hashmap<@str/~, V> {\n+    ret hashmap(|x: @str/~| str::hash(*x), |x,y| str::eq(*x,*y));\n }\n \n /// Construct a hashmap for byte string keys"}, {"sha": "91f63fe938c7b6d485807896cbd01064b8dad241", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -53,7 +53,7 @@ fn empty() -> rope {\n  * * this operation does not copy the string;\n  * * the function runs in linear time.\n  */\n-fn of_str(str: @str) -> rope {\n+fn of_str(str: @str/~) -> rope {\n     ret of_substr(str, 0u, str::len(*str));\n }\n \n@@ -79,7 +79,7 @@ fn of_str(str: @str) -> rope {\n  * * this function does _not_ check the validity of the substring;\n  * * this function fails if `byte_offset` or `byte_len` do not match `str`.\n  */\n-fn of_substr(str: @str, byte_offset: uint, byte_len: uint) -> rope {\n+fn of_substr(str: @str/~, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n     if byte_offset + byte_len  > str::len(*str) { fail; }\n     ret node::content(node::of_substr(str, byte_offset, byte_len));\n@@ -107,7 +107,7 @@ fn append_char(rope: rope, char: char) -> rope {\n  *\n  * * this function executes in near-linear time\n  */\n-fn append_str(rope: rope, str: @str) -> rope {\n+fn append_str(rope: rope, str: @str/~) -> rope {\n     ret append_rope(rope, of_str(str))\n }\n \n@@ -127,7 +127,7 @@ fn prepend_char(rope: rope, char: char) -> rope {\n  * # Performance note\n  * * this function executes in near-linear time\n  */\n-fn prepend_str(rope: rope, str: @str) -> rope {\n+fn prepend_str(rope: rope, str: @str/~) -> rope {\n     ret append_rope(of_str(str), rope)\n }\n \n@@ -567,7 +567,7 @@ mod node {\n         byte_offset: uint,\n         byte_len:    uint,\n         char_len:   uint,\n-        content:    @str\n+        content:    @str/~\n     };\n \n     /**\n@@ -627,7 +627,7 @@ mod node {\n      * Performance note: The complexity of this function is linear in\n      * the length of `str`.\n      */\n-    fn of_str(str: @str) -> @node {\n+    fn of_str(str: @str/~) -> @node {\n         ret of_substr(str, 0u, str::len(*str));\n     }\n \n@@ -648,7 +648,7 @@ mod node {\n      * Behavior is undefined if `byte_start` or `byte_len` do not represent\n      * valid positions in `str`\n      */\n-    fn of_substr(str: @str, byte_start: uint, byte_len: uint) -> @node {\n+    fn of_substr(str: @str/~, byte_start: uint, byte_len: uint) -> @node {\n         ret of_substr_unsafer(str, byte_start, byte_len,\n                               str::count_chars(*str, byte_start, byte_len));\n     }\n@@ -674,7 +674,7 @@ mod node {\n      * * Behavior is undefined if `char_len` does not accurately represent the\n      *   number of chars between byte_start and byte_start+byte_len\n      */\n-    fn of_substr_unsafer(str: @str, byte_start: uint, byte_len: uint,\n+    fn of_substr_unsafer(str: @str/~, byte_start: uint, byte_len: uint,\n                           char_len: uint) -> @node {\n         assert(byte_start + byte_len <= str::len(*str));\n         let candidate = @leaf({"}, {"sha": "10a29453c1e14c8e574043c97f63aa2e55b1ca4a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -32,7 +32,7 @@ fn deserialize_span<D>(_d: D) -> span {\n type spanned<T> = {node: T, span: span};\n \n #[auto_serialize]\n-type ident = @str;\n+type ident = @str/~;\n \n // Functions may or may not have names.\n #[auto_serialize]\n@@ -427,11 +427,11 @@ type lit = spanned<lit_>;\n \n #[auto_serialize]\n enum lit_ {\n-    lit_str(@str),\n+    lit_str(@str/~),\n     lit_int(i64, int_ty),\n     lit_uint(u64, uint_ty),\n     lit_int_unsuffixed(i64),\n-    lit_float(@str, float_ty),\n+    lit_float(@str/~, float_ty),\n     lit_nil,\n     lit_bool(bool),\n }"}, {"sha": "aac0b1f4d76dad6feedbbbc2fcb26d4470484f93", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -124,7 +124,7 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str> {\n+fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str/~> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n         alt v.node {\n@@ -154,7 +154,7 @@ fn get_meta_item_list(meta: @ast::meta_item) -> option<~[@ast::meta_item]> {\n  */\n fn get_name_value_str_pair(\n     item: @ast::meta_item\n-) -> option<(ast::ident, @str)> {\n+) -> option<(ast::ident, @str/~)> {\n     alt attr::get_meta_item_value_str(item) {\n       some(value) {\n         let name = attr::get_meta_item_name(item);\n@@ -239,7 +239,7 @@ fn attrs_contains_name(attrs: ~[ast::attribute], +name: str) -> bool {\n }\n \n fn first_attr_value_str_by_name(attrs: ~[ast::attribute], +name: str)\n-    -> option<@str> {\n+    -> option<@str/~> {\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n         ret get_meta_item_value_str(attr_meta(mattrs[0]));\n@@ -258,7 +258,7 @@ fn last_meta_item_by_name(\n fn last_meta_item_value_str_by_name(\n     items: ~[@ast::meta_item],\n     +name: str\n-) -> option<@str> {\n+) -> option<@str/~> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n         alt attr::get_meta_item_value_str(item) {"}, {"sha": "867d2d7e45a9b50600f274c1cc027ec04a143fb3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -45,7 +45,7 @@ enum file_substr {\n }\n \n type filemap =\n-    @{name: filename, substr: file_substr, src: @str,\n+    @{name: filename, substr: file_substr, src: @str/~,\n       start_pos: file_pos, mut lines: ~[file_pos]};\n \n type codemap = @{files: dvec<filemap>};\n@@ -55,15 +55,15 @@ type loc = {file: filemap, line: uint, col: uint};\n fn new_codemap() -> codemap { @{files: dvec()} }\n \n fn new_filemap_w_substr(+filename: filename, +substr: file_substr,\n-                        src: @str,\n+                        src: @str/~,\n                         start_pos_ch: uint, start_pos_byte: uint)\n    -> filemap {\n     ret @{name: filename, substr: substr, src: src,\n           start_pos: {ch: start_pos_ch, byte: start_pos_byte},\n           mut lines: ~[{ch: start_pos_ch, byte: start_pos_byte}]};\n }\n \n-fn new_filemap(+filename: filename, src: @str,\n+fn new_filemap(+filename: filename, src: @str/~,\n                start_pos_ch: uint, start_pos_byte: uint)\n     -> filemap {\n     ret new_filemap_w_substr(filename, fss_none, src,"}, {"sha": "e32ebf4eae5f15a11667aeb88260db9e0bfc66c9", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -218,7 +218,7 @@ impl helpers for ext_ctxt {\n                 ast::expr_alt(v, arms, ast::alt_exhaustive)))\n     }\n \n-    fn lit_str(span: span, s: @str) -> @ast::expr {\n+    fn lit_str(span: span, s: @str/~) -> @ast::expr {\n         self.expr(\n             span,\n             ast::expr_lit(\n@@ -343,8 +343,19 @@ fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n     cx.lambda(cx.blk(ty.span, ser_ty(cx, tps, ty, s, v)))\n }\n \n+fn is_vec_or_str(ty: @ast::ty) -> bool {\n+    alt ty.node {\n+      ast::ty_vec(_) { true }\n+      // This may be wrong if the user has shadowed (!) str\n+      ast::ty_path(@{span: _, global: _, idents: ids,\n+                             rp: none, types: _}, _)\n+      if ids == ~[@\"str\"] { true }\n+      _ { false }\n+    }\n+}\n+\n fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n-                ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n+          ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n     -> ~[@ast::stmt] {\n \n     let ext_cx = cx; // required for #ast{}\n@@ -365,6 +376,11 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n         ~[#ast(stmt){$(s).emit_box($(l));}]\n       }\n \n+      // For unique evecs/estrs, just pass through to underlying vec or str\n+      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) {\n+        ser_ty(cx, tps, mt.ty, s, v)\n+      }\n+\n       ast::ty_uniq(mt) {\n         let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n         ~[#ast(stmt){$(s).emit_uniq($(l));}]\n@@ -612,6 +628,11 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         #ast{ @$(d).read_box($(l)) }\n       }\n \n+      // For unique evecs/estrs, just pass through to underlying vec or str\n+      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) {\n+        deser_ty(cx, tps, mt.ty, d)\n+      }\n+\n       ast::ty_uniq(mt) {\n         let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n         #ast{ ~$(d).read_uniq($(l)) }"}, {"sha": "0d415ccfc4312624d2f7a1584bc3b54b533d552b", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -679,7 +679,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> base::macro_def {\n     let args = get_mac_args_no_max(cx, sp, arg, 0u, \"macro\");\n \n-    let mut macro_name: option<@str> = none;\n+    let mut macro_name: option<@str/~> = none;\n     let mut clauses: ~[@clause] = ~[];\n     for args.each |arg| {\n         alt arg.node {"}, {"sha": "113fdea42e4d96483dadda75ebeb2c2f8e43e020", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -24,7 +24,7 @@ type tt_frame = @{\n \n type tt_reader = @{\n     sp_diag: span_handler,\n-    interner: @interner<@str>,\n+    interner: @interner<@str/~>,\n     mut cur: tt_frame,\n     /* for MBE-style macro transcription */\n     interpolations: std::map::hashmap<ident, @arb_depth>,\n@@ -38,7 +38,7 @@ type tt_reader = @{\n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `tt_dotdotdot`s and `tt_interpolate`s, `interp` can (and\n  *  should) be none. */\n-fn new_tt_reader(sp_diag: span_handler, itr: @interner<@str>,\n+fn new_tt_reader(sp_diag: span_handler, itr: @interner<@str/~>,\n                  interp: option<std::map::hashmap<ident,@arb_depth>>,\n                  src: ~[ast::token_tree])\n     -> tt_reader {"}, {"sha": "7ccc9c5a438614c405bd324d18a2aa4176f02998", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -25,7 +25,7 @@ type parse_sess = @{\n     cm: codemap::codemap,\n     mut next_id: node_id,\n     span_diagnostic: span_handler,\n-    interner: @interner::interner<@str>,\n+    interner: @interner::interner<@str/~>,\n     // these two must be kept up to date\n     mut chpos: uint,\n     mut byte_pos: uint\n@@ -36,7 +36,7 @@ fn new_parse_sess(demitter: option<emitter>) -> parse_sess {\n     ret @{cm: cm,\n           mut next_id: 1,\n           span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n-          interner: @interner::mk::<@str>(|x| str::hash(*x),\n+          interner: @interner::mk::<@str/~>(|x| str::hash(*x),\n                                           |x,y| str::eq(*x, *y)),\n           mut chpos: 0u, mut byte_pos: 0u};\n }\n@@ -46,7 +46,7 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: codemap::codemap)\n     ret @{cm: cm,\n           mut next_id: 1,\n           span_diagnostic: sh,\n-          interner: @interner::mk::<@str>(|x| str::hash(*x),\n+          interner: @interner::mk::<@str/~>(|x| str::hash(*x),\n                                           |x,y| str::eq(*x, *y)),\n           mut chpos: 0u, mut byte_pos: 0u};\n }\n@@ -97,7 +97,7 @@ fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,\n     ret r;\n }\n \n-fn parse_crate_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n+fn parse_crate_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n                                sess: parse_sess) -> @ast::crate {\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n@@ -107,7 +107,7 @@ fn parse_crate_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n     ret r;\n }\n \n-fn parse_expr_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n+fn parse_expr_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n                               sess: parse_sess) -> @ast::expr {\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n@@ -117,7 +117,7 @@ fn parse_expr_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n     ret r;\n }\n \n-fn parse_item_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n+fn parse_item_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n                               +attrs: ~[ast::attribute],\n                               vis: ast::visibility,\n                               sess: parse_sess) -> option<@ast::item> {\n@@ -131,7 +131,7 @@ fn parse_item_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n \n fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n                             name: str, ss: codemap::file_substr,\n-                            source: @str, cfg: ast::crate_cfg,\n+                            source: @str/~, cfg: ast::crate_cfg,\n                             sess: parse_sess)\n     -> T\n {\n@@ -156,7 +156,7 @@ fn next_node_id(sess: parse_sess) -> node_id {\n \n fn new_parser_etc_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n                                   +name: str, +ss: codemap::file_substr,\n-                                  source: @str) -> (parser, string_reader) {\n+                                  source: @str/~) -> (parser, string_reader) {\n     let ftype = parser::SOURCE_FILE;\n     let filemap = codemap::new_filemap_w_substr\n         (name, ss, source, sess.chpos, sess.byte_pos);\n@@ -168,7 +168,7 @@ fn new_parser_etc_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n \n fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n                               +name: str, +ss: codemap::file_substr,\n-                              source: @str) -> parser {\n+                              source: @str/~) -> parser {\n     let (p, _) = new_parser_etc_from_source_str(sess, cfg, name, ss, source);\n     ret p;\n }"}, {"sha": "aa3e808f63e4b08f64c584decc88b4bdd5b3e1ac", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -275,7 +275,7 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n                                 srdr: io::reader) ->\n    {cmnts: ~[cmnt], lits: ~[lit]} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n-    let itr = @interner::mk::<@str>(\n+    let itr = @interner::mk::<@str/~>(\n         |x| str::hash(*x),\n         |x,y| str::eq(*x, *y)\n     );"}, {"sha": "54a2abf20c9377c63b0fa66aebe67984faa9eb1a", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -78,7 +78,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n     }\n }\n \n-fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @str {\n+fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @str/~ {\n     alt ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n       some(d) {\n         ret d;"}, {"sha": "d7f9fc12840b0cf40801be1420e33a37fd7cd175", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -14,28 +14,28 @@ iface reader {\n     fn next_token() -> {tok: token::token, sp: span};\n     fn fatal(str) -> !;\n     fn span_diag() -> span_handler;\n-    fn interner() -> @interner<@str>;\n+    fn interner() -> @interner<@str/~>;\n     fn peek() -> {tok: token::token, sp: span};\n     fn dup() -> reader;\n }\n \n type string_reader = @{\n     span_diagnostic: span_handler,\n-    src: @str,\n+    src: @str/~,\n     mut col: uint,\n     mut pos: uint,\n     mut curr: char,\n     mut chpos: uint,\n     filemap: codemap::filemap,\n-    interner: @interner<@str>,\n+    interner: @interner<@str/~>,\n     /* cached: */\n     mut peek_tok: token::token,\n     mut peek_span: span\n };\n \n fn new_string_reader(span_diagnostic: span_handler,\n                      filemap: codemap::filemap,\n-                     itr: @interner<@str>) -> string_reader {\n+                     itr: @interner<@str/~>) -> string_reader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap, itr);\n     string_advance_token(r); /* fill in peek_* */\n     ret r;\n@@ -44,7 +44,7 @@ fn new_string_reader(span_diagnostic: span_handler,\n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n fn new_low_level_string_reader(span_diagnostic: span_handler,\n                                filemap: codemap::filemap,\n-                               itr: @interner<@str>)\n+                               itr: @interner<@str/~>)\n     -> string_reader {\n     let r = @{span_diagnostic: span_diagnostic, src: filemap.src,\n               mut col: 0u, mut pos: 0u, mut curr: -1 as char,\n@@ -79,7 +79,7 @@ impl string_reader_as_reader of reader for string_reader {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n     fn span_diag() -> span_handler { self.span_diagnostic }\n-    fn interner() -> @interner<@str> { self.interner }\n+    fn interner() -> @interner<@str/~> { self.interner }\n     fn peek() -> {tok: token::token, sp: span} {\n         {tok: self.peek_tok, sp: self.peek_span}\n     }\n@@ -101,7 +101,7 @@ impl tt_reader_as_reader of reader for tt_reader {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n     fn span_diag() -> span_handler { self.sp_diag }\n-    fn interner() -> @interner<@str> { self.interner }\n+    fn interner() -> @interner<@str/~> { self.interner }\n     fn peek() -> {tok: token::token, sp: span} {\n         { tok: self.cur_tok, sp: self.cur_span }\n     }"}, {"sha": "9d8458c9c60f715b1c7b75ab7c84fce593bd55ac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -230,7 +230,7 @@ class parser {\n     fn warn(m: str) {\n         self.sess.span_diagnostic.span_warn(copy self.span, m)\n     }\n-    fn get_str(i: token::str_num) -> @str {\n+    fn get_str(i: token::str_num) -> @str/~ {\n         interner::get(*self.reader.interner(), i)\n     }\n     fn get_id() -> node_id { next_node_id(self.sess) }\n@@ -394,7 +394,7 @@ class parser {\n         }\n     }\n \n-    fn region_from_name(s: option<@str>) -> @region {\n+    fn region_from_name(s: option<@str/~>) -> @region {\n         let r = alt s {\n           some (string) { re_named(string) }\n           none { re_anon }\n@@ -461,22 +461,10 @@ class parser {\n             }\n         } else if self.token == token::AT {\n             self.bump();\n-            // HACK: turn @[...] into a @-evec\n-            alt self.parse_mt() {\n-              {ty: t @ @{node: ty_vec(_), _}, mutbl: m_imm} {\n-                ty_vstore(t, vstore_box)\n-              }\n-              mt { ty_box(mt) }\n-            }\n+            ty_box(self.parse_mt())\n         } else if self.token == token::TILDE {\n             self.bump();\n-            // HACK: turn ~[...] into a ~-evec\n-            alt self.parse_mt() {\n-              {ty: t @ @{node: ty_vec(_), _}, mutbl: m_imm} {\n-                ty_vstore(t, vstore_uniq)\n-              }\n-              mt { ty_uniq(mt) }\n-            }\n+            ty_uniq(self.parse_mt())\n         } else if self.token == token::BINOP(token::STAR) {\n             self.bump();\n             ty_ptr(self.parse_mt())\n@@ -506,13 +494,8 @@ class parser {\n         } else if self.token == token::BINOP(token::AND) {\n             self.bump();\n             let region = self.parse_region_dot();\n-            // HACK: turn &a.[...] into a &a-evec\n-            alt self.parse_mt() {\n-              {ty: t @ @{node: ty_vec(_), _}, mutbl: m_imm} {\n-                ty_vstore(t, vstore_slice(region))\n-              }\n-              mt { ty_rptr(region, mt) }\n-            }\n+            let mt = self.parse_mt();\n+            ty_rptr(region, mt)\n         } else if self.eat_keyword(\"pure\") {\n             self.parse_ty_fn(ast::pure_fn)\n         } else if self.eat_keyword(\"unsafe\") {\n@@ -2742,7 +2725,7 @@ class parser {\n                       config: self.cfg});\n     }\n \n-    fn parse_str() -> @str {\n+    fn parse_str() -> @str/~ {\n         alt copy self.token {\n           token::LIT_STR(s) { self.bump(); self.get_str(s) }\n           _ {"}, {"sha": "2c7b14cfe11b210d506de40f1c65e7f1baf0ff5f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -115,7 +115,7 @@ fn binop_to_str(o: binop) -> str {\n     }\n }\n \n-fn to_str(in: interner<@str>, t: token) -> str {\n+fn to_str(in: interner<@str/~>, t: token) -> str {\n     alt t {\n       EQ { \"=\" }\n       LT { \"<\" }"}, {"sha": "09754d27e67bbdf2e4177e3dddbb55c6a3c70776", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -59,7 +59,7 @@ type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n-enum token { STRING(@str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n+enum token { STRING(@str/~, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n fn tok_str(++t: token) -> str {\n     alt t {"}, {"sha": "10042ea85d2a1c7c3f64b3574ed873b1b7ae9bc4", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -291,14 +291,14 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n                    sha: sha1) -> link_meta {\n \n     type provided_metas =\n-        {name: option<@str>,\n-         vers: option<@str>,\n+        {name: option<@str/~>,\n+         vers: option<@str/~>,\n          cmh_items: ~[@ast::meta_item]};\n \n     fn provided_link_metas(sess: session, c: ast::crate) ->\n        provided_metas {\n-        let mut name: option<@str> = none;\n-        let mut vers: option<@str> = none;\n+        let mut name: option<@str/~> = none;\n+        let mut vers: option<@str/~> = none;\n         let mut cmh_items: ~[@ast::meta_item] = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n@@ -321,7 +321,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(sha: sha1, _crate: ast::crate,\n                               metas: provided_metas,\n-                              dep_hashes: ~[@str]) -> str {\n+                              dep_hashes: ~[@str/~]) -> str {\n         fn len_and_str(s: str) -> str {\n             ret #fmt[\"%u_%s\", str::len(s), s];\n         }\n@@ -362,7 +362,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n     }\n \n     fn crate_meta_name(sess: session, _crate: ast::crate,\n-                       output: str, metas: provided_metas) -> @str {\n+                       output: str, metas: provided_metas) -> @str/~ {\n         ret alt metas.name {\n               some(v) { v }\n               none {\n@@ -384,7 +384,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n     }\n \n     fn crate_meta_vers(sess: session, _crate: ast::crate,\n-                       metas: provided_metas) -> @str {\n+                       metas: provided_metas) -> @str/~ {\n         ret alt metas.vers {\n               some(v) { v }\n               none {\n@@ -490,7 +490,7 @@ fn mangle(ss: path) -> str {\n     n\n }\n \n-fn exported_name(path: path, hash: @str, vers: @str) -> str {\n+fn exported_name(path: path, hash: @str/~, vers: @str/~) -> str {\n     ret mangle(\n         vec::append_one(vec::append_one(path, path_name(hash)),\n                         path_name(vers)));\n@@ -502,23 +502,23 @@ fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> str {\n }\n \n fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n-                                     t: ty::t, name: @str) ->\n+                                     t: ty::t, name: @str/~) ->\n    str {\n     let s = @util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     ret mangle(~[path_name(name), path_name(s), path_name(@hash)]);\n }\n \n fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n-                                        flav: @str) -> str {\n+                                        flav: @str/~) -> str {\n     ret mangle(vec::append_one(path, path_name(@ccx.names(*flav))));\n }\n \n fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: path) -> str {\n     ret mangle(path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: @str) -> str {\n+fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: @str/~) -> str {\n     ret ccx.names(*flav);\n }\n "}, {"sha": "b6883097a5b241f930a652dff52573b95b1c4374", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -133,5 +133,5 @@ fn hash_path(&&s: str) -> uint {\n     ret h;\n }\n \n-type link_meta = {name: @str, vers: @str, extras_hash: str};\n+type link_meta = {name: @str/~, vers: @str/~, extras_hash: str};\n "}, {"sha": "13a1d3543c53f5f2bcc50a54920b9a0132d15a2d", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -38,7 +38,7 @@ fn read_crates(diag: span_handler, crate: ast::crate,\n type cache_entry = {\n     cnum: int,\n     span: span,\n-    hash: @str,\n+    hash: @str/~,\n     metas: @~[@ast::meta_item]\n };\n "}, {"sha": "f805d8d16cd063f88910e0396cb82253bbcd433d", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -37,7 +37,7 @@ type cnum_map = map::hashmap<ast::crate_num, ast::crate_num>;\n // Multiple items may have the same def_id in crate metadata. They may be\n // renamed imports or reexports. This map keeps the \"real\" module path\n // and def_id.\n-type mod_path_map = map::hashmap<ast::def_id, @str>;\n+type mod_path_map = map::hashmap<ast::def_id, @str/~>;\n \n type crate_metadata = @{name: str,\n                         data: @~[u8],\n@@ -83,12 +83,12 @@ fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {\n     ret p(cstore).metas.get(cnum);\n }\n \n-fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> @str {\n+fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> @str/~ {\n     let cdata = get_crate_data(cstore, cnum);\n     ret decoder::get_crate_hash(cdata.data);\n }\n \n-fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> @str {\n+fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> @str/~ {\n     let cdata = get_crate_data(cstore, cnum);\n     ret decoder::get_crate_vers(cdata.data);\n }\n@@ -153,8 +153,8 @@ fn find_use_stmt_cnum(cstore: cstore,\n \n // returns hashes of crates directly used by this crate. Hashes are\n // sorted by crate name.\n-fn get_dep_hashes(cstore: cstore) -> ~[@str] {\n-    type crate_hash = {name: @str, hash: @str};\n+fn get_dep_hashes(cstore: cstore) -> ~[@str/~] {\n+    type crate_hash = {name: @str/~, hash: @str/~};\n     let mut result = ~[];\n \n     for p(cstore).use_crate_map.each_value |cnum| {\n@@ -171,7 +171,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[@str] {\n     for sorted.each |x| {\n         #debug(\"  hash[%s]: %s\", *x.name, *x.hash);\n     }\n-    fn mapper(ch: crate_hash) -> @str { ret ch.hash; }\n+    fn mapper(ch: crate_hash) -> @str/~ { ret ch.hash; }\n     ret vec::map(sorted, mapper);\n }\n "}, {"sha": "9e915ff1e07631020f15b0fb297d24e7714e8c80", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -775,7 +775,7 @@ fn list_meta_items(meta_items: ebml::doc, out: io::writer) {\n     }\n }\n \n-fn list_crate_attributes(md: ebml::doc, hash: @str, out: io::writer) {\n+fn list_crate_attributes(md: ebml::doc, hash: @str/~, out: io::writer) {\n     out.write_str(#fmt(\"=Crate Attributes (%s)=\\n\", *hash));\n \n     for get_attributes(md).each |attr| {\n@@ -790,7 +790,7 @@ fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n-                  vers: @str, hash: @str};\n+                  vers: @str/~, hash: @str/~};\n \n fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n@@ -821,13 +821,13 @@ fn list_crate_deps(data: @~[u8], out: io::writer) {\n     out.write_str(\"\\n\");\n }\n \n-fn get_crate_hash(data: @~[u8]) -> @str {\n+fn get_crate_hash(data: @~[u8]) -> @str/~ {\n     let cratedoc = ebml::doc(data);\n     let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n     ret @str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n-fn get_crate_vers(data: @~[u8]) -> @str {\n+fn get_crate_vers(data: @~[u8]) -> @str/~ {\n     let attrs = decoder::get_crate_attributes(data);\n     ret alt attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), \"vers\") {"}, {"sha": "8a67de39c2baec8ec0c8783cf04c708db3f498dc", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -116,7 +116,7 @@ fn find_library_crate_aux(cx: ctxt,\n     }\n }\n \n-fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> @str {\n+fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> @str/~ {\n     let name_items = attr::find_meta_items_by_name(metas, \"name\");\n     alt vec::last_opt(name_items) {\n       some(i) {"}, {"sha": "026f06bc8b0bacaaf3d02aaf5da565cee23d5105", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -29,7 +29,7 @@ type ctxt = {\n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n-type ty_abbrev = {pos: uint, len: uint, s: @str};\n+type ty_abbrev = {pos: uint, len: uint, s: @str/~};\n \n enum abbrev_ctxt { ac_no_abbrevs, ac_use_abbrevs(hashmap<ty::t, ty_abbrev>), }\n "}, {"sha": "2e33fe8dd9abfa6dd9f336f41ff19e12b67f1d35", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -462,7 +462,10 @@ fn check_item_old_vecs(cx: ty::ctxt, it: @ast::item) {\n                     old_strs, t.id, it.id,\n                     t.span, \"deprecated str type\");\n               }\n-              ast::ty_vstore(inner, _) {\n+              ast::ty_vstore(inner, _) |\n+              ast::ty_box({ty: inner, _}) |\n+              ast::ty_uniq({ty: inner, _}) |\n+              ast::ty_rptr(_, {ty: inner, _}) {\n                 uses_vstore.insert(inner.id, true);\n               }\n               _ { }"}, {"sha": "640d2b3cb7e34159adb5b97c0fde4a580011cb15", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -202,18 +202,18 @@ fn Atom(n: uint) -> Atom {\n }\n \n class AtomTable {\n-    let atoms: hashmap<@str,Atom>;\n-    let strings: dvec<@str>;\n+    let atoms: hashmap<@str/~,Atom>;\n+    let strings: dvec<@str/~>;\n     let mut atom_count: uint;\n \n     new() {\n-        self.atoms = hashmap::<@str,Atom>(|x| str::hash(*x),\n+        self.atoms = hashmap::<@str/~,Atom>(|x| str::hash(*x),\n                                           |x, y| str::eq(*x, *y));\n         self.strings = dvec();\n         self.atom_count = 0u;\n     }\n \n-    fn intern(string: @str) -> Atom {\n+    fn intern(string: @str/~) -> Atom {\n         alt self.atoms.find(string) {\n             none { /* fall through */ }\n             some(atom) { ret atom; }\n@@ -227,19 +227,19 @@ class AtomTable {\n         ret atom;\n     }\n \n-    fn atom_to_str(atom: Atom) -> @str {\n+    fn atom_to_str(atom: Atom) -> @str/~ {\n         ret self.strings.get_elt(atom);\n     }\n \n-    fn atoms_to_strs(atoms: ~[Atom], f: fn(@str) -> bool) {\n+    fn atoms_to_strs(atoms: ~[Atom], f: fn(@str/~) -> bool) {\n         for atoms.each |atom| {\n             if !f(self.atom_to_str(atom)) {\n                 ret;\n             }\n         }\n     }\n \n-    fn atoms_to_str(atoms: ~[Atom]) -> @str {\n+    fn atoms_to_str(atoms: ~[Atom]) -> @str/~ {\n         // XXX: str::connect should do this.\n         let mut result = \"\";\n         let mut first = true;\n@@ -577,7 +577,8 @@ class PrimitiveTypeTable {\n         self.intern(atom_table, @\"u64\",     ty_uint(ty_u64));\n     }\n \n-    fn intern(atom_table: @AtomTable, string: @str, primitive_type: prim_ty) {\n+    fn intern(atom_table: @AtomTable, string: @str/~,\n+              primitive_type: prim_ty) {\n         let atom = (*atom_table).intern(string);\n         self.primitive_types.insert(atom, primitive_type);\n     }"}, {"sha": "33aecc473b3b22085ccf561990ec43166c4ca3f2", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -266,7 +266,7 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n     }\n }\n \n-fn trans_estr(bcx: block, s: @str, vstore: ast::vstore,\n+fn trans_estr(bcx: block, s: @str/~, vstore: ast::vstore,\n               dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::trans_estr\");\n     let ccx = bcx.ccx();"}, {"sha": "3bd19805e913756dba51b903706db813fa6b221e", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -253,7 +253,7 @@ type ctxt =\n       freevars: freevars::freevar_map,\n       tcache: type_cache,\n       rcache: creader_cache,\n-      short_names_cache: hashmap<t, @str>,\n+      short_names_cache: hashmap<t, @str/~>,\n       needs_drop_cache: hashmap<t, bool>,\n       needs_unwind_cleanup_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, kind>,"}, {"sha": "975d1efe4e70f6393c472fd74dd1d66e9eb26af0", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -160,12 +160,17 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ret {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n     }\n \n-    fn mk_vstore<AC: ast_conv, RS: region_scope copy>(\n-        self: AC, rscope: RS, a_seq_ty: @ast::ty, vst: ty::vstore) -> ty::t {\n+    // Handle @, ~, and & being able to mean estrs and evecs.\n+    // If a_seq_ty is a str or a vec, make it an estr/evec\n+    fn mk_maybe_vstore<AC: ast_conv, RS: region_scope copy>(\n+        self: AC, rscope: RS, a_seq_ty: ast::mt, vst: ty::vstore,\n+        constr: fn(ty::mt) -> ty::t) -> ty::t {\n \n         let tcx = self.tcx();\n \n-        alt a_seq_ty.node {\n+        alt a_seq_ty.ty.node {\n+          // to convert to an e{vec,str}, there can't be a mutability argument\n+          _ if a_seq_ty.mutbl != ast::m_imm {}\n           ast::ty_vec(mt) {\n             ret ty::mk_evec(tcx, ast_mt_to_mt(self, rscope, mt), vst);\n           }\n@@ -181,13 +186,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n           _ {}\n         }\n \n-        // Get the type, just for the error message\n-        let seq_ty = ast_ty_to_ty(self, rscope, a_seq_ty);\n-        tcx.sess.span_err(\n-            a_seq_ty.span,\n-            #fmt[\"bound not allowed on a %s\",\n-                 ty::ty_sort_str(tcx, seq_ty)]);\n-        ret seq_ty;\n+        let seq_ty = ast_mt_to_mt(self, rscope, a_seq_ty);\n+        ret constr(seq_ty);\n     }\n \n     fn check_path_args(tcx: ty::ctxt,\n@@ -227,10 +227,12 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n       ast::ty_nil { ty::mk_nil(tcx) }\n       ast::ty_bot { ty::mk_bot(tcx) }\n       ast::ty_box(mt) {\n-        ty::mk_box(tcx, ast_mt_to_mt(self, rscope, mt))\n+        mk_maybe_vstore(self, rscope, mt, ty::vstore_box,\n+                        |tmt| ty::mk_box(tcx, tmt))\n       }\n       ast::ty_uniq(mt) {\n-        ty::mk_uniq(tcx, ast_mt_to_mt(self, rscope, mt))\n+        mk_maybe_vstore(self, rscope, mt, ty::vstore_uniq,\n+                        |tmt| ty::mk_uniq(tcx, tmt))\n       }\n       ast::ty_vec(mt) {\n         ty::mk_vec(tcx, ast_mt_to_mt(self, rscope, mt))\n@@ -240,8 +242,9 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n       }\n       ast::ty_rptr(region, mt) {\n         let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n-        let mt = ast_mt_to_mt(self, in_anon_rscope(rscope, r), mt);\n-        ty::mk_rptr(tcx, r, mt)\n+        mk_maybe_vstore(self, in_anon_rscope(rscope, r), mt,\n+                        ty::vstore_slice(r),\n+                        |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(fields) {\n         let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, t));\n@@ -318,24 +321,64 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n           }\n         }\n       }\n+      // This is awful and repetitive but will go away\n       ast::ty_vstore(a_t, ast::vstore_slice(a_r)) {\n         let r = ast_region_to_region(self, rscope, ast_ty.span, a_r);\n-        mk_vstore(self, in_anon_rscope(rscope, r), a_t, ty::vstore_slice(r))\n+        mk_maybe_vstore(self, in_anon_rscope(rscope, r),\n+                        {ty: a_t, mutbl: ast::m_imm},\n+                        ty::vstore_slice(r),\n+                        |ty| {\n+                            tcx.sess.span_err(\n+                                a_t.span,\n+                                #fmt[\"bound not allowed on a %s\",\n+                                     ty::ty_sort_str(tcx, ty.ty)]);\n+                            ty.ty\n+                        })\n+\n       }\n       ast::ty_vstore(a_t, ast::vstore_uniq) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_uniq)\n+        mk_maybe_vstore(self, rscope, {ty: a_t, mutbl: ast::m_imm},\n+                        ty::vstore_uniq,\n+                        |ty| {\n+                            tcx.sess.span_err(\n+                                a_t.span,\n+                                #fmt[\"bound not allowed on a %s\",\n+                                     ty::ty_sort_str(tcx, ty.ty)]);\n+                            ty.ty\n+                        })\n       }\n       ast::ty_vstore(a_t, ast::vstore_box) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_box)\n+        mk_maybe_vstore(self, rscope, {ty: a_t, mutbl: ast::m_imm},\n+                        ty::vstore_box,\n+                        |ty| {\n+                            tcx.sess.span_err(\n+                                a_t.span,\n+                                #fmt[\"bound not allowed on a %s\",\n+                                     ty::ty_sort_str(tcx, ty.ty)]);\n+                            ty.ty\n+                        })\n       }\n       ast::ty_vstore(a_t, ast::vstore_fixed(some(u))) {\n-        mk_vstore(self, rscope, a_t, ty::vstore_fixed(u))\n+        mk_maybe_vstore(self, rscope, {ty: a_t, mutbl: ast::m_imm},\n+                        ty::vstore_fixed(u),\n+                        |ty| {\n+                            tcx.sess.span_err(\n+                                a_t.span,\n+                                #fmt[\"bound not allowed on a %s\",\n+                                     ty::ty_sort_str(tcx, ty.ty)]);\n+                            ty.ty\n+                        })\n       }\n       ast::ty_vstore(_, ast::vstore_fixed(none)) {\n         tcx.sess.span_bug(\n             ast_ty.span,\n             \"implied fixed length for bound\");\n       }\n+/*\n+      ast::ty_vstore(_, _) {\n+        tcx.sess.span_bug(ast_ty.span, \"some BS\");\n+      }\n+*/\n       ast::ty_constr(t, cs) {\n         let mut out_cs = ~[];\n         for cs.each |constr| {"}, {"sha": "049988863be9a516f16f7f2aed78e25b0eb7d8e7", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -7,7 +7,7 @@ import dvec::*;\n import dvec::dvec;\n import std::map::hashmap;\n \n-type header_map = hashmap<str, @dvec<@str>>;\n+type header_map = hashmap<str, @dvec<@str/~>>;\n \n // the unused ty param is necessary so this gets monomorphized\n fn request<T: copy>(req: header_map) {"}, {"sha": "11384408ad85a42afce279d223f9b7924f12d1c1", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -3,8 +3,8 @@\n \n class foo {\n   let i: int;\n-  let j: @str;\n-  new(i:int, j: @str) { self.i = i; self.j = j; }\n+  let j: @str/~;\n+  new(i:int, j: @str/~) { self.i = i; self.j = j; }\n }\n \n fn main() {"}, {"sha": "360d9cdeba36496cbcafffcd8e3f490acd53bba3", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let cheese = \"roquefort\";\n     let carrots = @\"crunchy\";\n \n-    fn@(tasties: @str, macerate: fn(str)) {\n+    fn@(tasties: @str/~, macerate: fn(str)) {\n         macerate(*tasties);\n     } (carrots, |food| {\n         let mush = food + cheese;"}, {"sha": "9eb7f88caee886dc265956af17a2f1904f23e3d7", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=2ea9c8df0f7c9ee72913883128b37d0a80d2f4f6", "patch": "@@ -7,11 +7,11 @@ import uint;\n \n fn main() {\n     let count = @mut 0u;\n-    fn hash(&&s: ~[@str]) -> uint {\n+    fn hash(&&s: ~[@str/~]) -> uint {\n         if (vec::len(s) > 0u && str::eq(*s[0], \"boom\")) { fail; }\n         ret 10u;\n     }\n-    fn eq(&&s: ~[@str], &&t: ~[@str]) -> bool {\n+    fn eq(&&s: ~[@str/~], &&t: ~[@str/~]) -> bool {\n         ret s == t;\n     }\n "}]}