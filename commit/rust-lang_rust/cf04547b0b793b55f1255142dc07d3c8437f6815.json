{"sha": "cf04547b0b793b55f1255142dc07d3c8437f6815", "node_id": "C_kwDOAAsO6NoAKGNmMDQ1NDdiMGI3OTNiNTVmMTI1NTE0MmRjMDdkM2M4NDM3ZjY4MTU", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-08-30T19:44:00Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-09-13T21:50:12Z"}, "message": "Address code review comments", "tree": {"sha": "0bc6fd4804dd5c7b05f51c19d063e19c718584b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bc6fd4804dd5c7b05f51c19d063e19c718584b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf04547b0b793b55f1255142dc07d3c8437f6815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf04547b0b793b55f1255142dc07d3c8437f6815", "html_url": "https://github.com/rust-lang/rust/commit/cf04547b0b793b55f1255142dc07d3c8437f6815", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf04547b0b793b55f1255142dc07d3c8437f6815/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de42ac39709f2307f20530c587bc2bdd110524fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/de42ac39709f2307f20530c587bc2bdd110524fc", "html_url": "https://github.com/rust-lang/rust/commit/de42ac39709f2307f20530c587bc2bdd110524fc"}], "stats": {"total": 460, "additions": 199, "deletions": 261}, "files": [{"sha": "6a0a1b08360133296069b79a284e80cfd2873707", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -19,7 +19,6 @@ use rustc_session::lint::builtin::{\n     DEPRECATED_WHERE_CLAUSE_LOCATION, MISSING_ABI, PATTERNS_IN_FNS_WITHOUT_BODY,\n };\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n-use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -754,19 +753,7 @@ impl<'a> AstValidator<'a> {\n                     self.maybe_lint_missing_abi(sig_span, ty.id);\n                 }\n             }\n-            TyKind::TraitObject(ref bounds, syntax, ..) => {\n-                if syntax == TraitObjectSyntax::DynStar\n-                    && !self.session.features_untracked().dyn_star\n-                {\n-                    feature_err(\n-                        &self.session.parse_sess,\n-                        sym::dyn_star,\n-                        ty.span,\n-                        \"dyn* trait objects are unstable\",\n-                    )\n-                    .emit();\n-                }\n-\n+            TyKind::TraitObject(ref bounds, ..) => {\n                 let mut any_lifetime_bounds = false;\n                 for bound in bounds {\n                     if let GenericBound::Outlives(ref lifetime) = *bound {"}, {"sha": "8a2b265c400dae5255328d38670fdfcbd609d77d", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -573,6 +573,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span, \"the `!` type is experimental\");\n             }\n+            ast::TyKind::TraitObject(_, ast::TraitObjectSyntax::DynStar, ..) => {\n+                gate_feature_post!(&self, dyn_star, ty.span, \"dyn* trait objects are unstable\");\n+            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty)"}, {"sha": "cfaadca9491079bca03a5390a70cca0c8d604083", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -816,6 +816,7 @@ pub(crate) fn assert_assignable<'tcx>(\n             // fn(&T) -> for<'l> fn(&'l T) is allowed\n         }\n         (&ty::Dynamic(from_traits, _, _from_kind), &ty::Dynamic(to_traits, _, _to_kind)) => {\n+            // FIXME(dyn-star): Do the right thing with DynKinds\n             for (from, to) in from_traits.iter().zip(to_traits) {\n                 let from =\n                     fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);"}, {"sha": "a6b226ef72096db9ff11c86fa863fdcc4a09d4c8", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx.ret(llval);\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self, helper, bx))]\n+    #[tracing::instrument(level = \"trace\", skip(self, helper, bx))]\n     fn codegen_drop_terminator(\n         &mut self,\n         helper: TerminatorCodegenHelper<'tcx>,"}, {"sha": "cbe98548025bca306bdd0e82a1a0d60986d3235c", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -113,11 +113,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if let ty::Dynamic(data, _, ty::DynStar) = cast_ty.kind() {\n                     // Initial cast from sized to dyn trait\n                     let vtable = self.get_vtable_ptr(src.layout.ty, data.principal())?;\n-                    let ptr = self.read_immediate(src)?.to_scalar();\n-                    // FIXME(dyn-star): This should not use new_dyn_trait, but\n-                    // it does exactly the same thing (makes a scalar pair)...\n-                    // so maybe we should just duplicate/rename the function.\n-                    let val = Immediate::new_dyn_trait(ptr, vtable, &*self.tcx);\n+                    let vtable = Scalar::from_maybe_pointer(vtable, self);\n+                    let data = self.read_immediate(src)?.to_scalar();\n+                    let _assert_pointer_sized = data.to_pointer(self)?;\n+                    let val = Immediate::ScalarPair(data, vtable);\n                     self.write_immediate(val, dest)?;\n                 } else {\n                     bug!()\n@@ -327,7 +326,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let new_vptr = self.get_vtable_ptr(ty, data_b.principal())?;\n                 self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n             }\n-            (_, &ty::Dynamic(ref data, _, _repr)) => {\n+            (_, &ty::Dynamic(ref data, _, ty::Dyn)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_scalar(src)?;"}, {"sha": "4aa98cb13d82bff5594b09f73a4451901ede31c1", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -570,7 +570,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                         }\n                     }\n                     CastKind::DynStar => {\n-                        // FIXME: make sure nothing needs to be done here.\n+                        // FIXME(dyn-star): make sure nothing needs to be done here.\n                     }\n                     // Nothing to check here\n                     CastKind::PointerFromExposedAddress"}, {"sha": "d5ec5feffa732a5f21870432795151a3bbc36062", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -381,7 +381,7 @@ declare_features! (\n     /// Allows `#[doc(masked)]`.\n     (active, doc_masked, \"1.21.0\", Some(44027), None),\n     /// Allows `dyn* Trait` objects.\n-    (active, dyn_star, \"1.65.0\", Some(91611), None),\n+    (incomplete, dyn_star, \"CURRENT_RUSTC_VERSION\", Some(91611), None),\n     /// Allows `X..Y` patterns.\n     (active, exclusive_range_pattern, \"1.11.0\", Some(37854), None),\n     /// Allows exhaustive pattern matching on types that contain uninhabited types."}, {"sha": "042eeec3f4622eefcf41b8d547cb1e46ae715590", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -626,11 +626,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             ty::Dynamic(_, _, ty::DynStar) => {\n-                let mut pointer = scalar_unit(Int(dl.ptr_sized_integer(), false));\n-                pointer.valid_range_mut().start = 1;\n+                let mut data = scalar_unit(Int(dl.ptr_sized_integer(), false));\n+                data.valid_range_mut().start = 0;\n                 let mut vtable = scalar_unit(Pointer);\n                 vtable.valid_range_mut().start = 1;\n-                tcx.intern_layout(self.scalar_pair(pointer, vtable))\n+                tcx.intern_layout(self.scalar_pair(data, vtable))\n             }\n \n             // Arrays and slices.\n@@ -2474,8 +2474,7 @@ where\n \n                     match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n                         ty::Slice(_) | ty::Str => TyMaybeWithLayout::Ty(tcx.types.usize),\n-                        // FIXME(eholk): Do the right thing with trait object representation\n-                        ty::Dynamic(_, _, _repr) => {\n+                        ty::Dynamic(_, _, ty::Dyn) => {\n                             TyMaybeWithLayout::Ty(tcx.mk_imm_ref(\n                                 tcx.lifetimes.re_static,\n                                 tcx.mk_array(tcx.types.usize, 3),\n@@ -3379,7 +3378,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         Ok(self.tcx.arena.alloc(fn_abi))\n     }\n \n-    #[tracing::instrument(level = \"debug\", skip(self))]\n+    #[tracing::instrument(level = \"trace\", skip(self))]\n     fn fn_abi_adjust_for_abi(\n         &self,\n         fn_abi: &mut FnAbi<'tcx, Ty<'tcx>>,"}, {"sha": "2a843ab0b8b4b6e3be14773b56bddb79c35be373", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -699,7 +699,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 // This could also be a different Unsize instruction, like\n                 // from a fixed sized array to a slice. But we are only\n                 // interested in things that produce a vtable.\n-                if (target_ty.is_trait() || target_ty.is_dyn_star()) && !source_ty.is_trait() {\n+                if (target_ty.is_trait() && !source_ty.is_trait())\n+                    || (target_ty.is_dyn_star() && !source_ty.is_dyn_star())\n+                {\n                     create_mono_items_for_vtable_methods(\n                         self.tcx,\n                         target_ty,"}, {"sha": "b47f0c0978381dcfd928e1296ce945cecfeade73", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -579,9 +579,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `dyn`\n \n         // parse dyn* types\n-        let dyn_star = matches!(self.token.kind, TokenKind::BinOp(token::Star));\n-        let syntax = if dyn_star {\n-            self.bump(); // `*`\n+        let syntax = if self.eat(&TokenKind::BinOp(token::Star)) {\n             TraitObjectSyntax::DynStar\n         } else {\n             TraitObjectSyntax::Dyn"}, {"sha": "aa65a72ab646a737301b943bb7fd7efccfba2e54", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -627,10 +627,13 @@ fn encode_ty<'tcx>(\n         }\n \n         // Trait types\n-        ty::Dynamic(predicates, region, _repr) => {\n+        ty::Dynamic(predicates, region, kind) => {\n             // u3dynI<element-type1[..element-typeN]>E, where <element-type> is <predicate>, as\n             // vendor extended type.\n-            let mut s = String::from(\"u3dynI\");\n+            let mut s = String::from(match kind {\n+                ty::Dyn => \"u3dynI\",\n+                ty::DynStar => \"u7dynstarI\",\n+            });\n             s.push_str(&encode_predicates(tcx, predicates, dict, options));\n             s.push_str(&encode_region(tcx, *region, dict, options));\n             s.push('E');"}, {"sha": "79d0ef69ba733576b9acb4dcb16591fce64d4409", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -479,8 +479,12 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                 })?;\n             }\n \n-            ty::Dynamic(predicates, r, _repr) => {\n-                self.push(\"D\");\n+            ty::Dynamic(predicates, r, kind) => {\n+                self.push(match kind {\n+                    ty::Dyn => \"D\",\n+                    // FIXME(dyn-star): need to update v0 mangling docs\n+                    ty::DynStar => \"D*\",\n+                });\n                 self = self.print_dyn_existential(predicates)?;\n                 self = r.print(self)?;\n             }"}, {"sha": "bd73ec471606055f6ac9ab236e3d17c19e2c6726", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -1067,7 +1067,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         object_ty: Ty<'tcx>,\n     ) {\n-        let ty::Dynamic(predicates, _, _) = object_ty.kind() else { return; };\n+        let ty::Dynamic(predicates, _, ty::Dyn) = object_ty.kind() else { return; };\n         let self_ref_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, self_ty);\n \n         for predicate in predicates.iter() {\n@@ -1365,7 +1365,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let trait_pred = self.resolve_vars_if_possible(trait_pred);\n         let ty = trait_pred.skip_binder().self_ty();\n         let is_object_safe = match ty.kind() {\n-            ty::Dynamic(predicates, _, _) => {\n+            ty::Dynamic(predicates, _, ty::Dyn) => {\n                 // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n                 predicates\n                     .principal_def_id()"}, {"sha": "43c4ddd3f6faf71aa090c37ebbf66a9c4a312baf", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -890,9 +890,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let mut nested = vec![];\n         match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (auto traits and lifetime subtyping).\n-            (&ty::Dynamic(ref data_a, r_a, repr_a), &ty::Dynamic(ref data_b, r_b, repr_b))\n-                if repr_a == repr_b =>\n-            {\n+            (&ty::Dynamic(ref data_a, r_a, ty::Dyn), &ty::Dynamic(ref data_b, r_b, ty::Dyn)) => {\n                 // See `assemble_candidates_for_unsizing` for more info.\n                 // We already checked the compatibility of auto traits within `assemble_candidates_for_unsizing`.\n                 let iter = data_a\n@@ -911,7 +909,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             .map(ty::Binder::dummy),\n                     );\n                 let existential_predicates = tcx.mk_poly_existential_predicates(iter);\n-                let source_trait = tcx.mk_dynamic(existential_predicates, r_b, repr_b);\n+                let source_trait = tcx.mk_dynamic(existential_predicates, r_b, ty::Dyn);\n \n                 // Require that the traits involved in this upcast are **equal**;\n                 // only the **lifetime bound** is changed.\n@@ -938,7 +936,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // `T` -> `Trait`\n-            (_, &ty::Dynamic(ref data, r, _repr)) => {\n+            (_, &ty::Dynamic(ref data, r, ty::Dyn)) => {\n                 let mut object_dids = data.auto_traits().chain(data.principal_def_id());\n                 if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n                     return Err(TraitNotObjectSafe(did));"}, {"sha": "45d5ea93d547fd5f4139afaa2dad8541f5475071", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -326,7 +326,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                     )),\n                 })\n             }\n-            ty::Dynamic(predicates, region, _repr) => chalk_ir::TyKind::Dyn(chalk_ir::DynTy {\n+            // FIXME(dyn-star): handle the dynamic kind (dyn or dyn*)\n+            ty::Dynamic(predicates, region, _kind) => chalk_ir::TyKind::Dyn(chalk_ir::DynTy {\n                 bounds: predicates.lower_into(interner),\n                 lifetime: region.lower_into(interner),\n             }),"}, {"sha": "6d54924e515fca03c725680bf81b3aecda1a0682", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -19,26 +19,33 @@ use rustc_data_structures::stable_hasher::HashStable;\n use rustc_serialize::{Decodable, Decoder, Encodable};\n \n /// Specifies how a trait object is represented.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n+#[derive(\n+    Clone,\n+    Copy,\n+    PartialEq,\n+    Eq,\n+    PartialOrd,\n+    Ord,\n+    Hash,\n+    Debug,\n+    Encodable,\n+    Decodable,\n+    HashStable_Generic\n+)]\n pub enum DynKind {\n     /// An unsized `dyn Trait` object\n     Dyn,\n     /// A sized `dyn* Trait` object\n+    ///\n+    /// These objects are represented as a `(data, vtable)` pair where `data` is a ptr-sized value\n+    /// (often a pointer to the real object, but not necessarily) and `vtable` is a pointer to\n+    /// the vtable for `dyn* Trait`. The representation is essentially the same as `&dyn Trait`\n+    /// or similar, but the drop function included in the vtable is responsible for freeing the\n+    /// underlying storage if needed. This allows a `dyn*` object to be treated agnostically with\n+    /// respect to whether it points to a `Box<T>`, `Rc<T>`, etc.\n     DynStar,\n }\n \n-// Manually implemented because deriving HashStable requires rustc_query_system, which would\n-// create a cyclic dependency.\n-impl<CTX> HashStable<CTX> for DynKind {\n-    fn hash_stable(\n-        &self,\n-        hcx: &mut CTX,\n-        hasher: &mut rustc_data_structures::stable_hasher::StableHasher,\n-    ) {\n-        std::mem::discriminant(self).hash_stable(hcx, hasher);\n-    }\n-}\n-\n /// Defines the kinds of types used by the type system.\n ///\n /// Types written by the user start out as `hir::TyKind` and get"}, {"sha": "81a979865acc3bef7e38809da9397e043c55c4a9", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         Ok(match *t.kind() {\n             ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n-            ty::Dynamic(ref tty, ..) => Some(PointerKind::VTable(tty.principal_def_id())),\n+            ty::Dynamic(ref tty, _, ty::Dyn) => Some(PointerKind::VTable(tty.principal_def_id())),\n             ty::Adt(def, substs) if def.is_struct() => match def.non_enum_variant().fields.last() {\n                 None => Some(PointerKind::Thin),\n                 Some(f) => {\n@@ -142,6 +142,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             | ty::Generator(..)\n             | ty::Adt(..)\n             | ty::Never\n+            | ty::Dynamic(_, _, ty::DynStar)\n             | ty::Error(_) => {\n                 let reported = self\n                     .tcx\n@@ -246,7 +247,7 @@ fn check_dyn_star_cast<'tcx>(\n     let cause = ObligationCause::new(\n         expr.span,\n         fcx.body_id,\n-        // FIXME: Use a better obligation cause code\n+        // FIXME(dyn-star): Use a better obligation cause code\n         ObligationCauseCode::MiscObligation,\n     );\n \n@@ -927,10 +928,10 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n \n-            // FIXME: this needs more conditions...\n+            // FIXME(dyn-star): this needs more conditions...\n             (_, DynStar) => Ok(CastKind::DynStarCast),\n \n-            // FIXME: do we want to allow dyn* upcasting or other casts?\n+            // FIXME(dyn-star): do we want to allow dyn* upcasting or other casts?\n             (DynStar, _) => Err(CastError::IllegalCast),\n         }\n     }"}, {"sha": "e49caf649f892c53d0606134218d4f654387218b", "filename": "src/test/ui/dyn-star/const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fconst.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n #![feature(dyn_star)]\n-#![allow(unused)]\n+#![allow(unused, incomplete_features)]\n \n use std::fmt::Debug;\n "}, {"sha": "46b232f3dd39996108697efe8476522100d7e379", "filename": "src/test/ui/dyn-star/drop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdrop.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n // check-run-results\n #![feature(dyn_star)]\n+#![allow(incomplete_features)]\n \n use std::fmt::Debug;\n "}, {"sha": "33eff80a5fe70276a472ad42a4345ea00075a002", "filename": "src/test/ui/dyn-star/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Ferror.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -1,4 +1,5 @@\n #![feature(dyn_star)]\n+#![allow(incomplete_features)]\n \n use std::fmt::Debug;\n "}, {"sha": "d612ccc630ea8a0bb01b97b8370a585cf96043c3", "filename": "src/test/ui/dyn-star/error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Ferror.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Ferror.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Ferror.stderr?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `{integer}: Foo` is not satisfied\n-  --> $DIR/error.rs:9:27\n+  --> $DIR/error.rs:10:27\n    |\n LL |     let dyn_i: dyn* Foo = i as dyn* Foo;\n    |                           ^ the trait `Foo` is not implemented for `{integer}`"}, {"sha": "708ffa25d6feef70fb2e39d934a88648a39a7c25", "filename": "src/test/ui/dyn-star/make-dyn-star.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fmake-dyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fmake-dyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fmake-dyn-star.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n #![feature(dyn_star)]\n+#![allow(incomplete_features)]\n \n use std::fmt::Debug;\n "}, {"sha": "d04958ca2aac9d56fedf02a96c7e9d8205be25c1", "filename": "src/test/ui/dyn-star/method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fmethod.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n #![feature(dyn_star)]\n+#![allow(incomplete_features)]\n \n trait Foo {\n     fn get(&self) -> usize;"}, {"sha": "618c72562b2a7f18179d8cb972fe7de454e2fd47", "filename": "src/test/ui/dyn-star/syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftest%2Fui%2Fdyn-star%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fsyntax.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -3,6 +3,7 @@\n // check-pass\n \n #![feature(dyn_star)]\n+#![allow(incomplete_features)]\n \n pub fn dyn_star_parameter(_: dyn* Send) {\n }"}, {"sha": "8bdadf2440231d6c6604a9995a873eb44fb2fcd1", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -2,18 +2,11 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;\n-use rustc_typeck::check::{\n-    cast::{self, CastCheckResult},\n-    FnCtxt, Inherited,\n-};\n+use rustc_typeck::check::{cast::{self, CastCheckResult}, FnCtxt, Inherited};\n \n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment\n-pub(super) fn is_layout_incompatible<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    from: Ty<'tcx>,\n-    to: Ty<'tcx>,\n-) -> bool {\n+pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n     if let Ok(from) = cx.tcx.try_normalize_erasing_regions(cx.param_env, from)\n         && let Ok(to) = cx.tcx.try_normalize_erasing_regions(cx.param_env, to)\n         && let Ok(from_layout) = cx.tcx.layout_of(cx.param_env.and(from))\n@@ -36,9 +29,7 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) -> bool {\n-    use CastKind::{\n-        AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast,\n-    };\n+    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n     matches!(\n         check_cast(cx, e, from_ty, to_ty),\n         Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n@@ -49,20 +40,18 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n /// the cast. In certain cases, including some invalid casts from array references\n /// to pointers, this may cause additional errors to be emitted and/or ICE error\n /// messages. This function will panic if that occurs.\n-fn check_cast<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    e: &'tcx Expr<'_>,\n-    from_ty: Ty<'tcx>,\n-    to_ty: Ty<'tcx>,\n-) -> Option<CastKind> {\n+fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n     let hir_id = e.hir_id;\n     let local_def_id = hir_id.owner;\n \n     Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n         let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n \n         // If we already have errors, we can't be sure we can pointer cast.\n-        assert!(!fn_ctxt.errors_reported_since_creation(), \"Newly created FnCtxt contained errors\");\n+        assert!(\n+            !fn_ctxt.errors_reported_since_creation(),\n+            \"Newly created FnCtxt contained errors\"\n+        );\n \n         if let CastCheckResult::Deferred(check) = cast::check_cast(\n             &fn_ctxt, e, from_ty, to_ty,"}, {"sha": "8835b9329095818d14b610eb0bbdb68f57010995", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 54, "deletions": 82, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -18,11 +18,7 @@ use std::borrow::Cow;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n-pub fn is_min_const_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a Body<'tcx>,\n-    msrv: Option<RustcVersion>,\n-) -> McfResult {\n+pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<RustcVersion>) -> McfResult {\n     let def_id = body.source.def_id();\n     let mut current = def_id;\n     loop {\n@@ -37,18 +33,10 @@ pub fn is_min_const_fn<'a, 'tcx>(\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n-                ty::PredicateKind::ObjectSafe(_) => {\n-                    panic!(\"object safe predicate on function: {:#?}\", predicate)\n-                }\n-                ty::PredicateKind::ClosureKind(..) => {\n-                    panic!(\"closure kind predicate on function: {:#?}\", predicate)\n-                }\n-                ty::PredicateKind::Subtype(_) => {\n-                    panic!(\"subtype predicate on function: {:#?}\", predicate)\n-                }\n-                ty::PredicateKind::Coerce(_) => {\n-                    panic!(\"coerce predicate on function: {:#?}\", predicate)\n-                }\n+                ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::Coerce(_) => panic!(\"coerce predicate on function: {:#?}\", predicate),\n             }\n         }\n         match predicates.parent {\n@@ -89,23 +77,22 @@ fn check_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n         match ty.kind() {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n                 return Err((span, \"mutable references in const fn are unstable\".into()));\n-            }\n+            },\n             ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n                 return Err((span, \"function pointers in const fn are unstable\".into()));\n-            }\n+            },\n             ty::Dynamic(preds, _, _) => {\n                 for pred in preds.iter() {\n                     match pred.skip_binder() {\n-                        ty::ExistentialPredicate::AutoTrait(_)\n-                        | ty::ExistentialPredicate::Projection(_) => {\n+                        ty::ExistentialPredicate::AutoTrait(_) | ty::ExistentialPredicate::Projection(_) => {\n                             return Err((\n                                 span,\n                                 \"trait bounds other than `Sized` \\\n                                  on const fn parameters are unstable\"\n                                     .into(),\n                             ));\n-                        }\n+                        },\n                         ty::ExistentialPredicate::Trait(trait_ref) => {\n                             if Some(trait_ref.def_id) != tcx.lang_items().sized_trait() {\n                                 return Err((\n@@ -115,11 +102,11 @@ fn check_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n                                         .into(),\n                                 ));\n                             }\n-                        }\n+                        },\n                     }\n                 }\n-            }\n-            _ => {}\n+            },\n+            _ => {},\n         }\n     }\n     Ok(())\n@@ -133,13 +120,10 @@ fn check_rvalue<'tcx>(\n     span: Span,\n ) -> McfResult {\n     match rvalue {\n-        Rvalue::ThreadLocalRef(_) => {\n-            Err((span, \"cannot access thread local storage in const fn\".into()))\n-        }\n-        Rvalue::Len(place)\n-        | Rvalue::Discriminant(place)\n-        | Rvalue::Ref(_, _, place)\n-        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span, body),\n+        Rvalue::ThreadLocalRef(_) => Err((span, \"cannot access thread local storage in const fn\".into())),\n+        Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+            check_place(tcx, *place, span, body)\n+        },\n         Rvalue::CopyForDeref(place) => check_place(tcx, *place, span, body),\n         Rvalue::Repeat(operand, _)\n         | Rvalue::Use(operand)\n@@ -152,9 +136,7 @@ fn check_rvalue<'tcx>(\n         ) => check_operand(tcx, operand, span, body),\n         Rvalue::Cast(\n             CastKind::Pointer(\n-                PointerCast::UnsafeFnPointer\n-                | PointerCast::ClosureFnPointer(_)\n-                | PointerCast::ReifyFnPointer,\n+                PointerCast::UnsafeFnPointer | PointerCast::ClosureFnPointer(_) | PointerCast::ReifyFnPointer,\n             ),\n             _,\n             _,\n@@ -164,10 +146,7 @@ fn check_rvalue<'tcx>(\n                 deref_ty.ty\n             } else {\n                 // We cannot allow this for now.\n-                return Err((\n-                    span,\n-                    \"unsizing casts are only allowed for references right now\".into(),\n-                ));\n+                return Err((span, \"unsizing casts are only allowed for references right now\".into()));\n             };\n             let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n             if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n@@ -178,14 +157,14 @@ fn check_rvalue<'tcx>(\n                 // We just can't allow trait objects until we have figured out trait method calls.\n                 Err((span, \"unsizing casts are not allowed in const fn\".into()))\n             }\n-        }\n+        },\n         Rvalue::Cast(CastKind::PointerExposeAddress, _, _) => {\n             Err((span, \"casting pointers to ints is unstable in const fn\".into()))\n-        }\n+        },\n         Rvalue::Cast(CastKind::DynStar, _, _) => {\n             // FIXME(dyn-star)\n             unimplemented!()\n-        }\n+        },\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, box (lhs, rhs)) | Rvalue::CheckedBinaryOp(_, box (lhs, rhs)) => {\n             check_operand(tcx, lhs, span, body)?;\n@@ -194,26 +173,27 @@ fn check_rvalue<'tcx>(\n             if ty.is_integral() || ty.is_bool() || ty.is_char() {\n                 Ok(())\n             } else {\n-                Err((span, \"only int, `bool` and `char` operations are stable in const fn\".into()))\n+                Err((\n+                    span,\n+                    \"only int, `bool` and `char` operations are stable in const fn\".into(),\n+                ))\n             }\n-        }\n-        Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) | Rvalue::ShallowInitBox(_, _) => {\n-            Ok(())\n-        }\n+        },\n+        Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) | Rvalue::ShallowInitBox(_, _) => Ok(()),\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {\n                 check_operand(tcx, operand, span, body)\n             } else {\n                 Err((span, \"only int and `bool` operations are stable in const fn\".into()))\n             }\n-        }\n+        },\n         Rvalue::Aggregate(_, operands) => {\n             for operand in operands {\n                 check_operand(tcx, operand, span, body)?;\n             }\n             Ok(())\n-        }\n+        },\n     }\n }\n \n@@ -228,7 +208,7 @@ fn check_statement<'tcx>(\n         StatementKind::Assign(box (place, rval)) => {\n             check_place(tcx, *place, span, body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n-        }\n+        },\n \n         StatementKind::FakeRead(box (_, place)) => check_place(tcx, *place, span, body),\n         // just an assignment\n@@ -238,15 +218,13 @@ fn check_statement<'tcx>(\n \n         StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(op)) => check_operand(tcx, op, span, body),\n \n-        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n-            dst,\n-            src,\n-            count,\n-        }) => {\n+        StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(\n+            rustc_middle::mir::CopyNonOverlapping { dst, src, count },\n+        )) => {\n             check_operand(tcx, dst, span, body)?;\n             check_operand(tcx, src, span, body)?;\n             check_operand(tcx, count, span, body)\n-        }\n+        },\n         // These are all NOPs\n         StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)\n@@ -257,12 +235,7 @@ fn check_statement<'tcx>(\n     }\n }\n \n-fn check_operand<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    operand: &Operand<'tcx>,\n-    span: Span,\n-    body: &Body<'tcx>,\n-) -> McfResult {\n+fn check_operand<'tcx>(tcx: TyCtxt<'tcx>, operand: &Operand<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n     match operand {\n         Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, body),\n         Operand::Constant(c) => match c.check_static_ptr(tcx) {\n@@ -272,12 +245,7 @@ fn check_operand<'tcx>(\n     }\n }\n \n-fn check_place<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    place: Place<'tcx>,\n-    span: Span,\n-    body: &Body<'tcx>,\n-) -> McfResult {\n+fn check_place<'tcx>(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n     let mut cursor = place.projection.as_ref();\n     while let [ref proj_base @ .., elem] = *cursor {\n         cursor = proj_base;\n@@ -290,12 +258,12 @@ fn check_place<'tcx>(\n                         return Err((span, \"accessing union fields is unstable\".into()));\n                     }\n                 }\n-            }\n+            },\n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Downcast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Deref\n-            | ProjectionElem::Index(_) => {}\n+            | ProjectionElem::Index(_) => {},\n         }\n     }\n \n@@ -321,16 +289,18 @@ fn check_terminator<'a, 'tcx>(\n         TerminatorKind::DropAndReplace { place, value, .. } => {\n             check_place(tcx, *place, span, body)?;\n             check_operand(tcx, value, span, body)\n-        }\n+        },\n \n-        TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n-            check_operand(tcx, discr, span, body)\n-        }\n+        TerminatorKind::SwitchInt {\n+            discr,\n+            switch_ty: _,\n+            targets: _,\n+        } => check_operand(tcx, discr, span, body),\n \n         TerminatorKind::Abort => Err((span, \"abort is not stable in const fn\".into())),\n         TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => {\n             Err((span, \"const fn generators are unstable\".into()))\n-        }\n+        },\n \n         TerminatorKind::Call {\n             func,\n@@ -375,15 +345,17 @@ fn check_terminator<'a, 'tcx>(\n             } else {\n                 Err((span, \"can only call other const fns within const fn\".into()))\n             }\n-        }\n+        },\n \n-        TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n-            check_operand(tcx, cond, span, body)\n-        }\n+        TerminatorKind::Assert {\n+            cond,\n+            expected: _,\n+            msg: _,\n+            target: _,\n+            cleanup: _,\n+        } => check_operand(tcx, cond, span, body),\n \n-        TerminatorKind::InlineAsm { .. } => {\n-            Err((span, \"cannot use inline assembly in const fn\".into()))\n-        }\n+        TerminatorKind::InlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n     }\n }\n "}, {"sha": "a8ad6cf4f6a3c9e3b7134ade39d808fd907d072d", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 65, "deletions": 96, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf04547b0b793b55f1255142dc07d3c8437f6815/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=cf04547b0b793b55f1255142dc07d3c8437f6815", "patch": "@@ -14,9 +14,8 @@ use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind,\n-    ProjectionTy, Region, RegionKind, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n-    UintTy, VariantDef, VariantDiscr,\n+    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy,\n+    Region, RegionKind, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -167,7 +166,9 @@ pub fn implements_trait_with_env<'tcx>(\n     }\n     let ty_params = tcx.mk_substs(ty_params.iter());\n     tcx.infer_ctxt().enter(|infcx| {\n-        infcx.type_implements_trait(trait_id, ty, ty_params, param_env).must_apply_modulo_regions()\n+        infcx\n+            .type_implements_trait(trait_id, ty, ty_params, param_env)\n+            .must_apply_modulo_regions()\n     })\n }\n \n@@ -184,14 +185,11 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.has_attr(adt.did(), sym::must_use),\n         ty::Foreign(did) => cx.tcx.has_attr(*did, sym::must_use),\n-        ty::Slice(ty)\n-        | ty::Array(ty, _)\n-        | ty::RawPtr(ty::TypeAndMut { ty, .. })\n-        | ty::Ref(_, ty, _) => {\n+        ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n-        }\n+        },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n@@ -202,7 +200,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n                 }\n             }\n             false\n-        }\n+        },\n         ty::Dynamic(binder, _, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n@@ -212,7 +210,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n                 }\n             }\n             false\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -222,11 +220,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // not succeed\n /// Checks if `Ty` is normalizable. This function is useful\n /// to avoid crashes on `layout_of`.\n-pub fn is_normalizable<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> bool {\n+pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n     is_normalizable_helper(cx, param_env, ty, &mut FxHashMap::default())\n }\n \n@@ -246,14 +240,15 @@ fn is_normalizable_helper<'tcx>(\n         if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n             match ty.kind() {\n                 ty::Adt(def, substs) => def.variants().iter().all(|variant| {\n-                    variant.fields.iter().all(|field| {\n-                        is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache)\n-                    })\n+                    variant\n+                        .fields\n+                        .iter()\n+                        .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n                 }),\n                 _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n                     GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n                         is_normalizable_helper(cx, param_env, inner_ty, cache)\n-                    }\n+                    },\n                     _ => true, // if inner_ty == ty, we've already checked it\n                 }),\n             }\n@@ -278,9 +273,7 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     match *ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => {\n-            is_recursively_primitive_type(inner_type)\n-        }\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n         ty::Tuple(inner_types) => inner_types.iter().all(is_recursively_primitive_type),\n         _ => false,\n     }\n@@ -320,9 +313,11 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n /// Returns `false` if the `LangItem` is not defined.\n pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => {\n-            cx.tcx.lang_items().require(lang_item).map_or(false, |li| li == adt.did())\n-        }\n+        ty::Adt(adt, _) => cx\n+            .tcx\n+            .lang_items()\n+            .require(lang_item)\n+            .map_or(false, |li| li == adt.did()),\n         _ => false,\n     }\n }\n@@ -347,11 +342,7 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n /// deallocate memory. For these types, and composites containing them, changing the drop order\n /// won't result in any observable side effects.\n pub fn needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    fn needs_ordered_drop_inner<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        ty: Ty<'tcx>,\n-        seen: &mut FxHashSet<Ty<'tcx>>,\n-    ) -> bool {\n+    fn needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n         if !seen.insert(ty) {\n             return false;\n         }\n@@ -402,7 +393,11 @@ pub fn needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n /// removed.\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n-        if let ty::Ref(_, ty, _) = ty.kind() { peel(*ty, count + 1) } else { (ty, count) }\n+        if let ty::Ref(_, ty, _) = ty.kind() {\n+            peel(*ty, count + 1)\n+        } else {\n+            (ty, count)\n+        }\n     }\n     peel(ty, 0)\n }\n@@ -457,18 +452,17 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n                 return false;\n             }\n \n-            substs_a.iter().zip(substs_b.iter()).all(|(arg_a, arg_b)| {\n-                match (arg_a.unpack(), arg_b.unpack()) {\n-                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => {\n-                        inner_a == inner_b\n-                    }\n+            substs_a\n+                .iter()\n+                .zip(substs_b.iter())\n+                .all(|(arg_a, arg_b)| match (arg_a.unpack(), arg_b.unpack()) {\n+                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => inner_a == inner_b,\n                     (GenericArgKind::Type(type_a), GenericArgKind::Type(type_b)) => {\n                         same_type_and_consts(type_a, type_b)\n-                    }\n+                    },\n                     _ => true,\n-                }\n-            })\n-        }\n+                })\n+        },\n         _ => a == b,\n     }\n }\n@@ -484,10 +478,7 @@ pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n }\n \n /// Gets an iterator over all predicates which apply to the given item.\n-pub fn all_predicates_of(\n-    tcx: TyCtxt<'_>,\n-    id: DefId,\n-) -> impl Iterator<Item = &(Predicate<'_>, Span)> {\n+pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(Predicate<'_>, Span)> {\n     let mut next_id = Some(id);\n     iter::from_fn(move || {\n         next_id.take().map(|id| {\n@@ -517,7 +508,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n                 } else {\n                     Some(sig.input(i))\n                 }\n-            }\n+            },\n             Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])),\n             Self::Trait(inputs, _, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n         }\n@@ -526,10 +517,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n     /// Gets the argument type at the given offset. For closures this will also get the type as\n     /// written. This will return `None` when the index is out of bounds only for variadic\n     /// functions, otherwise this will panic.\n-    pub fn input_with_hir(\n-        self,\n-        i: usize,\n-    ) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> {\n+    pub fn input_with_hir(self, i: usize) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> {\n         match self {\n             Self::Sig(sig, _) => {\n                 if sig.c_variadic() {\n@@ -540,7 +528,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n                 } else {\n                     Some((None, sig.input(i)))\n                 }\n-            }\n+            },\n             Self::Closure(decl, sig) => Some((\n                 decl.and_then(|decl| decl.inputs.get(i)),\n                 sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n@@ -559,15 +547,17 @@ impl<'tcx> ExprFnSig<'tcx> {\n     }\n \n     pub fn predicates_id(&self) -> Option<DefId> {\n-        if let ExprFnSig::Sig(_, id) | ExprFnSig::Trait(_, _, id) = *self { id } else { None }\n+        if let ExprFnSig::Sig(_, id) | ExprFnSig::Trait(_, _, id) = *self {\n+            id\n+        } else {\n+            None\n+        }\n     }\n }\n \n /// If the expression is function like, get the signature for it.\n pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnSig<'tcx>> {\n-    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) =\n-        path_res(cx, expr)\n-    {\n+    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = path_res(cx, expr) {\n         Some(ExprFnSig::Sig(cx.tcx.fn_sig(id), Some(id)))\n     } else {\n         ty_sig(cx, cx.typeck_results().expr_ty_adjusted(expr).peel_refs())\n@@ -581,14 +571,12 @@ pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'t\n     }\n     match *ty.kind() {\n         ty::Closure(id, subs) => {\n-            let decl = id.as_local().and_then(|id| {\n-                cx.tcx.hir().fn_decl_by_hir_id(cx.tcx.hir().local_def_id_to_hir_id(id))\n-            });\n+            let decl = id\n+                .as_local()\n+                .and_then(|id| cx.tcx.hir().fn_decl_by_hir_id(cx.tcx.hir().local_def_id_to_hir_id(id)));\n             Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n-        }\n-        ty::FnDef(id, subs) => {\n-            Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id)))\n-        }\n+        },\n+        ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id))),\n         ty::Opaque(id, _) => sig_from_bounds(cx, ty, cx.tcx.item_bounds(id), cx.tcx.opt_parent(id)),\n         ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig, None)),\n         ty::Dynamic(bounds, _, _) => {\n@@ -601,19 +589,16 @@ pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'t\n                 {\n                     let output = bounds\n                         .projection_bounds()\n-                        .find(|p| {\n-                            lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id())\n-                        })\n+                        .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n                         .map(|p| p.map_bound(|p| p.term.ty().unwrap()));\n                     Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output, None))\n-                }\n+                },\n                 _ => None,\n             }\n-        }\n+        },\n         ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n             Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n-            _ => sig_for_projection(cx, proj)\n-                .or_else(|| sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None)),\n+            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None)),\n         },\n         ty::Param(_) => sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None),\n         _ => None,\n@@ -644,7 +629,7 @@ fn sig_from_bounds<'tcx>(\n                     return None;\n                 }\n                 inputs = Some(i);\n-            }\n+            },\n             PredicateKind::Projection(p)\n                 if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n                     && p.projection_ty.self_ty() == ty =>\n@@ -654,18 +639,15 @@ fn sig_from_bounds<'tcx>(\n                     return None;\n                 }\n                 output = Some(pred.kind().rebind(p.term.ty().unwrap()));\n-            }\n+            },\n             _ => (),\n         }\n     }\n \n     inputs.map(|ty| ExprFnSig::Trait(ty, output, predicates_id))\n }\n \n-fn sig_for_projection<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ty: ProjectionTy<'tcx>,\n-) -> Option<ExprFnSig<'tcx>> {\n+fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n     let mut inputs = None;\n     let mut output = None;\n     let lang_items = cx.tcx.lang_items();\n@@ -691,10 +673,8 @@ fn sig_for_projection<'tcx>(\n                     return None;\n                 }\n                 inputs = Some(i);\n-            }\n-            PredicateKind::Projection(p)\n-                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() =>\n-            {\n+            },\n+            PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n                 if output.is_some() {\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n@@ -703,7 +683,7 @@ fn sig_for_projection<'tcx>(\n                     pred.map_bound(|pred| pred.kind().rebind(p.term.ty().unwrap()))\n                         .subst(cx.tcx, ty.substs),\n                 );\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -797,10 +777,7 @@ pub fn for_each_top_level_late_bound_region<B>(\n                 ControlFlow::Continue(())\n             }\n         }\n-        fn visit_binder<T: TypeVisitable<'tcx>>(\n-            &mut self,\n-            t: &Binder<'tcx, T>,\n-        ) -> ControlFlow<Self::BreakTy> {\n+        fn visit_binder<T: TypeVisitable<'tcx>>(&mut self, t: &Binder<'tcx, T>) -> ControlFlow<Self::BreakTy> {\n             self.index += 1;\n             let res = t.super_visit_with(self);\n             self.index -= 1;\n@@ -814,27 +791,19 @@ pub fn for_each_top_level_late_bound_region<B>(\n pub fn variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<&'tcx VariantDef> {\n     match res {\n         Res::Def(DefKind::Struct, id) => Some(cx.tcx.adt_def(id).non_enum_variant()),\n-        Res::Def(DefKind::Variant, id) => {\n-            Some(cx.tcx.adt_def(cx.tcx.parent(id)).variant_with_id(id))\n-        }\n-        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => {\n-            Some(cx.tcx.adt_def(cx.tcx.parent(id)).non_enum_variant())\n-        }\n+        Res::Def(DefKind::Variant, id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).variant_with_id(id)),\n+        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).non_enum_variant()),\n         Res::Def(DefKind::Ctor(CtorOf::Variant, _), id) => {\n             let var_id = cx.tcx.parent(id);\n             Some(cx.tcx.adt_def(cx.tcx.parent(var_id)).variant_with_id(var_id))\n-        }\n+        },\n         Res::SelfCtor(id) => Some(cx.tcx.type_of(id).ty_adt_def().unwrap().non_enum_variant()),\n         _ => None,\n     }\n }\n \n /// Checks if the type is a type parameter implementing `FnOnce`, but not `FnMut`.\n-pub fn ty_is_fn_once_param<'tcx>(\n-    tcx: TyCtxt<'_>,\n-    ty: Ty<'tcx>,\n-    predicates: &'tcx [Predicate<'_>],\n-) -> bool {\n+pub fn ty_is_fn_once_param<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, predicates: &'tcx [Predicate<'_>]) -> bool {\n     let ty::Param(ty) = *ty.kind() else {\n         return false;\n     };"}]}