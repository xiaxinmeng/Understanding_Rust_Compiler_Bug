{"sha": "722bebf1635709453e507a257688f5e85d80528a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMmJlYmYxNjM1NzA5NDUzZTUwN2EyNTc2ODhmNWU4NWQ4MDUyOGE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-05T15:52:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-05T15:52:18Z"}, "message": "Rollup merge of #83553 - jfrimmel:addr-of, r=m-ou-se\n\nUpdate `ptr` docs with regards to `ptr::addr_of!`\n\nThis updates the documentation since `ptr::addr_of!` and `ptr::addr_of_mut!` are now stable. One might remove the distinction between the sections `# On packed structs` and `# Examples`, as the old section on packed structs was primarily to prevent users of doing undefined behavior, which is not necessary anymore.\n\nTechnically there is now wrong/outdated documentation on stable, but I don't think this is worth a point release \ud83d\ude09\n\nFixes #83509.\n\n``````````@rustbot`````````` modify labels: T-doc", "tree": {"sha": "dd94be7d50d0b7c2271d444b220d3b5db4aa0b80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd94be7d50d0b7c2271d444b220d3b5db4aa0b80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/722bebf1635709453e507a257688f5e85d80528a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgkr8zCRBK7hj4Ov3rIwAApWQIABVCJRmhfjA1VmwTXFxj8F8i\n32aZC3sYvUKv0ZTw8ZO2fphIhB9OsQyip1qyNwaCJ7ZyM5Iv38g0GVUAtv0QOB49\nk2bsaPBuo4TD6o2bvgxk9zBdnp+2MOwIwTDfbqfBcJKaAwKsa+X7FdAdYFwhIJS5\ngNiGW2REVmh4wjplTtQ3B3325lJlpOO0KWY/GPZ4tQR++Nf0IfF7KY6eK+Zhic60\nyPsTS/1/dKCwEF6NpErHrl3CWN5W0k43r9aA7s/2rNGLI1mya2HkO6wfOzpW4r4Z\nwbCDCVCw4EJ10mYcFZ9ZlQQ/iK/h0a/v+r9JLN5nPwWIQOvpV+DIs901iHB6aTg=\n=diK5\n-----END PGP SIGNATURE-----\n", "payload": "tree dd94be7d50d0b7c2271d444b220d3b5db4aa0b80\nparent 24acc388da2cdbe1ec79b6933402941b6fffb26b\nparent 389333a21c6a0ed51952c6d5d0b339e7d274ef2e\nauthor Ralf Jung <post@ralfj.de> 1620229938 +0200\ncommitter GitHub <noreply@github.com> 1620229938 +0200\n\nRollup merge of #83553 - jfrimmel:addr-of, r=m-ou-se\n\nUpdate `ptr` docs with regards to `ptr::addr_of!`\n\nThis updates the documentation since `ptr::addr_of!` and `ptr::addr_of_mut!` are now stable. One might remove the distinction between the sections `# On packed structs` and `# Examples`, as the old section on packed structs was primarily to prevent users of doing undefined behavior, which is not necessary anymore.\n\nTechnically there is now wrong/outdated documentation on stable, but I don't think this is worth a point release \ud83d\ude09\n\nFixes #83509.\n\n``````````@rustbot`````````` modify labels: T-doc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/722bebf1635709453e507a257688f5e85d80528a", "html_url": "https://github.com/rust-lang/rust/commit/722bebf1635709453e507a257688f5e85d80528a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/722bebf1635709453e507a257688f5e85d80528a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24acc388da2cdbe1ec79b6933402941b6fffb26b", "url": "https://api.github.com/repos/rust-lang/rust/commits/24acc388da2cdbe1ec79b6933402941b6fffb26b", "html_url": "https://github.com/rust-lang/rust/commit/24acc388da2cdbe1ec79b6933402941b6fffb26b"}, {"sha": "389333a21c6a0ed51952c6d5d0b339e7d274ef2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/389333a21c6a0ed51952c6d5d0b339e7d274ef2e", "html_url": "https://github.com/rust-lang/rust/commit/389333a21c6a0ed51952c6d5d0b339e7d274ef2e"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "2c324b15a1a1a75ed15c95fb922e06631328c3ff", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/722bebf1635709453e507a257688f5e85d80528a/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722bebf1635709453e507a257688f5e85d80528a/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=722bebf1635709453e507a257688f5e85d80528a", "patch": "@@ -720,9 +720,6 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n ///\n /// ## On `packed` structs\n ///\n-/// It is currently impossible to create raw pointers to unaligned fields\n-/// of a packed struct.\n-///\n /// Attempting to create a raw pointer to an `unaligned` struct field with\n /// an expression such as `&packed.unaligned as *const FieldType` creates an\n /// intermediate unaligned reference before converting that to a raw pointer.\n@@ -731,9 +728,13 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n /// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n /// *undefined behavior* in your program.\n ///\n+/// Instead you must use the [`ptr::addr_of!`](addr_of) macro to\n+/// create the pointer. You may use that returned pointer together with this\n+/// function.\n+///\n /// An example of what not to do and how this relates to `read_unaligned` is:\n ///\n-/// ```no_run\n+/// ```\n /// #[repr(packed, C)]\n /// struct Packed {\n ///     _padding: u8,\n@@ -745,24 +746,15 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n ///     unaligned: 0x01020304,\n /// };\n ///\n-/// #[allow(unaligned_references)]\n-/// let v = unsafe {\n-///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n-///     let unaligned =\n-///         // A temporary unaligned reference is created here which results in\n-///         // undefined behavior regardless of whether the reference is used or not.\n-///         &packed.unaligned\n-///         // Casting to a raw pointer doesn't help; the mistake already happened.\n-///         as *const u32;\n+/// // Take the address of a 32-bit integer which is not aligned.\n+/// // In contrast to `&packed.unaligned as *const _`, this has no undefined behavior.\n+/// let unaligned = std::ptr::addr_of!(packed.unaligned);\n ///\n-///     let v = std::ptr::read_unaligned(unaligned);\n-///\n-///     v\n-/// };\n+/// let v = unsafe { std::ptr::read_unaligned(unaligned) };\n+/// assert_eq!(v, 0x01020304);\n /// ```\n ///\n /// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n-// FIXME: Update docs based on outcome of RFC #2582 and friends.\n ///\n /// # Examples\n ///\n@@ -916,9 +908,6 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// ## On `packed` structs\n ///\n-/// It is currently impossible to create raw pointers to unaligned fields\n-/// of a packed struct.\n-///\n /// Attempting to create a raw pointer to an `unaligned` struct field with\n /// an expression such as `&packed.unaligned as *const FieldType` creates an\n /// intermediate unaligned reference before converting that to a raw pointer.\n@@ -927,36 +916,32 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n /// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n /// *undefined behavior* in your program.\n ///\n-/// An example of what not to do and how this relates to `write_unaligned` is:\n+/// Instead you must use the [`ptr::addr_of_mut!`](addr_of_mut)\n+/// macro to create the pointer. You may use that returned pointer together with\n+/// this function.\n+///\n+/// An example of how to do it and how this relates to `write_unaligned` is:\n ///\n-/// ```no_run\n+/// ```\n /// #[repr(packed, C)]\n /// struct Packed {\n ///     _padding: u8,\n ///     unaligned: u32,\n /// }\n ///\n-/// let v = 0x01020304;\n /// let mut packed: Packed = unsafe { std::mem::zeroed() };\n ///\n-/// #[allow(unaligned_references)]\n-/// let v = unsafe {\n-///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n-///     let unaligned =\n-///         // A temporary unaligned reference is created here which results in\n-///         // undefined behavior regardless of whether the reference is used or not.\n-///         &mut packed.unaligned\n-///         // Casting to a raw pointer doesn't help; the mistake already happened.\n-///         as *mut u32;\n+/// // Take the address of a 32-bit integer which is not aligned.\n+/// // In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.\n+/// let unaligned = std::ptr::addr_of_mut!(packed.unaligned);\n ///\n-///     std::ptr::write_unaligned(unaligned, v);\n+/// unsafe { std::ptr::write_unaligned(unaligned, 42) };\n ///\n-///     v\n-/// };\n+/// assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.\n /// ```\n ///\n-/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n-// FIXME: Update docs based on outcome of RFC #2582 and friends.\n+/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however\n+/// (as can be seen in the `assert_eq!` above).\n ///\n /// # Examples\n ///"}, {"sha": "96ab32104ea2c0cffabfe6ca3f94fd6f14e9c7af", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/722bebf1635709453e507a257688f5e85d80528a/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722bebf1635709453e507a257688f5e85d80528a/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=722bebf1635709453e507a257688f5e85d80528a", "patch": "@@ -445,7 +445,27 @@ mod prim_unit {}\n /// Note that here the call to [`drop`] is for clarity - it indicates\n /// that we are done with the given value and it should be destroyed.\n ///\n-/// ## 3. Get it from C.\n+/// ## 3. Create it using `ptr::addr_of!`\n+///\n+/// Instead of coercing a reference to a raw pointer, you can use the macros\n+/// [`ptr::addr_of!`] (for `*const T`) and [`ptr::addr_of_mut!`] (for `*mut T`).\n+/// These macros allow you to create raw pointers to fields to which you cannot\n+/// create a reference (without causing undefined behaviour), such as an\n+/// unaligned field. This might be necessary if packed structs or uninitialized\n+/// memory is involved.\n+///\n+/// ```\n+/// #[derive(Debug, Default, Copy, Clone)]\n+/// #[repr(C, packed)]\n+/// struct S {\n+///     aligned: u8,\n+///     unaligned: u32,\n+/// }\n+/// let s = S::default();\n+/// let p = std::ptr::addr_of!(s.unaligned); // not allowed with coercion\n+/// ```\n+///\n+/// ## 4. Get it from C.\n ///\n /// ```\n /// # #![feature(rustc_private)]"}]}