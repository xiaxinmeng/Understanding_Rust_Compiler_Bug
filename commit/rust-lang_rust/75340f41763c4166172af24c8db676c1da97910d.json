{"sha": "75340f41763c4166172af24c8db676c1da97910d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MzQwZjQxNzYzYzQxNjYxNzJhZjI0YzhkYjY3NmMxZGE5NzkxMGQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-05-21T12:49:16Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-06-18T14:38:23Z"}, "message": "Revise dataflow to do a cfg-driven walk.\n\nFix #6298.\n\nThis is instead of the prior approach of emulating cfg traversal\nprivately by traversing AST in same way).\n\nOf special note, this removes a special case handling of `ExprParen`\nthat was actually injecting a bug (since it was acting like an\nexpression like `(*func)()` was consuming `*func` *twice*: once from\n`(*func)` and again from `*func`).  nikomatsakis was the first one to\npoint out that it might suffice to simply have the outer `ExprParen`\ndo the consumption of the contents (alone).\n\n(This version has been updated to incorporate feedback from Niko's\nreview of PR 14873.)", "tree": {"sha": "3e3a312f6ae26227b4f66becba49e723911a9517", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e3a312f6ae26227b4f66becba49e723911a9517"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75340f41763c4166172af24c8db676c1da97910d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75340f41763c4166172af24c8db676c1da97910d", "html_url": "https://github.com/rust-lang/rust/commit/75340f41763c4166172af24c8db676c1da97910d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75340f41763c4166172af24c8db676c1da97910d/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fef63e2f237ea016b367c97dca50f35ab68c5164", "url": "https://api.github.com/repos/rust-lang/rust/commits/fef63e2f237ea016b367c97dca50f35ab68c5164", "html_url": "https://github.com/rust-lang/rust/commit/fef63e2f237ea016b367c97dca50f35ab68c5164"}], "stats": {"total": 948, "additions": 340, "deletions": 608}, "files": [{"sha": "98edc6365cf325a8e5d96aaf3be713f1acb4bec2", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=75340f41763c4166172af24c8db676c1da97910d", "patch": "@@ -12,7 +12,9 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::cfg;\n use middle::dataflow::DataFlowContext;\n+use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n use middle::def;\n use euv = middle::expr_use_visitor;\n@@ -126,20 +128,28 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, decl, body);\n+    let cfg = cfg::CFG::new(this.tcx, body);\n+\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n+                             \"borrowck\",\n+                             Some(decl),\n+                             &cfg,\n                              LoanDataFlowOperator,\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n         loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n         loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n     }\n-    loan_dfcx.propagate(body);\n+    loan_dfcx.add_kills_from_flow_exits(&cfg);\n+    loan_dfcx.propagate(&cfg, body);\n \n     let flowed_moves = move_data::FlowedMoveData::new(move_data,\n                                                       this.tcx,\n+                                                      &cfg,\n                                                       id_range,\n+                                                      decl,\n                                                       body);\n \n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n@@ -753,15 +763,17 @@ fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {\n      }\n }\n \n-impl DataFlowOperator for LoanDataFlowOperator {\n+impl BitwiseOperator for LoanDataFlowOperator {\n     #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no loans in scope by default\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // loans from both preds are in scope\n     }\n+}\n \n+impl DataFlowOperator for LoanDataFlowOperator {\n     #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n-        succ | pred // loans from both preds are in scope\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n     }\n }\n "}, {"sha": "3e2f763a84bc246af48252569c3231ea26e8612c", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=75340f41763c4166172af24c8db676c1da97910d", "patch": "@@ -20,7 +20,9 @@ use std::rc::Rc;\n use std::uint;\n use std::collections::{HashMap, HashSet};\n use middle::borrowck::*;\n+use middle::cfg;\n use middle::dataflow::DataFlowContext;\n+use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n use euv = middle::expr_use_visitor;\n use middle::ty;\n@@ -499,22 +501,33 @@ impl MoveData {\n impl<'a> FlowedMoveData<'a> {\n     pub fn new(move_data: MoveData,\n                tcx: &'a ty::ctxt,\n+               cfg: &'a cfg::CFG,\n                id_range: ast_util::IdRange,\n+               decl: &ast::FnDecl,\n                body: &ast::Block)\n                -> FlowedMoveData<'a> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n+                                 \"flowed_move_data_moves\",\n+                                 Some(decl),\n+                                 cfg,\n                                  MoveDataFlowOperator,\n                                  id_range,\n                                  move_data.moves.borrow().len());\n         let mut dfcx_assign =\n             DataFlowContext::new(tcx,\n+                                 \"flowed_move_data_assigns\",\n+                                 Some(decl),\n+                                 cfg,\n                                  AssignDataFlowOperator,\n                                  id_range,\n                                  move_data.var_assignments.borrow().len());\n         move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n-        dfcx_moves.propagate(body);\n-        dfcx_assign.propagate(body);\n+        dfcx_moves.add_kills_from_flow_exits(cfg);\n+        dfcx_assign.add_kills_from_flow_exits(cfg);\n+        dfcx_moves.propagate(cfg, body);\n+        dfcx_assign.propagate(cfg, body);\n+\n         FlowedMoveData {\n             move_data: move_data,\n             dfcx_moves: dfcx_moves,\n@@ -659,12 +672,21 @@ impl<'a> FlowedMoveData<'a> {\n     }\n }\n \n+impl BitwiseOperator for MoveDataFlowOperator {\n+    #[inline]\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // moves from both preds are in scope\n+    }\n+}\n+\n impl DataFlowOperator for MoveDataFlowOperator {\n     #[inline]\n     fn initial_value(&self) -> bool {\n         false // no loans in scope by default\n     }\n+}\n \n+impl BitwiseOperator for AssignDataFlowOperator {\n     #[inline]\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n@@ -676,9 +698,4 @@ impl DataFlowOperator for AssignDataFlowOperator {\n     fn initial_value(&self) -> bool {\n         false // no assignments in scope by default\n     }\n-\n-    #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n-        succ | pred // moves from both preds are in scope\n-    }\n }"}, {"sha": "872a0878e3792d4218499e4326e330801ee152b5", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 296, "deletions": 576, "changes": 872, "blob_url": "https://github.com/rust-lang/rust/blob/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=75340f41763c4166172af24c8db676c1da97910d", "patch": "@@ -17,23 +17,24 @@\n  */\n \n \n-use middle::def;\n+use middle::cfg;\n+use middle::cfg::CFGIndex;\n use middle::ty;\n-use middle::typeck;\n use std::io;\n-use std::gc::Gc;\n use std::uint;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::ast_util::IdRange;\n+use syntax::visit;\n use syntax::print::{pp, pprust};\n-use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n #[deriving(Clone)]\n pub struct DataFlowContext<'a, O> {\n     tcx: &'a ty::ctxt,\n \n+    /// a name for the analysis using this dataflow instance\n+    analysis_name: &'static str,\n+\n     /// the data flow operator\n     oper: O,\n \n@@ -44,43 +45,108 @@ pub struct DataFlowContext<'a, O> {\n     /// equal to bits_per_id/uint::BITS rounded up.\n     words_per_id: uint,\n \n-    // mapping from node to bitset index.\n-    nodeid_to_bitset: NodeMap<uint>,\n+    // mapping from cfg node index to bitset index.\n+    index_to_bitset: Vec<Option<uint>>,\n+\n+    // mapping from node to cfg node index\n+    // FIXME (#6298): Shouldn't this go with CFG?\n+    nodeid_to_index: NodeMap<CFGIndex>,\n \n-    // Bit sets per id.  The following three fields (`gens`, `kills`,\n+    // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n     // `id_range`, there is a range of words equal to `words_per_id`.\n     // So, to access the bits for any given id, you take a slice of\n     // the full vector (see the method `compute_id_range()`).\n \n-    /// bits generated as we exit the scope `id`. Updated by `add_gen()`.\n+    /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n     gens: Vec<uint>,\n \n-    /// bits killed as we exit the scope `id`. Updated by `add_kill()`.\n+    /// bits killed as we exit the cfg node. Updated by `add_kill()`.\n     kills: Vec<uint>,\n \n-    /// bits that are valid on entry to the scope `id`. Updated by\n+    /// bits that are valid on entry to the cfg node. Updated by\n     /// `propagate()`.\n     on_entry: Vec<uint>,\n }\n \n+pub trait BitwiseOperator {\n+    /// Joins two predecessor bits together, typically either `|` or `&`\n+    fn join(&self, succ: uint, pred: uint) -> uint;\n+}\n+\n /// Parameterization for the precise form of data flow that is used.\n-pub trait DataFlowOperator {\n+pub trait DataFlowOperator : BitwiseOperator {\n     /// Specifies the initial value for each bit in the `on_entry` set\n     fn initial_value(&self) -> bool;\n-\n-    /// Joins two predecessor bits together, typically either `|` or `&`\n-    fn join(&self, succ: uint, pred: uint) -> uint;\n }\n \n struct PropagationContext<'a, 'b, O> {\n     dfcx: &'a mut DataFlowContext<'b, O>,\n     changed: bool\n }\n \n-struct LoopScope<'a> {\n-    loop_id: ast::NodeId,\n-    break_bits: Vec<uint>\n+fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n+    let opt_cfgindex = index.find(&id).map(|&i|i);\n+    opt_cfgindex.unwrap_or_else(|| {\n+        fail!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n+    })\n+}\n+\n+impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n+    fn has_bitset(&self, n: ast::NodeId) -> bool {\n+        assert!(n != ast::DUMMY_NODE_ID);\n+        match self.nodeid_to_index.find(&n) {\n+            None => false,\n+            Some(&cfgidx) => {\n+                let node_id = cfgidx.node_id();\n+                node_id < self.index_to_bitset.len() &&\n+                    self.index_to_bitset.get(node_id).is_some()\n+            }\n+        }\n+    }\n+    fn get_bitset_index(&self, cfgidx: CFGIndex) -> uint {\n+        let node_id = cfgidx.node_id();\n+        self.index_to_bitset.get(node_id).unwrap()\n+    }\n+    fn get_or_create_bitset_index(&mut self, cfgidx: CFGIndex) -> uint {\n+        assert!(self.words_per_id > 0);\n+        let len = self.gens.len() / self.words_per_id;\n+        let expanded;\n+        let n;\n+        if self.index_to_bitset.len() <= cfgidx.node_id() {\n+            self.index_to_bitset.grow_set(cfgidx.node_id(), &None, Some(len));\n+            expanded = true;\n+            n = len;\n+        } else {\n+            let entry = self.index_to_bitset.get_mut(cfgidx.node_id());\n+            match *entry {\n+                None => {\n+                    *entry = Some(len);\n+                    expanded = true;\n+                    n = len;\n+                }\n+                Some(bitidx) => {\n+                    expanded = false;\n+                    n = bitidx;\n+                }\n+            }\n+        }\n+        if expanded {\n+            let entry = if self.oper.initial_value() { uint::MAX } else {0};\n+            for _ in range(0, self.words_per_id) {\n+                self.gens.push(0);\n+                self.kills.push(0);\n+                self.on_entry.push(entry);\n+            }\n+        }\n+\n+        let start = n * self.words_per_id;\n+        let end = start + self.words_per_id;\n+        let len = self.gens.len();\n+        assert!(start < len);\n+        assert!(end <= len);\n+        n\n+    }\n }\n \n impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n@@ -94,8 +160,9 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n             pprust::NodePat(pat) => pat.id\n         };\n \n-        if self.nodeid_to_bitset.contains_key(&id) {\n-            let (start, end) = self.compute_id_range_frozen(id);\n+        if self.has_bitset(id) {\n+            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+            let (start, end) = self.compute_id_range_frozen(cfgidx);\n             let on_entry = self.on_entry.slice(start, end);\n             let entry_str = bits_to_str(on_entry);\n \n@@ -121,24 +188,74 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n     }\n }\n \n+fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n+                         cfg: &cfg::CFG) -> NodeMap<CFGIndex> {\n+    let mut index = NodeMap::new();\n+\n+    // FIXME (#6298): Would it be better to fold formals from decl\n+    // into cfg itself?  i.e. introduce a fn-based flow-graph in\n+    // addition to the current block-based flow-graph, rather than\n+    // have to put traversals like this here?\n+    match decl {\n+        None => {}\n+        Some(decl) => add_entries_from_fn_decl(&mut index, decl, cfg.entry)\n+    }\n+\n+    cfg.graph.each_node(|node_idx, node| {\n+        if node.data.id != ast::DUMMY_NODE_ID {\n+            index.insert(node.data.id, node_idx);\n+        }\n+        true\n+    });\n+\n+    return index;\n+\n+    fn add_entries_from_fn_decl(index: &mut NodeMap<CFGIndex>,\n+                                decl: &ast::FnDecl,\n+                                entry: CFGIndex) {\n+        //! add mappings from the ast nodes for the formal bindings to\n+        //! the entry-node in the graph.\n+        struct Formals<'a> {\n+            entry: CFGIndex,\n+            index: &'a mut NodeMap<CFGIndex>,\n+        }\n+        let mut formals = Formals { entry: entry, index: index };\n+        visit::walk_fn_decl(&mut formals, decl, ());\n+        impl<'a> visit::Visitor<()> for Formals<'a> {\n+            fn visit_pat(&mut self, p: &ast::Pat, e: ()) {\n+                self.index.insert(p.id, self.entry);\n+                visit::walk_pat(self, p, e)\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     pub fn new(tcx: &'a ty::ctxt,\n+               analysis_name: &'static str,\n+               decl: Option<&ast::FnDecl>,\n+               cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<'a, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n \n-        debug!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n-               id_range, bits_per_id, words_per_id);\n+        debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={:?}, \\\n+                                     bits_per_id={:?}, words_per_id={:?})\",\n+               analysis_name, id_range, bits_per_id, words_per_id);\n \n         let gens = Vec::new();\n         let kills = Vec::new();\n         let on_entry = Vec::new();\n \n+        let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n+\n         DataFlowContext {\n             tcx: tcx,\n+            analysis_name: analysis_name,\n             words_per_id: words_per_id,\n-            nodeid_to_bitset: NodeMap::new(),\n+            index_to_bitset: Vec::new(),\n+            nodeid_to_index: nodeid_to_index,\n             bits_per_id: bits_per_id,\n             oper: oper,\n             gens: gens,\n@@ -149,74 +266,60 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n \n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n-\n-        debug!(\"add_gen(id={:?}, bit={:?})\", id, bit);\n-        let (start, end) = self.compute_id_range(id);\n-        {\n-            let gens = self.gens.mut_slice(start, end);\n-            set_bit(gens, bit);\n+        if self.nodeid_to_index.contains_key(&id) {\n+            debug!(\"add_gen(id={:?}, bit={:?})\", id, bit);\n+            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            {\n+                let gens = self.gens.mut_slice(start, end);\n+                set_bit(gens, bit);\n+            }\n+        } else {\n+            debug!(\"{:s} add_gen skip (id={:?}, bit={:?}); id not in current fn\",\n+                   self.analysis_name, id, bit);\n         }\n     }\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n-\n-        debug!(\"add_kill(id={:?}, bit={:?})\", id, bit);\n-        let (start, end) = self.compute_id_range(id);\n-        {\n-            let kills = self.kills.mut_slice(start, end);\n-            set_bit(kills, bit);\n+        if self.nodeid_to_index.contains_key(&id) {\n+            debug!(\"add_kill(id={:?}, bit={:?})\", id, bit);\n+            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            {\n+                let kills = self.kills.mut_slice(start, end);\n+                set_bit(kills, bit);\n+            }\n+        } else {\n+            debug!(\"{:s} add_kill skip (id={:?}, bit={:?}); id not in current fn\",\n+                   self.analysis_name, id, bit);\n         }\n     }\n \n-    fn apply_gen_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n+    fn apply_gen_kill(&mut self, cfgidx: CFGIndex, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n-\n-        debug!(\"apply_gen_kill(id={:?}, bits={}) [before]\",\n-               id, mut_bits_to_str(bits));\n-        let (start, end) = self.compute_id_range(id);\n+        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n+               self.analysis_name, cfgidx, mut_bits_to_str(bits));\n+        let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n-        bitwise(bits, gens, |a, b| a | b);\n+        bitwise(bits, gens, &Union);\n         let kills = self.kills.slice(start, end);\n-        bitwise(bits, kills, |a, b| a & !b);\n-\n-        debug!(\"apply_gen_kill(id={:?}, bits={}) [after]\",\n-               id, mut_bits_to_str(bits));\n-    }\n+        bitwise(bits, kills, &Subtract);\n \n-    fn apply_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n-        debug!(\"apply_kill(id={:?}, bits={}) [before]\",\n-               id, mut_bits_to_str(bits));\n-        let (start, end) = self.compute_id_range(id);\n-        let kills = self.kills.slice(start, end);\n-        bitwise(bits, kills, |a, b| a & !b);\n-        debug!(\"apply_kill(id={:?}, bits={}) [after]\",\n-               id, mut_bits_to_str(bits));\n+        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n+               self.analysis_name, cfgidx, mut_bits_to_str(bits));\n     }\n \n-    fn compute_id_range_frozen(&self, id: ast::NodeId) -> (uint, uint) {\n-        let n = *self.nodeid_to_bitset.get(&id);\n+    fn compute_id_range_frozen(&self, cfgidx: CFGIndex) -> (uint, uint) {\n+        let n = self.get_bitset_index(cfgidx);\n         let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n         (start, end)\n     }\n \n-    fn compute_id_range(&mut self, id: ast::NodeId) -> (uint, uint) {\n-        let mut expanded = false;\n-        let len = self.nodeid_to_bitset.len();\n-        let n = self.nodeid_to_bitset.find_or_insert_with(id, |_| {\n-            expanded = true;\n-            len\n-        });\n-        if expanded {\n-            let entry = if self.oper.initial_value() { uint::MAX } else {0};\n-            for _ in range(0, self.words_per_id) {\n-                self.gens.push(0);\n-                self.kills.push(0);\n-                self.on_entry.push(entry);\n-            }\n-        }\n-        let start = *n * self.words_per_id;\n+    fn compute_id_range(&mut self, cfgidx: CFGIndex) -> (uint, uint) {\n+        let n = self.get_or_create_bitset_index(cfgidx);\n+        let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n \n         assert!(start < self.gens.len());\n@@ -234,26 +337,28 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                                     -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n-        if !self.nodeid_to_bitset.contains_key(&id) {\n+        if !self.has_bitset(id) {\n             return true;\n         }\n-        let (start, end) = self.compute_id_range_frozen(id);\n+        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        let (start, end) = self.compute_id_range_frozen(cfgidx);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug!(\"each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n-               id, bits_to_str(on_entry));\n+        debug!(\"{:s} each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n+               self.analysis_name, id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n     }\n \n     pub fn each_gen_bit_frozen(&self, id: ast::NodeId, f: |uint| -> bool)\n                                -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n-        if !self.nodeid_to_bitset.contains_key(&id) {\n+        if !self.has_bitset(id) {\n             return true;\n         }\n-        let (start, end) = self.compute_id_range_frozen(id);\n+        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        let (start, end) = self.compute_id_range_frozen(cfgidx);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"each_gen_bit(id={:?}, gens={})\",\n-               id, bits_to_str(gens));\n+        debug!(\"{:s} each_gen_bit(id={:?}, gens={})\",\n+               self.analysis_name, id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n \n@@ -287,11 +392,63 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         }\n         return true;\n     }\n+\n+    pub fn add_kills_from_flow_exits(&mut self, cfg: &cfg::CFG) {\n+        //! Whenever you have a `break` or `continue` statement, flow\n+        //! exits through any number of enclosing scopes on its way to\n+        //! the new destination. This function infers the kill bits of\n+        //! those control operators based on the kill bits associated\n+        //! with those scopes.\n+        //!\n+        //! This is usually called (if it is called at all), after\n+        //! all add_gen and add_kill calls, but before propagate.\n+\n+        debug!(\"{:s} add_kills_from_flow_exits\", self.analysis_name);\n+        if self.bits_per_id == 0 {\n+            // Skip the surprisingly common degenerate case.  (Note\n+            // compute_id_range requires self.words_per_id > 0.)\n+            return;\n+        }\n+        cfg.graph.each_edge(|_edge_index, edge| {\n+            let flow_exit = edge.source();\n+            let (start, end) = self.compute_id_range(flow_exit);\n+            let mut orig_kills = self.kills.slice(start, end).to_owned();\n+\n+            let mut changed = false;\n+            for &node_id in edge.data.exiting_scopes.iter() {\n+                let opt_cfg_idx = self.nodeid_to_index.find(&node_id).map(|&i|i);\n+                match opt_cfg_idx {\n+                    Some(cfg_idx) => {\n+                        let (start, end) = self.compute_id_range(cfg_idx);\n+                        let kills = self.kills.slice(start, end);\n+                        if bitwise(orig_kills.as_mut_slice(), kills, &Union) {\n+                            changed = true;\n+                        }\n+                    }\n+                    None => {\n+                        debug!(\"{:s} add_kills_from_flow_exits flow_exit={} \\\n+                                no cfg_idx for exiting_scope={:?}\",\n+                               self.analysis_name, flow_exit, node_id);\n+                    }\n+                }\n+            }\n+\n+            if changed {\n+                let bits = self.kills.mut_slice(start, end);\n+                debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n+                       self.analysis_name, flow_exit, mut_bits_to_str(bits));\n+                bits.copy_from(orig_kills.as_slice());\n+                debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n+                       self.analysis_name, flow_exit, mut_bits_to_str(bits));\n+            }\n+            true\n+        });\n+    }\n }\n \n impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n //                          ^^^^^^^^^^^^^ only needed for pretty printing\n-    pub fn propagate(&mut self, blk: &ast::Block) {\n+    pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &ast::Block) {\n         //! Performs the data flow analysis.\n \n         if self.bits_per_id == 0 {\n@@ -307,16 +464,14 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n             };\n \n             let mut temp = Vec::from_elem(words_per_id, 0u);\n-            let mut loop_scopes = Vec::new();\n-\n             while propcx.changed {\n                 propcx.changed = false;\n                 propcx.reset(temp.as_mut_slice());\n-                propcx.walk_block(blk, temp.as_mut_slice(), &mut loop_scopes);\n+                propcx.walk_cfg(cfg, temp.as_mut_slice());\n             }\n         }\n \n-        debug!(\"Dataflow result:\");\n+        debug!(\"Dataflow result for {:s}:\", self.analysis_name);\n         debug!(\"{}\", {\n             self.pretty_print_to(box io::stderr(), blk).unwrap();\n             \"\"\n@@ -334,499 +489,64 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n }\n \n impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n-    fn tcx(&self) -> &'b ty::ctxt {\n-        self.dfcx.tcx\n-    }\n-\n-    fn walk_block(&mut self,\n-                  blk: &ast::Block,\n-                  in_out: &mut [uint],\n-                  loop_scopes: &mut Vec<LoopScope> ) {\n-        debug!(\"DataFlowContext::walk_block(blk.id={}, in_out={})\",\n-               blk.id, bits_to_str(in_out));\n-\n-        self.merge_with_entry_set(blk.id, in_out);\n-\n-        for stmt in blk.stmts.iter() {\n-            self.walk_stmt(stmt.clone(), in_out, loop_scopes);\n-        }\n-\n-        self.walk_opt_expr(blk.expr, in_out, loop_scopes);\n-\n-        self.dfcx.apply_gen_kill(blk.id, in_out);\n-    }\n-\n-    fn walk_stmt(&mut self,\n-                 stmt: Gc<ast::Stmt>,\n-                 in_out: &mut [uint],\n-                 loop_scopes: &mut Vec<LoopScope> ) {\n-        match stmt.node {\n-            ast::StmtDecl(ref decl, _) => {\n-                self.walk_decl(decl.clone(), in_out, loop_scopes);\n-            }\n-\n-            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n-                self.walk_expr(&**expr, in_out, loop_scopes);\n-            }\n-\n-            ast::StmtMac(..) => {\n-                self.tcx().sess.span_bug(stmt.span, \"unexpanded macro\");\n-            }\n-        }\n-    }\n-\n-    fn walk_decl(&mut self,\n-                 decl: Gc<ast::Decl>,\n-                 in_out: &mut [uint],\n-                 loop_scopes: &mut Vec<LoopScope> ) {\n-        match decl.node {\n-            ast::DeclLocal(ref local) => {\n-                self.walk_opt_expr(local.init, in_out, loop_scopes);\n-                self.walk_pat(local.pat, in_out, loop_scopes);\n-            }\n-\n-            ast::DeclItem(_) => {}\n-        }\n-    }\n-\n-    fn walk_expr(&mut self,\n-                 expr: &ast::Expr,\n-                 in_out: &mut [uint],\n-                 loop_scopes: &mut Vec<LoopScope> ) {\n-        debug!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n-               expr.repr(self.dfcx.tcx), bits_to_str(in_out));\n-\n-        self.merge_with_entry_set(expr.id, in_out);\n-\n-        match expr.node {\n-            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-            }\n-\n-            ast::ExprIf(cond, then, els) => {\n-                //\n-                //     (cond)\n-                //       |\n-                //       v\n-                //      ( )\n-                //     /   \\\n-                //    |     |\n-                //    v     v\n-                //  (then)(els)\n-                //    |     |\n-                //    v     v\n-                //   (  succ  )\n-                //\n-                self.walk_expr(&*cond, in_out, loop_scopes);\n-\n-                let mut then_bits = in_out.to_owned();\n-                self.walk_block(&*then, then_bits.as_mut_slice(), loop_scopes);\n-\n-                self.walk_opt_expr(els, in_out, loop_scopes);\n-                join_bits(&self.dfcx.oper, then_bits.as_slice(), in_out);\n-            }\n-\n-            ast::ExprWhile(cond, blk) => {\n-                //\n-                //     (expr) <--+\n-                //       |       |\n-                //       v       |\n-                //  +--(cond)    |\n-                //  |    |       |\n-                //  |    v       |\n-                //  v  (blk) ----+\n-                //       |\n-                //    <--+ (break)\n-                //\n-\n-                self.walk_expr(&*cond, in_out, loop_scopes);\n-\n-                let mut body_bits = in_out.to_owned();\n-                loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n-                    break_bits: Vec::from_slice(in_out)\n-                });\n-                self.walk_block(&*blk, body_bits.as_mut_slice(), loop_scopes);\n-                self.add_to_entry_set(expr.id, body_bits.as_slice());\n-                let new_loop_scope = loop_scopes.pop().unwrap();\n-                copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n-            }\n-\n-            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n-\n-            ast::ExprLoop(ref blk, _) => {\n-                //\n-                //     (expr) <--+\n-                //       |       |\n-                //       v       |\n-                //     (blk) ----+\n-                //       |\n-                //    <--+ (break)\n-                //\n-\n-                let mut body_bits = in_out.to_owned();\n-                self.reset(in_out);\n-                loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n-                    break_bits: Vec::from_slice(in_out)\n-                });\n-                self.walk_block(&**blk, body_bits.as_mut_slice(), loop_scopes);\n-                self.add_to_entry_set(expr.id, body_bits.as_slice());\n-\n-                let new_loop_scope = loop_scopes.pop().unwrap();\n-                assert_eq!(new_loop_scope.loop_id, expr.id);\n-                copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n-            }\n-\n-            ast::ExprMatch(ref discr, ref arms) => {\n-                //\n-                //    (discr)\n-                //     / | \\\n-                //    |  |  |\n-                //    v  v  v\n-                //   (..arms..)\n-                //    |  |  |\n-                //    v  v  v\n-                //   (  succ  )\n-                //\n-                //\n-                self.walk_expr(&**discr, in_out, loop_scopes);\n-\n-                let mut guards = in_out.to_owned();\n-\n-                // We know that exactly one arm will be taken, so we\n-                // can start out with a blank slate and just union\n-                // together the bits from each arm:\n-                self.reset(in_out);\n-\n-                for arm in arms.iter() {\n-                    // in_out reflects the discr and all guards to date\n-                    self.walk_opt_expr(arm.guard, guards.as_mut_slice(),\n-                                       loop_scopes);\n-\n-                    // determine the bits for the body and then union\n-                    // them into `in_out`, which reflects all bodies to date\n-                    let mut body = guards.to_owned();\n-                    self.walk_pat_alternatives(arm.pats.as_slice(),\n-                                               body.as_mut_slice(),\n-                                               loop_scopes);\n-                    self.walk_expr(&*arm.body, body.as_mut_slice(), loop_scopes);\n-                    join_bits(&self.dfcx.oper, body.as_slice(), in_out);\n-                }\n-            }\n-\n-            ast::ExprRet(o_e) => {\n-                self.walk_opt_expr(o_e, in_out, loop_scopes);\n-                self.reset(in_out);\n-            }\n-\n-            ast::ExprBreak(label) => {\n-                let scope = self.find_scope(expr, label, loop_scopes);\n-                self.break_from_to(expr, scope, in_out);\n-                self.reset(in_out);\n-            }\n-\n-            ast::ExprAgain(label) => {\n-                let scope = self.find_scope(expr, label, loop_scopes);\n-                self.pop_scopes(expr, scope, in_out);\n-                self.add_to_entry_set(scope.loop_id, in_out);\n-                self.reset(in_out);\n-            }\n-\n-            ast::ExprAssign(ref l, ref r) |\n-            ast::ExprAssignOp(_, ref l, ref r) => {\n-                self.walk_expr(&**r, in_out, loop_scopes);\n-                self.walk_expr(&**l, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprVec(ref exprs) => {\n-                self.walk_exprs(exprs.as_slice(), in_out, loop_scopes)\n-            }\n-\n-            ast::ExprRepeat(ref l, ref r) => {\n-                self.walk_expr(&**l, in_out, loop_scopes);\n-                self.walk_expr(&**r, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprStruct(_, ref fields, with_expr) => {\n-                for field in fields.iter() {\n-                    self.walk_expr(&*field.expr, in_out, loop_scopes);\n-                }\n-                self.walk_opt_expr(with_expr, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprCall(ref f, ref args) => {\n-                self.walk_expr(&**f, in_out, loop_scopes);\n-                self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n-            }\n-\n-            ast::ExprMethodCall(_, _, ref args) => {\n-                self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n-            }\n-\n-            ast::ExprIndex(l, r) |\n-            ast::ExprBinary(_, l, r) if self.is_method_call(expr) => {\n-                self.walk_call(expr.id, [l, r], in_out, loop_scopes);\n-            }\n-\n-            ast::ExprUnary(_, e) if self.is_method_call(expr) => {\n-                self.walk_call(expr.id, [e], in_out, loop_scopes);\n-            }\n-\n-            ast::ExprTup(ref exprs) => {\n-                self.walk_exprs(exprs.as_slice(), in_out, loop_scopes);\n-            }\n-\n-            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n-                self.walk_expr(&**l, in_out, loop_scopes);\n-                let temp = in_out.to_owned();\n-                self.walk_expr(&**r, in_out, loop_scopes);\n-                join_bits(&self.dfcx.oper, temp.as_slice(), in_out);\n-            }\n-\n-            ast::ExprIndex(l, r) |\n-            ast::ExprBinary(_, l, r) => {\n-                self.walk_exprs([l, r], in_out, loop_scopes);\n-            }\n-\n-            ast::ExprLit(..) |\n-            ast::ExprPath(..) => {}\n-\n-            ast::ExprAddrOf(_, ref e) |\n-            ast::ExprCast(ref e, _) |\n-            ast::ExprUnary(_, ref e) |\n-            ast::ExprParen(ref e) |\n-            ast::ExprVstore(ref e, _) |\n-            ast::ExprField(ref e, _, _) => {\n-                self.walk_expr(&**e, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprBox(ref s, ref e) => {\n-                self.walk_expr(&**s, in_out, loop_scopes);\n-                self.walk_expr(&**e, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprInlineAsm(ref inline_asm) => {\n-                for &(_, ref expr) in inline_asm.inputs.iter() {\n-                    self.walk_expr(&**expr, in_out, loop_scopes);\n-                }\n-                for &(_, ref expr) in inline_asm.outputs.iter() {\n-                    self.walk_expr(&**expr, in_out, loop_scopes);\n-                }\n-            }\n-\n-            ast::ExprBlock(ref blk) => {\n-                self.walk_block(&**blk, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprMac(..) => {\n-                self.tcx().sess.span_bug(expr.span, \"unexpanded macro\");\n-            }\n-        }\n-\n-        self.dfcx.apply_gen_kill(expr.id, in_out);\n-    }\n-\n-    fn pop_scopes(&mut self,\n-                  from_expr: &ast::Expr,\n-                  to_scope: &mut LoopScope,\n-                  in_out: &mut [uint]) {\n-        //! Whenever you have a `break` or a `loop` statement, flow\n-        //! exits through any number of enclosing scopes on its\n-        //! way to the new destination. This function applies the kill\n-        //! sets of those enclosing scopes to `in_out` (those kill sets\n-        //! concern items that are going out of scope).\n-\n-        let tcx = self.tcx();\n-\n-        debug!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n-               from_expr.repr(tcx), to_scope.loop_id,\n-               bits_to_str(in_out));\n-\n-        let mut id = from_expr.id;\n-        while id != to_scope.loop_id {\n-            self.dfcx.apply_kill(id, in_out);\n-\n-            match tcx.region_maps.opt_encl_scope(id) {\n-                Some(i) => { id = i; }\n-                None => {\n-                    tcx.sess.span_bug(\n-                        from_expr.span,\n-                        format!(\"pop_scopes(from_expr={}, to_scope={:?}) \\\n-                                 to_scope does not enclose from_expr\",\n-                                from_expr.repr(tcx),\n-                                to_scope.loop_id).as_slice());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn break_from_to(&mut self,\n-                     from_expr: &ast::Expr,\n-                     to_scope: &mut LoopScope,\n-                     in_out: &mut [uint]) {\n-        self.pop_scopes(from_expr, to_scope, in_out);\n-        self.dfcx.apply_kill(from_expr.id, in_out);\n-        join_bits(&self.dfcx.oper,\n-                  in_out,\n-                  to_scope.break_bits.as_mut_slice());\n-        debug!(\"break_from_to(from_expr={}, to_scope={}) final break_bits={}\",\n-               from_expr.repr(self.tcx()),\n-               to_scope.loop_id,\n-               bits_to_str(in_out));\n-    }\n-\n-    fn walk_exprs(&mut self,\n-                  exprs: &[Gc<ast::Expr>],\n-                  in_out: &mut [uint],\n-                  loop_scopes: &mut Vec<LoopScope> ) {\n-        for expr in exprs.iter() {\n-            self.walk_expr(&**expr, in_out, loop_scopes);\n-        }\n-    }\n-\n-    fn walk_opt_expr(&mut self,\n-                     opt_expr: Option<Gc<ast::Expr>>,\n-                     in_out: &mut [uint],\n-                     loop_scopes: &mut Vec<LoopScope> ) {\n-        for expr in opt_expr.iter() {\n-            self.walk_expr(&**expr, in_out, loop_scopes);\n-        }\n-    }\n-\n-    fn walk_call(&mut self,\n-                 call_id: ast::NodeId,\n-                 args: &[Gc<ast::Expr>],\n-                 in_out: &mut [uint],\n-                 loop_scopes: &mut Vec<LoopScope> ) {\n-        self.walk_exprs(args, in_out, loop_scopes);\n-\n-        // FIXME(#6268) nested method calls\n-        // self.merge_with_entry_set(in_out);\n-        // self.dfcx.apply_gen_kill(in_out);\n-\n-        let return_ty = ty::node_id_to_type(self.tcx(), call_id);\n-        let fails = ty::type_is_bot(return_ty);\n-        if fails {\n-            self.reset(in_out);\n-        }\n-    }\n-\n-    fn walk_pat(&mut self,\n-                pat: Gc<ast::Pat>,\n-                in_out: &mut [uint],\n-                _loop_scopes: &mut Vec<LoopScope> ) {\n-        debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n-               pat.repr(self.dfcx.tcx), bits_to_str(in_out));\n-\n-        ast_util::walk_pat(&*pat, |p| {\n-            debug!(\"  p.id={} in_out={}\", p.id, bits_to_str(in_out));\n-            self.merge_with_entry_set(p.id, in_out);\n-            self.dfcx.apply_gen_kill(p.id, in_out);\n-            true\n+    fn walk_cfg(&mut self,\n+                cfg: &cfg::CFG,\n+                in_out: &mut [uint]) {\n+        debug!(\"DataFlowContext::walk_cfg(in_out={}) {:s}\",\n+               bits_to_str(in_out), self.dfcx.analysis_name);\n+        cfg.graph.each_node(|node_index, node| {\n+            debug!(\"DataFlowContext::walk_cfg idx={} id={} begin in_out={}\",\n+                   node_index, node.data.id, bits_to_str(in_out));\n+\n+            let (start, end) = self.dfcx.compute_id_range(node_index);\n+\n+            // Initialize local bitvector with state on-entry.\n+            in_out.copy_from(self.dfcx.on_entry.slice(start, end));\n+\n+            // Compute state on-exit by applying transfer function to\n+            // state on-entry.\n+            self.dfcx.apply_gen_kill(node_index, in_out);\n+\n+            // Propagate state on-exit from node into its successors.\n+            self.propagate_bits_into_graph_successors_of(in_out, cfg, node_index);\n+            true // continue to next node\n         });\n     }\n \n-    fn walk_pat_alternatives(&mut self,\n-                             pats: &[Gc<ast::Pat>],\n-                             in_out: &mut [uint],\n-                             loop_scopes: &mut Vec<LoopScope> ) {\n-        if pats.len() == 1 {\n-            // Common special case:\n-            return self.walk_pat(pats[0], in_out, loop_scopes);\n-        }\n-\n-        // In the general case, the patterns in `pats` are\n-        // alternatives, so we must treat this like an N-way select\n-        // statement.\n-        let initial_state = in_out.to_owned();\n-        for &pat in pats.iter() {\n-            let mut temp = initial_state.clone();\n-            self.walk_pat(pat, temp.as_mut_slice(), loop_scopes);\n-            join_bits(&self.dfcx.oper, temp.as_slice(), in_out);\n-        }\n-    }\n-\n-    fn find_scope<'a,'b>(\n-                  &self,\n-                  expr: &ast::Expr,\n-                  label: Option<ast::Ident>,\n-                  loop_scopes: &'a mut Vec<LoopScope<'b>>)\n-                  -> &'a mut LoopScope<'b> {\n-        let index = match label {\n-            None => {\n-                let len = loop_scopes.len();\n-                len - 1\n-            }\n-\n-            Some(_) => {\n-                match self.tcx().def_map.borrow().find(&expr.id) {\n-                    Some(&def::DefLabel(loop_id)) => {\n-                        match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n-                            Some(i) => i,\n-                            None => {\n-                                self.tcx().sess.span_bug(\n-                                    expr.span,\n-                                    format!(\"no loop scope for id {:?}\",\n-                                            loop_id).as_slice());\n-                            }\n-                        }\n-                    }\n-\n-                    r => {\n-                        self.tcx().sess.span_bug(\n-                            expr.span,\n-                            format!(\"bad entry `{:?}` in def_map for label\",\n-                                    r).as_slice());\n-                    }\n-                }\n-            }\n-        };\n-\n-        loop_scopes.get_mut(index)\n-    }\n-\n-    fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_call = typeck::MethodCall::expr(expr.id);\n-        self.dfcx.tcx.method_map.borrow().contains_key(&method_call)\n-    }\n-\n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n         for b in bits.mut_iter() {\n             *b = e;\n         }\n     }\n \n-    fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n-        debug!(\"add_to_entry_set(id={:?}, pred_bits={})\",\n-               id, bits_to_str(pred_bits));\n-        let (start, end) = self.dfcx.compute_id_range(id);\n-        let changed = { // FIXME(#5074) awkward construction\n-            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n-            join_bits(&self.dfcx.oper, pred_bits, on_entry)\n-        };\n-        if changed {\n-            debug!(\"changed entry set for {:?} to {}\",\n-                   id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n-            self.changed = true;\n-        }\n+    fn propagate_bits_into_graph_successors_of(&mut self,\n+                                               pred_bits: &[uint],\n+                                               cfg: &cfg::CFG,\n+                                               cfgidx: CFGIndex) {\n+        cfg.graph.each_outgoing_edge(cfgidx, |_e_idx, edge| {\n+            self.propagate_bits_into_entry_set_for(pred_bits, edge);\n+            true\n+        });\n     }\n \n-    fn merge_with_entry_set(&mut self,\n-                            id: ast::NodeId,\n-                            pred_bits: &mut [uint]) {\n-        debug!(\"merge_with_entry_set(id={:?}, pred_bits={})\",\n-               id, mut_bits_to_str(pred_bits));\n-        let (start, end) = self.dfcx.compute_id_range(id);\n-        let changed = { // FIXME(#5074) awkward construction\n+    fn propagate_bits_into_entry_set_for(&mut self,\n+                                         pred_bits: &[uint],\n+                                         edge: &cfg::CFGEdge) {\n+        let source = edge.source();\n+        let cfgidx = edge.target();\n+        debug!(\"{:s} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n+               self.dfcx.analysis_name, bits_to_str(pred_bits), source, cfgidx);\n+        let (start, end) = self.dfcx.compute_id_range(cfgidx);\n+        let changed = {\n+            // (scoping mutable borrow of self.dfcx.on_entry)\n             let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n-            let changed = join_bits(&self.dfcx.oper, pred_bits, on_entry);\n-            copy_bits(on_entry, pred_bits);\n-            changed\n+            bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n-            debug!(\"changed entry set for {:?} to {}\",\n-                   id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n+            debug!(\"{:s} changed entry set for {:?} to {}\",\n+                   self.dfcx.analysis_name, cfgidx,\n+                   bits_to_str(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n     }\n@@ -855,24 +575,15 @@ fn bits_to_str(words: &[uint]) -> String {\n     return result\n }\n \n-fn copy_bits(in_vec: &[uint], out_vec: &mut [uint]) -> bool {\n-    bitwise(out_vec, in_vec, |_, b| b)\n-}\n-\n-fn join_bits<O:DataFlowOperator>(oper: &O,\n-                                 in_vec: &[uint],\n-                                 out_vec: &mut [uint]) -> bool {\n-    bitwise(out_vec, in_vec, |a, b| oper.join(a, b))\n-}\n-\n #[inline]\n-fn bitwise(out_vec: &mut [uint], in_vec: &[uint], op: |uint, uint| -> uint)\n-           -> bool {\n+fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n+                               in_vec: &[uint],\n+                               op: &Op) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n     for (out_elt, in_elt) in out_vec.mut_iter().zip(in_vec.iter()) {\n         let old_val = *out_elt;\n-        let new_val = op(old_val, *in_elt);\n+        let new_val = op.join(old_val, *in_elt);\n         *out_elt = new_val;\n         changed |= old_val != new_val;\n     }\n@@ -897,3 +608,12 @@ fn bit_str(bit: uint) -> String {\n     let lobits = 1 << (bit & 0xFF);\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n+\n+struct Union;\n+impl BitwiseOperator for Union {\n+    fn join(&self, a: uint, b: uint) -> uint { a | b }\n+}\n+struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    fn join(&self, a: uint, b: uint) -> uint { a & !b }\n+}"}, {"sha": "ad058ab6b5f1d1afdf2a703619c2803c97c6be24", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=75340f41763c4166172af24c8db676c1da97910d", "patch": "@@ -186,24 +186,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(expr.id, expr.span, cmt);\n-\n-        match expr.node {\n-            ast::ExprParen(ref subexpr) => {\n-                // Argh but is ExprParen horrible. So, if we consume\n-                // `(x)`, that generally is also consuming `x`, UNLESS\n-                // there are adjustments on the `(x)` expression\n-                // (e.g., autoderefs and autorefs).\n-                if self.typer.adjustments().borrow().contains_key(&expr.id) {\n-                    self.walk_expr(expr);\n-                } else {\n-                    self.consume_expr(&**subexpr);\n-                }\n-            }\n-\n-            _ => {\n-                self.walk_expr(expr)\n-            }\n-        }\n+        self.walk_expr(expr);\n     }\n \n     fn mutate_expr(&mut self,"}, {"sha": "b1f9b0bff9fd280310337dbb60df83a213b9c17f", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75340f41763c4166172af24c8db676c1da97910d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=75340f41763c4166172af24c8db676c1da97910d", "patch": "@@ -55,7 +55,7 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n-#[deriving(PartialEq, Show)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct NodeIndex(pub uint);\n pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n "}]}