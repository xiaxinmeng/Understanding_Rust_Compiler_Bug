{"sha": "06fa3d8389c833b01f482bf35b0f850e627612b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZmEzZDgzODljODMzYjAxZjQ4MmJmMzViMGY4NTBlNjI3NjEyYjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-20T11:22:06Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-20T11:22:38Z"}, "message": "Move traits to hir_def", "tree": {"sha": "cec2d13fdf65bbc4d4cef9f3c1118afc7f264803", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cec2d13fdf65bbc4d4cef9f3c1118afc7f264803"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06fa3d8389c833b01f482bf35b0f850e627612b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06fa3d8389c833b01f482bf35b0f850e627612b9", "html_url": "https://github.com/rust-lang/rust/commit/06fa3d8389c833b01f482bf35b0f850e627612b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06fa3d8389c833b01f482bf35b0f850e627612b9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d56e3d85516fe9061aea84571ac88c3322a687c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d56e3d85516fe9061aea84571ac88c3322a687c", "html_url": "https://github.com/rust-lang/rust/commit/3d56e3d85516fe9061aea84571ac88c3322a687c"}], "stats": {"total": 220, "additions": 103, "deletions": 117}, "files": [{"sha": "f436d5d5e576a26664d2ef78d99119019a81dc08", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "patch": "@@ -10,8 +10,9 @@ use hir_def::{\n     adt::VariantData,\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n+    traits::TraitData,\n     type_ref::{Mutability, TypeRef},\n-    CrateModuleId, ImplId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n+    AssocItemId, CrateModuleId, ImplId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -30,7 +31,6 @@ use crate::{\n         TypeAliasId,\n     },\n     resolve::{Resolver, Scope, TypeNs},\n-    traits::TraitData,\n     ty::{InferenceResult, Namespace, TraitRef},\n     Either, HasSource, ImportId, Name, ScopeDef, Source, Ty,\n };\n@@ -230,15 +230,7 @@ impl Module {\n \n     pub fn declarations(self, db: &impl DefDatabase) -> Vec<ModuleDef> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.module_id]\n-            .scope\n-            .entries()\n-            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n-            .flat_map(|per_ns| {\n-                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n-            })\n-            .map(ModuleDef::from)\n-            .collect()\n+        def_map[self.id.module_id].scope.declarations().map(ModuleDef::from).collect()\n     }\n \n     pub fn impl_blocks(self, db: &impl DefDatabase) -> Vec<ImplBlock> {\n@@ -693,7 +685,7 @@ impl Function {\n \n     /// The containing trait, if this is a trait method definition.\n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n+        db.trait_items_index(self.module(db).id).get_parent_trait(self.id.into()).map(Trait::from)\n     }\n \n     pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n@@ -757,7 +749,7 @@ impl Const {\n     }\n \n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n+        db.trait_items_index(self.module(db).id).get_parent_trait(self.id.into()).map(Trait::from)\n     }\n \n     pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n@@ -861,11 +853,11 @@ impl Trait {\n     }\n \n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n-        self.trait_data(db).name().clone()\n+        self.trait_data(db).name.clone()\n     }\n \n     pub fn items(self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        self.trait_data(db).items().to_vec()\n+        self.trait_data(db).items.iter().map(|it| (*it).into()).collect()\n     }\n \n     fn direct_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n@@ -912,10 +904,10 @@ impl Trait {\n     pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n         let trait_data = self.trait_data(db);\n         trait_data\n-            .items()\n+            .items\n             .iter()\n             .filter_map(|item| match item {\n-                AssocItem::TypeAlias(t) => Some(*t),\n+                AssocItemId::TypeAliasId(t) => Some(TypeAlias::from(*t)),\n                 _ => None,\n             })\n             .find(|t| &t.name(db) == name)\n@@ -930,15 +922,15 @@ impl Trait {\n     }\n \n     pub(crate) fn trait_data(self, db: &impl DefDatabase) -> Arc<TraitData> {\n-        db.trait_data(self)\n+        db.trait_data(self.id)\n     }\n \n     pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {\n         TraitRef::for_trait(db, self)\n     }\n \n     pub fn is_auto(self, db: &impl DefDatabase) -> bool {\n-        self.trait_data(db).is_auto()\n+        self.trait_data(db).auto\n     }\n \n     pub(crate) fn resolver(self, db: &impl DefDatabase) -> Resolver {\n@@ -971,7 +963,7 @@ impl TypeAlias {\n \n     /// The containing trait, if this is a trait method definition.\n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db)).get_parent_trait(self.into())\n+        db.trait_items_index(self.module(db).id).get_parent_trait(self.id.into()).map(Trait::from)\n     }\n \n     pub fn container(self, db: &impl DefDatabase) -> Option<Container> {"}, {"sha": "73859e1e94d4ae59bb4a92d81eafc975373af07d", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "patch": "@@ -11,7 +11,6 @@ use crate::{\n     generics::{GenericDef, GenericParams},\n     ids,\n     lang_item::{LangItemTarget, LangItems},\n-    traits::TraitData,\n     ty::{\n         method_resolution::CrateImplBlocks,\n         traits::{AssocTyValue, Impl},\n@@ -26,7 +25,8 @@ use crate::{\n pub use hir_def::db::{\n     BodyQuery, BodyWithSourceMapQuery, CrateDefMapQuery, DefDatabase2, DefDatabase2Storage,\n     EnumDataQuery, ExprScopesQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n-    RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n+    RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery, TraitDataQuery,\n+    TraitItemsIndexQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -37,12 +37,6 @@ pub use hir_expand::db::{\n #[salsa::query_group(DefDatabaseStorage)]\n #[salsa::requires(AstDatabase)]\n pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n-    #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n-    fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n-\n-    #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n-    fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n-\n     #[salsa::invoke(crate::generics::generic_params_query)]\n     fn generic_params(&self, def: GenericDef) -> Arc<GenericParams>;\n "}, {"sha": "7ac9a904146996e2d1cc1fe423774277598d9e30", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "patch": "@@ -33,7 +33,6 @@ pub mod source_binder;\n \n mod ids;\n mod adt;\n-mod traits;\n mod type_alias;\n mod ty;\n mod impl_block;"}, {"sha": "858972c6fea94ef250239a607a06feb707b1334e", "filename": "crates/ra_hir/src/traits.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3d56e3d85516fe9061aea84571ac88c3322a687c/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d56e3d85516fe9061aea84571ac88c3322a687c/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=3d56e3d85516fe9061aea84571ac88c3322a687c", "patch": "@@ -1,82 +0,0 @@\n-//! HIR for trait definitions.\n-\n-use std::sync::Arc;\n-\n-use hir_expand::name::AsName;\n-\n-use ra_syntax::ast::{self, NameOwner};\n-use rustc_hash::FxHashMap;\n-\n-use crate::{\n-    db::{AstDatabase, DefDatabase},\n-    ids::LocationCtx,\n-    AssocItem, Const, Function, HasSource, Module, Name, Trait, TypeAlias,\n-};\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TraitData {\n-    name: Option<Name>,\n-    items: Vec<AssocItem>,\n-    auto: bool,\n-}\n-\n-impl TraitData {\n-    pub(crate) fn trait_data_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        tr: Trait,\n-    ) -> Arc<TraitData> {\n-        let src = tr.source(db);\n-        let name = src.value.name().map(|n| n.as_name());\n-        let module = tr.module(db);\n-        let ctx = LocationCtx::new(db, module.id, src.file_id);\n-        let auto = src.value.is_auto();\n-        let items = if let Some(item_list) = src.value.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItem::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-        Arc::new(TraitData { name, items, auto })\n-    }\n-\n-    pub(crate) fn name(&self) -> &Option<Name> {\n-        &self.name\n-    }\n-\n-    pub(crate) fn items(&self) -> &[AssocItem] {\n-        &self.items\n-    }\n-\n-    pub(crate) fn is_auto(&self) -> bool {\n-        self.auto\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct TraitItemsIndex {\n-    traits_by_def: FxHashMap<AssocItem, Trait>,\n-}\n-\n-impl TraitItemsIndex {\n-    pub(crate) fn trait_items_index(db: &impl DefDatabase, module: Module) -> TraitItemsIndex {\n-        let mut index = TraitItemsIndex { traits_by_def: FxHashMap::default() };\n-        for decl in module.declarations(db) {\n-            if let crate::ModuleDef::Trait(tr) = decl {\n-                for item in tr.trait_data(db).items() {\n-                    index.traits_by_def.insert(*item, tr);\n-                }\n-            }\n-        }\n-        index\n-    }\n-\n-    pub(crate) fn get_parent_trait(&self, item: AssocItem) -> Option<Trait> {\n-        self.traits_by_def.get(&item).cloned()\n-    }\n-}"}, {"sha": "f377fca48a69fbe7874107a46735e0897047ed18", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "patch": "@@ -232,8 +232,8 @@ fn iterate_trait_method_candidates<T>(\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n         let mut known_implemented = false;\n-        for &item in data.items() {\n-            if !is_valid_candidate(db, name, mode, item) {\n+        for &item in data.items.iter() {\n+            if !is_valid_candidate(db, name, mode, item.into()) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -243,7 +243,7 @@ fn iterate_trait_method_candidates<T>(\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&ty.value, item) {\n+            if let Some(result) = callback(&ty.value, item.into()) {\n                 return Some(result);\n             }\n         }"}, {"sha": "fb4402463c3a7f119e832be2c1559097f07c3ac8", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "patch": "@@ -8,12 +8,13 @@ use ra_syntax::ast;\n use crate::{\n     adt::{EnumData, StructData},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n-    imp::ImplData,\n+    impls::ImplData,\n     nameres::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    DefWithBodyId, EnumId, ImplId, ItemLoc, StructOrUnionId,\n+    traits::{TraitData, TraitItemsIndex},\n+    DefWithBodyId, EnumId, ImplId, ItemLoc, ModuleId, StructOrUnionId, TraitId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -59,6 +60,12 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     #[salsa::invoke(ImplData::impl_data_query)]\n     fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n \n+    #[salsa::invoke(TraitData::trait_data_query)]\n+    fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n+\n+    #[salsa::invoke(TraitItemsIndex::trait_items_index)]\n+    fn trait_items_index(&self, module: ModuleId) -> TraitItemsIndex;\n+\n     #[salsa::invoke(Body::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n "}, {"sha": "4323dfcb69025719320fea284442844877e78633", "filename": "crates/ra_hir_def/src/impls.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "previous_filename": "crates/ra_hir_def/src/imp.rs"}, {"sha": "38c110570c5fe36ccdf9c711ec9fb7d23d762482", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "patch": "@@ -13,11 +13,12 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n-pub mod imp;\n+pub mod impls;\n pub mod diagnostics;\n pub mod expr;\n pub mod body;\n pub mod generics;\n+pub mod traits;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "c01e020ef12e00b6d8789019c778edf9938162ce", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "patch": "@@ -165,6 +165,14 @@ impl ModuleScope {\n         self.items.iter().chain(BUILTIN_SCOPE.iter())\n     }\n \n+    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n+        self.entries()\n+            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n+            .flat_map(|per_ns| {\n+                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n+            })\n+    }\n+\n     /// Iterate over all module scoped macros\n     pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n         self.items"}, {"sha": "a8ba31594f3afecd82fd9edb6592ed4b3bf547c2", "filename": "crates/ra_hir_def/src/traits.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fa3d8389c833b01f482bf35b0f850e627612b9/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs?ref=06fa3d8389c833b01f482bf35b0f850e627612b9", "patch": "@@ -0,0 +1,67 @@\n+//! HIR for trait definitions.\n+\n+use std::sync::Arc;\n+\n+use hir_expand::name::{AsName, Name};\n+\n+use ra_syntax::ast::{self, NameOwner};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    db::DefDatabase2, AssocItemId, AstItemDef, ConstId, FunctionId, LocationCtx, ModuleDefId,\n+    ModuleId, TraitId, TypeAliasId,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    pub name: Option<Name>,\n+    pub items: Vec<AssocItemId>,\n+    pub auto: bool,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &impl DefDatabase2, tr: TraitId) -> Arc<TraitData> {\n+        let src = tr.source(db);\n+        let name = src.value.name().map(|n| n.as_name());\n+        let module = tr.module(db);\n+        let ctx = LocationCtx::new(db, module, src.file_id);\n+        let auto = src.value.is_auto();\n+        let items = if let Some(item_list) = src.value.item_list() {\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => FunctionId::from_ast(ctx, &it).into(),\n+                    ast::ImplItem::ConstDef(it) => ConstId::from_ast(ctx, &it).into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAliasId::from_ast(ctx, &it).into(),\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TraitData { name, items, auto })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitItemsIndex {\n+    traits_by_def: FxHashMap<AssocItemId, TraitId>,\n+}\n+\n+impl TraitItemsIndex {\n+    pub fn trait_items_index(db: &impl DefDatabase2, module: ModuleId) -> TraitItemsIndex {\n+        let mut index = TraitItemsIndex { traits_by_def: FxHashMap::default() };\n+        let crate_def_map = db.crate_def_map(module.krate);\n+        for decl in crate_def_map[module.module_id].scope.declarations() {\n+            if let ModuleDefId::TraitId(tr) = decl {\n+                for item in db.trait_data(tr).items.iter() {\n+                    index.traits_by_def.insert(*item, tr);\n+                }\n+            }\n+        }\n+        index\n+    }\n+\n+    pub fn get_parent_trait(&self, item: AssocItemId) -> Option<TraitId> {\n+        self.traits_by_def.get(&item).cloned()\n+    }\n+}"}]}