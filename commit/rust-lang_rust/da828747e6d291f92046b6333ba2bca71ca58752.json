{"sha": "da828747e6d291f92046b6333ba2bca71ca58752", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhODI4NzQ3ZTZkMjkxZjkyMDQ2YjYzMzNiYTJiY2E3MWNhNTg3NTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-18T23:42:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-19T01:20:46Z"}, "message": "correct use of GEP_tup_like in closure constr\n\nalso, streamline type_is_tup_like() to the cases which\nactually work", "tree": {"sha": "4e61884e546f97e6c5662646f1c2cd380d4e1fa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e61884e546f97e6c5662646f1c2cd380d4e1fa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da828747e6d291f92046b6333ba2bca71ca58752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da828747e6d291f92046b6333ba2bca71ca58752", "html_url": "https://github.com/rust-lang/rust/commit/da828747e6d291f92046b6333ba2bca71ca58752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da828747e6d291f92046b6333ba2bca71ca58752/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2286d8c17e5bf3d4312357eba9a845262068f007", "url": "https://api.github.com/repos/rust-lang/rust/commits/2286d8c17e5bf3d4312357eba9a845262068f007", "html_url": "https://github.com/rust-lang/rust/commit/2286d8c17e5bf3d4312357eba9a845262068f007"}], "stats": {"total": 94, "additions": 66, "deletions": 28}, "files": [{"sha": "16148c360a5810c27c97fb58b518152c46e7b4b9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da828747e6d291f92046b6333ba2bca71ca58752/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da828747e6d291f92046b6333ba2bca71ca58752/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=da828747e6d291f92046b6333ba2bca71ca58752", "patch": "@@ -691,6 +691,9 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n     : type_is_tup_like(bcx, t) -> result {\n     // It might be a static-known type. Handle this.\n     if !ty::type_has_dynamic_size(bcx_tcx(bcx), t) {\n+        #debug[\"GEP_tup_like t=%? ixs=%? -> static\",\n+               ty_to_str(bcx_tcx(bcx), t), ixs];\n+\n         ret rslt(bcx, GEPi(bcx, base, ixs));\n     }\n     // It is a dynamic-containing type that, if we convert directly to an LLVM\n@@ -758,6 +761,10 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n     for typ: ty::t in s.prefix { args += [typ]; }\n     let prefix_ty = ty::mk_tup(bcx_tcx(bcx), args);\n \n+    #debug[\"GEP_tup_like t=%? ixs=%? prefix_ty=%?\",\n+           ty_to_str(bcx_tcx(bcx), t), ixs,\n+           ty_to_str(bcx_tcx(bcx), prefix_ty)];\n+\n     let sz = size_of_(bcx, prefix_ty, align_next(s.target));\n     ret rslt(sz.bcx, bump_ptr(sz.bcx, s.target, base, sz.val));\n }"}, {"sha": "7c12f223a2f90f7f45bb7575e3f9003f7bacd405", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/da828747e6d291f92046b6333ba2bca71ca58752/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da828747e6d291f92046b6333ba2bca71ca58752/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=da828747e6d291f92046b6333ba2bca71ca58752", "patch": "@@ -261,7 +261,7 @@ fn allocate_cbox(bcx: @block_ctxt,\n \n type closure_result = {\n     llbox: ValueRef,     // llvalue of ptr to closure\n-    cboxptr_ty: ty::t,   // type of ptr to closure\n+    cbox_ty: ty::t,      // type of the closure data\n     bcx: @block_ctxt     // final bcx\n };\n \n@@ -332,12 +332,12 @@ fn store_environment(\n     // whatever.\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n     let llbox = cast_if_we_can(bcx, llbox, cboxptr_ty);\n-    check type_is_tup_like(bcx, cboxptr_ty);\n+    check type_is_tup_like(bcx, cbox_ty);\n \n     // If necessary, copy tydescs describing type parameters into the\n     // appropriate slot in the closure.\n     let {bcx:bcx, val:ty_params_slot} =\n-        GEP_tup_like_1(bcx, cboxptr_ty, llbox, [0, abi::cbox_elt_ty_params]);\n+        GEP_tup_like(bcx, cbox_ty, llbox, [0, abi::cbox_elt_ty_params]);\n     let off = 0;\n     for tp in lltyparams {\n         let cloned_td = maybe_clone_tydesc(bcx, ck, tp.desc);\n@@ -354,15 +354,16 @@ fn store_environment(\n \n     // Copy expr values into boxed bindings.\n     // Silly check\n-    let {bcx: bcx, val:bindings_slot} =\n-        GEP_tup_like_1(bcx, cboxptr_ty, llbox, [0, abi::cbox_elt_bindings]);\n     vec::iteri(bound_values) { |i, bv|\n         if (!ccx.sess.opts.no_asm_comments) {\n             add_comment(bcx, #fmt(\"Copy %s into closure\",\n                                   ev_to_str(ccx, bv)));\n         }\n \n-        let bound_data = GEPi(bcx, bindings_slot, [0, i as int]);\n+        let bound_data = GEP_tup_like_1(bcx, cbox_ty, llbox,\n+                                        [0, abi::cbox_elt_bindings, i as int]);\n+        bcx = bound_data.bcx;\n+        let bound_data = bound_data.val;\n         alt bv {\n           env_expr(e) {\n             bcx = trans::trans_expr_save_in(bcx, e, bound_data);\n@@ -397,7 +398,7 @@ fn store_environment(\n     }\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n \n-    ret {llbox: llbox, cboxptr_ty: cboxptr_ty, bcx: bcx};\n+    ret {llbox: llbox, cbox_ty: cbox_ty, bcx: bcx};\n }\n \n // Given a context and a list of upvars, build a closure. This just\n@@ -441,13 +442,15 @@ fn build_closure(bcx0: @block_ctxt,\n // with the upvars and type descriptors.\n fn load_environment(enclosing_cx: @block_ctxt,\n                     fcx: @fn_ctxt,\n-                    cboxptr_ty: ty::t,\n+                    cbox_ty: ty::t,\n                     cap_vars: [capture::capture_var],\n                     ck: ty::closure_kind) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n     let ccx = bcx_ccx(bcx);\n+    let tcx = bcx_tcx(bcx);\n \n     let sp = bcx.sp;\n+    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n     check (type_has_static_size(ccx, cboxptr_ty));\n     let llty = type_of(ccx, sp, cboxptr_ty);\n     let llclosure = PointerCast(bcx, fcx.llenv, llty);\n@@ -479,9 +482,9 @@ fn load_environment(enclosing_cx: @block_ctxt,\n         alt cap_var.mode {\n           capture::cap_drop. { /* ignore */ }\n           _ {\n-            check type_is_tup_like(bcx, cboxptr_ty);\n+            check type_is_tup_like(bcx, cbox_ty);\n             let upvarptr = GEP_tup_like(\n-                bcx, cboxptr_ty, llclosure, path + [i as int]);\n+                bcx, cbox_ty, llclosure, path + [i as int]);\n             bcx = upvarptr.bcx;\n             let llupvarptr = upvarptr.val;\n             alt ck {\n@@ -516,9 +519,9 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     let trans_closure_env = fn@(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n-        let {llbox, cboxptr_ty, bcx} = build_closure(bcx, cap_vars, ck);\n+        let {llbox, cbox_ty, bcx} = build_closure(bcx, cap_vars, ck);\n         trans_closure(sub_cx, sp, decl, body, llfn, no_self, [], id, {|fcx|\n-            load_environment(bcx, fcx, cboxptr_ty, cap_vars, ck);\n+            load_environment(bcx, fcx, cbox_ty, cap_vars, ck);\n         });\n         llbox\n     };\n@@ -616,15 +619,15 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     };\n \n     // Actually construct the closure\n-    let {llbox, cboxptr_ty, bcx} = store_environment(\n+    let {llbox, cbox_ty, bcx} = store_environment(\n         bcx, vec::map(lltydescs, {|d| {desc: d, dicts: none}}),\n         env_vals + vec::map(bound, {|x| env_expr(x)}),\n         ty::ck_box);\n \n     // Make thunk\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n-                         cboxptr_ty, *param_bounds, target_res);\n+                         cbox_ty, *param_bounds, target_res);\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n@@ -782,7 +785,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,\n                     args: [option::t<@ast::expr>],\n-                    cboxptr_ty: ty::t,\n+                    cbox_ty: ty::t,\n                     param_bounds: [ty::param_bounds],\n                     target_fn: option::t<ValueRef>)\n     -> {val: ValueRef, ty: TypeRef} {\n@@ -794,6 +797,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     */\n     // but since we don't, we have to do the checks at the beginning.\n     let ccx = cx.ccx;\n+    let tcx = ccx_tcx(ccx);\n     check type_has_static_size(ccx, incoming_fty);\n \n     // Here we're not necessarily constructing a thunk in the sense of\n@@ -838,7 +842,8 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // to the original function.  So, let's create one of those:\n \n     // The llenv pointer needs to be the correct size.  That size is\n-    // 'cboxptr_ty', which was determined by trans_bind.\n+    // 'cbox_ty', which was determined by trans_bind.\n+    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n     check type_has_static_size(ccx, cboxptr_ty);\n     let llclosure_ptr_ty = type_of(ccx, sp, cboxptr_ty);\n     let llclosure = PointerCast(l_bcx, fcx.llenv, llclosure_ptr_ty);\n@@ -854,9 +859,9 @@ fn trans_bind_thunk(cx: @local_ctxt,\n       }\n       none. {\n         // Silly check\n-        check type_is_tup_like(bcx, cboxptr_ty);\n+        check type_is_tup_like(bcx, cbox_ty);\n         let {bcx: cx, val: pair} =\n-            GEP_tup_like(bcx, cboxptr_ty, llclosure,\n+            GEP_tup_like(bcx, cbox_ty, llclosure,\n                          [0, abi::cbox_elt_bindings, 0]);\n         let lltargetenv =\n             Load(cx, GEPi(cx, pair, [0, abi::fn_field_box]));\n@@ -891,9 +896,9 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let llargs: [ValueRef] = [llretptr, lltargetenv];\n \n     // Copy in the type parameters.\n-    check type_is_tup_like(l_bcx, cboxptr_ty);\n+    check type_is_tup_like(l_bcx, cbox_ty);\n     let {bcx: l_bcx, val: param_record} =\n-        GEP_tup_like(l_bcx, cboxptr_ty, llclosure,\n+        GEP_tup_like(l_bcx, cbox_ty, llclosure,\n                      [0, abi::cbox_elt_ty_params]);\n     let off = 0;\n     for param in param_bounds {\n@@ -932,9 +937,9 @@ fn trans_bind_thunk(cx: @local_ctxt,\n           // closure.\n           some(e) {\n             // Silly check\n-            check type_is_tup_like(bcx, cboxptr_ty);\n+            check type_is_tup_like(bcx, cbox_ty);\n             let bound_arg =\n-                GEP_tup_like(bcx, cboxptr_ty, llclosure,\n+                GEP_tup_like(bcx, cbox_ty, llclosure,\n                              [0, abi::cbox_elt_bindings, b]);\n             bcx = bound_arg.bcx;\n             let val = bound_arg.val;"}, {"sha": "fee19a7b660a3481bcc57f0cf391a3eea5aba929", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da828747e6d291f92046b6333ba2bca71ca58752/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da828747e6d291f92046b6333ba2bca71ca58752/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=da828747e6d291f92046b6333ba2bca71ca58752", "patch": "@@ -859,8 +859,7 @@ fn sequence_element_type(cx: ctxt, ty: t) -> t {\n pure fn type_is_tup_like(cx: ctxt, ty: t) -> bool {\n     let sty = struct(cx, ty);\n     alt sty {\n-      ty_ptr(_) | ty_uniq(_) |\n-      ty_box(_) | ty_rec(_) | ty_tup(_) | ty_tag(_,_) { true }\n+      ty_rec(_) | ty_tup(_) { true }\n       _ { false }\n     }\n }\n@@ -871,12 +870,9 @@ fn get_element_type(cx: ctxt, ty: t, i: uint) -> t {\n       ty_tup(ts) { ret ts[i]; }\n       _ {\n         cx.sess.bug(\"get_element_type called on type \" + ty_to_str(cx, ty) +\n-                        \" - expected a \\\n-            tuple or record\");\n+                        \" - expected a tuple or record\");\n       }\n     }\n-    // NB: This is not exhaustive -- struct(cx, ty) could be a box or a\n-    // tag.\n }\n \n pure fn type_is_box(cx: ctxt, ty: t) -> bool {"}, {"sha": "0e25b86c90de29afbe1d61d6a07a517fd5c03afd", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da828747e6d291f92046b6333ba2bca71ca58752/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da828747e6d291f92046b6333ba2bca71ca58752/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=da828747e6d291f92046b6333ba2bca71ca58752", "patch": "@@ -0,0 +1,14 @@\n+type pair<A,B> = {\n+    a: A, b: B\n+};\n+\n+fn f<A:copy>(a: A, b: u16) -> fn@() -> (A, u16) {\n+    fn@() -> (A, u16) { (a, b) }\n+}\n+\n+fn main() {\n+    let (a, b) = f(22_u64, 44u16)();\n+    #debug[\"a=%? b=%?\", a, b];\n+    assert a == 22u64;\n+    assert b == 44u16;\n+}\n\\ No newline at end of file"}, {"sha": "3de5c2bc1e926999e1f507dd549fe457865cb349", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da828747e6d291f92046b6333ba2bca71ca58752/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da828747e6d291f92046b6333ba2bca71ca58752/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=da828747e6d291f92046b6333ba2bca71ca58752", "patch": "@@ -0,0 +1,16 @@\n+type pair<A,B> = {\n+    a: A, b: B\n+};\n+\n+fn f<A:send,B:send>(a: A, b: B) -> fn~() -> (A, B) {\n+    fn~() -> (A, B) { (a, b) }\n+}\n+\n+fn main() {\n+    let x = 22_u8;\n+    let y = 44_u64;\n+    let (a, b) = f(~x, ~y)();\n+    #debug[\"a=%? b=%?\", *a, *b];\n+    assert *a == x;\n+    assert *b == y;\n+}\n\\ No newline at end of file"}]}