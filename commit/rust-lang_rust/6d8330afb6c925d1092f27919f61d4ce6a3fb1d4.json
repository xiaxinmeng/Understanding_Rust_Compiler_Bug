{"sha": "6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkODMzMGFmYjZjOTI1ZDEwOTJmMjc5MTlmNjFkNGNlNmEzZmIxZDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-17T08:40:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-19T16:43:31Z"}, "message": "Use __morestack to detect stack overflow\n\nThis commit resumes management of the stack boundaries and limits when switching\nbetween tasks. This additionally leverages the __morestack function to run code\non \"stack overflow\". The current behavior is to abort the process, but this is\nprobably not the best behavior in the long term (for deails, see the comment I\nwrote up in the stack exhaustion routine).", "tree": {"sha": "72a6ff826ffcd13afe10a79cc4a4a78384cf2f16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72a6ff826ffcd13afe10a79cc4a4a78384cf2f16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "html_url": "https://github.com/rust-lang/rust/commit/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d773a024a2976f2759235551a52101cd08b37cce", "url": "https://api.github.com/repos/rust-lang/rust/commits/d773a024a2976f2759235551a52101cd08b37cce", "html_url": "https://github.com/rust-lang/rust/commit/d773a024a2976f2759235551a52101cd08b37cce"}], "stats": {"total": 2051, "additions": 500, "deletions": 1551}, "files": [{"sha": "7ba8f77ef980eb348a0faacafbf2c434823788e0", "filename": "mk/platform.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -507,7 +507,8 @@ define CFG_MAKE_TOOLCHAIN\n \n   # For the ARM and MIPS crosses, use the toolchain assembler\n   # XXX: We should be able to use the LLVM assembler\n-  CFG_ASSEMBLE_$(1)=$$(CC_$(1)) $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)\n+  CFG_ASSEMBLE_$(1)=$$(CC_$(1)) $$(CFG_GCCISH_CFLAGS_$(1)) \\\n+\t\t    $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)\n \n   endif\n "}, {"sha": "8a11d3553f45840d6127d5574a4709600da9f77d", "filename": "mk/rt.mk", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -91,8 +91,6 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/miniz.cpp \\\n               rt/memory_region.cpp \\\n               rt/boxed_region.cpp \\\n-              rt/arch/$$(HOST_$(1))/context.cpp \\\n-              rt/arch/$$(HOST_$(1))/gpr.cpp \\\n               rt/rust_android_dummy.cpp \\\n               rt/rust_test_helpers.cpp\n \n@@ -106,7 +104,6 @@ RUNTIME_CS_$(1)_$(2) := rt/sundown/src/autolink.c \\\n \t\t\trt/sundown/html/html.c\n \n RUNTIME_S_$(1)_$(2) := rt/arch/$$(HOST_$(1))/_context.S \\\n-\t\t\trt/arch/$$(HOST_$(1))/ccall.S \\\n \t\t\trt/arch/$$(HOST_$(1))/record_sp.S\n \n RT_BUILD_DIR_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/stage$(2)\n@@ -122,7 +119,7 @@ RUNTIME_OBJS_$(1)_$(2) := $$(RUNTIME_CXXS_$(1)_$(2):rt/%.cpp=$$(RT_BUILD_DIR_$(1\n                      $$(RUNTIME_S_$(1)_$(2):rt/%.S=$$(RT_BUILD_DIR_$(1)_$(2))/%.o)\n ALL_OBJ_FILES += $$(RUNTIME_OBJS_$(1)_$(2))\n \n-MORESTACK_OBJ_$(1)_$(2) := $$(RT_BUILD_DIR_$(1)_$(2))/arch/$$(HOST_$(1))/morestack.o\n+MORESTACK_OBJS_$(1)_$(2) := $$(RT_BUILD_DIR_$(1)_$(2))/arch/$$(HOST_$(1))/morestack.o\n ALL_OBJ_FILES += $$(MORESTACK_OBJS_$(1)_$(2))\n \n $$(RT_BUILD_DIR_$(1)_$(2))/%.o: rt/%.cpp $$(MKFILE_DEPS)\n@@ -140,9 +137,9 @@ $$(RT_BUILD_DIR_$(1)_$(2))/%.o: rt/%.S  $$(MKFILE_DEPS) \\\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_ASSEMBLE_$(1),$$@,$$<)\n \n-$$(RT_BUILD_DIR_$(1)_$(2))/arch/$$(HOST_$(1))/libmorestack.a: $$(MORESTACK_OBJ_$(1)_$(2))\n+$$(RT_BUILD_DIR_$(1)_$(2))/arch/$$(HOST_$(1))/libmorestack.a: $$(MORESTACK_OBJS_$(1)_$(2))\n \t@$$(call E, link: $$@)\n-\t$$(Q)$(AR_$(1)) rcs $$@ $$<\n+\t$$(Q)$(AR_$(1)) rcs $$@ $$^\n \n $$(RT_BUILD_DIR_$(1)_$(2))/$(CFG_RUNTIME_$(1)): $$(RUNTIME_OBJS_$(1)_$(2)) $$(MKFILE_DEPS) \\\n                         $$(RUNTIME_DEF_$(1)_$(2)) $$(LIBUV_LIB_$(1)) $$(JEMALLOC_LIB_$(1))"}, {"sha": "c6cc3092c11eccfb2d36db9c3e52e3ffcaa32d5d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -2226,6 +2226,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n                              [path_name(item.ident)]),\n                 decl,\n                 body,\n+                item.attrs,\n                 llfndecl,\n                 item.id);\n         } else if !generics.is_type_parameterized() {"}, {"sha": "09dd2f21a3b029b893b5124d38674a9cdb6bad10", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -386,14 +386,15 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                                       path: &ast_map::path,\n                                       decl: &ast::fn_decl,\n                                       body: &ast::Block,\n+                                      attrs: &[ast::Attribute],\n                                       llwrapfn: ValueRef,\n                                       id: ast::NodeId) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n     let tys = foreign_types_for_id(ccx, id);\n \n     unsafe { // unsafe because we call LLVM operations\n         // Build up the Rust function (`foo0` above).\n-        let llrustfn = build_rust_fn(ccx, path, decl, body, id);\n+        let llrustfn = build_rust_fn(ccx, path, decl, body, attrs, id);\n \n         // Build up the foreign wrapper (`foo` above).\n         return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys);\n@@ -403,6 +404,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                      path: &ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n+                     attrs: &[ast::Attribute],\n                      id: ast::NodeId)\n                      -> ValueRef {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n@@ -434,6 +436,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                t.repr(tcx));\n \n         let llfndecl = base::decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, ps);\n+        base::set_llvm_fn_attrs(attrs, llfndecl);\n         base::trans_fn(ccx,\n                        (*path).clone(),\n                        decl,"}, {"sha": "712bf66bdaf26ba529d5ca9d4aeb00000dac1c43", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -326,8 +326,12 @@ pub fn monitor(f: ~fn(@diagnostic::Emitter)) {\n     use std::comm::*;\n \n     // XXX: This is a hack for newsched since it doesn't support split stacks.\n-    // rustc needs a lot of stack!\n-    static STACK_SIZE: uint = 6000000;\n+    // rustc needs a lot of stack! When optimizations are disabled, it needs\n+    // even *more* stack than usual as well.\n+    #[cfg(rtopt)]\n+    static STACK_SIZE: uint = 6000000;  // 6MB\n+    #[cfg(not(rtopt))]\n+    static STACK_SIZE: uint = 20000000; // 20MB\n \n     let (p, ch) = stream();\n     let ch = SharedChan::new(ch);"}, {"sha": "f4616a8e18373ff6f6f1327c29231ed36b791019", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 253, "deletions": 30, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -11,9 +11,12 @@\n use option::*;\n use super::stack::StackSegment;\n use libc::c_void;\n+use uint;\n use cast::{transmute, transmute_mut_unsafe,\n            transmute_region, transmute_mut_region};\n \n+pub static RED_ZONE: uint = 20 * 1024;\n+\n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n // use an attribute on a struct.\n@@ -24,14 +27,17 @@ pub struct Context {\n     /// The context entry point, saved here for later destruction\n     start: Option<~~fn()>,\n     /// Hold the registers while the task or scheduler is suspended\n-    regs: ~Registers\n+    regs: ~Registers,\n+    /// Lower bound and upper bound for the stack\n+    stack_bounds: Option<(uint, uint)>,\n }\n \n impl Context {\n     pub fn empty() -> Context {\n         Context {\n             start: None,\n-            regs: new_regs()\n+            regs: new_regs(),\n+            stack_bounds: None,\n         }\n     }\n \n@@ -47,7 +53,6 @@ impl Context {\n \n         let fp: *c_void = task_start_wrapper as *c_void;\n         let argp: *c_void = unsafe { transmute::<&~fn(), *c_void>(&*start) };\n-        let stack_base: *uint = stack.start();\n         let sp: *uint = stack.end();\n         let sp: *mut uint = unsafe { transmute_mut_unsafe(sp) };\n         // Save and then immediately load the current context,\n@@ -57,11 +62,23 @@ impl Context {\n             swap_registers(transmute_mut_region(&mut *regs), transmute_region(&*regs));\n         };\n \n-        initialize_call_frame(&mut *regs, fp, argp, sp, stack_base);\n+        initialize_call_frame(&mut *regs, fp, argp, sp);\n \n+        // Scheduler tasks don't have a stack in the \"we allocated it\" sense,\n+        // but rather they run on pthreads stacks. We have complete control over\n+        // them in terms of the code running on them (and hopefully they don't\n+        // overflow). Additionally, their coroutine stacks are listed as being\n+        // zero-length, so that's how we detect what's what here.\n+        let stack_base: *uint = stack.start();\n+        let bounds = if sp as uint == stack_base as uint {\n+            None\n+        } else {\n+            Some((stack_base as uint, sp as uint))\n+        };\n         return Context {\n             start: Some(start),\n-            regs: regs\n+            regs: regs,\n+            stack_bounds: bounds,\n         }\n     }\n \n@@ -79,8 +96,25 @@ impl Context {\n         let in_regs: &Registers = match in_context {\n             &Context { regs: ~ref r, _ } => r\n         };\n-        rtdebug!(\"doing raw swap\");\n-        unsafe { swap_registers(out_regs, in_regs) };\n+\n+        rtdebug!(\"noting the stack limit and doing raw swap\");\n+\n+        unsafe {\n+            // Right before we switch to the new context, set the new context's\n+            // stack limit in the OS-specified TLS slot. This also  means that\n+            // we cannot call any more rust functions after record_stack_bounds\n+            // returns because they would all likely fail due to the limit being\n+            // invalid for the current task. Lucky for us `swap_registers` is a\n+            // C function so we don't have to worry about that!\n+            match in_context.stack_bounds {\n+                Some((lo, hi)) => record_stack_bounds(lo, hi),\n+                // If we're going back to one of the original contexts or\n+                // something that's possibly not a \"normal task\", then reset\n+                // the stack limit to 0 to make morestack never fail\n+                None => record_stack_bounds(0, uint::max_value),\n+            }\n+            swap_registers(out_regs, in_regs)\n+        }\n     }\n }\n \n@@ -89,6 +123,29 @@ extern {\n     fn swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n }\n \n+// Register contexts used in various architectures\n+//\n+// These structures all represent a context of one task throughout its\n+// execution. Each struct is a representation of the architecture's register\n+// set. When swapping between tasks, these register sets are used to save off\n+// the current registers into one struct, and load them all from another.\n+//\n+// Note that this is only used for context switching, which means that some of\n+// the registers may go unused. For example, for architectures with\n+// callee/caller saved registers, the context will only reflect the callee-saved\n+// registers. This is because the caller saved registers are already stored\n+// elsewhere on the stack (if it was necessary anyway).\n+//\n+// Additionally, there may be fields on various architectures which are unused\n+// entirely because they only reflect what is theoretically possible for a\n+// \"complete register set\" to show, but user-space cannot alter these registers.\n+// An example of this would be the segment selectors for x86.\n+//\n+// These structures/functions are roughly in-sync with the source files inside\n+// of src/rt/arch/$arch. The only currently used function from those folders is\n+// the `swap_registers` function, but that's only because for now segmented\n+// stacks are disabled.\n+\n #[cfg(target_arch = \"x86\")]\n struct Registers {\n     eax: u32, ebx: u32, ecx: u32, edx: u32,\n@@ -109,7 +166,7 @@ fn new_regs() -> ~Registers {\n \n #[cfg(target_arch = \"x86\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint, _stack_base: *uint) {\n+                         sp: *mut uint) {\n \n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -4);\n@@ -125,6 +182,8 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n     regs.ebp = 0;\n }\n \n+// windows requires saving more registers (both general and XMM), so the windows\n+// register context must be larger.\n #[cfg(windows, target_arch = \"x86_64\")]\n type Registers = [uint, ..34];\n #[cfg(not(windows), target_arch = \"x86_64\")]\n@@ -137,39 +196,24 @@ fn new_regs() -> ~Registers { ~([0, .. 22]) }\n \n #[cfg(target_arch = \"x86_64\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint, stack_base: *uint) {\n+                         sp: *mut uint) {\n \n-    // Redefinitions from regs.h\n+    // Redefinitions from rt/arch/x86_64/regs.h\n     static RUSTRT_ARG0: uint = 3;\n     static RUSTRT_RSP: uint = 1;\n     static RUSTRT_IP: uint = 8;\n     static RUSTRT_RBP: uint = 2;\n \n-    #[cfg(windows)]\n-    fn initialize_tib(regs: &mut Registers, sp: *mut uint, stack_base: *uint) {\n-        // Redefinitions from regs.h\n-        static RUSTRT_ST1: uint = 11; // stack bottom\n-        static RUSTRT_ST2: uint = 12; // stack top\n-        regs[RUSTRT_ST1] = sp as uint;\n-        regs[RUSTRT_ST2] = stack_base as uint;\n-    }\n-    #[cfg(not(windows))]\n-    fn initialize_tib(_: &mut Registers, _: *mut uint, _: *uint) {\n-    }\n-\n-    // Win64 manages stack range at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n-    initialize_tib(regs, sp, stack_base);\n-\n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -1);\n \n     // The final return address. 0 indicates the bottom of the stack\n     unsafe { *sp = 0; }\n \n     rtdebug!(\"creating call frame\");\n-    rtdebug!(\"fptr {}\", fptr as uint);\n-    rtdebug!(\"arg {}\", arg as uint);\n-    rtdebug!(\"sp {}\", sp as uint);\n+    rtdebug!(\"fptr {}\", fptr);\n+    rtdebug!(\"arg {}\", arg);\n+    rtdebug!(\"sp {}\", sp);\n \n     regs[RUSTRT_ARG0] = arg as uint;\n     regs[RUSTRT_RSP] = sp as uint;\n@@ -187,7 +231,7 @@ fn new_regs() -> ~Registers { ~([0, .. 32]) }\n \n #[cfg(target_arch = \"arm\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint, _stack_base: *uint) {\n+                         sp: *mut uint) {\n     let sp = align_down(sp);\n     // sp of arm eabi is 8-byte aligned\n     let sp = mut_offset(sp, -2);\n@@ -208,7 +252,7 @@ fn new_regs() -> ~Registers { ~([0, .. 32]) }\n \n #[cfg(target_arch = \"mips\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void,\n-                         sp: *mut uint, _stack_base: *uint) {\n+                         sp: *mut uint) {\n     let sp = align_down(sp);\n     // sp of mips o32 is 8-byte aligned\n     let sp = mut_offset(sp, -2);\n@@ -236,3 +280,182 @@ pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use std::sys::size_of;\n     (ptr as int + count * (size_of::<T>() as int)) as *mut T\n }\n+\n+#[inline(always)]\n+pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+    // When the old runtime had segmented stacks, it used a calculation that was\n+    // \"limit + RED_ZONE + FUDGE\". The red zone was for things like dynamic\n+    // symbol resolution, llvm function calls, etc. In theory this red zone\n+    // value is 0, but it matters far less when we have gigantic stacks because\n+    // we don't need to be so exact about our stack budget. The \"fudge factor\"\n+    // was because LLVM doesn't emit a stack check for functions < 256 bytes in\n+    // size. Again though, we have giant stacks, so we round all these\n+    // calculations up to the nice round number of 20k.\n+    record_sp_limit(stack_lo + RED_ZONE);\n+\n+    return target_record_stack_bounds(stack_lo, stack_hi);\n+\n+    #[cfg(not(windows))] #[cfg(not(target_arch = \"x86_64\"))] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}\n+    #[cfg(windows, target_arch = \"x86_64\")] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+        // Windows compiles C functions which may check the stack bounds. This\n+        // means that if we want to perform valid FFI on windows, then we need\n+        // to ensure that the stack bounds are what they truly are for this\n+        // task. More info can be found at:\n+        //   https://github.com/mozilla/rust/issues/3445#issuecomment-26114839\n+        //\n+        // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n+        asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_lo) :: \"volatile\");\n+        asm!(\"mov $0, %gs:0x10\" :: \"r\"(stack_hi) :: \"volatile\");\n+    }\n+}\n+\n+/// Records the current limit of the stack as specified by `end`.\n+///\n+/// This is stored in an OS-dependent location, likely inside of the thread\n+/// local storage. The location that the limit is stored is a pre-ordained\n+/// location because it's where LLVM has emitted code to check.\n+///\n+/// Note that this cannot be called under normal circumstances. This function is\n+/// changing the stack limit, so upon returning any further function calls will\n+/// possibly be triggering the morestack logic if you're not careful.\n+///\n+/// Also note that this and all of the inside functions are all flagged as\n+/// \"inline(always)\" because they're messing around with the stack limits.  This\n+/// would be unfortunate for the functions themselves to trigger a morestack\n+/// invocation (if they were an actual function call).\n+#[inline(always)]\n+pub unsafe fn record_sp_limit(limit: uint) {\n+    return target_record_sp_limit(limit);\n+\n+    // x86-64\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $$0x60+90*8, %rsi\n+              movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n+        // store this inside of the \"arbitrary data slot\", but double the size\n+        // because this is 64 bit instead of 32 bit\n+        asm!(\"movq $0, %gs:0x28\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $0, %fs:24\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+\n+    // x86\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movl $$0x48+90*4, %eax\n+              movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n+        // store this inside of the \"arbitrary data slot\"\n+        asm!(\"movl $0, %fs:0x14\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+\n+    // mips, arm - Some brave soul can port these to inline asm, but it's over\n+    //             my head personally\n+    #[cfg(target_arch = \"mips\")]\n+    #[cfg(target_arch = \"arm\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        return record_sp_limit(limit as *c_void);\n+        extern {\n+            #[rust_stack]\n+            fn record_sp_limit(limit: *c_void);\n+        }\n+    }\n+}\n+\n+/// The counterpart of the function above, this function will fetch the current\n+/// stack limit stored in TLS.\n+///\n+/// Note that all of these functions are meant to be exact counterparts of their\n+/// brethren above, except that the operands are reversed.\n+///\n+/// As with the setter, this function does not have a __morestack header and can\n+/// therefore be called in a \"we're out of stack\" situation.\n+#[inline(always)]\n+// NOTE: after the next snapshot, can remove the initialization before inline\n+//       assembly due to an improvement in how it's handled, then this specific\n+//       allow directive should get removed.\n+#[allow(dead_assignment)]\n+pub unsafe fn get_sp_limit() -> uint {\n+    return target_get_sp_limit();\n+\n+    // x86-64\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let mut limit: uint = 0;\n+        asm!(\"movq $$0x60+90*8, %rsi\n+              movq %gs:(%rsi), $0\" : \"=r\"(limit) :: \"rsi\" : \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let mut limit: uint = 0;\n+        asm!(\"movq %fs:112, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let mut limit: uint = 0;\n+        asm!(\"movq %gs:0x28, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let mut limit: uint = 0;\n+        asm!(\"movq %fs:24, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+\n+    // x86\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let mut limit: uint = 0;\n+        asm!(\"movl $$0x48+90*4, %eax\n+              movl %gs:(%eax), $0\" : \"=r\"(limit) :: \"eax\" : \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let mut limit: uint = 0;\n+        asm!(\"movl %gs:48, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let mut limit: uint = 0;\n+        asm!(\"movl %fs:0x14, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+\n+    // mips, arm - Some brave soul can port these to inline asm, but it's over\n+    //             my head personally\n+    #[cfg(target_arch = \"mips\")]\n+    #[cfg(target_arch = \"arm\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        return get_sp_limit() as uint;\n+        extern {\n+            #[rust_stack]\n+            fn get_sp_limit() -> *c_void;\n+        }\n+    }\n+}"}, {"sha": "96a0069e851568a7b27f16dfeb8d505ad7a9c5ea", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -17,7 +17,7 @@ use vec::ImmutableVector;\n // and instead look them up at runtime, which we need to resolve\n // the crate_map properly.\n #[cfg(target_os = \"macos\")]\n-#[link_args = \"-undefined dynamic_lookup\"]\n+#[link_args = \"-Wl,-U,__rust_crate_map_toplevel\"]\n extern {}\n \n pub struct ModEntry<'self> {"}, {"sha": "c02e7fe90131f8ada68cfca017d5ca6541aa70e4", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -17,7 +17,7 @@ use os;\n // Note that these are all accessed without any synchronization.\n // They are expected to be initialized once then left alone.\n \n-static mut MIN_STACK: uint = 2000000;\n+static mut MIN_STACK: uint = 4000000;\n static mut DEBUG_BORROW: bool = false;\n \n pub fn init() {"}, {"sha": "c636a16903700b43610fd6cbb7165c1080385e73", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -173,7 +173,7 @@ impl Scheduler {\n \n         // Now that we have an empty task struct for the scheduler\n         // task, put it in TLS.\n-        Local::put::(sched_task);\n+        Local::put(sched_task);\n \n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is"}, {"sha": "1b1e4e7d426ac3c40fcf452e99b1577498d67486", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -29,6 +29,7 @@ use rt::logging::StdErrLogger;\n use super::local_heap::LocalHeap;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n+use rt::context;\n use rt::context::Context;\n use unstable::finally::Finally;\n use task::spawn::Taskgroup;\n@@ -465,6 +466,80 @@ impl Unwinder {\n     }\n }\n \n+/// This function is invoked from rust's current __morestack function. Segmented\n+/// stacks are currently not enabled as segmented stacks, but rather one giant\n+/// stack segment. This means that whenever we run out of stack, we want to\n+/// truly consider it to be stack overflow rather than allocating a new stack.\n+#[no_mangle]      // - this is called from C code\n+#[no_split_stack] // - it would be sad for this function to trigger __morestack\n+#[doc(hidden)] // XXX: this function shouldn't have to be `pub` to get exported\n+               //      so it can be linked against, we should have a better way\n+               //      of specifying that.\n+pub extern \"C\" fn rust_stack_exhausted() {\n+    use rt::in_green_task_context;\n+    use rt::task::Task;\n+    use rt::local::Local;\n+    use rt::logging::Logger;\n+    use unstable::intrinsics;\n+\n+    unsafe {\n+        // We're calling this function because the stack just ran out. We need\n+        // to call some other rust functions, but if we invoke the functions\n+        // right now it'll just trigger this handler being called again. In\n+        // order to alleviate this, we move the stack limit to be inside of the\n+        // red zone that was allocated for exactly this reason.\n+        let limit = context::get_sp_limit();\n+        context::record_sp_limit(limit - context::RED_ZONE / 2);\n+\n+        // This probably isn't the best course of action. Ideally one would want\n+        // to unwind the stack here instead of just aborting the entire process.\n+        // This is a tricky problem, however. There's a few things which need to\n+        // be considered:\n+        //\n+        //  1. We're here because of a stack overflow, yet unwinding will run\n+        //     destructors and hence arbitrary code. What if that code overflows\n+        //     the stack? One possibility is to use the above allocation of an\n+        //     extra 10k to hope that we don't hit the limit, and if we do then\n+        //     abort the whole program. Not the best, but kind of hard to deal\n+        //     with unless we want to switch stacks.\n+        //\n+        //  2. LLVM will optimize functions based on whether they can unwind or\n+        //     not. It will flag functions with 'nounwind' if it believes that\n+        //     the function cannot trigger unwinding, but if we do unwind on\n+        //     stack overflow then it means that we could unwind in any function\n+        //     anywhere. We would have to make sure that LLVM only places the\n+        //     nounwind flag on functions which don't call any other functions.\n+        //\n+        //  3. The function that overflowed may have owned arguments. These\n+        //     arguments need to have their destructors run, but we haven't even\n+        //     begun executing the function yet, so unwinding will not run the\n+        //     any landing pads for these functions. If this is ignored, then\n+        //     the arguments will just be leaked.\n+        //\n+        // Exactly what to do here is a very delicate topic, and is possibly\n+        // still up in the air for what exactly to do. Some relevant issues:\n+        //\n+        //  #3555 - out-of-stack failure leaks arguments\n+        //  #3695 - should there be a stack limit?\n+        //  #9855 - possible strategies which could be taken\n+        //  #9854 - unwinding on windows through __morestack has never worked\n+        //  #2361 - possible implementation of not using landing pads\n+\n+        if in_green_task_context() {\n+            do Local::borrow |task: &mut Task| {\n+                let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+                format_args!(|args| { task.logger.log(args) },\n+                             \"task '{}' has overflowed its stack\", n);\n+            }\n+        } else {\n+            rterrln!(\"stack overflow in non-task context\");\n+        }\n+\n+        intrinsics::abort();\n+    }\n+}\n+\n /// This is the entry point of unwinding for things like lang items and such.\n /// The arguments are normally generated by the compiler.\n pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n@@ -481,22 +556,33 @@ pub fn begin_unwind(msg: *c_char, file: *c_char, line: size_t) -> ! {\n         let msg = match msg.as_str() {\n             Some(s) => s, None => rtabort!(\"message wasn't utf8?\")\n         };\n-        let file = match file.as_str() {\n-            Some(s) => s, None => rtabort!(\"message wasn't utf8?\")\n-        };\n \n         if in_green_task_context() {\n             // Be careful not to allocate in this block, if we're failing we may\n             // have been failing due to a lack of memory in the first place...\n             do Local::borrow |task: &mut Task| {\n                 let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-                format_args!(|args| { task.logger.log(args) },\n-                             \"task '{}' failed at '{}', {}:{}\",\n-                             n, msg, file, line);\n+\n+                match file.as_str() {\n+                    Some(file) => {\n+                        format_args!(|args| { task.logger.log(args) },\n+                                     \"task '{}' failed at '{}', {}:{}\",\n+                                     n, msg, file, line);\n+                    }\n+                    None => {\n+                        format_args!(|args| { task.logger.log(args) },\n+                                     \"task '{}' failed at '{}'\", n, msg);\n+                    }\n+                }\n             }\n         } else {\n-            rterrln!(\"failed in non-task context at '{}', {}:{}\",\n-                     msg, file, line as int);\n+            match file.as_str() {\n+                Some(file) => {\n+                    rterrln!(\"failed in non-task context at '{}', {}:{}\",\n+                             msg, file, line as int);\n+                }\n+                None => rterrln!(\"failed in non-task context at '{}'\", msg),\n+            }\n         }\n \n         let task: *mut Task = Local::unsafe_borrow();"}, {"sha": "e774b81da3501d3e29b1dd3578b04be7fba65d53", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -8,30 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cast;\n use libc;\n use ops::Drop;\n+use unstable::raw;\n+use uint;\n \n #[allow(non_camel_case_types)] // runtime type\n type raw_thread = libc::c_void;\n \n pub struct Thread {\n     main: ~fn(),\n     raw_thread: *raw_thread,\n-    joined: bool\n+    joined: bool,\n }\n \n impl Thread {\n+    #[fixed_stack_segment] #[inline(never)]\n     pub fn start(main: ~fn()) -> Thread {\n-        fn substart(main: &~fn()) -> *raw_thread {\n-            #[fixed_stack_segment]; #[inline(never)];\n-\n-            unsafe { rust_raw_thread_start(main) }\n+        // This is the starting point of rust os threads. The first thing we do\n+        // is make sure that we don't trigger __morestack (also why this has a\n+        // no_split_stack annotation), and then we re-build the main function\n+        // and invoke it from there.\n+        #[no_split_stack]\n+        extern \"C\" fn thread_start(code: *(), env: *()) {\n+            use rt::context;\n+            unsafe {\n+                context::record_stack_bounds(0, uint::max_value);\n+                let f: &fn() = cast::transmute(raw::Closure {\n+                    code: code,\n+                    env: env,\n+                });\n+                f();\n+            }\n         }\n-        let raw = substart(&main);\n+\n+        let raw_thread = unsafe {\n+            let c: raw::Closure = cast::transmute_copy(&main);\n+            let raw::Closure { code, env } = c;\n+            rust_raw_thread_start(thread_start, code, env)\n+        };\n         Thread {\n             main: main,\n-            raw_thread: raw,\n-            joined: false\n+            raw_thread: raw_thread,\n+            joined: false,\n         }\n     }\n \n@@ -55,7 +75,8 @@ impl Drop for Thread {\n }\n \n extern {\n-    pub fn rust_raw_thread_start(f: &(~fn())) -> *raw_thread;\n-    pub fn rust_raw_thread_join(thread: *raw_thread);\n-    pub fn rust_raw_thread_delete(thread: *raw_thread);\n+    fn rust_raw_thread_start(f: extern \"C\" fn(*(), *()),\n+                             code: *(), env: *()) -> *raw_thread;\n+    fn rust_raw_thread_join(thread: *raw_thread);\n+    fn rust_raw_thread_delete(thread: *raw_thread);\n }"}, {"sha": "ddb104240f2c615ce2e5112d2f4c4a645891cc58", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -27,15 +27,11 @@ pub unsafe fn create(key: &mut Key) {\n }\n \n #[cfg(unix)]\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n     assert_eq!(0, pthread_setspecific(key, value));\n }\n \n #[cfg(unix)]\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub unsafe fn get(key: Key) -> *mut c_void {\n     pthread_getspecific(key)\n }\n@@ -53,8 +49,21 @@ type pthread_key_t = ::libc::c_uint;\n #[cfg(unix)]\n extern {\n     fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n-    fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n+\n+    // This function is a very cheap operation on both osx and unix. On osx, it\n+    // turns out it's just three instructions, and on unix it's a cheap function\n+    // which only uses a very small amount of stack.\n+    //\n+    // This is not marked as such because we think it has a small stack, but\n+    // rather we would like to be able to fetch information from\n+    // thread-local-storage when a task is running very low on its stack budget.\n+    // For example, this is invoked whenever stack overflow is detected, and we\n+    // obviously have very little budget to deal with (certainly not anything\n+    // close to a fixed_stack_segment)\n+    #[rust_stack]\n     fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n+    #[rust_stack]\n+    fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n }\n \n #[cfg(windows)]\n@@ -70,31 +79,37 @@ pub unsafe fn create(key: &mut Key) {\n }\n \n #[cfg(windows)]\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n     assert!(0 != TlsSetValue(key, value))\n }\n \n #[cfg(windows)]\n-#[fixed_stack_segment]\n-#[inline(never)]\n pub unsafe fn get(key: Key) -> *mut c_void {\n     TlsGetValue(key)\n }\n \n #[cfg(windows, target_arch = \"x86\")]\n extern \"stdcall\" {\n-       fn TlsAlloc() -> DWORD;\n-       fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n-       fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n+    fn TlsAlloc() -> DWORD;\n+\n+    // See the reasoning in pthread_getspecific as to why this has the\n+    // 'rust_stack' attribute, as this function was also verified to only\n+    // require a small amount of stack.\n+    #[rust_stack]\n+    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n+    #[rust_stack]\n+    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n }\n \n #[cfg(windows, target_arch = \"x86_64\")]\n extern {\n-       fn TlsAlloc() -> DWORD;\n-       fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n-       fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n+    fn TlsAlloc() -> DWORD;\n+\n+    // See above.\n+    #[rust_stack]\n+    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n+    #[rust_stack]\n+    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n }\n \n #[test]"}, {"sha": "3350a040f53039057d59159417c4b7ab998b6467", "filename": "src/rt/arch/arm/ccall.S", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fccall.S?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,26 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif\n-\n-.text\n-.code 32\n-.arm\n-.align\n-\n-.globl __morestack\n-.hidden __morestack\n-.type __morestack, %function\n-__morestack:\n-\t.fnstart\n-\t.save {r4, fp, lr}\n-\tpush {r4, fp, lr}\n-    .movsp r4\n-\tmov r4, sp\n-\tmov sp, r2\n-\tmov fp, sp\n-\tblx r1\n-\tmov sp, r4\n-\tpop {r4, fp, lr}\n-\tmov pc, lr\n-\t.fnend"}, {"sha": "7d90668aad53a12f78ad7dcb82d2a8ab5ed83bd4", "filename": "src/rt/arch/arm/context.cpp", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fcontext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fcontext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fcontext.cpp?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,39 +0,0 @@\n-// xfail-license\n-\n-#include \"context.h\"\n-#include \"../../rust_globals.h\"\n-\n-extern \"C\" void CDECL swap_registers(registers_t *oregs,\n-                                     registers_t *regs)\n-asm (\"swap_registers\");\n-\n-context::context()\n-{\n-    assert((void*)&regs == (void*)this);\n-    memset(&regs, 0, sizeof(regs));\n-}\n-\n-void context::swap(context &out)\n-{\n-    swap_registers(&out.regs, &regs);\n-}\n-\n-void context::call(void *f, void *arg, void *stack)\n-{\n-  // Get the current context, which we will then modify to call the\n-  // given function.\n-  swap(*this);\n-\n-  // set up the stack\n-  uint32_t *sp = ( uint32_t *)stack;\n-  sp = align_down(sp);\n-  // The final return address. 0 indicates the bottom of the stack\n-  // sp of arm eabi is 8-byte aligned\n-  sp -= 2;\n-  *sp = 0;\n-\n-  regs.data[0] = ( uint32_t )arg; // r0\n-  regs.data[13] = ( uint32_t )sp; //#52 sp, r13\n-  regs.data[14] = ( uint32_t )f;  //#60 pc, r15 --> lr,\n-  // Last base pointer on the stack should be 0\n-}"}, {"sha": "54f0df7de3144f615b50ce462ad19bc58dc705be", "filename": "src/rt/arch/arm/context.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fcontext.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,44 +0,0 @@\n-// -*- mode: c++ -*-\n-// xfail-license\n-\n-#ifndef CONTEXT_H\n-#define CONTEXT_H\n-\n-#include <cstdlib>\n-#include <inttypes.h>\n-#include <stdint.h>\n-//#include <xmmintrin.h>\n-\n-#include \"vg/memcheck.h\"\n-\n-template<typename T>\n-T align_down(T sp)\n-{\n-    // There is no platform we care about that needs more than a\n-    // 16-byte alignment.\n-    return (T)((uint32_t)sp & ~(16 - 1));\n-}\n-\n-// The struct in which we store the saved data.  This is mostly the\n-// volatile registers and instruction pointer, but it also includes\n-// RCX/RDI which are used to pass arguments.  The indices for each\n-// register are found in \"regs.h\".  Note that the alignment must be\n-// 16 bytes so that SSE instructions can be used.\n-#include \"regs.h\"\n-struct registers_t {\n-    uint32_t data[RUSTRT_MAX];\n-} __attribute__((aligned(16)));\n-\n-class context {\n-public:\n-    registers_t regs;\n-\n-    context();\n-\n-    context *next;\n-\n-    void swap(context &out);\n-    void call(void *f, void *arg, void *sp);\n-};\n-\n-#endif"}, {"sha": "77ec9d5182a17b89efaf56ba75f488b670e024c1", "filename": "src/rt/arch/arm/gpr.cpp", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fgpr.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fgpr.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fgpr.cpp?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,16 +0,0 @@\n-// xfail-license\n-\n-#include \"gpr.h\"\n-\n-#define LOAD(rn) do { \\\n-    uintptr_t tmp; \\\n-    asm(\"mov %%\" #rn \",%0\" : \"=r\" (tmp) :); \\\n-    this->rn = tmp; \\\n-} while (0)\n-\n-void rust_gpr::load() {\n-    LOAD(r0); LOAD(r1); LOAD(r2); LOAD(r3);\n-    LOAD(r4); LOAD(r5); LOAD(r6); LOAD(r7);\n-    LOAD(r8);  LOAD(r9);  LOAD(r10); LOAD(r11);\n-    LOAD(r12); LOAD(r13); LOAD(r14); LOAD(r15);\n-}"}, {"sha": "c8a3e916a371c0692d356f7a42bdf4cfb692ba49", "filename": "src/rt/arch/arm/gpr.h", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fgpr.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fgpr.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fgpr.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,23 +0,0 @@\n-// xfail-license\n-// General-purpose registers. This structure is used during stack crawling.\n-\n-#ifndef GPR_H\n-#define GPR_H\n-\n-#include \"rust_gpr_base.h\"\n-\n-class rust_gpr : public rust_gpr_base {\n-public:\n-    uintptr_t r0, r1, r2, r3, r4, r5, r6, r7;\n-    uintptr_t  r8,  r9, r10, r11, r12, r13, r14, r15;\n-\n-    inline uintptr_t get_fp() { return r11; }\n-    inline uintptr_t get_ip() { return r12; }\n-\n-    inline void set_fp(uintptr_t new_fp) { r11 = new_fp; }\n-    inline void set_ip(uintptr_t new_ip) { r12 = new_ip; }\n-\n-    void load();\n-};\n-\n-#endif"}, {"sha": "219f0962d771c000edd75e7f90604b171b55af39", "filename": "src/rt/arch/arm/morestack.S", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Farm%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Farm%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fmorestack.S?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -3,13 +3,14 @@\n .section\t.note.GNU-stack, \"\", %progbits\n #endif\n \n+/* See i386/morestack.S for the lengthy, general explanation. */\n+\n .text\n .code 32\n .arm\n .align\n \n-.global upcall_new_stack\n-.global upcall_del_stack\n+.global rust_stack_exhausted\n .global __morestack\n .hidden __morestack\n \n@@ -32,40 +33,8 @@ __morestack:\n     // Save argument registers of the original function\n     push {r0, r1, r2, r3, lr}\n \n-    mov r0, r4         // The amount of stack needed\n-    add r1, fp, #20    // Address of stack arguments\n-    mov r2, r5         // Size of stack arguments\n-\n     // Create new stack\n-    bl upcall_new_stack@plt\n-\n-    // Hold new stack pointer\n-    mov r5, r0\n-\n-    // Pop the saved arguments\n-    pop {r0, r1, r2, r3, lr}\n-\n-    // Grab the return pointer\n-    add r4, lr, #16    // Skip past the return\n-    mov sp, r5         // Swich to the new stack\n-    mov lr, pc\n-    mov pc, r4         // Call the original function\n-\n-    // Switch back to rust stack\n-    mov sp, r6\n-\n-    // Save return value\n-\tmov r4, r0\n-\tmov r5, r1\n-\n-    // Remove the new allocated stack\n-    bl upcall_del_stack@plt\n-\n-    // Restore return value\n-\tmov r0, r4\n-\tmov r1, r5\n+    bl rust_stack_exhausted@plt\n \n-    // Return\n-    pop {r6, fp, lr}\n-    mov pc, lr\n+    // the above function ensures that it never returns\n     .fnend"}, {"sha": "6900444c0fe295f1b68b349f16966ab47ff2ebf0", "filename": "src/rt/arch/arm/record_sp.S", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Frecord_sp.S?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -11,7 +11,6 @@\n \n .globl record_sp_limit\n .globl get_sp_limit\n-.globl get_sp\n \n record_sp_limit:\n \t// First, try to read TLS address from coprocessor\n@@ -46,7 +45,3 @@ get_sp_limit:\n \n \tldr r0, [r3]\n \tmov pc, lr\n-\n-get_sp:\n-\tmov r0, sp\n-\tmov pc, lr"}, {"sha": "0d1c24e0fb7495a5f09c4067a7fc38d63d94152a", "filename": "src/rt/arch/arm/regs.h", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fregs.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fregs.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fregs.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,21 +0,0 @@\n-// xfail-license\n-\n-#define RUSTRT_RBX   0\n-#define RUSTRT_RSP   1\n-#define RUSTRT_RBP   2\n-// RCX on Windows, RDI elsewhere\n-#define RUSTRT_ARG0  3\n-#define RUSTRT_R12   4\n-#define RUSTRT_R13   5\n-#define RUSTRT_R14   6\n-#define RUSTRT_R15   7\n-#define RUSTRT_IP    8\n-\n-#define RUSTRT_MAX  32\n-\n-// ARG0 is the register in which the first argument goes.\n-// Naturally this depends on your operating system.\n-#   define RUSTRT_ARG0_S r0\n-#   define RUSTRT_ARG1_S r1\n-#   define RUSTRT_ARG2_S r2\n-#   define RUSTRT_ARG3_S r3"}, {"sha": "cd79884760777b02bf027749204d8b43faef9e98", "filename": "src/rt/arch/arm/sp.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fsp.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Farm%2Fsp.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fsp.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Getting the stack pointer and getting/setting sp limit.\n-\n-#ifndef SP_H\n-#define SP_H\n-\n-#include \"../../rust_globals.h\"\n-\n-// Gets a pointer to the vicinity of the current stack pointer\n-extern \"C\" uintptr_t get_sp();\n-\n-// Gets the pointer to the end of the Rust stack from a platform-\n-// specific location in the thread control block\n-extern \"C\" CDECL uintptr_t get_sp_limit();\n-\n-// Records the pointer to the end of the Rust stack in a platform-\n-// specific location in the thread control block\n-extern \"C\" CDECL void record_sp_limit(void *limit);\n-\n-#endif"}, {"sha": "eeee7a4e715e36a301a87ea75d9cc243d64c40f5", "filename": "src/rt/arch/i386/ccall.S", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fccall.S?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,52 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif\n-\n-/*\n-\tThe function for switching to the C stack.  It is called\n-\t__morestack because gdb allows any frame with that name to\n-\tmove the stack pointer to a different stack, which it usually\n-\tconsiders an error.\n-*/\n-\n-\t.text\n-\n-#if defined(__APPLE__) || defined(__WIN32__)\n-.globl ___morestack\n-___morestack:\n-#else\n-.globl __morestack\n-.hidden __morestack\n-__morestack:\n-#endif\n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__WIN32__)\n-\t.cfi_startproc\n-#endif\n-\n-\tpushl %ebp\n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__WIN32__)\n-\t.cfi_def_cfa_offset 8\n-\t.cfi_offset %ebp, -8\n-#endif\n-\n-\tmovl %esp,%ebp          // save esp\n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__WIN32__)\n-\t.cfi_def_cfa_register %ebp\n-#endif\n-\n-\tmovl 16(%ebp),%esp      // load new esp\n-\tsubl $12,%esp           // maintain 16-byte alignment\n-\tpushl 8(%ebp)           // push ptr to argument block\n-\tcalll *12(%ebp)\n-\tmovl %ebp,%esp          // would like to use \"leave\" but it's slower\n-\tpopl %ebp\n-\n-\tret\n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__WIN32__)\n-\t.cfi_endproc\n-#endif"}, {"sha": "94e6f0418d07c230d5153eb8e3eca04e21626389", "filename": "src/rt/arch/i386/context.cpp", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fcontext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fcontext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.cpp?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,82 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"context.h\"\n-#include \"../../rust_globals.h\"\n-\n-extern \"C\" uint32_t CDECL swap_registers(registers_t *oregs,\n-                                         registers_t *regs);\n-\n-context::context()\n-{\n-    assert((void*)&regs == (void*)this);\n-}\n-\n-void context::swap(context &out)\n-{\n-  swap_registers(&out.regs, &regs);\n-}\n-\n-void context::call(void *f, void *arg, void *stack) {\n-  // Get the current context, which we will then modify to call the\n-  // given function.\n-  swap(*this);\n-\n-  // set up the trampoline frame\n-  uint32_t *sp = (uint32_t *)stack;\n-\n-  // Shift the stack pointer so the alignment works out right.\n-  sp = align_down(sp) - 3;\n-  *--sp = (uint32_t)arg;\n-  // The final return address. 0 indicates the bottom of the stack\n-  *--sp = 0;\n-\n-  regs.esp = (uint32_t)sp;\n-  regs.eip = (uint32_t)f;\n-\n-  // Last base pointer on the stack should be 0\n-  regs.ebp = 0;\n-}\n-\n-#if 0\n-// This is some useful code to check how the registers struct got\n-// layed out in memory.\n-int main() {\n-  registers_t regs;\n-\n-  printf(\"Register offsets\\n\");\n-\n-#define REG(r) \\\n-  printf(\"  %6s: +%ld\\n\", #r, (intptr_t)&regs.r - (intptr_t)&regs);\n-\n-  REG(eax);\n-  REG(ebx);\n-  REG(ecx);\n-  REG(edx);\n-  REG(ebp);\n-  REG(esi);\n-  REG(edi);\n-  REG(esp);\n-\n-  REG(cs);\n-  REG(ds);\n-  REG(ss);\n-  REG(es);\n-  REG(fs);\n-  REG(gs);\n-\n-  REG(eflags);\n-\n-  REG(eip);\n-\n-  return 0;\n-}\n-#endif"}, {"sha": "33352b4a5562d8c64f7b184b7bddcf3b9c5ce5ec", "filename": "src/rt/arch/i386/context.h", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#ifndef CONTEXT_H\n-#define CONTEXT_H\n-\n-#include <cstdlib>\n-#include <inttypes.h>\n-#include <stdint.h>\n-\n-#include \"vg/memcheck.h\"\n-\n-template<typename T>\n-T align_down(T sp)\n-{\n-    // There is no platform we care about that needs more than a\n-    // 16-byte alignment.\n-    return (T)((uint32_t)sp & ~(16 - 1));\n-}\n-\n-struct registers_t {\n-  // general purpose registers\n-  uint32_t eax, ebx, ecx, edx, ebp, esi, edi, esp;\n-\n-  // segment registers\n-  uint16_t cs, ds, ss, es, fs, gs;\n-\n-  uint32_t eflags;\n-\n-  uint32_t eip;\n-} __attribute__((aligned(16)));\n-\n-class context {\n-public:\n-  registers_t regs;\n-\n-  context();\n-\n-  context *next;\n-\n-  void swap(context &out);\n-  void call(void *f, void *arg, void *sp);\n-};\n-\n-#endif"}, {"sha": "e5a59d664b0d02a0f436353c86c8dd2871f3d06e", "filename": "src/rt/arch/i386/gpr.cpp", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fgpr.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fgpr.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fgpr.cpp?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include \"gpr.h\"\n-\n-#define LOAD(rn) do { \\\n-    uintptr_t tmp; \\\n-    asm(\"movl %%\" #rn \",%0\" : \"=r\" (tmp) :); \\\n-    this->rn = tmp; \\\n-} while (0)\n-\n-void rust_gpr::load() {\n-    LOAD(eax); LOAD(ebx); LOAD(ecx); LOAD(edx);\n-    LOAD(esi); LOAD(edi); LOAD(ebp); LOAD(esi);\n-}"}, {"sha": "1953170301c53df3e5e3633c4fb91d8e44e4bd24", "filename": "src/rt/arch/i386/gpr.h", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fgpr.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fgpr.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fgpr.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// General-purpose registers. This structure is used during stack crawling.\n-\n-#ifndef GPR_H\n-#define GPR_H\n-\n-#include \"rust_gpr_base.h\"\n-\n-class rust_gpr : public rust_gpr_base {\n-public:\n-    uintptr_t eax, ebx, ecx, edx, esi, edi, ebp, eip;\n-\n-    inline uintptr_t get_fp() { return ebp; }\n-    inline uintptr_t get_ip() { return eip; }\n-\n-    inline void set_fp(uintptr_t new_fp) { ebp = new_fp; }\n-    inline void set_ip(uintptr_t new_ip) { eip = new_ip; }\n-\n-    void load();\n-};\n-\n-#endif"}, {"sha": "25f907f479caa6148fbbfdebdb523f5b1be1b03a", "filename": "src/rt/arch/i386/morestack.S", "status": "modified", "additions": 26, "deletions": 148, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fmorestack.S?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -6,29 +6,27 @@\n /*\n \t__morestack\n \n-\tThis function implements stack growth using the mechanism\n-\tdevised by Ian Lance Taylor for gccgo, described here:\n+        This function is normally used to implement stack growth using the\n+        mechanism devised by Ian Lance Taylor for gccgo, described here:\n \n \thttp://gcc.gnu.org/wiki/SplitStacks\n \n-\tThe Rust stack is composed of a linked list of stack segments,\n-\tand each stack segment contains two parts: the work area,\n-\twhere Rust functions are allowed to execute; and the red zone,\n-\twhere no Rust code can execute, but where short runtime\n-\tfunctions (including __morestack), the dynamic linker, signal\n-\thandlers, and the unwinder can run.\n+        Each Rust function contains an LLVM-generated prologue that compares the\n+        stack space required for the current function to the space remaining in\n+        the current stack segment, maintained in a platform-specific TLS slot.\n+        The stack limit is strategically maintained by the Rust runtime so that\n+        it is always in place whenever a Rust function is running.\n \n-\tEach Rust function contains an LLVM-generated prologue that\n-\tcompares the stack space required for the current function to\n-\tthe space remaining in the current stack segment,\n-\tmaintained in a platform-specific TLS slot.  The stack limit\n-\tis strategically maintained by the Rust runtime so that it is\n-\talways in place whenever a Rust function is running.\n+        In Rust, however, we currently do not use __morestack for stack growth\n+        purposes.  Rather each task has one large stack segment. When this\n+        __morestack function is run, we interpret this as a \"stack overflow\"\n+        event rather than an event requiring an allocation of a new stack.\n \n-\tWhen there is not enough room to run the function, the function\n-\tprologue makes a call to __morestack to allocate a new stack\n-\tsegment, copy any stack-based arguments to it, switch stacks,\n-\tthen resume execution of the original function.\n+        In the early days, this implementation did indeed have all of the fiddly\n+        bits in order to manage split stacks in the sense of always growing\n+        stacks. For posterity, the implementation can be found at commit\n+        c8e77d5586aed50821e0b9361b2e24c96ade816c if we ever need to refer back\n+        to it.\n \n \t-- The __morestack calling convention --\n \n@@ -72,30 +70,20 @@\n .text\n \n #if defined(__APPLE__)\n-#define RUST_GET_TASK           L_rust_get_task$stub\n-#define UPCALL_NEW_STACK        L_upcall_new_stack$stub\n-#define UPCALL_DEL_STACK        L_upcall_del_stack$stub\n #define MORESTACK               ___morestack\n+#define EXHAUSTED               _rust_stack_exhausted\n #else\n #if defined(__linux__) || defined(__FreeBSD__)\n-#define UPCALL_NEW_STACK        upcall_new_stack\n-#define UPCALL_DEL_STACK        upcall_del_stack\n-#define RUST_GET_TASK           rust_get_task\n #define MORESTACK               __morestack\n+#define EXHAUSTED               rust_stack_exhausted\n #else\n-#define UPCALL_NEW_STACK        _upcall_new_stack\n-#define UPCALL_DEL_STACK        _upcall_del_stack\n-#define RUST_GET_TASK           _rust_get_task\n #define MORESTACK               ___morestack\n+#define EXHAUSTED               _rust_stack_exhausted\n #endif\n #endif\n \n-#ifndef __APPLE__\n-.globl UPCALL_NEW_STACK\n-.globl UPCALL_DEL_STACK\n-.globl RUST_GET_TASK\n-#endif\n .globl MORESTACK\n+.globl EXHAUSTED\n \n // FIXME: What about __WIN32__?\n #if defined(__linux__) || defined(__FreeBSD__)\n@@ -111,9 +99,7 @@\n #endif\n \n MORESTACK:\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__WIN32__)\n \t.cfi_startproc\n-#endif\n \n \t// This base pointer setup differs from most in that we are\n \t// telling the unwinder to consider the Canonical Frame\n@@ -129,129 +115,21 @@ MORESTACK:\n \t// would normally be, accounting for the two arguments to\n \t// __morestack, and an extra return address.\n \n+        // FIXME(#9854) these cfi directives don't work on windows.\n+\n \tpushl %ebp\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__WIN32__)\n \t// The CFA is 20 bytes above the register that it is\n \t// associated with for this frame (which will be %ebp)\n \t.cfi_def_cfa_offset 20\n \t// %ebp is -20 bytes from the CFA\n \t.cfi_offset %ebp, -20\n-#endif\n \tmovl %esp, %ebp\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__WIN32__)\n \t// Calculate the CFA as an offset from %ebp\n \t.cfi_def_cfa_register %ebp\n-#endif\n-\n-\t// NB: This can be called with the fastcc convention so we\n-\t// have to preserve any argument registers\n-\n-\t// NB: __morestack is called misaligned by 4 bytes, i.e.\n-\t// subl $4, %esp would get us to a normal alignment\n-\n-\tsubl $28,%esp\n-\n-\t// Save fastcc arguments\n-\tmovl %ecx, 16(%esp)\n-\tmovl %edx, 12(%esp)\n-\n-\t// FIXME (1388): it's possible we also need to save/restore some\n-\t// SSE2 registers here, if floats-go-in-regs on x86+SSE2. Unclear.\n-\n-\t// FIXME (1226): main is compiled with the split-stack prologue,\n-\t// causing it to call __morestack, so we have to jump back out\n-\tcalll RUST_GET_TASK\n-\ttestl %eax,%eax\n-\tjz .L$bail\n-\n-\t// The arguments to upcall_new_stack\n-\n-\t// The size of the stack arguments to copy to the new stack,\n-\t// and of the arguments to __morestack\n-\tmovl 40(%esp),%eax\n-\tmovl %eax,8(%esp)\n-\t// The address of the stack arguments to the original function\n-\tleal 48(%esp),%eax\n-\tmovl %eax,4(%esp)\n-\t// The amount of stack needed for the original function,\n-\t// the other argument to __morestack\n-\tmovl 36(%esp),%eax // The amount of stack needed\n-\tmovl %eax,(%esp)\n-\n-\tcall UPCALL_NEW_STACK\n-\n-\t// Save the address of the new stack\n-\tmovl %eax, (%esp)\n-\n-\t// Grab the __morestack return pointer\n-\tmovl 32(%esp),%eax\n-\t// Skip past the ret instruction in the parent fn\n-\tinc  %eax\n-\n-\t// Restore the fastcc arguments to the original function\n-\tmovl 16(%esp), %ecx\n-\tmovl 12(%esp), %edx\n-\n-        // Switch stacks\n-\tmovl (%esp),%esp\n-        // Re-enter the function that called us\n-\tcall *%eax\n-\n-\t// Now the function that called us has returned, so we need to\n-\t// delete the old stack space\n \n-\t// Switch back to the rust stack\n-\tmovl %ebp, %esp\n+        // re-align the stack\n+        subl $12,%esp\n+        calll EXHAUSTED\n+        // the exhaustion function guarantees that it can't return\n \n-\t// Realign stack - remember that __morestack was called misaligned\n-\tsubl $12, %esp\n-\n-\t// Save the return value of the function we allocated space for\n-\tmovl %edx, 4(%esp)\n-\tmovl %eax, (%esp)\n-\n-\tcall UPCALL_DEL_STACK\n-\n-\t// And restore it\n-\tmovl (%esp), %eax\n-\tmovl 4(%esp), %edx\n-\n-\taddl $12,%esp\n-\n-\tpopl %ebp\n-\n-\tretl $8\n-\n-.L$bail:\n-\tmovl 32(%esp),%eax\n-\tinc %eax\n-\n-\taddl $44, %esp\n-\tpopl %ebp\n-\taddl $4+8,%esp\n-\n-\tjmpl *%eax\n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__WIN32__)\n \t.cfi_endproc\n-#endif\n-\n-#ifdef __APPLE__\n-\n-.section __IMPORT,__jump_table,symbol_stubs,pure_instructions+self_modifying_code,5\n-\n-\t// Linker will replace the hlts (the ascii) with jmp\n-L_rust_get_task$stub:\n-\t.indirect_symbol _rust_get_task\n-\t.ascii\t \"\\364\\364\\364\\364\\364\"\n-\n-L_upcall_new_stack$stub:\n-\t.indirect_symbol _upcall_new_stack\n-\t.ascii\t \"\\364\\364\\364\\364\\364\"\n-\n-L_upcall_del_stack$stub:\n-\t.indirect_symbol _upcall_del_stack\n-\t.ascii\t \"\\364\\364\\364\\364\\364\"\n-\n-\t.subsections_via_symbols\n-#endif"}, {"sha": "85c02049edd51368a22a4fbd51af48a8fa84d75d", "filename": "src/rt/arch/i386/regs.h", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fregs.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fregs.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fregs.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This file is not used by i386, but we keep it here so all\n-// architectures have the same set of header files."}, {"sha": "4f4c84c817573ca5e97bbe76265f53496e2f551f", "filename": "src/rt/arch/i386/sp.h", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fsp.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fi386%2Fsp.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fsp.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Getting the stack pointer and getting/setting sp limit.\n-\n-#ifndef SP_H\n-#define SP_H\n-\n-#include \"../../rust_globals.h\"\n-\n-// Gets a pointer to the vicinity of the current stack pointer\n-extern \"C\" ALWAYS_INLINE uintptr_t get_sp() {\n-    uintptr_t sp;\n-    asm volatile (\n-        \"movl %%esp, %0\"\n-        : \"=m\"(sp));\n-    return sp;\n-}\n-\n-// Gets the pointer to the end of the Rust stack from a platform-\n-// specific location in the thread control block\n-extern \"C\" CDECL ALWAYS_INLINE uintptr_t get_sp_limit() {\n-    uintptr_t limit;\n-\n-#if defined(__linux__) || defined(__FreeBSD__)\n-    asm volatile (\n-        \"movl %%gs:48, %0\"\n-        : \"=r\"(limit));\n-#elif defined(__APPLE__)\n-    asm volatile (\n-        \"movl $0x48+90*4, %%ecx\\n\\t\"\n-        \"movl %%gs:(%%ecx), %0\"\n-        :  \"=r\"(limit)\n-        :: \"ecx\");\n-#elif defined(_WIN32)\n-    asm volatile (\n-        \"movl %%fs:0x14, %0\"\n-        : \"=r\"(limit));\n-#endif\n-\n-    return limit;\n-}\n-\n-// Records the pointer to the end of the Rust stack in a platform-\n-// specific location in the thread control block\n-extern \"C\" CDECL ALWAYS_INLINE void record_sp_limit(void *limit) {\n-#if defined(__linux__) || defined(__FreeBSD__)\n-    asm volatile (\n-        \"movl %0, %%gs:48\"\n-        :: \"r\"(limit));\n-#elif defined(__APPLE__)\n-    asm volatile (\n-        \"movl $0x48+90*4, %%eax\\n\\t\"\n-        \"movl %0, %%gs:(%%eax)\"\n-        :: \"r\"(limit)\n-        :  \"eax\");\n-#elif defined(_WIN32)\n-    asm volatile (\n-        \"movl %0, %%fs:0x14\"\n-        :: \"r\"(limit));\n-#endif\n-}\n-\n-#endif"}, {"sha": "cdcdc07db555d6f132dedb2cce35358fd76a0937", "filename": "src/rt/arch/mips/ccall.S", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fccall.S?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,42 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif\n-\n-.text\n-\n-.align 2\n-.globl __morestack\n-.hidden __morestack\n-.cfi_startproc\n-.set nomips16\n-.ent __morestack\n-__morestack:\n-        .set noreorder\n-        .set nomacro\n-\n-        addiu $29, $29, -8\n-        sw $31, 4($29)\n-        sw $30, 0($29)\n-\n-        .cfi_def_cfa_offset 8\n-        .cfi_offset 31, -4\n-        .cfi_offset 30, -8\n-\n-        move $30, $29\n-        .cfi_def_cfa_register 30\n-\n-        move $29, $6\n-        move $25, $5\n-        jalr $25\n-        nop\n-        move $29, $30\n-\n-        lw $30, 0($29)\n-        lw $31, 4($29)\n-        addiu $29, $29, 8\n-\n-        jr $31\n-        nop\n-.end __morestack\n-.cfi_endproc"}, {"sha": "e1e5776bc1a65ab183941723d9815c8e475547ae", "filename": "src/rt/arch/mips/context.cpp", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fcontext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fcontext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fcontext.cpp?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include \"context.h\"\n-#include \"../../rust_globals.h\"\n-\n-extern \"C\" void CDECL swap_registers(registers_t *oregs,\n-                                     registers_t *regs)\n-asm (\"swap_registers\");\n-\n-context::context()\n-{\n-    assert((void*)&regs == (void*)this);\n-    memset(&regs, 0, sizeof(regs));\n-}\n-\n-void context::swap(context &out)\n-{\n-    swap_registers(&out.regs, &regs);\n-}\n-\n-void context::call(void *f, void *arg, void *stack)\n-{\n-  // Get the current context, which we will then modify to call the\n-  // given function.\n-  swap(*this);\n-\n-  // set up the stack\n-  uint32_t *sp = (uint32_t *)stack;\n-  sp = align_down(sp);\n-  // The final return address. 0 indicates the bottom of the stack\n-  // sp of mips o32 is 8-byte aligned\n-  sp -= 2;\n-  *sp = 0;\n-\n-  regs.data[4] = (uint32_t)arg;\n-  regs.data[29] = (uint32_t)sp;\n-  regs.data[25] = (uint32_t)f;\n-  regs.data[31] = (uint32_t)f;\n-\n-  // Last base pointer on the stack should be 0\n-}"}, {"sha": "5e2364437ec2c1893bac7c502b043cbcdbfeb889", "filename": "src/rt/arch/mips/context.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fcontext.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,51 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef CONTEXT_H\n-#define CONTEXT_H\n-\n-#include <cstdlib>\n-#include <inttypes.h>\n-#include <stdint.h>\n-//#include <xmmintrin.h>\n-\n-#include \"vg/memcheck.h\"\n-\n-template<typename T>\n-T align_down(T sp)\n-{\n-    // There is no platform we care about that needs more than a\n-    // 16-byte alignment.\n-    return (T)((uint32_t)sp & ~(16 - 1));\n-}\n-\n-// The struct in which we store the saved data.  This is mostly the\n-// volatile registers and instruction pointer, but it also includes\n-// RCX/RDI which are used to pass arguments.  The indices for each\n-// register are found in \"regs.h\".  Note that the alignment must be\n-// 16 bytes so that SSE instructions can be used.\n-#include \"regs.h\"\n-struct registers_t {\n-    uint32_t data[RUSTRT_MAX];\n-} __attribute__((aligned(16)));\n-\n-class context {\n-public:\n-    registers_t regs;\n-\n-    context();\n-\n-    context *next;\n-\n-    void swap(context &out);\n-    void call(void *f, void *arg, void *sp);\n-};\n-\n-#endif"}, {"sha": "da2f515999fdabedec6bc41c0dd9419e2ebece24", "filename": "src/rt/arch/mips/gpr.cpp", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fgpr.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fgpr.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fgpr.cpp?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include \"gpr.h\"\n-\n-#define LOAD(n) do { \\\n-    uintptr_t tmp; \\\n-    asm(\".set noat; move %0, $\" #n : \"=r\" (tmp) :); \\\n-    this->r##n = tmp; \\\n-} while (0)\n-\n-void rust_gpr::load() {\n-              LOAD(1); LOAD(2); LOAD(3);\n-    LOAD(4); LOAD(5); LOAD(6); LOAD(7);\n-\n-    LOAD(8); LOAD(9); LOAD(10); LOAD(11);\n-    LOAD(12); LOAD(13); LOAD(14); LOAD(15);\n-\n-    LOAD(16); LOAD(17); LOAD(18); LOAD(19);\n-    LOAD(20); LOAD(21); LOAD(22); LOAD(23);\n-\n-    LOAD(24); LOAD(25); LOAD(26); LOAD(27);\n-    LOAD(28); LOAD(29); LOAD(30); LOAD(31);\n-}"}, {"sha": "b48c1d4e732a506c9021316d7b2121c289a8ea7f", "filename": "src/rt/arch/mips/gpr.h", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fgpr.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fgpr.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fgpr.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef GPR_H\n-#define GPR_H\n-\n-#include \"rust_gpr_base.h\"\n-\n-class rust_gpr : public rust_gpr_base {\n-public:\n-    uintptr_t r0, r1, r2, r3, r4, r5, r6, r7;\n-    uintptr_t r8,  r9, r10, r11, r12, r13, r14, r15;\n-    uintptr_t r16, r17, r18, r19, r20, r21, r22, r23;\n-    uintptr_t r24, r25, r26, r27, r28, r29, r30, r31;\n-\n-    inline uintptr_t get_fp() { return r30; }\n-    inline uintptr_t get_ip() { return r31; }\n-\n-    inline void set_fp(uintptr_t new_fp) { r30 = new_fp; }\n-    inline void set_ip(uintptr_t new_ip) { r31 = new_ip; }\n-\n-    void load();\n-};\n-\n-#endif"}, {"sha": "9cb6ece80ce31e2f1440488d48c283df23ee2d5c", "filename": "src/rt/arch/mips/morestack.S", "status": "modified", "additions": 9, "deletions": 46, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fmips%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fmips%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fmorestack.S?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -3,10 +3,11 @@\n .section        .note.GNU-stack, \"\", @progbits\n #endif\n \n+/* See i386/morestack.S for the lengthy, general explanation. */\n+\n .text\n \n-.globl upcall_new_stack\n-.globl upcall_del_stack\n+.globl rust_stack_exhausted\n .globl __morestack\n \n .hidden __morestack\n@@ -18,6 +19,10 @@ __morestack:\n         .set noreorder\n         .set nomacro\n \n+        // n.b. most of this is probably unnecessary. I know very little mips\n+        //      assembly, and I didn't have anything to test on, so I wasn't\n+        //      brave enough to try to trim this down.\n+\n         addiu $29, $29, -12\n         sw $31, 8($29)\n         sw $30, 4($29)\n@@ -45,53 +50,11 @@ __morestack:\n         move $6, $15     // The amount of stack needed\n \n         move $28, $23\n-        lw $25, %call16(upcall_new_stack)($23)\n-        jalr $25\n-        nop\n-\n-        // Pop the saved arguments\n-        lw $4, 16($29)\n-        lw $5, 20($29)\n-        lw $6, 24($29)\n-        lw $7, 28($29)\n-        addiu $29, $29, 32\n-\n-        lw $24, 8($30)     // Grab the return pointer.\n-        addiu $24, $24, 12 // Skip past the `lw`, `jr`, `addiu` in our parent frame\n-        move $29, $2       // Switch to the new stack.\n-\n-        // for PIC\n-        lw $2, 12($30)\n-        lw $25, 16($30)\n-\n-        move $28, $23\n-        jalr $24           // Reenter the caller function\n-        nop\n-\n-        // Switch back to the rust stack\n-        move $29, $30\n-\n-        // Save the return value\n-        addiu $29, $29, -24\n-        sw $2, 16($29)\n-        sw $3, 20($29)\n-\n-        move $28, $23\n-        lw $25, %call16(upcall_del_stack)($23)\n+        lw $25, %call16(rust_stack_exhausted)($23)\n         jalr $25\n         nop\n \n-        // Restore the return value\n-        lw $2, 16($29)\n-        lw $3, 20($29)\n-        addiu $29, $29, 24\n+        // the above function make sure that we never get here\n \n-        lw $31, 8($29)\n-        lw $30, 4($29)\n-        lw $23, 0($29)\n-        addiu $29, $29, 12\n-\n-        jr $31\n-        nop\n .end __morestack\n .cfi_endproc"}, {"sha": "a6dfa04edbbd7e18f3c046ef1cffa53383a3b1f2", "filename": "src/rt/arch/mips/record_sp.S", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fmips%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fmips%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Frecord_sp.S?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -38,15 +38,3 @@ get_sp_limit:\n         jr $31\n         nop\n .end get_sp_limit\n-\n-.globl get_sp\n-.align 2\n-.set nomips16\n-.ent get_sp\n-get_sp:\n-        .set noreorder\n-        .set nomacro\n-        move $2, $29\n-        jr $31\n-        nop\n-.end get_sp"}, {"sha": "2f38e1507ad0e6bb445fe9c1bf7b62da4cd16c29", "filename": "src/rt/arch/mips/regs.h", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fregs.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fregs.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fregs.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#define RUSTRT_MAX  32\n-\n-// ARG0 is the register in which the first argument goes.\n-// Naturally this depends on your operating system.\n-#define RUSTRT_ARG0_S r4\n-#define RUSTRT_ARG1_S r5\n-#define RUSTRT_ARG2_S r6\n-#define RUSTRT_ARG3_S r7"}, {"sha": "cd79884760777b02bf027749204d8b43faef9e98", "filename": "src/rt/arch/mips/sp.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fsp.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fmips%2Fsp.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fsp.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Getting the stack pointer and getting/setting sp limit.\n-\n-#ifndef SP_H\n-#define SP_H\n-\n-#include \"../../rust_globals.h\"\n-\n-// Gets a pointer to the vicinity of the current stack pointer\n-extern \"C\" uintptr_t get_sp();\n-\n-// Gets the pointer to the end of the Rust stack from a platform-\n-// specific location in the thread control block\n-extern \"C\" CDECL uintptr_t get_sp_limit();\n-\n-// Records the pointer to the end of the Rust stack in a platform-\n-// specific location in the thread control block\n-extern \"C\" CDECL void record_sp_limit(void *limit);\n-\n-#endif"}, {"sha": "a53b1c2d737298cdfe88dbf7e64d3acbb6625da2", "filename": "src/rt/arch/x86_64/_context.S", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fx86_64%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fx86_64%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2F_context.S?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -89,12 +89,6 @@ SWAP_REGISTERS:\n #if defined(__MINGW32__) || defined(_WINDOWS)\n         mov %rdi, (RUSTRT_RDI*8)(ARG0)\n         mov %rsi, (RUSTRT_RSI*8)(ARG0)\n-\n-        // Save stack range\n-        mov %gs:0x08, %r8\n-        mov %r8, (RUSTRT_ST1*8)(ARG0)\n-        mov %gs:0x10, %r9\n-        mov %r9, (RUSTRT_ST2*8)(ARG0)\n #endif\n \n         // Save 0th argument register:\n@@ -134,12 +128,6 @@ SWAP_REGISTERS:\n #if defined(__MINGW32__) || defined(_WINDOWS)\n         mov (RUSTRT_RDI*8)(ARG1), %rdi\n         mov (RUSTRT_RSI*8)(ARG1), %rsi\n-\n-        // Restore stack range\n-        mov (RUSTRT_ST1*8)(ARG1), %r8\n-        mov %r8, %gs:0x08\n-        mov (RUSTRT_ST2*8)(ARG1), %r9\n-        mov %r9, %gs:0x10\n #endif\n \n         // Restore 0th argument register:"}, {"sha": "dbee5bcdc90a3222e518d9d6fee72391c3a4de82", "filename": "src/rt/arch/x86_64/ccall.S", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fccall.S?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,59 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif\n-\n-/*\n-\tThe function for switching to the C stack.  It is called\n-\t__morestack because gdb allows any frame with that name to\n-\tmove the stack pointer to a different stack, which it usually\n-\tconsiders an error.\n-*/\n-\n-#include \"regs.h\"\n-\n-#define ARG0 RUSTRT_ARG0_S\n-#define ARG1 RUSTRT_ARG1_S\n-#define ARG2 RUSTRT_ARG2_S\n-\n-        .text\n-\n-#if defined(__APPLE__)\n-.globl ___morestack\n-.private_extern MORESTACK\n-___morestack:\n-#elif defined(_WIN32)\n-.globl __morestack\n-__morestack:\n-#else\n-.globl __morestack\n-.hidden __morestack\n-__morestack:\n-#endif\n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n-\t.cfi_startproc\n-#endif\n-\n-\tpush %rbp\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n-\t.cfi_def_cfa_offset 16\n-\t.cfi_offset %rbp, -16\n-#endif\n-\n-\tmov %rsp,%rbp          // save rsp\n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n-\t.cfi_def_cfa_register %rbp\n-#endif\n-\n-\tmov ARG2,%rsp          // switch stack\n-\tcall *ARG1             // invoke target address\n-\tmov %rbp,%rsp\n-\tpop %rbp\n-\n-\tret\n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n-\t.cfi_endproc\n-#endif"}, {"sha": "6a265dff76156a7969f2d741829e1d7e119df674", "filename": "src/rt/arch/x86_64/context.cpp", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fcontext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fcontext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fcontext.cpp?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"context.h\"\n-#include \"../../rust_globals.h\"\n-\n-extern \"C\" void CDECL swap_registers(registers_t *oregs,\n-                                     registers_t *regs);\n-\n-context::context()\n-{\n-    assert((void*)&regs == (void*)this);\n-}\n-\n-void context::swap(context &out)\n-{\n-    swap_registers(&out.regs, &regs);\n-}\n-\n-void context::call(void *f, void *arg, void *stack) {\n-  // Get the current context, which we will then modify to call the\n-  // given function.\n-  swap(*this);\n-\n-  // set up the stack\n-  uint64_t *sp = (uint64_t *)stack;\n-  sp = align_down(sp);\n-  // The final return address. 0 indicates the bottom of the stack\n-  *--sp = 0;\n-\n-  regs.data[RUSTRT_ARG0] = (uint64_t)arg;\n-  regs.data[RUSTRT_RSP] = (uint64_t)sp;\n-  regs.data[RUSTRT_IP] = (uint64_t)f;\n-\n-  // Last base pointer on the stack should be 0\n-  regs.data[RUSTRT_RBP] = 0;\n-}"}, {"sha": "b768a1fb7b089b12ddce0f4d111b5aa8c711ac77", "filename": "src/rt/arch/x86_64/context.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fcontext.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#ifndef CONTEXT_H\n-#define CONTEXT_H\n-\n-#include <cstdlib>\n-#include <inttypes.h>\n-#include <stdint.h>\n-#include <xmmintrin.h>\n-\n-#include \"vg/memcheck.h\"\n-\n-template<typename T>\n-T align_down(T sp)\n-{\n-    // There is no platform we care about that needs more than a\n-    // 16-byte alignment.\n-    return (T)((uint64_t)sp & ~(16 - 1));\n-}\n-\n-// The struct in which we store the saved data.  This is mostly the\n-// volatile registers and instruction pointer, but it also includes\n-// RCX/RDI which are used to pass arguments.  The indices for each\n-// register are found in \"regs.h\".  Note that the alignment must be\n-// 16 bytes so that SSE instructions can be used.\n-#include \"regs.h\"\n-struct registers_t {\n-    uint64_t data[RUSTRT_MAX];\n-} __attribute__((aligned(16)));\n-\n-class context {\n-public:\n-    registers_t regs;\n-\n-    context();\n-\n-    context *next;\n-\n-    void swap(context &out);\n-    void call(void *f, void *arg, void *sp);\n-};\n-\n-#endif"}, {"sha": "37247d1dfdc8b04a3ab550986e1b90ce17b9fc23", "filename": "src/rt/arch/x86_64/gpr.cpp", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fgpr.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fgpr.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fgpr.cpp?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include \"gpr.h\"\n-\n-#define LOAD(rn) do { \\\n-    uintptr_t tmp; \\\n-    asm(\"movq %%\" #rn \",%0\" : \"=r\" (tmp) :); \\\n-    this->rn = tmp; \\\n-} while (0)\n-\n-void rust_gpr::load() {\n-    LOAD(rax); LOAD(rbx); LOAD(rcx); LOAD(rdx);\n-    LOAD(rsi); LOAD(rdi); LOAD(rbp); LOAD(rsi);\n-    LOAD(r8);  LOAD(r9);  LOAD(r10); LOAD(r11);\n-    LOAD(r12); LOAD(r13); LOAD(r14); LOAD(r15);\n-}"}, {"sha": "18ef77dbba63198f0527281472fbe6118fe18a53", "filename": "src/rt/arch/x86_64/gpr.h", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fgpr.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fgpr.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fgpr.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// General-purpose registers. This structure is used during stack crawling.\n-\n-#ifndef GPR_H\n-#define GPR_H\n-\n-#include \"rust_gpr_base.h\"\n-\n-class rust_gpr : public rust_gpr_base {\n-public:\n-    uintptr_t rax, rbx, rcx, rdx, rsi, rdi, rbp, rip;\n-    uintptr_t  r8,  r9, r10, r11, r12, r13, r14, r15;\n-\n-    inline uintptr_t get_fp() { return rbp; }\n-    inline uintptr_t get_ip() { return rip; }\n-\n-    inline void set_fp(uintptr_t new_fp) { rbp = new_fp; }\n-    inline void set_ip(uintptr_t new_ip) { rip = new_ip; }\n-\n-    void load();\n-};\n-\n-#endif"}, {"sha": "d248d79d12147b623fc4d008e33de4c4d5b1bc6b", "filename": "src/rt/arch/x86_64/morestack.S", "status": "modified", "additions": 14, "deletions": 84, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -3,27 +3,23 @@\n .section\t.note.GNU-stack, \"\", @progbits\n #endif\n \n-/*\n-\t__morestack\n-\n-\tSee i386/morestack.S for the lengthy, general explanation.\n-*/\n+/* See i386/morestack.S for the lengthy, general explanation. */\n \n .text\n \n #if defined(__APPLE__)\n-#define UPCALL_NEW_STACK        _upcall_new_stack\n-#define UPCALL_DEL_STACK        _upcall_del_stack\n #define MORESTACK               ___morestack\n #else\n-#define UPCALL_NEW_STACK        upcall_new_stack\n-#define UPCALL_DEL_STACK        upcall_del_stack\n #define MORESTACK               __morestack\n #endif\n \n-.globl UPCALL_NEW_STACK\n-.globl UPCALL_DEL_STACK\n-.globl MORESTACK\n+#if defined(__APPLE__)\n+#define EXHAUSTED               _rust_stack_exhausted\n+#elif defined(__linux__) || defined(__FreeBSD__)\n+#define EXHAUSTED               rust_stack_exhausted@PLT\n+#else\n+#define EXHAUSTED               rust_stack_exhausted\n+#endif\n \n #if defined(__linux__) || defined(__FreeBSD__)\n \t.hidden MORESTACK\n@@ -37,8 +33,7 @@\n \t.type MORESTACK,@function\n #endif\n \n-\n-#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n+.globl MORESTACK\n MORESTACK:\n \t.cfi_startproc\n \n@@ -54,77 +49,12 @@ MORESTACK:\n \t// Calculate the CFA as on offset from %ebp\n \t.cfi_def_cfa_register %rbp\n \n-        subq $56, %rsp\n-\n-\t// Save argument registers of the original function\n-\tmovq %rdi,       (%rsp)\n-\tmovq %rsi,      8(%rsp)\n-\tmovq %rdx,     16(%rsp)\n-\tmovq %rcx,     24(%rsp)\n-\tmovq %r8,      32(%rsp)\n-\tmovq %r9,      40(%rsp)\n-\n-\t// Calculate the address of the stack arguments.\n-\t// We have the base pointer, __morestack's return address,\n-\t// and __morestack's caller's return address to skip\n-\tmovq %rbp, %rax\n-\taddq $24, %rax  // Base pointer, return address x2\n-\n-\t// The arguments to __morestack are passed in %r10 & %r11\n-\n-\tmovq %r11, %rdx // Size of stack arguments\n-\tmovq %rax, %rsi // Address of stack arguments\n-\tmovq %r10, %rdi // The amount of stack needed\n-\n-#ifdef __APPLE__\n-\tcall UPCALL_NEW_STACK\n-#endif\n-#ifdef __linux__\n-\tcall UPCALL_NEW_STACK@PLT\n-#endif\n-#ifdef __FreeBSD__\n-\tcall UPCALL_NEW_STACK@PLT\n-#endif\n-\n-\t// Pop the saved arguments\n-\tmovq      (%rsp), %rdi\n-\tmovq     8(%rsp), %rsi\n-\tmovq    16(%rsp), %rdx\n-\tmovq    24(%rsp), %rcx\n-\tmovq    32(%rsp), %r8\n-\tmovq    40(%rsp), %r9\n-\n-\taddq $56, %rsp\n-\n-        movq 8(%rbp),%r10       // Grab the return pointer.\n-        incq %r10               // Skip past the `ret` in our parent frame\n-        movq %rax,%rsp          // Switch to the new stack.\n-\n-        call *%r10              // Reenter the caller function\n-\n-\t// Switch back to the rust stack\n-\tmovq %rbp, %rsp\n-\n-\t// Save the return value\n-\tpushq %rax\n+        // re-align the stack\n+        subq $8, %rsp\n \n-#ifdef __APPLE__\n-\tcall UPCALL_DEL_STACK\n-#endif\n-#ifdef __linux__\n-\tcall UPCALL_DEL_STACK@PLT\n-#endif\n-#ifdef __FreeBSD__\n-\tcall UPCALL_DEL_STACK@PLT\n-#endif\n+        // kill this program\n+        call EXHAUSTED\n \n-\tpopq %rax // Restore the return value\n-\tpopq %rbp\n-\tret\n+        // the exhaustion function guarantees that it can't return\n \n \t.cfi_endproc\n-\n-#else\n-MORESTACK:\n-\tret\n-#endif"}, {"sha": "25160ca68a6b398d526f71e5c55492d24385706e", "filename": "src/rt/arch/x86_64/regs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fx86_64%2Fregs.h", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Farch%2Fx86_64%2Fregs.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fregs.h?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// This is loosely kept in sync with src/libstd/rt/context.rs\n+\n #define RUSTRT_RBX   0\n #define RUSTRT_RSP   1\n #define RUSTRT_RBP   2"}, {"sha": "764927759fe684bf17ca0996160340d21b5d5401", "filename": "src/rt/arch/x86_64/sp.h", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fsp.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Farch%2Fx86_64%2Fsp.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fsp.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,79 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Getting the stack pointer and getting/setting sp limit.\n-\n-#ifndef SP_H\n-#define SP_H\n-\n-#include \"../../rust_globals.h\"\n-\n-// Gets a pointer to the vicinity of the current stack pointer\n-extern \"C\" ALWAYS_INLINE uintptr_t get_sp() {\n-    uintptr_t sp;\n-    asm volatile (\n-        \"movq %%rsp, %0\"\n-        : \"=m\"(sp));\n-    return sp;\n-}\n-\n-// Gets the pointer to the end of the Rust stack from a platform-\n-// specific location in the thread control block\n-extern \"C\" CDECL ALWAYS_INLINE uintptr_t get_sp_limit() {\n-    uintptr_t limit;\n-\n-#if defined(__linux__)\n-    asm volatile (\n-        \"movq %%fs:112, %0\"\n-        : \"=r\"(limit));\n-#elif defined(__APPLE__)\n-    asm volatile (\n-        \"movq $0x60+90*8, %%rsi\\n\\t\"\n-        \"movq %%gs:(%%rsi), %0\"\n-        :  \"=r\"(limit)\n-        :: \"rsi\");\n-#elif defined(__FreeBSD__)\n-    asm volatile (\n-        \"movq %%fs:24, %0\"\n-        : \"=r\"(limit));\n-#elif defined(_WIN64)\n-    asm volatile (\n-        \"movq %%gs:0x28, %0\"\n-        : \"=r\"(limit));\n-#endif\n-\n-    return limit;\n-}\n-\n-// Records the pointer to the end of the Rust stack in a platform-\n-// specific location in the thread control block\n-extern \"C\" CDECL ALWAYS_INLINE void record_sp_limit(void *limit) {\n-#if defined(__linux__)\n-    asm volatile (\n-        \"movq %0, %%fs:112\"\n-        :: \"r\"(limit));\n-#elif defined(__APPLE__)\n-    asm volatile (\n-        \"movq $0x60+90*8, %%rsi\\n\\t\"\n-        \"movq %0, %%gs:(%%rsi)\"\n-        :: \"r\"(limit)\n-        :  \"rsi\");\n-#elif defined(__FreeBSD__)\n-    asm volatile (\n-        \"movq %0, %%fs:24\"\n-        :: \"r\"(limit));\n-#elif defined(_WIN64)\n-    asm volatile (\n-        \"movq %0, %%gs:0x28\"\n-        :: \"r\"(limit));\n-#endif\n-}\n-\n-#endif"}, {"sha": "755235a9138dc20771385bdf72ac5874f4e52d31", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -16,7 +16,6 @@\n #include \"memory_region.h\"\n #include \"boxed_region.h\"\n #include \"vg/valgrind.h\"\n-#include \"sp.h\"\n \n #include <time.h>\n \n@@ -340,22 +339,26 @@ rust_unlock_little_lock(lock_and_signal *lock) {\n     lock->unlock();\n }\n \n+typedef void(startfn)(void*, void*);\n+\n class raw_thread: public rust_thread {\n public:\n-    fn_env_pair fn;\n+    startfn *raw_start;\n+    void *rust_fn;\n+    void *rust_env;\n \n-    raw_thread(fn_env_pair fn) : fn(fn) { }\n+    raw_thread(startfn *raw_start, void *rust_fn, void *rust_env)\n+        : raw_start(raw_start), rust_fn(rust_fn), rust_env(rust_env) { }\n \n     virtual void run() {\n-        record_sp_limit(0);\n-        fn.f(fn.env, NULL);\n+        raw_start(rust_fn, rust_env);\n     }\n };\n \n extern \"C\" raw_thread*\n-rust_raw_thread_start(fn_env_pair *fn) {\n-    assert(fn);\n-    raw_thread *thread = new raw_thread(*fn);\n+rust_raw_thread_start(startfn *raw_start, void *rust_start, void *rust_env) {\n+    assert(raw_start && rust_start);\n+    raw_thread *thread = new raw_thread(raw_start, rust_start, rust_env);\n     thread->start();\n     return thread;\n }\n@@ -552,12 +555,6 @@ rust_get_global_args_ptr() {\n     return &global_args_ptr;\n }\n \n-// Used by i386 __morestack\n-extern \"C\" CDECL uintptr_t\n-rust_get_task() {\n-    return 0;\n-}\n-\n static lock_and_signal env_lock;\n \n extern \"C\" CDECL void"}, {"sha": "7ec2dda9cd40cf12eeb481dd468e25da1ed314b5", "filename": "src/rt/rust_gpr_base.h", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Frust_gpr_base.h", "raw_url": "https://github.com/rust-lang/rust/raw/d773a024a2976f2759235551a52101cd08b37cce/src%2Frt%2Frust_gpr_base.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_gpr_base.h?ref=d773a024a2976f2759235551a52101cd08b37cce", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Base class for architecture-specific general-purpose registers. This\n-// structure is used during stack crawling.\n-\n-#ifndef GPR_BASE_H\n-#define GPR_BASE_H\n-\n-#include <stdint.h>\n-\n-class rust_gpr_base {\n-public:\n-    // Returns the value of a register by number.\n-    inline uintptr_t &get(uint32_t i) {\n-        return reinterpret_cast<uintptr_t *>(this)[i];\n-    }\n-\n-    // Sets the value of a register by number.\n-    inline void set(uint32_t i, uintptr_t val) {\n-        reinterpret_cast<uintptr_t *>(this)[i] = val;\n-    }\n-};\n-\n-\n-#endif"}, {"sha": "3c6e2d68c2fed274be5979a70604f10bd40f4478", "filename": "src/rt/rust_test_helpers.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Frust_test_helpers.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Frust_test_helpers.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.cpp?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -11,7 +11,6 @@\n // Helper functions used only in tests\n \n #include \"rust_util.h\"\n-#include \"sync/rust_thread.h\"\n #include \"sync/lock_and_signal.h\"\n \n // These functions are used in the unit tests for C ABI calls."}, {"sha": "aa545c3cdba0842084f6ee5b209e6e9a3866ae52", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -181,7 +181,6 @@ rust_get_global_args_ptr\n rust_take_global_args_lock\n rust_drop_global_args_lock\n rust_get_test_int\n-rust_get_task\n rust_uv_get_loop_from_getaddrinfo_req\n rust_uv_spawn\n rust_uv_process_kill"}, {"sha": "a78153523d2529bde99ccaf83b2de4da7366fb33", "filename": "src/rt/sync/rust_thread.cpp", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Fsync%2Frust_thread.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Fsync%2Frust_thread.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Frust_thread.cpp?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -14,11 +14,7 @@\n \n const size_t default_stack_sz = 1024*1024;\n \n-rust_thread::rust_thread() : thread(0), stack_sz(default_stack_sz) {\n-}\n-\n-rust_thread::rust_thread(size_t stack_sz)\n-  : thread(0), stack_sz(stack_sz) {\n+rust_thread::rust_thread() : thread(0) {\n }\n \n rust_thread::~rust_thread() {\n@@ -40,10 +36,11 @@ rust_thread_start(void *ptr) {\n void\n rust_thread::start() {\n #if defined(__WIN32__)\n-   thread = CreateThread(NULL, stack_sz, rust_thread_start, this, 0, NULL);\n+   thread = CreateThread(NULL, default_stack_sz, rust_thread_start, this, 0, NULL);\n #else\n    // PTHREAD_STACK_MIN of some system is larger than default size\n    // so we check stack_sz to prevent assertion failure.\n+   size_t stack_sz = default_stack_sz;\n    if (stack_sz < PTHREAD_STACK_MIN) {\n       stack_sz = PTHREAD_STACK_MIN;\n    }"}, {"sha": "cad87e514b5c831f9f24d3d26738125dd1605059", "filename": "src/rt/sync/rust_thread.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Fsync%2Frust_thread.h", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Frt%2Fsync%2Frust_thread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Frust_thread.h?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -23,11 +23,9 @@ class rust_thread {\n #else\n     pthread_t thread;\n #endif\n-    size_t stack_sz;\n  public:\n \n     rust_thread();\n-    rust_thread(size_t stack_sz);\n     virtual ~rust_thread();\n \n     void start();"}, {"sha": "e6fe8615a96280c885c3a0971bed1bd492f2c3ec", "filename": "src/test/auxiliary/static_priv_by_default.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic_priv_by_default.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #[crate_type = \"lib\"];\n-#[no_std];\n \n static private: int = 0;\n pub static public: int = 0;"}, {"sha": "24a2b561a8b0b1962caac732b2b74efe695725d9", "filename": "src/test/compile-fail/static-priv-by-default.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-priv-by-default.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -10,8 +10,6 @@\n \n // aux-build:static_priv_by_default.rs\n \n-#[no_std];\n-\n extern mod static_priv_by_default;\n \n mod child {"}, {"sha": "8dd05cd00da2c510e102c267c3eba338e36e188a", "filename": "src/test/compile-fail/xcrate-private-by-default.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-private-by-default.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -10,14 +10,11 @@\n \n // aux-build:static_priv_by_default.rs\n \n-#[no_std]; // helps if debugging resolve\n-\n extern mod static_priv_by_default;\n \n fn foo<T>() {}\n \n-#[start]\n-fn main(_: int, _: **u8) -> int {\n+fn main() {\n     // Actual public items should be public\n     static_priv_by_default::a;\n     static_priv_by_default::b;\n@@ -49,6 +46,4 @@ fn main(_: int, _: **u8) -> int {\n     //~^ ERROR: struct `c` is private\n     foo::<static_priv_by_default::foo::d>();\n     //~^ ERROR: type `d` is private\n-\n-    3\n }"}, {"sha": "f69f53cecd47865570778b3b7f6cb412841297d6", "filename": "src/test/run-pass/no-std-xcrate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Ftest%2Frun-pass%2Fno-std-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d8330afb6c925d1092f27919f61d4ce6a3fb1d4/src%2Ftest%2Frun-pass%2Fno-std-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-std-xcrate.rs?ref=6d8330afb6c925d1092f27919f61d4ce6a3fb1d4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-fast\n+// xfail-test #9839\n // aux-build:no_std_crate.rs\n \n // This tests that crates which link to std can also be linked to crates with"}]}