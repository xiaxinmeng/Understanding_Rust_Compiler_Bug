{"sha": "f8c4f0ea9c96218dbc81081799e77875fbb071de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YzRmMGVhOWM5NjIxOGRiYzgxMDgxNzk5ZTc3ODc1ZmJiMDcxZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-23T14:46:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-23T14:46:19Z"}, "message": "auto merge of #8684 : michaelwoerister/rust/stepping_and_scope_fixes, r=jdm\n\nThis PR contains some code cleanup and the fix for issue #8670.\r\n~~I am not sure about issue #8442 (could not reproduce it). @jdm, could check after this is merged and possibly close the issue then?~~ (closed now)\r\n\r\nSome interesting facts: With this commit, it should be possible to compile libstd with `-Zdebug-info` (it does not work yet with `-Zextra-debug-info` but we are getting there). Switching debug info on increases the compile time for libstd by about 2 seconds.\r\n\r\n@catamorphism I get one failing test in rustpkg:\r\n`package_script_with_default_build` says: `task <unnamed> failed at 'Couldn't copy file', /home/mw/rust/src/librustpkg/tests.rs:689`\r\nWould you have any idea what that is about? Seems be something wrong on my machine...\r\n\r\nCheers,\r\nMichael\r\n\r\nFixes #8670", "tree": {"sha": "c1878218c299ef921985b11259b54c262729eb0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1878218c299ef921985b11259b54c262729eb0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8c4f0ea9c96218dbc81081799e77875fbb071de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8c4f0ea9c96218dbc81081799e77875fbb071de", "html_url": "https://github.com/rust-lang/rust/commit/f8c4f0ea9c96218dbc81081799e77875fbb071de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8c4f0ea9c96218dbc81081799e77875fbb071de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "943f9aaa4a0302cee1b28c2fec3f23fc1c43fd61", "url": "https://api.github.com/repos/rust-lang/rust/commits/943f9aaa4a0302cee1b28c2fec3f23fc1c43fd61", "html_url": "https://github.com/rust-lang/rust/commit/943f9aaa4a0302cee1b28c2fec3f23fc1c43fd61"}, {"sha": "0e8a64073c8d3f5493703ca0eba62b8b568c11ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8a64073c8d3f5493703ca0eba62b8b568c11ce", "html_url": "https://github.com/rust-lang/rust/commit/0e8a64073c8d3f5493703ca0eba62b8b568c11ce"}], "stats": {"total": 327, "additions": 191, "deletions": 136}, "files": [{"sha": "5e4c58b9321acdb079392811d2479c978f19540b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f8c4f0ea9c96218dbc81081799e77875fbb071de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c4f0ea9c96218dbc81081799e77875fbb071de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f8c4f0ea9c96218dbc81081799e77875fbb071de", "patch": "@@ -137,6 +137,13 @@ fn fcx_has_nonzero_span(fcx: &FunctionContext) -> bool {\n     }\n }\n \n+fn span_is_empty(opt_span: &Option<span>) -> bool {\n+    match *opt_span {\n+        None => true,\n+        Some(span) => *span.lo == 0 && *span.hi == 0\n+    }\n+}\n+\n struct StatRecorder<'self> {\n     ccx: @mut CrateContext,\n     name: &'self str,\n@@ -1624,6 +1631,13 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n         }\n     };\n     let uses_outptr = type_of::return_uses_outptr(ccx.tcx, substd_output_type);\n+\n+    let debug_context = if id != -1 && ccx.sess.opts.debuginfo && !span_is_empty(&sp) {\n+        Some(debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl))\n+    } else {\n+        None\n+    };\n+\n     let fcx = @mut FunctionContext {\n           llfn: llfndecl,\n           llenv: unsafe {\n@@ -1644,7 +1658,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n           span: sp,\n           path: path,\n           ccx: ccx,\n-          debug_context: None,\n+          debug_context: debug_context,\n     };\n     fcx.llenv = unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n@@ -1877,6 +1891,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                                param_substs,\n                                body.info(),\n                                Some(body.span));\n+\n     let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n \n     // Set the fixed stack segment flag if necessary.\n@@ -1885,10 +1900,6 @@ pub fn trans_closure(ccx: @mut CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n-    if ccx.sess.opts.debuginfo && fcx_has_nonzero_span(fcx) {\n-        debuginfo::create_function_metadata(fcx);\n-    }\n-\n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n     let bcx_top = fcx.entry_bcx.unwrap();\n@@ -1900,6 +1911,11 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     maybe_load_env(fcx);\n \n+    // Up until here, IR instructions for this function have explicitly not been annotated with\n+    // source code location, so we don't step into call setup code. From here on, source location\n+    // emitting should be enabled.\n+    debuginfo::start_emitting_source_locations(fcx);\n+\n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, et cetera) and those that do"}, {"sha": "f8f29ec47e426540d206597ca6b9c731c74dbf34", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 168, "deletions": 129, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/f8c4f0ea9c96218dbc81081799e77875fbb071de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c4f0ea9c96218dbc81081799e77875fbb071de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f8c4f0ea9c96218dbc81081799e77875fbb071de", "patch": "@@ -96,11 +96,9 @@ pub struct DebugContext {\n     priv crate_file: ~str,\n     priv llcontext: ContextRef,\n     priv builder: DIBuilderRef,\n-    priv curr_loc: (uint, uint),\n+    priv curr_loc: DebugLocation,\n     priv created_files: HashMap<~str, DIFile>,\n-    priv created_functions: HashMap<FunctionCacheKey, DISubprogram>,\n-    priv created_blocks: HashMap<ast::NodeId, DILexicalBlock>,\n-    priv created_types: HashMap<uint, DIType>\n+    priv created_types: HashMap<uint, DIType>,\n }\n \n impl DebugContext {\n@@ -113,32 +111,18 @@ impl DebugContext {\n             crate_file: crate,\n             llcontext: llcontext,\n             builder: builder,\n-            curr_loc: (0, 0),\n+            curr_loc: UnknownLocation,\n             created_files: HashMap::new(),\n-            created_functions: HashMap::new(),\n-            created_blocks: HashMap::new(),\n-            created_types: HashMap::new()\n+            created_types: HashMap::new(),\n         };\n     }\n }\n \n-#[deriving(Eq,IterBytes)]\n-struct FunctionCacheKey {\n-    // Use the address of the llvm function (FunctionContext::llfn) as key for the cache. This\n-    // nicely takes care of monomorphization, where two specializations will have the same\n-    // ast::NodeId but different llvm functions (each needing its own debug description).\n-    priv llfn: ValueRef\n-}\n-\n-impl FunctionCacheKey {\n-    fn for_function_context(fcx: &FunctionContext) -> FunctionCacheKey {\n-        FunctionCacheKey { llfn: fcx.llfn }\n-    }\n-}\n-\n pub struct FunctionDebugContext {\n     priv scope_map: HashMap<ast::NodeId, DIScope>,\n+    priv fn_metadata: DISubprogram,\n     priv argument_counter: uint,\n+    priv source_locations_enabled: bool,\n }\n \n /// Create any deferred debug metadata nodes\n@@ -194,7 +178,14 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n \n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let scope = create_function_metadata(bcx.fcx);\n+    let scope = bcx.fcx.debug_context.get_ref().fn_metadata;\n+\n+    let argument_index = {\n+        let counter = &mut bcx.fcx.debug_context.get_mut_ref().argument_counter;\n+        let argument_index = *counter;\n+        *counter += 1;\n+        argument_index as c_uint\n+    };\n \n     let var_metadata = do cx.sess.str_of(special_idents::self_).to_c_str().with_ref |name| {\n         unsafe {\n@@ -208,11 +199,11 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n                 type_metadata,\n                 false,\n                 0,\n-                1)\n+                argument_index)\n         }\n     };\n \n-    set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n+    set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n@@ -222,6 +213,7 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n \n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n     }\n+    set_debug_location(cx, UnknownLocation);\n }\n \n /// Creates debug information for the given function argument.\n@@ -243,7 +235,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n \n     let def_map = cx.tcx.def_map;\n     let file_metadata = file_metadata(cx, filename);\n-    let scope = create_function_metadata(fcx);\n+    let scope = bcx.fcx.debug_context.get_ref().fn_metadata;//create_function_metadata(fcx);\n \n     do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n \n@@ -284,7 +276,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n             }\n         };\n \n-        set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n+        set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n         unsafe {\n             let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                 DIB(cx),\n@@ -294,83 +286,88 @@ pub fn create_argument_metadata(bcx: @mut Block,\n \n             llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n         }\n+        set_debug_location(cx, UnknownLocation);\n     }\n }\n \n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id parameter is used to\n /// reliably find the correct visibility scope for the code position.\n-pub fn update_source_pos(fcx: &FunctionContext,\n-                         node_id: ast::NodeId,\n-                         span: span) {\n+pub fn set_source_location(fcx: &FunctionContext,\n+                           node_id: ast::NodeId,\n+                           span: span) {\n     let cx: &mut CrateContext = fcx.ccx;\n \n     if !cx.sess.opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n         return;\n     }\n \n-    debug!(\"update_source_pos: %s\", cx.sess.codemap.span_to_str(span));\n+    debug!(\"set_source_location: %s\", cx.sess.codemap.span_to_str(span));\n \n-    let loc = span_start(cx, span);\n-    let scope = scope_metadata(fcx, node_id, span);\n+    if fcx.debug_context.get_ref().source_locations_enabled {\n+        let loc = span_start(cx, span);\n+        let scope = scope_metadata(fcx, node_id, span);\n \n-    set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n+        set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n+    } else {\n+        set_debug_location(cx, UnknownLocation);\n+    }\n }\n \n-/// Creates debug information for the given function.\n-///\n-/// Adds the created metadata nodes directly to the crate's IR.\n-/// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n-    let cx = fcx.ccx;\n-    let cache_key = FunctionCacheKey::for_function_context(fcx);\n-\n-    match dbg_cx(cx).created_functions.find_copy(&cache_key) {\n-        Some(fn_metadata) => {\n-            assert!(fcx.debug_context.is_some());\n-            return fn_metadata;\n-        }\n-        None => { /* fallthrough */}\n+pub fn start_emitting_source_locations(fcx: &mut FunctionContext) {\n+    for debug_context in fcx.debug_context.mut_iter() {\n+        debug_context.source_locations_enabled = true;\n     }\n+}\n+\n+pub fn create_function_debug_context(cx: &mut CrateContext,\n+                                     fn_ast_id: ast::NodeId,\n+                                     param_substs: Option<@param_substs>,\n+                                     llfn: ValueRef) -> ~FunctionDebugContext {\n+    assert!(fn_ast_id != -1);\n \n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n-    let fnitem = cx.tcx.items.get_copy(&fcx.id);\n-    let (ident, fn_decl, generics, span) = match fnitem {\n+    let fnitem = cx.tcx.items.get_copy(&fn_ast_id);\n+    let (ident, fn_decl, generics, top_level_block, span) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n-                ast::item_fn(ref fn_decl, _, _, ref generics, _) => {\n-                    (item.ident, fn_decl, generics, item.span)\n+                ast::item_fn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                    (item.ident, fn_decl, generics, Some(top_level_block), item.span)\n+                }\n+                _ => {\n+                    cx.sess.span_bug(item.span,\n+                        \"create_function_debug_context: item bound to non-function\");\n                 }\n-                _ => fcx.ccx.sess.span_bug(item.span,\n-                                           \"create_function_metadata: item bound to non-function\")\n             }\n         }\n         ast_map::node_method(\n             @ast::method {\n                 decl: ref fn_decl,\n                 ident: ident,\n                 generics: ref generics,\n+                body: ref top_level_block,\n                 span: span,\n                 _\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, generics, span)\n+            (ident, fn_decl, generics, Some(top_level_block), span)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n-                ast::expr_fn_block(ref fn_decl, _) => {\n+                ast::expr_fn_block(ref fn_decl, ref top_level_block) => {\n                     let name = gensym_name(\"fn\");\n                     (name, fn_decl,\n                         // This is not quite right. It should actually inherit the generics of the\n                         // enclosing function.\n                         &empty_generics,\n+                        Some(top_level_block),\n                         expr.span)\n                 }\n-                _ => fcx.ccx.sess.span_bug(expr.span,\n-                        \"create_function_metadata: expected an expr_fn_block here\")\n+                _ => cx.sess.span_bug(expr.span,\n+                        \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n         ast_map::node_trait_method(\n@@ -379,34 +376,45 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                     decl: ref fn_decl,\n                     ident: ident,\n                     generics: ref generics,\n+                    body: ref top_level_block,\n                     span: span,\n                     _\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, generics, span)\n+            (ident, fn_decl, generics, Some(top_level_block), span)\n         }\n-        _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n+        ast_map::node_foreign_item(@ast::foreign_item {\n+                ident: ident,\n+                node: ast::foreign_item_fn(ref fn_decl, ref generics),\n+                span: span,\n+                _\n+            },\n+            _,\n+            _,\n+            _) => {\n+            (ident, fn_decl, generics, None, span)\n+        }\n+        _ => cx.sess.bug(fmt!(\"create_function_debug_context: unexpected sort of node: %?\", fnitem))\n     };\n \n-    debug!(\"create_function_metadata: %s, %s\",\n-           cx.sess.str_of(ident),\n-           cx.sess.codemap.span_to_str(span));\n-\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(fcx, fn_decl);\n+        let fn_signature = get_function_signature(cx, fn_ast_id, fn_decl, param_substs);\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n     // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n     let mut function_name = cx.sess.str_of(ident).to_owned();\n-    let template_parameters = get_template_parameters(fcx,\n-                                                      generics,\n-                                                      file_metadata,\n-                                                      &mut function_name);\n+    let template_parameters = if cx.sess.opts.extra_debuginfo {\n+        get_template_parameters(cx, generics, param_substs, file_metadata, &mut function_name)\n+    } else {\n+        ptr::null()\n+    };\n+\n+    let scope_line = get_scope_line(cx, top_level_block, loc.line);\n \n     let fn_metadata = do function_name.to_c_str().with_ref |function_name| {\n         unsafe {\n@@ -420,50 +428,32 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                 function_type_metadata,\n                 false,\n                 true,\n-                loc.line as c_uint,\n+                scope_line as c_uint,\n                 FlagPrototyped as c_uint,\n                 cx.sess.opts.optimize != session::No,\n-                fcx.llfn,\n+                llfn,\n                 template_parameters,\n                 ptr::null())\n         }\n     };\n \n-    dbg_cx(cx).created_functions.insert(cache_key, fn_metadata);\n-\n     // Initialize fn debug context (including scope map)\n-    {\n-        assert!(fcx.debug_context.is_none());\n-\n-        let mut fn_debug_context = ~FunctionDebugContext {\n-            scope_map: HashMap::new(),\n-            argument_counter: if fcx.llself.is_some() { 2 } else { 1 }\n-        };\n-\n-        let entry_block_id = fcx.entry_bcx.get_ref().node_info.get_ref().id;\n-        let entry_block = cx.tcx.items.get(&entry_block_id);\n-\n-        match *entry_block {\n-            ast_map::node_block(ref block) => {\n-                let scope_map = &mut fn_debug_context.scope_map;\n-                let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n-\n-                populate_scope_map(cx, arg_pats, block, fn_metadata, scope_map);\n-            }\n-            _ => cx.sess.span_bug(span,\n-                    fmt!(\"debuginfo::create_function_metadata() - \\\n-                         FunctionContext::entry_bcx::node_info points to wrong type of ast_map \\\n-                         entry. Expected: ast_map::node_block, actual: %?\", *entry_block))\n-        }\n-\n-        fcx.debug_context = Some(fn_debug_context);\n-    }\n+    let mut fn_debug_context = ~FunctionDebugContext {\n+        scope_map: HashMap::new(),\n+        fn_metadata: fn_metadata,\n+        argument_counter: 1,\n+        source_locations_enabled: false,\n+    };\n \n-    return fn_metadata;\n+    let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+    populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n-    fn get_function_signature(fcx: &FunctionContext, fn_decl: &ast::fn_decl) -> DIArray {\n-        let cx = fcx.ccx;\n+    return fn_debug_context;\n \n+    fn get_function_signature(cx: &mut CrateContext,\n+                              fn_ast_id: ast::NodeId,\n+                              fn_decl: &ast::fn_decl,\n+                              param_substs: Option<@param_substs>) -> DIArray {\n         if !cx.sess.opts.extra_debuginfo {\n             return create_DIArray(DIB(cx), []);\n         }\n@@ -476,8 +466,8 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                 signature.push(ptr::null());\n             }\n             _ => {\n-                let return_type = ty::node_id_to_type(cx.tcx, fcx.id);\n-                let return_type = match fcx.param_substs {\n+                let return_type = ty::node_id_to_type(cx.tcx, fn_ast_id);\n+                let return_type = match param_substs {\n                     None => return_type,\n                     Some(substs) => {\n                         ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, return_type)\n@@ -491,7 +481,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         // arguments types\n         for arg in fn_decl.inputs.iter() {\n             let arg_type = ty::node_id_to_type(cx.tcx, arg.pat.id);\n-            let arg_type = match fcx.param_substs {\n+            let arg_type = match param_substs {\n                 None => arg_type,\n                 Some(substs) => {\n                     ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, arg_type)\n@@ -504,14 +494,13 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         return create_DIArray(DIB(cx), signature);\n     }\n \n-    fn get_template_parameters(fcx: &FunctionContext,\n+    fn get_template_parameters(cx: &mut CrateContext,\n                                generics: &ast::Generics,\n+                               param_substs: Option<@param_substs>,\n                                file_metadata: DIFile,\n                                name_to_append_suffix_to: &mut ~str)\n                             -> DIArray {\n-        let cx = fcx.ccx;\n-\n-        let self_type = match fcx.param_substs {\n+        let self_type = match param_substs {\n             Some(@param_substs{ self_ty: self_type, _ }) => self_type,\n             _ => None\n         };\n@@ -561,7 +550,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         }\n \n         // Handle other generic parameters\n-        let actual_types = match fcx.param_substs {\n+        let actual_types = match param_substs {\n             Some(@param_substs { tys: ref types, _ }) => types,\n             None => {\n                 return create_DIArray(DIB(cx), template_params);\n@@ -600,10 +589,22 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n \n         return create_DIArray(DIB(cx), template_params);\n     }\n-}\n-\n-\n \n+    fn get_scope_line(cx: &CrateContext,\n+                      top_level_block: Option<&ast::Block>,\n+                      default: uint)\n+                   -> uint {\n+        match top_level_block {\n+            Some(&ast::Block { stmts: ref statements, _ }) if statements.len() > 0 => {\n+                span_start(cx, statements[0].span).line\n+            }\n+            Some(&ast::Block { expr: Some(@ref expr), _ }) => {\n+                span_start(cx, expr.span).line\n+            }\n+            _ => default\n+        }\n+    }\n+}\n \n //=-------------------------------------------------------------------------------------------------\n // Module-Internal debug info creation functions\n@@ -676,7 +677,7 @@ fn declare_local(bcx: @mut Block,\n         }\n     };\n \n-    set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n+    set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n@@ -1424,29 +1425,62 @@ fn type_metadata(cx: &mut CrateContext,\n         ty::ty_tup(ref elements) => {\n             tuple_metadata(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in type_metadata\")\n+        ty::ty_opaque_box => {\n+            cx.sess.span_note(span, \"debuginfo for ty_opaque_box NYI\");\n+            unimplemented_type_metadata(cx, t)\n+        }\n+        _ => cx.sess.bug(fmt!(\"debuginfo: unexpected type in type_metadata: %?\", sty))\n     };\n \n     dbg_cx(cx).created_types.insert(type_id, type_metadata);\n     return type_metadata;\n }\n \n-fn set_debug_location(cx: &mut CrateContext, scope: DIScope, line: uint, col: uint) {\n-    if dbg_cx(cx).curr_loc == (line, col) {\n+#[deriving(Eq)]\n+enum DebugLocation {\n+    KnownLocation { scope: DIScope, line: uint, col: uint },\n+    UnknownLocation\n+}\n+\n+impl DebugLocation {\n+    fn new(scope: DIScope, line: uint, col: uint) -> DebugLocation {\n+        KnownLocation {\n+            scope: scope,\n+            line: line,\n+            col: col,\n+        }\n+    }\n+}\n+\n+fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n+    if debug_location == dbg_cx(cx).curr_loc {\n         return;\n     }\n-    debug!(\"setting debug location to %u %u\", line, col);\n-    dbg_cx(cx).curr_loc = (line, col);\n \n-    let elems = ~[C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n-    unsafe {\n-        let dbg_loc = llvm::LLVMMDNodeInContext(\n-                dbg_cx(cx).llcontext,\n-                vec::raw::to_ptr(elems),\n-                elems.len() as c_uint);\n \n-        llvm::LLVMSetCurrentDebugLocation(cx.builder.B, dbg_loc);\n+    let metadata_node;\n+\n+    match debug_location {\n+        KnownLocation { scope, line, col } => {\n+            debug!(\"setting debug location to %u %u\", line, col);\n+            let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n+            unsafe {\n+                metadata_node = llvm::LLVMMDNodeInContext(dbg_cx(cx).llcontext,\n+                                                          vec::raw::to_ptr(elements),\n+                                                          elements.len() as c_uint);\n+            }\n+        }\n+        UnknownLocation => {\n+            debug!(\"clearing debug location \");\n+            metadata_node = ptr::null();\n+        }\n+    };\n+\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(cx.builder.B, metadata_node);\n     }\n+\n+    dbg_cx(cx).curr_loc = debug_location;\n }\n \n //=-------------------------------------------------------------------------------------------------\n@@ -1498,7 +1532,7 @@ fn assert_fcx_has_span(fcx: &FunctionContext) {\n // shadowing.\n fn populate_scope_map(cx: &mut CrateContext,\n                       arg_pats: &[@ast::pat],\n-                      fn_entry_block: &ast::Block,\n+                      fn_entry_block: Option<&ast::Block>,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n     let def_map = cx.tcx.def_map;\n@@ -1519,7 +1553,10 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n+    for &fn_entry_block in fn_entry_block.iter() {\n+        walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n+    }\n+\n \n     // local helper functions for walking the AST.\n \n@@ -1898,7 +1935,9 @@ fn populate_scope_map(cx: &mut CrateContext,\n                     do with_new_scope(cx, arm_span, scope_stack, scope_map) |cx,\n                                                                              scope_stack,\n                                                                              scope_map| {\n-                        walk_pattern(cx, arm_ref.pats[0], scope_stack, scope_map);\n+                        for &pat in arm_ref.pats.iter() {\n+                            walk_pattern(cx, pat, scope_stack, scope_map);\n+                        }\n \n                         for &@ref guard_exp in arm_ref.guard.iter() {\n                             walk_expr(cx, guard_exp, scope_stack, scope_map)"}, {"sha": "ab4fc8ed6d331b1129e957634fab907e4aaaaeea", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8c4f0ea9c96218dbc81081799e77875fbb071de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8c4f0ea9c96218dbc81081799e77875fbb071de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f8c4f0ea9c96218dbc81081799e77875fbb071de", "patch": "@@ -413,7 +413,7 @@ pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {\n            dest.to_str(bcx.ccx()));\n     let _indenter = indenter();\n \n-    debuginfo::update_source_pos(bcx.fcx, expr.id, expr.span);\n+    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n     let dest = {\n         if ty::type_is_voidish(ty) {\n@@ -485,7 +485,7 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_to_datum_unadjusted(expr=%s)\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n-    debuginfo::update_source_pos(bcx.fcx, expr.id, expr.span);\n+    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n     match ty::expr_kind(bcx.tcx(), bcx.ccx().maps.method_map, expr) {\n         ty::LvalueExpr => {"}]}