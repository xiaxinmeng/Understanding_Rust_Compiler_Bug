{"sha": "d3a112d68c74cbd02630f6c909071c94872c193f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYTExMmQ2OGM3NGNiZDAyNjMwZjZjOTA5MDcxYzk0ODcyYzE5M2Y=", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2021-04-03T21:01:49Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2021-04-04T17:48:31Z"}, "message": "Allow including `Self` kw references to `FindUsages`", "tree": {"sha": "11e69733680a21c3281d9825b867527034a0c5ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11e69733680a21c3281d9825b867527034a0c5ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3a112d68c74cbd02630f6c909071c94872c193f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a112d68c74cbd02630f6c909071c94872c193f", "html_url": "https://github.com/rust-lang/rust/commit/d3a112d68c74cbd02630f6c909071c94872c193f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3a112d68c74cbd02630f6c909071c94872c193f/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0924888cce5f48e0ea0dc7fd8641db92850ef660", "url": "https://api.github.com/repos/rust-lang/rust/commits/0924888cce5f48e0ea0dc7fd8641db92850ef660", "html_url": "https://github.com/rust-lang/rust/commit/0924888cce5f48e0ea0dc7fd8641db92850ef660"}], "stats": {"total": 43, "additions": 39, "deletions": 4}, "files": [{"sha": "02f5e514b53adfb002d6d7bfc03acdc492219058", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d3a112d68c74cbd02630f6c909071c94872c193f/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a112d68c74cbd02630f6c909071c94872c193f/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=d3a112d68c74cbd02630f6c909071c94872c193f", "patch": "@@ -4,10 +4,13 @@\n //! get a super-set of matches. Then, we we confirm each match using precise\n //! name resolution.\n \n-use std::{convert::TryInto, mem};\n+use std::{convert::TryInto, iter, mem};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n-use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n+use either::Either;\n+use hir::{\n+    DefWithBody, HasAttrs, HasSource, InFile, ModuleDef, ModuleSource, Semantics, Visibility,\n+};\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n@@ -295,17 +298,23 @@ impl Definition {\n     }\n \n     pub fn usages<'a>(&'a self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n-        FindUsages { def: self, sema, scope: None }\n+        FindUsages { def: self, sema, scope: None, include_self_kw_refs: false }\n     }\n }\n \n pub struct FindUsages<'a> {\n     def: &'a Definition,\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n+    include_self_kw_refs: bool,\n }\n \n impl<'a> FindUsages<'a> {\n+    pub fn include_self_kw_refs(mut self, include: bool) -> FindUsages<'a> {\n+        self.include_self_kw_refs = include;\n+        self\n+    }\n+\n     pub fn in_scope(self, scope: SearchScope) -> FindUsages<'a> {\n         self.set_scope(Some(scope))\n     }\n@@ -352,14 +361,22 @@ impl<'a> FindUsages<'a> {\n         };\n \n         let pat = name.as_str();\n+        let search_for_self = self.include_self_kw_refs;\n+\n         for (file_id, search_range) in search_scope {\n             let text = sema.db.file_text(file_id);\n             let search_range =\n                 search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(text.as_str())));\n \n             let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n-            for (idx, _) in text.match_indices(pat) {\n+            let matches = text.match_indices(pat).chain(if search_for_self {\n+                Either::Left(text.match_indices(\"Self\"))\n+            } else {\n+                Either::Right(iter::empty())\n+            });\n+\n+            for (idx, _) in matches {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n                     continue;\n@@ -413,6 +430,24 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, &name_ref) {\n+            Some(NameRefClass::Definition(Definition::SelfType(impl_))) => {\n+                let ty = impl_.self_ty(self.sema.db);\n+\n+                if let Some(adt) = ty.as_adt() {\n+                    if &Definition::ModuleDef(ModuleDef::Adt(adt)) == self.def {\n+                        let FileRange { file_id, range } =\n+                            self.sema.original_range(name_ref.syntax());\n+                        let reference = FileReference {\n+                            range,\n+                            name: ast::NameLike::NameRef(name_ref.clone()),\n+                            access: None,\n+                        };\n+                        return sink(file_id, reference);\n+                    }\n+                }\n+\n+                false\n+            }\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {"}]}