{"sha": "ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmN2M4YTE1OGY1YmIzNmUzZjViOTZlYWNjMTk2MDYxZThhYjlkMTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-21T04:33:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-21T04:33:15Z"}, "message": "Rollup merge of #69033 - jonas-schievink:resume-with-context, r=tmandry\n\nUse generator resume arguments in the async/await lowering\n\nThis removes the TLS requirement from async/await and enables it in `#![no_std]` crates.\n\nCloses https://github.com/rust-lang/rust/issues/56974\n\nI'm not confident the HIR lowering is completely correct, there seem to be quite a few undocumented invariants in there. The `async-std` and tokio test suites are passing with these changes though.", "tree": {"sha": "f480ee62934374e6458d5da35bf480d2e60336a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f480ee62934374e6458d5da35bf480d2e60336a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJedZkLCRBK7hj4Ov3rIwAAdHIIAH2VPppEJMTLEKnMgixrykIL\nVXupYjW4qqY156akr0MjAf6bjlVxp6B8Jf2qafMpKkBMVHdToUHwelyIFEZTTTGi\nq4wbNXDCF9+dZdWA9vXvWI3nB7/5wWak64XOieGnNxHQER68GuHOAzvgfY0QLDpo\nELdMdOsrBI63fyaht+YBJaRiE2KgkFKxWqFLi/9/acnITvR42qt1yX/u8tO5o7Nu\nlWp+oX9zhJfmbC8ULR/oJDeCVyAwjI5HhoWP5QdyLOBxifaJOBI9SPLkOvzXZoNp\nXTu9FOxZs5zzd/5gHigLLSz9Ew02ZFy7LBYtB1lWtoDqPehoERS2vAcdNXCsFhQ=\n=0Bzz\n-----END PGP SIGNATURE-----\n", "payload": "tree f480ee62934374e6458d5da35bf480d2e60336a2\nparent 4b91729df22015bd412f6fc0fa397785d1e2159c\nparent db0126a7c251f4cca39ad4c50527e88c97190992\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584765195 +0100\ncommitter GitHub <noreply@github.com> 1584765195 +0100\n\nRollup merge of #69033 - jonas-schievink:resume-with-context, r=tmandry\n\nUse generator resume arguments in the async/await lowering\n\nThis removes the TLS requirement from async/await and enables it in `#![no_std]` crates.\n\nCloses https://github.com/rust-lang/rust/issues/56974\n\nI'm not confident the HIR lowering is completely correct, there seem to be quite a few undocumented invariants in there. The `async-std` and tokio test suites are passing with these changes though.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "html_url": "https://github.com/rust-lang/rust/commit/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b91729df22015bd412f6fc0fa397785d1e2159c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b91729df22015bd412f6fc0fa397785d1e2159c", "html_url": "https://github.com/rust-lang/rust/commit/4b91729df22015bd412f6fc0fa397785d1e2159c"}, {"sha": "db0126a7c251f4cca39ad4c50527e88c97190992", "url": "https://api.github.com/repos/rust-lang/rust/commits/db0126a7c251f4cca39ad4c50527e88c97190992", "html_url": "https://github.com/rust-lang/rust/commit/db0126a7c251f4cca39ad4c50527e88c97190992"}], "stats": {"total": 240, "additions": 204, "deletions": 36}, "files": [{"sha": "8dfda7a4a32366447668ff4b6ed79662457be66e", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -2,6 +2,84 @@\n \n //! Asynchronous values.\n \n+#[cfg(not(bootstrap))]\n+use crate::{\n+    ops::{Generator, GeneratorState},\n+    pin::Pin,\n+    ptr::NonNull,\n+    task::{Context, Poll},\n+};\n+\n mod future;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::future::Future;\n+\n+/// This type is needed because:\n+///\n+/// a) Generators cannot implement `for<'a, 'b> Generator<&'a mut Context<'b>>`, so we need to pass\n+///    a raw pointer (see https://github.com/rust-lang/rust/issues/68923).\n+/// b) Raw pointers and `NonNull` aren't `Send` or `Sync`, so that would make every single future\n+///    non-Send/Sync as well, and we don't want that.\n+///\n+/// It also simplifies the HIR lowering of `.await`.\n+#[doc(hidden)]\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ResumeTy(NonNull<Context<'static>>);\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+unsafe impl Send for ResumeTy {}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+unsafe impl Sync for ResumeTy {}\n+\n+/// Wrap a generator in a future.\n+///\n+/// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n+/// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n+// This is `const` to avoid extra errors after we recover from `const async fn`\n+#[doc(hidden)]\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+#[inline]\n+pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n+where\n+    T: Generator<ResumeTy, Yield = ()>,\n+{\n+    struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n+\n+    // We rely on the fact that async/await futures are immovable in order to create\n+    // self-referential borrows in the underlying generator.\n+    impl<T: Generator<ResumeTy, Yield = ()>> !Unpin for GenFuture<T> {}\n+\n+    impl<T: Generator<ResumeTy, Yield = ()>> Future for GenFuture<T> {\n+        type Output = T::Return;\n+        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+            // Safety: Safe because we're !Unpin + !Drop, and this is just a field projection.\n+            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n+\n+            // Resume the generator, turning the `&mut Context` into a `NonNull` raw pointer. The\n+            // `.await` lowering will safely cast that back to a `&mut Context`.\n+            match gen.resume(ResumeTy(NonNull::from(cx).cast::<Context<'static>>())) {\n+                GeneratorState::Yielded(()) => Poll::Pending,\n+                GeneratorState::Complete(x) => Poll::Ready(x),\n+            }\n+        }\n+    }\n+\n+    GenFuture(gen)\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[cfg(not(bootstrap))]\n+#[inline]\n+pub unsafe fn poll_with_context<F>(f: Pin<&mut F>, mut cx: ResumeTy) -> Poll<F::Output>\n+where\n+    F: Future,\n+{\n+    F::poll(f, cx.0.as_mut())\n+}"}, {"sha": "a212f0a71077b32618db04b0f5ca676de90b4089", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 79, "deletions": 22, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -470,6 +470,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n+    /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n+    ///\n+    /// This results in:\n+    ///\n+    /// ```text\n+    /// std::future::from_generator(static move? |_task_context| -> <ret_ty> {\n+    ///     <body>\n+    /// })\n+    /// ```\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -480,17 +489,42 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n     ) -> hir::ExprKind<'hir> {\n         let output = match ret_ty {\n-            Some(ty) => FnRetTy::Ty(ty),\n-            None => FnRetTy::Default(span),\n+            Some(ty) => hir::FnRetTy::Return(self.lower_ty(&ty, ImplTraitContext::disallowed())),\n+            None => hir::FnRetTy::DefaultReturn(span),\n         };\n-        let ast_decl = FnDecl { inputs: vec![], output };\n-        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n-        let body_id = self.lower_fn_body(&ast_decl, |this| {\n+\n+        // Resume argument type. We let the compiler infer this to simplify the lowering. It is\n+        // fully constrained by `future::from_generator`.\n+        let input_ty = hir::Ty { hir_id: self.next_id(), kind: hir::TyKind::Infer, span };\n+\n+        // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n+        let decl = self.arena.alloc(hir::FnDecl {\n+            inputs: arena_vec![self; input_ty],\n+            output,\n+            c_variadic: false,\n+            implicit_self: hir::ImplicitSelfKind::None,\n+        });\n+\n+        // Lower the argument pattern/ident. The ident is used again in the `.await` lowering.\n+        let (pat, task_context_hid) = self.pat_ident_binding_mode(\n+            span,\n+            Ident::with_dummy_span(sym::_task_context),\n+            hir::BindingAnnotation::Mutable,\n+        );\n+        let param = hir::Param { attrs: &[], hir_id: self.next_id(), pat, span };\n+        let params = arena_vec![self; param];\n+\n+        let body_id = self.lower_body(move |this| {\n             this.generator_kind = Some(hir::GeneratorKind::Async(async_gen_kind));\n-            body(this)\n+\n+            let old_ctx = this.task_context;\n+            this.task_context = Some(task_context_hid);\n+            let res = body(this);\n+            this.task_context = old_ctx;\n+            (params, res)\n         });\n \n-        // `static || -> <ret_ty> { body }`:\n+        // `static |_task_context| -> <ret_ty> { body }`:\n         let generator_kind = hir::ExprKind::Closure(\n             capture_clause,\n             decl,\n@@ -523,13 +557,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// ```rust\n     /// match <expr> {\n     ///     mut pinned => loop {\n-    ///         match ::std::future::poll_with_tls_context(unsafe {\n-    ///             <::std::pin::Pin>::new_unchecked(&mut pinned)\n-    ///         }) {\n+    ///         match unsafe { ::std::future::poll_with_context(\n+    ///             <::std::pin::Pin>::new_unchecked(&mut pinned),\n+    ///             task_context,\n+    ///         ) } {\n     ///             ::std::task::Poll::Ready(result) => break result,\n     ///             ::std::task::Poll::Pending => {}\n     ///         }\n-    ///         yield ();\n+    ///         task_context = yield ();\n     ///     }\n     /// }\n     /// ```\n@@ -561,12 +596,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let (pinned_pat, pinned_pat_hid) =\n             self.pat_ident_binding_mode(span, pinned_ident, hir::BindingAnnotation::Mutable);\n \n-        // ::std::future::poll_with_tls_context(unsafe {\n-        //     ::std::pin::Pin::new_unchecked(&mut pinned)\n-        // })`\n+        let task_context_ident = Ident::with_dummy_span(sym::_task_context);\n+\n+        // unsafe {\n+        //     ::std::future::poll_with_context(\n+        //         ::std::pin::Pin::new_unchecked(&mut pinned),\n+        //         task_context,\n+        //     )\n+        // }\n         let poll_expr = {\n             let pinned = self.expr_ident(span, pinned_ident, pinned_pat_hid);\n             let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n+            let task_context = if let Some(task_context_hid) = self.task_context {\n+                self.expr_ident_mut(span, task_context_ident, task_context_hid)\n+            } else {\n+                // Use of `await` outside of an async context, we cannot use `task_context` here.\n+                self.expr_err(span)\n+            };\n             let pin_ty_id = self.next_id();\n             let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n                 pin_ty_id,\n@@ -575,14 +621,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 \"new_unchecked\",\n                 arena_vec![self; ref_mut_pinned],\n             );\n-            let new_unchecked =\n-                self.arena.alloc(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n-            let unsafe_expr = self.expr_unsafe(new_unchecked);\n-            self.expr_call_std_path(\n+            let new_unchecked = self.expr(span, new_unchecked_expr_kind, ThinVec::new());\n+            let call = self.expr_call_std_path(\n                 gen_future_span,\n-                &[sym::future, sym::poll_with_tls_context],\n-                arena_vec![self; unsafe_expr],\n-            )\n+                &[sym::future, sym::poll_with_context],\n+                arena_vec![self; new_unchecked, task_context],\n+            );\n+            self.arena.alloc(self.expr_unsafe(call))\n         };\n \n         // `::std::task::Poll::Ready(result) => break result`\n@@ -622,14 +667,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             self.stmt_expr(span, match_expr)\n         };\n \n+        // task_context = yield ();\n         let yield_stmt = {\n             let unit = self.expr_unit(span);\n             let yield_expr = self.expr(\n                 span,\n                 hir::ExprKind::Yield(unit, hir::YieldSource::Await),\n                 ThinVec::new(),\n             );\n-            self.stmt_expr(span, yield_expr)\n+            let yield_expr = self.arena.alloc(yield_expr);\n+\n+            if let Some(task_context_hid) = self.task_context {\n+                let lhs = self.expr_ident(span, task_context_ident, task_context_hid);\n+                let assign =\n+                    self.expr(span, hir::ExprKind::Assign(lhs, yield_expr, span), AttrVec::new());\n+                self.stmt_expr(span, assign)\n+            } else {\n+                // Use of `await` outside of an async context. Return `yield_expr` so that we can\n+                // proceed with type checking.\n+                self.stmt(span, hir::StmtKind::Semi(yield_expr))\n+            }\n         };\n \n         let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None);"}, {"sha": "c22b2812a9e3c43af282e70656bbd213f201c2b6", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -814,7 +814,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n+    crate fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n@@ -960,7 +960,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id\n     }\n \n-    fn lower_body(\n+    pub(super) fn lower_body(\n         &mut self,\n         f: impl FnOnce(&mut Self) -> (&'hir [hir::Param<'hir>], hir::Expr<'hir>),\n     ) -> hir::BodyId {"}, {"sha": "24fe51fc4d0d1290bcc8d57de4d043d09ac807f0", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -116,6 +116,10 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n+    /// When inside an `async` context, this is the `HirId` of the\n+    /// `task_context` local bound to the resume argument of the generator.\n+    task_context: Option<hir::HirId>,\n+\n     /// Used to get the current `fn`'s def span to point to when using `await`\n     /// outside of an `async fn`.\n     current_item: Option<Span>,\n@@ -294,6 +298,7 @@ pub fn lower_crate<'a, 'hir>(\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n+        task_context: None,\n         current_item: None,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,"}, {"sha": "f2194c77c8991aee23f6bf65bb12bd101bc741aa", "filename": "src/librustc_mir/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -64,13 +64,16 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n         };\n \n+        debug!(\n+            \"equate_inputs_and_outputs: normalized_input_tys = {:?}, local_decls = {:?}\",\n+            normalized_input_tys, body.local_decls\n+        );\n+\n         // Equate expected input tys with those in the MIR.\n         for (&normalized_input_ty, argument_index) in normalized_input_tys.iter().zip(0..) {\n             // In MIR, argument N is stored in local N+1.\n             let local = Local::new(argument_index + 1);\n \n-            debug!(\"equate_inputs_and_outputs: normalized_input_ty = {:?}\", normalized_input_ty);\n-\n             let mir_input_ty = body.local_decls[local].ty;\n             let mir_input_span = body.local_decls[local].source_info.span;\n             self.equate_normalized_input_or_output("}, {"sha": "35a97cfd3c3c21f98b7e8438f90acf43d550dffb", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -544,7 +544,7 @@ symbols! {\n         plugin_registrar,\n         plugins,\n         Poll,\n-        poll_with_tls_context,\n+        poll_with_context,\n         powerpc_target_feature,\n         precise_pointer_size_matching,\n         pref_align_of,\n@@ -720,6 +720,7 @@ symbols! {\n         target_has_atomic_load_store,\n         target_thread_local,\n         task,\n+        _task_context,\n         tbm_target_feature,\n         termination_trait,\n         termination_trait_test,"}, {"sha": "c0675eeba98da602fba6d31893d89578bb86d3e5", "filename": "src/libstd/future.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -1,12 +1,14 @@\n //! Asynchronous values.\n \n-use core::cell::Cell;\n-use core::marker::Unpin;\n-use core::ops::{Drop, Generator, GeneratorState};\n-use core::option::Option;\n-use core::pin::Pin;\n-use core::ptr::NonNull;\n-use core::task::{Context, Poll};\n+#[cfg(bootstrap)]\n+use core::{\n+    cell::Cell,\n+    marker::Unpin,\n+    ops::{Drop, Generator, GeneratorState},\n+    pin::Pin,\n+    ptr::NonNull,\n+    task::{Context, Poll},\n+};\n \n #[doc(inline)]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n@@ -17,22 +19,26 @@ pub use core::future::*;\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n // This is `const` to avoid extra errors after we recover from `const async fn`\n+#[cfg(bootstrap)]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n pub const fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T::Return> {\n     GenFuture(x)\n }\n \n /// A wrapper around generators used to implement `Future` for `async`/`await` code.\n+#[cfg(bootstrap)]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n struct GenFuture<T: Generator<Yield = ()>>(T);\n \n // We rely on the fact that async/await futures are immovable in order to create\n // self-referential borrows in the underlying generator.\n+#[cfg(bootstrap)]\n impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n \n+#[cfg(bootstrap)]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n@@ -48,12 +54,15 @@ impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     }\n }\n \n+#[cfg(bootstrap)]\n thread_local! {\n     static TLS_CX: Cell<Option<NonNull<Context<'static>>>> = Cell::new(None);\n }\n \n+#[cfg(bootstrap)]\n struct SetOnDrop(Option<NonNull<Context<'static>>>);\n \n+#[cfg(bootstrap)]\n impl Drop for SetOnDrop {\n     fn drop(&mut self) {\n         TLS_CX.with(|tls_cx| {\n@@ -64,13 +73,15 @@ impl Drop for SetOnDrop {\n \n // Safety: the returned guard must drop before `cx` is dropped and before\n // any previous guard is dropped.\n+#[cfg(bootstrap)]\n unsafe fn set_task_context(cx: &mut Context<'_>) -> SetOnDrop {\n     // transmute the context's lifetime to 'static so we can store it.\n     let cx = core::mem::transmute::<&mut Context<'_>, &mut Context<'static>>(cx);\n     let old_cx = TLS_CX.with(|tls_cx| tls_cx.replace(Some(NonNull::from(cx))));\n     SetOnDrop(old_cx)\n }\n \n+#[cfg(bootstrap)]\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Polls a future in the current thread-local task waker."}, {"sha": "0624c049048c70896535f2db2a5e58214aeb8719", "filename": "src/test/ui/async-await/issues/issue-62009-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009-1.stderr?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -33,10 +33,10 @@ error[E0277]: the trait bound `[closure@$DIR/issue-62009-1.rs:16:5: 16:15]: std:\n LL |     (|_| 2333).await;\n    |     ^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `[closure@$DIR/issue-62009-1.rs:16:5: 16:15]`\n    | \n-  ::: $SRC_DIR/libstd/future.rs:LL:COL\n+  ::: $SRC_DIR/libcore/future/mod.rs:LL:COL\n    |\n LL |     F: Future,\n-   |        ------ required by this bound in `std::future::poll_with_tls_context`\n+   |        ------ required by this bound in `std::future::poll_with_context`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "63e93cdff7e7729465df974e48e7a99cdebb994d", "filename": "src/test/ui/async-await/no-std.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Ftest%2Fui%2Fasync-await%2Fno-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10/src%2Ftest%2Fui%2Fasync-await%2Fno-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-std.rs?ref=ef7c8a158f5bb36e3f5b96eacc196061e8ab9d10", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+// check-pass\n+\n+#![no_std]\n+#![crate_type = \"rlib\"]\n+\n+use core::future::Future;\n+\n+async fn a(f: impl Future) {\n+    f.await;\n+}\n+\n+fn main() {}"}]}