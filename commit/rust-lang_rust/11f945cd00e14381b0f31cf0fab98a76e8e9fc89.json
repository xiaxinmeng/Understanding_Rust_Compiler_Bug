{"sha": "11f945cd00e14381b0f31cf0fab98a76e8e9fc89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZjk0NWNkMDBlMTQzODFiMGYzMWNmMGZhYjk4YTc2ZThlOWZjODk=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-13T04:55:18Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-13T04:55:18Z"}, "message": "Merge branch 'trpl_embedding' into rollup", "tree": {"sha": "4e53d596836bfef1f6a4d85596377722b5fb668e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e53d596836bfef1f6a4d85596377722b5fb668e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11f945cd00e14381b0f31cf0fab98a76e8e9fc89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11f945cd00e14381b0f31cf0fab98a76e8e9fc89", "html_url": "https://github.com/rust-lang/rust/commit/11f945cd00e14381b0f31cf0fab98a76e8e9fc89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11f945cd00e14381b0f31cf0fab98a76e8e9fc89/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "704fb9c2c98912ee1c2123a33470ecfce6d6dfa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/704fb9c2c98912ee1c2123a33470ecfce6d6dfa0", "html_url": "https://github.com/rust-lang/rust/commit/704fb9c2c98912ee1c2123a33470ecfce6d6dfa0"}, {"sha": "fc6372ea1f3ab98ab1a0252843a93a7045e95849", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc6372ea1f3ab98ab1a0252843a93a7045e95849", "html_url": "https://github.com/rust-lang/rust/commit/fc6372ea1f3ab98ab1a0252843a93a7045e95849"}], "stats": {"total": 354, "additions": 354, "deletions": 0}, "files": [{"sha": "584f24b54ada504aa7b873fe70c86b03005dae30", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11f945cd00e14381b0f31cf0fab98a76e8e9fc89/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/11f945cd00e14381b0f31cf0fab98a76e8e9fc89/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=11f945cd00e14381b0f31cf0fab98a76e8e9fc89", "patch": "@@ -7,6 +7,7 @@\n * [Learn Rust](learn-rust.md)\n     * [Guessing Game](guessing-game.md)\n     * [Dining Philosophers](dining-philosophers.md)\n+    * [Rust inside other languages](rust-inside-other-languages.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n     * [Testing](testing.md)"}, {"sha": "a1ae50a0c5396565b4298e0f365d3b04078d9740", "filename": "src/doc/trpl/rust-inside-other-languages.md", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/11f945cd00e14381b0f31cf0fab98a76e8e9fc89/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "raw_url": "https://github.com/rust-lang/rust/raw/11f945cd00e14381b0f31cf0fab98a76e8e9fc89/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md?ref=11f945cd00e14381b0f31cf0fab98a76e8e9fc89", "patch": "@@ -0,0 +1,353 @@\n+% Rust Inside Other Languages\n+\n+For our third project, we\u2019re going to choose something that shows off one of\n+Rust\u2019s greatest strengths: a lack of a substantial runtime.\n+\n+As organizations grow, they increasingly rely on a multitude of programming\n+languages. Different programming languages have different strengths and\n+weaknesses, and a polyglot stack lets you use a particular language where\n+its strengths make sense, and use a different language where it\u2019s weak.\n+\n+A very common area where many programming languages are weak is in runtime\n+performance of programs. Often, using a language that is slower, but offers\n+greater programmer productivity is a worthwhile trade-off. To help mitigate\n+this, they provide a way to write some of your system in C, and then call\n+the C code as though it were written in the higher-level language. This is\n+called a \u2018foreign function interface\u2019, often shortened to \u2018FFI\u2019.\n+\n+Rust has support for FFI in both directions: it can call into C code easily,\n+but crucially, it can also be called _into_ as easily as C. Combined with\n+Rust\u2019s lack of a garbage collector and low runtime requirements, this makes\n+Rust a great candidate to embed inside of other languages when you need\n+some extra oomph.\n+\n+There is a whole [chapter devoted to FFI][ffi] and its specifics elsewhere in\n+the book, but in this chapter, we\u2019ll examine this particular use-case of FFI,\n+with three examples, in Ruby, Python, and JavaScript.\n+\n+[ffi]: ffi.html\n+\n+# The problem\n+\n+There are many different projects we could choose here, but we\u2019re going to\n+pick an example where Rust has a clear advantage over many other languages:\n+numeric computing and threading.\n+\n+Many languages, for the sake of consistency, place numbers on the heap, rather\n+than on the stack. Especially in languages that focus on object-oriented\n+programming and use garbage collection, heap allocation is the default. Sometimes\n+optimizations can stack allocate particular numbers, but rather than relying\n+on an optimizer to do its job, we may want to ensure that we\u2019re always using\n+primitive number types rather than some sort of object type.\n+\n+Second, many languages have a \u2018global interpreter lock\u2019, which limits\n+concurrency in many situations. This is done in the name of safety, which is\n+a positive effect, but it limits the amount of work that can be done at the\n+same time, which is a big negative.\n+\n+To emphasize these two aspects, we\u2019re going to create a little project that\n+uses these two aspects heavily. Since the focus of the example is the embedding\n+of Rust into the languages, rather than the problem itself, we\u2019ll just use a\n+toy example:\n+\n+> Start ten threads. Inside each thread, count from one to five million. After\n+> All ten threads are finished, print out \u2018done!\u2019.\n+\n+I chose five million based on my particular computer. Here\u2019s an example of this\n+code in Ruby:\n+\n+```ruby\n+threads = []\n+\n+10.times do\n+  threads << Thread.new do\n+    count = 0\n+\n+    5_000_000.times do\n+      count += 1\n+    end\n+  end\n+end\n+\n+threads.each {|t| t.join }\n+puts \"done!\"\n+```\n+\n+Try running this example, and choose a number that runs for a few seconds.\n+Depending on your computer\u2019s hardware, you may have to increase or decrease the\n+number.\n+\n+On my system, running this program takes `2.156` seconds. And, if I use some\n+sort of process monitoring tool, like `top`, I can see that it only uses one\n+core on my machine. That\u2019s the GIL kicking in.\n+\n+While it\u2019s true that this is a synthetic program, one can imagine many problems\n+that are similar to this in the real world. For our purposes, spinning up some\n+busy threads represents some sort of parallel, expensive computation.\n+\n+# A Rust library\n+\n+Let\u2019s re-write this problem in Rust. First, let\u2019s make a new project with\n+Cargo:\n+\n+```bash\n+$ cargo new embed\n+$ cd embed\n+```\n+\n+This program is fairly easy to write in Rust:\n+\n+```rust\n+use std::thread;\n+\n+fn process() {\n+    let handles: Vec<_> = (0..10).map(|_| {\n+        thread::spawn(|| {\n+            let mut _x = 0;\n+            for _ in (0..5_000_001) {\n+                _x += 1\n+            }\n+        })\n+    }).collect();\n+\n+    for h in handles {\n+        h.join().ok().expect(\"Could not join a thread!\");\n+    }\n+}\n+```\n+\n+Some of this should look familiar from previous examples. We spin up ten\n+threads, collecting them into a `handles` vector. Inside of each thread, we\n+loop five million times, and add one to `_x` each time. Why the underscore?\n+Well, if we remove it and compile:\n+\n+```bash\n+$ cargo build\n+   Compiling embed v0.1.0 (file:///home/steve/src/embed)\n+src/lib.rs:3:1: 16:2 warning: function is never used: `process`, #[warn(dead_code)] on by default\n+src/lib.rs:3 fn process() {\n+src/lib.rs:4     let handles: Vec<_> = (0..10).map(|_| {\n+src/lib.rs:5         thread::spawn(|| {\n+src/lib.rs:6             let mut x = 0;\n+src/lib.rs:7             for _ in (0..5_000_001) {\n+src/lib.rs:8                 x += 1\n+             ...\n+src/lib.rs:6:17: 6:22 warning: variable `x` is assigned to, but never used, #[warn(unused_variables)] on by default\n+src/lib.rs:6             let mut x = 0;\n+                             ^~~~~\n+```\n+\n+That first warning is because we are building a library. If we had a test\n+for this function, the warning would go away. But for now, it\u2019s never\n+called.\n+\n+The second is related to `x` versus `_x`. Because we never actually _do_\n+anything with `x`, we get a warning about it. In our case, that\u2019s perfectly\n+okay, as we\u2019re just trying to waste CPU cycles. Prefixing `x` with the\n+underscore removes the warning.\n+\n+Finally, we join on each thread.\n+\n+Right now, however, this is a Rust library, and it doesn\u2019t expose anything\n+that\u2019s callable from C. If we tried to hook this up to another language right\n+now, it wouldn\u2019t work. We only need to make two small changes to fix this,\n+though. The first is modify the beginning of our code:\n+\n+```rust,ignore\n+#[no_mangle]\n+pub extern fn process() {\n+```\n+\n+We have to add a new attribute, `no_mangle`. When you create a Rust library, it\n+changes the name of the function in the compiled output. The reasons for this\n+are outside the scope of this tutorial, but in order for other languages to\n+know how to call the function, we need to not do that. This attribute turns\n+that behavior off.\n+\n+The other change is the `pub extern`. The `pub` means that this function should\n+be callable from outside of this module, and the `extern` says that it should\n+be able to be called from C. That\u2019s it! Not a whole lot of change.\n+\n+The second thing we need to do is to change a setting in our `Cargo.toml`. Add\n+this at the bottom:\n+\n+```toml\n+[lib]\n+name = \"embed\"\n+crate-type = [\"dylib\"]\n+```\n+\n+This tells Rust that we want to compile our library into a standard dynamic\n+library. By default, Rust compiles into an \u2018rlib\u2019, a Rust-specific format.\n+\n+Let\u2019s build the project now:\n+\n+```bash\n+$ cargo build --release\n+   Compiling embed v0.1.0 (file:///home/steve/src/embed)\n+```\n+\n+We\u2019ve chosen `cargo build --release`, which builds with optimizations on. We\n+want this to be as fast as possible! You can find the output of the library in\n+`target/release`:\n+\n+```bash\n+$ ls target/release/\n+build  deps  examples  libembed.so  native\n+```\n+\n+That `libembed.so` is our \u2018shared object\u2019 library. We can use this file\n+just like any shared object library written in C! As an aside, this may be\n+`embed.dll` or `libembed.dylib`, depending on the platform.\n+\n+Now that we\u2019ve got our Rust library built, let\u2019s use it from our Ruby.\n+\n+# Ruby\n+\n+Open up a `embed.rb` file inside of our project, and do this:\n+\n+```ruby\n+require 'ffi'\n+\n+module Hello\n+  extend FFI::Library\n+  ffi_lib 'target/release/libembed.so'\n+  attach_function :process, [], :void\n+end\n+\n+Hello.process\n+\n+puts \"done!\u201d\n+```\n+\n+Before we can run this, we need to install the `ffi` gem:\n+\n+```bash\n+$ gem install ffi # this may need sudo\n+Fetching: ffi-1.9.8.gem (100%)\n+Building native extensions.  This could take a while...\n+Successfully installed ffi-1.9.8\n+Parsing documentation for ffi-1.9.8\n+Installing ri documentation for ffi-1.9.8\n+Done installing documentation for ffi after 0 seconds\n+1 gem installed\n+```\n+\n+And finally, we can try running it:\n+\n+```bash\n+$ ruby embed.rb\n+done!\n+$\n+```\n+\n+Whoah, that was fast! On my system, this took `0.086` seconds, rather than\n+the two seconds the pure Ruby version took. Let\u2019s break down this Ruby\n+code:\n+\n+```ruby\n+require 'ffi'\n+```\n+\n+We first need to require the `ffi` gem. This lets us interface with our\n+Rust library like a C library.\n+\n+```ruby\n+module Hello\n+  extend FFI::Library\n+  ffi_lib 'target/release/libembed.so'\n+```\n+\n+The `ffi` gem\u2019s authors recommend using a module to scope the functions\n+we\u2019ll import from the shared library. Inside, we `extend` the necessary\n+`FFI::Library` module, and then call `ffi_lib` to load up our shared\n+object library. We just pass it the path that our library is stored,\n+which as we saw before, is `target/release/libembed.so`.\n+\n+```ruby\n+attach_function :process, [], :void\n+```\n+\n+The `attach_function` method is provided by the FFI gem. It\u2019s what\n+connects our `process()` function in Rust to a Ruby function of the\n+same name. Since `process()` takes no arguments, the second parameter\n+is an empty array, and since it returns nothing, we pass `:void` as\n+the final argument.\n+\n+```ruby\n+Hello.process\n+```\n+\n+This is the actual call into Rust. The combination of our `module`\n+and the call to `attach_function` sets this all up. It looks like\n+a Ruby function, but is actually Rust!\n+\n+```ruby\n+puts \"done!\"\n+```\n+\n+Finally, as per our project\u2019s requirements, we print out `done!`.\n+\n+That\u2019s it! As we\u2019ve seen, bridging between the two languages is really easy,\n+and buys us a lot of performance.\n+\n+Next, let\u2019s try Python!\n+\n+# Python\n+\n+Create an `embed.py` file in this directory, and put this in it:\n+\n+```python\n+from ctypes import cdll\n+\n+lib = cdll.LoadLibrary(\"target/release/libembed.so\")\n+\n+lib.process()\n+\n+print(\"done!\")\n+```\n+\n+Even easier! We use `cdll` from the `ctypes` module. A quick call\n+to `LoadLibrary` later, and we can call `process()`.\n+\n+On my system, this takes `0.017` seconds. Speedy!\n+\n+# Node.js\n+\n+Node isn\u2019t a language, but it\u2019s currently the dominant implementation of\n+server-side JavaScript.\n+\n+In order to do FFI with Node, we first need to install the library:\n+\n+```bash\n+$ npm install ffi\n+```\n+\n+After that installs, we can use it:\n+\n+```javascript\n+var ffi = require('ffi');\n+\n+var lib = ffi.Library('target/release/libembed', {\n+  'process': [ 'void', []  ]\n+});\n+\n+lib.process();\n+\n+console.log(\"done!\");\n+```\n+\n+It looks more like the Ruby example than the Python example. We use\n+the `ffi` module to get access to `ffi.Library()`, which loads up\n+our shared object. We need to annotate the return type and argument\n+types of the function, which are 'void' for return, and an empty\n+array to signify no arguments. From there, we just call it and\n+print the result.\n+\n+On my system, this takes a quick `0.092` seconds.\n+\n+# Conclusion\n+\n+As you can see, the basics of doing this are _very_ easy. Of course,\n+there's a lot more that we could do here. Check out the [FFI][ffi]\n+chapter for more details."}]}