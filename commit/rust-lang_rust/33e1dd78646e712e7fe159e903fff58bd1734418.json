{"sha": "33e1dd78646e712e7fe159e903fff58bd1734418", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZTFkZDc4NjQ2ZTcxMmU3ZmUxNTllOTAzZmZmNThiZDE3MzQ0MTg=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-08-27T01:32:14Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-09-24T15:14:35Z"}, "message": "Fix coherence checking for impl trait in type aliases\n\nFixes #63677\n\nRFC #2071 (impl-trait-existential-types) does not explicitly state how\nimpl trait type alises should interact with coherence. However, there's\nonly one choice which makes sense - coherence should look at the\nunderlying type (i.e. the 'defining' type of the impl trait) of the type\nalias, just like we do for non-impl-trait type aliases.\n\nSpecifically, impl trait type alises which resolve to a local type\nshould be treated like a local type with respect to coherence (e.g.\nimpl trait type aliases which resolve to a forieign type should be\ntreated as a foreign type, and those that resolve to a local type should\nbe treated as a local type).\n\nSince neither inherent impls nor direct trait impl (i.e. `impl MyType`\nor `impl MyTrait for MyType`) are allowd for type aliases, this\nusually does not come up. Before we ever attempt to do coherence\nchecking, we will have errored out if an impl trait type alias was used\ndirectly in an 'impl' clause.\n\nHowever, during trait selection, we sometimes need to prove bounds like\n'T: Sized' for some type 'T'. If 'T' is an impl trait type alias, this\nrequires to know the coherence behavior for impl trait type aliases when\nwe perform coherence checking.\n\nNote: Since determining the underlying type of an impl trait type alias\nrequires us to perform body type checking, this commit causes us to type\ncheck some bodies easlier than we otherwise would have. However, since\nthis is done through a query, this shouldn't cause any problems\n\nFor completeness, I've added an additional test of the coherence-related\nbehavior of impl trait type aliases.", "tree": {"sha": "829ab43b6b30fe4a41d7de84fed422181b846a2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/829ab43b6b30fe4a41d7de84fed422181b846a2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33e1dd78646e712e7fe159e903fff58bd1734418", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl2KMtsACgkQtAh+UQ6Y\nsWRcGRAAp+AS7tF4P5h/3wBgK/zYDEr8ofbzU12ON7DOirIwocrvqgKj7CAQerr7\nTmCwggaFX6uPh+AHFw+M+azyzCPNeVd/7ZbAgjsSRB5SQXxTcd2A16+wqji0sMdU\npxmXzrxoDv+hkt0pFapi7dy9Dhz48enfj/+x8hDRyYRis/9ysKFm9TiOTcy46sEs\n/AAjkqhWAQf2lQ7E36mA9MExTySagQEVkN0NaHoTsk4NG2cyxzgaVAuUOSFYt2ca\n6g+DAXCSIBDM9Omuhr1Ces2O3vOuQgNaqek5CTxDp0TZnf9S/A1iAqhlfxelqWC/\nVSiGdUN43b9/jN0LB1JTH/oD8qOu7HXBQrxxKJBggZNeOA+v0Bm6zxzDs1mUQf2b\nGN3KFx6+RmBMLxqy40AwK4XO562ZmjZbTzavnoWto0bhLnkq6fa7pRXwPRGpgypX\nv7oMqzfjtEPP5zqc1DA4bdIaBpnqQ6qGVjZt24nXuKoBxjYT8jFRCv5IKUr51fob\n+IpMxskIJGcSXy2nyYWh4nzI87m4E5wOVfsn2ecxfCasgL0ho4iSQastmXhYyiKS\nagF16kCRf2LsZyPNr5YU4nMOYougnDVVBiYJqWwqv8ErYu8aKmcnXyo2hetaDG6b\nfbpGRVqmuQCDlOZzl/Lvcath047KaSYQQocYaGyqeNvQKZJsl5U=\n=SR51\n-----END PGP SIGNATURE-----", "payload": "tree 829ab43b6b30fe4a41d7de84fed422181b846a2b\nparent 6ef275e6c3cb1384ec78128eceeb4963ff788dca\nauthor Aaron Hill <aa1ronham@gmail.com> 1566869534 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1569338075 -0400\n\nFix coherence checking for impl trait in type aliases\n\nFixes #63677\n\nRFC #2071 (impl-trait-existential-types) does not explicitly state how\nimpl trait type alises should interact with coherence. However, there's\nonly one choice which makes sense - coherence should look at the\nunderlying type (i.e. the 'defining' type of the impl trait) of the type\nalias, just like we do for non-impl-trait type aliases.\n\nSpecifically, impl trait type alises which resolve to a local type\nshould be treated like a local type with respect to coherence (e.g.\nimpl trait type aliases which resolve to a forieign type should be\ntreated as a foreign type, and those that resolve to a local type should\nbe treated as a local type).\n\nSince neither inherent impls nor direct trait impl (i.e. `impl MyType`\nor `impl MyTrait for MyType`) are allowd for type aliases, this\nusually does not come up. Before we ever attempt to do coherence\nchecking, we will have errored out if an impl trait type alias was used\ndirectly in an 'impl' clause.\n\nHowever, during trait selection, we sometimes need to prove bounds like\n'T: Sized' for some type 'T'. If 'T' is an impl trait type alias, this\nrequires to know the coherence behavior for impl trait type aliases when\nwe perform coherence checking.\n\nNote: Since determining the underlying type of an impl trait type alias\nrequires us to perform body type checking, this commit causes us to type\ncheck some bodies easlier than we otherwise would have. However, since\nthis is done through a query, this shouldn't cause any problems\n\nFor completeness, I've added an additional test of the coherence-related\nbehavior of impl trait type aliases.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33e1dd78646e712e7fe159e903fff58bd1734418", "html_url": "https://github.com/rust-lang/rust/commit/33e1dd78646e712e7fe159e903fff58bd1734418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33e1dd78646e712e7fe159e903fff58bd1734418/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ef275e6c3cb1384ec78128eceeb4963ff788dca", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef275e6c3cb1384ec78128eceeb4963ff788dca", "html_url": "https://github.com/rust-lang/rust/commit/6ef275e6c3cb1384ec78128eceeb4963ff788dca"}], "stats": {"total": 69, "additions": 63, "deletions": 6}, "files": [{"sha": "ee318b127ae661158edf977172aab4a491f65880", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=33e1dd78646e712e7fe159e903fff58bd1734418", "patch": "@@ -432,7 +432,7 @@ fn orphan_check_trait_ref<'tcx>(\n }\n \n fn uncovered_tys<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(ty, in_crate) {\n+    if ty_is_local_constructor(tcx, ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(ty) {\n         ty.walk_shallow()\n@@ -451,7 +451,7 @@ fn is_possibly_remote_type(ty: Ty<'_>, _in_crate: InCrate) -> bool {\n }\n \n fn ty_is_local(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n-    ty_is_local_constructor(ty, in_crate) ||\n+    ty_is_local_constructor(tcx, ty, in_crate) ||\n         fundamental_ty(ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }\n \n@@ -472,7 +472,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n     }\n }\n \n-fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n+fn ty_is_local_constructor(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n@@ -504,6 +504,15 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n \n         ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n+        ty::Opaque(did, _) => {\n+            // Check the underlying type that this opaque\n+            // type resolves to.\n+            // This recursion will eventually terminate,\n+            // since we've already managed to successfully\n+            // resolve all opaque types by this point\n+            let real_ty = tcx.type_of(did);\n+            ty_is_local_constructor(tcx, real_ty, in_crate)\n+        }\n \n         ty::Dynamic(ref tt, ..) => {\n             if let Some(principal) = tt.principal() {\n@@ -518,8 +527,7 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n         ty::UnnormalizedProjection(..) |\n         ty::Closure(..) |\n         ty::Generator(..) |\n-        ty::GeneratorWitness(..) |\n-        ty::Opaque(..) => {\n+        ty::GeneratorWitness(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "c9a40db41dfde03e9a53ee8328463c6003c37a95", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=33e1dd78646e712e7fe159e903fff58bd1734418", "patch": "@@ -395,7 +395,7 @@ impl<'tcx> Graph {\n     /// The parent of a given impl, which is the `DefId` of the trait when the\n     /// impl is a \"specialization root\".\n     pub fn parent(&self, child: DefId) -> DefId {\n-        *self.parent.get(&child).unwrap()\n+        *self.parent.get(&child).unwrap_or_else(|| panic!(\"Failed to get parent for {:?}\", child))\n     }\n }\n "}, {"sha": "52802dd8fbb477b5e1ec4150693d1ea7bb32e0d2", "filename": "src/test/ui/type-alias-impl-trait/auxiliary/foreign-crate.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs?ref=33e1dd78646e712e7fe159e903fff58bd1734418", "patch": "@@ -0,0 +1,2 @@\n+pub trait ForeignTrait {}\n+pub struct ForeignType<T>(pub T);"}, {"sha": "1c0f83d6c12da643ed6803a60db80bd303345c3a", "filename": "src/test/ui/type-alias-impl-trait/coherence.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs?ref=33e1dd78646e712e7fe159e903fff58bd1734418", "patch": "@@ -0,0 +1,17 @@\n+// aux-build:foreign-crate.rs\n+#![feature(type_alias_impl_trait)]\n+\n+extern crate foreign_crate;\n+\n+trait LocalTrait {}\n+impl<T> LocalTrait for foreign_crate::ForeignType<T> {}\n+\n+type AliasOfForeignType<T> = impl LocalTrait;\n+fn use_alias<T>(val: T) -> AliasOfForeignType<T> {\n+    foreign_crate::ForeignType(val)\n+}\n+\n+impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n+//~^ ERROR the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+\n+fn main() {}"}, {"sha": "6ede0fa14ba707abf6d2b180935d86e69d52ac19", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=33e1dd78646e712e7fe159e903fff58bd1734418", "patch": "@@ -0,0 +1,9 @@\n+error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/coherence.rs:14:6\n+   |\n+LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n+   |      ^ unconstrained type parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "28f4a85c9f29039b45a1391c184361e67a43e2e2", "filename": "src/test/ui/type-alias-impl-trait/issue-63677-type-alias-coherence.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33e1dd78646e712e7fe159e903fff58bd1734418/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs?ref=33e1dd78646e712e7fe159e903fff58bd1734418", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+// Regression test for issue #63677 - ensure that\n+// coherence checking can properly handle 'impl trait'\n+// in type aliases\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Trait {}\n+pub struct S1<T>(T);\n+pub struct S2<T>(T);\n+\n+pub type T1 = impl Trait;\n+pub type T2 = S1<T1>;\n+pub type T3 = S2<T2>;\n+\n+impl<T> Trait for S1<T> {}\n+impl<T: Trait> S2<T> {}\n+impl T3 {}\n+\n+pub fn use_t1() -> T1 { S1(()) }\n+\n+fn main() {}"}]}