{"sha": "677b7cad3d0ca1347f65ae9b409078343a5f302e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3N2I3Y2FkM2QwY2ExMzQ3ZjY1YWU5YjQwOTA3ODM0M2E1ZjMwMmU=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-12-31T03:10:46Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-05T20:00:57Z"}, "message": "Reformat metadata for exported macros\n\nInstead of copy-pasting the whole macro_rules! item from the original .rs file,\nwe serialize a separate name, attributes list, and body, the latter as\npretty-printed TTs.  The compilation of macro_rules! macros is decoupled\nsomewhat from the expansion of macros in item position.\n\nThis filters out comments, and facilitates selective imports.", "tree": {"sha": "014e59bc3d1295b22d98b2c923396c0683965c6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/014e59bc3d1295b22d98b2c923396c0683965c6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/677b7cad3d0ca1347f65ae9b409078343a5f302e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/677b7cad3d0ca1347f65ae9b409078343a5f302e", "html_url": "https://github.com/rust-lang/rust/commit/677b7cad3d0ca1347f65ae9b409078343a5f302e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/677b7cad3d0ca1347f65ae9b409078343a5f302e/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24aa7f0e387e2a04795e80bc91b8b8adf6a1c98f", "url": "https://api.github.com/repos/rust-lang/rust/commits/24aa7f0e387e2a04795e80bc91b8b8adf6a1c98f", "html_url": "https://github.com/rust-lang/rust/commit/24aa7f0e387e2a04795e80bc91b8b8adf6a1c98f"}], "stats": {"total": 276, "additions": 143, "deletions": 133}, "files": [{"sha": "de9a09ffe44c1ba33dddee1c55b41199e02dbe20", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -206,8 +206,8 @@ pub const tag_native_libraries_name: uint = 0x89;\n pub const tag_native_libraries_kind: uint = 0x8a;\n \n pub const tag_plugin_registrar_fn: uint = 0x8b;\n-pub const tag_exported_macros: uint = 0x8c;\n-pub const tag_macro_def: uint = 0x8d;\n+\n+// GAP 0x8c, 0x8d\n \n pub const tag_method_argument_names: uint = 0x8e;\n pub const tag_method_argument_name: uint = 0x8f;\n@@ -261,3 +261,7 @@ pub const tag_associated_type_names: uint = 0xb2;\n pub const tag_associated_type_name: uint = 0xb3;\n \n pub const tag_polarity: uint = 0xb4;\n+\n+pub const tag_macro_defs: uint = 0xb5;\n+pub const tag_macro_def: uint = 0xb6;\n+pub const tag_macro_def_body: uint = 0xb7;"}, {"sha": "3bf0e41ae9caa7eac3c40b93d4e6475f21156cb8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -29,8 +29,9 @@ use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{Span};\n+use syntax::codemap::{Span, mk_sp};\n use syntax::diagnostic::SpanHandler;\n+use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit;\n@@ -491,7 +492,36 @@ impl<'a> CrateReader<'a> {\n             }\n             None => { load_ctxt.report_load_errs(); unreachable!() },\n         };\n-        let macros = decoder::get_exported_macros(library.metadata.as_slice());\n+\n+        // Read exported macros\n+        let imported_from = Some(token::intern(info.ident[]).ident());\n+        let source_name = format!(\"<{} macros>\", info.ident[]);\n+        let mut macros = vec![];\n+        decoder::each_exported_macro(library.metadata.as_slice(), &*self.sess.cstore.intr,\n+            |name, attrs, body| {\n+                // NB: Don't use parse::parse_tts_from_source_str because it parses with\n+                // quote_depth > 0.\n+                let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n+                                                              self.sess.opts.cfg.clone(),\n+                                                              source_name.clone(),\n+                                                              body);\n+                let lo = p.span.lo;\n+                let body = p.parse_all_token_trees();\n+                let span = mk_sp(lo, p.last_span.hi);\n+                p.abort_if_errors();\n+                macros.push(ast::MacroDef {\n+                    ident: name.ident(),\n+                    attrs: attrs,\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: span,\n+                    imported_from: imported_from,\n+                    body: body,\n+                });\n+                true\n+            }\n+        );\n+\n+        // Look for a plugin registrar\n         let registrar = decoder::get_plugin_registrar_fn(library.metadata.as_slice()).map(|id| {\n             decoder::get_symbol(library.metadata.as_slice(), id)\n         });\n@@ -504,9 +534,11 @@ impl<'a> CrateReader<'a> {\n             // empty dylib.\n         }\n         let pc = PluginMetadata {\n-            lib: library.dylib.clone(),\n             macros: macros,\n-            registrar_symbol: registrar,\n+            registrar: match (library.dylib.as_ref(), registrar) {\n+                (Some(dylib), Some(reg)) => Some((dylib.clone(), reg)),\n+                _ => None,\n+            },\n         };\n         if should_link && self.existing_match(info.name[], None).is_none() {\n             // register crate now to avoid double-reading metadata"}, {"sha": "0e1fbcfcb891e7320e5fd26ec1fbe5562c791809", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -1353,15 +1353,16 @@ pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n \n-pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n-    let macros = reader::get_doc(rbml::Doc::new(data),\n-                                 tag_exported_macros);\n-    let mut result = Vec::new();\n+pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n+    F: FnMut(ast::Name, Vec<ast::Attribute>, String) -> bool,\n+{\n+    let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n-        result.push(macro_doc.as_str().to_string());\n-        true\n+        let name = item_name(intr, macro_doc);\n+        let attrs = get_attributes(macro_doc);\n+        let body = reader::get_doc(macro_doc, tag_macro_def_body);\n+        f(name, attrs, body.as_str().to_string())\n     });\n-    result\n }\n \n pub fn get_dylib_dependency_formats(cdata: Cmd)"}, {"sha": "37f0692631757d5e09ddafbb6f25bd8160279ba9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -42,6 +42,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n+use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -1818,25 +1819,21 @@ fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     }\n }\n \n-/// Given a span, write the text of that span into the output stream\n-/// as an exported macro\n-fn encode_macro_def(ecx: &EncodeContext,\n-                    rbml_w: &mut Encoder,\n-                    span: &syntax::codemap::Span) {\n-    let def = ecx.tcx.sess.codemap().span_to_snippet(*span)\n-        .expect(\"Unable to find source for macro\");\n-    rbml_w.start_tag(tag_macro_def);\n-    rbml_w.wr_str(def[]);\n-    rbml_w.end_tag();\n-}\n-\n /// Serialize the text of the exported macros\n-fn encode_macro_defs(ecx: &EncodeContext,\n-                     krate: &ast::Crate,\n-                     rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_exported_macros);\n-    for item in krate.exported_macros.iter() {\n-        encode_macro_def(ecx, rbml_w, &item.span);\n+fn encode_macro_defs(rbml_w: &mut Encoder,\n+                     krate: &ast::Crate) {\n+    rbml_w.start_tag(tag_macro_defs);\n+    for def in krate.exported_macros.iter() {\n+        rbml_w.start_tag(tag_macro_def);\n+\n+        encode_name(rbml_w, def.ident.name);\n+        encode_attributes(rbml_w, def.attrs[]);\n+\n+        rbml_w.start_tag(tag_macro_def_body);\n+        rbml_w.wr_str(pprust::tts_to_string(def.body[])[]);\n+        rbml_w.end_tag();\n+\n+        rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n }\n@@ -2154,7 +2151,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     // Encode macro definitions\n     i = rbml_w.writer.tell().unwrap();\n-    encode_macro_defs(&ecx, krate, &mut rbml_w);\n+    encode_macro_defs(&mut rbml_w, krate);\n     stats.macro_defs_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the types of all unboxed closures in this crate."}, {"sha": "9aa7d8fe9906d68e57e442b9d257e4edb9f3b4fa", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Used by `rustc` when loading a plugin.\n+//! Used by `rustc` when loading a plugin, or a crate with exported macros.\n \n use session::Session;\n use metadata::creader::CrateReader;\n@@ -21,17 +21,14 @@ use syntax::ast;\n use syntax::attr;\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::ext::expand::ExportedMacros;\n use syntax::attr::AttrMetaMethods;\n \n-/// Plugin-related crate metadata.\n+/// Metadata for a single plugin crate.\n pub struct PluginMetadata {\n-    /// Source code of macros exported by the crate.\n-    pub macros: Vec<String>,\n-    /// Path to the shared library file.\n-    pub lib: Option<Path>,\n-    /// Symbol name of the plugin registrar function.\n-    pub registrar_symbol: Option<String>,\n+    /// Macros exported by the crate.\n+    pub macros: Vec<ast::MacroDef>,\n+    /// Path to the shared library file, and registrar function symbol.\n+    pub registrar: Option<(Path, String)>,\n }\n \n /// Pointer to a registrar function.\n@@ -40,8 +37,8 @@ pub type PluginRegistrarFun =\n \n /// Information about loaded plugins.\n pub struct Plugins {\n-    /// Source code of exported macros.\n-    pub macros: Vec<ExportedMacros>,\n+    /// Imported macros.\n+    pub macros: Vec<ast::MacroDef>,\n     /// Registrars, as function pointers.\n     pub registrars: Vec<PluginRegistrarFun>,\n }\n@@ -90,7 +87,7 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n     fn visit_view_item(&mut self, vi: &ast::ViewItem) {\n         match vi.node {\n-            ast::ViewItemExternCrate(name, _, _) => {\n+            ast::ViewItemExternCrate(_, _, _) => {\n                 let mut plugin_phase = false;\n \n                 for attr in vi.attrs.iter().filter(|a| a.check_name(\"phase\")) {\n@@ -107,17 +104,13 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n \n                 if !plugin_phase { return; }\n \n-                let PluginMetadata { macros, lib, registrar_symbol } =\n+                let PluginMetadata { macros, registrar } =\n                     self.reader.read_plugin_metadata(vi);\n \n-                self.plugins.macros.push(ExportedMacros {\n-                    crate_name: name,\n-                    macros: macros,\n-                });\n+                self.plugins.macros.extend(macros.into_iter());\n \n-                match (lib, registrar_symbol) {\n-                    (Some(lib), Some(symbol))\n-                        => self.dylink_registrar(vi, lib, symbol),\n+                match registrar {\n+                    Some((lib, symbol)) => self.dylink_registrar(vi, lib, symbol),\n                     _ => (),\n                 }\n             }"}, {"sha": "ad67672ea6ea741a35dc916fe31c990ee0f183f2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                               None);\n         // attach the crate's exported macros to the top-level module:\n         self.module.macros = krate.exported_macros.iter()\n-            .map(|it| self.visit_macro(&**it)).collect();\n+            .map(|def| self.visit_macro(def)).collect();\n         self.module.is_crate = true;\n     }\n \n@@ -363,13 +363,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     // convert each exported_macro into a doc item\n-    fn visit_macro(&self, item: &ast::Item) -> Macro {\n+    fn visit_macro(&self, def: &ast::MacroDef) -> Macro {\n         Macro {\n-            id: item.id,\n-            attrs: item.attrs.clone(),\n-            name: item.ident,\n-            whence: item.span,\n-            stab: self.stability(item.id),\n+            id: def.id,\n+            attrs: def.attrs.clone(),\n+            name: def.ident,\n+            whence: def.span,\n+            stab: self.stability(def.id),\n         }\n     }\n }"}, {"sha": "36fc8a691dc30e94f6cddca70a24fb383ed572a7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -476,7 +476,7 @@ pub struct Crate {\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<P<Item>>\n+    pub exported_macros: Vec<MacroDef>,\n }\n \n pub type MetaItem = Spanned<MetaItem_>;\n@@ -1698,6 +1698,19 @@ pub enum InlinedItem {\n     IIForeign(P<ForeignItem>),\n }\n \n+/// A macro definition, in this crate or imported from another.\n+///\n+/// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+pub struct MacroDef {\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub imported_from: Option<Ident>,\n+    pub body: Vec<TokenTree>,\n+}\n+\n #[cfg(test)]\n mod test {\n     use serialize::json;"}, {"sha": "9a06745967f0d34ce57096355497069d413a9b77", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -28,19 +28,6 @@ use fold::Folder;\n use std::collections::HashMap;\n use std::rc::Rc;\n \n-// new-style macro! tt code:\n-//\n-//    MacResult, NormalTT, IdentTT\n-//\n-// also note that ast::Mac used to have a bunch of extraneous cases and\n-// is now probably a redundant AST node, can be merged with\n-// ast::MacInvocTT.\n-\n-pub struct MacroDef {\n-    pub name: String,\n-    pub ext: SyntaxExtension\n-}\n-\n pub trait ItemDecorator {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n@@ -140,13 +127,6 @@ impl<F> IdentMacroExpander for F\n /// methods are spliced into the AST at the callsite of the macro (or\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n-    /// Attempt to define a new macro.\n-    // this should go away; the idea that a macro might expand into\n-    // either a macro definition or an expression, depending on what\n-    // the context wants, is kind of silly.\n-    fn make_def(&mut self) -> Option<MacroDef> {\n-        None\n-    }\n     /// Create an expression.\n     fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n         None\n@@ -469,7 +449,7 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n-    pub exported_macros: Vec<P<ast::Item>>,\n+    pub exported_macros: Vec<ast::MacroDef>,\n \n     pub syntax_env: SyntaxEnv,\n     pub recursion_count: uint,"}, {"sha": "d56df2d7fb4e0f2af09980e28f3add1e5be576ec", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -432,7 +432,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n     }\n \n     let mut new_items = match it.node {\n-        ast::ItemMac(..) => expand_item_mac(it, None, fld),\n+        ast::ItemMac(..) => expand_item_mac(it, fld),\n         ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n             let valid_ident =\n                 it.ident.name != parse::token::special_idents::invalid.name;\n@@ -549,7 +549,6 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(it: P<ast::Item>,\n-                       imported_from: Option<ast::Ident>,\n                        fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n     let (extname, path_span, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n@@ -630,18 +629,20 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         }\n                     });\n                     // DON'T mark before expansion.\n-                    let MacroDef { name, ext }\n-                        = macro_rules::add_new_extension(fld.cx, it.span, it.ident,\n-                                                         imported_from, tts);\n-\n-                    fld.cx.syntax_env.insert(intern(name.as_slice()), ext);\n-\n-                    if match imported_from {\n-                        None => attr::contains_name(it.attrs.as_slice(), \"macro_export\"),\n-                        Some(_) => fld.cx.ecfg.reexported_macros.iter()\n-                                       .any(|e| e.as_slice() == name.as_slice()),\n-                    } {\n-                        fld.cx.exported_macros.push(it);\n+\n+                    let def = ast::MacroDef {\n+                        ident: it.ident,\n+                        attrs: it.attrs.clone(),\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: it.span,\n+                        imported_from: None,\n+                        body: tts,\n+                    };\n+                    let ext = macro_rules::compile(fld.cx, &def);\n+                    fld.cx.syntax_env.insert(def.ident.name, ext);\n+\n+                    if attr::contains_name(def.attrs.as_slice(), \"macro_export\") {\n+                        fld.cx.exported_macros.push(def);\n                     }\n \n                     // macro_rules! has a side effect but expands to nothing.\n@@ -680,9 +681,6 @@ pub fn expand_item_mac(it: P<ast::Item>,\n }\n \n /// Expand a stmt\n-//\n-// I don't understand why this returns a vector... it looks like we're\n-// half done adding machinery to allow macros to expand into multiple statements.\n fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let (mac, style) = match s.node {\n         StmtMac(mac, style) => (mac, style),\n@@ -1195,30 +1193,23 @@ impl ExpansionConfig {\n     }\n }\n \n-pub struct ExportedMacros {\n-    pub crate_name: Ident,\n-    pub macros: Vec<String>,\n-}\n-\n pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     cfg: ExpansionConfig,\n                     // these are the macros being imported to this crate:\n-                    imported_macros: Vec<ExportedMacros>,\n+                    imported_macros: Vec<ast::MacroDef>,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander::new(&mut cx);\n \n-    for ExportedMacros { crate_name, macros } in imported_macros.into_iter() {\n-        let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n+    for def in imported_macros.iter() {\n+        let ext = macro_rules::compile(expander.cx, def);\n+        expander.cx.syntax_env.insert(def.ident.name, ext);\n+\n+        if expander.cx.ecfg.reexported_macros.iter()\n+            .any(|e| e[] == token::get_ident(def.ident).get()) {\n \n-        for source in macros.into_iter() {\n-            let item = parse::parse_item_from_source_str(name.clone(),\n-                                                         source,\n-                                                         expander.cx.cfg(),\n-                                                         expander.cx.parse_sess())\n-                    .expect(\"expected a serialized item\");\n-            expand_item_mac(item, Some(crate_name), &mut expander);\n+            expander.cx.exported_macros.push(def.clone());\n         }\n     }\n "}, {"sha": "cf0d2c6474b2c76d5af845cedf5d6197aaf054e6", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -11,7 +11,7 @@\n use ast::{Ident, TtDelimited, TtSequence, TtToken};\n use ast;\n use codemap::{Span, DUMMY_SP};\n-use ext::base::{ExtCtxt, MacResult, MacroDef};\n+use ext::base::{ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n@@ -208,15 +208,9 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n //\n // Holy self-referential!\n \n-/// This procedure performs the expansion of the\n-/// macro_rules! macro. It parses the RHS and adds\n-/// an extension to the current context.\n-pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n-                              sp: Span,\n-                              name: Ident,\n-                              imported_from: Option<Ident>,\n-                              arg: Vec<ast::TokenTree> )\n-                              -> MacroDef {\n+/// Converts a `macro_rules!` invocation into a syntax extension.\n+pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n+                    def: &ast::MacroDef) -> SyntaxExtension {\n \n     let lhs_nm =  gensym_ident(\"lhs\");\n     let rhs_nm =  gensym_ident(\"rhs\");\n@@ -254,7 +248,7 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n     let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                    None,\n                                    None,\n-                                   arg.clone());\n+                                   def.body.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n                                      arg_reader,\n@@ -263,23 +257,20 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n     // Extract the arguments:\n     let lhses = match *argument_map[lhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n-        _ => cx.span_bug(sp, \"wrong-structured lhs\")\n+        _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n     let rhses = match *argument_map[rhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n-        _ => cx.span_bug(sp, \"wrong-structured rhs\")\n+        _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n \n     let exp = box MacroRulesMacroExpander {\n-        name: name,\n-        imported_from: imported_from,\n+        name: def.ident,\n+        imported_from: def.imported_from,\n         lhses: lhses,\n         rhses: rhses,\n     };\n \n-    MacroDef {\n-        name: token::get_ident(name).to_string(),\n-        ext: NormalTT(exp, Some(sp))\n-    }\n+    NormalTT(exp, Some(def.span))\n }"}, {"sha": "6b5d333ef8fc1bbee68ea94c26557be49e33d74b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -1115,7 +1115,7 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mu\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, exported_macros, span}: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_macros, span}: Crate,\n                                   folder: &mut T) -> Crate {\n     let config = folder.fold_meta_items(config);\n \n@@ -1146,6 +1146,10 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, exported_macros,\n         }, Vec::new(), span)\n     };\n \n+    for def in exported_macros.iter_mut() {\n+        def.id = folder.new_id(def.id);\n+    }\n+\n     Crate {\n         module: module,\n         attrs: attrs,"}, {"sha": "b0969a573e66b3cf35e1cb5a0573c079e85228de", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b7cad3d0ca1347f65ae9b409078343a5f302e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=677b7cad3d0ca1347f65ae9b409078343a5f302e", "patch": "@@ -169,6 +169,8 @@ pub fn parse_stmt_from_source_str(name: String,\n \n // Note: keep in sync with `with_hygiene::parse_tts_from_source_str`\n // until #16472 is resolved.\n+//\n+// Warning: This parses with quote_depth > 0, which is not the default.\n pub fn parse_tts_from_source_str(name: String,\n                                  source: String,\n                                  cfg: ast::CrateConfig,\n@@ -310,6 +312,8 @@ pub mod with_hygiene {\n \n     // Note: keep this in sync with `super::parse_tts_from_source_str` until\n     // #16472 is resolved.\n+    //\n+    // Warning: This parses with quote_depth > 0, which is not the default.\n     pub fn parse_tts_from_source_str(name: String,\n                                      source: String,\n                                      cfg: ast::CrateConfig,"}]}