{"sha": "eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "node_id": "C_kwDOAAsO6NoAKGVkYTJhNDAxNDU3YmE2NDVhMzJiZGM1YjllN2U5MDIxNGUzZTRlMjQ", "commit": {"author": {"name": "Matthew Kelly", "email": "matthew.kelly2@gmail.com", "date": "2022-08-31T23:39:39Z"}, "committer": {"name": "Matthew Kelly", "email": "matthew.kelly2@gmail.com", "date": "2022-08-31T23:39:39Z"}, "message": "Merge remote-tracking branch 'origin/master' into mpk/add-long-error-message-for-E0311", "tree": {"sha": "76c4a12cb26666f03aa37a81abe27782def16f1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76c4a12cb26666f03aa37a81abe27782def16f1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "html_url": "https://github.com/rust-lang/rust/commit/eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/comments", "author": {"login": "MatthewPeterKelly", "id": 8137529, "node_id": "MDQ6VXNlcjgxMzc1Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/8137529?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MatthewPeterKelly", "html_url": "https://github.com/MatthewPeterKelly", "followers_url": "https://api.github.com/users/MatthewPeterKelly/followers", "following_url": "https://api.github.com/users/MatthewPeterKelly/following{/other_user}", "gists_url": "https://api.github.com/users/MatthewPeterKelly/gists{/gist_id}", "starred_url": "https://api.github.com/users/MatthewPeterKelly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MatthewPeterKelly/subscriptions", "organizations_url": "https://api.github.com/users/MatthewPeterKelly/orgs", "repos_url": "https://api.github.com/users/MatthewPeterKelly/repos", "events_url": "https://api.github.com/users/MatthewPeterKelly/events{/privacy}", "received_events_url": "https://api.github.com/users/MatthewPeterKelly/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MatthewPeterKelly", "id": 8137529, "node_id": "MDQ6VXNlcjgxMzc1Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/8137529?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MatthewPeterKelly", "html_url": "https://github.com/MatthewPeterKelly", "followers_url": "https://api.github.com/users/MatthewPeterKelly/followers", "following_url": "https://api.github.com/users/MatthewPeterKelly/following{/other_user}", "gists_url": "https://api.github.com/users/MatthewPeterKelly/gists{/gist_id}", "starred_url": "https://api.github.com/users/MatthewPeterKelly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MatthewPeterKelly/subscriptions", "organizations_url": "https://api.github.com/users/MatthewPeterKelly/orgs", "repos_url": "https://api.github.com/users/MatthewPeterKelly/repos", "events_url": "https://api.github.com/users/MatthewPeterKelly/events{/privacy}", "received_events_url": "https://api.github.com/users/MatthewPeterKelly/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a443dfb8227d407ff3f0542cb6e688833708ba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a443dfb8227d407ff3f0542cb6e688833708ba9", "html_url": "https://github.com/rust-lang/rust/commit/4a443dfb8227d407ff3f0542cb6e688833708ba9"}, {"sha": "9243168fa5615ec8ebe9164c6bc2fdcccffd08b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9243168fa5615ec8ebe9164c6bc2fdcccffd08b6", "html_url": "https://github.com/rust-lang/rust/commit/9243168fa5615ec8ebe9164c6bc2fdcccffd08b6"}], "stats": {"total": 56906, "additions": 36214, "deletions": 20692}, "files": [{"sha": "ec1ef041b206812b6780ee67e177e5b6d40b6070", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -391,24 +391,28 @@ jobs:\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --set llvm.allow-old-toolchain\"\n               SCRIPT: make ci-mingw-subset-1\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: i686-mingw-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --set llvm.allow-old-toolchain\"\n               SCRIPT: make ci-mingw-subset-2\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: x86_64-mingw-1\n             env:\n               SCRIPT: make ci-mingw-subset-1\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler --set llvm.allow-old-toolchain\"\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: x86_64-mingw-2\n             env:\n               SCRIPT: make ci-mingw-subset-2\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler --set llvm.allow-old-toolchain\"\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: dist-x86_64-msvc\n@@ -427,12 +431,13 @@ jobs:\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: python x.py dist\n-              DIST_REQUIRE_ALL_TOOLS: 0\n+              DIST_REQUIRE_ALL_TOOLS: 1\n               WINDOWS_SDK_20348_HACK: 1\n             os: windows-latest-xl\n           - name: dist-i686-mingw\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler --set llvm.allow-old-toolchain\"\n+              NO_DOWNLOAD_CI_LLVM: 1\n               SCRIPT: python x.py dist\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n@@ -441,6 +446,7 @@ jobs:\n             env:\n               SCRIPT: python x.py dist\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler --set llvm.allow-old-toolchain\"\n+              NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl"}, {"sha": "b16fb6341c2e50a2f37f04e563017a588365a4d7", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -42,6 +42,7 @@ no_llvm_build\n /llvm/\n /mingw-build/\n /build/\n+/build-rust-analyzer/\n /dist/\n /unicode-downloads\n /target"}, {"sha": "bc2dd39774154e57094f09cad859b672e6452d2d", "filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -13,9 +13,6 @@\n [submodule \"src/doc/book\"]\n \tpath = src/doc/book\n \turl = https://github.com/rust-lang/book.git\n-[submodule \"src/tools/rls\"]\n-\tpath = src/tools/rls\n-\turl = https://github.com/rust-lang/rls.git\n [submodule \"src/tools/miri\"]\n \tpath = src/tools/miri\n \turl = https://github.com/rust-lang/miri.git"}, {"sha": "e040f73b9e1f7ecba73a62ac925c7bd45d2370af", "filename": ".reuse/dep5", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/.reuse%2Fdep5", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/.reuse%2Fdep5", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.reuse%2Fdep5?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,28 @@\n+Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\n+Files-Excluded:\n+ src/llvm-project\n+\n+Files: *\n+Copyright: The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: MIT or Apache-2.0\n+\n+Files: library/std/src/sync/mpsc/mpsc_queue.rs\n+       library/std/src/sync/mpsc/spsc_queue.rs\n+Copyright: 2010-2011 Dmitry Vyukov\n+License: BSD-2-Clause\n+\n+Files: src/librustdoc/html/static/fonts/FiraSans*\n+Copyright: 2014, Mozilla Foundation, 2014, Telefonica S.A.\n+License: OFL-1.1\n+\n+Files: src/librustdoc/html/static/fonts/NanumBarun*\n+Copyright: 2010 NAVER Corporation\n+License: OFL-1.1\n+\n+Files: src/librustdoc/html/static/fonts/SourceCodePro*\n+Copyright: 2010, 2012 Adobe Systems Incorporated\n+License: OFL-1.1\n+\n+Files: src/librustdoc/html/static/fonts/SourceSerif4*\n+Copyright: 2014-2021 Adobe Systems Incorporated\n+License: OFL-1.1"}, {"sha": "002d73be7d1de67d1a7718ed60a75c00eb5984fe", "filename": "Cargo.lock", "status": "modified", "additions": 71, "deletions": 478, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -79,7 +79,7 @@ dependencies = [\n  \"maplit\",\n  \"once_cell\",\n  \"tendril\",\n- \"url 2.2.2\",\n+ \"url\",\n ]\n \n [[package]]\n@@ -359,7 +359,7 @@ dependencies = [\n  \"openssl\",\n  \"os_info\",\n  \"pathdiff\",\n- \"percent-encoding 2.1.0\",\n+ \"percent-encoding\",\n  \"pretty_env_logger\",\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n@@ -376,7 +376,7 @@ dependencies = [\n  \"toml_edit\",\n  \"unicode-width\",\n  \"unicode-xid\",\n- \"url 2.2.2\",\n+ \"url\",\n  \"walkdir\",\n  \"winapi\",\n ]\n@@ -462,7 +462,7 @@ dependencies = [\n  \"tar\",\n  \"termcolor\",\n  \"toml_edit\",\n- \"url 2.2.2\",\n+ \"url\",\n  \"winapi\",\n ]\n \n@@ -665,15 +665,15 @@ dependencies = [\n  \"compiletest_rs\",\n  \"derive-new\",\n  \"filetime\",\n- \"futures 0.3.19\",\n+ \"futures\",\n  \"if_chain\",\n  \"itertools\",\n  \"parking_lot 0.12.1\",\n  \"quote\",\n  \"regex\",\n  \"rustc-semver\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util 0.2.0\",\n+ \"rustc_tools_util\",\n  \"semver\",\n  \"serde\",\n  \"syn\",\n@@ -718,7 +718,7 @@ dependencies = [\n  \"toml\",\n  \"unicode-normalization\",\n  \"unicode-script\",\n- \"url 2.2.2\",\n+ \"url\",\n ]\n \n [[package]]\n@@ -921,10 +921,10 @@ version = \"0.34.0\"\n dependencies = [\n  \"anyhow\",\n  \"curl\",\n- \"percent-encoding 2.1.0\",\n+ \"percent-encoding\",\n  \"serde\",\n  \"serde_json\",\n- \"url 2.2.2\",\n+ \"url\",\n ]\n \n [[package]]\n@@ -1093,17 +1093,6 @@ dependencies = [\n  \"syn\",\n ]\n \n-[[package]]\n-name = \"derive_more\"\n-version = \"0.99.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"298998b1cf6b5b2c8a7b023dfd45821825ce3ba8a8af55c921a0e734e4653f76\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"diff\"\n version = \"0.1.13\"\n@@ -1280,7 +1269,6 @@ name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustdoc\",\n- \"walkdir\",\n ]\n \n [[package]]\n@@ -1416,14 +1404,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5fc25a87fa4fd2094bffb06925852034d90a17f0d1e05197d4956d3555752191\"\n dependencies = [\n  \"matches\",\n- \"percent-encoding 2.1.0\",\n+ \"percent-encoding\",\n ]\n \n [[package]]\n name = \"fortanix-sgx-abi\"\n-version = \"0.3.3\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c56c422ef86062869b2d57ae87270608dc5929969dd130a6e248979cf4fb6ca6\"\n+checksum = \"57cafc2274c10fab234f176b25903ce17e690fca7597090d50880e047a0389c5\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -1441,12 +1429,6 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \n-[[package]]\n-name = \"fst\"\n-version = \"0.4.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d79238883cf0307100b90aba4a755d8051a3182305dfe7f649a1e9dc0517006f\"\n-\n [[package]]\n name = \"futf\"\n version = \"0.1.5\"\n@@ -1457,12 +1439,6 @@ dependencies = [\n  \"new_debug_unreachable\",\n ]\n \n-[[package]]\n-name = \"futures\"\n-version = \"0.1.31\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a471a38ef8ed83cd6e40aa59c1ffe17db6855c18e3604d9c4ed8c08ebc28678\"\n-\n [[package]]\n name = \"futures\"\n version = \"0.3.19\"\n@@ -1503,7 +1479,6 @@ dependencies = [\n  \"futures-core\",\n  \"futures-task\",\n  \"futures-util\",\n- \"num_cpus\",\n ]\n \n [[package]]\n@@ -1541,7 +1516,6 @@ version = \"0.3.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d9b5cf40b47a271f77a8b1bec03ca09044d99d2372c0de244e66430761127164\"\n dependencies = [\n- \"futures 0.1.31\",\n  \"futures-channel\",\n  \"futures-core\",\n  \"futures-io\",\n@@ -1652,29 +1626,29 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.14.2\"\n+version = \"0.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3826a6e0e2215d7a41c2bfc7c9244123969273f3476b939a226aac0ab56e9e3c\"\n+checksum = \"2994bee4a3a6a51eb90c218523be382fd7ea09b16380b9312e9dbe955ff7c7d1\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n  \"libgit2-sys\",\n  \"log\",\n  \"openssl-probe\",\n  \"openssl-sys\",\n- \"url 2.2.2\",\n+ \"url\",\n ]\n \n [[package]]\n name = \"git2-curl\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ee51709364c341fbb6fe2a385a290fb9196753bdde2fc45447d27cd31b11b13\"\n+checksum = \"ed817a00721e2f8037ba722e60358d4956dae9cca10315fc982f967907d3b0cd\"\n dependencies = [\n  \"curl\",\n  \"git2\",\n  \"log\",\n- \"url 2.2.2\",\n+ \"url\",\n ]\n \n [[package]]\n@@ -1815,17 +1789,6 @@ version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3c1ad908cc71012b7bea4d0c53ba96a8cba9962f048fa68d143376143d863b7a\"\n \n-[[package]]\n-name = \"idna\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e\"\n-dependencies = [\n- \"matches\",\n- \"unicode-bidi\",\n- \"unicode-normalization\",\n-]\n-\n [[package]]\n name = \"idna\"\n version = \"0.2.0\"\n@@ -1980,12 +1943,6 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"json\"\n-version = \"0.12.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"078e285eafdfb6c4b434e0d31e8cfcb5115b651496faca5749b88fafd4f23bfd\"\n-\n [[package]]\n name = \"jsondocck\"\n version = \"0.1.0\"\n@@ -2012,110 +1969,6 @@ dependencies = [\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"jsonrpc-client-transports\"\n-version = \"18.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d2b99d4207e2a04fb4581746903c2bb7eb376f88de9c699d0f3e10feeac0cd3a\"\n-dependencies = [\n- \"derive_more\",\n- \"futures 0.3.19\",\n- \"jsonrpc-core\",\n- \"jsonrpc-pubsub\",\n- \"jsonrpc-server-utils\",\n- \"log\",\n- \"parity-tokio-ipc\",\n- \"serde\",\n- \"serde_json\",\n- \"tokio\",\n- \"url 1.7.2\",\n-]\n-\n-[[package]]\n-name = \"jsonrpc-core\"\n-version = \"18.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"14f7f76aef2d054868398427f6c54943cf3d1caa9a7ec7d0c38d69df97a965eb\"\n-dependencies = [\n- \"futures 0.3.19\",\n- \"futures-executor\",\n- \"futures-util\",\n- \"log\",\n- \"serde\",\n- \"serde_derive\",\n- \"serde_json\",\n-]\n-\n-[[package]]\n-name = \"jsonrpc-core-client\"\n-version = \"18.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b51da17abecbdab3e3d4f26b01c5ec075e88d3abe3ab3b05dc9aa69392764ec0\"\n-dependencies = [\n- \"futures 0.3.19\",\n- \"jsonrpc-client-transports\",\n-]\n-\n-[[package]]\n-name = \"jsonrpc-derive\"\n-version = \"18.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5b939a78fa820cdfcb7ee7484466746a7377760970f6f9c6fe19f9edcc8a38d2\"\n-dependencies = [\n- \"proc-macro-crate\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"jsonrpc-ipc-server\"\n-version = \"18.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"382bb0206323ca7cda3dcd7e245cea86d37d02457a02a975e3378fb149a48845\"\n-dependencies = [\n- \"futures 0.3.19\",\n- \"jsonrpc-core\",\n- \"jsonrpc-server-utils\",\n- \"log\",\n- \"parity-tokio-ipc\",\n- \"parking_lot 0.11.2\",\n- \"tower-service\",\n-]\n-\n-[[package]]\n-name = \"jsonrpc-pubsub\"\n-version = \"18.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"240f87695e6c6f62fb37f05c02c04953cf68d6408b8c1c89de85c7a0125b1011\"\n-dependencies = [\n- \"futures 0.3.19\",\n- \"jsonrpc-core\",\n- \"lazy_static\",\n- \"log\",\n- \"parking_lot 0.11.2\",\n- \"rand 0.7.3\",\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"jsonrpc-server-utils\"\n-version = \"18.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fa4fdea130485b572c39a460d50888beb00afb3e35de23ccd7fad8ff19f0e0d4\"\n-dependencies = [\n- \"bytes\",\n- \"futures 0.3.19\",\n- \"globset\",\n- \"jsonrpc-core\",\n- \"lazy_static\",\n- \"log\",\n- \"tokio\",\n- \"tokio-stream\",\n- \"tokio-util\",\n- \"unicase\",\n-]\n-\n [[package]]\n name = \"kstring\"\n version = \"2.0.0\"\n@@ -2148,9 +2001,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.13.2+1.4.2\"\n+version = \"0.14.0+1.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a42de9a51a5c12e00fc0e4ca6bc2ea43582fc6418488e8f615e905d886f258b\"\n+checksum = \"47a00859c70c8a4f7218e6d1cc32875c4b55f6799445b842b0d8ed5e4c3d959b\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -2258,30 +2111,6 @@ dependencies = [\n  \"cfg-if 1.0.0\",\n ]\n \n-[[package]]\n-name = \"lsp-codec\"\n-version = \"0.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aa939d0b62476a5a19fb7fcb423a5c6ce8c7e09b851d37531e2fe3e0e6d9d257\"\n-dependencies = [\n- \"bytes\",\n- \"serde_json\",\n- \"tokio-util\",\n-]\n-\n-[[package]]\n-name = \"lsp-types\"\n-version = \"0.60.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fe3edefcd66dde1f7f1df706f46520a3c93adc5ca4bc5747da6621195e894efd\"\n-dependencies = [\n- \"bitflags\",\n- \"serde\",\n- \"serde_json\",\n- \"serde_repr\",\n- \"url 2.2.2\",\n-]\n-\n [[package]]\n name = \"lzma-sys\"\n version = \"0.1.16\"\n@@ -2415,9 +2244,9 @@ dependencies = [\n \n [[package]]\n name = \"minifier\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ac96d1e7a65f206443f95afff6de8f1690c77c97d6fc9c9bb2d2cd0662e9ff9f\"\n+checksum = \"8eb022374af2f446981254e6bf9efb6e2c9e1a53176d395fca02792fd4435729\"\n \n [[package]]\n name = \"minimal-lexical\"\n@@ -2446,19 +2275,6 @@ dependencies = [\n  \"adler 1.0.2\",\n ]\n \n-[[package]]\n-name = \"mio\"\n-version = \"0.7.14\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8067b404fe97c70829f082dec8bcf4f71225d7eaea1d8645349cb76fa06205cc\"\n-dependencies = [\n- \"libc\",\n- \"log\",\n- \"miow\",\n- \"ntapi\",\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"miow\"\n version = \"0.3.7\"\n@@ -2510,15 +2326,6 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"61807f77802ff30975e01f4f071c8ba10c022052f98b3294119f3e615d13e5be\"\n \n-[[package]]\n-name = \"ntapi\"\n-version = \"0.3.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f6bb902e437b6d86e03cce10a7e2af662292c5dfef23b65899ea3ac9354ad44\"\n-dependencies = [\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"num-integer\"\n version = \"0.1.43\"\n@@ -2647,12 +2454,6 @@ dependencies = [\n  \"vcpkg\",\n ]\n \n-[[package]]\n-name = \"ordslice\"\n-version = \"0.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd20eec3dbe4376829cb7d80ae6ac45e0a766831dca50202ff2d40db46a8a024\"\n-\n [[package]]\n name = \"os_info\"\n version = \"3.5.0\"\n@@ -2718,20 +2519,6 @@ dependencies = [\n  \"unwind\",\n ]\n \n-[[package]]\n-name = \"parity-tokio-ipc\"\n-version = \"0.9.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9981e32fb75e004cc148f5fb70342f393830e0a4aa62e3cc93b50976218d42b6\"\n-dependencies = [\n- \"futures 0.3.19\",\n- \"libc\",\n- \"log\",\n- \"rand 0.7.3\",\n- \"tokio\",\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"parking_lot\"\n version = \"0.11.2\"\n@@ -2786,12 +2573,6 @@ version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8835116a5c179084a830efb3adc117ab007512b535bc1a21c991d3b32a6b44dd\"\n \n-[[package]]\n-name = \"percent-encoding\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831\"\n-\n [[package]]\n name = \"percent-encoding\"\n version = \"2.1.0\"\n@@ -2961,15 +2742,6 @@ dependencies = [\n  \"log\",\n ]\n \n-[[package]]\n-name = \"proc-macro-crate\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d6ea3c4595b96363c13943497db34af4460fb474a95c43f4446ad341b8c9785\"\n-dependencies = [\n- \"toml\",\n-]\n-\n [[package]]\n name = \"proc-macro-error\"\n version = \"1.0.4\"\n@@ -3079,37 +2851,6 @@ dependencies = [\n  \"proc-macro2\",\n ]\n \n-[[package]]\n-name = \"racer\"\n-version = \"2.2.2\"\n-dependencies = [\n- \"bitflags\",\n- \"derive_more\",\n- \"env_logger 0.7.1\",\n- \"humantime 2.0.1\",\n- \"lazy_static\",\n- \"lazycell\",\n- \"log\",\n- \"racer-cargo-metadata\",\n- \"rls-span\",\n-]\n-\n-[[package]]\n-name = \"racer-cargo-metadata\"\n-version = \"0.1.2\"\n-dependencies = [\n- \"racer-interner\",\n- \"serde\",\n- \"serde_json\",\n-]\n-\n-[[package]]\n-name = \"racer-interner\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"rand\"\n version = \"0.7.3\"\n@@ -3295,68 +3036,18 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rls\"\n-version = \"1.41.0\"\n+name = \"replace-version-placeholder\"\n+version = \"0.1.0\"\n dependencies = [\n- \"anyhow\",\n- \"cargo\",\n- \"cargo-util\",\n- \"cargo_metadata 0.14.0\",\n- \"clippy_lints\",\n- \"crossbeam-channel\",\n- \"difference\",\n- \"env_logger 0.9.0\",\n- \"futures 0.3.19\",\n- \"heck\",\n- \"home\",\n- \"itertools\",\n- \"jsonrpc-core\",\n- \"lazy_static\",\n- \"log\",\n- \"lsp-codec\",\n- \"lsp-types\",\n- \"num_cpus\",\n- \"ordslice\",\n- \"racer\",\n- \"rand 0.8.5\",\n- \"rayon\",\n- \"regex\",\n- \"rls-analysis\",\n- \"rls-data\",\n- \"rls-ipc\",\n- \"rls-rustc\",\n- \"rls-span\",\n- \"rls-vfs\",\n- \"rustc-workspace-hack\",\n- \"rustc_tools_util 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-nightly\",\n- \"serde\",\n- \"serde_derive\",\n- \"serde_ignored\",\n- \"serde_json\",\n- \"tempfile\",\n- \"tokio\",\n- \"tokio-stream\",\n- \"tokio-util\",\n- \"toml\",\n- \"toml_edit\",\n- \"url 2.2.2\",\n+ \"tidy\",\n  \"walkdir\",\n ]\n \n [[package]]\n-name = \"rls-analysis\"\n-version = \"0.18.3\"\n+name = \"rls\"\n+version = \"2.0.0\"\n dependencies = [\n- \"derive-new\",\n- \"env_logger 0.9.0\",\n- \"fst\",\n- \"itertools\",\n- \"json\",\n- \"lazy_static\",\n- \"log\",\n- \"rls-data\",\n- \"rls-span\",\n+ \"rustc-workspace-hack\",\n  \"serde\",\n  \"serde_json\",\n ]\n@@ -3371,33 +3062,6 @@ dependencies = [\n  \"serde\",\n ]\n \n-[[package]]\n-name = \"rls-ipc\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"jsonrpc-core\",\n- \"jsonrpc-core-client\",\n- \"jsonrpc-derive\",\n- \"jsonrpc-ipc-server\",\n- \"rls-data\",\n- \"serde\",\n-]\n-\n-[[package]]\n-name = \"rls-rustc\"\n-version = \"0.6.0\"\n-dependencies = [\n- \"clippy_lints\",\n- \"env_logger 0.9.0\",\n- \"futures 0.3.19\",\n- \"log\",\n- \"rand 0.8.5\",\n- \"rls-data\",\n- \"rls-ipc\",\n- \"serde\",\n- \"tokio\",\n-]\n-\n [[package]]\n name = \"rls-span\"\n version = \"0.5.3\"\n@@ -3407,16 +3071,6 @@ dependencies = [\n  \"serde\",\n ]\n \n-[[package]]\n-name = \"rls-vfs\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ce4b57b25b4330ed5ec14028fc02141e083ddafda327e7eb598dc0569c8c83c9\"\n-dependencies = [\n- \"log\",\n- \"rls-span\",\n-]\n-\n [[package]]\n name = \"rust-demangler\"\n version = \"0.0.1\"\n@@ -3516,21 +3170,13 @@ name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n  \"bstr\",\n- \"byteorder\",\n  \"clap\",\n- \"crossbeam-utils\",\n- \"libc\",\n  \"libz-sys\",\n  \"memchr\",\n- \"proc-macro2\",\n- \"quote\",\n- \"rand_core 0.5.1\",\n  \"regex\",\n- \"serde\",\n  \"serde_json\",\n- \"smallvec\",\n  \"syn\",\n- \"url 2.2.2\",\n+ \"url\",\n  \"winapi\",\n ]\n \n@@ -3575,6 +3221,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_query_system\",\n  \"rustc_session\",\n@@ -3595,6 +3242,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n+ \"rustc_macros\",\n  \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -3686,6 +3334,7 @@ dependencies = [\n  \"libc\",\n  \"libloading\",\n  \"measureme\",\n+ \"object 0.29.0\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3721,7 +3370,6 @@ dependencies = [\n  \"object 0.29.0\",\n  \"pathdiff\",\n  \"regex\",\n- \"rustc_apfloat\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3819,6 +3467,7 @@ dependencies = [\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_log\",\n+ \"rustc_macros\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_parse\",\n@@ -3982,6 +3631,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n@@ -4212,11 +3862,14 @@ dependencies = [\n  \"regex\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_graphviz\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n@@ -4252,8 +3905,10 @@ name = \"rustc_monomorphize\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4320,6 +3975,7 @@ dependencies = [\n  \"rustc_ast\",\n  \"rustc_errors\",\n  \"rustc_lint\",\n+ \"rustc_macros\",\n  \"rustc_metadata\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4419,9 +4075,11 @@ dependencies = [\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4498,7 +4156,9 @@ dependencies = [\n  \"punycode\",\n  \"rustc-demangle\",\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4524,12 +4184,6 @@ dependencies = [\n name = \"rustc_tools_util\"\n version = \"0.2.0\"\n \n-[[package]]\n-name = \"rustc_tools_util\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b725dadae9fabc488df69a287f5a99c5eaf5d10853842a8a3dfac52476f544ee\"\n-\n [[package]]\n name = \"rustc_trait_selection\"\n version = \"0.0.0\"\n@@ -4597,6 +4251,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4835,18 +4490,18 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.140\"\n+version = \"1.0.143\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fc855a42c7967b7c369eb5860f7164ef1f6f81c20c7cc1141f2a604e18723b03\"\n+checksum = \"53e8e5d5b70924f74ff5c6d64d9a5acd91422117c60f48c4e07855238a254553\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.140\"\n+version = \"1.0.143\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f2122636b9fe3b81f1cb25099fcf2d3f542cdb1d45940d56c713158884a05da\"\n+checksum = \"d3d8e8de557aee63c26b85b947f5e59b690d0454c753f3adeb5cd7835ab88391\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -4864,27 +4519,16 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.82\"\n+version = \"1.0.83\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"82c2c1fdcd807d1098552c5b9a36e425e42e9fbd7c6a37a8425f390f781f7fa7\"\n+checksum = \"38dd04e3c8279e75b31ef29dbdceebfe5ad89f4d0937213c53f7d49d01b3d5a7\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n  \"ryu\",\n  \"serde\",\n ]\n \n-[[package]]\n-name = \"serde_repr\"\n-version = \"0.1.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2dc6b7951b17b051f3210b063f12cc17320e2fe30ae05b0fe2a3abb068551c76\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"sha-1\"\n version = \"0.8.2\"\n@@ -4940,15 +4584,6 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"42a568c8f2cd051a4d283bd6eb0343ac214c1b0f1ac19f93e1175b2dee38c73d\"\n \n-[[package]]\n-name = \"signal-hook-registry\"\n-version = \"1.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ce32ea0c6c56d5eacaeb814fbed9960547021d3edd010ded1425f180536b20ab\"\n-dependencies = [\n- \"libc\",\n-]\n-\n [[package]]\n name = \"similar\"\n version = \"2.1.0\"\n@@ -4991,9 +4626,9 @@ checksum = \"da73c8f77aebc0e40c300b93f0a5f1bece7a248a36eee287d4e095f35c7b7d6e\"\n \n [[package]]\n name = \"snapbox\"\n-version = \"0.2.9\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1f212b806d6f56d19838e36a0aaa7e79a0bc9ca177e873fb87651ad92f983e2\"\n+checksum = \"44d199ccf8f606592df2d145db26f2aa45344e23c64b074cc5a4047f1d99b0f7\"\n dependencies = [\n  \"concolor\",\n  \"content_inspector\",\n@@ -5009,9 +4644,9 @@ dependencies = [\n \n [[package]]\n name = \"snapbox-macros\"\n-version = \"0.2.1\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c01dea7e04cbb27ef4c86e9922184608185f7cd95c1763bc30d727cda4a5e930\"\n+checksum = \"8a253e6f894cfa440cba00600a249fa90869d8e0ec45ab274a456e043a0ce8f2\"\n \n [[package]]\n name = \"socket2\"\n@@ -5294,7 +4929,6 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n- \"crossbeam-utils\",\n  \"lazy_static\",\n  \"regex\",\n  \"walkdir\",\n@@ -5334,39 +4968,8 @@ checksum = \"50dae83881bc9b0403dd5b44ea9deed3e939856cc8722d5be37f0d6e5c6d53dd\"\n dependencies = [\n  \"autocfg\",\n  \"bytes\",\n- \"libc\",\n  \"memchr\",\n- \"mio\",\n- \"num_cpus\",\n- \"once_cell\",\n- \"pin-project-lite\",\n- \"signal-hook-registry\",\n- \"winapi\",\n-]\n-\n-[[package]]\n-name = \"tokio-stream\"\n-version = \"0.1.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7b2f3f698253f03119ac0102beaa64f67a67e08074d03a22d18784104543727f\"\n-dependencies = [\n- \"futures-core\",\n- \"pin-project-lite\",\n- \"tokio\",\n-]\n-\n-[[package]]\n-name = \"tokio-util\"\n-version = \"0.6.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1caa0b0c8d94a049db56b5acf8cba99dc0623aab1b26d5b5f5e2d945846b3592\"\n-dependencies = [\n- \"bytes\",\n- \"futures-core\",\n- \"futures-sink\",\n- \"log\",\n  \"pin-project-lite\",\n- \"tokio\",\n ]\n \n [[package]]\n@@ -5397,17 +5000,11 @@ version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aa7c7f42dea4b1b99439786f5633aeb9c14c1b53f75e282803c2ec2ad545873c\"\n \n-[[package]]\n-name = \"tower-service\"\n-version = \"0.3.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"360dfd1d6d30e05fda32ace2c8c70e9c0a9da713275777f5a4dbb8a1893930c6\"\n-\n [[package]]\n name = \"tracing\"\n-version = \"0.1.29\"\n+version = \"0.1.35\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"375a639232caf30edfc78e8d89b2d4c375515393e7af7e16f01cd96917fb2105\"\n+checksum = \"a400e31aa60b9d44a52a8ee0343b5b18566b03a8321e0d321f695cf56e940160\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"pin-project-lite\",\n@@ -5417,9 +5014,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.18\"\n+version = \"0.1.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f4f480b8f81512e825f337ad51e94c1eb5d3bbdf2b363dcd01e2b19a9ffe3f8e\"\n+checksum = \"11c75893af559bc8e10716548bdef5cb2b983f8e637db9d0e15126b61b484ee2\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5428,11 +5025,12 @@ dependencies = [\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.21\"\n+version = \"0.1.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1f4ed65637b8390770814083d20756f87bfa2c21bf2f110babdc5438351746e4\"\n+checksum = \"7b7358be39f2f274f322d2aaed611acc57f382e8eb1e5b48cb9ae30933495ce7\"\n dependencies = [\n- \"lazy_static\",\n+ \"once_cell\",\n+ \"valuable\",\n ]\n \n [[package]]\n@@ -5726,27 +5324,16 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"url\"\n-version = \"1.7.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd4e7c0d531266369519a4aa4f399d748bd37043b00bde1e4ff1f60a120b355a\"\n-dependencies = [\n- \"idna 0.1.5\",\n- \"matches\",\n- \"percent-encoding 1.0.1\",\n-]\n-\n [[package]]\n name = \"url\"\n version = \"2.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a507c383b2d33b5fc35d1861e77e6b383d158b2da5e14fe51b83dfedf6fd578c\"\n dependencies = [\n  \"form_urlencoded\",\n- \"idna 0.2.0\",\n+ \"idna\",\n  \"matches\",\n- \"percent-encoding 2.1.0\",\n+ \"percent-encoding\",\n  \"serde\",\n ]\n \n@@ -5762,6 +5349,12 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8772a4ccbb4e89959023bc5b7cb8623a795caa7092d99f3aa9501b9484d4557d\"\n \n+[[package]]\n+name = \"valuable\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d\"\n+\n [[package]]\n name = \"vcpkg\"\n version = \"0.2.10\""}, {"sha": "5753730053f4cb6b29827584397faa7cf8919c2f", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -35,6 +35,7 @@ members = [\n   \"src/tools/jsondocck\",\n   \"src/tools/html-checker\",\n   \"src/tools/bump-stage0\",\n+  \"src/tools/replace-version-placeholder\",\n   \"src/tools/lld-wrapper\",\n ]\n \n@@ -96,21 +97,6 @@ gimli.debug = 0\n miniz_oxide.debug = 0\n object.debug = 0\n \n-# We want the RLS to use the version of Cargo that we've got vendored in this\n-# repository to ensure that the same exact version of Cargo is used by both the\n-# RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository\n-# so we use a `[patch]` here to override the github repository with our local\n-# vendored copy.\n-[patch.\"https://github.com/rust-lang/cargo\"]\n-cargo = { path = \"src/tools/cargo\" }\n-cargo-util = { path = \"src/tools/cargo/crates/cargo-util\" }\n-\n-[patch.\"https://github.com/rust-lang/rustfmt\"]\n-# Similar to Cargo above we want the RLS to use a vendored version of `rustfmt`\n-# that we're shipping as well (to ensure that the rustfmt in RLS and the\n-# `rustfmt` executable are the same exact version).\n-rustfmt-nightly = { path = \"src/tools/rustfmt\" }\n-\n [patch.crates-io]\n # See comments in `src/tools/rustc-workspace-hack/README.md` for what's going on\n # here"}, {"sha": "137069b823873b8bcf42979bcf8e9371052d26a2", "filename": "LICENSES/Apache-2.0.txt", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/LICENSES%2FApache-2.0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/LICENSES%2FApache-2.0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FApache-2.0.txt?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,73 @@\n+Apache License\n+Version 2.0, January 2004\n+http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n+\n+\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n+\n+\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.\n+\n+\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n+\n+\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n+\n+\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n+\n+\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n+\n+\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n+\n+     (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and\n+\n+     (b) You must cause any modified files to carry prominent notices stating that You changed the files; and\n+\n+     (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\n+\n+     (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\n+\n+     You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!)  The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "5f662b354cd40cd5339d5aa05d74b15405138230", "filename": "LICENSES/BSD-2-Clause.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/LICENSES%2FBSD-2-Clause.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/LICENSES%2FBSD-2-Clause.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FBSD-2-Clause.txt?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,9 @@\n+Copyright (c) <year> <owner> \n+\n+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n+\n+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n+\n+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."}, {"sha": "2071b23b0e08594ea6bc99ac71129ef992abf498", "filename": "LICENSES/MIT.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/LICENSES%2FMIT.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/LICENSES%2FMIT.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FMIT.txt?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,9 @@\n+MIT License\n+\n+Copyright (c) <year> <copyright holders>\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."}, {"sha": "6fe84ee21ebe5d2b54dc63b53b4d5c404c083409", "filename": "LICENSES/OFL-1.1.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/LICENSES%2FOFL-1.1.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/LICENSES%2FOFL-1.1.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FOFL-1.1.txt?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,43 @@\n+SIL OPEN FONT LICENSE\n+\n+Version 1.1 - 26 February 2007\n+\n+PREAMBLE\n+\n+The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.\n+\n+The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.\n+\n+DEFINITIONS\n+\n+\"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.\n+\n+\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).\n+\n+\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).\n+\n+\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting \u2014 in part or in whole \u2014 any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.\n+\n+\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.\n+\n+PERMISSION & CONDITIONS\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:\n+\n+1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.\n+\n+2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.\n+\n+3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.\n+\n+4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.\n+\n+5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.\n+\n+TERMINATION\n+\n+This license becomes null and void if any of the above conditions are not met.\n+\n+DISCLAIMER\n+\n+THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE."}, {"sha": "7c229487d1c13eae4e7e89deebc35a32b1ac797c", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -83,7 +83,7 @@ by running it with the `--help` flag or reading the [rustc dev guide][rustcguide\n     If you plan to use `x.py install` to create an installation, it is recommended\n     that you set the `prefix` value in the `[install]` section to a directory.\n \n-    Create install directory if you are not installing in default directory.\n+    Create an install directory if you are not installing in the default directory.\n \n 4. Build and install:\n \n@@ -153,7 +153,7 @@ build.\n #### MSVC\n \n MSVC builds of Rust additionally require an installation of Visual Studio 2017\n-(or later) so `rustc` can use its linker.  The simplest way is to get the\n+(or later) so `rustc` can use its linker.  The simplest way is to get\n [Visual Studio], check the \u201cC++ build tools\u201d and \u201cWindows 10 SDK\u201d workload.\n \n [Visual Studio]: https://visualstudio.microsoft.com/downloads/"}, {"sha": "dde368e7b924fa870e29482e041b0d96bbce4f76", "filename": "compiler/rustc_apfloat/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -33,6 +33,8 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![no_std]\n #![forbid(unsafe_code)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate alloc;"}, {"sha": "46dbbd83d19054e2c2aaf8e4751c68a9aaf974d0", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -16,9 +16,12 @@\n #![feature(maybe_uninit_slice)]\n #![feature(min_specialization)]\n #![feature(decl_macro)]\n+#![feature(pointer_byte_offsets)]\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n #![feature(strict_provenance)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n use smallvec::SmallVec;\n \n@@ -209,15 +212,15 @@ impl<T> TypedArena<T> {\n \n         unsafe {\n             if mem::size_of::<T>() == 0 {\n-                self.ptr.set((self.ptr.get() as *mut u8).wrapping_offset(1) as *mut T);\n+                self.ptr.set(self.ptr.get().wrapping_byte_add(1));\n                 let ptr = ptr::NonNull::<T>::dangling().as_ptr();\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);\n                 &mut *ptr\n             } else {\n                 let ptr = self.ptr.get();\n                 // Advance the pointer.\n-                self.ptr.set(self.ptr.get().offset(1));\n+                self.ptr.set(self.ptr.get().add(1));\n                 // Write into uninitialized memory.\n                 ptr::write(ptr, object);\n                 &mut *ptr"}, {"sha": "fb521073a428d2802bfe0fe994ecd16edce9c8e3", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -504,7 +504,7 @@ pub struct WhereEqPredicate {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: AttrVec,\n     pub items: Vec<P<Item>>,\n     pub spans: ModSpans,\n     /// Must be equal to `CRATE_NODE_ID` after the crate root is expanded, but may hold\n@@ -770,7 +770,7 @@ pub enum PatKind {\n     Paren(P<Pat>),\n \n     /// A macro pattern; pre-expansion.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Copy)]\n@@ -980,7 +980,7 @@ pub enum StmtKind {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCallStmt {\n-    pub mac: MacCall,\n+    pub mac: P<MacCall>,\n     pub style: MacStmtStyle,\n     pub attrs: AttrVec,\n     pub tokens: Option<LazyTokenStream>,\n@@ -1268,7 +1268,7 @@ impl Expr {\n                 id: DUMMY_NODE_ID,\n                 kind: ExprKind::Err,\n                 span: DUMMY_SP,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n                 tokens: None,\n             },\n         )\n@@ -1437,7 +1437,7 @@ pub enum ExprKind {\n     InlineAsm(P<InlineAsm>),\n \n     /// A macro invocation; pre-expansion.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n \n     /// A struct literal expression.\n     ///\n@@ -1751,7 +1751,8 @@ pub enum LitFloatType {\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n #[derive(Clone, Encodable, Decodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n pub enum LitKind {\n-    /// A string literal (`\"foo\"`).\n+    /// A string literal (`\"foo\"`). The symbol is unescaped, and so may differ\n+    /// from the original token's symbol.\n     Str(Symbol, StrStyle),\n     /// A byte string (`b\"foo\"`).\n     ByteStr(Lrc<[u8]>),\n@@ -1761,12 +1762,13 @@ pub enum LitKind {\n     Char(char),\n     /// An integer literal (`1`).\n     Int(u128, LitIntType),\n-    /// A float literal (`1f64` or `1E10f64`).\n+    /// A float literal (`1f64` or `1E10f64`). Stored as a symbol rather than\n+    /// `f64` so that `LitKind` can impl `Eq` and `Hash`.\n     Float(Symbol, LitFloatType),\n     /// A boolean literal.\n     Bool(bool),\n     /// Placeholder for a literal that wasn't well-formed in some way.\n-    Err(Symbol),\n+    Err,\n }\n \n impl LitKind {\n@@ -1805,7 +1807,7 @@ impl LitKind {\n             | LitKind::Int(_, LitIntType::Unsuffixed)\n             | LitKind::Float(_, LitFloatType::Unsuffixed)\n             | LitKind::Bool(..)\n-            | LitKind::Err(..) => false,\n+            | LitKind::Err => false,\n         }\n     }\n }\n@@ -2040,7 +2042,7 @@ pub enum TyKind {\n     /// Inferred type of a `self` or `&self` argument in a method.\n     ImplicitSelf,\n     /// A macro in the type position.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n     /// Placeholder for a kind that has failed to be defined.\n     Err,\n     /// Placeholder for a `va_list`.\n@@ -2669,7 +2671,7 @@ impl VariantData {\n /// An item definition.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Item<K = ItemKind> {\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: AttrVec,\n     pub id: NodeId,\n     pub span: Span,\n     pub vis: Visibility,\n@@ -2877,7 +2879,7 @@ pub enum ItemKind {\n     /// A macro invocation.\n     ///\n     /// E.g., `foo!(..)`.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n \n     /// A macro definition.\n     MacroDef(MacroDef),\n@@ -2951,7 +2953,7 @@ pub enum AssocItemKind {\n     /// An associated type.\n     TyAlias(Box<TyAlias>),\n     /// A macro expanding to associated items.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n }\n \n impl AssocItemKind {\n@@ -3000,7 +3002,7 @@ pub enum ForeignItemKind {\n     /// An foreign type.\n     TyAlias(Box<TyAlias>),\n     /// A macro expanding to foreign items.\n-    MacCall(MacCall),\n+    MacCall(P<MacCall>),\n }\n \n impl From<ForeignItemKind> for ItemKind {\n@@ -3036,19 +3038,19 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(AssocItem, 160);\n-    static_assert_size!(AssocItemKind, 72);\n+    static_assert_size!(AssocItem, 104);\n+    static_assert_size!(AssocItemKind, 32);\n     static_assert_size!(Attribute, 32);\n     static_assert_size!(Block, 48);\n     static_assert_size!(Expr, 104);\n     static_assert_size!(ExprKind, 72);\n     static_assert_size!(Fn, 192);\n-    static_assert_size!(ForeignItem, 160);\n-    static_assert_size!(ForeignItemKind, 72);\n+    static_assert_size!(ForeignItem, 96);\n+    static_assert_size!(ForeignItemKind, 24);\n     static_assert_size!(GenericBound, 88);\n     static_assert_size!(Generics, 72);\n     static_assert_size!(Impl, 200);\n-    static_assert_size!(Item, 200);\n+    static_assert_size!(Item, 184);\n     static_assert_size!(ItemKind, 112);\n     static_assert_size!(Lit, 48);\n     static_assert_size!(LitKind, 24);"}, {"sha": "0947a71b8243261a7e7efad25f1599b7a92fb943", "filename": "compiler/rustc_ast/src/ast_traits.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -270,7 +270,7 @@ pub trait HasAttrs {\n     /// during token collection.\n     const SUPPORTS_CUSTOM_INNER_ATTRS: bool;\n     fn attrs(&self) -> &[Attribute];\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec));\n }\n \n macro_rules! impl_has_attrs {\n@@ -283,8 +283,8 @@ macro_rules! impl_has_attrs {\n                     &self.attrs\n                 }\n \n-                fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-                    VecOrAttrVec::visit(&mut self.attrs, f)\n+                fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n+                    f(&mut self.attrs)\n                 }\n             }\n         )+\n@@ -299,7 +299,7 @@ macro_rules! impl_has_attrs_none {\n                 fn attrs(&self) -> &[Attribute] {\n                     &[]\n                 }\n-                fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n+                fn visit_attrs(&mut self, _f: impl FnOnce(&mut AttrVec)) {}\n             }\n         )+\n     };\n@@ -330,7 +330,7 @@ impl<T: AstDeref<Target: HasAttrs>> HasAttrs for T {\n     fn attrs(&self) -> &[Attribute] {\n         self.ast_deref().attrs()\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         self.ast_deref_mut().visit_attrs(f)\n     }\n }\n@@ -340,7 +340,7 @@ impl<T: HasAttrs> HasAttrs for Option<T> {\n     fn attrs(&self) -> &[Attribute] {\n         self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         if let Some(inner) = self.as_mut() {\n             inner.visit_attrs(f);\n         }\n@@ -362,13 +362,13 @@ impl HasAttrs for StmtKind {\n         }\n     }\n \n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         match self {\n-            StmtKind::Local(local) => visit_attrvec(&mut local.attrs, f),\n+            StmtKind::Local(local) => f(&mut local.attrs),\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n             StmtKind::Item(item) => item.visit_attrs(f),\n             StmtKind::Empty => {}\n-            StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n+            StmtKind::MacCall(mac) => f(&mut mac.attrs),\n         }\n     }\n }\n@@ -378,38 +378,11 @@ impl HasAttrs for Stmt {\n     fn attrs(&self) -> &[Attribute] {\n         self.kind.attrs()\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         self.kind.visit_attrs(f);\n     }\n }\n \n-/// Helper trait for the impls above. Abstracts over\n-/// the two types of attribute fields that AST nodes\n-/// may have (`Vec<Attribute>` or `AttrVec`).\n-trait VecOrAttrVec {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-}\n-\n-impl VecOrAttrVec for Vec<Attribute> {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        f(self)\n-    }\n-}\n-\n-impl VecOrAttrVec for AttrVec {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        visit_attrvec(self, f)\n-    }\n-}\n-\n-fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n-    crate::mut_visit::visit_clobber(attrs, |attrs| {\n-        let mut vec = attrs.into();\n-        f(&mut vec);\n-        vec.into()\n-    });\n-}\n-\n /// A newtype around an AST node that implements the traits above if the node implements them.\n pub struct AstNodeWrapper<Wrapped, Tag> {\n     pub wrapped: Wrapped,"}, {"sha": "5b72ec2b6015c32550e8f53eb0ab6f01d3495fc1", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -12,7 +12,6 @@ use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyTokenStream, TokenStream};\n use crate::util::comments;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -487,7 +486,7 @@ impl MetaItemKind {\n                     id: ast::DUMMY_NODE_ID,\n                     kind: ast::ExprKind::Lit(lit.clone()),\n                     span: lit.span,\n-                    attrs: ThinVec::new(),\n+                    attrs: ast::AttrVec::new(),\n                     tokens: None,\n                 });\n                 MacArgs::Eq(span, MacArgsEq::Ast(expr))"}, {"sha": "27061f300a2b20191e5906ed47ac7a683cfd8aa8", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -13,12 +13,15 @@\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(if_let_guard)]\n-#![feature(label_break_value)]\n+#![cfg_attr(bootstrap, feature(label_break_value))]\n+#![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(negative_impls)]\n #![feature(slice_internals)]\n #![feature(stmt_expr_attributes)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "458d1156ec251b7c17248facee6b2e8c91af9154", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -14,7 +14,6 @@ use crate::tokenstream::*;\n \n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n@@ -338,12 +337,7 @@ where\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_attrs<T: MutVisitor>(attrs: &mut Vec<Attribute>, vis: &mut T) {\n-    visit_vec(attrs, |attr| vis.visit_attribute(attr));\n-}\n-\n-// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_thin_attrs<T: MutVisitor>(attrs: &mut AttrVec, vis: &mut T) {\n+pub fn visit_attrs<T: MutVisitor>(attrs: &mut AttrVec, vis: &mut T) {\n     for attr in attrs.iter_mut() {\n         vis.visit_attribute(attr);\n     }\n@@ -398,7 +392,7 @@ pub fn noop_flat_map_pat_field<T: MutVisitor>(\n     vis.visit_ident(ident);\n     vis.visit_pat(pat);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     smallvec![fp]\n }\n \n@@ -424,7 +418,7 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n \n pub fn noop_flat_map_arm<T: MutVisitor>(mut arm: Arm, vis: &mut T) -> SmallVec<[Arm; 1]> {\n     let Arm { attrs, pat, guard, body, span, id, is_placeholder: _ } = &mut arm;\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n@@ -507,7 +501,7 @@ pub fn noop_flat_map_variant<T: MutVisitor>(\n     let Variant { ident, vis, attrs, id, data, disr_expr, span, is_placeholder: _ } = &mut variant;\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n-    visit_thin_attrs(attrs, visitor);\n+    visit_attrs(attrs, visitor);\n     visitor.visit_id(id);\n     visitor.visit_variant_data(data);\n     visit_opt(disr_expr, |disr_expr| visitor.visit_anon_const(disr_expr));\n@@ -589,7 +583,7 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n         }\n     }\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_lazy_tts(tokens, vis);\n }\n \n@@ -640,7 +634,7 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> SmallVec<[Param; 1]> {\n     let Param { attrs, id, pat, span, ty, is_placeholder: _ } = &mut param;\n     vis.visit_id(id);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     vis.visit_pat(pat);\n     vis.visit_span(span);\n     vis.visit_ty(ty);\n@@ -882,7 +876,7 @@ pub fn noop_flat_map_generic_param<T: MutVisitor>(\n     if let Some(ref mut colon_span) = colon_span {\n         vis.visit_span(colon_span);\n     }\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_vec(bounds, |bound| noop_visit_param_bound(bound, vis));\n     match kind {\n         GenericParamKind::Lifetime => {}\n@@ -978,7 +972,7 @@ pub fn noop_flat_map_field_def<T: MutVisitor>(\n     visitor.visit_vis(vis);\n     visitor.visit_id(id);\n     visitor.visit_ty(ty);\n-    visit_thin_attrs(attrs, visitor);\n+    visit_attrs(attrs, visitor);\n     smallvec![fd]\n }\n \n@@ -991,7 +985,7 @@ pub fn noop_flat_map_expr_field<T: MutVisitor>(\n     vis.visit_expr(expr);\n     vis.visit_id(id);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     smallvec![f]\n }\n \n@@ -1432,7 +1426,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n     }\n     vis.visit_id(id);\n     vis.visit_span(span);\n-    visit_thin_attrs(attrs, vis);\n+    visit_attrs(attrs, vis);\n     visit_lazy_tts(tokens, vis);\n }\n \n@@ -1478,7 +1472,7 @@ pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n         StmtKind::MacCall(mut mac) => {\n             let MacCallStmt { mac: mac_, style: _, attrs, tokens } = mac.deref_mut();\n             vis.visit_mac_call(mac_);\n-            visit_thin_attrs(attrs, vis);\n+            visit_attrs(attrs, vis);\n             visit_lazy_tts(tokens, vis);\n             smallvec![StmtKind::MacCall(mac)]\n         }\n@@ -1513,12 +1507,6 @@ impl<T: DummyAstNode + 'static> DummyAstNode for P<T> {\n     }\n }\n \n-impl<T> DummyAstNode for ThinVec<T> {\n-    fn dummy() -> Self {\n-        Default::default()\n-    }\n-}\n-\n impl DummyAstNode for Item {\n     fn dummy() -> Self {\n         Item {"}, {"sha": "dd98946b4cc5e8833b77f64645702d26cde6f5a1", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -436,6 +436,30 @@ impl Token {\n             || self == &OpenDelim(Delimiter::Parenthesis)\n     }\n \n+    /// Returns `true` if the token can appear at the start of an item.\n+    pub fn can_begin_item(&self) -> bool {\n+        match self.kind {\n+            Ident(name, _) => [\n+                kw::Fn,\n+                kw::Use,\n+                kw::Struct,\n+                kw::Enum,\n+                kw::Pub,\n+                kw::Trait,\n+                kw::Extern,\n+                kw::Impl,\n+                kw::Unsafe,\n+                kw::Static,\n+                kw::Union,\n+                kw::Macro,\n+                kw::Mod,\n+                kw::Type,\n+            ]\n+            .contains(&name),\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token is any literal.\n     pub fn is_lit(&self) -> bool {\n         matches!(self.kind, Literal(..))"}, {"sha": "69a78d165ef5895ad654b51103bd6efa21f5d016", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -146,7 +146,7 @@ impl LitKind {\n \n                 LitKind::ByteStr(bytes.into())\n             }\n-            token::Err => LitKind::Err(symbol),\n+            token::Err => LitKind::Err,\n         })\n     }\n \n@@ -199,7 +199,9 @@ impl LitKind {\n                 let symbol = if value { kw::True } else { kw::False };\n                 (token::Bool, symbol, None)\n             }\n-            LitKind::Err(symbol) => (token::Err, symbol, None),\n+            // This only shows up in places like `-Zunpretty=hir` output, so we\n+            // don't bother to produce something useful.\n+            LitKind::Err => (token::Err, Symbol::intern(\"<bad-literal>\"), None),\n         };\n \n         token::Lit::new(kind, symbol, suffix)"}, {"sha": "474aff2e2aac06fabc947ac8c733fa227c732e65", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -15,6 +15,7 @@ rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_middle = { path = \"../rustc_middle\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "0dba9da63da2a03d0d18c3ccfe2697d5b672252e", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 74, "deletions": 105, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,11 +1,17 @@\n use crate::{ImplTraitContext, ImplTraitPosition, ParamMode, ResolverAstLoweringExt};\n \n+use super::errors::{\n+    AbiSpecifiedMultipleTimes, AttSyntaxOnlyX86, ClobberAbiNotSupported,\n+    InlineAsmUnsupportedTarget, InvalidAbiClobberAbi, InvalidAsmTemplateModifierConst,\n+    InvalidAsmTemplateModifierRegClass, InvalidAsmTemplateModifierRegClassSub,\n+    InvalidAsmTemplateModifierSym, InvalidRegister, InvalidRegisterClass, RegisterClassOnlyClobber,\n+    RegisterConflict,\n+};\n use super::LoweringContext;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::definitions::DefPathData;\n@@ -26,13 +32,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let asm_arch =\n             if self.tcx.sess.opts.actually_rustdoc { None } else { self.tcx.sess.asm_arch };\n         if asm_arch.is_none() && !self.tcx.sess.opts.actually_rustdoc {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                sp,\n-                E0472,\n-                \"inline assembly is unsupported on this target\"\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(InlineAsmUnsupportedTarget { span: sp });\n         }\n         if let Some(asm_arch) = asm_arch {\n             // Inline assembly is currently only stable for these architectures.\n@@ -59,10 +59,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n             && !self.tcx.sess.opts.actually_rustdoc\n         {\n-            self.tcx\n-                .sess\n-                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n-                .emit();\n+            self.tcx.sess.emit_err(AttSyntaxOnlyX86 { span: sp });\n         }\n         if asm.options.contains(InlineAsmOptions::MAY_UNWIND) && !self.tcx.features().asm_unwind {\n             feature_err(\n@@ -82,51 +79,37 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n                             Some((prev_name, prev_sp)) => {\n-                                let mut err = self.tcx.sess.struct_span_err(\n-                                    *abi_span,\n-                                    &format!(\"`{}` ABI specified multiple times\", prev_name),\n-                                );\n-                                err.span_label(*prev_sp, \"previously specified here\");\n-\n                                 // Multiple different abi names may actually be the same ABI\n                                 // If the specified ABIs are not the same name, alert the user that they resolve to the same ABI\n                                 let source_map = self.tcx.sess.source_map();\n-                                if source_map.span_to_snippet(*prev_sp)\n-                                    != source_map.span_to_snippet(*abi_span)\n-                                {\n-                                    err.note(\"these ABIs are equivalent on the current target\");\n-                                }\n+                                let equivalent = (source_map.span_to_snippet(*prev_sp)\n+                                    != source_map.span_to_snippet(*abi_span))\n+                                .then_some(());\n \n-                                err.emit();\n+                                self.tcx.sess.emit_err(AbiSpecifiedMultipleTimes {\n+                                    abi_span: *abi_span,\n+                                    prev_name: *prev_name,\n+                                    prev_span: *prev_sp,\n+                                    equivalent,\n+                                });\n                             }\n                             None => {\n-                                clobber_abis.insert(abi, (abi_name, *abi_span));\n+                                clobber_abis.insert(abi, (*abi_name, *abi_span));\n                             }\n                         }\n                     }\n                     Err(&[]) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                *abi_span,\n-                                \"`clobber_abi` is not supported on this target\",\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(ClobberAbiNotSupported { abi_span: *abi_span });\n                     }\n                     Err(supported_abis) => {\n-                        let mut err = self\n-                            .tcx\n-                            .sess\n-                            .struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n                         let mut abis = format!(\"`{}`\", supported_abis[0]);\n                         for m in &supported_abis[1..] {\n                             let _ = write!(abis, \", `{}`\", m);\n                         }\n-                        err.note(&format!(\n-                            \"the following ABIs are supported on this target: {}\",\n-                            abis\n-                        ));\n-                        err.emit();\n+                        self.tcx.sess.emit_err(InvalidAbiClobberAbi {\n+                            abi_span: *abi_span,\n+                            supported_abis: abis,\n+                        });\n                     }\n                 }\n             }\n@@ -141,24 +124,28 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .iter()\n             .map(|(op, op_sp)| {\n                 let lower_reg = |reg| match reg {\n-                    InlineAsmRegOrRegClass::Reg(s) => {\n+                    InlineAsmRegOrRegClass::Reg(reg) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmReg::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register `{}`: {}\", s, e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n+                            asm::InlineAsmReg::parse(asm_arch, reg).unwrap_or_else(|error| {\n+                                sess.emit_err(InvalidRegister { op_span: *op_sp, reg, error });\n                                 asm::InlineAsmReg::Err\n                             })\n                         } else {\n                             asm::InlineAsmReg::Err\n                         })\n                     }\n-                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                    InlineAsmRegOrRegClass::RegClass(reg_class) => {\n                         asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n-                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n-                                let msg = format!(\"invalid register class `{}`: {}\", s, e);\n-                                sess.struct_span_err(*op_sp, &msg).emit();\n-                                asm::InlineAsmRegClass::Err\n-                            })\n+                            asm::InlineAsmRegClass::parse(asm_arch, reg_class).unwrap_or_else(\n+                                |error| {\n+                                    sess.emit_err(InvalidRegisterClass {\n+                                        op_span: *op_sp,\n+                                        reg_class,\n+                                        error,\n+                                    });\n+                                    asm::InlineAsmRegClass::Err\n+                                },\n+                            )\n                         } else {\n                             asm::InlineAsmRegClass::Err\n                         })\n@@ -282,50 +269,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n                         if !valid_modifiers.contains(&modifier) {\n-                            let mut err = sess.struct_span_err(\n-                                placeholder_span,\n-                                \"invalid asm template modifier for this register class\",\n-                            );\n-                            err.span_label(placeholder_span, \"template modifier\");\n-                            err.span_label(op_sp, \"argument\");\n-                            if !valid_modifiers.is_empty() {\n+                            let sub = if !valid_modifiers.is_empty() {\n                                 let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n                                 for m in &valid_modifiers[1..] {\n                                     let _ = write!(mods, \", `{}`\", m);\n                                 }\n-                                err.note(&format!(\n-                                    \"the `{}` register class supports \\\n-                                     the following template modifiers: {}\",\n-                                    class.name(),\n-                                    mods\n-                                ));\n+                                InvalidAsmTemplateModifierRegClassSub::SupportModifier {\n+                                    class_name: class.name(),\n+                                    modifiers: mods,\n+                                }\n                             } else {\n-                                err.note(&format!(\n-                                    \"the `{}` register class does not support template modifiers\",\n-                                    class.name()\n-                                ));\n-                            }\n-                            err.emit();\n+                                InvalidAsmTemplateModifierRegClassSub::DoesNotSupportModifier {\n+                                    class_name: class.name(),\n+                                }\n+                            };\n+                            sess.emit_err(InvalidAsmTemplateModifierRegClass {\n+                                placeholder_span,\n+                                op_span: op_sp,\n+                                sub,\n+                            });\n                         }\n                     }\n                     hir::InlineAsmOperand::Const { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierConst {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `const` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                     hir::InlineAsmOperand::SymFn { .. }\n                     | hir::InlineAsmOperand::SymStatic { .. } => {\n-                        let mut err = sess.struct_span_err(\n+                        sess.emit_err(InvalidAsmTemplateModifierSym {\n                             placeholder_span,\n-                            \"asm template modifiers are not allowed for `sym` arguments\",\n-                        );\n-                        err.span_label(placeholder_span, \"template modifier\");\n-                        err.span_label(op_sp, \"argument\");\n-                        err.emit();\n+                            op_span: op_sp,\n+                        });\n                     }\n                 }\n             }\n@@ -346,12 +322,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // require that the operand name an explicit register, not a\n                 // register class.\n                 if reg_class.is_clobber_only(asm_arch.unwrap()) && !op.is_clobber() {\n-                    let msg = format!(\n-                        \"register class `{}` can only be used as a clobber, \\\n-                             not as an input or output\",\n-                        reg_class.name()\n-                    );\n-                    sess.struct_span_err(op_sp, &msg).emit();\n+                    sess.emit_err(RegisterClassOnlyClobber {\n+                        op_span: op_sp,\n+                        reg_class_name: reg_class.name(),\n+                    });\n                     continue;\n                 }\n \n@@ -391,16 +365,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         unreachable!();\n                                     };\n \n-                                    let msg = format!(\n-                                        \"register `{}` conflicts with register `{}`\",\n-                                        reg.name(),\n-                                        reg2.name()\n-                                    );\n-                                    let mut err = sess.struct_span_err(op_sp, &msg);\n-                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n-                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n-\n-                                    match (op, op2) {\n+                                    let in_out = match (op, op2) {\n                                         (\n                                             hir::InlineAsmOperand::In { .. },\n                                             hir::InlineAsmOperand::Out { late, .. },\n@@ -411,14 +376,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                         ) => {\n                                             assert!(!*late);\n                                             let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                            let msg = \"use `lateout` instead of \\\n-                                                       `out` to avoid conflict\";\n-                                            err.span_help(out_op_sp, msg);\n-                                        }\n-                                        _ => {}\n-                                    }\n+                                            Some(out_op_sp)\n+                                        },\n+                                        _ => None,\n+                                    };\n \n-                                    err.emit();\n+                                    sess.emit_err(RegisterConflict {\n+                                        op_span1: op_sp,\n+                                        op_span2: op_sp2,\n+                                        reg1_name: reg.name(),\n+                                        reg2_name: reg2.name(),\n+                                        in_out\n+                                    });\n                                 }\n                                 Entry::Vacant(v) => {\n                                     if r == reg {"}, {"sha": "4adeaef9bbfa832d708a5275c5209229c105c37f", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,336 @@\n+use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay};\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::generic_type_with_parentheses, code = \"E0214\")]\n+pub struct GenericTypeWithParentheses {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<UseAngleBrackets>,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct UseAngleBrackets {\n+    pub open_param: Span,\n+    pub close_param: Span,\n+}\n+\n+impl AddSubdiagnostic for UseAngleBrackets {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        diag.multipart_suggestion(\n+            fluent::ast_lowering::use_angle_brackets,\n+            vec![(self.open_param, String::from(\"<\")), (self.close_param, String::from(\">\"))],\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[help]\n+#[diag(ast_lowering::invalid_abi, code = \"E0703\")]\n+pub struct InvalidAbi {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub abi: Symbol,\n+    pub valid_abis: String,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::assoc_ty_parentheses)]\n+pub struct AssocTyParentheses {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: AssocTyParenthesesSub,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub enum AssocTyParenthesesSub {\n+    Empty { parentheses_span: Span },\n+    NotEmpty { open_param: Span, close_param: Span },\n+}\n+\n+impl AddSubdiagnostic for AssocTyParenthesesSub {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        match self {\n+            Self::Empty { parentheses_span } => diag.multipart_suggestion(\n+                fluent::ast_lowering::remove_parentheses,\n+                vec![(parentheses_span, String::new())],\n+                Applicability::MaybeIncorrect,\n+            ),\n+            Self::NotEmpty { open_param, close_param } => diag.multipart_suggestion(\n+                fluent::ast_lowering::use_angle_brackets,\n+                vec![(open_param, String::from(\"<\")), (close_param, String::from(\">\"))],\n+                Applicability::MaybeIncorrect,\n+            ),\n+        };\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_lowering::misplaced_impl_trait, code = \"E0562\")]\n+pub struct MisplacedImplTrait<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub position: DiagnosticArgFromDisplay<'a>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::rustc_box_attribute_error)]\n+pub struct RustcBoxAttributeError {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::underscore_expr_lhs_assign)]\n+pub struct UnderscoreExprLhsAssign {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::base_expression_double_dot)]\n+pub struct BaseExpressionDoubleDot {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::await_only_in_async_fn_and_blocks, code = \"E0728\")]\n+pub struct AwaitOnlyInAsyncFnAndBlocks {\n+    #[primary_span]\n+    #[label]\n+    pub dot_await_span: Span,\n+    #[label(ast_lowering::this_not_async)]\n+    pub item_span: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::generator_too_many_parameters, code = \"E0628\")]\n+pub struct GeneratorTooManyParameters {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::closure_cannot_be_static, code = \"E0697\")]\n+pub struct ClosureCannotBeStatic {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[help]\n+#[diag(ast_lowering::async_non_move_closure_not_supported, code = \"E0708\")]\n+pub struct AsyncNonMoveClosureNotSupported {\n+    #[primary_span]\n+    pub fn_decl_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::functional_record_update_destructuring_assignment)]\n+pub struct FunctionalRecordUpdateDestructuringAssignemnt {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::async_generators_not_supported, code = \"E0727\")]\n+pub struct AsyncGeneratorsNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::inline_asm_unsupported_target, code = \"E0472\")]\n+pub struct InlineAsmUnsupportedTarget {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::att_syntax_only_x86)]\n+pub struct AttSyntaxOnlyX86 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::abi_specified_multiple_times)]\n+pub struct AbiSpecifiedMultipleTimes {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub prev_name: Symbol,\n+    #[label]\n+    pub prev_span: Span,\n+    #[note]\n+    pub equivalent: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::clobber_abi_not_supported)]\n+pub struct ClobberAbiNotSupported {\n+    #[primary_span]\n+    pub abi_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[note]\n+#[diag(ast_lowering::invalid_abi_clobber_abi)]\n+pub struct InvalidAbiClobberAbi {\n+    #[primary_span]\n+    pub abi_span: Span,\n+    pub supported_abis: String,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_register)]\n+pub struct InvalidRegister<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg: Symbol,\n+    pub error: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_register_class)]\n+pub struct InvalidRegisterClass<'a> {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class: Symbol,\n+    pub error: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_reg_class)]\n+pub struct InvalidAsmTemplateModifierRegClass {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+    #[subdiagnostic]\n+    pub sub: InvalidAsmTemplateModifierRegClassSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum InvalidAsmTemplateModifierRegClassSub {\n+    #[note(ast_lowering::support_modifiers)]\n+    SupportModifier { class_name: Symbol, modifiers: String },\n+    #[note(ast_lowering::does_not_support_modifiers)]\n+    DoesNotSupportModifier { class_name: Symbol },\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_const)]\n+pub struct InvalidAsmTemplateModifierConst {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::invalid_asm_template_modifier_sym)]\n+pub struct InvalidAsmTemplateModifierSym {\n+    #[primary_span]\n+    #[label(ast_lowering::template_modifier)]\n+    pub placeholder_span: Span,\n+    #[label(ast_lowering::argument)]\n+    pub op_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::register_class_only_clobber)]\n+pub struct RegisterClassOnlyClobber {\n+    #[primary_span]\n+    pub op_span: Span,\n+    pub reg_class_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::register_conflict)]\n+pub struct RegisterConflict<'a> {\n+    #[primary_span]\n+    #[label(ast_lowering::register1)]\n+    pub op_span1: Span,\n+    #[label(ast_lowering::register2)]\n+    pub op_span2: Span,\n+    pub reg1_name: &'a str,\n+    pub reg2_name: &'a str,\n+    #[help]\n+    pub in_out: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[help]\n+#[diag(ast_lowering::sub_tuple_binding)]\n+pub struct SubTupleBinding<'a> {\n+    #[primary_span]\n+    #[label]\n+    #[suggestion_verbose(\n+        ast_lowering::sub_tuple_binding_suggestion,\n+        code = \"..\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub ident_name: Symbol,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::extra_double_dot)]\n+pub struct ExtraDoubleDot<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(ast_lowering::previously_used_here)]\n+    pub prev_span: Span,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[note]\n+#[diag(ast_lowering::misplaced_double_dot)]\n+pub struct MisplacedDoubleDot {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::misplaced_relax_trait_bound)]\n+pub struct MisplacedRelaxTraitBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::not_supported_for_lifetime_binder_async_closure)]\n+pub struct NotSupportedForLifetimeBinderAsyncClosure {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::arbitrary_expression_in_pattern)]\n+pub struct ArbitraryExpressionInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::inclusive_range_with_no_end)]\n+pub struct InclusiveRangeWithNoEnd {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "176047616881f4a62da9610497adfe3f2b13832b", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 51, "deletions": 107, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,3 +1,9 @@\n+use super::errors::{\n+    AsyncGeneratorsNotSupported, AsyncNonMoveClosureNotSupported, AwaitOnlyInAsyncFnAndBlocks,\n+    BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignemnt,\n+    GeneratorTooManyParameters, InclusiveRangeWithNoEnd, NotSupportedForLifetimeBinderAsyncClosure,\n+    RustcBoxAttributeError, UnderscoreExprLhsAssign,\n+};\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n use crate::{FnDeclKind, ImplTraitPosition};\n@@ -6,8 +12,6 @@ use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n use rustc_ast::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n@@ -46,13 +50,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             let hir_id = self.lower_node_id(e.id);\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n-                            self.tcx.sess\n-                                .struct_span_err(\n-                                    e.span,\n-                                    \"#[rustc_box] requires precisely one argument \\\n-                                    and no other attributes are allowed\",\n-                                )\n-                                .emit();\n+                            self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n                             hir::ExprKind::Err\n                         }\n                     } else if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n@@ -212,13 +210,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.tcx\n-                        .sess.struct_span_err(\n-                            e.span,\n-                            \"in expressions, `_` can only be used on the left-hand side of an assignment\",\n-                        )\n-                        .span_label(e.span, \"`_` not allowed here\")\n-                        .emit();\n+                    self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n                     hir::ExprKind::Err\n                 }\n                 ExprKind::Path(ref qself, ref path) => {\n@@ -250,11 +242,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(*sp, \"base expression required after `..`\")\n-                                .span_label(*sp, \"add a base expression here\")\n-                                .emit();\n+                            self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n                             Some(&*self.arena.alloc(self.expr_err(*sp)))\n                         }\n                         StructRest::None => None,\n@@ -448,12 +436,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n         let new_cond = self.manage_let_cond(lowered_cond);\n         let then = self.lower_block_expr(body);\n-        let expr_break = self.expr_break(span, ThinVec::new());\n+        let expr_break = self.expr_break(span, AttrVec::new());\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n-        let else_expr = self.arena.alloc(self.expr_block(else_blk, ThinVec::new()));\n+        let else_expr = self.arena.alloc(self.expr_block(else_blk, AttrVec::new()));\n         let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));\n-        let if_expr = self.expr(span, if_kind, ThinVec::new());\n+        let if_expr = self.expr(span, if_kind, AttrVec::new());\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));\n         let opt_label = self.lower_label(opt_label);\n@@ -512,7 +500,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let constructor = self.arena.alloc(self.expr_lang_item_path(\n             method_span,\n             lang_item,\n-            ThinVec::new(),\n+            AttrVec::new(),\n             None,\n         ));\n         self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n@@ -635,7 +623,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let gen_future = self.expr_lang_item_path(\n             unstable_span,\n             hir::LangItem::FromGenerator,\n-            ThinVec::new(),\n+            AttrVec::new(),\n             None,\n         );\n \n@@ -663,17 +651,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Async(_)) => {}\n             Some(hir::GeneratorKind::Gen) | None => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.sess.emit_err(AwaitOnlyInAsyncFnAndBlocks {\n                     dot_await_span,\n-                    E0728,\n-                    \"`await` is only allowed inside `async` functions and blocks\"\n-                );\n-                err.span_label(dot_await_span, \"only allowed inside `async` functions and blocks\");\n-                if let Some(item_sp) = self.current_item {\n-                    err.span_label(item_sp, \"this is not `async`\");\n-                }\n-                err.emit();\n+                    item_span: self.current_item,\n+                });\n             }\n         }\n         let span = self.mark_span_with_reason(DesugaringKind::Await, dot_await_span, None);\n@@ -747,7 +728,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n-                this.arena.alloc(this.expr(gen_future_span, expr_break, ThinVec::new()))\n+                this.arena.alloc(this.expr(gen_future_span, expr_break, AttrVec::new()))\n             });\n             self.arm(ready_pat, break_x)\n         };\n@@ -780,7 +761,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let yield_expr = self.expr(\n                 span,\n                 hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }),\n-                ThinVec::new(),\n+                AttrVec::new(),\n             );\n             let yield_expr = self.arena.alloc(yield_expr);\n \n@@ -893,13 +874,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match generator_kind {\n             Some(hir::GeneratorKind::Gen) => {\n                 if decl.inputs.len() > 1 {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        fn_decl_span,\n-                        E0628,\n-                        \"too many parameters for a generator (expected 0 or 1 parameters)\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(GeneratorTooManyParameters { fn_decl_span });\n                 }\n                 Some(movability)\n             }\n@@ -908,13 +883,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             None => {\n                 if movability == Movability::Static {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        fn_decl_span,\n-                        E0697,\n-                        \"closures cannot be static\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(ClosureCannotBeStatic { fn_decl_span });\n                 }\n                 None\n             }\n@@ -947,10 +916,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         fn_decl_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         if let &ClosureBinder::For { span, .. } = binder {\n-            self.tcx.sess.span_err(\n-                span,\n-                \"`for<...>` binders on `async` closures are not currently supported\",\n-            );\n+            self.tcx.sess.emit_err(NotSupportedForLifetimeBinderAsyncClosure { span });\n         }\n \n         let (binder_clause, generic_params) = self.lower_closure_binder(binder);\n@@ -961,17 +927,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let body = self.with_new_scopes(|this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n-                struct_span_err!(\n-                    this.tcx.sess,\n-                    fn_decl_span,\n-                    E0708,\n-                    \"`async` non-`move` closures with parameters are not currently supported\",\n-                )\n-                .help(\n-                    \"consider using `let` statements to manually capture \\\n-                    variables by reference before entering an `async move` closure\",\n-                )\n-                .emit();\n+                this.tcx.sess.emit_err(AsyncNonMoveClosureNotSupported { fn_decl_span });\n             }\n \n             // Transform `async |x: u8| -> X { ... }` into\n@@ -987,7 +943,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::AsyncGeneratorKind::Closure,\n                     |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n                 );\n-                this.expr(fn_decl_span, async_body, ThinVec::new())\n+                this.expr(fn_decl_span, async_body, AttrVec::new())\n             });\n             body_id\n         });\n@@ -1211,20 +1167,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                e.span,\n-                                \"functional record updates are not allowed in destructuring \\\n-                                    assignments\",\n-                            )\n-                            .span_suggestion(\n-                                e.span,\n-                                \"consider removing the trailing pattern\",\n-                                \"\",\n-                                rustc_errors::Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(FunctionalRecordUpdateDestructuringAssignemnt {\n+                            span: e.span,\n+                        });\n                         true\n                     }\n                     StructRest::Rest(_) => true,\n@@ -1257,7 +1202,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let ident = self.expr_ident(lhs.span, ident, binding);\n         let assign =\n             hir::ExprKind::Assign(self.lower_expr(lhs), ident, self.lower_span(eq_sign_span));\n-        let expr = self.expr(lhs.span, assign, ThinVec::new());\n+        let expr = self.expr(lhs.span, assign, AttrVec::new());\n         assignments.push(self.stmt_expr(lhs.span, expr));\n         pat\n     }\n@@ -1299,7 +1244,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let fn_path =\n             hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, self.lower_span(span), None);\n         let fn_expr =\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), AttrVec::new()));\n         hir::ExprKind::Call(fn_expr, arena_vec![self; e1, e2])\n     }\n \n@@ -1319,7 +1264,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (Some(..), Some(..), HalfOpen) => hir::LangItem::Range,\n             (None, Some(..), Closed) => hir::LangItem::RangeToInclusive,\n             (Some(..), Some(..), Closed) => unreachable!(),\n-            (_, None, Closed) => self.diagnostic().span_fatal(span, \"inclusive range with no end\"),\n+            (start, None, Closed) => {\n+                self.tcx.sess.emit_err(InclusiveRangeWithNoEnd { span });\n+                match start {\n+                    Some(..) => hir::LangItem::RangeFrom,\n+                    None => hir::LangItem::RangeFull,\n+                }\n+            }\n         };\n \n         let fields = self.arena.alloc_from_iter(\n@@ -1421,13 +1372,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match self.generator_kind {\n             Some(hir::GeneratorKind::Gen) => {}\n             Some(hir::GeneratorKind::Async(_)) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0727,\n-                    \"`async` generators are not yet supported\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(AsyncGeneratorsNotSupported { span });\n             }\n             None => self.generator_kind = Some(hir::GeneratorKind::Gen),\n         }\n@@ -1472,7 +1417,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `None => break`\n         let none_arm = {\n             let break_expr =\n-                self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span, ThinVec::new()));\n+                self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span, AttrVec::new()));\n             let pat = self.pat_none(for_span);\n             self.arm(pat, break_expr)\n         };\n@@ -1481,7 +1426,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let some_arm = {\n             let some_pat = self.pat_some(pat_span, pat);\n             let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n-            let body_expr = self.arena.alloc(self.expr_block(body_block, ThinVec::new()));\n+            let body_expr = self.arena.alloc(self.expr_block(body_block, AttrVec::new()));\n             self.arm(some_pat, body_expr)\n         };\n \n@@ -1596,7 +1541,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             };\n             attr::mk_attr_outer(allow)\n         };\n-        let attrs = vec![attr];\n+        let attrs: AttrVec = vec![attr].into();\n \n         // `ControlFlow::Continue(val) => #[allow(unreachable_code)] val,`\n         let continue_arm = {\n@@ -1606,7 +1551,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 span,\n                 val_ident,\n                 val_pat_nid,\n-                ThinVec::from(attrs.clone()),\n+                attrs.clone(),\n             ));\n             let continue_pat = self.pat_cf_continue(unstable_span, val_pat);\n             self.arm(continue_pat, val_expr)\n@@ -1625,7 +1570,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.arena.alloc(residual_expr),\n                 unstable_span,\n             );\n-            let thin_attrs = ThinVec::from(attrs);\n             let ret_expr = if let Some(catch_node) = self.catch_scope {\n                 let target_id = Ok(self.lower_node_id(catch_node));\n                 self.arena.alloc(self.expr(\n@@ -1634,13 +1578,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::Destination { label: None, target_id },\n                         Some(from_residual_expr),\n                     ),\n-                    thin_attrs,\n+                    attrs,\n                 ))\n             } else {\n                 self.arena.alloc(self.expr(\n                     try_span,\n                     hir::ExprKind::Ret(Some(from_residual_expr)),\n-                    thin_attrs,\n+                    attrs,\n                 ))\n             };\n \n@@ -1728,7 +1672,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         arms: &'hir [hir::Arm<'hir>],\n         source: hir::MatchSource,\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source), AttrVec::new())\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: AttrVec) -> hir::Expr<'hir> {\n@@ -1745,12 +1689,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(\n             span,\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n-            ThinVec::new(),\n+            AttrVec::new(),\n         )\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), ThinVec::new()))\n+        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), AttrVec::new()))\n     }\n \n     fn expr_call_mut(\n@@ -1759,7 +1703,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         e: &'hir hir::Expr<'hir>,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n+        self.expr(span, hir::ExprKind::Call(e, args), AttrVec::new())\n     }\n \n     fn expr_call(\n@@ -1779,7 +1723,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir_id: Option<hir::HirId>,\n     ) -> hir::Expr<'hir> {\n         let path =\n-            self.arena.alloc(self.expr_lang_item_path(span, lang_item, ThinVec::new(), hir_id));\n+            self.arena.alloc(self.expr_lang_item_path(span, lang_item, AttrVec::new(), hir_id));\n         self.expr_call_mut(span, path, args)\n     }\n \n@@ -1822,7 +1766,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         ident: Ident,\n         binding: hir::HirId,\n     ) -> hir::Expr<'hir> {\n-        self.expr_ident_with_attrs(sp, ident, binding, ThinVec::new())\n+        self.expr_ident_with_attrs(sp, ident, binding, AttrVec::new())\n     }\n \n     fn expr_ident_with_attrs(\n@@ -1860,13 +1804,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }),\n                 None,\n             ),\n-            ThinVec::new(),\n+            AttrVec::new(),\n         )\n     }\n \n     fn expr_block_empty(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n         let blk = self.block_all(span, &[], None);\n-        let expr = self.expr_block(blk, ThinVec::new());\n+        let expr = self.expr_block(blk, AttrVec::new());\n         self.arena.alloc(expr)\n     }\n "}, {"sha": "fd338ffc0c5e8b64c9ca0469cc25cb766070e671", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,3 +1,4 @@\n+use super::errors::{InvalidAbi, MisplacedRelaxTraitBound};\n use super::ResolverAstLoweringExt;\n use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{FnDeclKind, LoweringContext, ParamMode};\n@@ -7,7 +8,6 @@ use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -1260,10 +1260,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn error_on_invalid_abi(&self, abi: StrLit) {\n-        struct_span_err!(self.tcx.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n-            .span_label(abi.span, \"invalid ABI\")\n-            .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n-            .emit();\n+        self.tcx.sess.emit_err(InvalidAbi {\n+            span: abi.span,\n+            abi: abi.symbol,\n+            valid_abis: abi::all_names().join(\", \"),\n+        });\n     }\n \n     fn lower_asyncness(&mut self, a: Async) -> hir::IsAsync {\n@@ -1338,11 +1339,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 let is_param = *is_param.get_or_insert_with(compute_is_param);\n                 if !is_param {\n-                    self.diagnostic().span_err(\n-                        bound.span(),\n-                        \"`?Trait` bounds are only permitted at the \\\n-                        point where a type parameter is declared\",\n-                    );\n+                    self.tcx.sess.emit_err(MisplacedRelaxTraitBound { span: bound.span() });\n                 }\n             }\n         }"}, {"sha": "30a87740c7f9b16c56f2d0261b61cdf761448d14", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -31,14 +31,19 @@\n //! in the HIR, especially for multiple identifiers.\n \n #![feature(box_patterns)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;\n \n+use crate::errors::{AssocTyParentheses, AssocTyParenthesesSub, MisplacedImplTrait};\n+\n use rustc_ast::ptr::P;\n use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n@@ -49,7 +54,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, Applicability, Handler, StashKey};\n+use rustc_errors::{DiagnosticArgFromDisplay, Handler, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -75,6 +80,7 @@ macro_rules! arena_vec {\n \n mod asm;\n mod block;\n+mod errors;\n mod expr;\n mod index;\n mod item;\n@@ -928,7 +934,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 } else {\n                     Lit {\n                         token_lit: token::Lit::new(token::LitKind::Err, kw::Empty, None),\n-                        kind: LitKind::Err(kw::Empty),\n+                        kind: LitKind::Err,\n                         span: DUMMY_SP,\n                     }\n                 };\n@@ -1070,19 +1076,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn emit_bad_parenthesized_trait_in_assoc_ty(&self, data: &ParenthesizedArgs) {\n-        let mut err = self.tcx.sess.struct_span_err(\n-            data.span,\n-            \"parenthesized generic arguments cannot be used in associated type constraints\",\n-        );\n         // Suggest removing empty parentheses: \"Trait()\" -> \"Trait\"\n-        if data.inputs.is_empty() {\n+        let sub = if data.inputs.is_empty() {\n             let parentheses_span =\n                 data.inputs_span.shrink_to_lo().to(data.inputs_span.shrink_to_hi());\n-            err.multipart_suggestion(\n-                \"remove these parentheses\",\n-                vec![(parentheses_span, String::new())],\n-                Applicability::MaybeIncorrect,\n-            );\n+            AssocTyParenthesesSub::Empty { parentheses_span }\n         }\n         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n         else {\n@@ -1096,13 +1094,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // End of last argument to end of parameters\n             let close_param =\n                 data.inputs.last().unwrap().span.shrink_to_hi().to(data.inputs_span.shrink_to_hi());\n-            err.multipart_suggestion(\n-                &format!(\"use angle brackets instead\",),\n-                vec![(open_param, String::from(\"<\")), (close_param, String::from(\">\"))],\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-        err.emit();\n+            AssocTyParenthesesSub::NotEmpty { open_param, close_param }\n+        };\n+        self.tcx.sess.emit_err(AssocTyParentheses { span: data.span, sub });\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n@@ -1341,14 +1335,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         path\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            t.span,\n-                            E0562,\n-                            \"`impl Trait` only allowed in function and inherent method return types, not in {}\",\n-                            position\n-                        );\n-                        err.emit();\n+                        self.tcx.sess.emit_err(MisplacedImplTrait {\n+                            span: t.span,\n+                            position: DiagnosticArgFromDisplay(&position),\n+                        });\n                         hir::TyKind::Err\n                     }\n                 }"}, {"sha": "1efa19a3a828655d22f7721cb4357d3cb5a308ff", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,11 +1,13 @@\n+use super::errors::{\n+    ArbitraryExpressionInPattern, ExtraDoubleDot, MisplacedDoubleDot, SubTupleBinding,\n+};\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n use crate::ImplTraitPosition;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::symbol::Ident;\n@@ -134,20 +136,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // This is not allowed as a sub-tuple pattern\n                 PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n                     let sp = pat.span;\n-                    self.diagnostic()\n-                        .struct_span_err(\n-                            sp,\n-                            &format!(\"`{} @` is not allowed in a {}\", ident.name, ctx),\n-                        )\n-                        .span_label(sp, \"this is only allowed in slice patterns\")\n-                        .help(\"remove this and bind each tuple field independently\")\n-                        .span_suggestion_verbose(\n-                            sp,\n-                            &format!(\"if you don't need to use the contents of {}, discard the tuple's remaining fields\", ident),\n-                            \"..\",\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(SubTupleBinding {\n+                        span: sp,\n+                        ident_name: ident.name,\n+                        ident,\n+                        ctx,\n+                    });\n                 }\n                 _ => {}\n             }\n@@ -296,19 +290,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n     pub(crate) fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n-        self.diagnostic()\n-            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n-            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n-            .span_label(prev_sp, \"previously used here\")\n-            .emit();\n+        self.tcx.sess.emit_err(ExtraDoubleDot { span: sp, prev_span: prev_sp, ctx });\n     }\n \n     /// Used to ban the `..` pattern in places it shouldn't be semantically.\n     fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n-        self.diagnostic()\n-            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n-            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n-            .emit();\n+        self.tcx.sess.emit_err(MisplacedDoubleDot { span: sp });\n \n         // We're not in a list context so `..` can be reasonably treated\n         // as `_` because it should always be valid and roughly matches the\n@@ -345,8 +332,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n-                self.diagnostic()\n-                    .span_err(expr.span, \"arbitrary expressions aren't allowed in patterns\");\n+                self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n                 return self.arena.alloc(self.expr_err(expr.span));\n             }\n         }"}, {"sha": "5874d08a94fe06bac55a516e8abef538f386aa58", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,11 +1,11 @@\n use crate::ImplTraitPosition;\n \n+use super::errors::{GenericTypeWithParentheses, UseAngleBrackets};\n use super::ResolverAstLoweringExt;\n use super::{GenericArgsCtor, LifetimeRes, ParenthesizedGenericArgs};\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n \n use rustc_ast::{self as ast, *};\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, PartialRes, Res};\n use rustc_hir::GenericArg;\n@@ -185,18 +185,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n                 GenericArgs::AngleBracketed(ref data) => {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Err => {\n-                        let mut err = struct_span_err!(self.tcx.sess, data.span, E0214, \"{}\", msg);\n-                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n                         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n-                        if !data.inputs.is_empty() {\n+                        let sub = if !data.inputs.is_empty() {\n                             // Start of the span to the 1st character of 1st argument\n                             let open_param = data.inputs_span.shrink_to_lo().to(data\n                                 .inputs\n@@ -212,16 +209,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 .span\n                                 .shrink_to_hi()\n                                 .to(data.inputs_span.shrink_to_hi());\n-                            err.multipart_suggestion(\n-                                &format!(\"use angle brackets instead\",),\n-                                vec![\n-                                    (open_param, String::from(\"<\")),\n-                                    (close_param, String::from(\">\")),\n-                                ],\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        err.emit();\n+\n+                            Some(UseAngleBrackets { open_param, close_param })\n+                        } else {\n+                            None\n+                        };\n+                        self.tcx.sess.emit_err(GenericTypeWithParentheses { span: data.span, sub });\n                         (\n                             self.lower_angle_bracketed_parameter_data(\n                                 &data.as_angle_bracketed_args(),"}, {"sha": "37eff9207c128688b02768b9bddfac6c9b360719", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -11,6 +11,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "c36c4ad54da4878c4c8b25ebb01d7196bd2fe2c2", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 84, "deletions": 167, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, pluralize, struct_span_err, Applicability, Diagnostic};\n+use rustc_errors::{error_code, fluent, pluralize, struct_span_err, Applicability};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n     DEPRECATED_WHERE_CLAUSE_LOCATION, MISSING_ABI, PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -27,6 +27,8 @@ use rustc_target::spec::abi;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n \n+use crate::errors::*;\n+\n const MORE_EXTERN: &str =\n     \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n \n@@ -117,23 +119,12 @@ impl<'a> AstValidator<'a> {\n \n     /// Emits an error banning the `let` expression provided in the given location.\n     fn ban_let_expr(&self, expr: &'a Expr, forbidden_let_reason: ForbiddenLetReason) {\n-        let err = \"`let` expressions are not supported here\";\n-        let mut diag = self.session.struct_span_err(expr.span, err);\n-        diag.note(\"only supported directly in conditions of `if` and `while` expressions\");\n-        match forbidden_let_reason {\n-            ForbiddenLetReason::GenericForbidden => {}\n-            ForbiddenLetReason::NotSupportedOr(span) => {\n-                diag.span_note(span, \"`||` operators are not supported in let chain expressions\");\n-            }\n-            ForbiddenLetReason::NotSupportedParentheses(span) => {\n-                diag.span_note(\n-                    span,\n-                    \"`let`s wrapped in parentheses are not supported in a context with let \\\n-                    chains\",\n-                );\n-            }\n+        let sess = &self.session;\n+        if sess.opts.unstable_features.is_nightly_build() {\n+            sess.emit_err(ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n+        } else {\n+            sess.emit_err(ForbiddenLetStable { span: expr.span });\n         }\n-        diag.emit();\n     }\n \n     fn check_gat_where(\n@@ -163,7 +154,7 @@ impl<'a> AstValidator<'a> {\n                 DEPRECATED_WHERE_CLAUSE_LOCATION,\n                 id,\n                 where_clauses.0.1,\n-                \"where clause not allowed here\",\n+                fluent::ast_passes::deprecated_where_clause_location,\n                 BuiltinLintDiagnostics::DeprecatedWhereclauseLocation(\n                     where_clauses.1.1.shrink_to_hi(),\n                     suggestion,\n@@ -193,10 +184,7 @@ impl<'a> AstValidator<'a> {\n             AssocConstraintKind::Equality { .. } => {}\n             AssocConstraintKind::Bound { .. } => {\n                 if self.is_assoc_ty_bound_banned {\n-                    self.err_handler().span_err(\n-                        constraint.span,\n-                        \"associated type bounds are not allowed within structs, enums, or unions\",\n-                    );\n+                    self.session.emit_err(ForbiddenAssocConstraint { span: constraint.span });\n                 }\n             }\n         }\n@@ -268,31 +256,26 @@ impl<'a> AstValidator<'a> {\n     fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n-            self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n+            self.session.emit_err(KeywordLifetime { span: ident.span });\n         }\n     }\n \n     fn check_label(&self, ident: Ident) {\n         if ident.without_first_quote().is_reserved() {\n-            self.err_handler()\n-                .span_err(ident.span, &format!(\"invalid label name `{}`\", ident.name));\n+            self.session.emit_err(InvalidLabel { span: ident.span, name: ident.name });\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, note: Option<&str>) {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<InvalidVisibilityNote>) {\n         if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n-        let mut err =\n-            struct_span_err!(self.session, vis.span, E0449, \"unnecessary visibility qualifier\");\n-        if vis.kind.is_pub() {\n-            err.span_label(vis.span, \"`pub` not permitted here because it's implied\");\n-        }\n-        if let Some(note) = note {\n-            err.note(note);\n-        }\n-        err.emit();\n+        self.session.emit_err(InvalidVisibility {\n+            span: vis.span,\n+            implied: if vis.kind.is_pub() { Some(vis.span) } else { None },\n+            note,\n+        });\n     }\n \n     fn check_decl_no_pat(decl: &FnDecl, mut report_err: impl FnMut(Span, Option<Ident>, bool)) {\n@@ -309,29 +292,13 @@ impl<'a> AstValidator<'a> {\n \n     fn check_trait_fn_not_async(&self, fn_span: Span, asyncness: Async) {\n         if let Async::Yes { span, .. } = asyncness {\n-            struct_span_err!(\n-                self.session,\n-                fn_span,\n-                E0706,\n-                \"functions in traits cannot be declared `async`\"\n-            )\n-            .span_label(span, \"`async` because of this\")\n-            .note(\"`async` trait functions are not currently supported\")\n-            .note(\"consider using the `async-trait` crate: https://crates.io/crates/async-trait\")\n-            .emit();\n+            self.session.emit_err(TraitFnAsync { fn_span, span });\n         }\n     }\n \n     fn check_trait_fn_not_const(&self, constness: Const) {\n         if let Const::Yes(span) = constness {\n-            struct_span_err!(\n-                self.session,\n-                span,\n-                E0379,\n-                \"functions in traits cannot be declared const\"\n-            )\n-            .span_label(span, \"functions in traits cannot be const\")\n-            .emit();\n+            self.session.emit_err(TraitFnConst { span });\n         }\n     }\n \n@@ -344,19 +311,15 @@ impl<'a> AstValidator<'a> {\n                 GenericParamKind::Lifetime { .. } => {\n                     if !param.bounds.is_empty() {\n                         let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                        self.err_handler()\n-                            .span_err(spans, \"lifetime bounds cannot be used in this context\");\n+                        self.session.emit_err(ForbiddenLifetimeBound { spans });\n                     }\n                     None\n                 }\n                 _ => Some(param.ident.span),\n             })\n             .collect();\n         if !non_lt_param_spans.is_empty() {\n-            self.err_handler().span_err(\n-                non_lt_param_spans,\n-                \"only lifetime parameters can be used in this context\",\n-            );\n+            self.session.emit_err(ForbiddenNonLifetimeParam { spans: non_lt_param_spans });\n         }\n     }\n \n@@ -373,30 +336,21 @@ impl<'a> AstValidator<'a> {\n         let max_num_args: usize = u16::MAX.into();\n         if fn_decl.inputs.len() > max_num_args {\n             let Param { span, .. } = fn_decl.inputs[0];\n-            self.err_handler().span_fatal(\n-                span,\n-                &format!(\"function can not have more than {} arguments\", max_num_args),\n-            );\n+            self.session.emit_fatal(FnParamTooMany { span, max_num_args });\n         }\n     }\n \n     fn check_decl_cvaradic_pos(&self, fn_decl: &FnDecl) {\n         match &*fn_decl.inputs {\n             [Param { ty, span, .. }] => {\n                 if let TyKind::CVarArgs = ty.kind {\n-                    self.err_handler().span_err(\n-                        *span,\n-                        \"C-variadic function must be declared with at least one named argument\",\n-                    );\n+                    self.session.emit_err(FnParamCVarArgsOnly { span: *span });\n                 }\n             }\n             [ps @ .., _] => {\n                 for Param { ty, span, .. } in ps {\n                     if let TyKind::CVarArgs = ty.kind {\n-                        self.err_handler().span_err(\n-                            *span,\n-                            \"`...` must be the last argument of a C-variadic function\",\n-                        );\n+                        self.session.emit_err(FnParamCVarArgsNotLast { span: *span });\n                     }\n                 }\n             }\n@@ -423,82 +377,38 @@ impl<'a> AstValidator<'a> {\n             })\n             .for_each(|attr| {\n                 if attr.is_doc_comment() {\n-                    self.err_handler()\n-                        .struct_span_err(\n-                            attr.span,\n-                            \"documentation comments cannot be applied to function parameters\",\n-                        )\n-                        .span_label(attr.span, \"doc comments are not allowed here\")\n-                        .emit();\n+                    self.session.emit_err(FnParamDocComment { span: attr.span });\n                 } else {\n-                    self.err_handler().span_err(\n-                        attr.span,\n-                        \"allow, cfg, cfg_attr, deny, expect, \\\n-                forbid, and warn are the only allowed built-in attributes in function parameters\",\n-                    );\n+                    self.session.emit_err(FnParamForbiddenAttr { span: attr.span });\n                 }\n             });\n     }\n \n     fn check_decl_self_param(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         if let (SelfSemantic::No, [param, ..]) = (self_semantic, &*fn_decl.inputs) {\n             if param.is_self() {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        param.span,\n-                        \"`self` parameter is only allowed in associated functions\",\n-                    )\n-                    .span_label(param.span, \"not semantically valid as function parameter\")\n-                    .note(\"associated functions are those in `impl` or `trait` definitions\")\n-                    .emit();\n+                self.session.emit_err(FnParamForbiddenSelf { span: param.span });\n             }\n         }\n     }\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n             let span = self.session.source_map().guess_head_span(span);\n-            self.err_handler()\n-                .struct_span_err(span, \"`default` is only allowed on items in trait impls\")\n-                .span_label(def_span, \"`default` because of this\")\n-                .emit();\n+            self.session.emit_err(ForbiddenDefault { span, def_span });\n         }\n     }\n \n-    fn error_item_without_body(&self, sp: Span, ctx: &str, msg: &str, sugg: &str) {\n-        self.error_item_without_body_with_help(sp, ctx, msg, sugg, |_| ());\n-    }\n-\n-    fn error_item_without_body_with_help(\n-        &self,\n-        sp: Span,\n-        ctx: &str,\n-        msg: &str,\n-        sugg: &str,\n-        help: impl FnOnce(&mut Diagnostic),\n-    ) {\n+    /// If `sp` ends with a semicolon, returns it as a `Span`\n+    /// Otherwise, returns `sp.shrink_to_hi()`\n+    fn ending_semi_or_hi(&self, sp: Span) -> Span {\n         let source_map = self.session.source_map();\n         let end = source_map.end_point(sp);\n-        let replace_span = if source_map.span_to_snippet(end).map(|s| s == \";\").unwrap_or(false) {\n+\n+        if source_map.span_to_snippet(end).map(|s| s == \";\").unwrap_or(false) {\n             end\n         } else {\n             sp.shrink_to_hi()\n-        };\n-        let mut err = self.err_handler().struct_span_err(sp, msg);\n-        err.span_suggestion(\n-            replace_span,\n-            &format!(\"provide a definition for the {}\", ctx),\n-            sugg,\n-            Applicability::HasPlaceholders,\n-        );\n-        help(&mut err);\n-        err.emit();\n-    }\n-\n-    fn check_impl_item_provided<T>(&self, sp: Span, body: &Option<T>, ctx: &str, sugg: &str) {\n-        if body.is_none() {\n-            let msg = format!(\"associated {} in `impl` without body\", ctx);\n-            self.error_item_without_body(sp, ctx, &msg, sugg);\n         }\n     }\n \n@@ -1168,7 +1078,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(\"place qualifiers on individual impl items instead\"),\n+                    Some(InvalidVisibilityNote::IndividualImplItems),\n                 );\n                 if let Unsafe::Yes(span) = unsafety {\n                     error(span, \"unsafe\").code(error_code!(E0197)).emit();\n@@ -1191,37 +1101,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.check_defaultness(item.span, defaultness);\n \n                 if body.is_none() {\n-                    let msg = \"free function without a body\";\n-                    let ext = sig.header.ext;\n-\n-                    let f = |e: &mut Diagnostic| {\n-                        if let Extern::Implicit(start_span) | Extern::Explicit(_, start_span) = &ext\n-                        {\n-                            let start_suggestion = if let Extern::Explicit(abi, _) = ext {\n-                                format!(\"extern \\\"{}\\\" {{\", abi.symbol_unescaped)\n-                            } else {\n-                                \"extern {\".to_owned()\n-                            };\n-\n-                            let end_suggestion = \" }\".to_owned();\n-                            let end_span = item.span.shrink_to_hi();\n-\n-                            e\n-                            .multipart_suggestion(\n-                                \"if you meant to declare an externally defined function, use an `extern` block\",\n-                                vec![(*start_span, start_suggestion), (end_span, end_suggestion)],\n-                                Applicability::MaybeIncorrect,\n-                             );\n-                        }\n-                    };\n-\n-                    self.error_item_without_body_with_help(\n-                        item.span,\n-                        \"function\",\n-                        msg,\n-                        \" { <body> }\",\n-                        f,\n-                    );\n+                    self.session.emit_err(FnWithoutBody {\n+                        span: item.span,\n+                        replace_span: self.ending_semi_or_hi(item.span),\n+                        extern_block_suggestion: match sig.header.ext {\n+                            Extern::None => None,\n+                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion {\n+                                start_span,\n+                                end_span: item.span.shrink_to_hi(),\n+                                abi: None,\n+                            }),\n+                            Extern::Explicit(abi, start_span) => Some(ExternBlockSuggestion {\n+                                start_span,\n+                                end_span: item.span.shrink_to_hi(),\n+                                abi: Some(abi.symbol_unescaped),\n+                            }),\n+                        },\n+                    });\n                 }\n \n                 self.visit_vis(&item.vis);\n@@ -1236,7 +1132,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(\"place qualifiers on individual foreign items instead\"),\n+                    Some(InvalidVisibilityNote::IndividualForeignItems),\n                 );\n                 if let Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n@@ -1327,12 +1223,16 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, def);\n-                let msg = \"free constant item without body\";\n-                self.error_item_without_body(item.span, \"constant\", msg, \" = <expr>;\");\n+                self.session.emit_err(ConstWithoutBody {\n+                    span: item.span,\n+                    replace_span: self.ending_semi_or_hi(item.span),\n+                });\n             }\n             ItemKind::Static(.., None) => {\n-                let msg = \"free static item without body\";\n-                self.error_item_without_body(item.span, \"static\", msg, \" = <expr>;\");\n+                self.session.emit_err(StaticWithoutBody {\n+                    span: item.span,\n+                    replace_span: self.ending_semi_or_hi(item.span),\n+                });\n             }\n             ItemKind::TyAlias(box TyAlias {\n                 defaultness,\n@@ -1343,8 +1243,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }) => {\n                 self.check_defaultness(item.span, defaultness);\n                 if ty.is_none() {\n-                    let msg = \"free type alias without body\";\n-                    self.error_item_without_body(item.span, \"type\", msg, \" = <type>;\");\n+                    self.session.emit_err(TyAliasWithoutBody {\n+                        span: item.span,\n+                        replace_span: self.ending_semi_or_hi(item.span),\n+                    });\n                 }\n                 self.check_type_no_bounds(bounds, \"this context\");\n                 if where_clauses.1.0 {\n@@ -1648,10 +1550,20 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         if ctxt == AssocCtxt::Impl {\n             match &item.kind {\n                 AssocItemKind::Const(_, _, body) => {\n-                    self.check_impl_item_provided(item.span, body, \"constant\", \" = <expr>;\");\n+                    if body.is_none() {\n+                        self.session.emit_err(AssocConstWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                 }\n                 AssocItemKind::Fn(box Fn { body, .. }) => {\n-                    self.check_impl_item_provided(item.span, body, \"function\", \" { <body> }\");\n+                    if body.is_none() {\n+                        self.session.emit_err(AssocFnWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                 }\n                 AssocItemKind::TyAlias(box TyAlias {\n                     generics,\n@@ -1661,7 +1573,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     ty,\n                     ..\n                 }) => {\n-                    self.check_impl_item_provided(item.span, ty, \"type\", \" = <type>;\");\n+                    if ty.is_none() {\n+                        self.session.emit_err(AssocTypeWithoutBody {\n+                            span: item.span,\n+                            replace_span: self.ending_semi_or_hi(item.span),\n+                        });\n+                    }\n                     self.check_type_no_bounds(bounds, \"`impl`s\");\n                     if ty.is_some() {\n                         self.check_gat_where(\n@@ -1876,7 +1793,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n \n /// Used to forbid `let` expressions in certain syntactic locations.\n #[derive(Clone, Copy)]\n-enum ForbiddenLetReason {\n+pub(crate) enum ForbiddenLetReason {\n     /// `let` is not valid and the source environment is not important\n     GenericForbidden,\n     /// A let chain with the `||` operator"}, {"sha": "21467e57651983fc78b918370d749af62bb78372", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,256 @@\n+//! Errors emitted by ast_passes.\n+\n+use rustc_errors::{fluent, AddSubdiagnostic, Applicability, Diagnostic};\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::ast_validation::ForbiddenLetReason;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_let)]\n+#[note]\n+pub struct ForbiddenLet {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub(crate) reason: ForbiddenLetReason,\n+}\n+\n+impl AddSubdiagnostic for ForbiddenLetReason {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        match self {\n+            Self::GenericForbidden => {}\n+            Self::NotSupportedOr(span) => {\n+                diag.span_note(span, fluent::ast_passes::not_supported_or);\n+            }\n+            Self::NotSupportedParentheses(span) => {\n+                diag.span_note(span, fluent::ast_passes::not_supported_parentheses);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_let_stable)]\n+#[note]\n+pub struct ForbiddenLetStable {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_assoc_constraint)]\n+pub struct ForbiddenAssocConstraint {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::keyword_lifetime)]\n+pub struct KeywordLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::invalid_label)]\n+pub struct InvalidLabel {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::invalid_visibility, code = \"E0449\")]\n+pub struct InvalidVisibility {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes::implied)]\n+    pub implied: Option<Span>,\n+    #[subdiagnostic]\n+    pub note: Option<InvalidVisibilityNote>,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum InvalidVisibilityNote {\n+    #[note(ast_passes::individual_impl_items)]\n+    IndividualImplItems,\n+    #[note(ast_passes::individual_foreign_items)]\n+    IndividualForeignItems,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::trait_fn_async, code = \"E0706\")]\n+#[note]\n+#[note(ast_passes::note2)]\n+pub struct TraitFnAsync {\n+    #[primary_span]\n+    pub fn_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::trait_fn_const, code = \"E0379\")]\n+pub struct TraitFnConst {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_lifetime_bound)]\n+pub struct ForbiddenLifetimeBound {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_non_lifetime_param)]\n+pub struct ForbiddenNonLifetimeParam {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_too_many)]\n+pub struct FnParamTooMany {\n+    #[primary_span]\n+    pub span: Span,\n+    pub max_num_args: usize,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_c_var_args_only)]\n+pub struct FnParamCVarArgsOnly {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_c_var_args_not_last)]\n+pub struct FnParamCVarArgsNotLast {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_doc_comment)]\n+pub struct FnParamDocComment {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_forbidden_attr)]\n+pub struct FnParamForbiddenAttr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_param_forbidden_self)]\n+#[note]\n+pub struct FnParamForbiddenSelf {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::forbidden_default)]\n+pub struct ForbiddenDefault {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub def_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_const_without_body)]\n+pub struct AssocConstWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_fn_without_body)]\n+pub struct AssocFnWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" {{ <body> }}\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::assoc_type_without_body)]\n+pub struct AssocTypeWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <type>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::const_without_body)]\n+pub struct ConstWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::static_without_body)]\n+pub struct StaticWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <expr>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::ty_alias_without_body)]\n+pub struct TyAliasWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" = <type>;\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(ast_passes::fn_without_body)]\n+pub struct FnWithoutBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \" {{ <body> }}\", applicability = \"has-placeholders\")]\n+    pub replace_span: Span,\n+    #[subdiagnostic]\n+    pub extern_block_suggestion: Option<ExternBlockSuggestion>,\n+}\n+\n+pub struct ExternBlockSuggestion {\n+    pub start_span: Span,\n+    pub end_span: Span,\n+    pub abi: Option<Symbol>,\n+}\n+\n+impl AddSubdiagnostic for ExternBlockSuggestion {\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        let start_suggestion = if let Some(abi) = self.abi {\n+            format!(\"extern \\\"{}\\\" {{\", abi)\n+        } else {\n+            \"extern {\".to_owned()\n+        };\n+        let end_suggestion = \" }\".to_owned();\n+\n+        diag.multipart_suggestion(\n+            fluent::ast_passes::extern_block_suggestion,\n+            vec![(self.start_span, start_suggestion), (self.end_span, end_suggestion)],\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}"}, {"sha": "6f7e88eb86f195e074a38cab814758c0f57d54d0", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,10 +2,10 @@ use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd, VariantData};\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_feature::Features;\n use rustc_feature::{AttributeGate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n-use rustc_feature::{Features, GateIssue};\n-use rustc_session::parse::{feature_err, feature_err_issue};\n+use rustc_session::parse::{feature_err, feature_warn};\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n@@ -20,9 +20,7 @@ macro_rules! gate_feature_fn {\n         let has_feature: bool = has_feature(visitor.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n-            feature_err_issue(&visitor.sess.parse_sess, name, span, GateIssue::Language, explain)\n-                .help(help)\n-                .emit();\n+            feature_err(&visitor.sess.parse_sess, name, span, explain).help(help).emit();\n         }\n     }};\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n@@ -31,8 +29,19 @@ macro_rules! gate_feature_fn {\n         let has_feature: bool = has_feature(visitor.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n-            feature_err_issue(&visitor.sess.parse_sess, name, span, GateIssue::Language, explain)\n-                .emit();\n+            feature_err(&visitor.sess.parse_sess, name, span, explain).emit();\n+        }\n+    }};\n+    (future_incompatible; $visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n+        let (visitor, has_feature, span, name, explain) =\n+            (&*$visitor, $has_feature, $span, $name, $explain);\n+        let has_feature: bool = has_feature(visitor.features);\n+        debug!(\n+            \"gate_feature(feature = {:?}, span = {:?}); has? {} (future_incompatible)\",\n+            name, span, has_feature\n+        );\n+        if !has_feature && !span.allows_unstable($name) {\n+            feature_warn(&visitor.sess.parse_sess, name, span, explain);\n         }\n     }};\n }\n@@ -44,6 +53,9 @@ macro_rules! gate_feature_post {\n     ($visitor: expr, $feature: ident, $span: expr, $explain: expr) => {\n         gate_feature_fn!($visitor, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n     };\n+    (future_incompatible; $visitor: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!(future_incompatible; $visitor, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n+    };\n }\n \n pub fn check_attribute(attr: &ast::Attribute, sess: &Session, features: &Features) {\n@@ -588,11 +600,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         {\n             // When we encounter a statement of the form `foo: Ty = val;`, this will emit a type\n             // ascription error, but the likely intention was to write a `let` statement. (#78907).\n-            feature_err_issue(\n+            feature_err(\n                 &self.sess.parse_sess,\n                 sym::type_ascription,\n                 lhs.span,\n-                GateIssue::Language,\n                 \"type ascription is experimental\",\n             ).span_suggestion_verbose(\n                 lhs.span.shrink_to_lo(),\n@@ -615,28 +626,27 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 );\n             }\n             ast::ExprKind::Type(..) => {\n-                // To avoid noise about type ascription in common syntax errors, only emit if it\n-                // is the *only* error.\n                 if self.sess.parse_sess.span_diagnostic.err_count() == 0 {\n+                    // To avoid noise about type ascription in common syntax errors,\n+                    // only emit if it is the *only* error.\n                     gate_feature_post!(\n                         &self,\n                         type_ascription,\n                         e.span,\n                         \"type ascription is experimental\"\n                     );\n+                } else {\n+                    // And if it isn't, cancel the early-pass warning.\n+                    self.sess\n+                        .parse_sess\n+                        .span_diagnostic\n+                        .steal_diagnostic(e.span, StashKey::EarlySyntaxWarning)\n+                        .map(|err| err.cancel());\n                 }\n             }\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n-            ast::ExprKind::Block(_, Some(label)) => {\n-                gate_feature_post!(\n-                    &self,\n-                    label_break_value,\n-                    label.ident.span,\n-                    \"labels on blocks are unstable\"\n-                );\n-            }\n             _ => {}\n         }\n         visit::walk_expr(self, e)\n@@ -767,6 +777,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n         \"`if let` guards are experimental\",\n         \"you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\"\n     );\n+    gate_all!(let_chains, \"`let` expressions in this position are unstable\");\n     gate_all!(\n         async_closure,\n         \"async closures are unstable\",\n@@ -789,14 +800,12 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded).\n+    // We emit an early future-incompatible warning for these.\n+    // New syntax gates should go above here to get a hard error gate.\n     macro_rules! gate_all {\n         ($gate:ident, $msg:literal) => {\n-            // FIXME(eddyb) do something more useful than always\n-            // disabling these uses of early feature-gatings.\n-            if false {\n-                for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n-                    gate_feature_post!(&visitor, $gate, *span, $msg);\n-                }\n+            for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n+                gate_feature_post!(future_incompatible; &visitor, $gate, *span, $msg);\n             }\n         };\n     }\n@@ -807,13 +816,8 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(box_patterns, \"box pattern syntax is experimental\");\n     gate_all!(exclusive_range_pattern, \"exclusive range pattern syntax is experimental\");\n     gate_all!(try_blocks, \"`try` blocks are unstable\");\n-    gate_all!(label_break_value, \"labels on blocks are unstable\");\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n-    // To avoid noise about type ascription in common syntax errors,\n-    // only emit if it is the *only* error. (Also check it last.)\n-    if sess.parse_sess.span_diagnostic.err_count() == 0 {\n-        gate_all!(type_ascription, \"type ascription is experimental\");\n-    }\n+    gate_all!(type_ascription, \"type ascription is experimental\");\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "f282ff251bda181ca8c7f97c961382c1cd1c1b95", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,10 +8,12 @@\n #![feature(box_patterns)]\n #![feature(if_let_guard)]\n #![feature(iter_is_partitioned)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![recursion_limit = \"256\"]\n \n pub mod ast_validation;\n+mod errors;\n pub mod feature_gate;\n pub mod node_count;\n pub mod show_span;"}, {"sha": "bf094af5f7bb0910beec66e0b3d114457345943c", "filename": "compiler/rustc_ast_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n #![feature(with_negative_coherence)]"}, {"sha": "65edab78ce74ece4c3b2cb1098b7db250851346b", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 113, "deletions": 217, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -3,7 +3,6 @@\n use rustc_ast as ast;\n use rustc_ast::{Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n use rustc_session::lint::builtin::UNEXPECTED_CFGS;\n@@ -14,6 +13,8 @@ use rustc_span::hygiene::Transparency;\n use rustc_span::{symbol::sym, symbol::Symbol, Span};\n use std::num::NonZeroU32;\n \n+use crate::session_diagnostics::{self, IncorrectReprFormatGenericCause};\n+\n pub fn is_builtin_attr(attr: &Attribute) -> bool {\n     attr.is_doc_comment() || attr.ident().filter(|ident| is_builtin_attr_name(ident.name)).is_some()\n }\n@@ -25,46 +26,38 @@ enum AttrError {\n     NonIdentFeature,\n     MissingFeature,\n     MultipleStabilityLevels,\n-    UnsupportedLiteral(&'static str, /* is_bytestr */ bool),\n+    UnsupportedLiteral(UnsupportedLiteralReason, /* is_bytestr */ bool),\n+}\n+\n+pub(crate) enum UnsupportedLiteralReason {\n+    Generic,\n+    CfgString,\n+    DeprecatedString,\n+    DeprecatedKvPair,\n }\n \n fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n-    let diag = &sess.span_diagnostic;\n     match error {\n         AttrError::MultipleItem(item) => {\n-            struct_span_err!(diag, span, E0538, \"multiple '{}' items\", item).emit();\n+            sess.emit_err(session_diagnostics::MultipleItem { span, item });\n         }\n         AttrError::UnknownMetaItem(item, expected) => {\n-            let expected = expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n-            struct_span_err!(diag, span, E0541, \"unknown meta item '{}'\", item)\n-                .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n-                .emit();\n+            sess.emit_err(session_diagnostics::UnknownMetaItem { span, item, expected });\n         }\n         AttrError::MissingSince => {\n-            struct_span_err!(diag, span, E0542, \"missing 'since'\").emit();\n+            sess.emit_err(session_diagnostics::MissingSince { span });\n         }\n         AttrError::NonIdentFeature => {\n-            struct_span_err!(diag, span, E0546, \"'feature' is not an identifier\").emit();\n+            sess.emit_err(session_diagnostics::NonIdentFeature { span });\n         }\n         AttrError::MissingFeature => {\n-            struct_span_err!(diag, span, E0546, \"missing 'feature'\").emit();\n+            sess.emit_err(session_diagnostics::MissingFeature { span });\n         }\n         AttrError::MultipleStabilityLevels => {\n-            struct_span_err!(diag, span, E0544, \"multiple stability levels\").emit();\n+            sess.emit_err(session_diagnostics::MultipleStabilityLevels { span });\n         }\n-        AttrError::UnsupportedLiteral(msg, is_bytestr) => {\n-            let mut err = struct_span_err!(diag, span, E0565, \"{}\", msg);\n-            if is_bytestr {\n-                if let Ok(lint_str) = sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider removing the prefix\",\n-                        &lint_str[1..],\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n-            err.emit();\n+        AttrError::UnsupportedLiteral(reason, is_bytestr) => {\n+            sess.emit_err(session_diagnostics::UnsupportedLiteral { span, reason, is_bytestr });\n         }\n     }\n }\n@@ -243,8 +236,6 @@ where\n     let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n-    let diagnostic = &sess.parse_sess.span_diagnostic;\n-\n     'outer: for attr in attrs_iter {\n         if ![\n             sym::rustc_const_unstable,\n@@ -284,7 +275,7 @@ where\n                     *item = Some(v);\n                     true\n                 } else {\n-                    struct_span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\").emit();\n+                    sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n                     false\n                 }\n             };\n@@ -326,7 +317,7 @@ where\n                             handle_errors(\n                                 &sess.parse_sess,\n                                 meta.span(),\n-                                AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n                             );\n                             continue 'outer;\n                         };\n@@ -350,39 +341,28 @@ where\n                                 // is a name/value pair string literal.\n                                 issue_num = match issue.unwrap().as_str() {\n                                     \"none\" => None,\n-                                    issue => {\n-                                        let emit_diag = |msg: &str| {\n-                                            struct_span_err!(\n-                                                diagnostic,\n-                                                mi.span,\n-                                                E0545,\n-                                                \"`issue` must be a non-zero numeric string \\\n-                                                or \\\"none\\\"\",\n-                                            )\n-                                            .span_label(mi.name_value_literal_span().unwrap(), msg)\n-                                            .emit();\n-                                        };\n-                                        match issue.parse() {\n-                                            Ok(0) => {\n-                                                emit_diag(\n-                                                    \"`issue` must not be \\\"0\\\", \\\n-                                                    use \\\"none\\\" instead\",\n-                                                );\n-                                                continue 'outer;\n-                                            }\n-                                            Ok(num) => NonZeroU32::new(num),\n-                                            Err(err) => {\n-                                                emit_diag(&err.to_string());\n-                                                continue 'outer;\n-                                            }\n+                                    issue => match issue.parse::<NonZeroU32>() {\n+                                        Ok(num) => Some(num),\n+                                        Err(err) => {\n+                                            sess.emit_err(\n+                                                session_diagnostics::InvalidIssueString {\n+                                                    span: mi.span,\n+                                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n+                                                        mi.name_value_literal_span().unwrap(),\n+                                                        err.kind(),\n+                                                    ),\n+                                                },\n+                                            );\n+                                            continue 'outer;\n                                         }\n-                                    }\n+                                    },\n                                 };\n                             }\n                             sym::soft => {\n                                 if !mi.is_word() {\n-                                    let msg = \"`soft` should not have any arguments\";\n-                                    sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n+                                    sess.emit_err(session_diagnostics::SoftNoArgs {\n+                                        span: mi.span,\n+                                    });\n                                 }\n                                 is_soft = true;\n                             }\n@@ -440,8 +420,7 @@ where\n                             continue;\n                         }\n                         _ => {\n-                            struct_span_err!(diagnostic, attr.span, E0547, \"missing 'issue'\")\n-                                .emit();\n+                            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n                             continue;\n                         }\n                     }\n@@ -494,7 +473,10 @@ where\n                                 handle_errors(\n                                     &sess.parse_sess,\n                                     lit.span,\n-                                    AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                                    AttrError::UnsupportedLiteral(\n+                                        UnsupportedLiteralReason::Generic,\n+                                        false,\n+                                    ),\n                                 );\n                                 continue 'outer;\n                             }\n@@ -533,14 +515,7 @@ where\n         if let Some((ref mut stab, _)) = const_stab {\n             stab.promotable = promotable;\n         } else {\n-            struct_span_err!(\n-                diagnostic,\n-                item_sp,\n-                E0717,\n-                \"`rustc_promotable` attribute must be paired with either a `rustc_const_unstable` \\\n-                or a `rustc_const_stable` attribute\"\n-            )\n-            .emit();\n+            sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp });\n         }\n     }\n \n@@ -555,13 +530,7 @@ where\n         {\n             *allowed_through_unstable_modules = true;\n         } else {\n-            struct_span_err!(\n-                diagnostic,\n-                item_sp,\n-                E0789,\n-                \"`rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\"\n-            )\n-            .emit();\n+            sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n         }\n     }\n \n@@ -675,25 +644,18 @@ pub fn eval_condition(\n                     NestedMetaItem::Literal(Lit { span, .. })\n                     | NestedMetaItem::MetaItem(MetaItem { span, .. }),\n                 ] => {\n-                    sess.span_diagnostic\n-                        .struct_span_err(*span, \"expected a version literal\")\n-                        .emit();\n+                    sess.emit_err(session_diagnostics::ExpectedVersionLiteral { span: *span });\n                     return false;\n                 }\n                 [..] => {\n-                    sess.span_diagnostic\n-                        .struct_span_err(cfg.span, \"expected single version literal\")\n-                        .emit();\n+                    sess.emit_err(session_diagnostics::ExpectedSingleVersionLiteral {\n+                        span: cfg.span,\n+                    });\n                     return false;\n                 }\n             };\n             let Some(min_version) = parse_version(min_version.as_str(), false) else {\n-                sess.span_diagnostic\n-                    .struct_span_warn(\n-                        *span,\n-                        \"unknown version literal format, assuming it refers to a future version\",\n-                    )\n-                    .emit();\n+                sess.emit_warning(session_diagnostics::UnknownVersionLiteral { span: *span });\n                 return false;\n             };\n             let rustc_version = parse_version(env!(\"CFG_RELEASE\"), true).unwrap();\n@@ -711,7 +673,7 @@ pub fn eval_condition(\n                     handle_errors(\n                         sess,\n                         mi.span(),\n-                        AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                        AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n                     );\n                     return false;\n                 }\n@@ -736,13 +698,9 @@ pub fn eval_condition(\n                     }),\n                 sym::not => {\n                     if mis.len() != 1 {\n-                        struct_span_err!(\n-                            sess.span_diagnostic,\n-                            cfg.span,\n-                            E0536,\n-                            \"expected 1 cfg-pattern\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::ExpectedOneCfgPattern {\n+                            span: cfg.span,\n+                        });\n                         return false;\n                     }\n \n@@ -768,29 +726,24 @@ pub fn eval_condition(\n                     })\n                 }\n                 _ => {\n-                    struct_span_err!(\n-                        sess.span_diagnostic,\n-                        cfg.span,\n-                        E0537,\n-                        \"invalid predicate `{}`\",\n-                        pprust::path_to_string(&cfg.path)\n-                    )\n-                    .emit();\n+                    sess.emit_err(session_diagnostics::InvalidPredicate {\n+                        span: cfg.span,\n+                        predicate: pprust::path_to_string(&cfg.path),\n+                    });\n                     false\n                 }\n             }\n         }\n         ast::MetaItemKind::Word | MetaItemKind::NameValue(..) if cfg.path.segments.len() != 1 => {\n-            sess.span_diagnostic\n-                .span_err(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n+            sess.emit_err(session_diagnostics::CfgPredicateIdentifier { span: cfg.path.span });\n             true\n         }\n         MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n             handle_errors(\n                 sess,\n                 lit.span,\n                 AttrError::UnsupportedLiteral(\n-                    \"literal in `cfg` predicate value must be a string\",\n+                    UnsupportedLiteralReason::CfgString,\n                     lit.kind.is_bytestr(),\n                 ),\n             );\n@@ -834,7 +787,6 @@ where\n     I: Iterator<Item = &'a Attribute>,\n {\n     let mut depr: Option<(Deprecation, Span)> = None;\n-    let diagnostic = &sess.parse_sess.span_diagnostic;\n     let is_rustc = sess.features_untracked().staged_api;\n \n     'outer: for attr in attrs_iter {\n@@ -870,14 +822,14 @@ where\n                                 &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n-                                    \"literal in `deprecated` \\\n-                                    value must be a string\",\n+                                    UnsupportedLiteralReason::DeprecatedString,\n                                     lit.kind.is_bytestr(),\n                                 ),\n                             );\n                         } else {\n-                            struct_span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\")\n-                                .emit();\n+                            sess.emit_err(session_diagnostics::IncorrectMetaItem2 {\n+                                span: meta.span,\n+                            });\n                         }\n \n                         false\n@@ -899,14 +851,11 @@ where\n                             }\n                             sym::suggestion => {\n                                 if !sess.features_untracked().deprecated_suggestion {\n-                                    let mut diag = sess.struct_span_err(\n-                                        mi.span,\n-                                        \"suggestions on deprecated items are unstable\",\n-                                    );\n-                                    if sess.is_nightly_build() {\n-                                        diag.help(\"add `#![feature(deprecated_suggestion)]` to the crate root\");\n-                                    }\n-                                    diag.note(\"see #94785 for more details\").emit();\n+                                    sess.emit_err(session_diagnostics::DeprecatedItemSuggestion {\n+                                        span: mi.span,\n+                                        is_nightly: sess.is_nightly_build().then_some(()),\n+                                        details: (),\n+                                    });\n                                 }\n \n                                 if !get(mi, &mut suggestion) {\n@@ -934,7 +883,7 @@ where\n                                 &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n-                                    \"item in `deprecated` must be a key/value pair\",\n+                                    UnsupportedLiteralReason::DeprecatedKvPair,\n                                     false,\n                                 ),\n                             );\n@@ -952,7 +901,7 @@ where\n             }\n \n             if note.is_none() {\n-                struct_span_err!(diagnostic, attr.span, E0543, \"missing 'note'\").emit();\n+                sess.emit_err(session_diagnostics::MissingNote { span: attr.span });\n                 continue;\n             }\n         }\n@@ -1022,19 +971,9 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     sym::simd => Some(ReprSimd),\n                     sym::transparent => Some(ReprTransparent),\n                     sym::align => {\n-                        let mut err = struct_span_err!(\n-                            diagnostic,\n-                            item.span(),\n-                            E0589,\n-                            \"invalid `repr(align)` attribute: `align` needs an argument\"\n-                        );\n-                        err.span_suggestion(\n-                            item.span(),\n-                            \"supply an argument here\",\n-                            \"align(...)\",\n-                            Applicability::HasPlaceholders,\n-                        );\n-                        err.emit();\n+                        sess.emit_err(session_diagnostics::InvalidReprAlignNeedArg {\n+                            span: item.span(),\n+                        });\n                         recognised = true;\n                         None\n                     }\n@@ -1063,109 +1002,66 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     || int_type_of_word(name).is_some()\n                 {\n                     recognised = true;\n-                    struct_span_err!(\n-                                diagnostic,\n-                                item.span(),\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n-                                name.to_ident_string(),\n-                            ).emit();\n+                    sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                        span: item.span(),\n+                        name: name.to_ident_string(),\n+                    });\n                 }\n                 if let Some(literal_error) = literal_error {\n-                    struct_span_err!(\n-                        diagnostic,\n-                        item.span(),\n-                        E0589,\n-                        \"invalid `repr({})` attribute: {}\",\n-                        name.to_ident_string(),\n-                        literal_error\n-                    )\n-                    .emit();\n+                    sess.emit_err(session_diagnostics::InvalidReprGeneric {\n+                        span: item.span(),\n+                        repr_arg: name.to_ident_string(),\n+                        error_part: literal_error,\n+                    });\n                 }\n             } else if let Some(meta_item) = item.meta_item() {\n                 if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n                     if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n                         let name = meta_item.name_or_empty().to_ident_string();\n                         recognised = true;\n-                        let mut err = struct_span_err!(\n-                            diagnostic,\n-                            item.span(),\n-                            E0693,\n-                            \"incorrect `repr({})` attribute format\",\n-                            name,\n-                        );\n-                        match value.kind {\n-                            ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                err.span_suggestion(\n-                                    item.span(),\n-                                    \"use parentheses instead\",\n-                                    format!(\"{}({})\", name, int),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            ast::LitKind::Str(s, _) => {\n-                                err.span_suggestion(\n-                                    item.span(),\n-                                    \"use parentheses instead\",\n-                                    format!(\"{}({})\", name, s),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            _ => {}\n-                        }\n-                        err.emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n+                            span: item.span(),\n+                            repr_arg: &name,\n+                            cause: IncorrectReprFormatGenericCause::from_lit_kind(\n+                                item.span(),\n+                                &value.kind,\n+                                &name,\n+                            ),\n+                        });\n                     } else {\n                         if matches!(\n                             meta_item.name_or_empty(),\n                             sym::C | sym::simd | sym::transparent\n                         ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n                         {\n                             recognised = true;\n-                            struct_span_err!(\n-                                diagnostic,\n-                                meta_item.span,\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a value\",\n-                                meta_item.name_or_empty().to_ident_string(),\n-                            )\n-                            .emit();\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n                         }\n                     }\n                 } else if let MetaItemKind::List(_) = meta_item.kind {\n                     if meta_item.has_name(sym::align) {\n                         recognised = true;\n-                        struct_span_err!(\n-                            diagnostic,\n-                            meta_item.span,\n-                            E0693,\n-                            \"incorrect `repr(align)` attribute format: \\\n-                                 `align` takes exactly one argument in parentheses\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n+                            span: meta_item.span,\n+                        });\n                     } else if meta_item.has_name(sym::packed) {\n                         recognised = true;\n-                        struct_span_err!(\n-                            diagnostic,\n-                            meta_item.span,\n-                            E0552,\n-                            \"incorrect `repr(packed)` attribute format: \\\n-                                 `packed` takes exactly one parenthesized argument, \\\n-                                 or no parentheses at all\"\n-                        )\n-                        .emit();\n+                        sess.emit_err(session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n+                            span: meta_item.span,\n+                        });\n                     } else if matches!(\n                         meta_item.name_or_empty(),\n                         sym::C | sym::simd | sym::transparent\n                     ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n                     {\n                         recognised = true;\n-                        struct_span_err!(\n-                                diagnostic,\n-                                meta_item.span,\n-                                E0552,\n-                                \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n-                                meta_item.name_or_empty().to_ident_string(),\n-                            ).emit();\n+                        sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                            span: meta_item.span,\n+                            name: meta_item.name_or_empty().to_ident_string(),\n+                        });\n                     }\n                 }\n             }\n@@ -1262,10 +1158,10 @@ fn allow_unstable<'a>(\n     let list = attrs\n         .filter_map(move |attr| {\n             attr.meta_item_list().or_else(|| {\n-                sess.diagnostic().span_err(\n-                    attr.span,\n-                    &format!(\"`{}` expects a list of feature names\", symbol.to_ident_string()),\n-                );\n+                sess.emit_err(session_diagnostics::ExpectsFeatureList {\n+                    span: attr.span,\n+                    name: symbol.to_ident_string(),\n+                });\n                 None\n             })\n         })\n@@ -1274,10 +1170,10 @@ fn allow_unstable<'a>(\n     list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {\n-            sess.diagnostic().span_err(\n-                it.span(),\n-                &format!(\"`{}` expects feature names\", symbol.to_ident_string()),\n-            );\n+            sess.emit_err(session_diagnostics::ExpectsFeatures {\n+                span: it.span(),\n+                name: symbol.to_ident_string(),\n+            });\n         }\n         name\n     })"}, {"sha": "053f848aacbf73351cd2d1bcc99d4663fbad6fa9", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -4,12 +4,16 @@\n //! The goal is to move the definition of `MetaItem` and things that don't need to be in `syntax`\n //! to this crate.\n \n+#![feature(let_chains)]\n #![feature(let_else)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;\n \n mod builtin;\n+mod session_diagnostics;\n \n pub use builtin::*;\n pub use IntType::*;"}, {"sha": "25cd960dbf1d0c232298fd6fee6f052f68392987", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "added", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,395 @@\n+use std::num::IntErrorKind;\n+\n+use rustc_ast as ast;\n+use rustc_errors::{error_code, fluent, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_macros::SessionDiagnostic;\n+use rustc_session::{parse::ParseSess, SessionDiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::UnsupportedLiteralReason;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_one_cfg_pattern, code = \"E0536\")]\n+pub(crate) struct ExpectedOneCfgPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_predicate, code = \"E0537\")]\n+pub(crate) struct InvalidPredicate {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub predicate: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::multiple_item, code = \"E0538\")]\n+pub(crate) struct MultipleItem {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub item: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_meta_item, code = \"E0539\")]\n+pub(crate) struct IncorrectMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// Error code: E0541\n+pub(crate) struct UnknownMetaItem<'a> {\n+    pub span: Span,\n+    pub item: String,\n+    pub expected: &'a [&'a str],\n+}\n+\n+// Manual implementation to be able to format `expected` items correctly.\n+impl<'a> SessionDiagnostic<'a> for UnknownMetaItem<'_> {\n+    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let expected = self.expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n+        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+            self.span,\n+            fluent::attr::unknown_meta_item,\n+            error_code!(E0541),\n+        );\n+        diag.set_arg(\"item\", self.item);\n+        diag.set_arg(\"expected\", expected.join(\", \"));\n+        diag.span_label(self.span, fluent::attr::label);\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_since, code = \"E0542\")]\n+pub(crate) struct MissingSince {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_note, code = \"E0543\")]\n+pub(crate) struct MissingNote {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::multiple_stability_levels, code = \"E0544\")]\n+pub(crate) struct MultipleStabilityLevels {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_issue_string, code = \"E0545\")]\n+pub(crate) struct InvalidIssueString {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    #[subdiagnostic]\n+    pub cause: Option<InvalidIssueStringCause>,\n+}\n+\n+// The error kinds of `IntErrorKind` are duplicated here in order to allow the messages to be\n+// translatable.\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum InvalidIssueStringCause {\n+    #[label(attr::must_not_be_zero)]\n+    MustNotBeZero {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::empty)]\n+    Empty {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::invalid_digit)]\n+    InvalidDigit {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::pos_overflow)]\n+    PosOverflow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+\n+    #[label(attr::neg_overflow)]\n+    NegOverflow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+impl InvalidIssueStringCause {\n+    pub fn from_int_error_kind(span: Span, kind: &IntErrorKind) -> Option<Self> {\n+        match kind {\n+            IntErrorKind::Empty => Some(Self::Empty { span }),\n+            IntErrorKind::InvalidDigit => Some(Self::InvalidDigit { span }),\n+            IntErrorKind::PosOverflow => Some(Self::PosOverflow { span }),\n+            IntErrorKind::NegOverflow => Some(Self::NegOverflow { span }),\n+            IntErrorKind::Zero => Some(Self::MustNotBeZero { span }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_feature, code = \"E0546\")]\n+pub(crate) struct MissingFeature {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::non_ident_feature, code = \"E0546\")]\n+pub(crate) struct NonIdentFeature {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::missing_issue, code = \"E0547\")]\n+pub(crate) struct MissingIssue {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// FIXME: This diagnostic is identical to `IncorrectMetaItem`, barring the error code. Consider\n+// changing this to `IncorrectMetaItem`. See #51489.\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_meta_item, code = \"E0551\")]\n+pub(crate) struct IncorrectMetaItem2 {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+// FIXME: Why is this the same error code as `InvalidReprHintNoParen` and `InvalidReprHintNoValue`?\n+// It is more similar to `IncorrectReprFormatGeneric`.\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_packed_one_or_zero_arg, code = \"E0552\")]\n+pub(crate) struct IncorrectReprFormatPackedOneOrZeroArg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_hint_no_paren, code = \"E0552\")]\n+pub(crate) struct InvalidReprHintNoParen {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_hint_no_value, code = \"E0552\")]\n+pub(crate) struct InvalidReprHintNoValue {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+// Error code: E0565\n+pub(crate) struct UnsupportedLiteral {\n+    pub span: Span,\n+    pub reason: UnsupportedLiteralReason,\n+    pub is_bytestr: bool,\n+}\n+\n+impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n+    fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = sess.span_diagnostic.struct_span_err_with_code(\n+            self.span,\n+            match self.reason {\n+                UnsupportedLiteralReason::Generic => fluent::attr::unsupported_literal_generic,\n+                UnsupportedLiteralReason::CfgString => fluent::attr::unsupported_literal_cfg_string,\n+                UnsupportedLiteralReason::DeprecatedString => {\n+                    fluent::attr::unsupported_literal_deprecated_string\n+                }\n+                UnsupportedLiteralReason::DeprecatedKvPair => {\n+                    fluent::attr::unsupported_literal_deprecated_kv_pair\n+                }\n+            },\n+            error_code!(E0565),\n+        );\n+        if self.is_bytestr {\n+            diag.span_suggestion(\n+                sess.source_map().start_point(self.span),\n+                fluent::attr::unsupported_literal_suggestion,\n+                \"\",\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_align_need_arg, code = \"E0589\")]\n+pub(crate) struct InvalidReprAlignNeedArg {\n+    #[primary_span]\n+    #[suggestion(code = \"align(...)\", applicability = \"has-placeholders\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::invalid_repr_generic, code = \"E0589\")]\n+pub(crate) struct InvalidReprGeneric<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub repr_arg: String,\n+    pub error_part: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_align_one_arg, code = \"E0693\")]\n+pub(crate) struct IncorrectReprFormatAlignOneArg {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::incorrect_repr_format_generic, code = \"E0693\")]\n+pub(crate) struct IncorrectReprFormatGeneric<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub repr_arg: &'a str,\n+\n+    #[subdiagnostic]\n+    pub cause: Option<IncorrectReprFormatGenericCause<'a>>,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n+    #[suggestion(attr::suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n+    Int {\n+        #[primary_span]\n+        span: Span,\n+\n+        #[skip_arg]\n+        name: &'a str,\n+\n+        #[skip_arg]\n+        int: u128,\n+    },\n+\n+    #[suggestion(\n+        attr::suggestion,\n+        code = \"{name}({symbol})\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Symbol {\n+        #[primary_span]\n+        span: Span,\n+\n+        #[skip_arg]\n+        name: &'a str,\n+\n+        #[skip_arg]\n+        symbol: Symbol,\n+    },\n+}\n+\n+impl<'a> IncorrectReprFormatGenericCause<'a> {\n+    pub fn from_lit_kind(span: Span, kind: &ast::LitKind, name: &'a str) -> Option<Self> {\n+        match kind {\n+            ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                Some(Self::Int { span, name, int: *int })\n+            }\n+            ast::LitKind::Str(symbol, _) => Some(Self::Symbol { span, name, symbol: *symbol }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::rustc_promotable_pairing, code = \"E0717\")]\n+pub(crate) struct RustcPromotablePairing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::rustc_allowed_unstable_pairing, code = \"E0789\")]\n+pub(crate) struct RustcAllowedUnstablePairing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::cfg_predicate_identifier)]\n+pub(crate) struct CfgPredicateIdentifier {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::deprecated_item_suggestion)]\n+pub(crate) struct DeprecatedItemSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    #[help]\n+    pub is_nightly: Option<()>,\n+\n+    #[note]\n+    pub details: (),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_single_version_literal)]\n+pub(crate) struct ExpectedSingleVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expected_version_literal)]\n+pub(crate) struct ExpectedVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expects_feature_list)]\n+pub(crate) struct ExpectsFeatureList {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::expects_features)]\n+pub(crate) struct ExpectsFeatures {\n+    #[primary_span]\n+    pub span: Span,\n+\n+    pub name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::soft_no_args)]\n+pub(crate) struct SoftNoArgs {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(attr::unknown_version_literal)]\n+pub(crate) struct UnknownVersionLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "144fd15fc24075d4b4ba5d8e244feb9076ab035d", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -31,7 +31,7 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n         body,\n     };\n \n-    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+    for (bb, data) in body.basic_blocks.iter_enumerated() {\n         cg.visit_basic_block_data(bb, data);\n     }\n }"}, {"sha": "c94dfe39b6903aea57a90c87d3871358e04531a1", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -105,8 +105,8 @@ impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             formatter,\n-            \"({:?}: {:?}) due to {:?} ({:?})\",\n-            self.sup, self.sub, self.locations, self.variance_info\n+            \"({:?}: {:?}) due to {:?} ({:?}) ({:?})\",\n+            self.sup, self.sub, self.locations, self.variance_info, self.category,\n         )\n     }\n }"}, {"sha": "816288eb50b293e35518b7af57063dc19bc688d9", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -143,7 +143,7 @@ struct OutOfScopePrecomputer<'a, 'tcx> {\n impl<'a, 'tcx> OutOfScopePrecomputer<'a, 'tcx> {\n     fn new(body: &'a Body<'tcx>, regioncx: &'a RegionInferenceContext<'tcx>) -> Self {\n         OutOfScopePrecomputer {\n-            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            visited: BitSet::new_empty(body.basic_blocks.len()),\n             visit_stack: vec![],\n             body,\n             regioncx,"}, {"sha": "5971f7623f215a4c3ed8c1a1832d8b31f32ba134", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1119,20 +1119,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// short a lifetime. (But sometimes it is more useful to report\n     /// it as a more direct conflict between the execution of a\n     /// `Drop::drop` with an aliasing borrow.)\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         place_span: (Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n-        debug!(\n-            \"report_borrowed_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, borrow, place_span, kind\n-        );\n-\n         let drop_span = place_span.1;\n         let root_place =\n             self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n@@ -1189,10 +1183,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n         let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n \n-        debug!(\n-            \"report_borrowed_value_does_not_live_long_enough(place_desc: {:?}, explanation: {:?})\",\n-            place_desc, explanation\n-        );\n+        debug!(?place_desc, ?explanation);\n+\n         let err = match (place_desc, explanation) {\n             // If the outlives constraint comes from inside the closure,\n             // for example:\n@@ -1464,6 +1456,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn report_temporary_value_does_not_live_long_enough(\n         &mut self,\n         location: Location,\n@@ -1473,13 +1466,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         proper_span: Span,\n         explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n-        debug!(\n-            \"report_temporary_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, borrow, drop_span, proper_span\n-        );\n-\n         if let BorrowExplanation::MustBeValidFor { category, span, from_closure: false, .. } =\n             explanation\n         {"}, {"sha": "2f61849c383c528ea3c62e2e08062e26e2b13aff", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -273,13 +273,17 @@ impl<'tcx> BorrowExplanation<'tcx> {\n             _ => {}\n         }\n     }\n-    pub(crate) fn add_lifetime_bound_suggestion_to_diagnostic(\n+\n+    fn add_lifetime_bound_suggestion_to_diagnostic(\n         &self,\n         err: &mut Diagnostic,\n         category: &ConstraintCategory<'tcx>,\n         span: Span,\n         region_name: &RegionName,\n     ) {\n+        if !span.is_desugaring(DesugaringKind::OpaqueTy) {\n+            return;\n+        }\n         if let ConstraintCategory::OpaqueType = category {\n             let suggestable_name =\n                 if region_name.was_named() { region_name.name } else { kw::UnderscoreLifetime };\n@@ -332,26 +336,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///   - second half is the place being accessed\n     ///\n     /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn explain_why_borrow_contains_point(\n         &self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, Place<'tcx>)>,\n     ) -> BorrowExplanation<'tcx> {\n-        debug!(\n-            \"explain_why_borrow_contains_point(location={:?}, borrow={:?}, kind_place={:?})\",\n-            location, borrow, kind_place\n-        );\n-\n         let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n-        debug!(\"explain_why_borrow_contains_point: borrow_region_vid={:?}\", borrow_region_vid);\n+        debug!(?borrow_region_vid);\n \n         let region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n-        debug!(\"explain_why_borrow_contains_point: region_sub={:?}\", region_sub);\n+        debug!(?region_sub);\n \n         match find_use::find(body, regioncx, tcx, region_sub, location) {\n             Some(Cause::LiveVar(local, location)) => {\n@@ -404,17 +404,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             opt_place_desc,\n                         }\n                     } else {\n-                        debug!(\n-                            \"explain_why_borrow_contains_point: \\\n-                             Could not generate a region name\"\n-                        );\n+                        debug!(\"Could not generate a region name\");\n                         BorrowExplanation::Unexplained\n                     }\n                 } else {\n-                    debug!(\n-                        \"explain_why_borrow_contains_point: \\\n-                         Could not generate an error region vid\"\n-                    );\n+                    debug!(\"Could not generate an error region vid\");\n                     BorrowExplanation::Unexplained\n                 }\n             }\n@@ -455,7 +449,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 return outmost_back_edge;\n             }\n \n-            let block = &self.body.basic_blocks()[location.block];\n+            let block = &self.body.basic_blocks[location.block];\n \n             if location.statement_index < block.statements.len() {\n                 let successor = location.successor_within_block();\n@@ -514,7 +508,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         if loop_head.dominates(from, &self.dominators) {\n-            let block = &self.body.basic_blocks()[from.block];\n+            let block = &self.body.basic_blocks[from.block];\n \n             if from.statement_index < block.statements.len() {\n                 let successor = from.successor_within_block();\n@@ -564,7 +558,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span)\n             | UseSpans::FnSelfUse { var_span: span, .. } => {\n-                let block = &self.body.basic_blocks()[location.block];\n+                let block = &self.body.basic_blocks[location.block];\n \n                 let kind = if let Some(&Statement {\n                     kind: StatementKind::FakeRead(box (FakeReadCause::ForLet(_), _)),"}, {"sha": "683084cf09d443d3a8be50472b77b8892871da60", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1086,14 +1086,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ),\n                         );\n                     }\n-                    if is_option_or_result && maybe_reinitialized_locations_is_empty {\n-                        err.span_suggestion_verbose(\n-                            fn_call_span.shrink_to_lo(),\n-                            \"consider calling `.as_ref()` to borrow the type's contents\",\n-                            \"as_ref().\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n                     // Avoid pointing to the same function in multiple different\n                     // error messages.\n                     if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span) {\n@@ -1102,6 +1094,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             &format!(\"this function takes ownership of the receiver `self`, which moves {}\", place_name)\n                         );\n                     }\n+                    if is_option_or_result && maybe_reinitialized_locations_is_empty {\n+                        err.span_label(\n+                            var_span,\n+                            \"help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\",\n+                        );\n+                    }\n                 }\n                 // Other desugarings takes &self, which cannot cause a move\n                 _ => {}"}, {"sha": "16c2f9ccc6aa4b8d06a122bdb85748eef3e5c285", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(StatementKind::Assign(box (\n                     place,\n                     Rvalue::Use(Operand::Move(move_from)),\n-                ))) = self.body.basic_blocks()[location.block]\n+                ))) = self.body.basic_blocks[location.block]\n                     .statements\n                     .get(location.statement_index)\n                     .map(|stmt| &stmt.kind)"}, {"sha": "dd9590016b990f27f98f64cd04cd49b3a3e005ea", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 127, "deletions": 2, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,4 +1,8 @@\n+use rustc_errors::{\n+    Applicability, Diagnostic, DiagnosticBuilder, EmissionGuarantee, ErrorGuaranteed,\n+};\n use rustc_hir as hir;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_middle::hir::map::Map;\n use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n@@ -12,12 +16,11 @@ use rustc_middle::{\n };\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{sym, BytePos, Span};\n \n use crate::diagnostics::BorrowedContentSource;\n use crate::MirBorrowckCtxt;\n use rustc_const_eval::util::collect_writes::FindAssignments;\n-use rustc_errors::{Applicability, Diagnostic};\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum AccessKind {\n@@ -614,6 +617,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             \"trait `IndexMut` is required to modify indexed content, \\\n                                 but it is not implemented for `{ty}`\",\n                         ));\n+                        self.suggest_map_index_mut_alternatives(ty, &mut err, span);\n                     }\n                     _ => (),\n                 }\n@@ -627,6 +631,127 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         self.buffer_error(err);\n     }\n \n+    fn suggest_map_index_mut_alternatives(\n+        &self,\n+        ty: Ty<'_>,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        span: Span,\n+    ) {\n+        let Some(adt) = ty.ty_adt_def() else { return };\n+        let did = adt.did();\n+        if self.infcx.tcx.is_diagnostic_item(sym::HashMap, did)\n+            || self.infcx.tcx.is_diagnostic_item(sym::BTreeMap, did)\n+        {\n+            struct V<'a, 'b, 'tcx, G: EmissionGuarantee> {\n+                assign_span: Span,\n+                err: &'a mut DiagnosticBuilder<'b, G>,\n+                ty: Ty<'tcx>,\n+                suggested: bool,\n+            }\n+            impl<'a, 'b: 'a, 'hir, 'tcx, G: EmissionGuarantee> Visitor<'hir> for V<'a, 'b, 'tcx, G> {\n+                fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'hir>) {\n+                    hir::intravisit::walk_stmt(self, stmt);\n+                    let expr = match stmt.kind {\n+                        hir::StmtKind::Semi(expr) | hir::StmtKind::Expr(expr) => expr,\n+                        hir::StmtKind::Local(hir::Local { init: Some(expr), .. }) => expr,\n+                        _ => {\n+                            return;\n+                        }\n+                    };\n+                    if let hir::ExprKind::Assign(place, rv, _sp) = expr.kind\n+                        && let hir::ExprKind::Index(val, index) = place.kind\n+                        && (expr.span == self.assign_span || place.span == self.assign_span)\n+                    {\n+                        // val[index] = rv;\n+                        // ---------- place\n+                        self.err.multipart_suggestions(\n+                            &format!(\n+                                \"to modify a `{}`, use `.get_mut()`, `.insert()` or the entry API\",\n+                                self.ty,\n+                            ),\n+                            vec![\n+                                vec![ // val.insert(index, rv);\n+                                    (\n+                                        val.span.shrink_to_hi().with_hi(index.span.lo()),\n+                                        \".insert(\".to_string(),\n+                                    ),\n+                                    (\n+                                        index.span.shrink_to_hi().with_hi(rv.span.lo()),\n+                                        \", \".to_string(),\n+                                    ),\n+                                    (rv.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                                vec![ // val.get_mut(index).map(|v| { *v = rv; });\n+                                    (\n+                                        val.span.shrink_to_hi().with_hi(index.span.lo()),\n+                                        \".get_mut(\".to_string(),\n+                                    ),\n+                                    (\n+                                        index.span.shrink_to_hi().with_hi(place.span.hi()),\n+                                        \").map(|val| { *val\".to_string(),\n+                                    ),\n+                                    (\n+                                        rv.span.shrink_to_hi(),\n+                                        \"; })\".to_string(),\n+                                    ),\n+                                ],\n+                                vec![ // let x = val.entry(index).or_insert(rv);\n+                                    (val.span.shrink_to_lo(), \"let val = \".to_string()),\n+                                    (\n+                                        val.span.shrink_to_hi().with_hi(index.span.lo()),\n+                                        \".entry(\".to_string(),\n+                                    ),\n+                                    (\n+                                        index.span.shrink_to_hi().with_hi(rv.span.lo()),\n+                                        \").or_insert(\".to_string(),\n+                                    ),\n+                                    (rv.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                            ].into_iter(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        self.suggested = true;\n+                    } else if let hir::ExprKind::MethodCall(_path, args @ [_, ..], sp) = expr.kind\n+                        && let hir::ExprKind::Index(val, index) = args[0].kind\n+                        && expr.span == self.assign_span\n+                    {\n+                        // val[index].path(args..);\n+                        self.err.multipart_suggestion(\n+                            &format!(\"to modify a `{}` use `.get_mut()`\", self.ty),\n+                            vec![\n+                                (\n+                                    val.span.shrink_to_hi().with_hi(index.span.lo()),\n+                                    \".get_mut(\".to_string(),\n+                                ),\n+                                (\n+                                    index.span.shrink_to_hi().with_hi(args[0].span.hi()),\n+                                    \").map(|val| val\".to_string(),\n+                                ),\n+                                (sp.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                        self.suggested = true;\n+                    }\n+                }\n+            }\n+            let hir_map = self.infcx.tcx.hir();\n+            let def_id = self.body.source.def_id();\n+            let hir_id = hir_map.local_def_id_to_hir_id(def_id.as_local().unwrap());\n+            let node = hir_map.find(hir_id);\n+            let Some(hir::Node::Item(item)) = node else { return; };\n+            let hir::ItemKind::Fn(.., body_id) = item.kind else { return; };\n+            let body = self.infcx.tcx.hir().body(body_id);\n+            let mut v = V { assign_span: span, err, ty, suggested: false };\n+            v.visit_body(body);\n+            if !v.suggested {\n+                err.help(&format!(\n+                    \"to modify a `{ty}`, use `.get_mut()`, `.insert()` or the entry API\",\n+                ));\n+            }\n+        }\n+    }\n+\n     /// User cannot make signature of a trait mutable without changing the\n     /// trait. So we find if this error belongs to a trait and if so we move\n     /// suggestion to the trait or disable it if it is out of scope of this crate"}, {"sha": "00fdf331ca60ce8c270a3ce98ec6a41d35baafa6", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 41, "deletions": 52, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! Error reporting machinery for lifetime errors.\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -23,7 +25,10 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n \n use crate::borrowck_errors;\n-use crate::session_diagnostics::GenericDoesNotLiveLongEnough;\n+use crate::session_diagnostics::{\n+    FnMutError, FnMutReturnTypeErr, GenericDoesNotLiveLongEnough, LifetimeOutliveErr,\n+    LifetimeReturnCategoryErr, RequireStaticErr, VarHereDenote,\n+};\n \n use super::{OutlivesSuggestionBuilder, RegionName};\n use crate::region_infer::BlameConstraint;\n@@ -488,32 +493,27 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n-        let mut diag = self\n-            .infcx\n-            .tcx\n-            .sess\n-            .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n-\n         let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         if let ty::Opaque(def_id, _) = *output_ty.kind() {\n             output_ty = self.infcx.tcx.type_of(def_id)\n         };\n \n         debug!(\"report_fnmut_error: output_ty={:?}\", output_ty);\n \n-        let message = match output_ty.kind() {\n-            ty::Closure(_, _) => {\n-                \"returns a closure that contains a reference to a captured variable, which then \\\n-                 escapes the closure body\"\n-            }\n-            ty::Adt(def, _) if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did()) => {\n-                \"returns an `async` block that contains a reference to a captured variable, which then \\\n-                 escapes the closure body\"\n-            }\n-            _ => \"returns a reference to a captured variable which escapes the closure body\",\n+        let err = FnMutError {\n+            span: *span,\n+            ty_err: match output_ty.kind() {\n+                ty::Closure(_, _) => FnMutReturnTypeErr::ReturnClosure { span: *span },\n+                ty::Adt(def, _)\n+                    if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did()) =>\n+                {\n+                    FnMutReturnTypeErr::ReturnAsyncBlock { span: *span }\n+                }\n+                _ => FnMutReturnTypeErr::ReturnRef { span: *span },\n+            },\n         };\n \n-        diag.span_label(*span, message);\n+        let mut diag = self.infcx.tcx.sess.create_err(err);\n \n         if let ReturnConstraint::ClosureUpvar(upvar_field) = kind {\n             let def_id = match self.regioncx.universal_regions().defining_ty {\n@@ -532,20 +532,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvars_map = self.infcx.tcx.upvars_mentioned(def_id).unwrap();\n                 let upvar_def_span = self.infcx.tcx.hir().span(def_hir);\n                 let upvar_span = upvars_map.get(&def_hir).unwrap().span;\n-                diag.span_label(upvar_def_span, \"variable defined here\");\n-                diag.span_label(upvar_span, \"variable captured here\");\n+                diag.subdiagnostic(VarHereDenote::Defined { span: upvar_def_span });\n+                diag.subdiagnostic(VarHereDenote::Captured { span: upvar_span });\n             }\n         }\n \n         if let Some(fr_span) = self.give_region_a_name(*outlived_fr).unwrap().span() {\n-            diag.span_label(fr_span, \"inferred to be a `FnMut` closure\");\n+            diag.subdiagnostic(VarHereDenote::FnMutInferred { span: fr_span });\n         }\n \n-        diag.note(\n-            \"`FnMut` closures only have access to their captured variables while they are \\\n-             executing...\",\n-        );\n-        diag.note(\"...therefore, they cannot allow references to captured variables to escape\");\n         self.suggest_move_on_borrowing_closure(&mut diag);\n \n         diag\n@@ -681,39 +676,33 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             ..\n         } = errci;\n \n-        let mut diag =\n-            self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n-\n         let (_, mir_def_name) =\n             self.infcx.tcx.article_and_description(self.mir_def_id().to_def_id());\n \n+        let err = LifetimeOutliveErr { span: *span };\n+        let mut diag = self.infcx.tcx.sess.create_err(err);\n+\n         let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n         let outlived_fr_name = self.give_region_a_name(*outlived_fr).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n-        match (category, outlived_fr_is_local, fr_is_local) {\n-            (ConstraintCategory::Return(_), true, _) => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\n-                        \"{mir_def_name} was supposed to return data with lifetime `{outlived_fr_name}` but it is returning \\\n-                         data with lifetime `{fr_name}`\",\n-                    ),\n-                );\n-            }\n-            _ => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\n-                        \"{}requires that `{}` must outlive `{}`\",\n-                        category.description(),\n-                        fr_name,\n-                        outlived_fr_name,\n-                    ),\n-                );\n-            }\n-        }\n+        let err_category = match (category, outlived_fr_is_local, fr_is_local) {\n+            (ConstraintCategory::Return(_), true, _) => LifetimeReturnCategoryErr::WrongReturn {\n+                span: *span,\n+                mir_def_name,\n+                outlived_fr_name,\n+                fr_name: &fr_name,\n+            },\n+            _ => LifetimeReturnCategoryErr::ShortReturn {\n+                span: *span,\n+                category_desc: category.description(),\n+                free_region_name: &fr_name,\n+                outlived_fr_name,\n+            },\n+        };\n+\n+        diag.subdiagnostic(err_category);\n \n         self.add_static_impl_trait_suggestion(&mut diag, *fr, fr_name, *outlived_fr);\n         self.suggest_adding_lifetime_params(&mut diag, *fr, *outlived_fr);\n@@ -862,7 +851,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ident.span,\n                     \"calling this method introduces the `impl`'s 'static` requirement\",\n                 );\n-                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n+                err.subdiagnostic(RequireStaticErr::UsedImpl { multi_span });\n                 err.span_suggestion_verbose(\n                     span.shrink_to_hi(),\n                     \"consider relaxing the implicit `'static` requirement\","}, {"sha": "20c22575bd1fadcd27e20412204801a0f34184d0", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n@@ -18,7 +19,7 @@ extern crate tracing;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n@@ -50,6 +51,8 @@ use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult, MoveData, MoveE\n use rustc_mir_dataflow::Analysis;\n use rustc_mir_dataflow::MoveDataParamEnv;\n \n+use crate::session_diagnostics::VarNeedNotMut;\n+\n use self::diagnostics::{AccessKind, RegionName};\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -424,17 +427,9 @@ fn do_mir_borrowck<'a, 'tcx>(\n             continue;\n         }\n \n-        tcx.struct_span_lint_hir(UNUSED_MUT, lint_root, span, |lint| {\n-            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n-            lint.build(\"variable does not need to be mutable\")\n-                .span_suggestion_short(\n-                    mut_span,\n-                    \"remove this `mut`\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n-        })\n+        let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n+\n+        tcx.emit_spanned_lint(UNUSED_MUT, lint_root, span, VarNeedNotMut { span: mut_span })\n     }\n \n     let tainted_by_errors = mbcx.emit_errors();\n@@ -981,6 +976,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, flow_state))]\n     fn check_access_for_conflict(\n         &mut self,\n         location: Location,\n@@ -989,11 +985,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'tcx>,\n     ) -> bool {\n-        debug!(\n-            \"check_access_for_conflict(location={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n-            location, place_span, sd, rw,\n-        );\n-\n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n@@ -1457,13 +1448,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Checks whether a borrow of this place is invalidated when the function\n     /// exits\n+    #[instrument(level = \"debug\", skip(self))]\n     fn check_for_invalidation_at_exit(\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         span: Span,\n     ) {\n-        debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = borrow.borrowed_place;\n         let mut root_place = PlaceRef { local: place.local, projection: &[] };\n "}, {"sha": "5ca3f2f4d033c1c8dc27815369c9db4338ff6790", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -33,7 +33,7 @@ impl LocationTable {\n     pub(crate) fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block = body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;"}, {"sha": "6e5a96bee97e69031aebbf99662632eb9807249b", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -44,6 +44,7 @@ pub(crate) fn places_conflict<'tcx>(\n /// access depth. The `bias` parameter is used to determine how the unknowable (comparing runtime\n /// array indices, for example) should be interpreted - this depends on what the caller wants in\n /// order to make the conservative choice and preserve soundness.\n+#[instrument(level = \"debug\", skip(tcx, body))]\n pub(super) fn borrow_conflicts_with_place<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n@@ -53,11 +54,6 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n-    debug!(\n-        \"borrow_conflicts_with_place({:?}, {:?}, {:?}, {:?})\",\n-        borrow_place, access_place, access, bias,\n-    );\n-\n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n     if let Some(l1) = borrow_place.as_local() && let Some(l2) = access_place.as_local() {\n@@ -140,10 +136,9 @@ fn place_components_conflict<'tcx>(\n     for (i, (borrow_c, &access_c)) in\n         iter::zip(borrow_place.projection, access_place.projection).enumerate()\n     {\n-        debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n-        let borrow_proj_base = &borrow_place.projection[..i];\n+        debug!(?borrow_c, ?access_c);\n \n-        debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n+        let borrow_proj_base = &borrow_place.projection[..i];\n \n         // Borrow and access path both have more components.\n         //\n@@ -180,7 +175,7 @@ fn place_components_conflict<'tcx>(\n                 // idea, at least for now, so just give up and\n                 // report a conflict. This is unsafe code anyway so\n                 // the user could always use raw pointers.\n-                debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                debug!(\"arbitrary -> conflict\");\n                 return true;\n             }\n             Overlap::EqualOrDisjoint => {\n@@ -189,7 +184,7 @@ fn place_components_conflict<'tcx>(\n             Overlap::Disjoint => {\n                 // We have proven the borrow disjoint - further\n                 // projections will remain disjoint.\n-                debug!(\"borrow_conflicts_with_place: disjoint\");\n+                debug!(\"disjoint\");\n                 return false;\n             }\n         }"}, {"sha": "f5bd5cd3beaed0ab0006c2ba688a5fc8009f743a", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1167,8 +1167,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Therefore, this method should only be used in diagnostic code,\n     /// where displaying *some* named universal region is better than\n     /// falling back to 'static.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn approx_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\"approx_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n+        debug!(\"{}\", self.region_value_str(r));\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n@@ -1177,7 +1178,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let static_r = self.universal_regions.fr_static;\n         for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n             let new_lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n-            debug!(\"approx_universal_upper_bound: ur={:?} lub={:?} new_lub={:?}\", ur, lub, new_lub);\n+            debug!(?ur, ?lub, ?new_lub);\n             // The upper bound of two non-static regions is static: this\n             // means we know nothing about the relationship between these\n             // two regions. Pick a 'better' one to use when constructing\n@@ -1201,7 +1202,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        debug!(\"approx_universal_upper_bound: r={:?} lub={:?}\", r, lub);\n+        debug!(?r, ?lub);\n \n         lub\n     }\n@@ -2048,23 +2049,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// creating a constraint path that forces `R` to outlive\n     /// `from_region`, and then finding the best choices within that\n     /// path to blame.\n+    #[instrument(level = \"debug\", skip(self, target_test))]\n     pub(crate) fn best_blame_constraint(\n         &self,\n         body: &Body<'tcx>,\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> BlameConstraint<'tcx> {\n-        debug!(\n-            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n-            from_region, from_region_origin\n-        );\n-\n         // Find all paths\n         let (path, target_region) =\n             self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n         debug!(\n-            \"best_blame_constraint: path={:#?}\",\n+            \"path={:#?}\",\n             path.iter()\n                 .map(|c| format!(\n                     \"{:?} ({:?}: {:?})\",\n@@ -2116,7 +2113,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             })\n             .collect();\n-        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n+        debug!(\"categorized_path={:#?}\", categorized_path);\n \n         // To find the best span to cite, we first try to look for the\n         // final constraint that is interesting and where the `sup` is\n@@ -2214,10 +2211,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let best_choice =\n             if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n \n-        debug!(\n-            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n-            best_choice, blame_source\n-        );\n+        debug!(?best_choice, ?blame_source);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n@@ -2254,7 +2248,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // appears to be the most interesting point to report to the\n         // user via an even more ad-hoc guess.\n         categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n-        debug!(\"best_blame_constraint: sorted_path={:#?}\", categorized_path);\n+        debug!(\"sorted_path={:#?}\", categorized_path);\n \n         categorized_path.remove(0)\n     }"}, {"sha": "127cb4e408372e800e9ef7380f04c8ee59cf9e8d", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -16,6 +16,8 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n+use crate::session_diagnostics::ConstNotUsedTraitAlias;\n+\n use super::RegionInferenceContext;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -639,17 +641,10 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     Some(GenericArgKind::Const(c1)) => c1,\n                     Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n                     None => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"const parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ct\n-                                ),\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(ConstNotUsedTraitAlias {\n+                            ct: ct.to_string(),\n+                            span: self.span,\n+                        });\n \n                         self.tcx().const_error(ct.ty())\n                     }"}, {"sha": "de20a4bb465c207c6e77a6b4c47280b8c822e3d1", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -25,7 +25,7 @@ impl RegionValueElements {\n     pub(crate) fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block: IndexVec<BasicBlock, usize> = body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;\n@@ -37,7 +37,7 @@ impl RegionValueElements {\n         debug!(\"RegionValueElements: num_points={:#?}\", num_points);\n \n         let mut basic_blocks = IndexVec::with_capacity(num_points);\n-        for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n+        for (bb, bb_data) in body.basic_blocks.iter_enumerated() {\n             basic_blocks.extend((0..=bb_data.statements.len()).map(|_| bb));\n         }\n "}, {"sha": "5d750c6ca8c7beac7cd32767ab2bbb35d76ce3b4", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 120, "deletions": 5, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,9 +1,12 @@\n-use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_errors::{IntoDiagnosticArg, MultiSpan};\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic, SessionSubdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n \n+use crate::diagnostics::RegionName;\n+\n #[derive(SessionDiagnostic)]\n-#[error(borrowck::move_unsized, code = \"E0161\")]\n+#[diag(borrowck::move_unsized, code = \"E0161\")]\n pub(crate) struct MoveUnsized<'tcx> {\n     pub ty: Ty<'tcx>,\n     #[primary_span]\n@@ -12,7 +15,7 @@ pub(crate) struct MoveUnsized<'tcx> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(borrowck::higher_ranked_lifetime_error)]\n+#[diag(borrowck::higher_ranked_lifetime_error)]\n pub(crate) struct HigherRankedLifetimeError {\n     #[subdiagnostic]\n     pub cause: Option<HigherRankedErrorCause>,\n@@ -29,16 +32,128 @@ pub(crate) enum HigherRankedErrorCause {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(borrowck::higher_ranked_subtype_error)]\n+#[diag(borrowck::higher_ranked_subtype_error)]\n pub(crate) struct HigherRankedSubtypeError {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(borrowck::generic_does_not_live_long_enough)]\n+#[diag(borrowck::generic_does_not_live_long_enough)]\n pub(crate) struct GenericDoesNotLiveLongEnough {\n     pub kind: String,\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[diag(borrowck::var_does_not_need_mut)]\n+pub(crate) struct VarNeedNotMut {\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(borrowck::const_not_used_in_type_alias)]\n+pub(crate) struct ConstNotUsedTraitAlias {\n+    pub ct: String,\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(borrowck::var_cannot_escape_closure)]\n+#[note]\n+#[note(borrowck::cannot_escape)]\n+pub(crate) struct FnMutError {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub ty_err: FnMutReturnTypeErr,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum VarHereDenote {\n+    #[label(borrowck::var_here_captured)]\n+    Captured {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(borrowck::var_here_defined)]\n+    Defined {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(borrowck::closure_inferred_mut)]\n+    FnMutInferred {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum FnMutReturnTypeErr {\n+    #[label(borrowck::returned_closure_escaped)]\n+    ReturnClosure {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(borrowck::returned_async_block_escaped)]\n+    ReturnAsyncBlock {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(borrowck::returned_ref_escaped)]\n+    ReturnRef {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(borrowck::lifetime_constraints_error)]\n+pub(crate) struct LifetimeOutliveErr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum LifetimeReturnCategoryErr<'a> {\n+    #[label(borrowck::returned_lifetime_wrong)]\n+    WrongReturn {\n+        #[primary_span]\n+        span: Span,\n+        mir_def_name: &'a str,\n+        outlived_fr_name: RegionName,\n+        fr_name: &'a RegionName,\n+    },\n+    #[label(borrowck::returned_lifetime_short)]\n+    ShortReturn {\n+        #[primary_span]\n+        span: Span,\n+        category_desc: &'static str,\n+        free_region_name: &'a RegionName,\n+        outlived_fr_name: RegionName,\n+    },\n+}\n+\n+impl IntoDiagnosticArg for &RegionName {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        format!(\"{}\", self).into_diagnostic_arg()\n+    }\n+}\n+\n+impl IntoDiagnosticArg for RegionName {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        format!(\"{}\", self).into_diagnostic_arg()\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub(crate) enum RequireStaticErr {\n+    #[note(borrowck::used_impl_require_static)]\n+    UsedImpl {\n+        #[primary_span]\n+        multi_span: MultiSpan,\n+    },\n+}"}, {"sha": "29195b3922fcdb24dc8734caa8f03dcb5f9ce230", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// **Any `rustc_infer::infer` operations that might generate region\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n-    #[instrument(skip(self, category, op), level = \"trace\")]\n+    #[instrument(skip(self, op), level = \"trace\")]\n     pub(super) fn fully_perform_op<R, Op>(\n         &mut self,\n         locations: Locations,\n@@ -90,12 +90,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n     ) {\n-        self.prove_predicates(\n-            Some(ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n+        self.prove_predicate(\n+            ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n                 trait_ref,\n                 constness: ty::BoundConstness::NotConst,\n                 polarity: ty::ImplPolarity::Positive,\n-            }))),\n+            }))\n+            .to_predicate(self.tcx()),\n             locations,\n             category,\n         );"}, {"sha": "7c10047e9dc83c5ddeaa599d1ab4e3c2582b82a2", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::frozen::Frozen;\n-use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use rustc_data_structures::transitive_relation::{TransitiveRelation, TransitiveRelationBuilder};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n@@ -61,25 +61,13 @@ pub(crate) fn create<'tcx>(\n         constraints,\n         universal_regions: universal_regions.clone(),\n         region_bound_pairs: Default::default(),\n-        relations: UniversalRegionRelations {\n-            universal_regions: universal_regions.clone(),\n-            outlives: Default::default(),\n-            inverse_outlives: Default::default(),\n-        },\n+        outlives: Default::default(),\n+        inverse_outlives: Default::default(),\n     }\n     .create()\n }\n \n impl UniversalRegionRelations<'_> {\n-    /// Records in the `outlives_relation` (and\n-    /// `inverse_outlives_relation`) that `fr_a: fr_b`. Invoked by the\n-    /// builder below.\n-    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n-        debug!(\"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\", fr_a, fr_b);\n-        self.outlives.add(fr_a, fr_b);\n-        self.inverse_outlives.add(fr_b, fr_a);\n-    }\n-\n     /// Given two universal regions, returns the postdominating\n     /// upper-bound (effectively the least upper bound).\n     ///\n@@ -216,11 +204,20 @@ struct UniversalRegionRelationsBuilder<'this, 'tcx> {\n     constraints: &'this mut MirTypeckRegionConstraints<'tcx>,\n \n     // outputs:\n-    relations: UniversalRegionRelations<'tcx>,\n+    outlives: TransitiveRelationBuilder<RegionVid>,\n+    inverse_outlives: TransitiveRelationBuilder<RegionVid>,\n     region_bound_pairs: RegionBoundPairs<'tcx>,\n }\n \n impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n+    /// Records in the `outlives_relation` (and\n+    /// `inverse_outlives_relation`) that `fr_a: fr_b`.\n+    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n+        debug!(\"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\", fr_a, fr_b);\n+        self.outlives.add(fr_a, fr_b);\n+        self.inverse_outlives.add(fr_b, fr_a);\n+    }\n+\n     pub(crate) fn create(mut self) -> CreateResult<'tcx> {\n         let unnormalized_input_output_tys = self\n             .universal_regions\n@@ -268,7 +265,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                 // }\n                 // impl Foo for () {\n                 //   type Bar = ();\n-                //   fn foo(&self) ->&() {}\n+                //   fn foo(&self) -> &() {}\n                 // }\n                 // ```\n                 // Both &Self::Bar and &() are WF\n@@ -292,9 +289,9 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         let fr_fn_body = self.universal_regions.fr_fn_body;\n         for fr in self.universal_regions.universal_regions() {\n             debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n-            self.relations.relate_universal_regions(fr, fr);\n-            self.relations.relate_universal_regions(fr_static, fr);\n-            self.relations.relate_universal_regions(fr, fr_fn_body);\n+            self.relate_universal_regions(fr, fr);\n+            self.relate_universal_regions(fr_static, fr);\n+            self.relate_universal_regions(fr, fr_fn_body);\n         }\n \n         for data in &constraint_sets {\n@@ -313,7 +310,11 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         }\n \n         CreateResult {\n-            universal_region_relations: Frozen::freeze(self.relations),\n+            universal_region_relations: Frozen::freeze(UniversalRegionRelations {\n+                universal_regions: self.universal_regions,\n+                outlives: self.outlives.freeze(),\n+                inverse_outlives: self.inverse_outlives.freeze(),\n+            }),\n             region_bound_pairs: self.region_bound_pairs,\n             normalized_inputs_and_output,\n         }\n@@ -356,7 +357,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     // The bound says that `r1 <= r2`; we store `r2: r1`.\n                     let r1 = self.universal_regions.to_region_vid(r1);\n                     let r2 = self.universal_regions.to_region_vid(r2);\n-                    self.relations.relate_universal_regions(r2, r1);\n+                    self.relate_universal_regions(r2, r1);\n                 }\n \n                 OutlivesBound::RegionSubParam(r_a, param_b) => {"}, {"sha": "a620c987052ba0b987175df02e70fc9e5d3b9cd6", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 55, "deletions": 87, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -178,97 +178,15 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         upvars,\n     };\n \n-    let opaque_type_values = type_check_internal(\n+    let mut checker = TypeChecker::new(\n         infcx,\n-        param_env,\n         body,\n-        promoted,\n+        param_env,\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n-        |mut cx| {\n-            debug!(\"inside extra closure of type_check_internal\");\n-            cx.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(\n-                &mut cx,\n-                body,\n-                elements,\n-                flow_inits,\n-                move_data,\n-                location_table,\n-                use_polonius,\n-            );\n-\n-            translate_outlives_facts(&mut cx);\n-            let opaque_type_values =\n-                infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-\n-            opaque_type_values\n-                .into_iter()\n-                .map(|(opaque_type_key, decl)| {\n-                    cx.fully_perform_op(\n-                        Locations::All(body.span),\n-                        ConstraintCategory::OpaqueType,\n-                        CustomTypeOp::new(\n-                            |infcx| {\n-                                infcx.register_member_constraints(\n-                                    param_env,\n-                                    opaque_type_key,\n-                                    decl.hidden_type.ty,\n-                                    decl.hidden_type.span,\n-                                );\n-                                Ok(InferOk { value: (), obligations: vec![] })\n-                            },\n-                            || \"opaque_type_map\".to_string(),\n-                        ),\n-                    )\n-                    .unwrap();\n-                    let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n-                    trace!(\n-                        \"finalized opaque type {:?} to {:#?}\",\n-                        opaque_type_key,\n-                        hidden_type.ty.kind()\n-                    );\n-                    if hidden_type.has_infer_types_or_consts() {\n-                        infcx.tcx.sess.delay_span_bug(\n-                            decl.hidden_type.span,\n-                            &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n-                        );\n-                        hidden_type.ty = infcx.tcx.ty_error();\n-                    }\n-\n-                    (opaque_type_key, (hidden_type, decl.origin))\n-                })\n-                .collect()\n-        },\n     );\n \n-    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n-}\n-\n-#[instrument(\n-    skip(infcx, body, promoted, region_bound_pairs, borrowck_context, extra),\n-    level = \"debug\"\n-)]\n-fn type_check_internal<'a, 'tcx, R>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n-    promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n-    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-    implicit_region_bound: ty::Region<'tcx>,\n-    borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n-    extra: impl FnOnce(TypeChecker<'a, 'tcx>) -> R,\n-) -> R {\n-    debug!(\"body: {:#?}\", body);\n-    let mut checker = TypeChecker::new(\n-        infcx,\n-        body,\n-        param_env,\n-        region_bound_pairs,\n-        implicit_region_bound,\n-        borrowck_context,\n-    );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, promoted);\n         verifier.visit_body(&body);\n@@ -280,7 +198,56 @@ fn type_check_internal<'a, 'tcx, R>(\n         checker.typeck_mir(body);\n     }\n \n-    extra(checker)\n+    checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n+    liveness::generate(\n+        &mut checker,\n+        body,\n+        elements,\n+        flow_inits,\n+        move_data,\n+        location_table,\n+        use_polonius,\n+    );\n+\n+    translate_outlives_facts(&mut checker);\n+    let opaque_type_values = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+\n+    let opaque_type_values = opaque_type_values\n+        .into_iter()\n+        .map(|(opaque_type_key, decl)| {\n+            checker\n+                .fully_perform_op(\n+                    Locations::All(body.span),\n+                    ConstraintCategory::OpaqueType,\n+                    CustomTypeOp::new(\n+                        |infcx| {\n+                            infcx.register_member_constraints(\n+                                param_env,\n+                                opaque_type_key,\n+                                decl.hidden_type.ty,\n+                                decl.hidden_type.span,\n+                            );\n+                            Ok(InferOk { value: (), obligations: vec![] })\n+                        },\n+                        || \"opaque_type_map\".to_string(),\n+                    ),\n+                )\n+                .unwrap();\n+            let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n+            trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n+            if hidden_type.has_infer_types_or_consts() {\n+                infcx.tcx.sess.delay_span_bug(\n+                    decl.hidden_type.span,\n+                    &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n+                );\n+                hidden_type.ty = infcx.tcx.ty_error();\n+            }\n+\n+            (opaque_type_key, (hidden_type, decl.origin))\n+        })\n+        .collect();\n+\n+    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n }\n \n fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n@@ -1076,6 +1043,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n             let annotation = self.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n+            debug!(?annotation);\n             match annotation {\n                 UserType::Ty(mut ty) => {\n                     ty = self.normalize(ty, Locations::All(span));\n@@ -1911,7 +1879,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n-            &Rvalue::NullaryOp(_, ty) => {\n+            &Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, ty) => {\n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n                     substs: tcx.mk_substs_trait(ty, &[]),\n@@ -2666,7 +2634,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             self.check_local(&body, local, local_decl);\n         }\n \n-        for (block, block_data) in body.basic_blocks().iter_enumerated() {\n+        for (block, block_data) in body.basic_blocks.iter_enumerated() {\n             let mut location = Location { block, statement_index: 0 };\n             for stmt in &block_data.statements {\n                 if !stmt.source_info.span.is_dummy() {"}, {"sha": "a1051d990b14b910b1634ca8e43288a511718ca1", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -852,7 +852,7 @@ pub(super) fn expand_global_asm<'cx>(\n             if let Some(inline_asm) = expand_preparsed_asm(ecx, args) {\n                 MacEager::items(smallvec![P(ast::Item {\n                     ident: Ident::empty(),\n-                    attrs: Vec::new(),\n+                    attrs: ast::AttrVec::new(),\n                     id: ast::DUMMY_NODE_ID,\n                     kind: ast::ItemKind::GlobalAsm(Box::new(inline_asm)),\n                     vis: ast::Visibility {"}, {"sha": "119724b50493eedb83dd5d2223e9b450aa199dd2", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -52,15 +52,15 @@ pub fn expand_assert<'cx>(\n     let expr = if let Some(tokens) = custom_message {\n         let then = cx.expr(\n             call_site_span,\n-            ExprKind::MacCall(MacCall {\n+            ExprKind::MacCall(P(MacCall {\n                 path: panic_path(),\n                 args: P(MacArgs::Delimited(\n                     DelimSpan::from_single(call_site_span),\n                     MacDelimiter::Parenthesis,\n                     tokens,\n                 )),\n                 prior_type_ascription: None,\n-            }),\n+            })),\n         );\n         expr_if_not(cx, call_site_span, cond_expr, then, None)\n     }"}, {"sha": "d2ee4249989ee396a8195ae9030b70be35b55564", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -119,7 +119,8 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                 vec![self.cx.attribute(attr::mk_list_item(\n                     Ident::new(sym::allow, self.span),\n                     vec![attr::mk_nested_word_item(Ident::new(sym::unused_imports, self.span))],\n-                ))],\n+                ))]\n+                .into(),\n                 ItemKind::Use(UseTree {\n                     prefix: self.cx.path(self.span, self.cx.std_path(&[sym::asserting])),\n                     kind: UseTreeKind::Nested(vec![\n@@ -177,15 +178,15 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         });\n         self.cx.expr(\n             self.span,\n-            ExprKind::MacCall(MacCall {\n+            ExprKind::MacCall(P(MacCall {\n                 path: panic_path,\n                 args: P(MacArgs::Delimited(\n                     DelimSpan::from_single(self.span),\n                     MacDelimiter::Parenthesis,\n                     initial.into_iter().chain(captures).collect::<TokenStream>(),\n                 )),\n                 prior_type_ascription: None,\n-            }),\n+            })),\n         )\n     }\n "}, {"sha": "9046bf130593398d4052fc2e1111c97c4b680c26", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -36,15 +36,15 @@ pub fn expand_cfg(\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(builtin_macros::requires_cfg_pattern)]\n+#[diag(builtin_macros::requires_cfg_pattern)]\n struct RequiresCfgPattern {\n     #[primary_span]\n     #[label]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(builtin_macros::expected_one_cfg_pattern)]\n+#[diag(builtin_macros::expected_one_cfg_pattern)]\n struct OneCfgPattern {\n     #[primary_span]\n     span: Span,"}, {"sha": "41f4e8c234d5adc004c8a44710e238fb89494cdd", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -39,7 +39,7 @@ pub fn expand_concat(\n                 ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..) => {\n                     cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n                 }\n-                ast::LitKind::Err(_) => {\n+                ast::LitKind::Err => {\n                     has_errors = true;\n                 }\n             },"}, {"sha": "66e86bf2182672e0453f24aa3837623ea1a43b72", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -42,7 +42,7 @@ fn invalid_type_err(cx: &mut base::ExtCtxt<'_>, expr: &P<rustc_ast::Expr>, is_ne\n         ast::LitKind::Bool(_) => {\n             cx.span_err(expr.span, \"cannot concatenate boolean literals\");\n         }\n-        ast::LitKind::Err(_) => {}\n+        ast::LitKind::Err => {}\n         ast::LitKind::Int(_, _) if !is_nested => {\n             let mut err = cx.struct_span_err(expr.span, \"cannot concatenate numeric literals\");\n             if let Ok(snippet) = cx.sess.source_map().span_to_snippet(expr.span) {"}, {"sha": "dd7989cf48c37b784cd37fdc7020e71bcea334bc", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -68,7 +68,7 @@ pub fn expand_deriving_clone(\n     }\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(clone::Clone),"}, {"sha": "9b6d3e5032f9495f92caad1231e79e01680e7d05", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -20,7 +20,7 @@ pub fn expand_deriving_eq(\n     let hidden = rustc_ast::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n     let doc = rustc_ast::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n     let no_coverage = cx.meta_word(span, sym::no_coverage);\n-    let attrs = vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)];\n+    let attrs = vec![cx.attribute(inline), cx.attribute(doc), cx.attribute(no_coverage)].into();\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Eq),"}, {"sha": "0e17b95178759368b59147dfca1fda6751b78066", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -15,7 +15,7 @@ pub fn expand_deriving_ord(\n     push: &mut dyn FnMut(Annotatable),\n ) {\n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Ord),"}, {"sha": "ac1325b92a6f38ed38acd385baded5839cdb076f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -68,7 +68,7 @@ pub fn expand_deriving_partial_eq(\n     // No need to generate `ne`, the default suffices, and not generating it is\n     // faster.\n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n     let methods = vec![MethodDef {\n         name: sym::eq,\n         generics: Bounds::empty(),"}, {"sha": "7763e55401783b19670703c070c72fa418e2117f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -19,7 +19,7 @@ pub fn expand_deriving_partial_ord(\n         Path(Path::new_(pathvec_std!(option::Option), vec![Box::new(ordering_ty)], PathKind::Std));\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n \n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,"}, {"sha": "4af7fd8165388894456292ac08518d98dabcbbde", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -29,7 +29,7 @@ pub fn expand_deriving_debug(\n             explicit_self: true,\n             nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n-            attributes: Vec::new(),\n+            attributes: ast::AttrVec::new(),\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 show_substructure(a, b, c)"}, {"sha": "7174dbbe7ea8b5abc7e1ac07dd2f28e1edafa14b", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -47,7 +47,7 @@ pub fn expand_deriving_rustc_decodable(\n                 ],\n                 PathKind::Std,\n             )),\n-            attributes: Vec::new(),\n+            attributes: ast::AttrVec::new(),\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 decodable_substructure(a, b, c, krate)"}, {"sha": "f316f01ef66152e7bb1b3308ce9c924b0d80b6e2", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,9 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n \n use rustc_ast as ast;\n-use rustc_ast::walk_list;\n-use rustc_ast::EnumDef;\n-use rustc_ast::VariantData;\n+use rustc_ast::{walk_list, EnumDef, VariantData};\n use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n@@ -22,7 +20,7 @@ pub fn expand_deriving_default(\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let attrs = vec![cx.attribute(inline)];\n+    let attrs = vec![cx.attribute(inline)].into();\n     let trait_def = TraitDef {\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),"}, {"sha": "b220e54238f462e27c1d5d383490dcb7bdb6ec99", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -89,7 +89,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n \n-use rustc_ast::{ExprKind, MetaItem, Mutability};\n+use rustc_ast::{AttrVec, ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -131,7 +131,7 @@ pub fn expand_deriving_rustc_encodable(\n                 ],\n                 PathKind::Std,\n             )),\n-            attributes: Vec::new(),\n+            attributes: AttrVec::new(),\n             unify_fieldless_variants: false,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 encodable_substructure(a, b, c, krate)"}, {"sha": "ecaafd0fc2652946fd2afb73a79b1d4592477b77", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -217,7 +217,7 @@ pub struct MethodDef<'a> {\n     /// Returns type\n     pub ret_ty: Ty,\n \n-    pub attributes: Vec<ast::Attribute>,\n+    pub attributes: ast::AttrVec,\n \n     /// Can we combine fieldless variants for enums into a single match arm?\n     /// If true, indicates that the trait operation uses the enum tag in some\n@@ -383,8 +383,7 @@ fn find_type_parameters(\n         // Place bound generic params on a stack, to extract them when a type is encountered.\n         fn visit_poly_trait_ref(&mut self, trait_ref: &'a ast::PolyTraitRef) {\n             let stack_len = self.bound_generic_params_stack.len();\n-            self.bound_generic_params_stack\n-                .extend(trait_ref.bound_generic_params.clone().into_iter());\n+            self.bound_generic_params_stack.extend(trait_ref.bound_generic_params.iter().cloned());\n \n             visit::walk_poly_trait_ref(self, trait_ref);\n \n@@ -562,7 +561,7 @@ impl<'a> TraitDef<'a> {\n                     kind: ast::VisibilityKind::Inherited,\n                     tokens: None,\n                 },\n-                attrs: Vec::new(),\n+                attrs: ast::AttrVec::new(),\n                 kind: ast::AssocItemKind::TyAlias(Box::new(ast::TyAlias {\n                     defaultness: ast::Defaultness::Final,\n                     generics: Generics::default(),\n@@ -716,7 +715,7 @@ impl<'a> TraitDef<'a> {\n         let self_type = cx.ty_path(path);\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n-        let attrs = vec![attr];\n+        let attrs = vec![attr].into();\n         let opt_trait_ref = Some(trait_ref);\n \n         cx.item("}, {"sha": "f1f02e7ce778740246c2a81b0038ec2d0ced1453", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,7 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n \n-use rustc_ast::{MetaItem, Mutability};\n+use rustc_ast::{AttrVec, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -31,7 +31,7 @@ pub fn expand_deriving_hash(\n             explicit_self: true,\n             nonself_args: vec![(Ref(Box::new(Path(arg)), Mutability::Mut), sym::state)],\n             ret_ty: Unit,\n-            attributes: vec![],\n+            attributes: AttrVec::new(),\n             unify_fieldless_variants: true,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 hash_substructure(a, b, c)"}, {"sha": "a65d0bad6de801e91d62ca492a2ba68ec9d20975", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -164,7 +164,7 @@ fn inject_impl_of_structural_trait(\n \n     // Keep the lint and stability attributes of the original item, to control\n     // how the generated implementation is linted.\n-    let mut attrs = Vec::new();\n+    let mut attrs = ast::AttrVec::new();\n     attrs.extend(\n         item.attrs\n             .iter()"}, {"sha": "3f1a8b3bc2cf7b2c45a8d078e21091bef961eae7", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -48,7 +48,7 @@ fn expand<'cx>(\n     MacEager::expr(\n         cx.expr(\n             sp,\n-            ExprKind::MacCall(MacCall {\n+            ExprKind::MacCall(P(MacCall {\n                 path: Path {\n                     span: sp,\n                     segments: cx\n@@ -64,7 +64,7 @@ fn expand<'cx>(\n                     tts,\n                 )),\n                 prior_type_ascription: None,\n-            }),\n+            })),\n         ),\n     )\n }"}, {"sha": "210048710751702a4c278b844536e16a85c97968", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Verifies one piece of a parse string, and remembers it if valid.\n     /// All errors are not emitted as fatal so we can continue giving errors\n     /// about this and possibly other format strings.\n-    fn verify_piece(&mut self, p: &parse::Piece<'_>) {\n+    fn verify_piece(&mut self, p: &parse::Piece<'a>) {\n         match *p {\n             parse::String(..) => {}\n             parse::NextArgument(ref arg) => {\n@@ -433,6 +433,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let has_precision = arg.format.precision != Count::CountImplied;\n                 let has_width = arg.format.width != Count::CountImplied;\n \n+                if has_precision || has_width {\n+                    // push before named params are resolved to aid diagnostics\n+                    self.arg_with_formatting.push(arg.format);\n+                }\n+\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n@@ -536,7 +541,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     ) {\n         match c {\n             parse::CountImplied | parse::CountIs(..) => {}\n-            parse::CountIsParam(i) => {\n+            parse::CountIsParam(i) | parse::CountIsStar(i) => {\n                 self.unused_names_lint.maybe_add_positional_named_arg(\n                     self.args.get(i),\n                     named_arg_type,\n@@ -581,7 +586,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut zero_based_note = false;\n \n         let count = self.pieces.len()\n-            + self.arg_with_formatting.iter().filter(|fmt| fmt.precision_span.is_some()).count();\n+            + self\n+                .arg_with_formatting\n+                .iter()\n+                .filter(|fmt| matches!(fmt.precision, parse::CountIsStar(_)))\n+                .count();\n         if self.names.is_empty() && !numbered_position_args && count != self.num_args() {\n             e = self.ecx.struct_span_err(\n                 sp,\n@@ -630,7 +639,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             if let Some(span) = fmt.precision_span {\n                 let span = self.fmtsp.from_inner(InnerSpan::new(span.start, span.end));\n                 match fmt.precision {\n-                    parse::CountIsParam(pos) if pos > self.num_args() => {\n+                    parse::CountIsParam(pos) if pos >= self.num_args() => {\n                         e.span_label(\n                             span,\n                             &format!(\n@@ -642,12 +651,12 @@ impl<'a, 'b> Context<'a, 'b> {\n                         );\n                         zero_based_note = true;\n                     }\n-                    parse::CountIsParam(pos) => {\n+                    parse::CountIsStar(pos) => {\n                         let count = self.pieces.len()\n                             + self\n                                 .arg_with_formatting\n                                 .iter()\n-                                .filter(|fmt| fmt.precision_span.is_some())\n+                                .filter(|fmt| matches!(fmt.precision, parse::CountIsStar(_)))\n                                 .count();\n                         e.span_label(\n                             span,\n@@ -828,7 +837,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         };\n         match c {\n             parse::CountIs(i) => count(sym::Is, Some(self.ecx.expr_usize(sp, i))),\n-            parse::CountIsParam(i) => {\n+            parse::CountIsParam(i) | parse::CountIsStar(i) => {\n                 // This needs mapping too, as `i` is referring to a macro\n                 // argument. If `i` is not found in `count_positions` then\n                 // the error had already been emitted elsewhere.\n@@ -899,26 +908,22 @@ impl<'a, 'b> Context<'a, 'b> {\n                     },\n                     position_span: arg.position_span,\n                     format: parse::FormatSpec {\n-                        fill: arg.format.fill,\n+                        fill: None,\n                         align: parse::AlignUnknown,\n                         flags: 0,\n                         precision: parse::CountImplied,\n-                        precision_span: None,\n+                        precision_span: arg.format.precision_span,\n                         width: parse::CountImplied,\n-                        width_span: None,\n+                        width_span: arg.format.width_span,\n                         ty: arg.format.ty,\n                         ty_span: arg.format.ty_span,\n                     },\n                 };\n \n                 let fill = arg.format.fill.unwrap_or(' ');\n-\n                 let pos_simple = arg.position.index() == simple_arg.position.index();\n \n-                if arg.format.precision_span.is_some() || arg.format.width_span.is_some() {\n-                    self.arg_with_formatting.push(arg.format);\n-                }\n-                if !pos_simple || arg.format != simple_arg.format || fill != ' ' {\n+                if !pos_simple || arg.format != simple_arg.format {\n                     self.all_pieces_simple = false;\n                 }\n \n@@ -1176,7 +1181,7 @@ fn create_lints_for_named_arguments_used_positionally(cx: &mut Context<'_, '_>)\n \n         cx.ecx.buffered_early_lint.push(BufferedEarlyLint {\n             span: MultiSpan::from_span(named_arg.positional_named_arg_span),\n-            msg: msg.clone(),\n+            msg: msg.into(),\n             node_id: ast::CRATE_NODE_ID,\n             lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n             diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {"}, {"sha": "2bad9bbce6650b30af53e970bd90a0ae21287552", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::expand::allocator::{\n     AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS,\n };\n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Attribute, Expr, FnHeader, FnSig, Generics, Param, StmtKind};\n+use rustc_ast::{self as ast, AttrVec, Expr, FnHeader, FnSig, Generics, Param, StmtKind};\n use rustc_ast::{Fn, ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -113,10 +113,10 @@ impl AllocFnFactory<'_, '_> {\n         self.cx.expr_call(self.ty_span, method, args)\n     }\n \n-    fn attrs(&self) -> Vec<Attribute> {\n+    fn attrs(&self) -> AttrVec {\n         let special = sym::rustc_std_internal_symbol;\n         let special = self.cx.meta_word(self.span, special);\n-        vec![self.cx.attribute(special)]\n+        vec![self.cx.attribute(special)].into()\n     }\n \n     fn arg_ty("}, {"sha": "11565ba72d7555f1fb157468fd4c83b957eb873e", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,6 +8,7 @@\n #![feature(decl_macro)]\n #![feature(if_let_guard)]\n #![feature(is_sorted)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]"}, {"sha": "ebe1c3663e3a7fafc65da5117b065ac2eccb962f", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -281,7 +281,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n     let span = DUMMY_SP.with_def_site_ctxt(expn_id.to_expn_id());\n \n     let proc_macro = Ident::new(sym::proc_macro, span);\n-    let krate = cx.item(span, proc_macro, Vec::new(), ast::ItemKind::ExternCrate(None));\n+    let krate = cx.item(span, proc_macro, ast::AttrVec::new(), ast::ItemKind::ExternCrate(None));\n \n     let bridge = Ident::new(sym::bridge, span);\n     let client = Ident::new(sym::client, span);"}, {"sha": "90ea1e457ba8031885f3941cb605e00e52590c0f", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -51,7 +51,7 @@ pub fn inject(\n             cx.item(\n                 span,\n                 ident,\n-                vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n+                vec![cx.attribute(cx.meta_word(span, sym::macro_use))].into(),\n                 ast::ItemKind::ExternCrate(None),\n             ),\n         );\n@@ -78,7 +78,7 @@ pub fn inject(\n     let use_item = cx.item(\n         span,\n         Ident::empty(),\n-        vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n+        vec![cx.attribute(cx.meta_word(span, sym::prelude_import))].into(),\n         ast::ItemKind::Use(ast::UseTree {\n             prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,"}, {"sha": "03c84f5ec2a740fe1f158099885719b5369477c6", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -227,7 +227,8 @@ pub fn expand_test_or_bench(\n             )),\n             // #[rustc_test_marker]\n             cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),\n-        ],\n+        ]\n+        .into(),\n         // const $ident: test::TestDescAndFn =\n         ast::ItemKind::Const(\n             ast::Defaultness::Final,\n@@ -334,7 +335,7 @@ pub fn expand_test_or_bench(\n     });\n \n     // extern crate test\n-    let test_extern = cx.item(sp, test_id, vec![], ast::ItemKind::ExternCrate(None));\n+    let test_extern = cx.item(sp, test_id, ast::AttrVec::new(), ast::ItemKind::ExternCrate(None));\n \n     tracing::debug!(\"synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n "}, {"sha": "093f0f10a3867e591108604f1547841a960ff125", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -298,8 +298,10 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n     // extern crate test\n-    let test_extern_stmt =\n-        ecx.stmt_item(sp, ecx.item(sp, test_id, vec![], ast::ItemKind::ExternCrate(None)));\n+    let test_extern_stmt = ecx.stmt_item(\n+        sp,\n+        ecx.item(sp, test_id, ast::AttrVec::new(), ast::ItemKind::ExternCrate(None)),\n+    );\n \n     // #[rustc_main]\n     let main_meta = ecx.meta_word(sp, sym::rustc_main);\n@@ -333,7 +335,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     let main = P(ast::Item {\n         ident: main_id,\n-        attrs: vec![main_attr],\n+        attrs: vec![main_attr].into(),\n         id: ast::DUMMY_NODE_ID,\n         kind: main,\n         vis: ast::Visibility { span: sp, kind: ast::VisibilityKind::Public, tokens: None },"}, {"sha": "732edd66196d7de4c3d8d18e0c944e05d279906c", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -22,4 +22,4 @@ task:\n     - # Reduce amount of benchmark runs as they are slow\n     - export COMPILE_RUNS=2\n     - export RUN_RUNS=2\n-    - ./test.sh\n+    - ./y.rs test"}, {"sha": "e8897e9ae81454a01145a9b4343f66cafdb00565", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -103,7 +103,7 @@ jobs:\n         # Enable extra checks\n         export CG_CLIF_ENABLE_VERIFIER=1\n \n-        ./test.sh\n+        ./y.rs test\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build\n@@ -162,14 +162,14 @@ jobs:\n       #name: Test\n       run: |\n         # Enable backtraces for easier debugging\n-        #export RUST_BACKTRACE=1\n+        #$Env:RUST_BACKTRACE=1\n \n         # Reduce amount of benchmark runs as they are slow\n-        #export COMPILE_RUNS=2\n-        #export RUN_RUNS=2\n+        #$Env:COMPILE_RUNS=2\n+        #$Env:RUN_RUNS=2\n \n         # Enable extra checks\n-        #export CG_CLIF_ENABLE_VERIFIER=1\n+        #$Env:CG_CLIF_ENABLE_VERIFIER=1\n \n         ./y.exe build\n "}, {"sha": "6fd3e4443de5c29a78797daa438342723ce3468b", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,6 +8,8 @@ perf.data.old\n *.string*\n /y.bin\n /y.bin.dSYM\n+/y.exe\n+/y.pdb\n /build\n /build_sysroot/sysroot_src\n /build_sysroot/compiler-builtins\n@@ -17,3 +19,4 @@ perf.data.old\n /regex\n /simple-raytracer\n /portable-simd\n+/abi-checker"}, {"sha": "edae7e471578a88a9ec482c52397ab5330ac4cda", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 92, "deletions": 55, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -50,18 +50,18 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"749d0d6022c9038dccf480bdde2a38d435937335bf2bb0f14e815d94517cdce8\"\n+checksum = \"93945adbccc8d731503d3038814a51e8317497c9e205411820348132fa01a358\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e94370cc7b37bf652ccd8bb8f09bd900997f7ccf97520edfc75554bb5c4abbea\"\n+checksum = \"2b482acc9d0d0d1ad3288a90a8150ee648be3dce8dc8c8669ff026f72debdc31\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n@@ -77,30 +77,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e0a3cea8fdab90e44018c5b9a1dfd460d8ee265ac354337150222a354628bdb6\"\n+checksum = \"f9ec188d71e663192ef9048f204e410a7283b609942efc9fcc77da6d496edbb8\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ac72f76f2698598951ab26d8c96eaa854810e693e7dd52523958b5909fde6b2\"\n+checksum = \"3ad794b1b1c2c7bd9f7b76cfe0f084eaf7753e55d56191c3f7d89e8fa4978b99\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09eaeacfcd2356fe0e66b295e8f9d59fdd1ac3ace53ba50de14d628ec902f72d\"\n+checksum = \"342da0d5056f4119d3c311c4aab2460ceb6ee6e127bb395b76dd2279a09ea7a5\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dba69c9980d5ffd62c18a2bde927855fcd7c8dc92f29feaf8636052662cbd99c\"\n+checksum = \"dfff792f775b07d4d9cfe9f1c767ce755c6cbadda1bbd6db18a1c75ff9f7376a\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -110,15 +110,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d2920dc1e05cac40304456ed3301fde2c09bd6a9b0210bcfa2f101398d628d5b\"\n+checksum = \"8d51089478849f2ac8ef60a8a2d5346c8d4abfec0e45ac5b24530ef9f9499e1e\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1c3c5ed067f2c81577e431f3039148a9c187b33cc79e0d1731fede27d801ec56\"\n+checksum = \"095936e41720f86004b4c57ce88e6a13af28646bb3a6fb4afbebd5ae90c50029\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -129,24 +129,24 @@ dependencies = [\n  \"log\",\n  \"region\",\n  \"target-lexicon\",\n- \"winapi\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eee6784303bf9af235237a4885f7417e09a35df896d38ea969a0081064b3ede4\"\n+checksum = \"704a1aea4723d97eafe0fb7af110f6f6868b1ac95f5380bbc9adb2a3b8cf97e8\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f04dfa45f9b2a6f587c564d6b63388e00cd6589d2df6ea2758cf79e1a13285e6\"\n+checksum = \"885debe62f2078638d6585f54c9f05f5c2008f22ce5a2a9100ada785fc065dbd\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -155,9 +155,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.85.3\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0bf38b2c505db749276793116c0cb30bd096206c7810e471677a453134881881\"\n+checksum = \"aac1310cf1081ae8eca916c92cd163b977c77cab6e831fa812273c26ff921816\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -187,9 +187,9 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.6\"\n+version = \"0.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9be70c98951c83b8d2f8f60d7065fa6d5146873094452a1008da8c2f1e4205ad\"\n+checksum = \"4eb1a864a501629691edf6c15a593b7a51eebaa1e8468e9ddc623de7c9b58ec6\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -198,43 +198,37 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.26.1\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n dependencies = [\n  \"indexmap\",\n ]\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.11.2\"\n+version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n+checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n dependencies = [\n  \"ahash\",\n ]\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.12.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n-\n [[package]]\n name = \"indexmap\"\n version = \"1.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown 0.12.3\",\n+ \"hashbrown\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.126\"\n+version = \"0.2.127\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+checksum = \"505e71a4706fa491e9b1b55f51b95d4037d0821ee40131190475f692b35b009b\"\n \n [[package]]\n name = \"libloading\"\n@@ -248,9 +242,9 @@ dependencies = [\n \n [[package]]\n name = \"log\"\n-version = \"0.4.14\"\n+version = \"0.4.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n+checksum = \"abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -266,33 +260,33 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.4.1\"\n+version = \"2.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n+checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"object\"\n-version = \"0.28.4\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n+checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n dependencies = [\n  \"crc32fast\",\n- \"hashbrown 0.11.2\",\n+ \"hashbrown\",\n  \"indexmap\",\n  \"memchr\",\n ]\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.10.0\"\n+version = \"1.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"87f3e037eac156d1775da914196f0f37741a274155e34a0b7e427c35d2a2ecb9\"\n+checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n \n [[package]]\n name = \"regalloc2\"\n-version = \"0.2.3\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4a8d23b35d7177df3b9d31ed8a9ab4bf625c668be77a319d4f5efd4a5257701c\"\n+checksum = \"d43a209257d978ef079f3d446331d0f1794f5e0fc19b306a199983857833a779\"\n dependencies = [\n  \"fxhash\",\n  \"log\",\n@@ -340,15 +334,15 @@ checksum = \"03b634d87b960ab1a38c4fe143b508576f075e7c978bfad18217645ebfdfa2ec\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.8.1\"\n+version = \"1.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc88c725d61fc6c3132893370cac4a0200e3fedf5da8331c570664b1987f5ca2\"\n+checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.3\"\n+version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7fa7e55043acb85fca6b3c01485a2eeb6b69c5d21002e273c79e465f43b7ac1\"\n+checksum = \"c02424087780c9b71cc96799eaeddff35af2bc513278cda5c99fc1f5d026d3c1\"\n \n [[package]]\n name = \"version_check\"\n@@ -358,9 +352,9 @@ checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n \n [[package]]\n name = \"wasi\"\n-version = \"0.10.2+wasi-snapshot-preview1\"\n+version = \"0.11.0+wasi-snapshot-preview1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n+checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n [[package]]\n name = \"winapi\"\n@@ -383,3 +377,46 @@ name = \"winapi-x86_64-pc-windows-gnu\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+dependencies = [\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n+ \"windows_x86_64_msvc\",\n+]\n+\n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+\n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+\n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+\n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\""}, {"sha": "e7c3427485480119829d0322b76cb0feb217e5f8", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,15 +8,15 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.85.3\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.85.3\"\n-cranelift-module = \"0.85.3\"\n-cranelift-native = \"0.85.3\"\n-cranelift-jit = { version = \"0.85.3\", optional = true }\n-cranelift-object = \"0.85.3\"\n+cranelift-codegen = { version = \"0.87.0\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.87.0\"\n+cranelift-module = \"0.87.0\"\n+cranelift-native = \"0.87.0\"\n+cranelift-jit = { version = \"0.87.0\", optional = true }\n+cranelift-object = \"0.87.0\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.28.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\""}, {"sha": "1e84c7fa3657b37afeb26614a49896fab8846b40", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -52,9 +52,7 @@ configuration options.\n ## Not yet supported\n \n * Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041))\n-    * On Linux there is support for invoking an external assembler for `global_asm!` and `asm!`.\n-      `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n-      have to specify specific registers instead.\n+    * On UNIX there is support for invoking an external assembler for `global_asm!` and `asm!`.\n * SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n \n ## License"}, {"sha": "6c5043bb6f8e1e86cdde105d5607a4355581d5a4", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -56,9 +56,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.75\"\n+version = \"0.1.79\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c6e3183e88f659a862835db8f4b67dbeed3d93e44dd4927eef78edb1c149d784\"\n+checksum = \"4f873ce2bd3550b0b565f878b3d04ea8253f4259dc3d20223af2e1ba86f5ecca\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -69,9 +69,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"dlmalloc\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a6fe28e0bf9357092740362502f5cc7955d8dc125ebda71dec72336c2e15c62e\"\n+checksum = \"203540e710bfadb90e5e29930baf5d10270cec1f43ab34f46f78b147b2de715a\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -80,9 +80,9 @@ dependencies = [\n \n [[package]]\n name = \"fortanix-sgx-abi\"\n-version = \"0.3.3\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c56c422ef86062869b2d57ae87270608dc5929969dd130a6e248979cf4fb6ca6\"\n+checksum = \"57cafc2274c10fab234f176b25903ce17e690fca7597090d50880e047a0389c5\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -123,9 +123,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.4\"\n+version = \"0.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7668753748e445859e4e373c3d41117235d9feed578392f5a3a73efdc751ca4a\"\n+checksum = \"897cd85af6387be149f55acf168e41be176a02de7872403aaab184afc2f327e6\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -135,9 +135,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.126\"\n+version = \"0.2.132\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+checksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "67dbd0a38a4fb4d44d0579e907bbc1a4c6bc9de0", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_checker.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,60 @@\n+use super::build_sysroot;\n+use super::config;\n+use super::utils::spawn_and_wait;\n+use build_system::SysrootKind;\n+use std::env;\n+use std::path::Path;\n+use std::process::Command;\n+\n+pub(crate) fn run(\n+    channel: &str,\n+    sysroot_kind: SysrootKind,\n+    target_dir: &Path,\n+    cg_clif_build_dir: &Path,\n+    host_triple: &str,\n+    target_triple: &str,\n+) {\n+    if !config::get_bool(\"testsuite.abi-checker\") {\n+        eprintln!(\"[SKIP] abi-checker\");\n+        return;\n+    }\n+\n+    if host_triple != target_triple {\n+        eprintln!(\"[SKIP] abi-checker (cross-compilation not supported)\");\n+        return;\n+    }\n+\n+    eprintln!(\"Building sysroot for abi-checker\");\n+    build_sysroot::build_sysroot(\n+        channel,\n+        sysroot_kind,\n+        target_dir,\n+        cg_clif_build_dir,\n+        host_triple,\n+        target_triple,\n+    );\n+\n+    eprintln!(\"Running abi-checker\");\n+    let mut abi_checker_path = env::current_dir().unwrap();\n+    abi_checker_path.push(\"abi-checker\");\n+    env::set_current_dir(abi_checker_path.clone()).unwrap();\n+\n+    let build_dir = abi_checker_path.parent().unwrap().join(\"build\");\n+    let cg_clif_dylib_path = build_dir.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n+        env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n+    );\n+\n+    let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n+\n+    let mut cmd = Command::new(\"cargo\");\n+    cmd.arg(\"run\");\n+    cmd.arg(\"--target\");\n+    cmd.arg(target_triple);\n+    cmd.arg(\"--\");\n+    cmd.arg(\"--pairs\");\n+    cmd.args(pairs);\n+    cmd.arg(\"--add-rustc-codegen-backend\");\n+    cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib_path.display()));\n+\n+    spawn_and_wait(cmd);\n+}"}, {"sha": "9e59b8199b4123076a960771b4f2132a86d3cd54", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,6 +2,8 @@ use std::env;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use super::utils::is_ci;\n+\n pub(crate) fn build_backend(\n     channel: &str,\n     host_triple: &str,\n@@ -14,7 +16,7 @@ pub(crate) fn build_backend(\n \n     let mut rustflags = env::var(\"RUSTFLAGS\").unwrap_or_default();\n \n-    if env::var(\"CI\").as_ref().map(|val| &**val) == Ok(\"true\") {\n+    if is_ci() {\n         // Deny warnings on CI\n         rustflags += \" -Dwarnings\";\n "}, {"sha": "7e205b0fd0b3b85dab07cb83a620a56fd256a233", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,18 +2,20 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n-use super::rustc_info::{get_file_name, get_rustc_version};\n+use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n use super::utils::{spawn_and_wait, try_hard_link};\n use super::SysrootKind;\n \n pub(crate) fn build_sysroot(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     target_dir: &Path,\n-    cg_clif_build_dir: PathBuf,\n+    cg_clif_build_dir: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n+    eprintln!(\"[BUILD] sysroot {:?}\", sysroot_kind);\n+\n     if target_dir.exists() {\n         fs::remove_dir_all(target_dir).unwrap();\n     }\n@@ -35,11 +37,13 @@ pub(crate) fn build_sysroot(\n \n     // Build and copy rustc and cargo wrappers\n     for wrapper in [\"rustc-clif\", \"cargo-clif\"] {\n+        let wrapper_name = get_wrapper_file_name(wrapper, \"bin\");\n+\n         let mut build_cargo_wrapper_cmd = Command::new(\"rustc\");\n         build_cargo_wrapper_cmd\n             .arg(PathBuf::from(\"scripts\").join(format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(target_dir.join(wrapper))\n+            .arg(target_dir.join(wrapper_name))\n             .arg(\"-g\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n     }"}, {"sha": "c3706dc6f82039cfee03fe18fdb7ef7c3f8c36d6", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,11 +2,15 @@ use std::env;\n use std::path::PathBuf;\n use std::process;\n \n+use self::utils::is_ci;\n+\n+mod abi_checker;\n mod build_backend;\n mod build_sysroot;\n mod config;\n mod prepare;\n mod rustc_info;\n+mod tests;\n mod utils;\n \n fn usage() {\n@@ -15,6 +19,9 @@ fn usage() {\n     eprintln!(\n         \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n     );\n+    eprintln!(\n+        \"  ./y.rs test [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n+    );\n }\n \n macro_rules! arg_error {\n@@ -25,11 +32,13 @@ macro_rules! arg_error {\n     }};\n }\n \n+#[derive(PartialEq, Debug)]\n enum Command {\n     Build,\n+    Test,\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) enum SysrootKind {\n     None,\n     Clif,\n@@ -42,16 +51,22 @@ pub fn main() {\n     // The target dir is expected in the default location. Guard against the user changing it.\n     env::set_var(\"CARGO_TARGET_DIR\", \"target\");\n \n+    if is_ci() {\n+        // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n+        env::set_var(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n+    }\n+\n     let mut args = env::args().skip(1);\n     let command = match args.next().as_deref() {\n         Some(\"prepare\") => {\n             if args.next().is_some() {\n-                arg_error!(\"./x.rs prepare doesn't expect arguments\");\n+                arg_error!(\"./y.rs prepare doesn't expect arguments\");\n             }\n             prepare::prepare();\n             process::exit(0);\n         }\n         Some(\"build\") => Command::Build,\n+        Some(\"test\") => Command::Test,\n         Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n         Some(command) => arg_error!(\"Unknown command {}\", command),\n         None => {\n@@ -117,12 +132,35 @@ pub fn main() {\n \n     let cg_clif_build_dir =\n         build_backend::build_backend(channel, &host_triple, use_unstable_features);\n-    build_sysroot::build_sysroot(\n-        channel,\n-        sysroot_kind,\n-        &target_dir,\n-        cg_clif_build_dir,\n-        &host_triple,\n-        &target_triple,\n-    );\n+    match command {\n+        Command::Test => {\n+            tests::run_tests(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+\n+            abi_checker::run(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+        }\n+        Command::Build => {\n+            build_sysroot::build_sysroot(\n+                channel,\n+                sysroot_kind,\n+                &target_dir,\n+                &cg_clif_build_dir,\n+                &host_triple,\n+                &target_triple,\n+            );\n+        }\n+    }\n }"}, {"sha": "d23b7f00dcf16da744be926925043d5716cad145", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -14,6 +14,14 @@ pub(crate) fn prepare() {\n     eprintln!(\"[INSTALL] hyperfine\");\n     Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n \n+    clone_repo_shallow_github(\n+        \"abi-checker\",\n+        \"Gankra\",\n+        \"abi-checker\",\n+        \"a2232d45f202846f5c02203c9f27355360f9a2ff\",\n+    );\n+    apply_patches(\"abi-checker\", Path::new(\"abi-checker\"));\n+\n     clone_repo_shallow_github(\n         \"rand\",\n         \"rust-random\",\n@@ -50,8 +58,7 @@ pub(crate) fn prepare() {\n     spawn_and_wait(build_cmd);\n     fs::copy(\n         Path::new(\"simple-raytracer/target/debug\").join(get_file_name(\"main\", \"bin\")),\n-        // FIXME use get_file_name here too once testing is migrated to rust\n-        \"simple-raytracer/raytracer_cg_llvm\",\n+        Path::new(\"simple-raytracer\").join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }"}, {"sha": "913b589afcc87f658510195969fd03aef5d683e2", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -63,3 +63,12 @@ pub(crate) fn get_file_name(crate_name: &str, crate_type: &str) -> String {\n     assert!(file_name.contains(crate_name));\n     file_name\n }\n+\n+/// Similar to `get_file_name`, but converts any dashes (`-`) in the `crate_name` to\n+/// underscores (`_`). This is specially made for the the rustc and cargo wrappers\n+/// which have a dash in the name, and that is not allowed in a crate name.\n+pub(crate) fn get_wrapper_file_name(crate_name: &str, crate_type: &str) -> String {\n+    let crate_name = crate_name.replace('-', \"_\");\n+    let wrapper_name = get_file_name(&crate_name, crate_type);\n+    wrapper_name.replace('_', \"-\")\n+}"}, {"sha": "e21397cece8b32e28d7d7d6c206d4dad07e79ca1", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "added", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,619 @@\n+use super::build_sysroot;\n+use super::config;\n+use super::rustc_info::get_wrapper_file_name;\n+use super::utils::{spawn_and_wait, spawn_and_wait_with_input};\n+use build_system::SysrootKind;\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+struct TestCase {\n+    config: &'static str,\n+    func: &'static dyn Fn(&TestRunner),\n+}\n+\n+impl TestCase {\n+    const fn new(config: &'static str, func: &'static dyn Fn(&TestRunner)) -> Self {\n+        Self { config, func }\n+    }\n+}\n+\n+const NO_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"build.mini_core\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mini_core.rs\",\n+            \"--crate-name\",\n+            \"mini_core\",\n+            \"--crate-type\",\n+            \"lib,dylib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"build.example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/example.rs\",\n+            \"--crate-type\",\n+            \"lib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"jit.mini_core_hello_world\", &|runner| {\n+        let mut jit_cmd = runner.rustc_command([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit\",\n+            \"-Cprefer-dynamic\",\n+            \"example/mini_core_hello_world.rs\",\n+            \"--cfg\",\n+            \"jit\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n+        spawn_and_wait(jit_cmd);\n+\n+        eprintln!(\"[JIT-lazy] mini_core_hello_world\");\n+        let mut jit_cmd = runner.rustc_command([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit-lazy\",\n+            \"-Cprefer-dynamic\",\n+            \"example/mini_core_hello_world.rs\",\n+            \"--cfg\",\n+            \"jit\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n+        spawn_and_wait(jit_cmd);\n+    }),\n+    TestCase::new(\"aot.mini_core_hello_world\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mini_core_hello_world.rs\",\n+            \"--crate-name\",\n+            \"mini_core_hello_world\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-g\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"mini_core_hello_world\", [\"abc\", \"bcd\"]);\n+    }),\n+];\n+\n+const BASE_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"aot.arbitrary_self_types_pointers_and_wrappers\", &|runner| {\n+        runner.run_rustc([\n+            \"example/arbitrary_self_types_pointers_and_wrappers.rs\",\n+            \"--crate-name\",\n+            \"arbitrary_self_types_pointers_and_wrappers\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"arbitrary_self_types_pointers_and_wrappers\", []);\n+    }),\n+    TestCase::new(\"aot.issue_91827_extern_types\", &|runner| {\n+        runner.run_rustc([\n+            \"example/issue-91827-extern-types.rs\",\n+            \"--crate-name\",\n+            \"issue_91827_extern_types\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"issue_91827_extern_types\", []);\n+    }),\n+    TestCase::new(\"build.alloc_system\", &|runner| {\n+        runner.run_rustc([\n+            \"example/alloc_system.rs\",\n+            \"--crate-type\",\n+            \"lib\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"aot.alloc_example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/alloc_example.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"alloc_example\", []);\n+    }),\n+    TestCase::new(\"jit.std_example\", &|runner| {\n+        runner.run_rustc([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit\",\n+            \"-Cprefer-dynamic\",\n+            \"example/std_example.rs\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+\n+        eprintln!(\"[JIT-lazy] std_example\");\n+        runner.run_rustc([\n+            \"-Zunstable-options\",\n+            \"-Cllvm-args=mode=jit-lazy\",\n+            \"-Cprefer-dynamic\",\n+            \"example/std_example.rs\",\n+            \"--target\",\n+            &runner.host_triple,\n+        ]);\n+    }),\n+    TestCase::new(\"aot.std_example\", &|runner| {\n+        runner.run_rustc([\n+            \"example/std_example.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"std_example\", [\"arg\"]);\n+    }),\n+    TestCase::new(\"aot.dst_field_align\", &|runner| {\n+        runner.run_rustc([\n+            \"example/dst-field-align.rs\",\n+            \"--crate-name\",\n+            \"dst_field_align\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"dst_field_align\", []);\n+    }),\n+    TestCase::new(\"aot.subslice-patterns-const-eval\", &|runner| {\n+        runner.run_rustc([\n+            \"example/subslice-patterns-const-eval.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"subslice-patterns-const-eval\", []);\n+    }),\n+    TestCase::new(\"aot.track-caller-attribute\", &|runner| {\n+        runner.run_rustc([\n+            \"example/track-caller-attribute.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"track-caller-attribute\", []);\n+    }),\n+    TestCase::new(\"aot.float-minmax-pass\", &|runner| {\n+        runner.run_rustc([\n+            \"example/float-minmax-pass.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"-Cpanic=abort\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"float-minmax-pass\", []);\n+    }),\n+    TestCase::new(\"aot.mod_bench\", &|runner| {\n+        runner.run_rustc([\n+            \"example/mod_bench.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_triple,\n+        ]);\n+        runner.run_out_command(\"mod_bench\", []);\n+    }),\n+];\n+\n+const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"test.rust-random/rand\", &|runner| {\n+        runner.in_dir([\"rand\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                eprintln!(\"[TEST] rust-random/rand\");\n+                runner.run_cargo([\"test\", \"--workspace\"]);\n+            } else {\n+                eprintln!(\"[AOT] rust-random/rand\");\n+                runner.run_cargo([\n+                    \"build\",\n+                    \"--workspace\",\n+                    \"--target\",\n+                    &runner.target_triple,\n+                    \"--tests\",\n+                ]);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"bench.simple-raytracer\", &|runner| {\n+        runner.in_dir([\"simple-raytracer\"], |runner| {\n+            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string());\n+\n+            if runner.host_triple == runner.target_triple {\n+                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n+                let mut bench_compile = Command::new(\"hyperfine\");\n+                bench_compile.arg(\"--runs\");\n+                bench_compile.arg(&run_runs);\n+                bench_compile.arg(\"--warmup\");\n+                bench_compile.arg(\"1\");\n+                bench_compile.arg(\"--prepare\");\n+                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"clean\"])));\n+\n+                if cfg!(windows) {\n+                    bench_compile.arg(\"cmd /C \\\"set RUSTFLAGS= && cargo build\\\"\");\n+                } else {\n+                    bench_compile.arg(\"RUSTFLAGS='' cargo build\");\n+                }\n+\n+                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"build\"])));\n+                spawn_and_wait(bench_compile);\n+\n+                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n+                fs::copy(PathBuf::from(\"./target/debug/main\"), PathBuf::from(\"raytracer_cg_clif\"))\n+                    .unwrap();\n+\n+                let mut bench_run = Command::new(\"hyperfine\");\n+                bench_run.arg(\"--runs\");\n+                bench_run.arg(&run_runs);\n+                bench_run.arg(PathBuf::from(\"./raytracer_cg_llvm\"));\n+                bench_run.arg(PathBuf::from(\"./raytracer_cg_clif\"));\n+                spawn_and_wait(bench_run);\n+            } else {\n+                runner.run_cargo([\"clean\"]);\n+                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n+                eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n+                runner.run_cargo([\"build\", \"--target\", &runner.target_triple]);\n+                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.libcore\", &|runner| {\n+        runner.in_dir([\"build_sysroot\", \"sysroot_src\", \"library\", \"core\", \"tests\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                runner.run_cargo([\"test\"]);\n+            } else {\n+                eprintln!(\"Cross-Compiling: Not running tests\");\n+                runner.run_cargo([\"build\", \"--target\", &runner.target_triple, \"--tests\"]);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n+        runner.in_dir([\"regex\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            // newer aho_corasick versions throw a deprecation warning\n+            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n+\n+            let mut build_cmd = runner.cargo_command([\n+                \"build\",\n+                \"--example\",\n+                \"shootout-regex-dna\",\n+                \"--target\",\n+                &runner.target_triple,\n+            ]);\n+            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+            spawn_and_wait(build_cmd);\n+\n+            if runner.host_triple == runner.target_triple {\n+                let mut run_cmd = runner.cargo_command([\n+                    \"run\",\n+                    \"--example\",\n+                    \"shootout-regex-dna\",\n+                    \"--target\",\n+                    &runner.target_triple,\n+                ]);\n+                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+\n+                let input =\n+                    fs::read_to_string(PathBuf::from(\"examples/regexdna-input.txt\")).unwrap();\n+                let expected_path = PathBuf::from(\"examples/regexdna-output.txt\");\n+                let expected = fs::read_to_string(&expected_path).unwrap();\n+\n+                let output = spawn_and_wait_with_input(run_cmd, input);\n+                // Make sure `[codegen mono items] start` doesn't poison the diff\n+                let output = output\n+                    .lines()\n+                    .filter(|line| !line.contains(\"codegen mono items\"))\n+                    .chain(Some(\"\")) // This just adds the trailing newline\n+                    .collect::<Vec<&str>>()\n+                    .join(\"\\r\\n\");\n+\n+                let output_matches = expected.lines().eq(output.lines());\n+                if !output_matches {\n+                    let res_path = PathBuf::from(\"res.txt\");\n+                    fs::write(&res_path, &output).unwrap();\n+\n+                    if cfg!(windows) {\n+                        println!(\"Output files don't match!\");\n+                        println!(\"Expected Output:\\n{}\", expected);\n+                        println!(\"Actual Output:\\n{}\", output);\n+                    } else {\n+                        let mut diff = Command::new(\"diff\");\n+                        diff.arg(\"-u\");\n+                        diff.arg(res_path);\n+                        diff.arg(expected_path);\n+                        spawn_and_wait(diff);\n+                    }\n+\n+                    std::process::exit(1);\n+                }\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.regex\", &|runner| {\n+        runner.in_dir([\"regex\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+\n+            // newer aho_corasick versions throw a deprecation warning\n+            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n+\n+            if runner.host_triple == runner.target_triple {\n+                let mut run_cmd = runner.cargo_command([\n+                    \"test\",\n+                    \"--tests\",\n+                    \"--\",\n+                    \"--exclude-should-panic\",\n+                    \"--test-threads\",\n+                    \"1\",\n+                    \"-Zunstable-options\",\n+                    \"-q\",\n+                ]);\n+                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+                spawn_and_wait(run_cmd);\n+            } else {\n+                eprintln!(\"Cross-Compiling: Not running tests\");\n+                let mut build_cmd =\n+                    runner.cargo_command([\"build\", \"--tests\", \"--target\", &runner.target_triple]);\n+                build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+                spawn_and_wait(build_cmd);\n+            }\n+        });\n+    }),\n+    TestCase::new(\"test.portable-simd\", &|runner| {\n+        runner.in_dir([\"portable-simd\"], |runner| {\n+            runner.run_cargo([\"clean\"]);\n+            runner.run_cargo([\"build\", \"--all-targets\", \"--target\", &runner.target_triple]);\n+\n+            if runner.host_triple == runner.target_triple {\n+                runner.run_cargo([\"test\", \"-q\"]);\n+            }\n+        });\n+    }),\n+];\n+\n+pub(crate) fn run_tests(\n+    channel: &str,\n+    sysroot_kind: SysrootKind,\n+    target_dir: &Path,\n+    cg_clif_build_dir: &Path,\n+    host_triple: &str,\n+    target_triple: &str,\n+) {\n+    let runner = TestRunner::new(host_triple.to_string(), target_triple.to_string());\n+\n+    if config::get_bool(\"testsuite.no_sysroot\") {\n+        build_sysroot::build_sysroot(\n+            channel,\n+            SysrootKind::None,\n+            &target_dir,\n+            cg_clif_build_dir,\n+            &host_triple,\n+            &target_triple,\n+        );\n+\n+        let _ = fs::remove_dir_all(Path::new(\"target\").join(\"out\"));\n+        runner.run_testsuite(NO_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] no_sysroot tests\");\n+    }\n+\n+    let run_base_sysroot = config::get_bool(\"testsuite.base_sysroot\");\n+    let run_extended_sysroot = config::get_bool(\"testsuite.extended_sysroot\");\n+\n+    if run_base_sysroot || run_extended_sysroot {\n+        build_sysroot::build_sysroot(\n+            channel,\n+            sysroot_kind,\n+            &target_dir,\n+            cg_clif_build_dir,\n+            &host_triple,\n+            &target_triple,\n+        );\n+    }\n+\n+    if run_base_sysroot {\n+        runner.run_testsuite(BASE_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] base_sysroot tests\");\n+    }\n+\n+    if run_extended_sysroot {\n+        runner.run_testsuite(EXTENDED_SYSROOT_SUITE);\n+    } else {\n+        eprintln!(\"[SKIP] extended_sysroot tests\");\n+    }\n+}\n+\n+struct TestRunner {\n+    root_dir: PathBuf,\n+    out_dir: PathBuf,\n+    jit_supported: bool,\n+    rust_flags: String,\n+    run_wrapper: Vec<String>,\n+    host_triple: String,\n+    target_triple: String,\n+}\n+\n+impl TestRunner {\n+    pub fn new(host_triple: String, target_triple: String) -> Self {\n+        let root_dir = env::current_dir().unwrap();\n+\n+        let mut out_dir = root_dir.clone();\n+        out_dir.push(\"target\");\n+        out_dir.push(\"out\");\n+\n+        let is_native = host_triple == target_triple;\n+        let jit_supported =\n+            target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n+\n+        let mut rust_flags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n+        let mut run_wrapper = Vec::new();\n+\n+        if !is_native {\n+            match target_triple.as_str() {\n+                \"aarch64-unknown-linux-gnu\" => {\n+                    // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+                    rust_flags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rust_flags);\n+                    run_wrapper = vec![\"qemu-aarch64\", \"-L\", \"/usr/aarch64-linux-gnu\"];\n+                }\n+                \"x86_64-pc-windows-gnu\" => {\n+                    // We are cross-compiling for Windows. Run tests in wine.\n+                    run_wrapper = vec![\"wine\"];\n+                }\n+                _ => {\n+                    println!(\"Unknown non-native platform\");\n+                }\n+            }\n+        }\n+\n+        // FIXME fix `#[linkage = \"extern_weak\"]` without this\n+        if host_triple.contains(\"darwin\") {\n+            rust_flags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rust_flags);\n+        }\n+\n+        Self {\n+            root_dir,\n+            out_dir,\n+            jit_supported,\n+            rust_flags,\n+            run_wrapper: run_wrapper.iter().map(|s| s.to_string()).collect(),\n+            host_triple,\n+            target_triple,\n+        }\n+    }\n+\n+    pub fn run_testsuite(&self, tests: &[TestCase]) {\n+        for &TestCase { config, func } in tests {\n+            let (tag, testname) = config.split_once('.').unwrap();\n+            let tag = tag.to_uppercase();\n+            let is_jit_test = tag == \"JIT\";\n+\n+            if !config::get_bool(config) || (is_jit_test && !self.jit_supported) {\n+                eprintln!(\"[{tag}] {testname} (skipped)\");\n+                continue;\n+            } else {\n+                eprintln!(\"[{tag}] {testname}\");\n+            }\n+\n+            func(self);\n+        }\n+    }\n+\n+    fn in_dir<'a, I, F>(&self, dir: I, callback: F)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+        F: FnOnce(&TestRunner),\n+    {\n+        let current = env::current_dir().unwrap();\n+        let mut new = current.clone();\n+        for d in dir {\n+            new.push(d);\n+        }\n+\n+        env::set_current_dir(new).unwrap();\n+        callback(self);\n+        env::set_current_dir(current).unwrap();\n+    }\n+\n+    fn rustc_command<I, S>(&self, args: I) -> Command\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        let mut rustc_clif = self.root_dir.clone();\n+        rustc_clif.push(\"build\");\n+        rustc_clif.push(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n+\n+        let mut cmd = Command::new(rustc_clif);\n+        cmd.args(self.rust_flags.split_whitespace());\n+        cmd.arg(\"-L\");\n+        cmd.arg(format!(\"crate={}\", self.out_dir.display()));\n+        cmd.arg(\"--out-dir\");\n+        cmd.arg(format!(\"{}\", self.out_dir.display()));\n+        cmd.arg(\"-Cdebuginfo=2\");\n+        cmd.args(args);\n+        cmd\n+    }\n+\n+    fn run_rustc<I, S>(&self, args: I)\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        spawn_and_wait(self.rustc_command(args));\n+    }\n+\n+    fn run_out_command<'a, I>(&self, name: &str, args: I)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+    {\n+        let mut full_cmd = vec![];\n+\n+        // Prepend the RUN_WRAPPER's\n+        if !self.run_wrapper.is_empty() {\n+            full_cmd.extend(self.run_wrapper.iter().cloned());\n+        }\n+\n+        full_cmd.push({\n+            let mut out_path = self.out_dir.clone();\n+            out_path.push(name);\n+            out_path.to_str().unwrap().to_string()\n+        });\n+\n+        for arg in args.into_iter() {\n+            full_cmd.push(arg.to_string());\n+        }\n+\n+        let mut cmd_iter = full_cmd.into_iter();\n+        let first = cmd_iter.next().unwrap();\n+\n+        let mut cmd = Command::new(first);\n+        cmd.args(cmd_iter);\n+\n+        spawn_and_wait(cmd);\n+    }\n+\n+    fn cargo_command<I, S>(&self, args: I) -> Command\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        let mut cargo_clif = self.root_dir.clone();\n+        cargo_clif.push(\"build\");\n+        cargo_clif.push(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n+\n+        let mut cmd = Command::new(cargo_clif);\n+        cmd.args(args);\n+        cmd.env(\"RUSTFLAGS\", &self.rust_flags);\n+        cmd\n+    }\n+\n+    fn run_cargo<'a, I>(&self, args: I)\n+    where\n+        I: IntoIterator<Item = &'a str>,\n+    {\n+        spawn_and_wait(self.cargo_command(args));\n+    }\n+}"}, {"sha": "bdf8f8ecd9970cb4b71976de33a953101047c808", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,6 +1,8 @@\n+use std::env;\n use std::fs;\n+use std::io::Write;\n use std::path::Path;\n-use std::process::{self, Command};\n+use std::process::{self, Command, Stdio};\n \n #[track_caller]\n pub(crate) fn try_hard_link(src: impl AsRef<Path>, dst: impl AsRef<Path>) {\n@@ -18,6 +20,27 @@ pub(crate) fn spawn_and_wait(mut cmd: Command) {\n     }\n }\n \n+#[track_caller]\n+pub(crate) fn spawn_and_wait_with_input(mut cmd: Command, input: String) -> String {\n+    let mut child = cmd\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn child process\");\n+\n+    let mut stdin = child.stdin.take().expect(\"Failed to open stdin\");\n+    std::thread::spawn(move || {\n+        stdin.write_all(input.as_bytes()).expect(\"Failed to write to stdin\");\n+    });\n+\n+    let output = child.wait_with_output().expect(\"Failed to read stdout\");\n+    if !output.status.success() {\n+        process::exit(1);\n+    }\n+\n+    String::from_utf8(output.stdout).unwrap()\n+}\n+\n pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n     for entry in fs::read_dir(from).unwrap() {\n         let entry = entry.unwrap();\n@@ -33,3 +56,7 @@ pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n         }\n     }\n }\n+\n+pub(crate) fn is_ci() -> bool {\n+    env::var(\"CI\").as_ref().map(|val| &**val) == Ok(\"true\")\n+}"}, {"sha": "62e52bd1958005655adbe4609fa3fbfe05c4b907", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -3,4 +3,4 @@ set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n rm -rf target/ build/ perf.data{,.old} y.bin\n-rm -rf rand/ regex/ simple-raytracer/ portable-simd/\n+rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/"}, {"sha": "2264d301d592003b27f679becdeb32e90d583023", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -15,3 +15,38 @@\n # This option can be changed while the build system is already running for as long as sysroot\n # building hasn't started yet.\n #keep_sysroot\n+\n+\n+# Testsuite\n+#\n+# Each test suite item has a corresponding key here. The default is to run all tests.\n+# Comment any of these lines to skip individual tests.\n+\n+testsuite.no_sysroot\n+build.mini_core\n+build.example\n+jit.mini_core_hello_world\n+aot.mini_core_hello_world\n+\n+testsuite.base_sysroot\n+aot.arbitrary_self_types_pointers_and_wrappers\n+aot.issue_91827_extern_types\n+build.alloc_system\n+aot.alloc_example\n+jit.std_example\n+aot.std_example\n+aot.dst_field_align\n+aot.subslice-patterns-const-eval\n+aot.track-caller-attribute\n+aot.float-minmax-pass\n+aot.mod_bench\n+\n+testsuite.extended_sysroot\n+test.rust-random/rand\n+bench.simple-raytracer\n+test.libcore\n+test.regex-shootout-regex-dna\n+test.regex\n+test.portable-simd\n+\n+testsuite.abi-checker"}, {"sha": "50261c193973932d85be96140e1359129e8e6641", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -94,7 +94,7 @@ mod platform {\n     struct Header(*mut u8);\n     const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n+        &mut *(ptr as *mut Header).sub(1)\n     }\n     unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n         let aligned = ptr.add(align - (ptr as usize & (align - 1)));"}, {"sha": "42f8aa50ba1a99d73f84d9de07eb550d1c778637", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -535,7 +535,7 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, alloc: ()) {\n+unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, _alloc: ()) {\n     libc::free(ptr.pointer.0 as *mut u8);\n }\n \n@@ -575,11 +575,19 @@ pub mod intrinsics {\n }\n \n pub mod libc {\n+    // With the new Universal CRT, msvc has switched to all the printf functions being inline wrapper\n+    // functions. legacy_stdio_definitions.lib which provides the printf wrapper functions as normal\n+    // symbols to link against.\n+    #[cfg_attr(unix, link(name = \"c\"))]\n+    #[cfg_attr(target_env=\"msvc\", link(name=\"legacy_stdio_definitions\"))]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+\n     #[cfg_attr(unix, link(name = \"c\"))]\n     #[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n     extern \"C\" {\n         pub fn puts(s: *const i8) -> i32;\n-        pub fn printf(format: *const i8, ...) -> i32;\n         pub fn malloc(size: usize) -> *mut u8;\n         pub fn free(ptr: *mut u8);\n         pub fn memcpy(dst: *mut u8, src: *const u8, size: usize);"}, {"sha": "e83be3a3df5c4f410f470099f1d623df22a2c76b", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 101, "deletions": 16, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -139,7 +139,7 @@ pub struct bool_11 {\n     field10: bool,\n }\n \n-extern \"C\" fn bool_struct_in_11(arg0: bool_11) {}\n+extern \"C\" fn bool_struct_in_11(_arg0: bool_11) {}\n \n #[allow(unreachable_code)] // FIXME false positive\n fn main() {\n@@ -321,7 +321,7 @@ fn main() {\n     #[cfg(not(any(jit, windows)))]\n     test_tls();\n \n-    #[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]\n+    #[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n     unsafe {\n         global_asm_test();\n     }\n@@ -343,7 +343,7 @@ fn main() {\n }\n }\n \n-#[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]\n+#[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n extern \"C\" {\n     fn global_asm_test();\n }\n@@ -358,6 +358,16 @@ global_asm! {\n     \"\n }\n \n+#[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"darwin\"))]\n+global_asm! {\n+    \"\n+    .global _global_asm_test\n+    _global_asm_test:\n+    // comment that would normally be removed by LLVM\n+    ret\n+    \"\n+}\n+\n #[repr(C)]\n enum c_void {\n     _1,\n@@ -375,6 +385,7 @@ struct pthread_attr_t {\n }\n \n #[link(name = \"pthread\")]\n+#[cfg(unix)]\n extern \"C\" {\n     fn pthread_attr_init(attr: *mut pthread_attr_t) -> c_int;\n \n@@ -391,6 +402,91 @@ extern \"C\" {\n     ) -> c_int;\n }\n \n+type DWORD = u32;\n+type LPDWORD = *mut u32;\n+\n+type LPVOID = *mut c_void;\n+type HANDLE = *mut c_void;\n+\n+#[link(name = \"msvcrt\")]\n+#[cfg(windows)]\n+extern \"C\" {\n+    fn WaitForSingleObject(\n+        hHandle: LPVOID,\n+        dwMilliseconds: DWORD\n+    ) -> DWORD;\n+\n+    fn CreateThread(\n+        lpThreadAttributes: LPVOID, // Technically LPSECURITY_ATTRIBUTES, but we don't use it anyway\n+        dwStackSize: usize,\n+        lpStartAddress: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n+        lpParameter: LPVOID,\n+        dwCreationFlags: DWORD,\n+        lpThreadId: LPDWORD\n+    ) -> HANDLE;\n+}\n+\n+struct Thread {\n+    #[cfg(windows)]\n+    handle: HANDLE,\n+    #[cfg(unix)]\n+    handle: pthread_t,\n+}\n+\n+impl Thread {\n+    unsafe fn create(f: extern \"C\" fn(_: *mut c_void) -> *mut c_void) -> Self {\n+        #[cfg(unix)]\n+        {\n+            let mut attr: pthread_attr_t = zeroed();\n+            let mut thread: pthread_t = 0;\n+\n+            if pthread_attr_init(&mut attr) != 0 {\n+                assert!(false);\n+            }\n+\n+            if pthread_create(&mut thread, &attr, f, 0 as *mut c_void) != 0 {\n+                assert!(false);\n+            }\n+\n+            Thread {\n+                handle: thread,\n+            }\n+        }\n+\n+        #[cfg(windows)]\n+        {\n+            let handle = CreateThread(0 as *mut c_void, 0, f, 0 as *mut c_void, 0, 0 as *mut u32);\n+\n+            if (handle as u64) == 0 {\n+                assert!(false);\n+            }\n+\n+            Thread {\n+                handle,\n+            }\n+        }\n+    }\n+\n+\n+    unsafe fn join(self) {\n+        #[cfg(unix)]\n+        {\n+            let mut res = 0 as *mut c_void;\n+            pthread_join(self.handle, &mut res);\n+        }\n+\n+        #[cfg(windows)]\n+        {\n+            // The INFINITE macro is used to signal operations that do not timeout.\n+            let infinite = 0xffffffff;\n+            assert!(WaitForSingleObject(self.handle, infinite) == 0);\n+        }\n+    }\n+}\n+\n+\n+\n+\n #[thread_local]\n #[cfg(not(jit))]\n static mut TLS: u8 = 42;\n@@ -404,21 +500,10 @@ extern \"C\" fn mutate_tls(_: *mut c_void) -> *mut c_void {\n #[cfg(not(jit))]\n fn test_tls() {\n     unsafe {\n-        let mut attr: pthread_attr_t = zeroed();\n-        let mut thread: pthread_t = 0;\n-\n         assert_eq!(TLS, 42);\n \n-        if pthread_attr_init(&mut attr) != 0 {\n-            assert!(false);\n-        }\n-\n-        if pthread_create(&mut thread, &attr, mutate_tls, 0 as *mut c_void) != 0 {\n-            assert!(false);\n-        }\n-\n-        let mut res = 0 as *mut c_void;\n-        pthread_join(thread, &mut res);\n+        let thread = Thread::create(mutate_tls);\n+        thread.join();\n \n         // TLS of main thread must not have been changed by the other thread.\n         assert_eq!(TLS, 42);"}, {"sha": "526366a7598760b95bb6d107ca3dbf20a8f0f871", "filename": "compiler/rustc_codegen_cranelift/patches/0001-abi-checker-Disable-failing-tests.patch", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,36 @@\n+From 1a315ba225577dbbd1f449d9609f16f984f68708 Mon Sep 17 00:00:00 2001\n+From: Afonso Bordado <afonso360@users.noreply.github.com>\n+Date: Fri, 12 Aug 2022 22:51:58 +0000\n+Subject: [PATCH] Disable abi-checker tests\n+\n+---\n+ src/report.rs | 14 ++++++++++++++\n+ 1 file changed, 14 insertions(+)\n+\n+diff --git a/src/report.rs b/src/report.rs\n+index 7346f5e..8347762 100644\n+--- a/src/report.rs\n++++ b/src/report.rs\n+@@ -45,6 +45,20 @@ pub fn get_test_rules(test: &TestKey, caller: &dyn AbiImpl, callee: &dyn AbiImpl\n+     //\n+     // THIS AREA RESERVED FOR VENDORS TO APPLY PATCHES\n+\n++    // Currently MSVC has some broken ABI issues. Furthermore, they cause\n++    // a STATUS_ACCESS_VIOLATION, so we can't even run them. Ensure that they compile and link.\n++    if cfg!(windows) && (test.test_name == \"bool\" || test.test_name == \"ui128\") {\n++        result.run = Link;\n++        result.check = Pass(Link);\n++    }\n++\n++    // structs is broken in the current release of cranelift for aarch64.\n++    // It has been fixed for cranelift 0.88: https://github.com/bytecodealliance/wasmtime/pull/4634\n++    if cfg!(target_arch = \"aarch64\") && test.test_name == \"structs\" {\n++        result.run = Link;\n++        result.check = Pass(Link);\n++    }\n++\n+     // END OF VENDOR RESERVED AREA\n+     //\n+     //\n+--\n+2.34.1"}, {"sha": "f3cd7ee77e26e34586ac8cc146d0791f960c4520", "filename": "compiler/rustc_codegen_cranelift/patches/0023-sysroot-Ignore-failing-tests.patch", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-sysroot-Ignore-failing-tests.patch?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -46,5 +46,17 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n+diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+index 13b12db..96fe4b9 100644\n+--- a/library/core/tests/atomic.rs\n++++ b/library/core/tests/atomic.rs\n+@@ -185,6 +185,7 @@ fn ptr_bitops() {\n+ }\n+ \n+ #[test]\n++#[cfg_attr(target_arch = \"s390x\", ignore)] // s390x backend doesn't support stack alignment >8 bytes\n+ #[cfg(any(not(target_arch = \"arm\"), target_os = \"linux\"))] // Missing intrinsic in compiler-builtins\n+ fn ptr_bitops_tagging() {\n+     #[repr(align(16))]\n -- \n 2.21.0 (Apple Git-122)"}, {"sha": "14f2746ecb19f0f342a286bf752732d678a94414", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-07-25\"\n+channel = \"nightly-2022-08-24\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "9b5ffa4096049c04b9b2b509e9ec80107a7e1a92", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/4a443dfb8227d407ff3f0542cb6e688833708ba9/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4a443dfb8227d407ff3f0542cb6e688833708ba9/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=4a443dfb8227d407ff3f0542cb6e688833708ba9", "patch": "@@ -1,203 +0,0 @@\n-#!/usr/bin/env bash\n-\n-set -e\n-\n-export CG_CLIF_DISPLAY_CG_TIME=1\n-export CG_CLIF_DISABLE_INCR_CACHE=1\n-\n-export HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n-export TARGET_TRIPLE=${TARGET_TRIPLE:-$HOST_TRIPLE}\n-\n-export RUN_WRAPPER=''\n-\n-case \"$TARGET_TRIPLE\" in\n-   x86_64*)\n-      export JIT_SUPPORTED=1\n-      ;;\n-   *)\n-      export JIT_SUPPORTED=0\n-      ;;\n-esac\n-\n-if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n-   export JIT_SUPPORTED=0\n-   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n-      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-      export RUSTFLAGS='-Clinker=aarch64-linux-gnu-gcc '$RUSTFLAGS\n-      export RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n-   elif [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n-      # We are cross-compiling for Windows. Run tests in wine.\n-      export RUN_WRAPPER='wine'\n-   else\n-      echo \"Unknown non-native platform\"\n-   fi\n-fi\n-\n-# FIXME fix `#[linkage = \"extern_weak\"]` without this\n-if [[ \"$(uname)\" == 'Darwin' ]]; then\n-   export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n-fi\n-\n-MY_RUSTC=\"$(pwd)/build/rustc-clif $RUSTFLAGS -L crate=target/out --out-dir target/out -Cdebuginfo=2\"\n-\n-function no_sysroot_tests() {\n-    echo \"[BUILD] mini_core\"\n-    $MY_RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib --target \"$TARGET_TRIPLE\"\n-\n-    echo \"[BUILD] example\"\n-    $MY_RUSTC example/example.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n-\n-    if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n-        echo \"[JIT] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n-\n-        echo \"[JIT-lazy] mini_core_hello_world\"\n-        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n-    else\n-        echo \"[JIT] mini_core_hello_world (skipped)\"\n-    fi\n-\n-    echo \"[AOT] mini_core_hello_world\"\n-    $MY_RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n-    # (echo \"break set -n main\"; echo \"run\"; sleep 1; echo \"si -c 10\"; sleep 1; echo \"frame variable\") | lldb -- ./target/out/mini_core_hello_world abc bcd\n-}\n-\n-function base_sysroot_tests() {\n-    echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n-    $MY_RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n-\n-    echo \"[AOT] issue_91827_extern_types\"\n-    $MY_RUSTC example/issue-91827-extern-types.rs --crate-name issue_91827_extern_types --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/issue_91827_extern_types\n-\n-    echo \"[BUILD] alloc_system\"\n-    $MY_RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n-\n-    echo \"[AOT] alloc_example\"\n-    $MY_RUSTC example/alloc_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/alloc_example\n-\n-    if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n-        echo \"[JIT] std_example\"\n-        $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n-\n-        echo \"[JIT-lazy] std_example\"\n-        $MY_RUSTC -Zunstable-options -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n-    else\n-        echo \"[JIT] std_example (skipped)\"\n-    fi\n-\n-    echo \"[AOT] std_example\"\n-    $MY_RUSTC example/std_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/std_example arg\n-\n-    echo \"[AOT] dst_field_align\"\n-    $MY_RUSTC example/dst-field-align.rs --crate-name dst_field_align --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/dst_field_align\n-\n-    echo \"[AOT] subslice-patterns-const-eval\"\n-    $MY_RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n-\n-    echo \"[AOT] track-caller-attribute\"\n-    $MY_RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/track-caller-attribute\n-\n-    echo \"[AOT] float-minmax-pass\"\n-    $MY_RUSTC example/float-minmax-pass.rs --crate-type bin -Cpanic=abort --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/float-minmax-pass\n-\n-    echo \"[AOT] mod_bench\"\n-    $MY_RUSTC example/mod_bench.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n-    $RUN_WRAPPER ./target/out/mod_bench\n-}\n-\n-function extended_sysroot_tests() {\n-    pushd rand\n-    ../build/cargo-clif clean\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[TEST] rust-random/rand\"\n-        ../build/cargo-clif test --workspace\n-    else\n-        echo \"[AOT] rust-random/rand\"\n-        ../build/cargo-clif build --workspace --target $TARGET_TRIPLE --tests\n-    fi\n-    popd\n-\n-    pushd simple-raytracer\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-        hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"../build/cargo-clif clean\" \\\n-        \"RUSTFLAGS='' cargo build\" \\\n-        \"../build/cargo-clif build\"\n-\n-        echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-        cp ./target/debug/main ./raytracer_cg_clif\n-        hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_clif\n-    else\n-        ../build/cargo-clif clean\n-        echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n-        echo \"[COMPILE] ebobby/simple-raytracer\"\n-        ../build/cargo-clif build --target $TARGET_TRIPLE\n-        echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n-    fi\n-    popd\n-\n-    pushd build_sysroot/sysroot_src/library/core/tests\n-    echo \"[TEST] libcore\"\n-    ../../../../../build/cargo-clif clean\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        ../../../../../build/cargo-clif test\n-    else\n-        ../../../../../build/cargo-clif build --target $TARGET_TRIPLE --tests\n-    fi\n-    popd\n-\n-    pushd regex\n-    echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n-    ../build/cargo-clif clean\n-    export RUSTFLAGS=\"$RUSTFLAGS --cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n-    # Make sure `[codegen mono items] start` doesn't poison the diff\n-    ../build/cargo-clif build --example shootout-regex-dna --target $TARGET_TRIPLE\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        cat examples/regexdna-input.txt \\\n-            | ../build/cargo-clif run --example shootout-regex-dna --target $TARGET_TRIPLE \\\n-            | grep -v \"Spawned thread\" > res.txt\n-        diff -u res.txt examples/regexdna-output.txt\n-    fi\n-\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        echo \"[TEST] rust-lang/regex tests\"\n-        ../build/cargo-clif test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n-    else\n-        echo \"[AOT] rust-lang/regex tests\"\n-        ../build/cargo-clif build --tests --target $TARGET_TRIPLE\n-    fi\n-    popd\n-\n-    pushd portable-simd\n-    echo \"[TEST] rust-lang/portable-simd\"\n-    ../build/cargo-clif clean\n-    ../build/cargo-clif build --all-targets --target $TARGET_TRIPLE\n-    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-        ../build/cargo-clif test -q\n-    fi\n-    popd\n-}\n-\n-case \"$1\" in\n-    \"no_sysroot\")\n-        no_sysroot_tests\n-        ;;\n-    \"base_sysroot\")\n-        base_sysroot_tests\n-        ;;\n-    \"extended_sysroot\")\n-        extended_sysroot_tests\n-        ;;\n-    *)\n-        echo \"unknown test suite\"\n-        ;;\n-esac"}, {"sha": "7f4619b5c940b12f3701ca2aebba46e92808a163", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -24,7 +24,7 @@ pub(super) fn add_arg_comment<'tcx>(\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n     params: &[Value],\n-    arg_abi_mode: PassMode,\n+    arg_abi_mode: &PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n     if !fx.clif_comments.enabled() {"}, {"sha": "96e25d3a8d4c9423ba85eea5de2006e4db2a6cd4", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -23,7 +23,7 @@ fn reg_to_abi_param(reg: Reg) -> AbiParam {\n         (RegKind::Integer, 9..=16) => types::I128,\n         (RegKind::Float, 4) => types::F32,\n         (RegKind::Float, 8) => types::F64,\n-        (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+        (RegKind::Vector, size) => types::I8.by(u32::try_from(size).unwrap()).unwrap(),\n         _ => unreachable!(\"{:?}\", reg),\n     };\n     AbiParam::new(clif_ty)\n@@ -38,7 +38,7 @@ fn apply_arg_attrs_to_abi_param(mut param: AbiParam, arg_attrs: ArgAttributes) -\n     param\n }\n \n-fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+fn cast_target_to_abi_params(cast: &CastTarget) -> SmallVec<[AbiParam; 2]> {\n     let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n         (0, 0)\n     } else {\n@@ -100,7 +100,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n+            PassMode::Cast(ref cast, pad_i32) => {\n+                assert!(!pad_i32, \"padding support not yet implemented\");\n+                cast_target_to_abi_params(cast)\n+            }\n             PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     // Abi requires aligning struct size to pointer size\n@@ -145,7 +148,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n+            PassMode::Cast(ref cast, _) => {\n+                (None, cast_target_to_abi_params(cast).into_iter().collect())\n+            }\n             PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n                 (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n@@ -160,7 +165,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n pub(super) fn to_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> SmallVec<[Value; 2]> {\n     let (ptr, meta) = arg.force_stack(fx);\n     assert!(meta.is_none());\n@@ -179,12 +184,12 @@ pub(super) fn from_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n     let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n     let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n-    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+    let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n         // specify stack slot alignment.\n@@ -193,7 +198,7 @@ pub(super) fn from_casted_value<'tcx>(\n         // larger alignment than the integer.\n         size: (std::cmp::max(abi_param_size, layout_size) + 15) / 16 * 16,\n     });\n-    let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n+    let ptr = Pointer::stack_slot(stack_slot);\n     let mut offset = 0;\n     let mut block_params_iter = block_params.iter().copied();\n     for param in abi_params {\n@@ -224,7 +229,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             smallvec![a, b]\n         }\n-        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Cast(ref cast, _) => to_casted_value(fx, arg, cast),\n         PassMode::Indirect { .. } => {\n             if is_owned {\n                 match arg.force_stack(fx) {\n@@ -268,7 +273,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n         local,\n         local_field,\n         &block_params,\n-        arg_abi.mode,\n+        &arg_abi.mode,\n         arg_abi.layout,\n     );\n \n@@ -282,7 +287,9 @@ pub(super) fn cvalue_for_param<'tcx>(\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n-        PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n+        PassMode::Cast(ref cast, _) => {\n+            Some(from_casted_value(fx, &block_params, arg_abi.layout, cast))\n+        }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n             Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))"}, {"sha": "aaa1418767a357680ef3b2cd5b2ad8a2d970c015", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -13,7 +13,7 @@ pub(super) fn codegen_return_param<'tcx>(\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(\n@@ -44,7 +44,7 @@ pub(super) fn codegen_return_param<'tcx>(\n         Some(RETURN_PLACE),\n         None,\n         &ret_param,\n-        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        &fx.fn_abi.as_ref().unwrap().ret.mode,\n         fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n@@ -75,7 +75,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n-        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => (None, None),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => (None, None),\n     };\n \n     let call_inst = f(fx, return_ptr);\n@@ -92,7 +92,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n             ret_place\n                 .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let results =\n                 fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n             let result =\n@@ -131,7 +131,7 @@ pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx);\n             let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);"}, {"sha": "0cbb9f3ec2d80512d6277be4ab8463d07932e2bc", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n         })\n         .collect::<IndexVec<Local, SsaKind>>();\n \n-    for bb in fx.mir.basic_blocks().iter() {\n+    for bb in fx.mir.basic_blocks.iter() {\n         for stmt in bb.statements.iter() {\n             match &stmt.kind {\n                 Assign(place_and_rval) => match &place_and_rval.1 {"}, {"sha": "c412e451a033e9619f2630e5362b5e0c12b4e08c", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 116, "deletions": 122, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -6,21 +6,43 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n-use indexmap::IndexSet;\n-\n use crate::constant::ConstantCx;\n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n use crate::pretty_clif::CommentWriter;\n \n-pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+pub(crate) struct CodegenedFunction {\n+    symbol_name: String,\n+    func_id: FuncId,\n+    func: Function,\n+    clif_comments: CommentWriter,\n+    func_debug_cx: Option<FunctionDebugContext>,\n+}\n+\n+#[cfg_attr(not(feature = \"jit\"), allow(dead_code))]\n+pub(crate) fn codegen_and_compile_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n+    cached_context: &mut Context,\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) {\n-    let tcx = cx.tcx;\n-\n     let _inst_guard =\n         crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));\n+\n+    let cached_func = std::mem::replace(&mut cached_context.func, Function::new());\n+    let codegened_func = codegen_fn(tcx, cx, cached_func, module, instance);\n+\n+    compile_fn(cx, cached_context, module, codegened_func);\n+}\n+\n+pub(crate) fn codegen_fn<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut crate::CodegenCx,\n+    cached_func: Function,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) -> CodegenedFunction {\n     debug_assert!(!instance.substs.needs_infer());\n \n     let mir = tcx.instance_mir(instance.def);\n@@ -34,15 +56,14 @@ pub(crate) fn codegen_fn<'tcx>(\n     });\n \n     // Declare function\n-    let symbol_name = tcx.symbol_name(instance);\n+    let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let sig = get_function_sig(tcx, module.isa().triple(), instance);\n-    let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n-\n-    cx.cached_context.clear();\n+    let func_id = module.declare_function(&symbol_name, Linkage::Local, &sig).unwrap();\n \n     // Make the FunctionBuilder\n     let mut func_ctx = FunctionBuilderContext::new();\n-    let mut func = std::mem::replace(&mut cx.cached_context.func, Function::new());\n+    let mut func = cached_func;\n+    func.clear();\n     func.name = ExternalName::user(0, func_id.as_u32());\n     func.signature = sig;\n     func.collect_debug_info();\n@@ -52,20 +73,27 @@ pub(crate) fn codegen_fn<'tcx>(\n     // Predefine blocks\n     let start_block = bcx.create_block();\n     let block_map: IndexVec<BasicBlock, Block> =\n-        (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n+        (0..mir.basic_blocks.len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n     let target_config = module.target_config();\n     let pointer_type = target_config.pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n+    let func_debug_cx = if let Some(debug_context) = &mut cx.debug_context {\n+        Some(debug_context.define_function(tcx, &symbol_name, mir.span))\n+    } else {\n+        None\n+    };\n+\n     let mut fx = FunctionCx {\n         cx,\n         module,\n         tcx,\n         target_config,\n         pointer_type,\n         constants_cx: ConstantCx::new(),\n+        func_debug_cx,\n \n         instance,\n         symbol_name,\n@@ -78,81 +106,48 @@ pub(crate) fn codegen_fn<'tcx>(\n         caller_location: None, // set by `codegen_fn_prelude`\n \n         clif_comments,\n-        source_info_set: indexmap::IndexSet::new(),\n+        last_source_file: None,\n         next_ssa_var: 0,\n     };\n \n-    let arg_uninhabited = fx\n-        .mir\n-        .args_iter()\n-        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n-\n-    if !crate::constant::check_constants(&mut fx) {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n-        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        crate::trap::trap_unreachable(&mut fx, \"compilation should have been aborted\");\n-    } else if arg_uninhabited {\n-        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n-        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n-        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-    } else {\n-        tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess\n-                .time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n-            codegen_fn_content(&mut fx);\n-        });\n-    }\n+    tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n-    let instance = fx.instance;\n+    let symbol_name = fx.symbol_name;\n     let clif_comments = fx.clif_comments;\n-    let source_info_set = fx.source_info_set;\n-    let local_map = fx.local_map;\n+    let func_debug_cx = fx.func_debug_cx;\n \n     fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"unopt\",\n-        module.isa(),\n-        instance,\n-        &func,\n-        &clif_comments,\n-    );\n+    if cx.should_write_ir {\n+        crate::pretty_clif::write_clif_file(\n+            tcx.output_filenames(()),\n+            &symbol_name,\n+            \"unopt\",\n+            module.isa(),\n+            &func,\n+            &clif_comments,\n+        );\n+    }\n \n     // Verify function\n     verify_func(tcx, &clif_comments, &func);\n \n-    compile_fn(\n-        cx,\n-        module,\n-        instance,\n-        symbol_name.name,\n-        func_id,\n-        func,\n-        clif_comments,\n-        source_info_set,\n-        local_map,\n-    );\n+    CodegenedFunction { symbol_name, func_id, func, clif_comments, func_debug_cx }\n }\n \n-fn compile_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx>,\n+pub(crate) fn compile_fn(\n+    cx: &mut crate::CodegenCx,\n+    cached_context: &mut Context,\n     module: &mut dyn Module,\n-    instance: Instance<'tcx>,\n-    symbol_name: &str,\n-    func_id: FuncId,\n-    func: Function,\n-    mut clif_comments: CommentWriter,\n-    source_info_set: IndexSet<SourceInfo>,\n-    local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n+    codegened_func: CodegenedFunction,\n ) {\n-    let tcx = cx.tcx;\n+    let clif_comments = codegened_func.clif_comments;\n \n     // Store function in context\n-    let context = &mut cx.cached_context;\n+    let context = cached_context;\n     context.clear();\n-    context.func = func;\n+    context.func = codegened_func.func;\n \n     // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n     // instruction, which doesn't have an encoding.\n@@ -164,17 +159,6 @@ fn compile_fn<'tcx>(\n     // invalidate it when it would change.\n     context.domtree.clear();\n \n-    // Perform rust specific optimizations\n-    tcx.sess.time(\"optimize clif ir\", || {\n-        crate::optimize::optimize_function(\n-            tcx,\n-            module.isa(),\n-            instance,\n-            context,\n-            &mut clif_comments,\n-        );\n-    });\n-\n     #[cfg(any())] // This is never true\n     let _clif_guard = {\n         use std::fmt::Write;\n@@ -203,46 +187,44 @@ fn compile_fn<'tcx>(\n     };\n \n     // Define function\n-    tcx.sess.time(\"define function\", || {\n-        context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n-        module.define_function(func_id, context).unwrap();\n+    cx.profiler.verbose_generic_activity(\"define function\").run(|| {\n+        context.want_disasm = cx.should_write_ir;\n+        module.define_function(codegened_func.func_id, context).unwrap();\n     });\n \n-    // Write optimized function to file for debugging\n-    crate::pretty_clif::write_clif_file(\n-        tcx,\n-        \"opt\",\n-        module.isa(),\n-        instance,\n-        &context.func,\n-        &clif_comments,\n-    );\n+    if cx.should_write_ir {\n+        // Write optimized function to file for debugging\n+        crate::pretty_clif::write_clif_file(\n+            &cx.output_filenames,\n+            &codegened_func.symbol_name,\n+            \"opt\",\n+            module.isa(),\n+            &context.func,\n+            &clif_comments,\n+        );\n \n-    if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n-        crate::pretty_clif::write_ir_file(\n-            tcx,\n-            || format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n-            |file| file.write_all(disasm.as_bytes()),\n-        )\n+        if let Some(disasm) = &context.compiled_code().unwrap().disasm {\n+            crate::pretty_clif::write_ir_file(\n+                &cx.output_filenames,\n+                &format!(\"{}.vcode\", codegened_func.symbol_name),\n+                |file| file.write_all(disasm.as_bytes()),\n+            )\n+        }\n     }\n \n     // Define debuginfo for function\n     let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n-    tcx.sess.time(\"generate debug info\", || {\n+    cx.profiler.verbose_generic_activity(\"generate debug info\").run(|| {\n         if let Some(debug_context) = debug_context {\n-            debug_context.define_function(\n-                instance,\n-                func_id,\n-                symbol_name,\n-                isa,\n+            codegened_func.func_debug_cx.unwrap().finalize(\n+                debug_context,\n+                codegened_func.func_id,\n                 context,\n-                &source_info_set,\n-                local_map,\n             );\n         }\n-        unwind_context.add_function(func_id, &context, isa);\n+        unwind_context.add_function(codegened_func.func_id, &context, isa);\n     });\n }\n \n@@ -268,8 +250,28 @@ pub(crate) fn verify_func(\n     });\n }\n \n-fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n-    for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n+fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n+    if !crate::constant::check_constants(fx) {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        // compilation should have been aborted\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        return;\n+    }\n+\n+    let arg_uninhabited = fx\n+        .mir\n+        .args_iter()\n+        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n+    if arg_uninhabited {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        return;\n+    }\n+    fx.tcx.sess.time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(fx, start_block));\n+\n+    for (bb, bb_data) in fx.mir.basic_blocks.iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n \n@@ -457,17 +459,8 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                     template,\n                     operands,\n                     *options,\n+                    *destination,\n                 );\n-\n-                match *destination {\n-                    Some(destination) => {\n-                        let destination_block = fx.get_block(destination);\n-                        fx.bcx.ins().jump(destination_block, &[]);\n-                    }\n-                    None => {\n-                        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-                    }\n-                }\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort => {\n                 // FIXME implement unwinding\n@@ -711,9 +704,7 @@ fn codegen_stmt<'tcx>(\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n                     let value = place.to_cvalue(fx);\n-                    let discr =\n-                        crate::discriminant::codegen_get_discriminant(fx, value, dest_layout);\n-                    lval.write_cvalue(fx, discr);\n+                    crate::discriminant::codegen_get_discriminant(fx, lval, value, dest_layout);\n                 }\n                 Rvalue::Repeat(ref operand, times) => {\n                     let operand = codegen_operand(fx, operand);\n@@ -934,8 +925,11 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n     args: &[Value],\n     span: Span,\n ) {\n-    let def_id =\n-        fx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n+    let def_id = fx\n+        .tcx\n+        .lang_items()\n+        .require(lang_item)\n+        .unwrap_or_else(|e| fx.tcx.sess.span_fatal(span, e.to_string()));\n \n     let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n     let symbol_name = fx.tcx.symbol_name(instance).name;"}, {"sha": "589594465783e1611c688cd17f5c82325ae9576f", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,14 +1,18 @@\n use cranelift_codegen::isa::TargetFrontendConfig;\n+use gimli::write::FileId;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n-use rustc_middle::ty::SymbolName;\n+use rustc_span::SourceFile;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n use crate::constant::ConstantCx;\n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -74,7 +78,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n                 _ => unreachable!(),\n             };\n \n-            match scalar_to_clif_type(tcx, element).by(u16::try_from(count).unwrap()) {\n+            match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n                 // Cranelift currently only implements icmp for 128bit vectors.\n                 Some(vector_ty) if vector_ty.bits() == 128 => vector_ty,\n                 _ => return None,\n@@ -232,15 +236,16 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n }\n \n pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n+    pub(crate) cx: &'clif mut crate::CodegenCx,\n     pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) target_config: TargetFrontendConfig, // Cached from module\n     pub(crate) pointer_type: Type,                  // Cached from module\n     pub(crate) constants_cx: ConstantCx,\n+    pub(crate) func_debug_cx: Option<FunctionDebugContext>,\n \n     pub(crate) instance: Instance<'tcx>,\n-    pub(crate) symbol_name: SymbolName<'tcx>,\n+    pub(crate) symbol_name: String,\n     pub(crate) mir: &'tcx Body<'tcx>,\n     pub(crate) fn_abi: Option<&'tcx FnAbi<'tcx, Ty<'tcx>>>,\n \n@@ -252,7 +257,11 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) caller_location: Option<CValue<'tcx>>,\n \n     pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n-    pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n+\n+    /// Last accessed source file and it's debuginfo file id.\n+    ///\n+    /// For optimization purposes only\n+    pub(crate) last_source_file: Option<(Lrc<SourceFile>, FileId)>,\n \n     /// This should only be accessed by `CPlace::new_var`.\n     pub(crate) next_ssa_var: u32,\n@@ -336,8 +345,31 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     }\n \n     pub(crate) fn set_debug_loc(&mut self, source_info: mir::SourceInfo) {\n-        let (index, _) = self.source_info_set.insert_full(source_info);\n-        self.bcx.set_srcloc(SourceLoc::new(index as u32));\n+        if let Some(debug_context) = &mut self.cx.debug_context {\n+            let (file, line, column) =\n+                DebugContext::get_span_loc(self.tcx, self.mir.span, source_info.span);\n+\n+            // add_source_file is very slow.\n+            // Optimize for the common case of the current file not being changed.\n+            let mut cached_file_id = None;\n+            if let Some((ref last_source_file, last_file_id)) = self.last_source_file {\n+                // If the allocations are not equal, the files may still be equal, but that\n+                // doesn't matter, as this is just an optimization.\n+                if rustc_data_structures::sync::Lrc::ptr_eq(last_source_file, &file) {\n+                    cached_file_id = Some(last_file_id);\n+                }\n+            }\n+\n+            let file_id = if let Some(file_id) = cached_file_id {\n+                file_id\n+            } else {\n+                debug_context.add_source_file(&file)\n+            };\n+\n+            let source_loc =\n+                self.func_debug_cx.as_mut().unwrap().add_dbg_loc(file_id, line, column);\n+            self.bcx.set_srcloc(source_loc);\n+        }\n     }\n \n     // Note: must be kept in sync with get_caller_location from cg_ssa"}, {"sha": "dfde97920461e21de9d6cfcc40581d5eda55234e", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,168 @@\n+use std::sync::{Arc, Condvar, Mutex};\n+\n+use rustc_session::Session;\n+\n+use jobserver::HelperThread;\n+\n+// FIXME don't panic when a worker thread panics\n+\n+pub(super) struct ConcurrencyLimiter {\n+    helper_thread: Option<HelperThread>,\n+    state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n+    available_token_condvar: Arc<Condvar>,\n+}\n+\n+impl ConcurrencyLimiter {\n+    pub(super) fn new(sess: &Session, pending_jobs: usize) -> Self {\n+        let state = Arc::new(Mutex::new(state::ConcurrencyLimiterState::new(pending_jobs)));\n+        let available_token_condvar = Arc::new(Condvar::new());\n+\n+        let state_helper = state.clone();\n+        let available_token_condvar_helper = available_token_condvar.clone();\n+        let helper_thread = sess\n+            .jobserver\n+            .clone()\n+            .into_helper_thread(move |token| {\n+                let mut state = state_helper.lock().unwrap();\n+                state.add_new_token(token.unwrap());\n+                available_token_condvar_helper.notify_one();\n+            })\n+            .unwrap();\n+        ConcurrencyLimiter {\n+            helper_thread: Some(helper_thread),\n+            state,\n+            available_token_condvar: Arc::new(Condvar::new()),\n+        }\n+    }\n+\n+    pub(super) fn acquire(&mut self) -> ConcurrencyLimiterToken {\n+        let mut state = self.state.lock().unwrap();\n+        loop {\n+            state.assert_invariants();\n+\n+            if state.try_start_job() {\n+                return ConcurrencyLimiterToken {\n+                    state: self.state.clone(),\n+                    available_token_condvar: self.available_token_condvar.clone(),\n+                };\n+            }\n+\n+            self.helper_thread.as_mut().unwrap().request_token();\n+            state = self.available_token_condvar.wait(state).unwrap();\n+        }\n+    }\n+\n+    pub(super) fn job_already_done(&mut self) {\n+        let mut state = self.state.lock().unwrap();\n+        state.job_already_done();\n+    }\n+}\n+\n+impl Drop for ConcurrencyLimiter {\n+    fn drop(&mut self) {\n+        //\n+        self.helper_thread.take();\n+\n+        // Assert that all jobs have finished\n+        let state = Mutex::get_mut(Arc::get_mut(&mut self.state).unwrap()).unwrap();\n+        state.assert_done();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) struct ConcurrencyLimiterToken {\n+    state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n+    available_token_condvar: Arc<Condvar>,\n+}\n+\n+impl Drop for ConcurrencyLimiterToken {\n+    fn drop(&mut self) {\n+        let mut state = self.state.lock().unwrap();\n+        state.job_finished();\n+        self.available_token_condvar.notify_one();\n+    }\n+}\n+\n+mod state {\n+    use jobserver::Acquired;\n+\n+    #[derive(Debug)]\n+    pub(super) struct ConcurrencyLimiterState {\n+        pending_jobs: usize,\n+        active_jobs: usize,\n+\n+        // None is used to represent the implicit token, Some to represent explicit tokens\n+        tokens: Vec<Option<Acquired>>,\n+    }\n+\n+    impl ConcurrencyLimiterState {\n+        pub(super) fn new(pending_jobs: usize) -> Self {\n+            ConcurrencyLimiterState { pending_jobs, active_jobs: 0, tokens: vec![None] }\n+        }\n+\n+        pub(super) fn assert_invariants(&self) {\n+            // There must be no excess active jobs\n+            assert!(self.active_jobs <= self.pending_jobs);\n+\n+            // There may not be more active jobs than there are tokens\n+            assert!(self.active_jobs <= self.tokens.len());\n+        }\n+\n+        pub(super) fn assert_done(&self) {\n+            assert_eq!(self.pending_jobs, 0);\n+            assert_eq!(self.active_jobs, 0);\n+        }\n+\n+        pub(super) fn add_new_token(&mut self, token: Acquired) {\n+            self.tokens.push(Some(token));\n+            self.drop_excess_capacity();\n+        }\n+\n+        pub(super) fn try_start_job(&mut self) -> bool {\n+            if self.active_jobs < self.tokens.len() {\n+                // Using existing token\n+                self.job_started();\n+                return true;\n+            }\n+\n+            false\n+        }\n+\n+        pub(super) fn job_started(&mut self) {\n+            self.assert_invariants();\n+            self.active_jobs += 1;\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        pub(super) fn job_finished(&mut self) {\n+            self.assert_invariants();\n+            self.pending_jobs -= 1;\n+            self.active_jobs -= 1;\n+            self.assert_invariants();\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        pub(super) fn job_already_done(&mut self) {\n+            self.assert_invariants();\n+            self.pending_jobs -= 1;\n+            self.assert_invariants();\n+            self.drop_excess_capacity();\n+            self.assert_invariants();\n+        }\n+\n+        fn drop_excess_capacity(&mut self) {\n+            self.assert_invariants();\n+\n+            // Drop all tokens that can never be used anymore\n+            self.tokens.truncate(std::cmp::max(self.pending_jobs, 1));\n+\n+            // Keep some excess tokens to satisfy requests faster\n+            const MAX_EXTRA_CAPACITY: usize = 2;\n+            self.tokens.truncate(std::cmp::max(self.active_jobs + MAX_EXTRA_CAPACITY, 1));\n+\n+            self.assert_invariants();\n+        }\n+    }\n+}"}, {"sha": "cb5d73a7e0ba9bd277c6318a70da19d284360bb4", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -430,7 +430,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n         let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n-        for &(offset, alloc_id) in alloc.relocations().iter() {\n+        for &(offset, alloc_id) in alloc.provenance().iter() {\n             let addend = {\n                 let endianness = tcx.data_layout.endian;\n                 let offset = offset.bytes() as usize;\n@@ -505,7 +505,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                 return None;\n             }\n             let mut computed_const_val = None;\n-            for bb_data in fx.mir.basic_blocks() {\n+            for bb_data in fx.mir.basic_blocks.iter() {\n                 for stmt in &bb_data.statements {\n                     match &stmt.kind {\n                         StatementKind::Assign(local_and_rvalue) if &local_and_rvalue.0 == place => {"}, {"sha": "9583cd2ec60f8a5bcf3bb3d4b0b74ea806f97614", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -9,7 +9,7 @@ use gimli::{RunTimeEndian, SectionId};\n use super::object::WriteDebugInfo;\n use super::DebugContext;\n \n-impl DebugContext<'_> {\n+impl DebugContext {\n     pub(crate) fn emit(&mut self, product: &mut ObjectProduct) {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();"}, {"sha": "3ad0c420eaf0b010b313e4dae0a785778eb21f0f", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 93, "deletions": 120, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -3,8 +3,10 @@\n use std::ffi::OsStr;\n use std::path::{Component, Path};\n \n+use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_span::{\n     FileName, Pos, SourceFile, SourceFileAndLine, SourceFileHash, SourceFileHashAlgorithm,\n };\n@@ -14,7 +16,6 @@ use cranelift_codegen::MachSrcLoc;\n \n use gimli::write::{\n     Address, AttributeValue, FileId, FileInfo, LineProgram, LineString, LineStringTable,\n-    UnitEntryId,\n };\n \n // OPTIMIZATION: It is cheaper to do this in one pass than using `.parent()` and `.file_name()`.\n@@ -47,9 +48,9 @@ fn osstr_as_utf8_bytes(path: &OsStr) -> &[u8] {\n     }\n }\n \n-pub(crate) const MD5_LEN: usize = 16;\n+const MD5_LEN: usize = 16;\n \n-pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n+fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n@@ -59,160 +60,132 @@ pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     }\n }\n \n-fn line_program_add_file(\n-    line_program: &mut LineProgram,\n-    line_strings: &mut LineStringTable,\n-    file: &SourceFile,\n-) -> FileId {\n-    match &file.name {\n-        FileName::Real(path) => {\n-            let (dir_path, file_name) = split_path_dir_and_file(path.remapped_path_if_available());\n-            let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n-            let file_name = osstr_as_utf8_bytes(file_name);\n-\n-            let dir_id = if !dir_name.is_empty() {\n-                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n-                line_program.add_directory(dir_name)\n-            } else {\n-                line_program.default_directory()\n-            };\n-            let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+impl DebugContext {\n+    pub(crate) fn get_span_loc(\n+        tcx: TyCtxt<'_>,\n+        function_span: Span,\n+        span: Span,\n+    ) -> (Lrc<SourceFile>, u64, u64) {\n+        // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n+            span\n+        } else {\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            // We also stop at the function body level because no line stepping can occur\n+            // at the level above that.\n+            rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        };\n \n-            let info = make_file_info(file.src_hash);\n+        match tcx.sess.source_map().lookup_line(span.lo()) {\n+            Ok(SourceFileAndLine { sf: file, line }) => {\n+                let line_pos = file.line_begin_pos(span.lo());\n \n-            line_program.file_has_md5 &= info.is_some();\n-            line_program.add_file(file_name, dir_id, info)\n+                (\n+                    file,\n+                    u64::try_from(line).unwrap() + 1,\n+                    u64::from((span.lo() - line_pos).to_u32()) + 1,\n+                )\n+            }\n+            Err(file) => (file, 0, 0),\n         }\n-        // FIXME give more appropriate file names\n-        filename => {\n-            let dir_id = line_program.default_directory();\n-            let dummy_file_name = LineString::new(\n-                filename.prefer_remapped().to_string().into_bytes(),\n-                line_program.encoding(),\n-                line_strings,\n-            );\n-            line_program.add_file(dummy_file_name, dir_id, None)\n+    }\n+\n+    pub(crate) fn add_source_file(&mut self, source_file: &SourceFile) -> FileId {\n+        let line_program: &mut LineProgram = &mut self.dwarf.unit.line_program;\n+        let line_strings: &mut LineStringTable = &mut self.dwarf.line_strings;\n+\n+        match &source_file.name {\n+            FileName::Real(path) => {\n+                let (dir_path, file_name) =\n+                    split_path_dir_and_file(path.remapped_path_if_available());\n+                let dir_name = osstr_as_utf8_bytes(dir_path.as_os_str());\n+                let file_name = osstr_as_utf8_bytes(file_name);\n+\n+                let dir_id = if !dir_name.is_empty() {\n+                    let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n+                    line_program.add_directory(dir_name)\n+                } else {\n+                    line_program.default_directory()\n+                };\n+                let file_name = LineString::new(file_name, line_program.encoding(), line_strings);\n+\n+                let info = make_file_info(source_file.src_hash);\n+\n+                line_program.file_has_md5 &= info.is_some();\n+                line_program.add_file(file_name, dir_id, info)\n+            }\n+            // FIXME give more appropriate file names\n+            filename => {\n+                let dir_id = line_program.default_directory();\n+                let dummy_file_name = LineString::new(\n+                    filename.prefer_remapped().to_string().into_bytes(),\n+                    line_program.encoding(),\n+                    line_strings,\n+                );\n+                line_program.add_file(dummy_file_name, dir_id, None)\n+            }\n         }\n     }\n }\n \n-impl<'tcx> DebugContext<'tcx> {\n-    pub(super) fn emit_location(&mut self, entry_id: UnitEntryId, span: Span) {\n-        let loc = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n-\n-        let file_id = line_program_add_file(\n-            &mut self.dwarf.unit.line_program,\n-            &mut self.dwarf.line_strings,\n-            &loc.file,\n-        );\n-\n-        let entry = self.dwarf.unit.get_mut(entry_id);\n-\n-        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n-        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n-        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n+impl FunctionDebugContext {\n+    pub(crate) fn add_dbg_loc(&mut self, file_id: FileId, line: u64, column: u64) -> SourceLoc {\n+        let (index, _) = self.source_loc_set.insert_full((file_id, line, column));\n+        SourceLoc::new(u32::try_from(index).unwrap())\n     }\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n+        debug_context: &mut DebugContext,\n         symbol: usize,\n-        entry_id: UnitEntryId,\n         context: &Context,\n-        function_span: Span,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n     ) -> CodeOffset {\n-        let tcx = self.tcx;\n-        let line_program = &mut self.dwarf.unit.line_program;\n-\n-        let line_strings = &mut self.dwarf.line_strings;\n-        let mut last_span = None;\n-        let mut last_file = None;\n-        let mut create_row_for_span = |line_program: &mut LineProgram, span: Span| {\n-            if let Some(last_span) = last_span {\n-                if span == last_span {\n-                    line_program.generate_row();\n-                    return;\n-                }\n-            }\n-            last_span = Some(span);\n-\n-            // Based on https://github.com/rust-lang/rust/blob/e369d87b015a84653343032833d65d0545fd3f26/src/librustc_codegen_ssa/mir/mod.rs#L116-L131\n-            // In order to have a good line stepping behavior in debugger, we overwrite debug\n-            // locations of macro expansions with that of the outermost expansion site\n-            // (unless the crate is being compiled with `-Z debug-macros`).\n-            let span = if !span.from_expansion() || tcx.sess.opts.unstable_opts.debug_macros {\n-                span\n-            } else {\n-                // Walk up the macro expansion chain until we reach a non-expanded span.\n-                // We also stop at the function body level because no line stepping can occur\n-                // at the level above that.\n-                rustc_span::hygiene::walk_chain(span, function_span.ctxt())\n+        let create_row_for_span =\n+            |debug_context: &mut DebugContext, source_loc: (FileId, u64, u64)| {\n+                let (file_id, line, col) = source_loc;\n+\n+                debug_context.dwarf.unit.line_program.row().file = file_id;\n+                debug_context.dwarf.unit.line_program.row().line = line;\n+                debug_context.dwarf.unit.line_program.row().column = col;\n+                debug_context.dwarf.unit.line_program.generate_row();\n             };\n \n-            let (file, line, col) = match tcx.sess.source_map().lookup_line(span.lo()) {\n-                Ok(SourceFileAndLine { sf: file, line }) => {\n-                    let line_pos = file.line_begin_pos(span.lo());\n-\n-                    (\n-                        file,\n-                        u64::try_from(line).unwrap() + 1,\n-                        u64::from((span.lo() - line_pos).to_u32()) + 1,\n-                    )\n-                }\n-                Err(file) => (file, 0, 0),\n-            };\n-\n-            // line_program_add_file is very slow.\n-            // Optimize for the common case of the current file not being changed.\n-            let current_file_changed = if let Some(last_file) = &last_file {\n-                // If the allocations are not equal, then the files may still be equal, but that\n-                // is not a problem, as this is just an optimization.\n-                !rustc_data_structures::sync::Lrc::ptr_eq(last_file, &file)\n-            } else {\n-                true\n-            };\n-            if current_file_changed {\n-                let file_id = line_program_add_file(line_program, line_strings, &file);\n-                line_program.row().file = file_id;\n-                last_file = Some(file);\n-            }\n-\n-            line_program.row().line = line;\n-            line_program.row().column = col;\n-            line_program.generate_row();\n-        };\n-\n-        line_program.begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n+        debug_context\n+            .dwarf\n+            .unit\n+            .line_program\n+            .begin_sequence(Some(Address::Symbol { symbol, addend: 0 }));\n \n         let mut func_end = 0;\n \n-        let mcr = context.mach_compile_result.as_ref().unwrap();\n+        let mcr = context.compiled_code().unwrap();\n         for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-            line_program.row().address_offset = u64::from(start);\n+            debug_context.dwarf.unit.line_program.row().address_offset = u64::from(start);\n             if !loc.is_default() {\n-                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                create_row_for_span(line_program, source_info.span);\n+                let source_loc = *self.source_loc_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(debug_context, source_loc);\n             } else {\n-                create_row_for_span(line_program, function_span);\n+                create_row_for_span(debug_context, self.function_source_loc);\n             }\n             func_end = end;\n         }\n \n-        line_program.end_sequence(u64::from(func_end));\n+        debug_context.dwarf.unit.line_program.end_sequence(u64::from(func_end));\n \n         let func_end = mcr.buffer.total_size();\n \n         assert_ne!(func_end, 0);\n \n-        let entry = self.dwarf.unit.get_mut(entry_id);\n+        let entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n-        self.emit_location(entry_id, function_span);\n-\n         func_end\n     }\n }"}, {"sha": "c55db2017ee68c31c53b0a59e12c82b6b72c6c7e", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 44, "deletions": 238, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -7,35 +7,34 @@ mod unwind;\n \n use crate::prelude::*;\n \n-use rustc_index::vec::IndexVec;\n-\n-use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{Endianness, LabelValueLoc, ValueLabel};\n+use cranelift_codegen::ir::Endianness;\n use cranelift_codegen::isa::TargetIsa;\n-use cranelift_codegen::ValueLocRange;\n \n use gimli::write::{\n-    Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n-    LocationList, Range, RangeList, UnitEntryId,\n+    Address, AttributeValue, DwarfUnit, FileId, LineProgram, LineString, Range, RangeList,\n+    UnitEntryId,\n };\n-use gimli::{Encoding, Format, LineEncoding, RunTimeEndian, X86_64};\n+use gimli::{Encoding, Format, LineEncoding, RunTimeEndian};\n+use indexmap::IndexSet;\n \n pub(crate) use emit::{DebugReloc, DebugRelocName};\n pub(crate) use unwind::UnwindContext;\n \n-pub(crate) struct DebugContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n+pub(crate) struct DebugContext {\n     endian: RunTimeEndian,\n \n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n+}\n \n-    types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n+pub(crate) struct FunctionDebugContext {\n+    entry_id: UnitEntryId,\n+    function_source_loc: (FileId, u64, u64),\n+    source_loc_set: indexmap::IndexSet<(FileId, u64, u64)>,\n }\n \n-impl<'tcx> DebugContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n+impl DebugContext {\n+    pub(crate) fn new(tcx: TyCtxt<'_>, isa: &dyn TargetIsa) -> Self {\n         let encoding = Encoding {\n             format: Format::Dwarf32,\n             // FIXME this should be configurable\n@@ -101,127 +100,18 @@ impl<'tcx> DebugContext<'tcx> {\n             root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n-        DebugContext {\n-            tcx,\n-\n-            endian,\n-\n-            dwarf,\n-            unit_range_list: RangeList(Vec::new()),\n-\n-            types: FxHashMap::default(),\n-        }\n-    }\n-\n-    fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n-        if let Some(type_id) = self.types.get(&ty) {\n-            return *type_id;\n-        }\n-\n-        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n-\n-        let primitive = |dwarf: &mut DwarfUnit, ate| {\n-            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n-            let type_entry = dwarf.unit.get_mut(type_id);\n-            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n-            type_id\n-        };\n-\n-        let name = format!(\"{}\", ty);\n-        let layout = self.tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-\n-        let type_id = match ty.kind() {\n-            ty::Bool => primitive(&mut self.dwarf, gimli::DW_ATE_boolean),\n-            ty::Char => primitive(&mut self.dwarf, gimli::DW_ATE_UTF),\n-            ty::Uint(_) => primitive(&mut self.dwarf, gimli::DW_ATE_unsigned),\n-            ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n-            ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n-            ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let pointee = self.dwarf_ty(*pointee_ty);\n-\n-                let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-                //type_entry.set(gimli::DW_AT_mutable, AttributeValue::Flag(mutbl == rustc_hir::Mutability::Mut));\n-                type_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(pointee));\n-\n-                type_id\n-            }\n-            ty::Adt(adt_def, _substs) if adt_def.is_struct() && !layout.is_unsized() => {\n-                let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type);\n-\n-                // Ensure that type is inserted before recursing to avoid duplicates\n-                self.types.insert(ty, type_id);\n-\n-                let variant = adt_def.non_enum_variant();\n-\n-                for (field_idx, field_def) in variant.fields.iter().enumerate() {\n-                    let field_offset = layout.fields.offset(field_idx);\n-                    let field_layout = layout.field(\n-                        &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n-                        field_idx,\n-                    );\n-\n-                    let field_type = self.dwarf_ty(field_layout.ty);\n-\n-                    let field_id = self.dwarf.unit.add(type_id, gimli::DW_TAG_member);\n-                    let field_entry = self.dwarf.unit.get_mut(field_id);\n-\n-                    field_entry.set(\n-                        gimli::DW_AT_name,\n-                        AttributeValue::String(field_def.name.as_str().to_string().into_bytes()),\n-                    );\n-                    field_entry.set(\n-                        gimli::DW_AT_data_member_location,\n-                        AttributeValue::Udata(field_offset.bytes()),\n-                    );\n-                    field_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(field_type));\n-                }\n-\n-                type_id\n-            }\n-            _ => new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type),\n-        };\n-\n-        let type_entry = self.dwarf.unit.get_mut(type_id);\n-\n-        type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n-\n-        self.types.insert(ty, type_id);\n-\n-        type_id\n-    }\n-\n-    fn define_local(&mut self, scope: UnitEntryId, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n-        let dw_ty = self.dwarf_ty(ty);\n-\n-        let var_id = self.dwarf.unit.add(scope, gimli::DW_TAG_variable);\n-        let var_entry = self.dwarf.unit.get_mut(var_id);\n-\n-        var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n-\n-        var_id\n+        DebugContext { endian, dwarf, unit_range_list: RangeList(Vec::new()) }\n     }\n \n     pub(crate) fn define_function(\n         &mut self,\n-        instance: Instance<'tcx>,\n-        func_id: FuncId,\n+        tcx: TyCtxt<'_>,\n         name: &str,\n-        isa: &dyn TargetIsa,\n-        context: &Context,\n-        source_info_set: &indexmap::IndexSet<SourceInfo>,\n-        local_map: IndexVec<mir::Local, CPlace<'tcx>>,\n-    ) {\n-        let symbol = func_id.as_u32() as usize;\n-        let mir = self.tcx.instance_mir(instance.def);\n+        function_span: Span,\n+    ) -> FunctionDebugContext {\n+        let (file, line, column) = DebugContext::get_span_loc(tcx, function_span, function_span);\n+\n+        let file_id = self.add_source_file(&file);\n \n         // FIXME: add to appropriate scope instead of root\n         let scope = self.dwarf.unit.root();\n@@ -233,125 +123,41 @@ impl<'tcx> DebugContext<'tcx> {\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n         entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n-        let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(line));\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(column));\n \n-        self.unit_range_list.0.push(Range::StartLength {\n+        FunctionDebugContext {\n+            entry_id,\n+            function_source_loc: (file_id, line, column),\n+            source_loc_set: IndexSet::new(),\n+        }\n+    }\n+}\n+\n+impl FunctionDebugContext {\n+    pub(crate) fn finalize(\n+        mut self,\n+        debug_context: &mut DebugContext,\n+        func_id: FuncId,\n+        context: &Context,\n+    ) {\n+        let symbol = func_id.as_u32() as usize;\n+\n+        let end = self.create_debug_lines(debug_context, symbol, context);\n+\n+        debug_context.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },\n             length: u64::from(end),\n         });\n \n-        let func_entry = self.dwarf.unit.get_mut(entry_id);\n+        let func_entry = debug_context.dwarf.unit.get_mut(self.entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n         func_entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n-\n-        // FIXME make it more reliable and implement scopes before re-enabling this.\n-        if false {\n-            let value_labels_ranges = std::collections::HashMap::new(); // FIXME\n-\n-            for (local, _local_decl) in mir.local_decls.iter_enumerated() {\n-                let ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    instance.substs,\n-                    ty::ParamEnv::reveal_all(),\n-                    mir.local_decls[local].ty,\n-                );\n-                let var_id = self.define_local(entry_id, format!(\"{:?}\", local), ty);\n-\n-                let location = place_location(\n-                    self,\n-                    isa,\n-                    symbol,\n-                    &local_map,\n-                    &value_labels_ranges,\n-                    Place { local, projection: ty::List::empty() },\n-                );\n-\n-                let var_entry = self.dwarf.unit.get_mut(var_id);\n-                var_entry.set(gimli::DW_AT_location, location);\n-            }\n-        }\n-\n-        // FIXME create locals for all entries in mir.var_debug_info\n-    }\n-}\n-\n-fn place_location<'tcx>(\n-    debug_context: &mut DebugContext<'tcx>,\n-    isa: &dyn TargetIsa,\n-    symbol: usize,\n-    local_map: &IndexVec<mir::Local, CPlace<'tcx>>,\n-    #[allow(rustc::default_hash_types)] value_labels_ranges: &std::collections::HashMap<\n-        ValueLabel,\n-        Vec<ValueLocRange>,\n-    >,\n-    place: Place<'tcx>,\n-) -> AttributeValue {\n-    assert!(place.projection.is_empty()); // FIXME implement them\n-\n-    match local_map[place.local].inner() {\n-        CPlaceInner::Var(_local, var) => {\n-            let value_label = cranelift_codegen::ir::ValueLabel::new(var.index());\n-            if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n-                let loc_list = LocationList(\n-                    value_loc_ranges\n-                        .iter()\n-                        .map(|value_loc_range| Location::StartEnd {\n-                            begin: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.start),\n-                            },\n-                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n-                            data: translate_loc(isa, value_loc_range.loc).unwrap(),\n-                        })\n-                        .collect(),\n-                );\n-                let loc_list_id = debug_context.dwarf.unit.locations.add(loc_list);\n-\n-                AttributeValue::LocationListRef(loc_list_id)\n-            } else {\n-                // FIXME set value labels for unused locals\n-\n-                AttributeValue::Exprloc(Expression::new())\n-            }\n-        }\n-        CPlaceInner::VarPair(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::VarLane(_, _, _) => {\n-            // FIXME implement this\n-\n-            AttributeValue::Exprloc(Expression::new())\n-        }\n-        CPlaceInner::Addr(_, _) => {\n-            // FIXME implement this (used by arguments and returns)\n-\n-            AttributeValue::Exprloc(Expression::new())\n-\n-            // For PointerBase::Stack:\n-            //AttributeValue::Exprloc(translate_loc(ValueLoc::Stack(*stack_slot)).unwrap())\n-        }\n-    }\n-}\n-\n-// Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n-fn translate_loc(isa: &dyn TargetIsa, loc: LabelValueLoc) -> Option<Expression> {\n-    match loc {\n-        LabelValueLoc::Reg(reg) => {\n-            let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n-            let mut expr = Expression::new();\n-            expr.op_reg(gimli::Register(machine_reg));\n-            Some(expr)\n-        }\n-        LabelValueLoc::SPOffset(offset) => {\n-            let mut expr = Expression::new();\n-            expr.op_breg(X86_64::RSP, offset);\n-            Some(expr)\n-        }\n     }\n }"}, {"sha": "e41ae1fbdbac54cd9a58bb80f4d8c9905e1738dc", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -62,16 +62,14 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n \n pub(crate) fn codegen_get_discriminant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    dest: CPlace<'tcx>,\n     value: CValue<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n-) -> CValue<'tcx> {\n+) {\n     let layout = value.layout();\n \n-    if layout.abi == Abi::Uninhabited {\n-        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-        fx.bcx.ins().trapnz(true_, TrapCode::UnreachableCodeReached);\n-        // Return a dummy value\n-        return CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout);\n+    if layout.abi.is_uninhabited() {\n+        return;\n     }\n \n     let (tag_scalar, tag_field, tag_encoding) = match &layout.variants {\n@@ -89,7 +87,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             } else {\n                 ty::ScalarInt::try_from_uint(discr_val, dest_layout.size).unwrap()\n             };\n-            return CValue::const_val(fx, dest_layout, discr_val);\n+            let res = CValue::const_val(fx, dest_layout, discr_val);\n+            dest.write_cvalue(fx, res);\n+            return;\n         }\n         Variants::Multiple { tag, tag_field, tag_encoding, variants: _ } => {\n             (tag, *tag_field, tag_encoding)\n@@ -110,7 +110,8 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 _ => false,\n             };\n             let val = clif_intcast(fx, tag, cast_to, signed);\n-            CValue::by_val(val, dest_layout)\n+            let res = CValue::by_val(val, dest_layout);\n+            dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n@@ -170,7 +171,8 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n \n             let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n             let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n-            CValue::by_val(discr, dest_layout)\n+            let res = CValue::by_val(discr, dest_layout);\n+            dest.write_cvalue(fx, res);\n         }\n     }\n }"}, {"sha": "8eabe1cbcb15030380e0ac333315d3326c765629", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 315, "deletions": 245, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,33 +1,129 @@\n //! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n //! standalone executable.\n \n+use std::fs::File;\n use std::path::PathBuf;\n+use std::sync::Arc;\n+use std::thread::JoinHandle;\n \n-use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::back::metadata::create_compressed_metadata_file;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, CrateInfo, ModuleKind};\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_session::config::{DebugInfo, OutputType};\n+use rustc_session::config::{DebugInfo, OutputFilenames, OutputType};\n use rustc_session::Session;\n \n-use cranelift_codegen::isa::TargetIsa;\n use cranelift_object::{ObjectBuilder, ObjectModule};\n \n+use crate::concurrency_limiter::{ConcurrencyLimiter, ConcurrencyLimiterToken};\n+use crate::global_asm::GlobalAsmConfig;\n use crate::{prelude::*, BackendConfig};\n \n-struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+struct ModuleCodegenResult {\n+    module_regular: CompiledModule,\n+    module_global_asm: Option<CompiledModule>,\n+    existing_work_product: Option<(WorkProductId, WorkProduct)>,\n+}\n+\n+enum OngoingModuleCodegen {\n+    Sync(Result<ModuleCodegenResult, String>),\n+    Async(JoinHandle<Result<ModuleCodegenResult, String>>),\n+}\n \n-impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n+impl<HCX> HashStable<HCX> for OngoingModuleCodegen {\n     fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n         // do nothing\n     }\n }\n \n-fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectModule {\n+pub(crate) struct OngoingCodegen {\n+    modules: Vec<OngoingModuleCodegen>,\n+    allocator_module: Option<CompiledModule>,\n+    metadata_module: Option<CompiledModule>,\n+    metadata: EncodedMetadata,\n+    crate_info: CrateInfo,\n+    concurrency_limiter: ConcurrencyLimiter,\n+}\n+\n+impl OngoingCodegen {\n+    pub(crate) fn join(\n+        self,\n+        sess: &Session,\n+        backend_config: &BackendConfig,\n+    ) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n+        let mut work_products = FxHashMap::default();\n+        let mut modules = vec![];\n+\n+        for module_codegen in self.modules {\n+            let module_codegen_result = match module_codegen {\n+                OngoingModuleCodegen::Sync(module_codegen_result) => module_codegen_result,\n+                OngoingModuleCodegen::Async(join_handle) => match join_handle.join() {\n+                    Ok(module_codegen_result) => module_codegen_result,\n+                    Err(panic) => std::panic::resume_unwind(panic),\n+                },\n+            };\n+\n+            let module_codegen_result = match module_codegen_result {\n+                Ok(module_codegen_result) => module_codegen_result,\n+                Err(err) => sess.fatal(&err),\n+            };\n+            let ModuleCodegenResult { module_regular, module_global_asm, existing_work_product } =\n+                module_codegen_result;\n+\n+            if let Some((work_product_id, work_product)) = existing_work_product {\n+                work_products.insert(work_product_id, work_product);\n+            } else {\n+                let work_product = if backend_config.disable_incr_cache {\n+                    None\n+                } else if let Some(module_global_asm) = &module_global_asm {\n+                    rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+                        sess,\n+                        &module_regular.name,\n+                        &[\n+                            (\"o\", &module_regular.object.as_ref().unwrap()),\n+                            (\"asm.o\", &module_global_asm.object.as_ref().unwrap()),\n+                        ],\n+                    )\n+                } else {\n+                    rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n+                        sess,\n+                        &module_regular.name,\n+                        &[(\"o\", &module_regular.object.as_ref().unwrap())],\n+                    )\n+                };\n+                if let Some((work_product_id, work_product)) = work_product {\n+                    work_products.insert(work_product_id, work_product);\n+                }\n+            }\n+\n+            modules.push(module_regular);\n+            if let Some(module_global_asm) = module_global_asm {\n+                modules.push(module_global_asm);\n+            }\n+        }\n+\n+        drop(self.concurrency_limiter);\n+\n+        (\n+            CodegenResults {\n+                modules,\n+                allocator_module: self.allocator_module,\n+                metadata_module: self.metadata_module,\n+                metadata: self.metadata,\n+                crate_info: self.crate_info,\n+            },\n+            work_products,\n+        )\n+    }\n+}\n+\n+fn make_module(sess: &Session, backend_config: &BackendConfig, name: String) -> ObjectModule {\n+    let isa = crate::build_isa(sess, backend_config);\n+\n     let mut builder =\n         ObjectBuilder::new(isa, name + \".o\", cranelift_module::default_libcall_names()).unwrap();\n     // Unlike cg_llvm, cg_clif defaults to disabling -Zfunction-sections. For cg_llvm binary size\n@@ -37,15 +133,15 @@ fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectM\n     ObjectModule::new(builder)\n }\n \n-fn emit_module(\n-    tcx: TyCtxt<'_>,\n-    backend_config: &BackendConfig,\n+fn emit_cgu(\n+    output_filenames: &OutputFilenames,\n+    prof: &SelfProfilerRef,\n     name: String,\n-    kind: ModuleKind,\n     module: ObjectModule,\n-    debug: Option<DebugContext<'_>>,\n+    debug: Option<DebugContext>,\n     unwind_context: UnwindContext,\n-) -> ModuleCodegenResult {\n+    global_asm_object_file: Option<PathBuf>,\n+) -> Result<ModuleCodegenResult, String> {\n     let mut product = module.finish();\n \n     if let Some(mut debug) = debug {\n@@ -54,144 +150,199 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let tmp_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(&name));\n-    let obj = product.object.write().unwrap();\n+    let module_regular =\n+        emit_module(output_filenames, prof, product.object, ModuleKind::Regular, name.clone())?;\n+\n+    Ok(ModuleCodegenResult {\n+        module_regular,\n+        module_global_asm: global_asm_object_file.map(|global_asm_object_file| CompiledModule {\n+            name: format!(\"{name}.asm\"),\n+            kind: ModuleKind::Regular,\n+            object: Some(global_asm_object_file),\n+            dwarf_object: None,\n+            bytecode: None,\n+        }),\n+        existing_work_product: None,\n+    })\n+}\n \n-    tcx.sess.prof.artifact_size(\"object_file\", name.clone(), obj.len().try_into().unwrap());\n+fn emit_module(\n+    output_filenames: &OutputFilenames,\n+    prof: &SelfProfilerRef,\n+    object: cranelift_object::object::write::Object<'_>,\n+    kind: ModuleKind,\n+    name: String,\n+) -> Result<CompiledModule, String> {\n+    let tmp_file = output_filenames.temp_path(OutputType::Object, Some(&name));\n+    let mut file = match File::create(&tmp_file) {\n+        Ok(file) => file,\n+        Err(err) => return Err(format!(\"error creating object file: {}\", err)),\n+    };\n \n-    if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n+    if let Err(err) = object.write_stream(&mut file) {\n+        return Err(format!(\"error writing object file: {}\", err));\n     }\n \n-    let work_product = if backend_config.disable_incr_cache {\n-        None\n-    } else {\n-        rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n-            tcx.sess,\n-            &name,\n-            &[(\"o\", &tmp_file)],\n-        )\n-    };\n+    prof.artifact_size(\"object_file\", &*name, file.metadata().unwrap().len());\n \n-    ModuleCodegenResult(\n-        CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None },\n-        work_product,\n-    )\n+    Ok(CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None })\n }\n \n fn reuse_workproduct_for_cgu(\n     tcx: TyCtxt<'_>,\n     cgu: &CodegenUnit<'_>,\n-    work_products: &mut FxHashMap<WorkProductId, WorkProduct>,\n-) -> CompiledModule {\n+) -> Result<ModuleCodegenResult, String> {\n     let work_product = cgu.previous_work_product(tcx);\n-    let obj_out = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n-    let source_file = rustc_incremental::in_incr_comp_dir_sess(\n+    let obj_out_regular =\n+        tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu.name().as_str()));\n+    let source_file_regular = rustc_incremental::in_incr_comp_dir_sess(\n         &tcx.sess,\n         &work_product.saved_files.get(\"o\").expect(\"no saved object file in work product\"),\n     );\n-    if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n-        tcx.sess.err(&format!(\n+\n+    if let Err(err) = rustc_fs_util::link_or_copy(&source_file_regular, &obj_out_regular) {\n+        return Err(format!(\n             \"unable to copy {} to {}: {}\",\n-            source_file.display(),\n-            obj_out.display(),\n+            source_file_regular.display(),\n+            obj_out_regular.display(),\n             err\n         ));\n     }\n+    let obj_out_global_asm =\n+        crate::global_asm::add_file_stem_postfix(obj_out_regular.clone(), \".asm\");\n+    let has_global_asm = if let Some(asm_o) = work_product.saved_files.get(\"asm.o\") {\n+        let source_file_global_asm = rustc_incremental::in_incr_comp_dir_sess(&tcx.sess, asm_o);\n+        if let Err(err) = rustc_fs_util::link_or_copy(&source_file_global_asm, &obj_out_global_asm)\n+        {\n+            return Err(format!(\n+                \"unable to copy {} to {}: {}\",\n+                source_file_regular.display(),\n+                obj_out_regular.display(),\n+                err\n+            ));\n+        }\n+        true\n+    } else {\n+        false\n+    };\n \n-    work_products.insert(cgu.work_product_id(), work_product);\n-\n-    CompiledModule {\n-        name: cgu.name().to_string(),\n-        kind: ModuleKind::Regular,\n-        object: Some(obj_out),\n-        dwarf_object: None,\n-        bytecode: None,\n-    }\n+    Ok(ModuleCodegenResult {\n+        module_regular: CompiledModule {\n+            name: cgu.name().to_string(),\n+            kind: ModuleKind::Regular,\n+            object: Some(obj_out_regular),\n+            dwarf_object: None,\n+            bytecode: None,\n+        },\n+        module_global_asm: if has_global_asm {\n+            Some(CompiledModule {\n+                name: cgu.name().to_string(),\n+                kind: ModuleKind::Regular,\n+                object: Some(obj_out_global_asm),\n+                dwarf_object: None,\n+                bytecode: None,\n+            })\n+        } else {\n+            None\n+        },\n+        existing_work_product: Some((cgu.work_product_id(), work_product)),\n+    })\n }\n \n fn module_codegen(\n     tcx: TyCtxt<'_>,\n-    (backend_config, cgu_name): (BackendConfig, rustc_span::Symbol),\n-) -> ModuleCodegenResult {\n-    let cgu = tcx.codegen_unit(cgu_name);\n-    let mono_items = cgu.items_in_deterministic_order(tcx);\n-\n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut module = make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n-\n-    let mut cx = crate::CodegenCx::new(\n-        tcx,\n-        backend_config.clone(),\n-        module.isa(),\n-        tcx.sess.opts.debuginfo != DebugInfo::None,\n-        cgu_name,\n-    );\n-    super::predefine_mono_items(tcx, &mut module, &mono_items);\n-    for (mono_item, _) in mono_items {\n-        match mono_item {\n-            MonoItem::Fn(inst) => {\n-                cx.tcx\n-                    .sess\n-                    .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, &mut module, inst));\n-            }\n-            MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n-            MonoItem::GlobalAsm(item_id) => {\n-                let item = cx.tcx.hir().item(item_id);\n-                if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n-                    if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                        cx.global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n-                    } else {\n-                        cx.global_asm.push_str(\"\\n.att_syntax\\n\");\n-                    }\n-                    for piece in asm.template {\n-                        match *piece {\n-                            InlineAsmTemplatePiece::String(ref s) => cx.global_asm.push_str(s),\n-                            InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n-                        }\n-                    }\n-                    cx.global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n-                } else {\n-                    bug!(\"Expected GlobalAsm found {:?}\", item);\n+    (backend_config, global_asm_config, cgu_name, token): (\n+        BackendConfig,\n+        Arc<GlobalAsmConfig>,\n+        rustc_span::Symbol,\n+        ConcurrencyLimiterToken,\n+    ),\n+) -> OngoingModuleCodegen {\n+    let (cgu_name, mut cx, mut module, codegened_functions) = tcx.sess.time(\"codegen cgu\", || {\n+        let cgu = tcx.codegen_unit(cgu_name);\n+        let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+        let mut module = make_module(tcx.sess, &backend_config, cgu_name.as_str().to_string());\n+\n+        let mut cx = crate::CodegenCx::new(\n+            tcx,\n+            backend_config.clone(),\n+            module.isa(),\n+            tcx.sess.opts.debuginfo != DebugInfo::None,\n+            cgu_name,\n+        );\n+        super::predefine_mono_items(tcx, &mut module, &mono_items);\n+        let mut codegened_functions = vec![];\n+        for (mono_item, _) in mono_items {\n+            match mono_item {\n+                MonoItem::Fn(inst) => {\n+                    tcx.sess.time(\"codegen fn\", || {\n+                        let codegened_function = crate::base::codegen_fn(\n+                            tcx,\n+                            &mut cx,\n+                            Function::new(),\n+                            &mut module,\n+                            inst,\n+                        );\n+                        codegened_functions.push(codegened_function);\n+                    });\n+                }\n+                MonoItem::Static(def_id) => {\n+                    crate::constant::codegen_static(tcx, &mut module, def_id)\n+                }\n+                MonoItem::GlobalAsm(item_id) => {\n+                    crate::global_asm::codegen_global_asm_item(tcx, &mut cx.global_asm, item_id);\n                 }\n             }\n         }\n-    }\n-    crate::main_shim::maybe_create_entry_wrapper(\n-        tcx,\n-        &mut module,\n-        &mut cx.unwind_context,\n-        false,\n-        cgu.is_primary(),\n-    );\n-\n-    let debug_context = cx.debug_context;\n-    let unwind_context = cx.unwind_context;\n-    let codegen_result = tcx.sess.time(\"write object file\", || {\n-        emit_module(\n+        crate::main_shim::maybe_create_entry_wrapper(\n             tcx,\n-            &backend_config,\n-            cgu.name().as_str().to_string(),\n-            ModuleKind::Regular,\n-            module,\n-            debug_context,\n-            unwind_context,\n-        )\n+            &mut module,\n+            &mut cx.unwind_context,\n+            false,\n+            cgu.is_primary(),\n+        );\n+\n+        let cgu_name = cgu.name().as_str().to_owned();\n+\n+        (cgu_name, cx, module, codegened_functions)\n     });\n \n-    codegen_global_asm(tcx, cgu.name().as_str(), &cx.global_asm);\n+    OngoingModuleCodegen::Async(std::thread::spawn(move || {\n+        cx.profiler.clone().verbose_generic_activity(\"compile functions\").run(|| {\n+            let mut cached_context = Context::new();\n+            for codegened_func in codegened_functions {\n+                crate::base::compile_fn(&mut cx, &mut cached_context, &mut module, codegened_func);\n+            }\n+        });\n \n-    codegen_result\n+        let global_asm_object_file =\n+            cx.profiler.verbose_generic_activity(\"compile assembly\").run(|| {\n+                crate::global_asm::compile_global_asm(&global_asm_config, &cgu_name, &cx.global_asm)\n+            })?;\n+\n+        let codegen_result = cx.profiler.verbose_generic_activity(\"write object file\").run(|| {\n+            emit_cgu(\n+                &global_asm_config.output_filenames,\n+                &cx.profiler,\n+                cgu_name,\n+                module,\n+                cx.debug_context,\n+                cx.unwind_context,\n+                global_asm_object_file,\n+            )\n+        });\n+        std::mem::drop(token);\n+        codegen_result\n+    }))\n }\n \n pub(crate) fn run_aot(\n     tcx: TyCtxt<'_>,\n     backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n-    let mut work_products = FxHashMap::default();\n-\n+) -> Box<OngoingCodegen> {\n     let cgus = if tcx.sess.opts.output_types.should_codegen() {\n         tcx.collect_and_partition_mono_items(()).1\n     } else {\n@@ -206,62 +357,69 @@ pub(crate) fn run_aot(\n         }\n     }\n \n+    let global_asm_config = Arc::new(crate::global_asm::GlobalAsmConfig::new(tcx));\n+\n+    let mut concurrency_limiter = ConcurrencyLimiter::new(tcx.sess, cgus.len());\n+\n     let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n-                let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n+                let cgu_reuse = if backend_config.disable_incr_cache {\n+                    CguReuse::No\n+                } else {\n+                    determine_cgu_reuse(tcx, cgu)\n+                };\n                 tcx.sess.cgu_reuse_tracker.set_actual_reuse(cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n-                    _ if backend_config.disable_incr_cache => {}\n-                    CguReuse::No => {}\n-                    CguReuse::PreLto => {\n-                        return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n+                    CguReuse::No => {\n+                        let dep_node = cgu.codegen_dep_node(tcx);\n+                        tcx.dep_graph\n+                            .with_task(\n+                                dep_node,\n+                                tcx,\n+                                (\n+                                    backend_config.clone(),\n+                                    global_asm_config.clone(),\n+                                    cgu.name(),\n+                                    concurrency_limiter.acquire(),\n+                                ),\n+                                module_codegen,\n+                                Some(rustc_middle::dep_graph::hash_result),\n+                            )\n+                            .0\n+                    }\n+                    CguReuse::PreLto => unreachable!(),\n+                    CguReuse::PostLto => {\n+                        concurrency_limiter.job_already_done();\n+                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, &*cgu))\n                     }\n-                    CguReuse::PostLto => unreachable!(),\n-                }\n-\n-                let dep_node = cgu.codegen_dep_node(tcx);\n-                let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n-                    dep_node,\n-                    tcx,\n-                    (backend_config.clone(), cgu.name()),\n-                    module_codegen,\n-                    Some(rustc_middle::dep_graph::hash_result),\n-                );\n-\n-                if let Some((id, product)) = work_product {\n-                    work_products.insert(id, product);\n                 }\n-\n-                module\n             })\n             .collect::<Vec<_>>()\n     });\n \n     tcx.sess.abort_if_errors();\n \n-    let isa = crate::build_isa(tcx.sess, &backend_config);\n-    let mut allocator_module = make_module(tcx.sess, isa, \"allocator_shim\".to_string());\n-    assert_eq!(pointer_ty(tcx), allocator_module.target_config().pointer_type());\n+    let mut allocator_module = make_module(tcx.sess, &backend_config, \"allocator_shim\".to_string());\n     let mut allocator_unwind_context = UnwindContext::new(allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n \n     let allocator_module = if created_alloc_shim {\n-        let ModuleCodegenResult(module, work_product) = emit_module(\n-            tcx,\n-            &backend_config,\n-            \"allocator_shim\".to_string(),\n+        let mut product = allocator_module.finish();\n+        allocator_unwind_context.emit(&mut product);\n+\n+        match emit_module(\n+            tcx.output_filenames(()),\n+            &tcx.sess.prof,\n+            product.object,\n             ModuleKind::Allocator,\n-            allocator_module,\n-            None,\n-            allocator_unwind_context,\n-        );\n-        if let Some((id, product)) = work_product {\n-            work_products.insert(id, product);\n+            \"allocator_shim\".to_owned(),\n+        ) {\n+            Ok(allocator_module) => Some(allocator_module),\n+            Err(err) => tcx.sess.fatal(err),\n         }\n-        Some(module)\n     } else {\n         None\n     };\n@@ -308,102 +466,14 @@ pub(crate) fn run_aot(\n     }\n     .to_owned();\n \n-    Box::new((\n-        CodegenResults {\n-            modules,\n-            allocator_module,\n-            metadata_module,\n-            metadata,\n-            crate_info: CrateInfo::new(tcx, target_cpu),\n-        },\n-        work_products,\n-    ))\n-}\n-\n-fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n-    use std::io::Write;\n-    use std::process::{Command, Stdio};\n-\n-    if global_asm.is_empty() {\n-        return;\n-    }\n-\n-    if cfg!(not(feature = \"inline_asm\"))\n-        || tcx.sess.target.is_like_osx\n-        || tcx.sess.target.is_like_windows\n-    {\n-        if global_asm.contains(\"__rust_probestack\") {\n-            return;\n-        }\n-\n-        // FIXME fix linker error on macOS\n-        if cfg!(not(feature = \"inline_asm\")) {\n-            tcx.sess.fatal(\n-                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n-            );\n-        } else {\n-            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n-        }\n-    }\n-\n-    let assembler = crate::toolchain::get_toolchain_binary(tcx.sess, \"as\");\n-    let linker = crate::toolchain::get_toolchain_binary(tcx.sess, \"ld\");\n-\n-    // Remove all LLVM style comments\n-    let global_asm = global_asm\n-        .lines()\n-        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n-        .collect::<Vec<_>>()\n-        .join(\"\\n\");\n-\n-    let output_object_file = tcx.output_filenames(()).temp_path(OutputType::Object, Some(cgu_name));\n-\n-    // Assemble `global_asm`\n-    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n-    let mut child = Command::new(assembler)\n-        .arg(\"-o\")\n-        .arg(&global_asm_object_file)\n-        .stdin(Stdio::piped())\n-        .spawn()\n-        .expect(\"Failed to spawn `as`.\");\n-    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n-    let status = child.wait().expect(\"Failed to wait for `as`.\");\n-    if !status.success() {\n-        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n-    }\n-\n-    // Link the global asm and main object file together\n-    let main_object_file = add_file_stem_postfix(output_object_file.clone(), \".main\");\n-    std::fs::rename(&output_object_file, &main_object_file).unwrap();\n-    let status = Command::new(linker)\n-        .arg(\"-r\") // Create a new object file\n-        .arg(\"-o\")\n-        .arg(output_object_file)\n-        .arg(&main_object_file)\n-        .arg(&global_asm_object_file)\n-        .status()\n-        .unwrap();\n-    if !status.success() {\n-        tcx.sess.fatal(&format!(\n-            \"Failed to link `{}` and `{}` together\",\n-            main_object_file.display(),\n-            global_asm_object_file.display(),\n-        ));\n-    }\n-\n-    std::fs::remove_file(global_asm_object_file).unwrap();\n-    std::fs::remove_file(main_object_file).unwrap();\n-}\n-\n-fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n-    let mut new_filename = path.file_stem().unwrap().to_owned();\n-    new_filename.push(postfix);\n-    if let Some(extension) = path.extension() {\n-        new_filename.push(\".\");\n-        new_filename.push(extension);\n-    }\n-    path.set_file_name(new_filename);\n-    path\n+    Box::new(OngoingCodegen {\n+        modules,\n+        allocator_module,\n+        metadata_module,\n+        metadata,\n+        crate_info: CrateInfo::new(tcx, target_cpu),\n+        concurrency_limiter,\n+    })\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8/src/librustc_codegen_ssa/base.rs#L922-L953\n@@ -432,5 +502,5 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.try_mark_green(&dep_node) { CguReuse::PreLto } else { CguReuse::No }\n+    if tcx.try_mark_green(&dep_node) { CguReuse::PostLto } else { CguReuse::No }\n }"}, {"sha": "0e77e4004c0bb5d0ef4c814c9003fa114c1b51d1", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -61,11 +61,11 @@ impl UnsafeMessage {\n     }\n }\n \n-fn create_jit_module<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn create_jit_module(\n+    tcx: TyCtxt<'_>,\n     backend_config: &BackendConfig,\n     hotswap: bool,\n-) -> (JITModule, CodegenCx<'tcx>) {\n+) -> (JITModule, CodegenCx) {\n     let crate_info = CrateInfo::new(tcx, \"dummy_target_cpu\".to_string());\n     let imported_symbols = load_imported_symbols_for_jit(tcx.sess, crate_info);\n \n@@ -111,6 +111,7 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         &backend_config,\n         matches!(backend_config.codegen_mode, CodegenMode::JitLazy),\n     );\n+    let mut cached_context = Context::new();\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(());\n     let mono_items = cgus\n@@ -128,11 +129,19 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_fn(&mut cx, &mut jit_module, inst)\n+                        tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_and_compile_fn(\n+                                tcx,\n+                                &mut cx,\n+                                &mut cached_context,\n+                                &mut jit_module,\n+                                inst,\n+                            )\n                         });\n                     }\n-                    CodegenMode::JitLazy => codegen_shim(&mut cx, &mut jit_module, inst),\n+                    CodegenMode::JitLazy => {\n+                        codegen_shim(tcx, &mut cx, &mut cached_context, &mut jit_module, inst)\n+                    }\n                 },\n                 MonoItem::Static(def_id) => {\n                     crate::constant::codegen_static(tcx, &mut jit_module, def_id);\n@@ -259,7 +268,15 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n                 false,\n                 Symbol::intern(\"dummy_cgu_name\"),\n             );\n-            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n+            tcx.sess.time(\"codegen fn\", || {\n+                crate::base::codegen_and_compile_fn(\n+                    tcx,\n+                    &mut cx,\n+                    &mut Context::new(),\n+                    jit_module,\n+                    instance,\n+                )\n+            });\n \n             assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions();\n@@ -334,9 +351,13 @@ fn load_imported_symbols_for_jit(\n     imported_symbols\n }\n \n-fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: Instance<'tcx>) {\n-    let tcx = cx.tcx;\n-\n+fn codegen_shim<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cx: &mut CodegenCx,\n+    cached_context: &mut Context,\n+    module: &mut JITModule,\n+    inst: Instance<'tcx>,\n+) {\n     let pointer_type = module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name;\n@@ -357,8 +378,9 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n         )\n         .unwrap();\n \n-    cx.cached_context.clear();\n-    let trampoline = &mut cx.cached_context.func;\n+    let context = cached_context;\n+    context.clear();\n+    let trampoline = &mut context.func;\n     trampoline.signature = sig.clone();\n \n     let mut builder_ctx = FunctionBuilderContext::new();\n@@ -381,5 +403,6 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: In\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    module.define_function(func_id, &mut cx.cached_context).unwrap();\n+    module.define_function(func_id, context).unwrap();\n+    cx.unwind_context.add_function(func_id, context, module.isa());\n }"}, {"sha": "dcbcaba30feeda219cea9d7042dd73e40167fe82", "filename": "compiler/rustc_codegen_cranelift/src/global_asm.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,114 @@\n+//! The AOT driver uses [`cranelift_object`] to write object files suitable for linking into a\n+//! standalone executable.\n+\n+use std::io::Write;\n+use std::path::PathBuf;\n+use std::process::{Command, Stdio};\n+use std::sync::Arc;\n+\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_hir::ItemId;\n+use rustc_session::config::{OutputFilenames, OutputType};\n+\n+use crate::prelude::*;\n+\n+pub(crate) fn codegen_global_asm_item(tcx: TyCtxt<'_>, global_asm: &mut String, item_id: ItemId) {\n+    let item = tcx.hir().item(item_id);\n+    if let rustc_hir::ItemKind::GlobalAsm(asm) = item.kind {\n+        if !asm.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+            global_asm.push_str(\"\\n.intel_syntax noprefix\\n\");\n+        } else {\n+            global_asm.push_str(\"\\n.att_syntax\\n\");\n+        }\n+        for piece in asm.template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => global_asm.push_str(s),\n+                InlineAsmTemplatePiece::Placeholder { .. } => todo!(),\n+            }\n+        }\n+        global_asm.push_str(\"\\n.att_syntax\\n\\n\");\n+    } else {\n+        bug!(\"Expected GlobalAsm found {:?}\", item);\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct GlobalAsmConfig {\n+    asm_enabled: bool,\n+    assembler: PathBuf,\n+    pub(crate) output_filenames: Arc<OutputFilenames>,\n+}\n+\n+impl GlobalAsmConfig {\n+    pub(crate) fn new(tcx: TyCtxt<'_>) -> Self {\n+        let asm_enabled = cfg!(feature = \"inline_asm\") && !tcx.sess.target.is_like_windows;\n+\n+        GlobalAsmConfig {\n+            asm_enabled,\n+            assembler: crate::toolchain::get_toolchain_binary(tcx.sess, \"as\"),\n+            output_filenames: tcx.output_filenames(()).clone(),\n+        }\n+    }\n+}\n+\n+pub(crate) fn compile_global_asm(\n+    config: &GlobalAsmConfig,\n+    cgu_name: &str,\n+    global_asm: &str,\n+) -> Result<Option<PathBuf>, String> {\n+    if global_asm.is_empty() {\n+        return Ok(None);\n+    }\n+\n+    if !config.asm_enabled {\n+        if global_asm.contains(\"__rust_probestack\") {\n+            return Ok(None);\n+        }\n+\n+        // FIXME fix linker error on macOS\n+        if cfg!(not(feature = \"inline_asm\")) {\n+            return Err(\n+                \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\"\n+                    .to_owned(),\n+            );\n+        } else {\n+            return Err(\"asm! and global_asm! are not yet supported on Windows\".to_owned());\n+        }\n+    }\n+\n+    // Remove all LLVM style comments\n+    let global_asm = global_asm\n+        .lines()\n+        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n+\n+    let output_object_file = config.output_filenames.temp_path(OutputType::Object, Some(cgu_name));\n+\n+    // Assemble `global_asm`\n+    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n+    let mut child = Command::new(&config.assembler)\n+        .arg(\"-o\")\n+        .arg(&global_asm_object_file)\n+        .stdin(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn `as`.\");\n+    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n+    let status = child.wait().expect(\"Failed to wait for `as`.\");\n+    if !status.success() {\n+        return Err(format!(\"Failed to assemble `{}`\", global_asm));\n+    }\n+\n+    Ok(Some(global_asm_object_file))\n+}\n+\n+pub(crate) fn add_file_stem_postfix(mut path: PathBuf, postfix: &str) -> PathBuf {\n+    let mut new_filename = path.file_stem().unwrap().to_owned();\n+    new_filename.push(postfix);\n+    if let Some(extension) = path.extension() {\n+        new_filename.push(\".\");\n+        new_filename.push(extension);\n+    }\n+    path.set_file_name(new_filename);\n+    path\n+}"}, {"sha": "8b3d475cb1802dcc1662145ca0cc4a1c99a8119c", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 136, "deletions": 40, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -15,15 +15,19 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n+    destination: Option<mir::BasicBlock>,\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n     if !template.is_empty() {\n+        // Used by panic_abort\n         if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n-            let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-            fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+            fx.bcx.ins().trap(TrapCode::User(1));\n             return;\n-        } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+        }\n+\n+        // Used by stdarch\n+        if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n             && matches!(\n                 template[1],\n                 InlineAsmTemplatePiece::Placeholder {\n@@ -47,51 +51,46 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         {\n             assert_eq!(operands.len(), 4);\n             let (leaf, eax_place) = match operands[1] {\n-                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n-                    );\n-                    (\n-                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                        crate::base::codegen_place(fx, out_place.unwrap()),\n-                    )\n-                }\n+                InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n+                    late: true,\n+                    ref in_value,\n+                    out_place: Some(out_place),\n+                } => (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place),\n+                ),\n                 _ => unreachable!(),\n             };\n             let ebx_place = match operands[0] {\n-                InlineAsmOperand::Out { reg, late: true, place } => {\n-                    assert_eq!(\n-                        reg,\n+                InlineAsmOperand::Out {\n+                    reg:\n                         InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n-                            X86InlineAsmRegClass::reg\n-                        ))\n-                    );\n-                    crate::base::codegen_place(fx, place.unwrap())\n-                }\n+                            X86InlineAsmRegClass::reg,\n+                        )),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n             let (sub_leaf, ecx_place) = match operands[2] {\n-                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n-                    );\n-                    (\n-                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                        crate::base::codegen_place(fx, out_place.unwrap()),\n-                    )\n-                }\n+                InlineAsmOperand::InOut {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n+                    late: true,\n+                    ref in_value,\n+                    out_place: Some(out_place),\n+                } => (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place),\n+                ),\n                 _ => unreachable!(),\n             };\n             let edx_place = match operands[3] {\n-                InlineAsmOperand::Out { reg, late: true, place } => {\n-                    assert_eq!(\n-                        reg,\n-                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n-                    );\n-                    crate::base::codegen_place(fx, place.unwrap())\n-                }\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n \n@@ -101,12 +100,99 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n             ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n             edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n             return;\n-        } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+        }\n+\n+        // Used by compiler-builtins\n+        if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n             // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n             crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+            return;\n         } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n             crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+            return;\n+        }\n+\n+        // Used by measureme\n+        if template[0] == InlineAsmTemplatePiece::String(\"xor %eax, %eax\".to_string())\n+            && template[1] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[2] == InlineAsmTemplatePiece::String(\"mov %rbx, \".to_string())\n+            && matches!(\n+                template[3],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[6] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[7] == InlineAsmTemplatePiece::String(\"mov \".to_string())\n+            && matches!(\n+                template[8],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[9] == InlineAsmTemplatePiece::String(\", %rbx\".to_string())\n+        {\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"rdpmc\".to_string()) {\n+            // Return zero dummy values for all performance counters\n+            match operands[0] {\n+                InlineAsmOperand::In {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n+                    value: _,\n+                } => {}\n+                _ => unreachable!(),\n+            };\n+            let lo = match operands[1] {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n+                _ => unreachable!(),\n+            };\n+            let hi = match operands[2] {\n+                InlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n+                    late: true,\n+                    place: Some(place),\n+                } => crate::base::codegen_place(fx, place),\n+                _ => unreachable!(),\n+            };\n+\n+            let u32_layout = fx.layout_of(fx.tcx.types.u32);\n+            let zero = fx.bcx.ins().iconst(types::I32, 0);\n+            lo.write_cvalue(fx, CValue::by_val(zero, u32_layout));\n+            hi.write_cvalue(fx, CValue::by_val(zero, u32_layout));\n+\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"lock xadd \".to_string())\n+            && matches!(\n+                template[1],\n+                InlineAsmTemplatePiece::Placeholder { operand_idx: 1, modifier: None, span: _ }\n+            )\n+            && template[2] == InlineAsmTemplatePiece::String(\", (\".to_string())\n+            && matches!(\n+                template[3],\n+                InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: None, span: _ }\n+            )\n+            && template[4] == InlineAsmTemplatePiece::String(\")\".to_string())\n+        {\n+            let destination_block = fx.get_block(destination.unwrap());\n+            fx.bcx.ins().jump(destination_block, &[]);\n+            return;\n         }\n     }\n \n@@ -175,6 +261,16 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     }\n \n     call_inline_asm(fx, &asm_name, asm_gen.stack_slot_size, inputs, outputs);\n+\n+    match destination {\n+        Some(destination) => {\n+            let destination_block = fx.get_block(destination);\n+            fx.bcx.ins().jump(destination_block, &[]);\n+        }\n+        None => {\n+            fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n+        }\n+    }\n }\n \n struct InlineAssemblyGenerator<'a, 'tcx> {\n@@ -637,7 +733,7 @@ fn call_inline_asm<'tcx>(\n     inputs: Vec<(Size, Value)>,\n     outputs: Vec<(Size, CPlace<'tcx>)>,\n ) {\n-    let stack_slot = fx.bcx.func.create_stack_slot(StackSlotData {\n+    let stack_slot = fx.bcx.func.create_sized_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n         size: u32::try_from(slot_size.bytes()).unwrap(),\n     });"}, {"sha": "5120b89c4e8b0b28dba764aac67ed47cbfac3f1a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n     fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n-    crate::trap::trap_unreachable(\n+    crate::trap::trap_unimplemented(\n         fx,\n         \"__cpuid_count arch intrinsic doesn't yet support specified leaf\",\n     );"}, {"sha": "a799dca938e21bb4ef79027aaf408263aa961389", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -139,6 +139,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 .sess\n                 .warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n             crate::trap::trap_unimplemented(fx, intrinsic);\n+            return;\n         }\n     }\n "}, {"sha": "95239f415a99b5e88c965b37aab3cc860cdf97a3", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -44,7 +44,7 @@ fn report_atomic_type_validation_error<'tcx>(\n         ),\n     );\n     // Prevent verifier error\n-    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n@@ -53,7 +53,7 @@ pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx\n         _ => unreachable!(),\n     };\n \n-    match scalar_to_clif_type(tcx, element).by(u16::try_from(count).unwrap()) {\n+    match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n         // Cranelift currently only implements icmp for 128bit vectors.\n         Some(vector_ty) if vector_ty.bits() == 128 => Some(vector_ty),\n         _ => None,\n@@ -301,7 +301,44 @@ fn codegen_float_intrinsic_call<'tcx>(\n         _ => unreachable!(),\n     };\n \n-    let res = fx.easy_call(name, &args, ty);\n+    let layout = fx.layout_of(ty);\n+    let res = match intrinsic {\n+        sym::fmaf32 | sym::fmaf64 => {\n+            let a = args[0].load_scalar(fx);\n+            let b = args[1].load_scalar(fx);\n+            let c = args[2].load_scalar(fx);\n+            CValue::by_val(fx.bcx.ins().fma(a, b, c), layout)\n+        }\n+        sym::copysignf32 | sym::copysignf64 => {\n+            let a = args[0].load_scalar(fx);\n+            let b = args[1].load_scalar(fx);\n+            CValue::by_val(fx.bcx.ins().fcopysign(a, b), layout)\n+        }\n+        sym::fabsf32\n+        | sym::fabsf64\n+        | sym::floorf32\n+        | sym::floorf64\n+        | sym::ceilf32\n+        | sym::ceilf64\n+        | sym::truncf32\n+        | sym::truncf64 => {\n+            let a = args[0].load_scalar(fx);\n+\n+            let val = match intrinsic {\n+                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(a),\n+                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(a),\n+                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(a),\n+                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(a),\n+                _ => unreachable!(),\n+            };\n+\n+            CValue::by_val(val, layout)\n+        }\n+        // These intrinsics aren't supported natively by Cranelift.\n+        // Lower them to a libcall.\n+        _ => fx.easy_call(name, &args, ty),\n+    };\n+\n     ret.write_cvalue(fx, res);\n \n     true\n@@ -540,6 +577,13 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(res, base.layout()));\n         }\n \n+        sym::ptr_mask => {\n+            intrinsic_args!(fx, args => (ptr, mask); intrinsic);\n+            let ptr = ptr.load_scalar(fx);\n+            let mask = mask.load_scalar(fx);\n+            fx.bcx.ins().band(ptr, mask);\n+        }\n+\n         sym::transmute => {\n             intrinsic_args!(fx, args => (from); intrinsic);\n \n@@ -818,8 +862,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap());\n-                        fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n                         fx.tcx\n@@ -851,8 +893,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                     if fx.tcx.is_compiler_builtins(LOCAL_CRATE) {\n                         // special case for compiler-builtins to avoid having to patch it\n                         crate::trap::trap_unimplemented(fx, \"128bit atomics not yet supported\");\n-                        let ret_block = fx.get_block(destination.unwrap());\n-                        fx.bcx.ins().jump(ret_block, &[]);\n                         return;\n                     } else {\n                         fx.tcx"}, {"sha": "1f358b1bbb96edb89a2893cf9bc526f6dbcc79b9", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -14,7 +14,7 @@ fn report_simd_type_validation_error(\n ) {\n     fx.tcx.sess.span_err(span, &format!(\"invalid monomorphization of `{}` intrinsic: expected SIMD input type, found non-SIMD `{}`\", intrinsic, ty));\n     // Prevent verifier error\n-    crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n@@ -157,7 +157,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                             ),\n                         );\n                         // Prevent verifier error\n-                        crate::trap::trap_unreachable(fx, \"compilation should not have succeeded\");\n+                        fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n                         return;\n                     }\n                 }\n@@ -186,7 +186,10 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                         let size = Size::from_bytes(\n                             4 * ret_lane_count, /* size_of([u32; ret_lane_count]) */\n                         );\n-                        alloc.inner().get_bytes(fx, alloc_range(offset, size)).unwrap()\n+                        alloc\n+                            .inner()\n+                            .get_bytes_strip_provenance(fx, alloc_range(offset, size))\n+                            .unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", idx_const),\n                 };\n@@ -274,12 +277,17 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 idx_const\n             } else {\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n-                let res = crate::trap::trap_unimplemented_ret_value(\n+                let trap_block = fx.bcx.create_block();\n+                let dummy_block = fx.bcx.create_block();\n+                let true_ = fx.bcx.ins().iconst(types::I8, 1);\n+                fx.bcx.ins().brnz(true_, trap_block, &[]);\n+                fx.bcx.ins().jump(dummy_block, &[]);\n+                fx.bcx.switch_to_block(trap_block);\n+                crate::trap::trap_unimplemented(\n                     fx,\n-                    ret.layout(),\n                     \"Index argument for `simd_extract` is not a constant\",\n                 );\n-                ret.write_cvalue(fx, res);\n+                fx.bcx.switch_to_block(dummy_block);\n                 return;\n             };\n \n@@ -392,21 +400,15 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n             let layout = a.layout();\n             let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+            let res_lane_layout = fx.layout_of(lane_ty);\n \n             for lane in 0..lane_count {\n-                let a_lane = a.value_lane(fx, lane);\n-                let b_lane = b.value_lane(fx, lane);\n-                let c_lane = c.value_lane(fx, lane);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+                let c_lane = c.value_lane(fx, lane).load_scalar(fx);\n \n-                let res_lane = match lane_ty.kind() {\n-                    ty::Float(FloatTy::F32) => {\n-                        fx.easy_call(\"fmaf\", &[a_lane, b_lane, c_lane], lane_ty)\n-                    }\n-                    ty::Float(FloatTy::F64) => {\n-                        fx.easy_call(\"fma\", &[a_lane, b_lane, c_lane], lane_ty)\n-                    }\n-                    _ => unreachable!(),\n-                };\n+                let res_lane = fx.bcx.ins().fma(a_lane, b_lane, c_lane);\n+                let res_lane = CValue::by_val(res_lane, res_lane_layout);\n \n                 ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n             }"}, {"sha": "913414e7618213d99adb63a711ef18412e747695", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -4,6 +4,7 @@\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n+extern crate jobserver;\n #[macro_use]\n extern crate rustc_middle;\n extern crate rustc_ast;\n@@ -25,10 +26,12 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n+use std::sync::Arc;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_errors::ErrorGuaranteed;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n@@ -51,11 +54,13 @@ mod cast;\n mod codegen_i128;\n mod common;\n mod compiler_builtins;\n+mod concurrency_limiter;\n mod config;\n mod constant;\n mod debuginfo;\n mod discriminant;\n mod driver;\n+mod global_asm;\n mod inline_asm;\n mod intrinsics;\n mod linkage;\n@@ -119,19 +124,20 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n \n /// The codegen context holds any information shared between the codegen of individual functions\n /// inside a single codegen unit with the exception of the Cranelift [`Module`](cranelift_module::Module).\n-struct CodegenCx<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct CodegenCx {\n+    profiler: SelfProfilerRef,\n+    output_filenames: Arc<OutputFilenames>,\n+    should_write_ir: bool,\n     global_asm: String,\n     inline_asm_index: Cell<usize>,\n-    cached_context: Context,\n-    debug_context: Option<DebugContext<'tcx>>,\n+    debug_context: Option<DebugContext>,\n     unwind_context: UnwindContext,\n     cgu_name: Symbol,\n }\n \n-impl<'tcx> CodegenCx<'tcx> {\n+impl CodegenCx {\n     fn new(\n-        tcx: TyCtxt<'tcx>,\n+        tcx: TyCtxt<'_>,\n         backend_config: BackendConfig,\n         isa: &dyn TargetIsa,\n         debug_info: bool,\n@@ -147,10 +153,11 @@ impl<'tcx> CodegenCx<'tcx> {\n             None\n         };\n         CodegenCx {\n-            tcx,\n+            profiler: tcx.prof.clone(),\n+            output_filenames: tcx.output_filenames(()).clone(),\n+            should_write_ir: crate::pretty_clif::should_write_ir(tcx),\n             global_asm: String::new(),\n             inline_asm_index: Cell::new(0),\n-            cached_context: Context::new(),\n             debug_context,\n             unwind_context,\n             cgu_name,\n@@ -159,7 +166,7 @@ impl<'tcx> CodegenCx<'tcx> {\n }\n \n pub struct CraneliftCodegenBackend {\n-    pub config: Option<BackendConfig>,\n+    pub config: RefCell<Option<BackendConfig>>,\n }\n \n impl CodegenBackend for CraneliftCodegenBackend {\n@@ -169,6 +176,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             Lto::No | Lto::ThinLocal => {}\n             Lto::Thin | Lto::Fat => sess.warn(\"LTO is not supported. You may get a linker error.\"),\n         }\n+\n+        let mut config = self.config.borrow_mut();\n+        if config.is_none() {\n+            let new_config = BackendConfig::from_opts(&sess.opts.cg.llvm_args)\n+                .unwrap_or_else(|err| sess.fatal(&err));\n+            *config = Some(new_config);\n+        }\n     }\n \n     fn target_features(&self, _sess: &Session, _allow_unstable: bool) -> Vec<rustc_span::Symbol> {\n@@ -186,15 +200,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n         tcx.sess.abort_if_errors();\n-        let config = if let Some(config) = self.config.clone() {\n-            config\n-        } else {\n-            if !tcx.sess.unstable_options() && !tcx.sess.opts.cg.llvm_args.is_empty() {\n-                tcx.sess.fatal(\"`-Z unstable-options` must be passed to allow configuring cg_clif\");\n-            }\n-            BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n-                .unwrap_or_else(|err| tcx.sess.fatal(&err))\n-        };\n+        let config = self.config.borrow().clone().unwrap();\n         match config.codegen_mode {\n             CodegenMode::Aot => driver::aot::run_aot(tcx, config, metadata, need_metadata_module),\n             CodegenMode::Jit | CodegenMode::JitLazy => {\n@@ -210,12 +216,13 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     fn join_codegen(\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n-        _sess: &Session,\n+        sess: &Session,\n         _outputs: &OutputFilenames,\n     ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorGuaranteed> {\n-        Ok(*ongoing_codegen\n-            .downcast::<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)>()\n-            .unwrap())\n+        Ok(ongoing_codegen\n+            .downcast::<driver::aot::OngoingCodegen>()\n+            .unwrap()\n+            .join(sess, self.config.borrow().as_ref().unwrap()))\n     }\n \n     fn link(\n@@ -312,5 +319,5 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n /// This is the entrypoint for a hot plugged rustc_codegen_cranelift\n #[no_mangle]\n pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n-    Box::new(CraneliftCodegenBackend { config: None })\n+    Box::new(CraneliftCodegenBackend { config: RefCell::new(None) })\n }"}, {"sha": "0df7e82294bd23521b72225d3746116488cac4d3", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,20 +1,3 @@\n //! Various optimizations specific to cg_clif\n \n-use cranelift_codegen::isa::TargetIsa;\n-\n-use crate::prelude::*;\n-\n pub(crate) mod peephole;\n-\n-pub(crate) fn optimize_function<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    isa: &dyn TargetIsa,\n-    instance: Instance<'tcx>,\n-    ctx: &mut Context,\n-    clif_comments: &mut crate::pretty_clif::CommentWriter,\n-) {\n-    // FIXME classify optimizations over opt levels once we have more\n-\n-    crate::pretty_clif::write_clif_file(tcx, \"preopt\", isa, instance, &ctx.func, &*clif_comments);\n-    crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n-}"}, {"sha": "a7af162687c34c5cd0fa4ffbea65459779231eb7", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -62,7 +62,7 @@ use cranelift_codegen::{\n };\n \n use rustc_middle::ty::layout::FnAbiOf;\n-use rustc_session::config::OutputType;\n+use rustc_session::config::{OutputFilenames, OutputType};\n \n use crate::prelude::*;\n \n@@ -205,60 +205,55 @@ pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n }\n \n pub(crate) fn write_ir_file(\n-    tcx: TyCtxt<'_>,\n-    name: impl FnOnce() -> String,\n+    output_filenames: &OutputFilenames,\n+    name: &str,\n     write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n ) {\n-    if !should_write_ir(tcx) {\n-        return;\n-    }\n-\n-    let clif_output_dir = tcx.output_filenames(()).with_extension(\"clif\");\n+    let clif_output_dir = output_filenames.with_extension(\"clif\");\n \n     match std::fs::create_dir(&clif_output_dir) {\n         Ok(()) => {}\n         Err(err) if err.kind() == std::io::ErrorKind::AlreadyExists => {}\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(name());\n+    let clif_file_name = clif_output_dir.join(name);\n \n     let res = std::fs::File::create(clif_file_name).and_then(|mut file| write(&mut file));\n     if let Err(err) = res {\n-        tcx.sess.warn(&format!(\"error writing ir file: {}\", err));\n+        // Using early_warn as no Session is available here\n+        rustc_session::early_warn(\n+            rustc_session::config::ErrorOutputType::default(),\n+            &format!(\"error writing ir file: {}\", err),\n+        );\n     }\n }\n \n-pub(crate) fn write_clif_file<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn write_clif_file(\n+    output_filenames: &OutputFilenames,\n+    symbol_name: &str,\n     postfix: &str,\n     isa: &dyn cranelift_codegen::isa::TargetIsa,\n-    instance: Instance<'tcx>,\n     func: &cranelift_codegen::ir::Function,\n     mut clif_comments: &CommentWriter,\n ) {\n     // FIXME work around filename too long errors\n-    write_ir_file(\n-        tcx,\n-        || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n-        |file| {\n-            let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func)\n-                .unwrap();\n+    write_ir_file(output_filenames, &format!(\"{}.{}.clif\", symbol_name, postfix), |file| {\n+        let mut clif = String::new();\n+        cranelift_codegen::write::decorate_function(&mut clif_comments, &mut clif, func).unwrap();\n \n-            for flag in isa.flags().iter() {\n-                writeln!(file, \"set {}\", flag)?;\n-            }\n-            write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n-            for isa_flag in isa.isa_flags().iter() {\n-                write!(file, \" {}\", isa_flag)?;\n-            }\n-            writeln!(file, \"\\n\")?;\n-            writeln!(file)?;\n-            file.write_all(clif.as_bytes())?;\n-            Ok(())\n-        },\n-    );\n+        for flag in isa.flags().iter() {\n+            writeln!(file, \"set {}\", flag)?;\n+        }\n+        write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n+        for isa_flag in isa.isa_flags().iter() {\n+            write!(file, \" {}\", isa_flag)?;\n+        }\n+        writeln!(file, \"\\n\")?;\n+        writeln!(file)?;\n+        file.write_all(clif.as_bytes())?;\n+        Ok(())\n+    });\n }\n \n impl fmt::Debug for FunctionCx<'_, '_, '_> {"}, {"sha": "b6b465e1f4e0a808a394c07b68ee0563d1538314", "filename": "compiler/rustc_codegen_cranelift/src/toolchain.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,10 +8,8 @@ use rustc_session::Session;\n /// Tries to infer the path of a binary for the target toolchain from the linker name.\n pub(crate) fn get_toolchain_binary(sess: &Session, tool: &str) -> PathBuf {\n     let (mut linker, _linker_flavor) = linker_and_flavor(sess);\n-    let linker_file_name = linker\n-        .file_name()\n-        .and_then(|name| name.to_str())\n-        .unwrap_or_else(|| sess.fatal(\"couldn't extract file name from specified linker\"));\n+    let linker_file_name =\n+        linker.file_name().unwrap().to_str().expect(\"linker filename should be valid UTF-8\");\n \n     if linker_file_name == \"ld.lld\" {\n         if tool != \"ld\" {"}, {"sha": "82a2ec579549669afca23f19c1fac2e0eba12936", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -25,33 +25,10 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }\n \n-/// Use this for example when a function call should never return. This will fill the current block,\n-/// so you can **not** add instructions to it afterwards.\n-///\n-/// Trap code: user65535\n-pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n-    codegen_print(fx, msg.as_ref());\n-    fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n-}\n /// Use this when something is unimplemented, but `libcore` or `libstd` requires it to codegen.\n-/// Unlike `trap_unreachable` this will not fill the current block, so you **must** add instructions\n-/// to it afterwards.\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n-    let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-    fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n-}\n-\n-/// Like `trap_unimplemented` but returns a fake value of the specified type.\n-///\n-/// Trap code: user65535\n-pub(crate) fn trap_unimplemented_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    dest_layout: TyAndLayout<'tcx>,\n-    msg: impl AsRef<str>,\n-) -> CValue<'tcx> {\n-    trap_unimplemented(fx, msg);\n-    CValue::by_ref(Pointer::const_addr(fx, 0), dest_layout)\n+    fx.bcx.ins().trap(TrapCode::User(!0));\n }"}, {"sha": "dd9d891ddbdee5d47272982e7685606270ae2197", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -29,6 +29,7 @@ pub(crate) fn unsized_info<'tcx>(\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n+                // A NOP cast that doesn't actually change anything, should be allowed even with invalid vtables.\n                 return old_info;\n             }\n "}, {"sha": "2ee98546c992a1ec8cce8ccd3c7e2a2fdb9d06a8", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> CValue<'tcx> {\n                 let clif_ty = match layout.abi {\n                     Abi::Scalar(scalar) => scalar_to_clif_type(fx.tcx, scalar),\n                     Abi::Vector { element, count } => scalar_to_clif_type(fx.tcx, element)\n-                        .by(u16::try_from(count).unwrap())\n+                        .by(u32::try_from(count).unwrap())\n                         .unwrap(),\n                     _ => unreachable!(\"{:?}\", layout.ty),\n                 };\n@@ -330,7 +330,7 @@ impl<'tcx> CPlace<'tcx> {\n                 .fatal(&format!(\"values of type {} are too big to store on the stack\", layout.ty));\n         }\n \n-        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+        let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n             // specify stack slot alignment.\n@@ -472,7 +472,7 @@ impl<'tcx> CPlace<'tcx> {\n                 }\n                 _ if src_ty.is_vector() || dst_ty.is_vector() => {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n-                    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+                    let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n                         kind: StackSlotKind::ExplicitSlot,\n                         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n                         // specify stack slot alignment.\n@@ -519,7 +519,7 @@ impl<'tcx> CPlace<'tcx> {\n                 if let ty::Array(element, len) = dst_layout.ty.kind() {\n                     // Can only happen for vector types\n                     let len =\n-                        u16::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n+                        u32::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n                     let vector_ty = fx.clif_type(*element).unwrap().by(len).unwrap();\n \n                     let data = match from.0 {\n@@ -614,7 +614,7 @@ impl<'tcx> CPlace<'tcx> {\n                     dst_align,\n                     src_align,\n                     true,\n-                    MemFlags::trusted(),\n+                    flags,\n                 );\n             }\n             CValueInner::ByRef(_, Some(_)) => todo!(),"}, {"sha": "3d929a1d50ce2435307a7834c1fe04c1c73b94bd", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,13 +1,2 @@\n #!/usr/bin/env bash\n-set -e\n-\n-./y.rs build --sysroot none \"$@\"\n-\n-rm -r target/out || true\n-\n-scripts/tests.sh no_sysroot\n-\n-./y.rs build \"$@\"\n-\n-scripts/tests.sh base_sysroot\n-scripts/tests.sh extended_sysroot\n+exec ./y.rs test"}, {"sha": "89661918d05a5d14e90359c267beb57f356dab98", "filename": "compiler/rustc_codegen_gcc/example/alloc_system.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -156,7 +156,7 @@ mod platform {\n     struct Header(*mut u8);\n     const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n+        &mut *(ptr as *mut Header).sub(1)\n     }\n     unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n         let aligned = ptr.add(align - (ptr as usize & (align - 1)));"}, {"sha": "c59a40df03988aeec2b908ad36e9e4413793533b", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -14,7 +14,6 @@ index 06c7be0..359e2e7 100644\n @@ -75,7 +75,6 @@\n  #![feature(never_type)]\n  #![feature(unwrap_infallible)]\n- #![feature(result_into_ok_or_err)]\n -#![feature(portable_simd)]\n  #![feature(ptr_metadata)]\n  #![feature(once_cell)]"}, {"sha": "848c34211ff616c09c9bf2f8a62b535442646fbf", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -107,45 +107,24 @@ pub trait FnAbiGccExt<'gcc, 'tcx> {\n impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool, FxHashSet<usize>) {\n         let mut on_stack_param_indices = FxHashSet::default();\n-        let args_capacity: usize = self.args.iter().map(|arg|\n-            if arg.pad.is_some() {\n-                1\n-            }\n-            else {\n-                0\n-            } +\n-            if let PassMode::Pair(_, _) = arg.mode {\n-                2\n-            } else {\n-                1\n-            }\n-        ).sum();\n+\n+        // This capacity calculation is approximate.\n         let mut argument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect { .. } = self.ret.mode {\n-                1\n-            }\n-            else {\n-                0\n-            } + args_capacity,\n+            self.args.len() + if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 }\n         );\n \n         let return_ty =\n             match self.ret.mode {\n                 PassMode::Ignore => cx.type_void(),\n                 PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_gcc_type(cx),\n-                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast, _) => cast.gcc_type(cx),\n                 PassMode::Indirect { .. } => {\n                     argument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                     cx.type_void()\n                 }\n             };\n \n-        for arg in &self.args {\n-            // add padding\n-            if let Some(ty) = arg.pad {\n-                argument_tys.push(ty.gcc_type(cx));\n-            }\n-\n+        for arg in self.args.iter() {\n             let arg_ty = match arg.mode {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_gcc_type(cx),\n@@ -157,7 +136,13 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                     unimplemented!();\n                 }\n-                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast, pad_i32) => {\n+                    // add padding\n+                    if pad_i32 {\n+                        argument_tys.push(Reg::i32().gcc_type(cx));\n+                    }\n+                    cast.gcc_type(cx)\n+                }\n                 PassMode::Indirect { extra_attrs: None, on_stack: true, .. } => {\n                     on_stack_param_indices.insert(argument_tys.len());\n                     arg.memory_ty(cx)"}, {"sha": "6994eeb00c3e2e6de92639e6039d5e00e8d0c63a", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 169, "deletions": 5, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -15,8 +15,11 @@ use gccjit::{\n     Type,\n     UnaryOp,\n };\n+use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_codegen_ssa::MemFlags;\n-use rustc_codegen_ssa::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n+use rustc_codegen_ssa::common::{\n+    AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope, TypeKind,\n+};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n@@ -31,6 +34,7 @@ use rustc_codegen_ssa::traits::{\n     StaticBuilderMethods,\n };\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::bug;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n@@ -1271,12 +1275,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         val\n     }\n \n-    fn fptoui_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptoui_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(false, val, dest_ty)\n     }\n \n-    fn fptosi_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n-        None\n+    fn fptosi_sat(&mut self, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.fptoint_sat(true, val, dest_ty)\n     }\n \n     fn instrprof_increment(&mut self, _fn_name: RValue<'gcc>, _hash: RValue<'gcc>, _num_counters: RValue<'gcc>, _index: RValue<'gcc>) {\n@@ -1285,6 +1289,166 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    fn fptoint_sat(&mut self, signed: bool, val: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        let src_ty = self.cx.val_ty(val);\n+        let (float_ty, int_ty) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n+            assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n+            (self.cx.element_type(src_ty), self.cx.element_type(dest_ty))\n+        } else {\n+            (src_ty, dest_ty)\n+        };\n+\n+        // FIXME(jistone): the following was originally the fallback SSA implementation, before LLVM 13\n+        // added native `fptosi.sat` and `fptoui.sat` conversions, but it was used by GCC as well.\n+        // Now that LLVM always relies on its own, the code has been moved to GCC, but the comments are\n+        // still LLVM-specific. This should be updated, and use better GCC specifics if possible.\n+\n+        let int_width = self.cx.int_width(int_ty);\n+        let float_width = self.cx.float_width(float_ty);\n+        // LLVM's fpto[su]i returns undef when the input val is infinite, NaN, or does not fit into the\n+        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n+        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n+        // Semantically, the mathematical value of the input is rounded towards zero to the next\n+        // mathematical integer, and then the result is clamped into the range of the destination\n+        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n+        // the destination integer type. NaN is mapped to 0.\n+        //\n+        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n+        // a value representable in int_ty.\n+        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n+        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n+        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n+        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n+        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n+        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n+        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n+        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n+        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n+        let int_max = |signed: bool, int_width: u64| -> u128 {\n+            let shift_amount = 128 - int_width;\n+            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n+        };\n+        let int_min = |signed: bool, int_width: u64| -> i128 {\n+            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n+        };\n+\n+        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n+            let rounded_min =\n+                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            let rounded_max =\n+                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n+            assert!(rounded_max.value.is_finite());\n+            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n+        };\n+        // To implement saturation, we perform the following steps:\n+        //\n+        // 1. Cast val to an integer with fpto[su]i. This may result in undef.\n+        // 2. Compare val to f_min and f_max, and use the comparison results to select:\n+        //  a) int_ty::MIN if val < f_min or val is NaN\n+        //  b) int_ty::MAX if val > f_max\n+        //  c) the result of fpto[su]i otherwise\n+        // 3. If val is NaN, return 0.0, otherwise return the result of step 2.\n+        //\n+        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n+        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n+        // undef does not introduce any non-determinism either.\n+        // More importantly, the above procedure correctly implements saturating conversion.\n+        // Proof (sketch):\n+        // If val is NaN, 0 is returned by definition.\n+        // Otherwise, val is finite or infinite and thus can be compared with f_min and f_max.\n+        // This yields three cases to consider:\n+        // (1) if val in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n+        //     saturating conversion for inputs in that range.\n+        // (2) if val > f_max, then val is larger than int_ty::MAX. This holds even if f_max is rounded\n+        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n+        //     than int_ty::MAX. Because val is larger than int_ty::MAX, the return value of int_ty::MAX\n+        //     is correct.\n+        // (3) if val < f_min, then val is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n+        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n+        // QED.\n+\n+        let float_bits_to_llval = |bx: &mut Self, bits| {\n+            let bits_llval = match float_width {\n+                32 => bx.cx().const_u32(bits as u32),\n+                64 => bx.cx().const_u64(bits as u64),\n+                n => bug!(\"unsupported float width {}\", n),\n+            };\n+            bx.bitcast(bits_llval, float_ty)\n+        };\n+        let (f_min, f_max) = match float_width {\n+            32 => compute_clamp_bounds_single(signed, int_width),\n+            64 => compute_clamp_bounds_double(signed, int_width),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        let f_min = float_bits_to_llval(self, f_min);\n+        let f_max = float_bits_to_llval(self, f_max);\n+        let int_max = self.cx.const_uint_big(int_ty, int_max(signed, int_width));\n+        let int_min = self.cx.const_uint_big(int_ty, int_min(signed, int_width) as u128);\n+        let zero = self.cx.const_uint(int_ty, 0);\n+\n+        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n+        // into each lane of the vector.  The algorithm stays the same, we are just using the\n+        // same constant across all lanes.\n+        let maybe_splat = |bx: &mut Self, val| {\n+            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n+                bx.vector_splat(bx.vector_length(dest_ty), val)\n+            } else {\n+                val\n+            }\n+        };\n+        let f_min = maybe_splat(self, f_min);\n+        let f_max = maybe_splat(self, f_max);\n+        let int_max = maybe_splat(self, int_max);\n+        let int_min = maybe_splat(self, int_min);\n+        let zero = maybe_splat(self, zero);\n+\n+        // Step 1 ...\n+        let fptosui_result = if signed { self.fptosi(val, dest_ty) } else { self.fptoui(val, dest_ty) };\n+        let less_or_nan = self.fcmp(RealPredicate::RealULT, val, f_min);\n+        let greater = self.fcmp(RealPredicate::RealOGT, val, f_max);\n+\n+        // Step 2: We use two comparisons and two selects, with %s1 being the\n+        // result:\n+        //     %less_or_nan = fcmp ult %val, %f_min\n+        //     %greater = fcmp olt %val, %f_max\n+        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n+        //     %s1 = select %greater, int_ty::MAX, %s0\n+        // Note that %less_or_nan uses an *unordered* comparison. This\n+        // comparison is true if the operands are not comparable (i.e., if val is\n+        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n+        // val is NaN.\n+        //\n+        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n+        // comparison and a negation, and the negation can be merged into the\n+        // select. Therefore, it not necessarily any more expensive than an\n+        // ordered (\"normal\") comparison. Whether these optimizations will be\n+        // performed is ultimately up to the backend, but at least x86 does\n+        // perform them.\n+        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n+        let s1 = self.select(greater, int_max, s0);\n+\n+        // Step 3: NaN replacement.\n+        // For unsigned types, the above step already yielded int_ty::MIN == 0 if val is NaN.\n+        // Therefore we only need to execute this step for signed integer types.\n+        if signed {\n+            // LLVM has no isNaN predicate, so we use (val == val) instead\n+            let cmp = self.fcmp(RealPredicate::RealOEQ, val, val);\n+            self.select(cmp, s1, zero)\n+        } else {\n+            s1\n+        }\n+    }\n+\n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n         let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");"}, {"sha": "356c03ee3c189cadeacc111f37403d29911ba704", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -127,7 +127,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n             //\n             // We could remove this hack whenever we decide to drop macOS 10.10 support.\n             if self.tcx.sess.target.options.is_like_osx {\n-                // The `inspect` method is okay here because we checked relocations, and\n+                // The `inspect` method is okay here because we checked for provenance, and\n                 // because we are doing this access to inspect the final interpreter state\n                 // (not as part of the interpreter execution).\n                 //\n@@ -296,17 +296,17 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAllocation<'tcx>) -> RValue<'gcc> {\n     let alloc = alloc.inner();\n-    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.provenance().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, alloc_id) in alloc.relocations().iter() {\n+    for &(offset, alloc_id) in alloc.provenance().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // This `inspect` is okay since we have checked that it is not within a pointer with provenance, it\n             // is within the bounds of the allocation, and it doesn't affect interpreter execution\n             // (we inspect the result after interpreter execution). Any undef byte is replaced with\n             // some arbitrary byte value.\n@@ -319,7 +319,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n             read_target_uint( dl.endian,\n                 // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n                 // affect interpreter execution (we inspect the result after interpreter execution),\n-                // and we properly interpret the relocation as a relocation pointer offset.\n+                // and we properly interpret the provenance as a relocation pointer offset.\n                 alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n             )\n             .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n@@ -336,7 +336,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n     }\n     if alloc.len() >= next_offset {\n         let range = next_offset..alloc.len();\n-        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // This `inspect` is okay since we have check that it is after all provenance, it is\n         // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n         // inspect the result after interpreter execution). Any undef byte is replaced with some\n         // arbitrary byte value."}, {"sha": "02cedd4646bbd0939e8b7cbfdd8da7c0b32b17c0", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 sym::volatile_load | sym::unaligned_volatile_load => {\n                     let tp_ty = substs.type_at(0);\n                     let mut ptr = args[0].immediate();\n-                    if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                    if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                         ptr = self.pointercast(ptr, self.type_ptr_to(ty.gcc_type(self)));\n                     }\n                     let load = self.volatile_load(ptr.get_type(), ptr);\n@@ -309,6 +309,18 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     return;\n                 }\n \n+                sym::ptr_mask => {\n+                    let usize_type = self.context.new_type::<usize>();\n+                    let void_ptr_type = self.context.new_type::<*const ()>();\n+\n+                    let ptr = args[0].immediate();\n+                    let mask = args[1].immediate();\n+\n+                    let addr = self.bitcast(ptr, usize_type);\n+                    let masked = self.and(addr, mask);\n+                    self.bitcast(masked, void_ptr_type)\n+                },\n+                \n                 _ if name_str.starts_with(\"simd_\") => {\n                     match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                         Ok(llval) => llval,\n@@ -320,7 +332,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.gcc_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);\n@@ -416,7 +428,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n         }\n-        else if let PassMode::Cast(cast) = self.mode {\n+        else if let PassMode::Cast(ref cast, _) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n@@ -481,7 +493,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n             },\n-            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(_) => {\n+            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(..) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             },"}, {"sha": "223466fb9b51f26533243aa178b051483b563473", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -19,6 +19,7 @@\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n \n+extern crate rustc_apfloat;\n extern crate rustc_ast;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;"}, {"sha": "74115353aaf76267fc9e82e0710b90c29b3a157c", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -13,6 +13,7 @@ cstr = \"0.2\"\n libc = \"0.2\"\n libloading = \"0.7.1\"\n measureme = \"10.0.0\"\n+object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc-demangle = \"0.1.21\""}, {"sha": "0ce161d7e756cfbc2960375df513f12bd917733f", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -213,7 +213,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             OperandValue::Ref(val, None, self.layout.align.abi).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n-        } else if let PassMode::Cast(cast) = self.mode {\n+        } else if let PassMode::Cast(cast, _) = &self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n@@ -283,7 +283,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             }\n             PassMode::Direct(_)\n             | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ }\n-            | PassMode::Cast(_) => {\n+            | PassMode::Cast(..) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             }\n@@ -325,33 +325,26 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         // Ignore \"extra\" args from the call site for C variadic functions.\n         // Only the \"fixed\" args are part of the LLVM function signature.\n-        let args = if self.c_variadic { &self.args[..self.fixed_count] } else { &self.args };\n+        let args =\n+            if self.c_variadic { &self.args[..self.fixed_count as usize] } else { &self.args };\n \n-        let args_capacity: usize = args.iter().map(|arg|\n-            if arg.pad.is_some() { 1 } else { 0 } +\n-            if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n-        ).sum();\n+        // This capacity calculation is approximate.\n         let mut llargument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 } + args_capacity,\n+            self.args.len() + if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 },\n         );\n \n-        let llreturn_ty = match self.ret.mode {\n+        let llreturn_ty = match &self.ret.mode {\n             PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_llvm_type(cx),\n-            PassMode::Cast(cast) => cast.llvm_type(cx),\n+            PassMode::Cast(cast, _) => cast.llvm_type(cx),\n             PassMode::Indirect { .. } => {\n                 llargument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                 cx.type_void()\n             }\n         };\n \n         for arg in args {\n-            // add padding\n-            if let Some(ty) = arg.pad {\n-                llargument_tys.push(ty.llvm_type(cx));\n-            }\n-\n-            let llarg_ty = match arg.mode {\n+            let llarg_ty = match &arg.mode {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n@@ -366,7 +359,13 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n-                PassMode::Cast(cast) => cast.llvm_type(cx),\n+                PassMode::Cast(cast, pad_i32) => {\n+                    // add padding\n+                    if *pad_i32 {\n+                        llargument_tys.push(Reg::i32().llvm_type(cx));\n+                    }\n+                    cast.llvm_type(cx)\n+                }\n                 PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n                     cx.type_ptr_to(arg.memory_ty(cx))\n                 }\n@@ -426,46 +425,46 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             i += 1;\n             i - 1\n         };\n-        match self.ret.mode {\n-            PassMode::Direct(ref attrs) => {\n+        match &self.ret.mode {\n+            PassMode::Direct(attrs) => {\n                 attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n             }\n-            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+            PassMode::Indirect { attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(attrs);\n                 let sret = llvm::CreateStructRetAttr(cx.llcx, self.ret.layout.llvm_type(cx));\n                 attributes::apply_to_llfn(llfn, llvm::AttributePlace::Argument(i), &[sret]);\n             }\n-            PassMode::Cast(cast) => {\n+            PassMode::Cast(cast, _) => {\n                 cast.attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n             }\n             _ => {}\n         }\n-        for arg in &self.args {\n-            if arg.pad.is_some() {\n-                apply(&ArgAttributes::new());\n-            }\n-            match arg.mode {\n+        for arg in self.args.iter() {\n+            match &arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                PassMode::Indirect { attrs, extra_attrs: None, on_stack: true } => {\n                     let i = apply(attrs);\n                     let byval = llvm::CreateByValAttr(cx.llcx, arg.layout.llvm_type(cx));\n                     attributes::apply_to_llfn(llfn, llvm::AttributePlace::Argument(i), &[byval]);\n                 }\n-                PassMode::Direct(ref attrs)\n-                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                PassMode::Direct(attrs)\n+                | PassMode::Indirect { attrs, extra_attrs: None, on_stack: false } => {\n                     apply(attrs);\n                 }\n-                PassMode::Indirect { ref attrs, extra_attrs: Some(ref extra_attrs), on_stack } => {\n+                PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack } => {\n                     assert!(!on_stack);\n                     apply(attrs);\n                     apply(extra_attrs);\n                 }\n-                PassMode::Pair(ref a, ref b) => {\n+                PassMode::Pair(a, b) => {\n                     apply(a);\n                     apply(b);\n                 }\n-                PassMode::Cast(cast) => {\n+                PassMode::Cast(cast, pad_i32) => {\n+                    if *pad_i32 {\n+                        apply(&ArgAttributes::new());\n+                    }\n                     apply(&cast.attrs);\n                 }\n             }\n@@ -488,17 +487,17 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             i += 1;\n             i - 1\n         };\n-        match self.ret.mode {\n-            PassMode::Direct(ref attrs) => {\n+        match &self.ret.mode {\n+            PassMode::Direct(attrs) => {\n                 attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, bx.cx, callsite);\n             }\n-            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+            PassMode::Indirect { attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(bx.cx, attrs);\n                 let sret = llvm::CreateStructRetAttr(bx.cx.llcx, self.ret.layout.llvm_type(bx));\n                 attributes::apply_to_callsite(callsite, llvm::AttributePlace::Argument(i), &[sret]);\n             }\n-            PassMode::Cast(cast) => {\n+            PassMode::Cast(cast, _) => {\n                 cast.attrs.apply_attrs_to_callsite(\n                     llvm::AttributePlace::ReturnValue,\n                     &bx.cx,\n@@ -517,13 +516,10 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 }\n             }\n         }\n-        for arg in &self.args {\n-            if arg.pad.is_some() {\n-                apply(bx.cx, &ArgAttributes::new());\n-            }\n-            match arg.mode {\n+        for arg in self.args.iter() {\n+            match &arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                PassMode::Indirect { attrs, extra_attrs: None, on_stack: true } => {\n                     let i = apply(bx.cx, attrs);\n                     let byval = llvm::CreateByValAttr(bx.cx.llcx, arg.layout.llvm_type(bx));\n                     attributes::apply_to_callsite(\n@@ -532,23 +528,22 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                         &[byval],\n                     );\n                 }\n-                PassMode::Direct(ref attrs)\n-                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                PassMode::Direct(attrs)\n+                | PassMode::Indirect { attrs, extra_attrs: None, on_stack: false } => {\n                     apply(bx.cx, attrs);\n                 }\n-                PassMode::Indirect {\n-                    ref attrs,\n-                    extra_attrs: Some(ref extra_attrs),\n-                    on_stack: _,\n-                } => {\n+                PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack: _ } => {\n                     apply(bx.cx, attrs);\n                     apply(bx.cx, extra_attrs);\n                 }\n-                PassMode::Pair(ref a, ref b) => {\n+                PassMode::Pair(a, b) => {\n                     apply(bx.cx, a);\n                     apply(bx.cx, b);\n                 }\n-                PassMode::Cast(cast) => {\n+                PassMode::Cast(cast, pad_i32) => {\n+                    if *pad_i32 {\n+                        apply(bx.cx, &ArgAttributes::new());\n+                    }\n                     apply(bx.cx, &cast.attrs);\n                 }\n             }"}, {"sha": "2e614e5dd88e7fc18068974f22e1e7a3a8a34df7", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,10 +8,11 @@ use std::path::{Path, PathBuf};\n use std::ptr;\n use std::str;\n \n+use crate::common;\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n-use rustc_session::cstore::{DllCallingConvention, DllImport};\n+use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n \n /// Helper for adding many files to an archive.\n@@ -111,21 +112,18 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n         };\n \n         let target = &sess.target;\n-        let mingw_gnu_toolchain = target.vendor == \"pc\"\n-            && target.os == \"windows\"\n-            && target.env == \"gnu\"\n-            && target.abi.is_empty();\n+        let mingw_gnu_toolchain = common::is_mingw_gnu_toolchain(target);\n \n         let import_name_and_ordinal_vector: Vec<(String, Option<u16>)> = dll_imports\n             .iter()\n             .map(|import: &DllImport| {\n                 if sess.target.arch == \"x86\" {\n                     (\n-                        LlvmArchiveBuilder::i686_decorated_name(import, mingw_gnu_toolchain),\n-                        import.ordinal,\n+                        common::i686_decorated_name(import, mingw_gnu_toolchain, false),\n+                        import.ordinal(),\n                     )\n                 } else {\n-                    (import.name.to_string(), import.ordinal)\n+                    (import.name.to_string(), import.ordinal())\n                 }\n             })\n             .collect();\n@@ -159,6 +157,9 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n                 }\n             };\n \n+            // --no-leading-underscore: For the `import_name_type` feature to work, we need to be\n+            // able to control the *exact* spelling of each of the symbols that are being imported:\n+            // hence we don't want `dlltool` adding leading underscores automatically.\n             let dlltool = find_binutils_dlltool(sess);\n             let result = std::process::Command::new(dlltool)\n                 .args([\n@@ -168,6 +169,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n                     lib_name,\n                     \"-l\",\n                     output_path.to_str().unwrap(),\n+                    \"--no-leading-underscore\",\n                 ])\n                 .output();\n \n@@ -322,22 +324,6 @@ impl<'a> LlvmArchiveBuilder<'a> {\n             ret\n         }\n     }\n-\n-    fn i686_decorated_name(import: &DllImport, mingw: bool) -> String {\n-        let name = import.name;\n-        let prefix = if mingw { \"\" } else { \"_\" };\n-\n-        match import.calling_convention {\n-            DllCallingConvention::C => format!(\"{}{}\", prefix, name),\n-            DllCallingConvention::Stdcall(arg_list_size) => {\n-                format!(\"{}{}@{}\", prefix, name, arg_list_size)\n-            }\n-            DllCallingConvention::Fastcall(arg_list_size) => format!(\"@{}@{}\", name, arg_list_size),\n-            DllCallingConvention::Vectorcall(arg_list_size) => {\n-                format!(\"{}@@{}\", name, arg_list_size)\n-            }\n-        }\n-    }\n }\n \n fn string_to_io_error(s: String) -> io::Error {"}, {"sha": "e4af6269abc5305870515a832baf27da3111b677", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,15 +1,16 @@\n use crate::back::write::{\n     self, save_temp_bitcode, to_llvm_opt_settings, with_llvm_pmb, DiagnosticHandlers,\n };\n-use crate::llvm::archive_ro::ArchiveRO;\n use crate::llvm::{self, build_string, False, True};\n use crate::{llvm_util, LlvmCodegenBackend, ModuleLlvm};\n+use object::read::archive::ArchiveFile;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, TargetMachineFactoryConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{looks_like_rust_object_file, ModuleCodegen, ModuleKind};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::memmap::Mmap;\n use rustc_errors::{FatalError, Handler};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n@@ -107,14 +108,24 @@ fn prepare_lto(\n                     .extend(exported_symbols[&cnum].iter().filter_map(symbol_filter));\n             }\n \n-            let archive = ArchiveRO::open(path).expect(\"wanted an rlib\");\n+            let archive_data = unsafe {\n+                Mmap::map(std::fs::File::open(&path).expect(\"couldn't open rlib\"))\n+                    .expect(\"couldn't map rlib\")\n+            };\n+            let archive = ArchiveFile::parse(&*archive_data).expect(\"wanted an rlib\");\n             let obj_files = archive\n-                .iter()\n-                .filter_map(|child| child.ok().and_then(|c| c.name().map(|name| (name, c))))\n+                .members()\n+                .filter_map(|child| {\n+                    child.ok().and_then(|c| {\n+                        std::str::from_utf8(c.name()).ok().map(|name| (name.trim(), c))\n+                    })\n+                })\n                 .filter(|&(name, _)| looks_like_rust_object_file(name));\n             for (name, child) in obj_files {\n                 info!(\"adding bitcode from {}\", name);\n-                match get_bitcode_slice_from_object_data(child.data()) {\n+                match get_bitcode_slice_from_object_data(\n+                    child.data(&*archive_data).expect(\"corrupt rlib\"),\n+                ) {\n                     Ok(data) => {\n                         let module = SerializedModule::FromRlib(data.to_vec());\n                         upstream_modules.push((module, CString::new(name).unwrap()));"}, {"sha": "e7e373bf45d11043f9e3ba32bd18d09f10313322", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -725,11 +725,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n-    fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+    fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.fptoint_sat(false, val, dest_ty)\n     }\n \n-    fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+    fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         self.fptoint_sat(true, val, dest_ty)\n     }\n \n@@ -1429,12 +1429,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn fptoint_sat(\n-        &mut self,\n-        signed: bool,\n-        val: &'ll Value,\n-        dest_ty: &'ll Type,\n-    ) -> Option<&'ll Value> {\n+    fn fptoint_sat(&mut self, signed: bool, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         let src_ty = self.cx.val_ty(val);\n         let (float_ty, int_ty, vector_length) = if self.cx.type_kind(src_ty) == TypeKind::Vector {\n             assert_eq!(self.cx.vector_length(src_ty), self.cx.vector_length(dest_ty));\n@@ -1459,7 +1454,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n         };\n         let f = self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n-        Some(self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None))\n+        self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None)\n     }\n \n     pub(crate) fn landing_pad("}, {"sha": "d55f995b933a6f6ec4935c8bf712247a0fcd9762", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -6,6 +6,7 @@\n \n use crate::abi::FnAbiLlvmExt;\n use crate::attributes;\n+use crate::common;\n use crate::context::CodegenCx;\n use crate::llvm;\n use crate::value::Value;\n@@ -79,13 +80,18 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n             llfn\n         }\n     } else {\n-        let llfn = cx.declare_fn(sym, fn_abi);\n+        let instance_def_id = instance.def_id();\n+        let llfn = if tcx.sess.target.arch == \"x86\" &&\n+            let Some(dllimport) = common::get_dllimport(tcx, instance_def_id, sym)\n+        {\n+            cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi)\n+        } else {\n+            cx.declare_fn(sym, fn_abi)\n+        };\n         debug!(\"get_fn: not casting pointer!\");\n \n         attributes::from_fn_attrs(cx, llfn, instance);\n \n-        let instance_def_id = instance.def_id();\n-\n         // Apply an appropriate linkage/visibility value to our item that we\n         // just declared.\n         //"}, {"sha": "63d3bb40a3fe0c448463f9d32253b984b7476424", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -10,12 +10,17 @@ use crate::value::Value;\n use rustc_ast::Mutability;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::bug;\n use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::cstore::{DllCallingConvention, DllImport, PeImportNameType};\n use rustc_target::abi::{self, AddressSpace, HasDataLayout, Pointer, Size};\n+use rustc_target::spec::Target;\n \n use libc::{c_char, c_uint};\n+use std::fmt::Write;\n use tracing::debug;\n \n /*\n@@ -357,3 +362,74 @@ fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n fn try_as_const_integral(v: &Value) -> Option<&ConstantInt> {\n     unsafe { llvm::LLVMIsAConstantInt(v) }\n }\n+\n+pub(crate) fn get_dllimport<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    id: DefId,\n+    name: &str,\n+) -> Option<&'tcx DllImport> {\n+    tcx.native_library(id)\n+        .map(|lib| lib.dll_imports.iter().find(|di| di.name.as_str() == name))\n+        .flatten()\n+}\n+\n+pub(crate) fn is_mingw_gnu_toolchain(target: &Target) -> bool {\n+    target.vendor == \"pc\" && target.os == \"windows\" && target.env == \"gnu\" && target.abi.is_empty()\n+}\n+\n+pub(crate) fn i686_decorated_name(\n+    dll_import: &DllImport,\n+    mingw: bool,\n+    disable_name_mangling: bool,\n+) -> String {\n+    let name = dll_import.name.as_str();\n+\n+    let (add_prefix, add_suffix) = match dll_import.import_name_type {\n+        Some(PeImportNameType::NoPrefix) => (false, true),\n+        Some(PeImportNameType::Undecorated) => (false, false),\n+        _ => (true, true),\n+    };\n+\n+    // Worst case: +1 for disable name mangling, +1 for prefix, +4 for suffix (@@__).\n+    let mut decorated_name = String::with_capacity(name.len() + 6);\n+\n+    if disable_name_mangling {\n+        // LLVM uses a binary 1 ('\\x01') prefix to a name to indicate that mangling needs to be disabled.\n+        decorated_name.push('\\x01');\n+    }\n+\n+    let prefix = if add_prefix && dll_import.is_fn {\n+        match dll_import.calling_convention {\n+            DllCallingConvention::C | DllCallingConvention::Vectorcall(_) => None,\n+            DllCallingConvention::Stdcall(_) => (!mingw\n+                || dll_import.import_name_type == Some(PeImportNameType::Decorated))\n+            .then_some('_'),\n+            DllCallingConvention::Fastcall(_) => Some('@'),\n+        }\n+    } else if !dll_import.is_fn && !mingw {\n+        // For static variables, prefix with '_' on MSVC.\n+        Some('_')\n+    } else {\n+        None\n+    };\n+    if let Some(prefix) = prefix {\n+        decorated_name.push(prefix);\n+    }\n+\n+    decorated_name.push_str(name);\n+\n+    if add_suffix && dll_import.is_fn {\n+        match dll_import.calling_convention {\n+            DllCallingConvention::C => {}\n+            DllCallingConvention::Stdcall(arg_list_size)\n+            | DllCallingConvention::Fastcall(arg_list_size) => {\n+                write!(&mut decorated_name, \"@{}\", arg_list_size).unwrap();\n+            }\n+            DllCallingConvention::Vectorcall(arg_list_size) => {\n+                write!(&mut decorated_name, \"@@{}\", arg_list_size).unwrap();\n+            }\n+        }\n+    }\n+\n+    decorated_name\n+}"}, {"sha": "d3e33da27993c6b3286765128fd0b7ca6ce04952", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,5 +1,5 @@\n use crate::base;\n-use crate::common::CodegenCx;\n+use crate::common::{self, CodegenCx};\n use crate::debuginfo;\n use crate::llvm::{self, True};\n use crate::llvm_util;\n@@ -27,12 +27,12 @@ use tracing::debug;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n     let alloc = alloc.inner();\n-    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.provenance().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n-    // Note: this function may call `inspect_with_uninit_and_ptr_outside_interpreter`,\n-    // so `range` must be within the bounds of `alloc` and not contain or overlap a relocation.\n+    // Note: this function may call `inspect_with_uninit_and_ptr_outside_interpreter`, so `range`\n+    // must be within the bounds of `alloc` and not contain or overlap a pointer provenance.\n     fn append_chunks_of_init_and_uninit_bytes<'ll, 'a, 'b>(\n         llvals: &mut Vec<&'ll Value>,\n         cx: &'a CodegenCx<'ll, 'b>,\n@@ -79,12 +79,12 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n     }\n \n     let mut next_offset = 0;\n-    for &(offset, alloc_id) in alloc.relocations().iter() {\n+    for &(offset, alloc_id) in alloc.provenance().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // This `inspect` is okay since we have checked that there is no provenance, it\n             // is within the bounds of the allocation, and it doesn't affect interpreter execution\n             // (we inspect the result after interpreter execution).\n             append_chunks_of_init_and_uninit_bytes(&mut llvals, cx, alloc, next_offset..offset);\n@@ -93,7 +93,7 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n             dl.endian,\n             // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n             // affect interpreter execution (we inspect the result after interpreter execution),\n-            // and we properly interpret the relocation as a relocation pointer offset.\n+            // and we properly interpret the provenance as a relocation pointer offset.\n             alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n         )\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n@@ -121,7 +121,7 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n     }\n     if alloc.len() >= next_offset {\n         let range = next_offset..alloc.len();\n-        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // This `inspect` is okay since we have check that it is after all provenance, it is\n         // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n         // inspect the result after interpreter execution).\n         append_chunks_of_init_and_uninit_bytes(&mut llvals, cx, alloc, range);\n@@ -160,7 +160,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n     attrs: &CodegenFnAttrs,\n     ty: Ty<'tcx>,\n     sym: &str,\n-    span_def_id: DefId,\n+    def_id: DefId,\n ) -> &'ll Value {\n     let llty = cx.layout_of(ty).llvm_type(cx);\n     if let Some(linkage) = attrs.linkage {\n@@ -175,7 +175,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n             cx.layout_of(mt.ty).llvm_type(cx)\n         } else {\n             cx.sess().span_fatal(\n-                cx.tcx.def_span(span_def_id),\n+                cx.tcx.def_span(def_id),\n                 \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n             )\n         };\n@@ -194,14 +194,18 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n             real_name.push_str(sym);\n             let g2 = cx.define_global(&real_name, llty).unwrap_or_else(|| {\n                 cx.sess().span_fatal(\n-                    cx.tcx.def_span(span_def_id),\n+                    cx.tcx.def_span(def_id),\n                     &format!(\"symbol `{}` is already defined\", &sym),\n                 )\n             });\n             llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n             llvm::LLVMSetInitializer(g2, g1);\n             g2\n         }\n+    } else if cx.tcx.sess.target.arch == \"x86\" &&\n+        let Some(dllimport) = common::get_dllimport(cx.tcx, def_id, sym)\n+    {\n+        cx.declare_global(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&cx.tcx.sess.target), true), llty)\n     } else {\n         // Generate an external declaration.\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n@@ -475,15 +479,15 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n                 if self.tcx.sess.target.is_like_osx {\n-                    // The `inspect` method is okay here because we checked relocations, and\n+                    // The `inspect` method is okay here because we checked for provenance, and\n                     // because we are doing this access to inspect the final interpreter state\n                     // (not as part of the interpreter execution).\n                     //\n                     // FIXME: This check requires that the (arbitrary) value of undefined bytes\n                     // happens to be zero. Instead, we should only check the value of defined bytes\n                     // and set all undefined bytes to zero if this allocation is headed for the\n                     // BSS.\n-                    let all_bytes_are_zero = alloc.relocations().is_empty()\n+                    let all_bytes_are_zero = alloc.provenance().is_empty()\n                         && alloc\n                             .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n@@ -507,9 +511,9 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                         section.as_str().as_ptr().cast(),\n                         section.as_str().len() as c_uint,\n                     );\n-                    assert!(alloc.relocations().is_empty());\n+                    assert!(alloc.provenance().is_empty());\n \n-                    // The `inspect` method is okay here because we checked relocations, and\n+                    // The `inspect` method is okay here because we checked for provenance, and\n                     // because we are doing this access to inspect the final interpreter state (not\n                     // as part of the interpreter execution).\n                     let bytes ="}, {"sha": "67ffc7cb9511f3939ca94d7e951e1b0c16805bc8", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -886,6 +886,9 @@ impl<'ll> CodegenCx<'ll, '_> {\n             ifn!(\"llvm.dbg.declare\", fn(t_metadata, t_metadata) -> void);\n             ifn!(\"llvm.dbg.value\", fn(t_metadata, t_i64, t_metadata) -> void);\n         }\n+\n+        ifn!(\"llvm.ptrmask\", fn(i8p, t_isize) -> i8p);\n+\n         None\n     }\n "}, {"sha": "d0a6f216858b61575238b6101f2a34fd151d8bd0", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1500,24 +1500,18 @@ fn vcall_visibility_metadata<'ll, 'tcx>(\n         // If there is not LTO and the visibility in public, we have to assume that the vtable can\n         // be seen from anywhere. With multiple CGUs, the vtable is quasi-public.\n         (Lto::No | Lto::ThinLocal, Visibility::Public, _)\n-        | (Lto::No, Visibility::Restricted(_) | Visibility::Invisible, false) => {\n-            VCallVisibility::Public\n-        }\n+        | (Lto::No, Visibility::Restricted(_), false) => VCallVisibility::Public,\n         // With LTO and a quasi-public visibility, the usages of the functions of the vtable are\n         // all known by the `LinkageUnit`.\n         // FIXME: LLVM only supports this optimization for `Lto::Fat` currently. Once it also\n         // supports `Lto::Thin` the `VCallVisibility` may have to be adjusted for those.\n         (Lto::Fat | Lto::Thin, Visibility::Public, _)\n-        | (\n-            Lto::ThinLocal | Lto::Thin | Lto::Fat,\n-            Visibility::Restricted(_) | Visibility::Invisible,\n-            false,\n-        ) => VCallVisibility::LinkageUnit,\n+        | (Lto::ThinLocal | Lto::Thin | Lto::Fat, Visibility::Restricted(_), false) => {\n+            VCallVisibility::LinkageUnit\n+        }\n         // If there is only one CGU, private vtables can only be seen by that CGU/translation unit\n         // and therefore we know of all usages of functions in the vtable.\n-        (_, Visibility::Restricted(_) | Visibility::Invisible, true) => {\n-            VCallVisibility::TranslationUnit\n-        }\n+        (_, Visibility::Restricted(_), true) => VCallVisibility::TranslationUnit,\n     };\n \n     let trait_ref_typeid = typeid_for_trait_ref(cx.tcx, trait_ref);"}, {"sha": "3d789904707c0e80758d2849b3c4e342698ac1a5", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -71,6 +71,7 @@ fn get_simple_intrinsic<'ll>(\n         sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n         sym::roundf32 => \"llvm.round.f32\",\n         sym::roundf64 => \"llvm.round.f64\",\n+        sym::ptr_mask => \"llvm.ptrmask\",\n         _ => return None,\n     };\n     Some(cx.get_intrinsic(llvm_name))\n@@ -161,7 +162,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n                 let ptr = args[0].immediate();\n-                let load = if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                let load = if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                     let llty = ty.llvm_type(self);\n                     let ptr = self.pointercast(ptr, self.type_ptr_to(llty));\n                     self.volatile_load(llty, ptr)\n@@ -374,7 +375,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.llvm_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);"}, {"sha": "636d689a34b5a900ef1ad0ae41484ac5147b4729", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(hash_raw_entry)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(extern_types)]\n #![feature(once_cell)]"}, {"sha": "7d948970223451361bfe606341afa17a07c2ee6d", "filename": "compiler/rustc_codegen_llvm/src/llvm/archive_ro.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Farchive_ro.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -83,17 +83,6 @@ impl<'a> Child<'a> {\n             }\n         }\n     }\n-\n-    pub fn data(&self) -> &'a [u8] {\n-        unsafe {\n-            let mut data_len = 0;\n-            let data_ptr = super::LLVMRustArchiveChildData(self.raw, &mut data_len);\n-            if data_ptr.is_null() {\n-                panic!(\"failed to read data from archive child\");\n-            }\n-            slice::from_raw_parts(data_ptr as *const u8, data_len as usize)\n-        }\n-    }\n }\n \n impl<'a> Drop for Child<'a> {"}, {"sha": "172684414fc5534495d2218c26062c80306f4b94", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2389,7 +2389,6 @@ extern \"C\" {\n         AIR: &ArchiveIterator<'a>,\n     ) -> Option<&'a mut ArchiveChild<'a>>;\n     pub fn LLVMRustArchiveChildName(ACR: &ArchiveChild<'_>, size: &mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildData(ACR: &ArchiveChild<'_>, size: &mut size_t) -> *const c_char;\n     pub fn LLVMRustArchiveChildFree<'a>(ACR: &'a mut ArchiveChild<'a>);\n     pub fn LLVMRustArchiveIteratorFree<'a>(AIR: &'a mut ArchiveIterator<'a>);\n     pub fn LLVMRustDestroyArchive(AR: &'static mut Archive);"}, {"sha": "d868e3d56ba6b33d240fe92b65b7e003ebe45726", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -26,7 +26,6 @@ rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }\n-rustc_apfloat = { path = \"../rustc_apfloat\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "d2f2c7bf7988ad84ea14ffd0563c5961fb631c7c", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1958,7 +1958,6 @@ fn linker_with_args<'a>(\n     // Upstream rust libraries are not supposed to depend on our local native\n     // libraries as that would violate the structure of the DAG, in that\n     // scenario they are required to link to them as well in a shared fashion.\n-    // (The current implementation still doesn't prevent it though, see the FIXME below.)\n     //\n     // Note that upstream rust libraries may contain native dependencies as\n     // well, but they also can't depend on what we just started to add to the\n@@ -1979,15 +1978,16 @@ fn linker_with_args<'a>(\n     // and move this option back to the top.\n     cmd.add_as_needed();\n \n-    // FIXME: Move this below to other native libraries\n-    // (or alternatively link all native libraries after their respective crates).\n-    // This change is somewhat breaking in practice due to local static libraries being linked\n-    // as whole-archive (#85144), so removing whole-archive may be a pre-requisite.\n+    // Local native libraries of all kinds.\n+    //\n+    // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n+    // external build system already has the native dependencies defined, and it\n+    // will provide them to the linker itself.\n     if sess.opts.unstable_opts.link_native_libraries {\n         add_local_native_libraries(cmd, sess, codegen_results);\n     }\n \n-    // Upstream rust libraries and their non-bundled static libraries\n+    // Upstream rust libraries and their (possibly bundled) static native libraries.\n     add_upstream_rust_crates(\n         cmd,\n         sess,\n@@ -1997,11 +1997,11 @@ fn linker_with_args<'a>(\n         tmpdir,\n     );\n \n-    // Upstream dynamic native libraries linked with `#[link]` attributes at and `-l`\n-    // command line options.\n-    // If -Zlink-native-libraries=false is set, then the assumption is that an\n-    // external build system already has the native dependencies defined, and it\n-    // will provide them to the linker itself.\n+    // Dynamic native libraries from upstream crates.\n+    //\n+    // FIXME: Merge this to `add_upstream_rust_crates` so that all native libraries are linked\n+    // together with their respective upstream crates, and in their originally specified order.\n+    // This may be slightly breaking due to our use of `--as-needed` and needs a crater run.\n     if sess.opts.unstable_opts.link_native_libraries {\n         add_upstream_native_libraries(cmd, sess, codegen_results);\n     }\n@@ -2415,7 +2415,7 @@ fn add_upstream_rust_crates<'a>(\n                 // or is an rlib already included via some other dylib crate, the symbols from\n                 // native libs will have already been included in that dylib.\n                 //\n-                // If -Zlink-native-libraries=false is set, then the assumption is that an\n+                // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n                 // external build system already has the native dependencies defined, and it\n                 // will provide them to the linker itself.\n                 if sess.opts.unstable_opts.link_native_libraries {"}, {"sha": "b92e146bee2af5a95b1461d7a7da35813be74971", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -187,12 +187,12 @@ pub enum MetadataPosition {\n     Last,\n }\n \n-// For rlibs we \"pack\" rustc metadata into a dummy object file. When rustc\n-// creates a dylib crate type it will pass `--whole-archive` (or the\n-// platform equivalent) to include all object files from an rlib into the\n-// final dylib itself. This causes linkers to iterate and try to include all\n-// files located in an archive, so if metadata is stored in an archive then\n-// it needs to be of a form that the linker will be able to process.\n+// For rlibs we \"pack\" rustc metadata into a dummy object file.\n+//\n+// Historically it was needed because rustc linked rlibs as whole-archive in some cases.\n+// In that case linkers try to include all files located in an archive, so if metadata is stored\n+// in an archive then it needs to be of a form that the linker is able to process.\n+// Now it's not clear whether metadata still needs to be wrapped into an object file or not.\n //\n // Note, though, that we don't actually want this metadata to show up in any\n // final output of the compiler. Instead this is purely for rustc's own"}, {"sha": "32b340832ce289625a283503b9bdf090c2a608c6", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -103,18 +103,14 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             }\n         })\n         .map(|def_id| {\n-            let (export_level, used) = if special_runtime_crate {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())).name;\n-                // We won't link right if these symbols are stripped during LTO.\n-                let used = match name {\n-                    \"rust_eh_personality\"\n-                    | \"rust_eh_register_frames\"\n-                    | \"rust_eh_unregister_frames\" => true,\n-                    _ => false,\n-                };\n-                (SymbolExportLevel::Rust, used)\n+            // We won't link right if this symbol is stripped during LTO.\n+            let name = tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())).name;\n+            let used = name == \"rust_eh_personality\";\n+\n+            let export_level = if special_runtime_crate {\n+                SymbolExportLevel::Rust\n             } else {\n-                (symbol_export_level(tcx, def_id.to_def_id()), false)\n+                symbol_export_level(tcx, def_id.to_def_id())\n             };\n             let codegen_attrs = tcx.codegen_fn_attrs(def_id.to_def_id());\n             debug!("}, {"sha": "68f3b19b715ad7563a672184f44ce9aa895f7aa0", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1892,7 +1892,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n             }\n         });\n \n-        sess.cgu_reuse_tracker.check_expected_reuse(sess.diagnostic());\n+        sess.cgu_reuse_tracker.check_expected_reuse(sess);\n \n         sess.abort_if_errors();\n "}, {"sha": "4c6be3f910827d7886b48e2ebbada31c3d701a86", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -151,6 +151,7 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n+                // A NOP cast that doesn't actually change anything, should be allowed even with invalid vtables.\n                 return old_info;\n             }\n "}, {"sha": "0faf51b062b4ce81f684c936da6a9ab68d3a94ef", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -168,6 +168,13 @@ pub struct CodegenResults {\n     pub crate_info: CrateInfo,\n }\n \n+pub enum CodegenErrors<'a> {\n+    WrongFileType,\n+    EmptyVersionNumber,\n+    EncodingVersionMismatch { version_array: String, rlink_version: u32 },\n+    RustcVersionMismatch { rustc_version: String, current_version: &'a str },\n+}\n+\n pub fn provide(providers: &mut Providers) {\n     crate::back::symbol_export::provide(providers);\n     crate::base::provide(providers);\n@@ -212,30 +219,34 @@ impl CodegenResults {\n         encoder.finish()\n     }\n \n-    pub fn deserialize_rlink(data: Vec<u8>) -> Result<Self, String> {\n+    pub fn deserialize_rlink<'a>(data: Vec<u8>) -> Result<Self, CodegenErrors<'a>> {\n         // The Decodable machinery is not used here because it panics if the input data is invalid\n         // and because its internal representation may change.\n         if !data.starts_with(RLINK_MAGIC) {\n-            return Err(\"The input does not look like a .rlink file\".to_string());\n+            return Err(CodegenErrors::WrongFileType);\n         }\n         let data = &data[RLINK_MAGIC.len()..];\n         if data.len() < 4 {\n-            return Err(\"The input does not contain version number\".to_string());\n+            return Err(CodegenErrors::EmptyVersionNumber);\n         }\n \n         let mut version_array: [u8; 4] = Default::default();\n         version_array.copy_from_slice(&data[..4]);\n         if u32::from_be_bytes(version_array) != RLINK_VERSION {\n-            return Err(\".rlink file was produced with encoding version {version_array}, but the current version is {RLINK_VERSION}\".to_string());\n+            return Err(CodegenErrors::EncodingVersionMismatch {\n+                version_array: String::from_utf8_lossy(&version_array).to_string(),\n+                rlink_version: RLINK_VERSION,\n+            });\n         }\n \n         let mut decoder = MemDecoder::new(&data[4..], 0);\n         let rustc_version = decoder.read_str();\n         let current_version = RUSTC_VERSION.unwrap();\n         if rustc_version != current_version {\n-            return Err(format!(\n-                \".rlink file was produced by rustc version {rustc_version}, but the current version is {current_version}.\"\n-            ));\n+            return Err(CodegenErrors::RustcVersionMismatch {\n+                rustc_version: rustc_version.to_string(),\n+                current_version,\n+            });\n         }\n \n         let codegen_results = CodegenResults::decode(&mut decoder);"}, {"sha": "f8e982b775189f7ed45ae19b5f0e572bb657f3af", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::*;\n \n-use rustc_middle::ty::{self, subst::GenericArgKind, ExistentialPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n use rustc_session::config::Lto;\n use rustc_symbol_mangling::typeid_for_trait_ref;\n use rustc_target::abi::call::FnAbi;\n@@ -29,7 +29,7 @@ impl<'a, 'tcx> VirtualIndex {\n             && bx.cx().sess().lto() == Lto::Fat\n         {\n             let typeid =\n-                bx.typeid_metadata(typeid_for_trait_ref(bx.tcx(), get_trait_ref(bx.tcx(), ty)));\n+                bx.typeid_metadata(typeid_for_trait_ref(bx.tcx(), expect_dyn_trait_in_self(ty)));\n             let vtable_byte_offset = self.0 * bx.data_layout().pointer_size.bytes();\n             let type_checked_load = bx.type_checked_load(llvtable, vtable_byte_offset, typeid);\n             let func = bx.extract_value(type_checked_load, 0);\n@@ -64,17 +64,13 @@ impl<'a, 'tcx> VirtualIndex {\n     }\n }\n \n-fn get_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ty::PolyExistentialTraitRef<'tcx> {\n+/// This takes a valid `self` receiver type and extracts the principal trait\n+/// ref of the type.\n+fn expect_dyn_trait_in_self<'tcx>(ty: Ty<'tcx>) -> ty::PolyExistentialTraitRef<'tcx> {\n     for arg in ty.peel_refs().walk() {\n         if let GenericArgKind::Type(ty) = arg.unpack() {\n-            if let ty::Dynamic(trait_refs, _) = ty.kind() {\n-                return trait_refs[0].map_bound(|trait_ref| match trait_ref {\n-                    ExistentialPredicate::Trait(tr) => tr,\n-                    ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n-                    ExistentialPredicate::AutoTrait(_) => {\n-                        bug!(\"auto traits don't have functions\")\n-                    }\n-                });\n+            if let ty::Dynamic(data, _) = ty.kind() {\n+                return data.principal().expect(\"expected principal trait object\");\n             }\n         }\n     }"}, {"sha": "c7617d2e464fab1e7b867c373e3b20e23185bd47", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -266,7 +266,7 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n         result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n         mir: &mir::Body<'tcx>,\n     ) {\n-        for (bb, data) in mir.basic_blocks().iter_enumerated() {\n+        for (bb, data) in mir.basic_blocks.iter_enumerated() {\n             match data.terminator().kind {\n                 TerminatorKind::Goto { .. }\n                 | TerminatorKind::Resume\n@@ -296,7 +296,7 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n     }\n \n     fn propagate<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>, mir: &mir::Body<'tcx>) {\n-        let mut funclet_succs = IndexVec::from_elem(None, mir.basic_blocks());\n+        let mut funclet_succs = IndexVec::from_elem(None, &mir.basic_blocks);\n \n         let mut set_successor = |funclet: mir::BasicBlock, succ| match funclet_succs[funclet] {\n             ref mut s @ None => {\n@@ -359,7 +359,7 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n         }\n     }\n \n-    let mut result = IndexVec::from_elem(CleanupKind::NotCleanup, mir.basic_blocks());\n+    let mut result = IndexVec::from_elem(CleanupKind::NotCleanup, &mir.basic_blocks);\n \n     discover_masters(&mut result, mir);\n     propagate(&mut result, mir);"}, {"sha": "5c67d3b6431fd5f346438bde0fe17ecb19904f72", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 63, "deletions": 70, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n-use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode, Reg};\n use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n use rustc_target::spec::abi::Abi;\n \n@@ -324,7 +324,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.unreachable();\n             return;\n         }\n-        let llval = match self.fn_abi.ret.mode {\n+        let llval = match &self.fn_abi.ret.mode {\n             PassMode::Ignore | PassMode::Indirect { .. } => {\n                 bx.ret_void();\n                 return;\n@@ -339,7 +339,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            PassMode::Cast(cast_ty) => {\n+            PassMode::Cast(cast_ty, _) => {\n                 let op = match self.locals[mir::RETURN_PLACE] {\n                     LocalRef::Operand(Some(op)) => op,\n                     LocalRef::Operand(None) => bug!(\"use of return before def\"),\n@@ -360,7 +360,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         llval\n                     }\n                 };\n-                let ty = bx.cast_backend_type(&cast_ty);\n+                let ty = bx.cast_backend_type(cast_ty);\n                 let addr = bx.pointercast(llslot, bx.type_ptr_to(ty));\n                 bx.load(ty, addr, self.fn_abi.ret.layout.align.abi)\n             }\n@@ -798,58 +798,55 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let mut op = self.codegen_operand(&mut bx, arg);\n \n             if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n-                if let Pair(..) = op.val {\n-                    // In the case of Rc<Self>, we need to explicitly pass a\n-                    // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n-                    // that is understood elsewhere in the compiler as a method on\n-                    // `dyn Trait`.\n-                    // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n-                    // we get a value of a built-in pointer type\n-                    'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                        && !op.layout.ty.is_region_ptr()\n-                    {\n-                        for i in 0..op.layout.fields.count() {\n-                            let field = op.extract_field(&mut bx, i);\n-                            if !field.layout.is_zst() {\n-                                // we found the one non-zero-sized field that is allowed\n-                                // now find *its* non-zero-sized field, or stop if it's a\n-                                // pointer\n-                                op = field;\n-                                continue 'descend_newtypes;\n+                match op.val {\n+                    Pair(data_ptr, meta) => {\n+                        // In the case of Rc<Self>, we need to explicitly pass a\n+                        // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n+                        // that is understood elsewhere in the compiler as a method on\n+                        // `dyn Trait`.\n+                        // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n+                        // we get a value of a built-in pointer type\n+                        'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                            && !op.layout.ty.is_region_ptr()\n+                        {\n+                            for i in 0..op.layout.fields.count() {\n+                                let field = op.extract_field(&mut bx, i);\n+                                if !field.layout.is_zst() {\n+                                    // we found the one non-zero-sized field that is allowed\n+                                    // now find *its* non-zero-sized field, or stop if it's a\n+                                    // pointer\n+                                    op = field;\n+                                    continue 'descend_newtypes;\n+                                }\n                             }\n+\n+                            span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n                         }\n \n-                        span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n+                        // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n+                        // data pointer and vtable. Look up the method in the vtable, and pass\n+                        // the data pointer as the first argument\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta,\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr);\n+                        continue 'make_args;\n                     }\n-\n-                    // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n-                    // data pointer and vtable. Look up the method in the vtable, and pass\n-                    // the data pointer as the first argument\n-                    match op.val {\n-                        Pair(data_ptr, meta) => {\n-                            llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                                &mut bx,\n-                                meta,\n-                                op.layout.ty,\n-                                &fn_abi,\n-                            ));\n-                            llargs.push(data_ptr);\n-                            continue 'make_args;\n-                        }\n-                        other => bug!(\"expected a Pair, got {:?}\", other),\n+                    Ref(data_ptr, Some(meta), _) => {\n+                        // by-value dynamic dispatch\n+                        llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                            &mut bx,\n+                            meta,\n+                            op.layout.ty,\n+                            &fn_abi,\n+                        ));\n+                        llargs.push(data_ptr);\n+                        continue;\n                     }\n-                } else if let Ref(data_ptr, Some(meta), _) = op.val {\n-                    // by-value dynamic dispatch\n-                    llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n-                        &mut bx,\n-                        meta,\n-                        op.layout.ty,\n-                        &fn_abi,\n-                    ));\n-                    llargs.push(data_ptr);\n-                    continue;\n-                } else {\n-                    span_bug!(span, \"can't codegen a virtual call on {:?}\", op);\n+                    _ => span_bug!(span, \"can't codegen a virtual call on {:?}\", op),\n                 }\n             }\n \n@@ -1161,39 +1158,35 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         llargs: &mut Vec<Bx::Value>,\n         arg: &ArgAbi<'tcx, Ty<'tcx>>,\n     ) {\n-        // Fill padding with undef value, where applicable.\n-        if let Some(ty) = arg.pad {\n-            llargs.push(bx.const_undef(bx.reg_backend_type(&ty)))\n-        }\n-\n-        if arg.is_ignore() {\n-            return;\n-        }\n-\n-        if let PassMode::Pair(..) = arg.mode {\n-            match op.val {\n+        match arg.mode {\n+            PassMode::Ignore => return,\n+            PassMode::Cast(_, true) => {\n+                // Fill padding with undef value, where applicable.\n+                llargs.push(bx.const_undef(bx.reg_backend_type(&Reg::i32())));\n+            }\n+            PassMode::Pair(..) => match op.val {\n                 Pair(a, b) => {\n                     llargs.push(a);\n                     llargs.push(b);\n                     return;\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for pair argument\", op),\n-            }\n-        } else if arg.is_unsized_indirect() {\n-            match op.val {\n+            },\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => match op.val {\n                 Ref(a, Some(b), _) => {\n                     llargs.push(a);\n                     llargs.push(b);\n                     return;\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for unsized indirect argument\", op),\n-            }\n+            },\n+            _ => {}\n         }\n \n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => match arg.mode {\n-                PassMode::Indirect { .. } | PassMode::Cast(_) => {\n+                PassMode::Indirect { .. } | PassMode::Cast(..) => {\n                     let scratch = PlaceRef::alloca(bx, arg.layout);\n                     op.val.store(bx, scratch);\n                     (scratch.llval, scratch.align, true)\n@@ -1225,8 +1218,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if let PassMode::Cast(ty) = arg.mode {\n-                let llty = bx.cast_backend_type(&ty);\n+            if let PassMode::Cast(ty, _) = &arg.mode {\n+                let llty = bx.cast_backend_type(ty);\n                 let addr = bx.pointercast(llval, bx.type_ptr_to(llty));\n                 llval = bx.load(llty, addr, align.min(arg.layout.align.abi));\n             } else {\n@@ -1625,7 +1618,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n-                let op = if let PassMode::Cast(_) = ret_abi.mode {\n+                let op = if let PassMode::Cast(..) = ret_abi.mode {\n                     let tmp = PlaceRef::alloca(bx, ret_abi.layout);\n                     tmp.storage_live(bx);\n                     bx.store_arg(&ret_abi, llval, tmp);"}, {"sha": "16aad07194da8afa048c5fcf94a02a6caa5d134b", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -597,8 +597,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n-                let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(&ty));\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n+                let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(ty));\n                 let ptr = bx.pointercast(result.llval, ptr_llty);\n                 bx.store(llval, ptr, result.align);\n             } else {"}, {"sha": "d6bbcd99234553bf3173620c5fdc8d7c0a419674", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -150,13 +150,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let start_llbb = Bx::append_block(cx, llfn, \"start\");\n     let mut bx = Bx::build(cx, start_llbb);\n \n-    if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n+    if mir.basic_blocks.iter().any(|bb| bb.is_cleanup) {\n         bx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     let cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>> = mir\n-        .basic_blocks()\n+        .basic_blocks\n         .indices()\n         .map(|bb| if bb == mir::START_BLOCK { Some(start_llbb) } else { None })\n         .collect();\n@@ -172,8 +172,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         unreachable_block: None,\n         double_unwind_guard: None,\n         cleanup_kinds,\n-        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n-        funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks().len()),\n+        landing_pads: IndexVec::from_elem(None, &mir.basic_blocks),\n+        funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks.len()),\n         locals: IndexVec::new(),\n         debug_context,\n         per_local_var_debug_info: None,\n@@ -283,7 +283,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 for i in 0..tupled_arg_tys.len() {\n                     let arg = &fx.fn_abi.args[idx];\n                     idx += 1;\n-                    if arg.pad.is_some() {\n+                    if let PassMode::Cast(_, true) = arg.mode {\n                         llarg_idx += 1;\n                     }\n                     let pr_field = place.project_field(bx, i);\n@@ -309,7 +309,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n             let arg = &fx.fn_abi.args[idx];\n             idx += 1;\n-            if arg.pad.is_some() {\n+            if let PassMode::Cast(_, true) = arg.mode {\n                 llarg_idx += 1;\n             }\n "}, {"sha": "10cf8948b5a54fc55c73e100fc988f7752d7b607", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 3, "deletions": 154, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,6 +1,5 @@\n use super::abi::AbiBuilderMethods;\n use super::asm::AsmBuilderMethods;\n-use super::consts::ConstMethods;\n use super::coverageinfo::CoverageInfoBuilderMethods;\n use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n@@ -15,7 +14,6 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n \n-use rustc_apfloat::{ieee, Float, Round, Status};\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n@@ -188,8 +186,8 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn trunc(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn sext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n-    fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n-    fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Option<Self::Value>;\n+    fn fptoui_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n+    fn fptosi_sat(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptoui(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn fptosi(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n     fn uitofp(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n@@ -223,156 +221,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n             return if signed { self.fptosi(x, dest_ty) } else { self.fptoui(x, dest_ty) };\n         }\n \n-        let try_sat_result =\n-            if signed { self.fptosi_sat(x, dest_ty) } else { self.fptoui_sat(x, dest_ty) };\n-        if let Some(try_sat_result) = try_sat_result {\n-            return try_sat_result;\n-        }\n-\n-        let int_width = self.cx().int_width(int_ty);\n-        let float_width = self.cx().float_width(float_ty);\n-        // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n-        // destination integer type after rounding towards zero. This `undef` value can cause UB in\n-        // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n-        // Semantically, the mathematical value of the input is rounded towards zero to the next\n-        // mathematical integer, and then the result is clamped into the range of the destination\n-        // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n-        // the destination integer type. NaN is mapped to 0.\n-        //\n-        // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n-        // a value representable in int_ty.\n-        // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n-        // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n-        // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n-        // representable. Note that this only works if float_ty's exponent range is sufficiently large.\n-        // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n-        // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n-        // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n-        // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n-        // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-        let int_max = |signed: bool, int_width: u64| -> u128 {\n-            let shift_amount = 128 - int_width;\n-            if signed { i128::MAX as u128 >> shift_amount } else { u128::MAX >> shift_amount }\n-        };\n-        let int_min = |signed: bool, int_width: u64| -> i128 {\n-            if signed { i128::MIN >> (128 - int_width) } else { 0 }\n-        };\n-\n-        let compute_clamp_bounds_single = |signed: bool, int_width: u64| -> (u128, u128) {\n-            let rounded_min =\n-                ieee::Single::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n-            assert_eq!(rounded_min.status, Status::OK);\n-            let rounded_max =\n-                ieee::Single::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n-            assert!(rounded_max.value.is_finite());\n-            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-        };\n-        let compute_clamp_bounds_double = |signed: bool, int_width: u64| -> (u128, u128) {\n-            let rounded_min =\n-                ieee::Double::from_i128_r(int_min(signed, int_width), Round::TowardZero);\n-            assert_eq!(rounded_min.status, Status::OK);\n-            let rounded_max =\n-                ieee::Double::from_u128_r(int_max(signed, int_width), Round::TowardZero);\n-            assert!(rounded_max.value.is_finite());\n-            (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n-        };\n-        // To implement saturation, we perform the following steps:\n-        //\n-        // 1. Cast x to an integer with fpto[su]i. This may result in undef.\n-        // 2. Compare x to f_min and f_max, and use the comparison results to select:\n-        //  a) int_ty::MIN if x < f_min or x is NaN\n-        //  b) int_ty::MAX if x > f_max\n-        //  c) the result of fpto[su]i otherwise\n-        // 3. If x is NaN, return 0.0, otherwise return the result of step 2.\n-        //\n-        // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n-        // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n-        // undef does not introduce any non-determinism either.\n-        // More importantly, the above procedure correctly implements saturating conversion.\n-        // Proof (sketch):\n-        // If x is NaN, 0 is returned by definition.\n-        // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n-        // This yields three cases to consider:\n-        // (1) if x in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n-        //     saturating conversion for inputs in that range.\n-        // (2) if x > f_max, then x is larger than int_ty::MAX. This holds even if f_max is rounded\n-        //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n-        //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value of int_ty::MAX\n-        //     is correct.\n-        // (3) if x < f_min, then x is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n-        //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n-        // QED.\n-\n-        let float_bits_to_llval = |bx: &mut Self, bits| {\n-            let bits_llval = match float_width {\n-                32 => bx.cx().const_u32(bits as u32),\n-                64 => bx.cx().const_u64(bits as u64),\n-                n => bug!(\"unsupported float width {}\", n),\n-            };\n-            bx.bitcast(bits_llval, float_ty)\n-        };\n-        let (f_min, f_max) = match float_width {\n-            32 => compute_clamp_bounds_single(signed, int_width),\n-            64 => compute_clamp_bounds_double(signed, int_width),\n-            n => bug!(\"unsupported float width {}\", n),\n-        };\n-        let f_min = float_bits_to_llval(self, f_min);\n-        let f_max = float_bits_to_llval(self, f_max);\n-        let int_max = self.cx().const_uint_big(int_ty, int_max(signed, int_width));\n-        let int_min = self.cx().const_uint_big(int_ty, int_min(signed, int_width) as u128);\n-        let zero = self.cx().const_uint(int_ty, 0);\n-\n-        // If we're working with vectors, constants must be \"splatted\": the constant is duplicated\n-        // into each lane of the vector.  The algorithm stays the same, we are just using the\n-        // same constant across all lanes.\n-        let maybe_splat = |bx: &mut Self, val| {\n-            if bx.cx().type_kind(dest_ty) == TypeKind::Vector {\n-                bx.vector_splat(bx.vector_length(dest_ty), val)\n-            } else {\n-                val\n-            }\n-        };\n-        let f_min = maybe_splat(self, f_min);\n-        let f_max = maybe_splat(self, f_max);\n-        let int_max = maybe_splat(self, int_max);\n-        let int_min = maybe_splat(self, int_min);\n-        let zero = maybe_splat(self, zero);\n-\n-        // Step 1 ...\n-        let fptosui_result = if signed { self.fptosi(x, dest_ty) } else { self.fptoui(x, dest_ty) };\n-        let less_or_nan = self.fcmp(RealPredicate::RealULT, x, f_min);\n-        let greater = self.fcmp(RealPredicate::RealOGT, x, f_max);\n-\n-        // Step 2: We use two comparisons and two selects, with %s1 being the\n-        // result:\n-        //     %less_or_nan = fcmp ult %x, %f_min\n-        //     %greater = fcmp olt %x, %f_max\n-        //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n-        //     %s1 = select %greater, int_ty::MAX, %s0\n-        // Note that %less_or_nan uses an *unordered* comparison. This\n-        // comparison is true if the operands are not comparable (i.e., if x is\n-        // NaN). The unordered comparison ensures that s1 becomes int_ty::MIN if\n-        // x is NaN.\n-        //\n-        // Performance note: Unordered comparison can be lowered to a \"flipped\"\n-        // comparison and a negation, and the negation can be merged into the\n-        // select. Therefore, it not necessarily any more expensive than an\n-        // ordered (\"normal\") comparison. Whether these optimizations will be\n-        // performed is ultimately up to the backend, but at least x86 does\n-        // perform them.\n-        let s0 = self.select(less_or_nan, int_min, fptosui_result);\n-        let s1 = self.select(greater, int_max, s0);\n-\n-        // Step 3: NaN replacement.\n-        // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n-        // Therefore we only need to execute this step for signed integer types.\n-        if signed {\n-            // LLVM has no isNaN predicate, so we use (x == x) instead\n-            let cmp = self.fcmp(RealPredicate::RealOEQ, x, x);\n-            self.select(cmp, s1, zero)\n-        } else {\n-            s1\n-        }\n+        if signed { self.fptosi_sat(x, dest_ty) } else { self.fptoui_sat(x, dest_ty) }\n     }\n \n     fn icmp(&mut self, op: IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;"}, {"sha": "09d53331b5b269310fc29249887f64f2e28de83d", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -10,12 +10,12 @@ use rustc_span::{Span, Symbol};\n use super::InterpCx;\n use crate::interpret::{\n     struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine, MachineStopType,\n+    UnsupportedOpInfo,\n };\n \n /// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n pub enum ConstEvalErrKind {\n-    NeedsRfc(String),\n     ConstAccessesStatic,\n     ModifiedGlobal,\n     AssertFailure(AssertKind<ConstInt>),\n@@ -42,9 +42,6 @@ impl fmt::Display for ConstEvalErrKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::ConstEvalErrKind::*;\n         match *self {\n-            NeedsRfc(ref msg) => {\n-                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n-            }\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n             ModifiedGlobal => {\n                 write!(f, \"modifying a static's initial value from another static's initializer\")\n@@ -153,6 +150,18 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             if let Some(span_msg) = span_msg {\n                 err.span_label(self.span, span_msg);\n             }\n+            // Add some more context for select error types.\n+            match self.error {\n+                InterpError::Unsupported(\n+                    UnsupportedOpInfo::ReadPointerAsBytes\n+                    | UnsupportedOpInfo::PartialPointerOverwrite(_)\n+                    | UnsupportedOpInfo::PartialPointerCopy(_),\n+                ) => {\n+                    err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n+                    err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n+                }\n+                _ => {}\n+            }\n             // Add spans for the stacktrace. Don't print a single-line backtrace though.\n             if self.stacktrace.len() > 1 {\n                 // Helper closure to print duplicated lines."}, {"sha": "b46f71fc78a3b9164919ce9c3e2097e7764875d9", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,8 +2,8 @@ use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n-    Immediate, InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking,\n-    ScalarMaybeUninit, StackPopCleanup,\n+    Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n+    RefTracking, StackPopCleanup,\n };\n \n use rustc_hir::def::DefKind;\n@@ -74,14 +74,16 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n+    ecx.machine.check_alignment = false; // interning doesn't need to respect alignment\n     intern_const_alloc_recursive(ecx, intern_kind, &ret)?;\n+    // we leave alignment checks off, since this `ecx` will not be used for further evaluation anyway\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n }\n \n /// The `InterpCx` is only meant to be used to do field and index projections into constants for\n-/// `simd_shuffle` and const patterns in match arms.\n+/// `simd_shuffle` and const patterns in match arms. It never performs alignment checks.\n ///\n /// The function containing the `match` that is currently being analyzed may have generic bounds\n /// that inform us about the generic bounds of the constant. E.g., using an associated constant\n@@ -98,7 +100,11 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n         tcx,\n         root_span,\n         param_env,\n-        CompileTimeInterpreter::new(tcx.const_eval_limit(), can_access_statics),\n+        CompileTimeInterpreter::new(\n+            tcx.const_eval_limit(),\n+            can_access_statics,\n+            /*check_alignment:*/ false,\n+        ),\n     )\n }\n \n@@ -166,10 +172,7 @@ pub(super) fn op_to_const<'tcx>(\n         // see comment on `let try_as_immediate` above\n         Err(imm) => match *imm {\n             _ if imm.layout.is_zst() => ConstValue::ZeroSized,\n-            Immediate::Scalar(x) => match x {\n-                ScalarMaybeUninit::Scalar(s) => ConstValue::Scalar(s),\n-                ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place()),\n-            },\n+            Immediate::Scalar(x) => ConstValue::Scalar(x),\n             Immediate::ScalarPair(a, b) => {\n                 debug!(\"ScalarPair(a: {:?}, b: {:?})\", a, b);\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`.\n@@ -203,7 +206,13 @@ pub(crate) fn turn_into_const_value<'tcx>(\n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();\n     let is_static = tcx.is_static(def_id);\n-    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n+    // This is just accessing an already computed constant, so no need to check alginment here.\n+    let ecx = mk_eval_cx(\n+        tcx,\n+        tcx.def_span(key.value.instance.def_id()),\n+        key.param_env,\n+        /*can_access_statics:*/ is_static,\n+    );\n \n     let mplace = ecx.raw_const_to_mplace(constant).expect(\n         \"can only fail if layout computation failed, \\\n@@ -300,7 +309,11 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         key.param_env,\n         // Statics (and promoteds inside statics) may access other statics, because unlike consts\n         // they do not have to behave \"as if\" they were evaluated at runtime.\n-        CompileTimeInterpreter::new(tcx.const_eval_limit(), /*can_access_statics:*/ is_static),\n+        CompileTimeInterpreter::new(\n+            tcx.const_eval_limit(),\n+            /*can_access_statics:*/ is_static,\n+            /*check_alignment:*/ tcx.sess.opts.unstable_opts.extra_const_ub_checks,\n+        ),\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n@@ -374,7 +387,9 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                     ecx.tcx,\n                     \"it is undefined behavior to use this value\",\n                     |diag| {\n-                        diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n+                        if matches!(err.error, InterpError::UndefinedBehavior(_)) {\n+                            diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n+                        }\n                         diag.note(&format!(\n                             \"the raw bytes of the constant ({}\",\n                             display_allocation("}, {"sha": "9ea9fbe0e0e54188260281048bf8bfd11edfc308", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -89,10 +89,10 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// exhaustion error.\n     ///\n     /// Setting this to `0` disables the limit and allows the interpreter to run forever.\n-    pub steps_remaining: usize,\n+    pub(super) steps_remaining: usize,\n \n     /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx, AllocId, ()>>,\n+    pub(super) stack: Vec<Frame<'mir, 'tcx, AllocId, ()>>,\n \n     /// We need to make sure consts never point to anything mutable, even recursively. That is\n     /// relied on for pattern matching on consts with references.\n@@ -101,14 +101,22 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// * Pointers to allocations inside of statics can never leak outside, to a non-static global.\n     /// This boolean here controls the second part.\n     pub(super) can_access_statics: bool,\n+\n+    /// Whether to check alignment during evaluation.\n+    pub(super) check_alignment: bool,\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    pub(crate) fn new(const_eval_limit: Limit, can_access_statics: bool) -> Self {\n+    pub(crate) fn new(\n+        const_eval_limit: Limit,\n+        can_access_statics: bool,\n+        check_alignment: bool,\n+    ) -> Self {\n         CompileTimeInterpreter {\n             steps_remaining: const_eval_limit.0,\n             stack: Vec::new(),\n             can_access_statics,\n+            check_alignment,\n         }\n     }\n }\n@@ -238,7 +246,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     #[inline(always)]\n     fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.tcx.sess.opts.unstable_opts.extra_const_ub_checks\n+        ecx.machine.check_alignment\n     }\n \n     #[inline(always)]\n@@ -261,9 +269,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     );\n                     throw_inval!(AlreadyReported(guar));\n                 } else {\n+                    // `find_mir_or_eval_fn` checks that this is a const fn before even calling us,\n+                    // so this should be unreachable.\n                     let path = ecx.tcx.def_path_str(def.did);\n-                    Err(ConstEvalErrKind::NeedsRfc(format!(\"calling extern function `{}`\", path))\n-                        .into())\n+                    bug!(\"trying to call extern function `{path}` at compile-time\");\n                 }\n             }\n             _ => Ok(ecx.tcx.instance_mir(instance)),\n@@ -331,16 +340,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n         // CTFE-specific intrinsics.\n         let Some(ret) = target else {\n-            return Err(ConstEvalErrKind::NeedsRfc(format!(\n-                \"calling intrinsic `{}`\",\n-                intrinsic_name\n-            ))\n-            .into());\n+            throw_unsup_format!(\"intrinsic `{intrinsic_name}` is not supported at compile-time\");\n         };\n         match intrinsic_name {\n             sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                let a = ecx.read_immediate(&args[0])?.to_scalar()?;\n-                let b = ecx.read_immediate(&args[1])?.to_scalar()?;\n+                let a = ecx.read_scalar(&args[0])?;\n+                let b = ecx.read_scalar(&args[1])?;\n                 let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n                     ecx.guaranteed_eq(a, b)?\n                 } else {\n@@ -392,11 +397,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 }\n             }\n             _ => {\n-                return Err(ConstEvalErrKind::NeedsRfc(format!(\n-                    \"calling intrinsic `{}`\",\n-                    intrinsic_name\n-                ))\n-                .into());\n+                throw_unsup_format!(\n+                    \"intrinsic `{intrinsic_name}` is not supported at compile-time\"\n+                );\n             }\n         }\n \n@@ -439,7 +442,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _left: &ImmTy<'tcx>,\n         _right: &ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n+        throw_unsup_format!(\"pointer arithmetic or comparison is not supported at compile-time\");\n     }\n \n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n@@ -461,7 +464,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _ptr: Pointer<AllocId>,\n     ) -> InterpResult<'tcx> {\n-        Err(ConstEvalErrKind::NeedsRfc(\"exposing pointers\".to_string()).into())\n+        // This is only reachable with -Zunleash-the-miri-inside-of-you.\n+        throw_unsup_format!(\"exposing pointers is not possible at compile-time\")\n     }\n \n     #[inline(always)]"}, {"sha": "d9c4ae4d53f91d3946fce0f16368aaf45f5f86d0", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,16 +1,16 @@\n // Not in interpret to make sure we do not use private implementation details\n \n+use crate::errors::MaxNumNodesInConstErr;\n+use crate::interpret::{\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n+    Scalar,\n+};\n use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{EvalToValTreeResult, GlobalId};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n-use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n-    Scalar,\n-};\n-\n mod error;\n mod eval_queries;\n mod fn_queries;\n@@ -72,12 +72,17 @@ pub(crate) fn eval_to_valtree<'tcx>(\n         Ok(valtree) => Ok(Some(valtree)),\n         Err(err) => {\n             let did = cid.instance.def_id();\n-            let s = cid.display(tcx);\n+            let global_const_id = cid.display(tcx);\n             match err {\n                 ValTreeCreationError::NodesOverflow => {\n-                    let msg = format!(\"maximum number of nodes exceeded in constant {}\", &s);\n+                    let msg = format!(\n+                        \"maximum number of nodes exceeded in constant {}\",\n+                        &global_const_id\n+                    );\n                     let mut diag = match tcx.hir().span_if_local(did) {\n-                        Some(span) => tcx.sess.struct_span_err(span, &msg),\n+                        Some(span) => {\n+                            tcx.sess.create_err(MaxNumNodesInConstErr { span, global_const_id })\n+                        }\n                         None => tcx.sess.struct_err(&msg),\n                     };\n                     diag.emit();"}, {"sha": "373b139c86e424d941b779aaddbe7e5912db6301", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -3,7 +3,7 @@ use super::machine::CompileTimeEvalContext;\n use super::{ValTreeCreationError, ValTreeCreationResult, VALTREE_MAX_NODES};\n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemPlaceMeta,\n-    MemoryKind, PlaceTy, Scalar, ScalarMaybeUninit,\n+    MemoryKind, PlaceTy, Scalar,\n };\n use crate::interpret::{MPlaceTy, Value};\n use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n@@ -90,7 +90,7 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n             let Ok(val) = ecx.read_immediate(&place.into()) else {\n                 return Err(ValTreeCreationError::Other);\n             };\n-            let val = val.to_scalar().unwrap();\n+            let val = val.to_scalar();\n             *num_nodes += 1;\n \n             Ok(ty::ValTree::Leaf(val.assert_int()))\n@@ -349,11 +349,7 @@ fn valtree_into_mplace<'tcx>(\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n             let scalar_int = valtree.unwrap_leaf();\n             debug!(\"writing trivial valtree {:?} to place {:?}\", scalar_int, place);\n-            ecx.write_immediate(\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(scalar_int.into())),\n-                &place.into(),\n-            )\n-            .unwrap();\n+            ecx.write_immediate(Immediate::Scalar(scalar_int.into()), &place.into()).unwrap();\n         }\n         ty::Ref(_, inner_ty, _) => {\n             let mut pointee_place = create_pointee_place(ecx, *inner_ty, valtree);\n@@ -366,11 +362,10 @@ fn valtree_into_mplace<'tcx>(\n             let imm = match inner_ty.kind() {\n                 ty::Slice(_) | ty::Str => {\n                     let len = valtree.unwrap_branch().len();\n-                    let len_scalar =\n-                        ScalarMaybeUninit::Scalar(Scalar::from_machine_usize(len as u64, &tcx));\n+                    let len_scalar = Scalar::from_machine_usize(len as u64, &tcx);\n \n                     Immediate::ScalarPair(\n-                        ScalarMaybeUninit::from_maybe_pointer((*pointee_place).ptr, &tcx),\n+                        Scalar::from_maybe_pointer((*pointee_place).ptr, &tcx),\n                         len_scalar,\n                     )\n                 }"}, {"sha": "c3547cb3abdf3ff2fefa5205545281ebb6087bb4", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 116, "deletions": 9, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -3,7 +3,7 @@ use rustc_macros::SessionDiagnostic;\n use rustc_span::Span;\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::unstable_in_stable)]\n+#[diag(const_eval::unstable_in_stable)]\n pub(crate) struct UnstableInStable {\n     pub gate: String,\n     #[primary_span]\n@@ -22,14 +22,14 @@ pub(crate) struct UnstableInStable {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::thread_local_access, code = \"E0625\")]\n+#[diag(const_eval::thread_local_access, code = \"E0625\")]\n pub(crate) struct NonConstOpErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::static_access, code = \"E0013\")]\n+#[diag(const_eval::static_access, code = \"E0013\")]\n #[help]\n pub(crate) struct StaticAccessErr {\n     #[primary_span]\n@@ -41,7 +41,7 @@ pub(crate) struct StaticAccessErr {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::raw_ptr_to_int)]\n+#[diag(const_eval::raw_ptr_to_int)]\n #[note]\n #[note(const_eval::note2)]\n pub(crate) struct RawPtrToIntErr {\n@@ -50,40 +50,147 @@ pub(crate) struct RawPtrToIntErr {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::raw_ptr_comparison)]\n+#[diag(const_eval::raw_ptr_comparison)]\n #[note]\n pub(crate) struct RawPtrComparisonErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::panic_non_str)]\n+#[diag(const_eval::panic_non_str)]\n pub(crate) struct PanicNonStrErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::mut_deref, code = \"E0658\")]\n+#[diag(const_eval::mut_deref, code = \"E0658\")]\n pub(crate) struct MutDerefErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::transient_mut_borrow, code = \"E0658\")]\n+#[diag(const_eval::transient_mut_borrow, code = \"E0658\")]\n pub(crate) struct TransientMutBorrowErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(const_eval::transient_mut_borrow_raw, code = \"E0658\")]\n+#[diag(const_eval::transient_mut_borrow_raw, code = \"E0658\")]\n pub(crate) struct TransientMutBorrowErrRaw {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::max_num_nodes_in_const)]\n+pub(crate) struct MaxNumNodesInConstErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub global_const_id: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_fn_pointer_call)]\n+pub(crate) struct UnallowedFnPointerCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unstable_const_fn)]\n+pub(crate) struct UnstableConstFn {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def_path: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_mutable_refs, code = \"E0764\")]\n+pub(crate) struct UnallowedMutableRefs {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_mutable_refs_raw, code = \"E0764\")]\n+pub(crate) struct UnallowedMutableRefsRaw {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::non_const_fmt_macro_call, code = \"E0015\")]\n+pub(crate) struct NonConstFmtMacroCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::non_const_fn_call, code = \"E0015\")]\n+pub(crate) struct NonConstFnCall {\n+    #[primary_span]\n+    pub span: Span,\n+    pub def_path_str: String,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_op_in_const_context)]\n+pub(crate) struct UnallowedOpInConstContext {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_heap_allocations, code = \"E0010\")]\n+pub(crate) struct UnallowedHeapAllocations {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::unallowed_inline_asm, code = \"E0015\")]\n+pub(crate) struct UnallowedInlineAsm {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: ConstContext,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::interior_mutable_data_refer, code = \"E0492\")]\n+pub(crate) struct InteriorMutableDataRefer {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[help]\n+    pub opt_help: Option<()>,\n+    pub kind: ConstContext,\n+    #[note(const_eval::teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(const_eval::interior_mutability_borrow)]\n+pub(crate) struct InteriorMutabilityBorrow {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "07dbd80e077f939bfd7ee0b9d06f3e8b6ab0a709", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -123,10 +123,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match src.layout.ty.kind() {\n             // Floating point\n             Float(FloatTy::F32) => {\n-                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, cast_ty).into());\n+                return Ok(self.cast_from_float(src.to_scalar().to_f32()?, cast_ty).into());\n             }\n             Float(FloatTy::F64) => {\n-                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, cast_ty).into());\n+                return Ok(self.cast_from_float(src.to_scalar().to_f64()?, cast_ty).into());\n             }\n             // The rest is integer/pointer-\"like\", including fn ptr casts\n             _ => assert!(\n@@ -153,7 +153,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(dest_layout.size, self.pointer_size());\n                 assert!(src.layout.ty.is_unsafe_ptr());\n                 return match **src {\n-                    Immediate::ScalarPair(data, _) => Ok(data.check_init()?.into()),\n+                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n                     Immediate::Scalar(..) => span_bug!(\n                         self.cur_span(),\n                         \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n@@ -167,7 +167,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         // # The remaining source values are scalar and \"int-like\".\n-        let scalar = src.to_scalar()?;\n+        let scalar = src.to_scalar();\n         Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n     }\n \n@@ -179,7 +179,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_matches!(src.layout.ty.kind(), ty::RawPtr(_) | ty::FnPtr(_));\n         assert!(cast_ty.is_integral());\n \n-        let scalar = src.to_scalar()?;\n+        let scalar = src.to_scalar();\n         let ptr = scalar.to_pointer(self)?;\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => M::expose_ptr(self, ptr)?,\n@@ -197,7 +197,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_matches!(cast_ty.kind(), ty::RawPtr(_));\n \n         // First cast to usize.\n-        let scalar = src.to_scalar()?;\n+        let scalar = src.to_scalar();\n         let addr = self.cast_from_int_like(scalar, src.layout, self.tcx.types.usize)?;\n         let addr = addr.to_machine_usize(self)?;\n \n@@ -291,14 +291,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match (&src_pointee_ty.kind(), &dest_pointee_ty.kind()) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n-                let ptr = self.read_immediate(src)?.to_scalar()?;\n+                let ptr = self.read_scalar(src)?;\n                 // u64 cast is from usize to u64, which is always good\n                 let val =\n                     Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n-                let (old_data, old_vptr) = self.read_immediate(src)?.to_scalar_pair()?;\n+                let val = self.read_immediate(src)?;\n+                if data_a.principal() == data_b.principal() {\n+                    // A NOP cast that doesn't actually change anything, should be allowed even with mismatching vtables.\n+                    return self.write_immediate(*val, dest);\n+                }\n+                let (old_data, old_vptr) = val.to_scalar_pair();\n                 let old_vptr = old_vptr.to_pointer(self)?;\n                 let (ty, old_trait) = self.get_ptr_vtable(old_vptr)?;\n                 if old_trait != data_a.principal() {\n@@ -310,7 +315,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n-                let ptr = self.read_immediate(src)?.to_scalar()?;\n+                let ptr = self.read_scalar(src)?;\n                 let val = Immediate::new_dyn_trait(ptr, vtable, &*self.tcx);\n                 self.write_immediate(val, dest)\n             }"}, {"sha": "d37eaeed095a154fa7732fa24253ab4dfde84688", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -21,7 +21,7 @@ use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayou\n use super::{\n     AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemPlace,\n     MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n-    Scalar, ScalarMaybeUninit, StackPopJump,\n+    Scalar, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n \n@@ -187,9 +187,6 @@ pub enum LocalValue<Prov: Provenance = AllocId> {\n \n impl<'tcx, Prov: Provenance + 'static> LocalState<'tcx, Prov> {\n     /// Read the local's value or error if the local is not yet live or not live anymore.\n-    ///\n-    /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n-    /// anywhere else. You may be invalidating machine invariants if you do!\n     #[inline]\n     pub fn access(&self) -> InterpResult<'tcx, &Operand<Prov>> {\n         match &self.value {\n@@ -782,7 +779,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_eq!(\n             unwinding,\n             match self.frame().loc {\n-                Ok(loc) => self.body().basic_blocks()[loc.block].is_cleanup,\n+                Ok(loc) => self.body().basic_blocks[loc.block].is_cleanup,\n                 Err(_) => true,\n             }\n         );\n@@ -991,16 +988,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n                         write!(fmt, \" {:?}\", val)?;\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val {\n+                        if let Scalar::Ptr(ptr, _size) = val {\n                             allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n                         write!(fmt, \" ({:?}, {:?})\", val1, val2)?;\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val1 {\n+                        if let Scalar::Ptr(ptr, _size) = val1 {\n                             allocs.push(ptr.provenance.get_alloc_id());\n                         }\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val2 {\n+                        if let Scalar::Ptr(ptr, _size) = val2 {\n                             allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                     }"}, {"sha": "66ab3f15716f2e5d7eb93782df478f32bf5f50e2", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -134,7 +134,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n-    leftover_allocations.extend(alloc.relocations().iter().map(|&(_, alloc_id)| alloc_id));\n+    leftover_allocations.extend(alloc.provenance().iter().map(|&(_, alloc_id)| alloc_id));\n     let alloc = tcx.intern_const_alloc(alloc);\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n     None\n@@ -191,10 +191,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n                     return Ok(true);\n                 };\n \n-                // If there are no relocations in this allocation, it does not contain references\n+                // If there is no provenance in this allocation, it does not contain references\n                 // that point to another allocation, and we can avoid the interning walk.\n                 if let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, align)? {\n-                    if !alloc.has_relocations() {\n+                    if !alloc.has_provenance() {\n                         return Ok(false);\n                     }\n                 } else {\n@@ -233,8 +233,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n     }\n \n     fn visit_value(&mut self, mplace: &MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n-        // Handle Reference types, as these are the only relocations supported by const eval.\n-        // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n+        // Handle Reference types, as these are the only types with provenance supported by const eval.\n+        // Raw pointers (and boxes) are handled by the `leftover_allocations` logic.\n         let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, ref_mutability) = *ty.kind() {\n@@ -410,7 +410,7 @@ pub fn intern_const_alloc_recursive<\n             // references and a `leftover_allocations` set (where we only have a todo-list here).\n             // So we hand-roll the interning logic here again.\n             match intern_kind {\n-                // Statics may contain mutable allocations even behind relocations.\n+                // Statics may point to mutable allocations.\n                 // Even for immutable statics it would be ok to have mutable allocations behind\n                 // raw pointers, e.g. for `static FOO: *const AtomicUsize = &AtomicUsize::new(42)`.\n                 InternKind::Static(_) => {}\n@@ -441,7 +441,7 @@ pub fn intern_const_alloc_recursive<\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.set_alloc_id_memory(alloc_id, alloc);\n-            for &(_, alloc_id) in alloc.inner().relocations().iter() {\n+            for &(_, alloc_id) in alloc.inner().provenance().iter() {\n                 if leftover_allocations.insert(alloc_id) {\n                     todo.push(alloc_id);\n                 }"}, {"sha": "a8ec8447f64a4d1206fdf16aead8229ad09c38dd", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -184,7 +184,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::bitreverse => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n-                let val = self.read_scalar(&args[0])?.check_init()?;\n+                let val = self.read_scalar(&args[0])?;\n                 let bits = val.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     Abi::Scalar(scalar) => scalar.primitive(),\n@@ -256,7 +256,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, &l, &r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n-                    let r_val = r.to_scalar()?.to_bits(layout.size)?;\n+                    let r_val = r.to_scalar().to_bits(layout.size)?;\n                     if let sym::unchecked_shl | sym::unchecked_shr = intrinsic_name {\n                         throw_ub_format!(\"overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n                     } else {\n@@ -269,9 +269,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n-                let val = self.read_scalar(&args[0])?.check_init()?;\n+                let val = self.read_scalar(&args[0])?;\n                 let val_bits = val.to_bits(layout.size)?;\n-                let raw_shift = self.read_scalar(&args[1])?.check_init()?;\n+                let raw_shift = self.read_scalar(&args[1])?;\n                 let raw_shift_bits = raw_shift.to_bits(layout.size)?;\n                 let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n@@ -507,7 +507,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_op(&args[0], dest, /*allow_transmute*/ false)?;\n             }\n             sym::assume => {\n-                let cond = self.read_scalar(&args[0])?.check_init()?.to_bool()?;\n+                let cond = self.read_scalar(&args[0])?.to_bool()?;\n                 if !cond {\n                     throw_ub_format!(\"`assume` intrinsic called with `false`\");\n                 }\n@@ -570,7 +570,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // term since the sign of the second term can be inferred from this and\n                 // the fact that the operation has overflowed (if either is 0 no\n                 // overflow can occur)\n-                let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n+                let first_term: u128 = l.to_scalar().to_bits(l.layout.size)?;\n                 let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n                 if first_term_positive {\n                     // Negative overflow not possible since the positive first term\n@@ -687,10 +687,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n         assert!(!layout.is_unsized());\n \n-        let lhs = self.read_pointer(lhs)?;\n-        let rhs = self.read_pointer(rhs)?;\n-        let lhs_bytes = self.read_bytes_ptr(lhs, layout.size)?;\n-        let rhs_bytes = self.read_bytes_ptr(rhs, layout.size)?;\n+        let get_bytes = |this: &InterpCx<'mir, 'tcx, M>,\n+                         op: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+                         size|\n+         -> InterpResult<'tcx, &[u8]> {\n+            let ptr = this.read_pointer(op)?;\n+            let Some(alloc_ref) = self.get_ptr_alloc(ptr, size, Align::ONE)? else {\n+                // zero-sized access\n+                return Ok(&[]);\n+            };\n+            if alloc_ref.has_provenance() {\n+                throw_ub_format!(\"`raw_eq` on bytes with provenance\");\n+            }\n+            alloc_ref.get_bytes_strip_provenance()\n+        };\n+\n+        let lhs_bytes = get_bytes(self, lhs, layout.size)?;\n+        let rhs_bytes = get_bytes(self, rhs, layout.size)?;\n         Ok(Scalar::from_bool(lhs_bytes == rhs_bytes))\n     }\n }"}, {"sha": "91f4f04251721209e177286b3363c4f215098f67", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -28,7 +28,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let mut source_info = *frame.body.source_info(loc);\n \n             // If this is a `Call` terminator, use the `fn_span` instead.\n-            let block = &frame.body.basic_blocks()[loc.block];\n+            let block = &frame.body.basic_blocks[loc.block];\n             if loc.statement_index == block.statements.len() {\n                 debug!(\n                     \"find_closest_untracked_caller_location: got terminator {:?} ({:?})\","}, {"sha": "5aabb14fba88454bc55bbf7c824e52d5a456a95a", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -123,18 +123,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether memory accesses should be alignment-checked.\n     fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Whether, when checking alignment, we should `force_int` and thus support\n+    /// Whether, when checking alignment, we should look at the actual address and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n     ///\n-    /// Requires Provenance::OFFSET_IS_ADDR to be true.\n-    fn force_int_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    /// If this returns true, Provenance::OFFSET_IS_ADDR must be true.\n+    fn use_addr_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Whether to enforce integers and floats being initialized.\n-    fn enforce_number_init(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n-\n     /// Whether function calls should be [ABI](CallAbi)-checked.\n     fn enforce_abi(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         true\n@@ -218,23 +215,12 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         right: &ImmTy<'tcx, Self::Provenance>,\n     ) -> InterpResult<'tcx, (Scalar<Self::Provenance>, bool, Ty<'tcx>)>;\n \n-    /// Called to read the specified `local` from the `frame`.\n-    /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n-    /// for ZST reads.\n-    #[inline]\n-    fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n-        local: mir::Local,\n-    ) -> InterpResult<'tcx, &'a Operand<Self::Provenance>>\n-    where\n-        'tcx: 'mir,\n-    {\n-        frame.locals[local].access()\n-    }\n-\n     /// Called to write the specified `local` from the `frame`.\n     /// Since writing a ZST is not actually accessing memory or locals, this is never invoked\n     /// for ZST reads.\n+    ///\n+    /// Due to borrow checker trouble, we indicate the `frame` as an index rather than an `&mut\n+    /// Frame`.\n     #[inline]\n     fn access_local_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n@@ -329,7 +315,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n     ///\n-    /// This must only fail if `alloc` contains relocations.\n+    /// This must only fail if `alloc` contains provenance.\n     fn adjust_allocation<'b>(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         id: AllocId,\n@@ -437,16 +423,11 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type FrameExtra = ();\n \n     #[inline(always)]\n-    fn force_int_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        // We do not support `force_int`.\n+    fn use_addr_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n+        // We do not support `use_addr`.\n         false\n     }\n \n-    #[inline(always)]\n-    fn enforce_number_init(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        true\n-    }\n-\n     #[inline(always)]\n     fn checked_binop_checks_overflow(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         true\n@@ -498,6 +479,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     ) -> InterpResult<$tcx, Pointer<Option<AllocId>>> {\n         // Allow these casts, but make the pointer not dereferenceable.\n         // (I.e., they behave like transmutation.)\n+        // This is correct because no pointers can ever be exposed in compile-time evaluation.\n         Ok(Pointer::from_addr(addr))\n     }\n "}, {"sha": "69dbc9592fa87a73bd11b0a4e38805260e30c8df", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 37, "deletions": 47, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -21,7 +21,6 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n use super::{\n     alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n     InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n-    ScalarMaybeUninit,\n };\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -215,7 +214,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.allocate_raw_ptr(alloc, kind).unwrap()\n     }\n \n-    /// This can fail only of `alloc` contains relocations.\n+    /// This can fail only of `alloc` contains provenance.\n     pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n@@ -445,8 +444,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n-                    if M::force_int_for_alignment_check(self) {\n-                        // `force_int_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n+                    if M::use_addr_for_alignment_check(self) {\n+                        // `use_addr_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n                         check_offset_align(ptr.addr().bytes(), align)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n@@ -795,10 +794,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             todo.extend(static_roots);\n             while let Some(id) = todo.pop() {\n                 if reachable.insert(id) {\n-                    // This is a new allocation, add its relocations to `todo`.\n+                    // This is a new allocation, add the allocation it points to to `todo`.\n                     if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n                         todo.extend(\n-                            alloc.relocations().values().filter_map(|prov| prov.get_alloc_id()),\n+                            alloc.provenance().values().filter_map(|prov| prov.get_alloc_id()),\n                         );\n                     }\n                 }\n@@ -834,7 +833,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Prov, Extra>,\n         ) -> std::fmt::Result {\n-            for alloc_id in alloc.relocations().values().filter_map(|prov| prov.get_alloc_id()) {\n+            for alloc_id in alloc.provenance().values().filter_map(|prov| prov.get_alloc_id()) {\n                 allocs_to_print.push_back(alloc_id);\n             }\n             write!(fmt, \"{}\", display_allocation(tcx, alloc))\n@@ -901,11 +900,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n /// Reading and writing.\n impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn write_scalar(\n-        &mut self,\n-        range: AllocRange,\n-        val: ScalarMaybeUninit<Prov>,\n-    ) -> InterpResult<'tcx> {\n+    pub fn write_scalar(&mut self, range: AllocRange, val: Scalar<Prov>) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n         debug!(\"write_scalar at {:?}{range:?}: {val:?}\", self.alloc_id);\n         Ok(self\n@@ -915,11 +910,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     }\n \n     /// `offset` is relative to this allocation reference, not the base of the allocation.\n-    pub fn write_ptr_sized(\n-        &mut self,\n-        offset: Size,\n-        val: ScalarMaybeUninit<Prov>,\n-    ) -> InterpResult<'tcx> {\n+    pub fn write_ptr_sized(&mut self, offset: Size, val: Scalar<Prov>) -> InterpResult<'tcx> {\n         self.write_scalar(alloc_range(offset, self.tcx.data_layout().pointer_size), val)\n     }\n \n@@ -938,7 +929,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n         &self,\n         range: AllocRange,\n         read_provenance: bool,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n+    ) -> InterpResult<'tcx, Scalar<Prov>> {\n         let range = self.range.subrange(range);\n         let res = self\n             .alloc\n@@ -949,42 +940,38 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n     }\n \n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn read_integer(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n+    pub fn read_integer(&self, range: AllocRange) -> InterpResult<'tcx, Scalar<Prov>> {\n         self.read_scalar(range, /*read_provenance*/ false)\n     }\n \n     /// `offset` is relative to this allocation reference, not the base of the allocation.\n-    pub fn read_pointer(&self, offset: Size) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n+    pub fn read_pointer(&self, offset: Size) -> InterpResult<'tcx, Scalar<Prov>> {\n         self.read_scalar(\n             alloc_range(offset, self.tcx.data_layout().pointer_size),\n             /*read_provenance*/ true,\n         )\n     }\n \n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn check_bytes(\n-        &self,\n-        range: AllocRange,\n-        allow_uninit: bool,\n-        allow_ptr: bool,\n-    ) -> InterpResult<'tcx> {\n+    pub fn get_bytes_strip_provenance<'b>(&'b self) -> InterpResult<'tcx, &'a [u8]> {\n         Ok(self\n             .alloc\n-            .check_bytes(&self.tcx, self.range.subrange(range), allow_uninit, allow_ptr)\n+            .get_bytes_strip_provenance(&self.tcx, self.range)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n \n-    /// Returns whether the allocation has relocations for the entire range of the `AllocRef`.\n-    pub(crate) fn has_relocations(&self) -> bool {\n-        self.alloc.has_relocations(&self.tcx, self.range)\n+    /// Returns whether the allocation has provenance anywhere in the range of the `AllocRef`.\n+    pub(crate) fn has_provenance(&self) -> bool {\n+        self.alloc.range_has_provenance(&self.tcx, self.range)\n     }\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// Reads the given number of bytes from memory. Returns them as a slice.\n+    /// Reads the given number of bytes from memory, and strips their provenance if possible.\n+    /// Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn read_bytes_ptr(\n+    pub fn read_bytes_ptr_strip_provenance(\n         &self,\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n@@ -997,7 +984,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // (We are staying inside the bounds here so all is good.)\n         Ok(alloc_ref\n             .alloc\n-            .get_bytes(&alloc_ref.tcx, alloc_ref.range)\n+            .get_bytes_strip_provenance(&alloc_ref.tcx, alloc_ref.range)\n             .map_err(|e| e.to_interp_error(alloc_ref.alloc_id))?)\n     }\n \n@@ -1092,17 +1079,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         };\n \n-        // This checks relocation edges on the src, which needs to happen before\n-        // `prepare_relocation_copy`.\n-        let src_bytes = src_alloc\n-            .get_bytes_with_uninit_and_ptr(&tcx, src_range)\n-            .map_err(|e| e.to_interp_error(src_alloc_id))?\n-            .as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n-        // first copy the relocations to a temporary buffer, because\n-        // `get_bytes_mut` will clear the relocations, which is correct,\n-        // since we don't want to keep any relocations at the target.\n-        let relocations =\n-            src_alloc.prepare_relocation_copy(self, src_range, dest_offset, num_copies);\n+        // Checks provenance edges on the src, which needs to happen before\n+        // `prepare_provenance_copy`.\n+        if src_alloc.range_has_provenance(&tcx, alloc_range(src_range.start, Size::ZERO)) {\n+            throw_unsup!(PartialPointerCopy(Pointer::new(src_alloc_id, src_range.start)));\n+        }\n+        if src_alloc.range_has_provenance(&tcx, alloc_range(src_range.end(), Size::ZERO)) {\n+            throw_unsup!(PartialPointerCopy(Pointer::new(src_alloc_id, src_range.end())));\n+        }\n+        let src_bytes = src_alloc.get_bytes_unchecked(src_range).as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n+        // first copy the provenance to a temporary buffer, because\n+        // `get_bytes_mut` will clear the provenance, which is correct,\n+        // since we don't want to keep any provenance at the target.\n+        let provenance =\n+            src_alloc.prepare_provenance_copy(self, src_range, dest_offset, num_copies);\n         // Prepare a copy of the initialization mask.\n         let compressed = src_alloc.compress_uninit_range(src_range);\n \n@@ -1131,7 +1121,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             dest_alloc\n                 .write_uninit(&tcx, dest_range)\n                 .map_err(|e| e.to_interp_error(dest_alloc_id))?;\n-            // We can forget about the relocations, this is all not initialized anyway.\n+            // We can forget about the provenance, this is all not initialized anyway.\n             return Ok(());\n         }\n \n@@ -1175,8 +1165,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             alloc_range(dest_offset, size), // just a single copy (i.e., not full `dest_range`)\n             num_copies,\n         );\n-        // copy the relocations to the destination\n-        dest_alloc.mark_relocation_range(relocations);\n+        // copy the provenance to the destination\n+        dest_alloc.mark_provenance_range(provenance);\n \n         Ok(())\n     }"}, {"sha": "35c2cf8102dc571269645cc1537433a415339063", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 74, "deletions": 114, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,11 +1,9 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n-use std::fmt::Write;\n-\n use rustc_hir::def::Namespace;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n-use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n+use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n use rustc_middle::ty::{ConstInt, DelaySpanBugEmitted, Ty};\n use rustc_middle::{mir, ty};\n use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n@@ -14,7 +12,7 @@ use rustc_target::abi::{VariantIdx, Variants};\n use super::{\n     alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n     InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Place, PlaceTy, Pointer,\n-    Provenance, Scalar, ScalarMaybeUninit,\n+    Provenance, Scalar,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -27,37 +25,28 @@ use super::{\n #[derive(Copy, Clone, Debug)]\n pub enum Immediate<Prov: Provenance = AllocId> {\n     /// A single scalar value (must have *initialized* `Scalar` ABI).\n-    /// FIXME: we also currently often use this for ZST.\n-    /// `ScalarMaybeUninit` should reject ZST, and we should use `Uninit` for them instead.\n-    Scalar(ScalarMaybeUninit<Prov>),\n+    Scalar(Scalar<Prov>),\n     /// A pair of two scalar value (must have `ScalarPair` ABI where both fields are\n     /// `Scalar::Initialized`).\n-    ScalarPair(ScalarMaybeUninit<Prov>, ScalarMaybeUninit<Prov>),\n+    ScalarPair(Scalar<Prov>, Scalar<Prov>),\n     /// A value of fully uninitialized memory. Can have and size and layout.\n     Uninit,\n }\n \n-impl<Prov: Provenance> From<ScalarMaybeUninit<Prov>> for Immediate<Prov> {\n-    #[inline(always)]\n-    fn from(val: ScalarMaybeUninit<Prov>) -> Self {\n-        Immediate::Scalar(val)\n-    }\n-}\n-\n impl<Prov: Provenance> From<Scalar<Prov>> for Immediate<Prov> {\n     #[inline(always)]\n     fn from(val: Scalar<Prov>) -> Self {\n         Immediate::Scalar(val.into())\n     }\n }\n \n-impl<'tcx, Prov: Provenance> Immediate<Prov> {\n+impl<Prov: Provenance> Immediate<Prov> {\n     pub fn from_pointer(p: Pointer<Prov>, cx: &impl HasDataLayout) -> Self {\n-        Immediate::Scalar(ScalarMaybeUninit::from_pointer(p, cx))\n+        Immediate::Scalar(Scalar::from_pointer(p, cx))\n     }\n \n     pub fn from_maybe_pointer(p: Pointer<Option<Prov>>, cx: &impl HasDataLayout) -> Self {\n-        Immediate::Scalar(ScalarMaybeUninit::from_maybe_pointer(p, cx))\n+        Immediate::Scalar(Scalar::from_maybe_pointer(p, cx))\n     }\n \n     pub fn new_slice(val: Scalar<Prov>, len: u64, cx: &impl HasDataLayout) -> Self {\n@@ -69,41 +58,28 @@ impl<'tcx, Prov: Provenance> Immediate<Prov> {\n         vtable: Pointer<Option<Prov>>,\n         cx: &impl HasDataLayout,\n     ) -> Self {\n-        Immediate::ScalarPair(val.into(), ScalarMaybeUninit::from_maybe_pointer(vtable, cx))\n+        Immediate::ScalarPair(val.into(), Scalar::from_maybe_pointer(vtable, cx))\n     }\n \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_or_uninit(self) -> ScalarMaybeUninit<Prov> {\n+    pub fn to_scalar(self) -> Scalar<Prov> {\n         match self {\n             Immediate::Scalar(val) => val,\n             Immediate::ScalarPair(..) => bug!(\"Got a scalar pair where a scalar was expected\"),\n-            Immediate::Uninit => ScalarMaybeUninit::Uninit,\n+            Immediate::Uninit => bug!(\"Got uninit where a scalar was expected\"),\n         }\n     }\n \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Prov>> {\n-        self.to_scalar_or_uninit().check_init()\n-    }\n-\n-    #[inline]\n-    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_or_uninit_pair(self) -> (ScalarMaybeUninit<Prov>, ScalarMaybeUninit<Prov>) {\n+    pub fn to_scalar_pair(self) -> (Scalar<Prov>, Scalar<Prov>) {\n         match self {\n             Immediate::ScalarPair(val1, val2) => (val1, val2),\n             Immediate::Scalar(..) => bug!(\"Got a scalar where a scalar pair was expected\"),\n-            Immediate::Uninit => (ScalarMaybeUninit::Uninit, ScalarMaybeUninit::Uninit),\n+            Immediate::Uninit => bug!(\"Got uninit where a scalar pair was expected\"),\n         }\n     }\n-\n-    #[inline]\n-    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Prov>, Scalar<Prov>)> {\n-        let (val1, val2) = self.to_scalar_or_uninit_pair();\n-        Ok((val1.check_init()?, val2.check_init()?))\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n@@ -119,27 +95,17 @@ impl<Prov: Provenance> std::fmt::Display for ImmTy<'_, Prov> {\n         /// Helper function for printing a scalar to a FmtPrinter\n         fn p<'a, 'tcx, Prov: Provenance>(\n             cx: FmtPrinter<'a, 'tcx>,\n-            s: ScalarMaybeUninit<Prov>,\n+            s: Scalar<Prov>,\n             ty: Ty<'tcx>,\n         ) -> Result<FmtPrinter<'a, 'tcx>, std::fmt::Error> {\n             match s {\n-                ScalarMaybeUninit::Scalar(Scalar::Int(int)) => {\n-                    cx.pretty_print_const_scalar_int(int, ty, true)\n-                }\n-                ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _sz)) => {\n+                Scalar::Int(int) => cx.pretty_print_const_scalar_int(int, ty, true),\n+                Scalar::Ptr(ptr, _sz) => {\n                     // Just print the ptr value. `pretty_print_const_scalar_ptr` would also try to\n                     // print what is points to, which would fail since it has no access to the local\n                     // memory.\n                     cx.pretty_print_const_pointer(ptr, ty, true)\n                 }\n-                ScalarMaybeUninit::Uninit => cx.typed_value(\n-                    |mut this| {\n-                        this.write_str(\"uninit \")?;\n-                        Ok(this)\n-                    },\n-                    |this| this.print_type(ty),\n-                    \" \",\n-                ),\n             }\n         }\n         ty::tls::with(|tcx| {\n@@ -269,7 +235,7 @@ impl<'tcx, Prov: Provenance> ImmTy<'tcx, Prov> {\n     #[inline]\n     pub fn to_const_int(self) -> ConstInt {\n         assert!(self.layout.ty.is_integral());\n-        let int = self.to_scalar().expect(\"to_const_int doesn't work on scalar pairs\").assert_int();\n+        let int = self.to_scalar().assert_int();\n         ConstInt::new(int, self.layout.ty.is_signed(), self.layout.ty.is_ptr_sized_integral())\n     }\n }\n@@ -327,7 +293,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn read_immediate_from_mplace_raw(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n-        force: bool,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::Provenance>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n@@ -345,47 +310,44 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // case where some of the bytes are initialized and others are not. So, we need an extra\n         // check that walks over the type of `mplace` to make sure it is truly correct to treat this\n         // like a `Scalar` (or `ScalarPair`).\n-        let scalar_layout = match mplace.layout.abi {\n-            // `if` does not work nested inside patterns, making this a bit awkward to express.\n-            Abi::Scalar(abi::Scalar::Initialized { value: s, .. }) => Some(s),\n-            Abi::Scalar(s) if force => Some(s.primitive()),\n-            _ => None,\n-        };\n-        if let Some(s) = scalar_layout {\n-            let size = s.size(self);\n-            assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n-            let scalar = alloc\n-                .read_scalar(alloc_range(Size::ZERO, size), /*read_provenance*/ s.is_ptr())?;\n-            return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n-        }\n-        let scalar_pair_layout = match mplace.layout.abi {\n+        Ok(match mplace.layout.abi {\n+            Abi::Scalar(abi::Scalar::Initialized { value: s, .. }) => {\n+                let size = s.size(self);\n+                assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n+                let scalar = alloc.read_scalar(\n+                    alloc_range(Size::ZERO, size),\n+                    /*read_provenance*/ s.is_ptr(),\n+                )?;\n+                Some(ImmTy { imm: scalar.into(), layout: mplace.layout })\n+            }\n             Abi::ScalarPair(\n                 abi::Scalar::Initialized { value: a, .. },\n                 abi::Scalar::Initialized { value: b, .. },\n-            ) => Some((a, b)),\n-            Abi::ScalarPair(a, b) if force => Some((a.primitive(), b.primitive())),\n-            _ => None,\n-        };\n-        if let Some((a, b)) = scalar_pair_layout {\n-            // We checked `ptr_align` above, so all fields will have the alignment they need.\n-            // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n-            // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-            let (a_size, b_size) = (a.size(self), b.size(self));\n-            let b_offset = a_size.align_to(b.align(self).abi);\n-            assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n-            let a_val = alloc.read_scalar(\n-                alloc_range(Size::ZERO, a_size),\n-                /*read_provenance*/ a.is_ptr(),\n-            )?;\n-            let b_val = alloc\n-                .read_scalar(alloc_range(b_offset, b_size), /*read_provenance*/ b.is_ptr())?;\n-            return Ok(Some(ImmTy {\n-                imm: Immediate::ScalarPair(a_val, b_val),\n-                layout: mplace.layout,\n-            }));\n-        }\n-        // Neither a scalar nor scalar pair.\n-        return Ok(None);\n+            ) => {\n+                // We checked `ptr_align` above, so all fields will have the alignment they need.\n+                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n+                let (a_size, b_size) = (a.size(self), b.size(self));\n+                let b_offset = a_size.align_to(b.align(self).abi);\n+                assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n+                let a_val = alloc.read_scalar(\n+                    alloc_range(Size::ZERO, a_size),\n+                    /*read_provenance*/ a.is_ptr(),\n+                )?;\n+                let b_val = alloc.read_scalar(\n+                    alloc_range(b_offset, b_size),\n+                    /*read_provenance*/ b.is_ptr(),\n+                )?;\n+                Some(ImmTy {\n+                    imm: Immediate::ScalarPair(a_val.into(), b_val.into()),\n+                    layout: mplace.layout,\n+                })\n+            }\n+            _ => {\n+                // Neither a scalar nor scalar pair.\n+                None\n+            }\n+        })\n     }\n \n     /// Try returning an immediate for the operand. If the layout does not permit loading this as an\n@@ -394,20 +356,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n     /// in an `Immediate`, not on which data is stored there currently.\n     ///\n-    /// If `force` is `true`, then even scalars with fields that can be ununit will be\n-    /// read. This means the load is lossy and should not be written back!\n-    /// This flag exists only for validity checking.\n-    ///\n     /// This is an internal function that should not usually be used; call `read_immediate` instead.\n     /// ConstProp needs it, though.\n     pub fn read_immediate_raw(\n         &self,\n         src: &OpTy<'tcx, M::Provenance>,\n-        force: bool,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::Provenance>, MPlaceTy<'tcx, M::Provenance>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(ref mplace) => {\n-                if let Some(val) = self.read_immediate_from_mplace_raw(mplace, force)? {\n+                if let Some(val) = self.read_immediate_from_mplace_raw(mplace)? {\n                     Ok(val)\n                 } else {\n                     Err(*mplace)\n@@ -418,24 +375,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Read an immediate from a place, asserting that that is possible with the given layout.\n+    ///\n+    /// If this suceeds, the `ImmTy` is never `Uninit`.\n     #[inline(always)]\n     pub fn read_immediate(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n-        if let Ok(imm) = self.read_immediate_raw(op, /*force*/ false)? {\n-            Ok(imm)\n-        } else {\n-            span_bug!(self.cur_span(), \"primitive read failed for type: {:?}\", op.layout.ty);\n+        if !matches!(\n+            op.layout.abi,\n+            Abi::Scalar(abi::Scalar::Initialized { .. })\n+                | Abi::ScalarPair(abi::Scalar::Initialized { .. }, abi::Scalar::Initialized { .. })\n+        ) {\n+            span_bug!(self.cur_span(), \"primitive read not possible for type: {:?}\", op.layout.ty);\n         }\n+        let imm = self.read_immediate_raw(op)?.unwrap();\n+        if matches!(*imm, Immediate::Uninit) {\n+            throw_ub!(InvalidUninitBytes(None));\n+        }\n+        Ok(imm)\n     }\n \n     /// Read a scalar from a place\n     pub fn read_scalar(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::Provenance>> {\n-        Ok(self.read_immediate(op)?.to_scalar_or_uninit())\n+    ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n+        Ok(self.read_immediate(op)?.to_scalar())\n     }\n \n     /// Read a pointer from a place.\n@@ -449,7 +415,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.read_bytes_ptr(mplace.ptr, Size::from_bytes(len))?;\n+        let bytes = self.read_bytes_ptr_strip_provenance(mplace.ptr, Size::from_bytes(len))?;\n         let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }\n@@ -478,7 +444,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Read from a local. Will not actually access the local if reading from a ZST.\n+    /// Read from a local.\n     /// Will not access memory, instead an indirect `Operand` is returned.\n     ///\n     /// This is public because it is used by [priroda](https://github.com/oli-obk/priroda) to get an\n@@ -490,12 +456,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let layout = self.layout_of_local(frame, local, layout)?;\n-        let op = if layout.is_zst() {\n-            // Bypass `access_local` (helps in ConstProp)\n-            Operand::Immediate(Immediate::Uninit)\n-        } else {\n-            *M::access_local(frame, local)?\n-        };\n+        let op = *frame.locals[local].access()?;\n         Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }\n \n@@ -727,7 +688,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Figure out which discriminant and variant this corresponds to.\n         Ok(match *tag_encoding {\n             TagEncoding::Direct => {\n-                let scalar = tag_val.to_scalar()?;\n+                let scalar = tag_val.to_scalar();\n                 // Generate a specific error if `tag_val` is not an integer.\n                 // (`tag_bits` itself is only used for error messages below.)\n                 let tag_bits = scalar\n@@ -758,7 +719,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 (discr_val, index.0)\n             }\n             TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n-                let tag_val = tag_val.to_scalar()?;\n+                let tag_val = tag_val.to_scalar();\n                 // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n@@ -785,9 +746,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                         let variant_index_relative_val =\n                             self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n-                        let variant_index_relative = variant_index_relative_val\n-                            .to_scalar()?\n-                            .assert_bits(tag_val.layout.size);\n+                        let variant_index_relative =\n+                            variant_index_relative_val.to_scalar().assert_bits(tag_val.layout.size);\n                         // Check if this is in the range that indicates an actual discriminant.\n                         if variant_index_relative <= u128::from(variants_end - variants_start) {\n                             let variant_index_relative = u32::try_from(variant_index_relative)"}, {"sha": "1f1d0665139d093f005f9c0a81edd2e6d0c7c19a", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -329,21 +329,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match left.layout.ty.kind() {\n             ty::Char => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_scalar()?;\n-                let right = right.to_scalar()?;\n+                let left = left.to_scalar();\n+                let right = right.to_scalar();\n                 Ok(self.binary_char_op(bin_op, left.to_char()?, right.to_char()?))\n             }\n             ty::Bool => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_scalar()?;\n-                let right = right.to_scalar()?;\n+                let left = left.to_scalar();\n+                let right = right.to_scalar();\n                 Ok(self.binary_bool_op(bin_op, left.to_bool()?, right.to_bool()?))\n             }\n             ty::Float(fty) => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n                 let ty = left.layout.ty;\n-                let left = left.to_scalar()?;\n-                let right = right.to_scalar()?;\n+                let left = left.to_scalar();\n+                let right = right.to_scalar();\n                 Ok(match fty {\n                     FloatTy::F32 => {\n                         self.binary_float_op(bin_op, ty, left.to_f32()?, right.to_f32()?)\n@@ -363,8 +363,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     right.layout.ty\n                 );\n \n-                let l = left.to_scalar()?.to_bits(left.layout.size)?;\n-                let r = right.to_scalar()?.to_bits(right.layout.size)?;\n+                let l = left.to_scalar().to_bits(left.layout.size)?;\n+                let r = right.to_scalar().to_bits(right.layout.size)?;\n                 self.binary_int_op(bin_op, l, left.layout, r, right.layout)\n             }\n             _ if left.layout.ty.is_any_ptr() => {\n@@ -410,7 +410,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::UnOp::*;\n \n         let layout = val.layout;\n-        let val = val.to_scalar()?;\n+        let val = val.to_scalar();\n         trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty);\n \n         match layout.ty.kind() {"}, {"sha": "a03b0dfb6038b737739098c77213a4433caab1e5", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,8 +2,6 @@\n //! into a place.\n //! All high-level functions to write to memory work on places as destinations.\n \n-use std::hash::Hash;\n-\n use rustc_ast::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty;\n@@ -13,7 +11,7 @@ use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding, Vari\n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n     ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, Machine, MemoryKind, OpTy, Operand,\n-    Pointer, Provenance, Scalar, ScalarMaybeUninit,\n+    Pointer, Provenance, Scalar,\n };\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n@@ -254,8 +252,6 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n // These are defined here because they produce a place.\n impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n     #[inline(always)]\n-    /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n-    /// read from the resulting mplace, not to get its address back.\n     pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Prov>, ImmTy<'tcx, Prov>> {\n         match **self {\n             Operand::Indirect(mplace) => {\n@@ -267,8 +263,6 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n-    /// read from the resulting mplace, not to get its address back.\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n         self.try_as_mplace().unwrap()\n     }\n@@ -294,7 +288,7 @@ impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n impl<'mir, 'tcx: 'mir, Prov, M> InterpCx<'mir, 'tcx, M>\n where\n-    Prov: Provenance + Eq + Hash + 'static,\n+    Prov: Provenance + 'static,\n     M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place.\n@@ -312,7 +306,7 @@ where\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match **val {\n             Immediate::Scalar(ptr) => (ptr, MemPlaceMeta::None),\n-            Immediate::ScalarPair(ptr, meta) => (ptr, MemPlaceMeta::Meta(meta.check_init()?)),\n+            Immediate::ScalarPair(ptr, meta) => (ptr, MemPlaceMeta::Meta(meta)),\n             Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         };\n \n@@ -467,7 +461,7 @@ where\n     #[inline(always)]\n     pub fn write_scalar(\n         &mut self,\n-        val: impl Into<ScalarMaybeUninit<M::Provenance>>,\n+        val: impl Into<Scalar<M::Provenance>>,\n         dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate(Immediate::Scalar(val.into()), dest)\n@@ -644,9 +638,9 @@ where\n \n         // Let us see if the layout is simple so we take a shortcut,\n         // avoid force_allocation.\n-        let src = match self.read_immediate_raw(src, /*force*/ false)? {\n+        let src = match self.read_immediate_raw(src)? {\n             Ok(src_val) => {\n-                assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n+                assert!(!src.layout.is_unsized(), \"cannot copy unsized immediates\");\n                 assert!(\n                     !dest.layout.is_unsized(),\n                     \"the src is sized, so the dest must also be sized\""}, {"sha": "67dc9011ea209ace27078a8460ecc627feb1091b", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -7,8 +7,6 @@\n //! but we still need to do bounds checking and adjust the layout. To not duplicate that with MPlaceTy, we actually\n //! implement the logic on OpTy, and MPlaceTy calls that.\n \n-use std::hash::Hash;\n-\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::LayoutOf;\n@@ -22,7 +20,7 @@ use super::{\n // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n impl<'mir, 'tcx: 'mir, Prov, M> InterpCx<'mir, 'tcx, M>\n where\n-    Prov: Provenance + Eq + Hash + 'static,\n+    Prov: Provenance + 'static,\n     M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     //# Field access\n@@ -100,6 +98,8 @@ where\n         // This makes several assumptions about what layouts we will encounter; we match what\n         // codegen does as good as we can (see `extract_field` in `rustc_codegen_ssa/src/mir/operand.rs`).\n         let field_val: Immediate<_> = match (*base, base.layout.abi) {\n+            // if the entire value is uninit, then so is the field (can happen in ConstProp)\n+            (Immediate::Uninit, _) => Immediate::Uninit,\n             // the field contains no information, can be left uninit\n             _ if field_layout.is_zst() => Immediate::Uninit,\n             // the field covers the entire type\n@@ -124,6 +124,7 @@ where\n                     b_val\n                 })\n             }\n+            // everything else is a bug\n             _ => span_bug!(\n                 self.cur_span(),\n                 \"invalid field access on immediate {}, layout {:#?}\","}, {"sha": "6b827149f505ea60f6c7c44e1d7fb39652eb67fa", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -53,7 +53,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.pop_stack_frame(/* unwinding */ true)?;\n             return Ok(true);\n         };\n-        let basic_block = &self.body().basic_blocks()[loc.block];\n+        let basic_block = &self.body().basic_blocks[loc.block];\n \n         if let Some(stmt) = basic_block.statements.get(loc.statement_index) {\n             let old_frames = self.frame_idx();\n@@ -251,8 +251,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Len(place) => {\n                 let src = self.eval_place(place)?;\n-                let mplace = self.force_allocation(&src)?;\n-                let len = mplace.len(self)?;\n+                let op = self.place_to_op(&src)?;\n+                let len = op.len(self)?;\n                 self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n             }\n "}, {"sha": "a71a5d4b833c8c43d2681f92afe6544e6c45ae4e", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -129,8 +129,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let cond_val =\n-                    self.read_immediate(&self.eval_operand(cond, None)?)?.to_scalar()?.to_bool()?;\n+                let cond_val = self.read_scalar(&self.eval_operand(cond, None)?)?.to_bool()?;\n                 if expected == cond_val {\n                     self.go_to_block(target);\n                 } else {\n@@ -215,10 +214,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 _ => false,\n             }\n         };\n-        // Padding must be fully equal.\n-        let pad_compat = || caller_abi.pad == callee_abi.pad;\n         // When comparing the PassMode, we have to be smart about comparing the attributes.\n-        let arg_attr_compat = |a1: ArgAttributes, a2: ArgAttributes| {\n+        let arg_attr_compat = |a1: &ArgAttributes, a2: &ArgAttributes| {\n             // There's only one regular attribute that matters for the call ABI: InReg.\n             // Everything else is things like noalias, dereferencable, nonnull, ...\n             // (This also applies to pointee_size, pointee_align.)\n@@ -233,13 +230,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             return true;\n         };\n-        let mode_compat = || match (caller_abi.mode, callee_abi.mode) {\n+        let mode_compat = || match (&caller_abi.mode, &callee_abi.mode) {\n             (PassMode::Ignore, PassMode::Ignore) => true,\n             (PassMode::Direct(a1), PassMode::Direct(a2)) => arg_attr_compat(a1, a2),\n             (PassMode::Pair(a1, b1), PassMode::Pair(a2, b2)) => {\n                 arg_attr_compat(a1, a2) && arg_attr_compat(b1, b2)\n             }\n-            (PassMode::Cast(c1), PassMode::Cast(c2)) => c1 == c2,\n+            (PassMode::Cast(c1, pad1), PassMode::Cast(c2, pad2)) => c1 == c2 && pad1 == pad2,\n             (\n                 PassMode::Indirect { attrs: a1, extra_attrs: None, on_stack: s1 },\n                 PassMode::Indirect { attrs: a2, extra_attrs: None, on_stack: s2 },\n@@ -251,7 +248,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => false,\n         };\n \n-        if layout_compat() && pad_compat() && mode_compat() {\n+        if layout_compat() && mode_compat() {\n             return true;\n         }\n         trace!("}, {"sha": "0382e2d5805aacb10148c56487e9694aa609a0bc", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 128, "deletions": 162, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,6 +8,7 @@ use std::convert::TryFrom;\n use std::fmt::Write;\n use std::num::NonZeroUsize;\n \n+use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpError;\n@@ -19,9 +20,11 @@ use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, Wr\n \n use std::hash::Hash;\n \n+// for the validation errors\n+use super::UndefinedBehaviorInfo::*;\n use super::{\n-    alloc_range, CheckInAllocMsg, GlobalAlloc, Immediate, InterpCx, InterpResult, MPlaceTy,\n-    Machine, MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n+    CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine,\n+    MemPlaceMeta, OpTy, Scalar, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -59,6 +62,7 @@ macro_rules! throw_validation_failure {\n /// });\n /// ```\n ///\n+/// The patterns must be of type `UndefinedBehaviorInfo`.\n /// An additional expected parameter can also be added to the failure message:\n ///\n /// ```\n@@ -86,7 +90,7 @@ macro_rules! try_validation {\n             // allocation here as this can only slow down builds that fail anyway.\n             Err(e) => match e.kind() {\n                 $(\n-                    $($p)|+ =>\n+                    InterpError::UndefinedBehavior($($p)|+) =>\n                        throw_validation_failure!(\n                             $where,\n                             { $( $what_fmt ),+ } $( expected { $( $expected_fmt ),+ } )?\n@@ -304,6 +308,26 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         Ok(r)\n     }\n \n+    fn read_immediate(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+        expected: &str,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n+        Ok(try_validation!(\n+            self.ecx.read_immediate(op),\n+            self.path,\n+            InvalidUninitBytes(None) => { \"uninitialized memory\" } expected { \"{expected}\" }\n+        ))\n+    }\n+\n+    fn read_scalar(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+        expected: &str,\n+    ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n+        Ok(self.read_immediate(op, expected)?.to_scalar())\n+    }\n+\n     fn check_wide_ptr_meta(\n         &mut self,\n         meta: MemPlaceMeta<M::Provenance>,\n@@ -317,18 +341,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let (_ty, _trait) = try_validation!(\n                     self.ecx.get_ptr_vtable(vtable),\n                     self.path,\n-                    err_ub!(DanglingIntPointer(..)) |\n-                    err_ub!(InvalidVTablePointer(..)) =>\n+                    DanglingIntPointer(..) |\n+                    InvalidVTablePointer(..) =>\n                         { \"{vtable}\" } expected { \"a vtable pointer\" },\n                 );\n                 // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n             ty::Slice(..) | ty::Str => {\n-                let _len = try_validation!(\n-                    meta.unwrap_meta().to_machine_usize(self.ecx),\n-                    self.path,\n-                    err_unsup!(ReadPointerAsBytes) => { \"non-integer slice length in wide pointer\" },\n-                );\n+                let _len = meta.unwrap_meta().to_machine_usize(self.ecx)?;\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n                 // \"dereferenceable\" check performed by Stacked Borrows.\n@@ -348,26 +368,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         value: &OpTy<'tcx, M::Provenance>,\n         kind: &str,\n     ) -> InterpResult<'tcx> {\n-        let value = try_validation!(\n-            self.ecx.read_immediate(value),\n-            self.path,\n-            err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n-        );\n+        let place = self.ecx.ref_to_mplace(&self.read_immediate(value, &format!(\"a {kind}\"))?)?;\n         // Handle wide pointers.\n         // Check metadata early, for better diagnostics\n-        let place = try_validation!(\n-            self.ecx.ref_to_mplace(&value),\n-            self.path,\n-            err_ub!(InvalidUninitBytes(None)) => { \"uninitialized {}\", kind },\n-        );\n         if place.layout.is_unsized() {\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n         }\n         // Make sure this is dereferenceable and all.\n         let size_and_align = try_validation!(\n             self.ecx.size_and_align_of_mplace(&place),\n             self.path,\n-            err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n+            InvalidMeta(msg) => { \"invalid {} metadata: {}\", kind, msg },\n         );\n         let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n@@ -383,21 +394,21 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n             ),\n             self.path,\n-            err_ub!(AlignmentCheckFailed { required, has }) =>\n+            AlignmentCheckFailed { required, has } =>\n                 {\n                     \"an unaligned {kind} (required {} byte alignment but found {})\",\n                     required.bytes(),\n                     has.bytes()\n                 },\n-            err_ub!(DanglingIntPointer(0, _)) =>\n+            DanglingIntPointer(0, _) =>\n                 { \"a null {kind}\" },\n-            err_ub!(DanglingIntPointer(i, _)) =>\n+            DanglingIntPointer(i, _) =>\n                 { \"a dangling {kind} (address {i:#x} is unallocated)\" },\n-            err_ub!(PointerOutOfBounds { .. }) =>\n+            PointerOutOfBounds { .. } =>\n                 { \"a dangling {kind} (going beyond the bounds of its allocation)\" },\n             // This cannot happen during const-eval (because interning already detects\n             // dangling pointers), but it can happen in Miri.\n-            err_ub!(PointerUseAfterFree(..)) =>\n+            PointerUseAfterFree(..) =>\n                 { \"a dangling {kind} (use-after-free)\" },\n         );\n         // Do not allow pointers to uninhabited types.\n@@ -411,34 +422,51 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n             if let Ok((alloc_id, _offset, _prov)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n-                // Special handling for pointers to statics (irrespective of their type).\n+                // Let's see what kind of memory this points to.\n                 let alloc_kind = self.ecx.tcx.try_get_global_alloc(alloc_id);\n-                if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n-                    assert!(!self.ecx.tcx.is_thread_local_static(did));\n-                    assert!(self.ecx.tcx.is_static(did));\n-                    if matches!(\n-                        self.ctfe_mode,\n-                        Some(CtfeValidationMode::Const { allow_static_ptrs: false, .. })\n-                    ) {\n-                        // See const_eval::machine::MemoryExtra::can_access_statics for why\n-                        // this check is so important.\n-                        // This check is reachable when the const just referenced the static,\n-                        // but never read it (so we never entered `before_access_global`).\n-                        throw_validation_failure!(self.path,\n-                            { \"a {} pointing to a static variable\", kind }\n-                        );\n+                match alloc_kind {\n+                    Some(GlobalAlloc::Static(did)) => {\n+                        // Special handling for pointers to statics (irrespective of their type).\n+                        assert!(!self.ecx.tcx.is_thread_local_static(did));\n+                        assert!(self.ecx.tcx.is_static(did));\n+                        if matches!(\n+                            self.ctfe_mode,\n+                            Some(CtfeValidationMode::Const { allow_static_ptrs: false, .. })\n+                        ) {\n+                            // See const_eval::machine::MemoryExtra::can_access_statics for why\n+                            // this check is so important.\n+                            // This check is reachable when the const just referenced the static,\n+                            // but never read it (so we never entered `before_access_global`).\n+                            throw_validation_failure!(self.path,\n+                                { \"a {} pointing to a static variable in a constant\", kind }\n+                            );\n+                        }\n+                        // We skip recursively checking other statics. These statics must be sound by\n+                        // themselves, and the only way to get broken statics here is by using\n+                        // unsafe code.\n+                        // The reasons we don't check other statics is twofold. For one, in all\n+                        // sound cases, the static was already validated on its own, and second, we\n+                        // trigger cycle errors if we try to compute the value of the other static\n+                        // and that static refers back to us.\n+                        // We might miss const-invalid data,\n+                        // but things are still sound otherwise (in particular re: consts\n+                        // referring to statics).\n+                        return Ok(());\n                     }\n-                    // We skip checking other statics. These statics must be sound by\n-                    // themselves, and the only way to get broken statics here is by using\n-                    // unsafe code.\n-                    // The reasons we don't check other statics is twofold. For one, in all\n-                    // sound cases, the static was already validated on its own, and second, we\n-                    // trigger cycle errors if we try to compute the value of the other static\n-                    // and that static refers back to us.\n-                    // We might miss const-invalid data,\n-                    // but things are still sound otherwise (in particular re: consts\n-                    // referring to statics).\n-                    return Ok(());\n+                    Some(GlobalAlloc::Memory(alloc)) => {\n+                        if alloc.inner().mutability == Mutability::Mut\n+                            && matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. }))\n+                        {\n+                            // This should be unreachable, but if someone manages to copy a pointer\n+                            // out of a `static`, then that pointer might point to mutable memory,\n+                            // and we would catch that here.\n+                            throw_validation_failure!(self.path,\n+                                { \"a {} pointing to mutable memory in a constant\", kind }\n+                            );\n+                        }\n+                    }\n+                    // Nothing to check for these.\n+                    None | Some(GlobalAlloc::Function(..) | GlobalAlloc::VTable(..)) => {}\n                 }\n             }\n             let path = &self.path;\n@@ -454,28 +482,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         Ok(())\n     }\n \n-    fn read_scalar(\n-        &self,\n-        op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::Provenance>> {\n-        Ok(try_validation!(\n-            self.ecx.read_scalar(op),\n-            self.path,\n-            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"plain (non-pointer) bytes\" },\n-        ))\n-    }\n-\n-    fn read_immediate_forced(\n-        &self,\n-        op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n-        Ok(*try_validation!(\n-            self.ecx.read_immediate_raw(op, /*force*/ true),\n-            self.path,\n-            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"plain (non-pointer) bytes\" },\n-        ).unwrap())\n-    }\n-\n     /// Check if this is a value of primitive type, and if yes check the validity of the value\n     /// at that type.  Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n@@ -486,41 +492,39 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let ty = value.layout.ty;\n         match ty.kind() {\n             ty::Bool => {\n-                let value = self.read_scalar(value)?;\n+                let value = self.read_scalar(value, \"a boolean\")?;\n                 try_validation!(\n                     value.to_bool(),\n                     self.path,\n-                    err_ub!(InvalidBool(..)) | err_ub!(InvalidUninitBytes(None)) =>\n+                    InvalidBool(..) =>\n                         { \"{:x}\", value } expected { \"a boolean\" },\n                 );\n                 Ok(true)\n             }\n             ty::Char => {\n-                let value = self.read_scalar(value)?;\n+                let value = self.read_scalar(value, \"a unicode scalar value\")?;\n                 try_validation!(\n                     value.to_char(),\n                     self.path,\n-                    err_ub!(InvalidChar(..)) | err_ub!(InvalidUninitBytes(None)) =>\n+                    InvalidChar(..) =>\n                         { \"{:x}\", value } expected { \"a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\" },\n                 );\n                 Ok(true)\n             }\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n-                let value = self.read_scalar(value)?;\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n-                if M::enforce_number_init(self.ecx) {\n-                    try_validation!(\n-                        value.check_init(),\n-                        self.path,\n-                        err_ub!(InvalidUninitBytes(..)) =>\n-                            { \"{:x}\", value } expected { \"initialized bytes\" }\n-                    );\n-                }\n+                let value = self.read_scalar(\n+                    value,\n+                    if matches!(ty.kind(), ty::Float(..)) {\n+                        \"a floating point number\"\n+                    } else {\n+                        \"an integer\"\n+                    },\n+                )?;\n                 // As a special exception we *do* match on a `Scalar` here, since we truly want\n                 // to know its underlying representation (and *not* cast it to an integer).\n-                let is_ptr = value.check_init().map_or(false, |v| matches!(v, Scalar::Ptr(..)));\n-                if is_ptr {\n+                if matches!(value, Scalar::Ptr(..)) {\n                     throw_validation_failure!(self.path,\n                         { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n                     )\n@@ -531,20 +535,16 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // We are conservative with uninit for integers, but try to\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n-                let place = try_validation!(\n-                    self.ecx.read_immediate(value).and_then(|ref i| self.ecx.ref_to_mplace(i)),\n-                    self.path,\n-                    err_ub!(InvalidUninitBytes(None)) => { \"uninitialized raw pointer\" },\n-                    err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n-                );\n+                let place =\n+                    self.ecx.ref_to_mplace(&self.read_immediate(value, \"a raw pointer\")?)?;\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n                 Ok(true)\n             }\n             ty::Ref(_, ty, mutbl) => {\n                 if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. }))\n-                    && *mutbl == hir::Mutability::Mut\n+                    && *mutbl == Mutability::Mut\n                 {\n                     // A mutable reference inside a const? That does not seem right (except if it is\n                     // a ZST).\n@@ -557,21 +557,16 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 Ok(true)\n             }\n             ty::FnPtr(_sig) => {\n-                let value = try_validation!(\n-                    self.ecx.read_scalar(value).and_then(|v| v.check_init()),\n-                    self.path,\n-                    err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n-                    err_ub!(InvalidUninitBytes(None)) => { \"uninitialized bytes\" } expected { \"a proper pointer or integer value\" },\n-                );\n+                let value = self.read_scalar(value, \"a function pointer\")?;\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n                     let ptr = value.to_pointer(self.ecx)?;\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n-                        err_ub!(DanglingIntPointer(..)) |\n-                        err_ub!(InvalidFunctionPointer(..)) =>\n+                        DanglingIntPointer(..) |\n+                        InvalidFunctionPointer(..) =>\n                             { \"{ptr}\" } expected { \"a function pointer\" },\n                     );\n                     // FIXME: Check if the signature matches\n@@ -613,48 +608,23 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn visit_scalar(\n         &mut self,\n-        scalar: ScalarMaybeUninit<M::Provenance>,\n+        scalar: Scalar<M::Provenance>,\n         scalar_layout: ScalarAbi,\n     ) -> InterpResult<'tcx> {\n-        // We check `is_full_range` in a slightly complicated way because *if* we are checking\n-        // number validity, then we want to ensure that `Scalar::Initialized` is indeed initialized,\n-        // i.e. that we go over the `check_init` below.\n         let size = scalar_layout.size(self.ecx);\n-        let is_full_range = match scalar_layout {\n-            ScalarAbi::Initialized { .. } => {\n-                if M::enforce_number_init(self.ecx) {\n-                    false // not \"full\" since uninit is not accepted\n-                } else {\n-                    scalar_layout.is_always_valid(self.ecx)\n-                }\n-            }\n-            ScalarAbi::Union { .. } => true,\n-        };\n-        if is_full_range {\n-            // Nothing to check. Cruciall we don't even `read_scalar` until here, since that would\n-            // fail for `Union` scalars!\n-            return Ok(());\n-        }\n-        // We have something to check: it must at least be initialized.\n         let valid_range = scalar_layout.valid_range(self.ecx);\n         let WrappingRange { start, end } = valid_range;\n         let max_value = size.unsigned_int_max();\n         assert!(end <= max_value);\n-        let value = try_validation!(\n-            scalar.check_init(),\n-            self.path,\n-            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", scalar }\n-                expected { \"something {}\", wrapping_range_format(valid_range, max_value) },\n-        );\n-        let bits = match value.try_to_int() {\n+        let bits = match scalar.try_to_int() {\n             Ok(int) => int.assert_bits(size),\n             Err(_) => {\n                 // So this is a pointer then, and casting to an int failed.\n                 // Can only happen during CTFE.\n                 // We support 2 kinds of ranges here: full range, and excluding zero.\n                 if start == 1 && end == max_value {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n-                    if self.ecx.scalar_may_be_null(value)? {\n+                    if self.ecx.scalar_may_be_null(scalar)? {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n                             expected {\n@@ -711,12 +681,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             Ok(try_validation!(\n                 this.ecx.read_discriminant(op),\n                 this.path,\n-                err_ub!(InvalidTag(val)) =>\n+                InvalidTag(val) =>\n                     { \"{:x}\", val } expected { \"a valid enum tag\" },\n-                err_ub!(InvalidUninitBytes(None)) =>\n+                InvalidUninitBytes(None) =>\n                     { \"uninitialized bytes\" } expected { \"a valid enum tag\" },\n-                err_unsup!(ReadPointerAsBytes) =>\n-                    { \"a pointer\" } expected { \"a valid enum tag\" },\n             )\n             .1)\n         })\n@@ -808,21 +776,27 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 );\n             }\n             Abi::Scalar(scalar_layout) => {\n-                // We use a 'forced' read because we always need a `Immediate` here\n-                // and treating \"partially uninit\" as \"fully uninit\" is fine for us.\n-                let scalar = self.read_immediate_forced(op)?.to_scalar_or_uninit();\n-                self.visit_scalar(scalar, scalar_layout)?;\n+                if !scalar_layout.is_uninit_valid() {\n+                    // There is something to check here.\n+                    let scalar = self.read_scalar(op, \"initiailized scalar value\")?;\n+                    self.visit_scalar(scalar, scalar_layout)?;\n+                }\n             }\n             Abi::ScalarPair(a_layout, b_layout) => {\n                 // There is no `rustc_layout_scalar_valid_range_start` for pairs, so\n                 // we would validate these things as we descend into the fields,\n                 // but that can miss bugs in layout computation. Layout computation\n                 // is subtle due to enums having ScalarPair layout, where one field\n                 // is the discriminant.\n-                if cfg!(debug_assertions) {\n-                    // We use a 'forced' read because we always need a `Immediate` here\n-                    // and treating \"partially uninit\" as \"fully uninit\" is fine for us.\n-                    let (a, b) = self.read_immediate_forced(op)?.to_scalar_or_uninit_pair();\n+                if cfg!(debug_assertions)\n+                    && !a_layout.is_uninit_valid()\n+                    && !b_layout.is_uninit_valid()\n+                {\n+                    // We can only proceed if *both* scalars need to be initialized.\n+                    // FIXME: find a way to also check ScalarPair when one side can be uninit but\n+                    // the other must be init.\n+                    let (a, b) =\n+                        self.read_immediate(op, \"initiailized scalar value\")?.to_scalar_pair();\n                     self.visit_scalar(a, a_layout)?;\n                     self.visit_scalar(b, b_layout)?;\n                 }\n@@ -850,10 +824,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(); // strings are unsized and hence never immediate\n                 let len = mplace.len(self.ecx)?;\n                 try_validation!(\n-                    self.ecx.read_bytes_ptr(mplace.ptr, Size::from_bytes(len)),\n+                    self.ecx.read_bytes_ptr_strip_provenance(mplace.ptr, Size::from_bytes(len)),\n                     self.path,\n-                    err_ub!(InvalidUninitBytes(..)) => { \"uninitialized data in `str`\" },\n-                    err_unsup!(ReadPointerAsBytes) => { \"a pointer in `str`\" },\n+                    InvalidUninitBytes(..) => { \"uninitialized data in `str`\" },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n@@ -901,13 +874,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // We also accept uninit, for consistency with the slow path.\n                 let alloc = self.ecx.get_ptr_alloc(mplace.ptr, size, mplace.align)?.expect(\"we already excluded size 0\");\n \n-                match alloc.check_bytes(\n-                    alloc_range(Size::ZERO, size),\n-                    /*allow_uninit*/ !M::enforce_number_init(self.ecx),\n-                    /*allow_ptr*/ false,\n-                ) {\n+                match alloc.get_bytes_strip_provenance() {\n                     // In the happy case, we needn't check anything else.\n-                    Ok(()) => {}\n+                    Ok(_) => {}\n                     // Some error happened, try to provide a more detailed description.\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information.\n@@ -925,9 +894,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n                                 throw_validation_failure!(self.path, { \"uninitialized bytes\" })\n                             }\n-                            err_unsup!(ReadPointerAsBytes) => {\n-                                throw_validation_failure!(self.path, { \"a pointer\" } expected { \"plain (non-pointer) bytes\" })\n-                            }\n \n                             // Propagate upwards (that will also check for unexpected errors).\n                             _ => return Err(err),\n@@ -968,14 +934,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Ok(()) => Ok(()),\n             // Pass through validation failures.\n             Err(err) if matches!(err.kind(), err_ub!(ValidationFailure { .. })) => Err(err),\n-            // Also pass through InvalidProgram, those just indicate that we could not\n-            // validate and each caller will know best what to do with them.\n-            Err(err) if matches!(err.kind(), InterpError::InvalidProgram(_)) => Err(err),\n-            // Avoid other errors as those do not show *where* in the value the issue lies.\n-            Err(err) => {\n+            // Complain about any other kind of UB error -- those are bad because we'd like to\n+            // report them in a way that shows *where* in the value the issue lies.\n+            Err(err) if matches!(err.kind(), InterpError::UndefinedBehavior(_)) => {\n                 err.print_backtrace();\n-                bug!(\"Unexpected error during validation: {}\", err);\n+                bug!(\"Unexpected Undefined Behavior error during validation: {}\", err);\n             }\n+            // Pass through everything else.\n+            Err(err) => Err(err),\n         }\n     }\n "}, {"sha": "72ac6af685dc4b247341c8a9fec847e1177cac83", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -9,6 +9,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(control_flow_enum)]\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]"}, {"sha": "37ffa19ccd6b9d7097c431545641129fdac547b6", "filename": "compiler/rustc_const_eval/src/might_permit_raw_init.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -13,7 +13,11 @@ pub fn might_permit_raw_init<'tcx>(\n     let strict = tcx.sess.opts.unstable_opts.strict_init_checks;\n \n     if strict {\n-        let machine = CompileTimeInterpreter::new(Limit::new(0), false);\n+        let machine = CompileTimeInterpreter::new(\n+            Limit::new(0),\n+            /*can_access_statics:*/ false,\n+            /*check_alignment:*/ true,\n+        );\n \n         let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n "}, {"sha": "cbfdb47dd1a4072eb30b9c919873f69e38b69b32", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -135,7 +135,7 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         // qualifs for the return type.\n         let return_block = ccx\n             .body\n-            .basic_blocks()\n+            .basic_blocks\n             .iter_enumerated()\n             .find(|(_, block)| matches!(block.terminator().kind, TerminatorKind::Return))\n             .map(|(bb, _)| bb);"}, {"sha": "5fb4bf638b342648d8648926c4aaeba2872e0a07", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 56, "deletions": 105, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,6 +1,7 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n use hir::def_id::LocalDefId;\n+use hir::ConstContext;\n use rustc_errors::{\n     error_code, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed,\n };\n@@ -23,8 +24,11 @@ use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n use crate::errors::{\n-    MutDerefErr, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n-    TransientMutBorrowErr, TransientMutBorrowErrRaw,\n+    InteriorMutabilityBorrow, InteriorMutableDataRefer, MutDerefErr, NonConstFmtMacroCall,\n+    NonConstFnCall, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n+    TransientMutBorrowErr, TransientMutBorrowErrRaw, UnallowedFnPointerCall,\n+    UnallowedHeapAllocations, UnallowedInlineAsm, UnallowedMutableRefs, UnallowedMutableRefsRaw,\n+    UnallowedOpInConstContext, UnstableConstFn,\n };\n use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n@@ -96,10 +100,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.struct_span_err(\n-            span,\n-            &format!(\"function pointer calls are not allowed in {}s\", ccx.const_kind()),\n-        )\n+        ccx.tcx.sess.create_err(UnallowedFnPointerCall { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -307,22 +308,13 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 err\n             }\n             _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => {\n-                struct_span_err!(\n-                    ccx.tcx.sess,\n-                    span,\n-                    E0015,\n-                    \"cannot call non-const formatting macro in {}s\",\n-                    ccx.const_kind(),\n-                )\n+                ccx.tcx.sess.create_err(NonConstFmtMacroCall { span, kind: ccx.const_kind() })\n             }\n-            _ => struct_span_err!(\n-                ccx.tcx.sess,\n+            _ => ccx.tcx.sess.create_err(NonConstFnCall {\n                 span,\n-                E0015,\n-                \"cannot call non-const fn `{}` in {}s\",\n-                ccx.tcx.def_path_str_with_substs(callee, substs),\n-                ccx.const_kind(),\n-            ),\n+                def_path_str: ccx.tcx.def_path_str_with_substs(callee, substs),\n+                kind: ccx.const_kind(),\n+            }),\n         };\n \n         err.note(&format!(\n@@ -331,6 +323,10 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n             ccx.const_kind(),\n         ));\n \n+        if let ConstContext::Static(_) = ccx.const_kind() {\n+            err.note(\"consider wrapping this expression in `Lazy::new(|| ...)` from the `once_cell` crate: https://crates.io/crates/once_cell\");\n+        }\n+\n         err\n     }\n }\n@@ -349,10 +345,10 @@ impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let FnCallUnstable(def_id, feature) = *self;\n \n-        let mut err = ccx.tcx.sess.struct_span_err(\n-            span,\n-            &format!(\"`{}` is not yet stable as a const fn\", ccx.tcx.def_path_str(def_id)),\n-        );\n+        let mut err = ccx\n+            .tcx\n+            .sess\n+            .create_err(UnstableConstFn { span, def_path: ccx.tcx.def_path_str(def_id) });\n \n         if ccx.is_const_stable_const_fn() {\n             err.help(\"const-stable functions can only call other const-stable functions\");\n@@ -387,9 +383,12 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n-            feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n+            ccx.tcx.sess.create_feature_err(\n+                UnallowedOpInConstContext { span, msg },\n+                sym::const_async_blocks,\n+            )\n         } else {\n-            ccx.tcx.sess.struct_span_err(span, &msg)\n+            ccx.tcx.sess.create_err(UnallowedOpInConstContext { span, msg })\n         }\n     }\n }\n@@ -402,23 +401,11 @@ impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n+        ccx.tcx.sess.create_err(UnallowedHeapAllocations {\n             span,\n-            E0010,\n-            \"allocations are not allowed in {}s\",\n-            ccx.const_kind()\n-        );\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", ccx.const_kind()));\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"The value of statics and constants must be known at compile time, \\\n-                 and they live for the entire lifetime of a program. Creating a boxed \\\n-                 value allocates memory on the heap at runtime, and therefore cannot \\\n-                 be done at compile time.\",\n-            );\n-        }\n-        err\n+            kind: ccx.const_kind(),\n+            teach: ccx.tcx.sess.teach(&error_code!(E0010)).then_some(()),\n+        })\n     }\n }\n \n@@ -430,13 +417,7 @@ impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0015,\n-            \"inline assembly is not allowed in {}s\",\n-            ccx.const_kind()\n-        )\n+        ccx.tcx.sess.create_err(UnallowedInlineAsm { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -482,12 +463,7 @@ impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        feature_err(\n-            &ccx.tcx.sess.parse_sess,\n-            sym::const_refs_to_cell,\n-            span,\n-            \"cannot borrow here, since the borrowed element may contain interior mutability\",\n-        )\n+        ccx.tcx.sess.create_feature_err(InteriorMutabilityBorrow { span }, sym::const_refs_to_cell)\n     }\n }\n \n@@ -502,32 +478,22 @@ impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0492,\n-            \"{}s cannot refer to interior mutable data\",\n-            ccx.const_kind(),\n-        );\n-        err.span_label(\n-            span,\n-            \"this borrow of an interior mutable value may end up in the final value\",\n-        );\n+        // FIXME: Maybe a more elegant solution to this if else case\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n-            err.help(\n-                \"to fix this, the value can be extracted to a separate \\\n-                `static` item and then referenced\",\n-            );\n-        }\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"A constant containing interior mutable data behind a reference can allow you\n-                 to modify that data. This would make multiple uses of a constant to be able to\n-                 see different values and allow circumventing the `Send` and `Sync` requirements\n-                 for shared mutable data, which is unsound.\",\n-            );\n+            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+                span,\n+                opt_help: Some(()),\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n+            })\n+        } else {\n+            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+                span,\n+                opt_help: None,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n+            })\n         }\n-        err\n     }\n }\n \n@@ -553,33 +519,18 @@ impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let raw = match self.0 {\n-            hir::BorrowKind::Raw => \"raw \",\n-            hir::BorrowKind::Ref => \"\",\n-        };\n-\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0764,\n-            \"{}mutable references are not allowed in the final value of {}s\",\n-            raw,\n-            ccx.const_kind(),\n-        );\n-\n-        if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\n-                \"References in statics and constants may only refer \\\n-                      to immutable values.\\n\\n\\\n-                      Statics are shared everywhere, and if they refer to \\\n-                      mutable data one might violate memory safety since \\\n-                      holding multiple mutable references to shared data \\\n-                      is not allowed.\\n\\n\\\n-                      If you really want global mutable state, try using \\\n-                      static mut or a global UnsafeCell.\",\n-            );\n+        match self.0 {\n+            hir::BorrowKind::Raw => ccx.tcx.sess.create_err(UnallowedMutableRefsRaw {\n+                span,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+            }),\n+            hir::BorrowKind::Ref => ccx.tcx.sess.create_err(UnallowedMutableRefs {\n+                span,\n+                kind: ccx.const_kind(),\n+                teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n+            }),\n         }\n-        err\n     }\n }\n "}, {"sha": "f5ba408bee0e132955e38c978f7a03e5a1c478ba", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -41,7 +41,7 @@ pub struct PromoteTemps<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n     fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::ConstsPromoted)\n+        Some(MirPhase::Analysis(AnalysisPhase::Initial))\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n@@ -710,7 +710,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn assign(&mut self, dest: Local, rvalue: Rvalue<'tcx>, span: Span) {\n-        let last = self.promoted.basic_blocks().last().unwrap();\n+        let last = self.promoted.basic_blocks.last().unwrap();\n         let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo::outermost(span),\n@@ -803,7 +803,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         self.visit_operand(arg, loc);\n                     }\n \n-                    let last = self.promoted.basic_blocks().last().unwrap();\n+                    let last = self.promoted.basic_blocks.last().unwrap();\n                     let new_target = self.new_block();\n \n                     *self.promoted[last].terminator_mut() = Terminator {\n@@ -964,7 +964,7 @@ pub fn promote_candidates<'tcx>(\n         let mut scope = body.source_scopes[body.source_info(candidate.location).scope].clone();\n         scope.parent_scope = None;\n \n-        let promoted = Body::new(\n+        let mut promoted = Body::new(\n             body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n             IndexVec::from_elem_n(scope, 1),\n@@ -976,6 +976,7 @@ pub fn promote_candidates<'tcx>(\n             body.generator_kind(),\n             body.tainted_by_errors,\n         );\n+        promoted.phase = MirPhase::Analysis(AnalysisPhase::Initial);\n \n         let promoter = Promoter {\n             promoted,\n@@ -1041,7 +1042,7 @@ pub fn is_const_fn_in_array_repeat_expression<'tcx>(\n         _ => {}\n     }\n \n-    for block in body.basic_blocks() {\n+    for block in body.basic_blocks.iter() {\n         if let Some(Terminator { kind: TerminatorKind::Call { func, destination, .. }, .. }) =\n             &block.terminator\n         {"}, {"sha": "b662513e70fbe6ee0d57ec27d50c651bd691c5c1", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,8 +8,8 @@ use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n     traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, Local, Location,\n-    MirPass, MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope,\n-    Statement, StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n+    MirPass, MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, RuntimePhase, Rvalue,\n+    SourceScope, Statement, StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::Subst;\n@@ -89,22 +89,20 @@ pub fn equal_up_to_regions<'tcx>(\n \n     // Normalize lifetimes away on both sides, then compare.\n     let normalize = |ty: Ty<'tcx>| {\n-        tcx.normalize_erasing_regions(\n-            param_env,\n-            ty.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n-                // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n-                // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n-                // since one may have an `impl SomeTrait for fn(&32)` and\n-                // `impl SomeTrait for fn(&'static u32)` at the same time which\n-                // specify distinct values for Assoc. (See also #56105)\n-                lt_op: |_| tcx.lifetimes.re_erased,\n-                // Leave consts and types unchanged.\n-                ct_op: |ct| ct,\n-                ty_op: |ty| ty,\n-            }),\n-        )\n+        let ty = ty.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n+            // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n+            // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n+            // since one may have an `impl SomeTrait for fn(&32)` and\n+            // `impl SomeTrait for fn(&'static u32)` at the same time which\n+            // specify distinct values for Assoc. (See also #56105)\n+            lt_op: |_| tcx.lifetimes.re_erased,\n+            // Leave consts and types unchanged.\n+            ct_op: |ct| ct,\n+            ty_op: |ty| ty,\n+        });\n+        tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty)\n     };\n     tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())\n }\n@@ -142,8 +140,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if bb == START_BLOCK {\n             self.fail(location, \"start block must not have predecessors\")\n         }\n-        if let Some(bb) = self.body.basic_blocks().get(bb) {\n-            let src = self.body.basic_blocks().get(location.block).unwrap();\n+        if let Some(bb) = self.body.basic_blocks.get(bb) {\n+            let src = self.body.basic_blocks.get(location.block).unwrap();\n             match (src.is_cleanup, bb.is_cleanup, edge_kind) {\n                 // Non-cleanup blocks can jump to non-cleanup blocks along non-unwind edges\n                 (false, false, EdgeKind::Normal)\n@@ -223,7 +221,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         // This check is somewhat expensive, so only run it when -Zvalidate-mir is passed.\n-        if self.tcx.sess.opts.unstable_opts.validate_mir && self.mir_phase < MirPhase::DropsLowered\n+        if self.tcx.sess.opts.unstable_opts.validate_mir\n+            && self.mir_phase < MirPhase::Runtime(RuntimePhase::Initial)\n         {\n             // `Operand::Copy` is only supposed to be used with `Copy` types.\n             if let Operand::Copy(place) = operand {\n@@ -254,7 +253,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, format!(\"bad index ({:?} != usize)\", index_ty))\n                 }\n             }\n-            ProjectionElem::Deref if self.mir_phase >= MirPhase::GeneratorsLowered => {\n+            ProjectionElem::Deref\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::PostCleanup) =>\n+            {\n                 let base_ty = Place::ty_from(local, proj_base, &self.body.local_decls, self.tcx).ty;\n \n                 if base_ty.is_box() {\n@@ -362,7 +363,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         // Set off any `bug!`s in the type computation code\n         let _ = place.ty(&self.body.local_decls, self.tcx);\n \n-        if self.mir_phase >= MirPhase::Derefered\n+        if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial)\n             && place.projection.len() > 1\n             && cntxt != PlaceContext::NonUse(VarDebugInfo)\n             && place.projection[1..].contains(&ProjectionElem::Deref)\n@@ -386,8 +387,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             Rvalue::Aggregate(agg_kind, _) => {\n                 let disallowed = match **agg_kind {\n                     AggregateKind::Array(..) => false,\n-                    AggregateKind::Generator(..) => self.mir_phase >= MirPhase::GeneratorsLowered,\n-                    _ => self.mir_phase >= MirPhase::Deaggregated,\n+                    _ => self.mir_phase >= MirPhase::Runtime(RuntimePhase::PostCleanup),\n                 };\n                 if disallowed {\n                     self.fail(\n@@ -397,10 +397,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n-                        \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n+                        \"`Assign` statement with a `Shallow` borrow should have been removed in runtime MIR\",\n                     );\n                 }\n             }\n@@ -614,15 +614,15 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::AscribeUserType(..) => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`AscribeUserType` should have been removed after drop lowering phase\",\n                     );\n                 }\n             }\n             StatementKind::FakeRead(..) => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`FakeRead` should have been removed after drop lowering phase\",\n@@ -666,7 +666,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::SetDiscriminant { place, .. } => {\n-                if self.mir_phase < MirPhase::Deaggregated {\n+                if self.mir_phase < MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(location, \"`SetDiscriminant`is not allowed until deaggregation\");\n                 }\n                 let pty = place.ty(&self.body.local_decls, self.tcx).ty.kind();\n@@ -681,7 +681,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             StatementKind::Deinit(..) => {\n-                if self.mir_phase < MirPhase::Deaggregated {\n+                if self.mir_phase < MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(location, \"`Deinit`is not allowed until deaggregation\");\n                 }\n             }\n@@ -761,7 +761,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::DropAndReplace { target, unwind, .. } => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`DropAndReplace` should have been removed during drop elaboration\",\n@@ -832,7 +832,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 if self.body.generator.is_none() {\n                     self.fail(location, \"`Yield` cannot appear outside generator bodies\");\n                 }\n-                if self.mir_phase >= MirPhase::GeneratorsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(location, \"`Yield` should have been replaced by generator lowering\");\n                 }\n                 self.check_edge(location, *resume, EdgeKind::Normal);\n@@ -841,7 +841,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::FalseEdge { real_target, imaginary_target } => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`FalseEdge` should have been removed after drop elaboration\",\n@@ -851,7 +851,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 self.check_edge(location, *imaginary_target, EdgeKind::Normal);\n             }\n             TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                if self.mir_phase >= MirPhase::DropsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`FalseUnwind` should have been removed after drop elaboration\",\n@@ -874,7 +874,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 if self.body.generator.is_none() {\n                     self.fail(location, \"`GeneratorDrop` cannot appear outside generator bodies\");\n                 }\n-                if self.mir_phase >= MirPhase::GeneratorsLowered {\n+                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n                         location,\n                         \"`GeneratorDrop` should have been replaced by generator lowering\",\n@@ -883,13 +883,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort => {\n                 let bb = location.block;\n-                if !self.body.basic_blocks()[bb].is_cleanup {\n+                if !self.body.basic_blocks[bb].is_cleanup {\n                     self.fail(location, \"Cannot `Resume` or `Abort` from non-cleanup basic block\")\n                 }\n             }\n             TerminatorKind::Return => {\n                 let bb = location.block;\n-                if self.body.basic_blocks()[bb].is_cleanup {\n+                if self.body.basic_blocks[bb].is_cleanup {\n                     self.fail(location, \"Cannot `Return` from cleanup basic block\")\n                 }\n             }"}, {"sha": "c8b09cffe0136e0ef5cfb8b4d5c9a4262fb0c0ea", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -28,6 +28,8 @@\n #![feature(vec_into_raw_parts)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "d912211443a893813d6b5c4fda225f2487765289", "filename": "compiler/rustc_data_structures/src/map_in_place.rs", "status": "modified", "additions": 49, "deletions": 78, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,3 +1,4 @@\n+use crate::thin_vec::ThinVec;\n use smallvec::{Array, SmallVec};\n use std::ptr;\n \n@@ -15,94 +16,64 @@ pub trait MapInPlace<T>: Sized {\n         I: IntoIterator<Item = T>;\n }\n \n-impl<T> MapInPlace<T> for Vec<T> {\n-    fn flat_map_in_place<F, I>(&mut self, mut f: F)\n-    where\n-        F: FnMut(T) -> I,\n-        I: IntoIterator<Item = T>,\n-    {\n-        let mut read_i = 0;\n-        let mut write_i = 0;\n-        unsafe {\n-            let mut old_len = self.len();\n-            self.set_len(0); // make sure we just leak elements in case of panic\n+// The implementation of this method is syntactically identical for all the\n+// different vector types.\n+macro_rules! flat_map_in_place {\n+    () => {\n+        fn flat_map_in_place<F, I>(&mut self, mut f: F)\n+        where\n+            F: FnMut(T) -> I,\n+            I: IntoIterator<Item = T>,\n+        {\n+            let mut read_i = 0;\n+            let mut write_i = 0;\n+            unsafe {\n+                let mut old_len = self.len();\n+                self.set_len(0); // make sure we just leak elements in case of panic\n \n-            while read_i < old_len {\n-                // move the read_i'th item out of the vector and map it\n-                // to an iterator\n-                let e = ptr::read(self.as_ptr().add(read_i));\n-                let iter = f(e).into_iter();\n-                read_i += 1;\n+                while read_i < old_len {\n+                    // move the read_i'th item out of the vector and map it\n+                    // to an iterator\n+                    let e = ptr::read(self.as_ptr().add(read_i));\n+                    let iter = f(e).into_iter();\n+                    read_i += 1;\n \n-                for e in iter {\n-                    if write_i < read_i {\n-                        ptr::write(self.as_mut_ptr().add(write_i), e);\n-                        write_i += 1;\n-                    } else {\n-                        // If this is reached we ran out of space\n-                        // in the middle of the vector.\n-                        // However, the vector is in a valid state here,\n-                        // so we just do a somewhat inefficient insert.\n-                        self.set_len(old_len);\n-                        self.insert(write_i, e);\n+                    for e in iter {\n+                        if write_i < read_i {\n+                            ptr::write(self.as_mut_ptr().add(write_i), e);\n+                            write_i += 1;\n+                        } else {\n+                            // If this is reached we ran out of space\n+                            // in the middle of the vector.\n+                            // However, the vector is in a valid state here,\n+                            // so we just do a somewhat inefficient insert.\n+                            self.set_len(old_len);\n+                            self.insert(write_i, e);\n \n-                        old_len = self.len();\n-                        self.set_len(0);\n+                            old_len = self.len();\n+                            self.set_len(0);\n \n-                        read_i += 1;\n-                        write_i += 1;\n+                            read_i += 1;\n+                            write_i += 1;\n+                        }\n                     }\n                 }\n-            }\n \n-            // write_i tracks the number of actually written new items.\n-            self.set_len(write_i);\n+                // write_i tracks the number of actually written new items.\n+                self.set_len(write_i);\n+            }\n         }\n-    }\n+    };\n }\n \n-impl<T, A: Array<Item = T>> MapInPlace<T> for SmallVec<A> {\n-    fn flat_map_in_place<F, I>(&mut self, mut f: F)\n-    where\n-        F: FnMut(T) -> I,\n-        I: IntoIterator<Item = T>,\n-    {\n-        let mut read_i = 0;\n-        let mut write_i = 0;\n-        unsafe {\n-            let mut old_len = self.len();\n-            self.set_len(0); // make sure we just leak elements in case of panic\n-\n-            while read_i < old_len {\n-                // move the read_i'th item out of the vector and map it\n-                // to an iterator\n-                let e = ptr::read(self.as_ptr().add(read_i));\n-                let iter = f(e).into_iter();\n-                read_i += 1;\n-\n-                for e in iter {\n-                    if write_i < read_i {\n-                        ptr::write(self.as_mut_ptr().add(write_i), e);\n-                        write_i += 1;\n-                    } else {\n-                        // If this is reached we ran out of space\n-                        // in the middle of the vector.\n-                        // However, the vector is in a valid state here,\n-                        // so we just do a somewhat inefficient insert.\n-                        self.set_len(old_len);\n-                        self.insert(write_i, e);\n-\n-                        old_len = self.len();\n-                        self.set_len(0);\n+impl<T> MapInPlace<T> for Vec<T> {\n+    flat_map_in_place!();\n+}\n \n-                        read_i += 1;\n-                        write_i += 1;\n-                    }\n-                }\n-            }\n+impl<T, A: Array<Item = T>> MapInPlace<T> for SmallVec<A> {\n+    flat_map_in_place!();\n+}\n \n-            // write_i tracks the number of actually written new items.\n-            self.set_len(write_i);\n-        }\n-    }\n+impl<T> MapInPlace<T> for ThinVec<T> {\n+    flat_map_in_place!();\n }"}, {"sha": "fce42e709ab74cfefcf6d81ebff7d2ddc164ea32", "filename": "compiler/rustc_data_structures/src/thin_vec.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -27,6 +27,51 @@ impl<T> ThinVec<T> {\n             ThinVec(None) => *self = vec![item].into(),\n         }\n     }\n+\n+    /// Note: if `set_len(0)` is called on a non-empty `ThinVec`, it will\n+    /// remain in the `Some` form. This is required for some code sequences\n+    /// (such as the one in `flat_map_in_place`) that call `set_len(0)` before\n+    /// an operation that might panic, and then call `set_len(n)` again\n+    /// afterwards.\n+    pub unsafe fn set_len(&mut self, new_len: usize) {\n+        match *self {\n+            ThinVec(None) => {\n+                // A prerequisite of `Vec::set_len` is that `new_len` must be\n+                // less than or equal to capacity(). The same applies here.\n+                if new_len != 0 {\n+                    panic!(\"unsafe ThinVec::set_len({})\", new_len);\n+                }\n+            }\n+            ThinVec(Some(ref mut vec)) => vec.set_len(new_len),\n+        }\n+    }\n+\n+    pub fn insert(&mut self, index: usize, value: T) {\n+        match *self {\n+            ThinVec(None) => {\n+                if index == 0 {\n+                    *self = vec![value].into();\n+                } else {\n+                    panic!(\"invalid ThinVec::insert\");\n+                }\n+            }\n+            ThinVec(Some(ref mut vec)) => vec.insert(index, value),\n+        }\n+    }\n+\n+    pub fn remove(&mut self, index: usize) -> T {\n+        match self {\n+            ThinVec(None) => panic!(\"invalid ThinVec::remove\"),\n+            ThinVec(Some(vec)) => vec.remove(index),\n+        }\n+    }\n+\n+    pub fn as_slice(&self) -> &[T] {\n+        match self {\n+            ThinVec(None) => &[],\n+            ThinVec(Some(vec)) => vec.as_slice(),\n+        }\n+    }\n }\n \n impl<T> From<Vec<T>> for ThinVec<T> {"}, {"sha": "f016c391fe777cfc83c21e317c080db6440086e2", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 67, "deletions": 54, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,45 +1,57 @@\n+use crate::frozen::Frozen;\n use crate::fx::FxIndexSet;\n-use crate::sync::Lock;\n use rustc_index::bit_set::BitMatrix;\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n+use std::ops::Deref;\n \n #[cfg(test)]\n mod tests;\n \n #[derive(Clone, Debug)]\n-pub struct TransitiveRelation<T> {\n+pub struct TransitiveRelationBuilder<T> {\n     // List of elements. This is used to map from a T to a usize.\n     elements: FxIndexSet<T>,\n \n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n     edges: Vec<Edge>,\n+}\n+\n+#[derive(Debug)]\n+pub struct TransitiveRelation<T> {\n+    // Frozen transitive relation elements and edges.\n+    builder: Frozen<TransitiveRelationBuilder<T>>,\n \n-    // This is a cached transitive closure derived from the edges.\n-    // Currently, we build it lazily and just throw out any existing\n-    // copy whenever a new edge is added. (The Lock is to permit\n-    // the lazy computation.) This is kind of silly, except for the\n-    // fact its size is tied to `self.elements.len()`, so I wanted to\n-    // wait before building it up to avoid reallocating as new edges\n-    // are added with new elements. Perhaps better would be to ask the\n-    // user for a batch of edges to minimize this effect, but I\n-    // already wrote the code this way. :P -nmatsakis\n-    closure: Lock<Option<BitMatrix<usize, usize>>>,\n+    // Cached transitive closure derived from the edges.\n+    closure: Frozen<BitMatrix<usize, usize>>,\n }\n \n-// HACK(eddyb) manual impl avoids `Default` bound on `T`.\n-impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n-    fn default() -> Self {\n+impl<T> Deref for TransitiveRelation<T> {\n+    type Target = Frozen<TransitiveRelationBuilder<T>>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.builder\n+    }\n+}\n+\n+impl<T: Clone> Clone for TransitiveRelation<T> {\n+    fn clone(&self) -> Self {\n         TransitiveRelation {\n-            elements: Default::default(),\n-            edges: Default::default(),\n-            closure: Default::default(),\n+            builder: Frozen::freeze(self.builder.deref().clone()),\n+            closure: Frozen::freeze(self.closure.deref().clone()),\n         }\n     }\n }\n \n+// HACK(eddyb) manual impl avoids `Default` bound on `T`.\n+impl<T: Eq + Hash> Default for TransitiveRelationBuilder<T> {\n+    fn default() -> Self {\n+        TransitiveRelationBuilder { elements: Default::default(), edges: Default::default() }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n struct Index(usize);\n \n@@ -49,7 +61,7 @@ struct Edge {\n     target: Index,\n }\n \n-impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n+impl<T: Eq + Hash + Copy> TransitiveRelationBuilder<T> {\n     pub fn is_empty(&self) -> bool {\n         self.edges.is_empty()\n     }\n@@ -63,23 +75,19 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        let (index, added) = self.elements.insert_full(a);\n-        if added {\n-            // if we changed the dimensions, clear the cache\n-            *self.closure.get_mut() = None;\n-        }\n+        let (index, _added) = self.elements.insert_full(a);\n         Index(index)\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n-    /// relation. If `f` returns `None` for any end-point, returns\n-    /// `None`.\n-    pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n+    /// relation builder. If `f` returns `None` for any end-point,\n+    /// returns `None`.\n+    pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelationBuilder<U>>\n     where\n         F: FnMut(T) -> Option<U>,\n         U: Clone + Debug + Eq + Hash + Copy,\n     {\n-        let mut result = TransitiveRelation::default();\n+        let mut result = TransitiveRelationBuilder::default();\n         for edge in &self.edges {\n             result.add(f(self.elements[edge.source.0])?, f(self.elements[edge.target.0])?);\n         }\n@@ -93,10 +101,38 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n         let edge = Edge { source: a, target: b };\n         if !self.edges.contains(&edge) {\n             self.edges.push(edge);\n+        }\n+    }\n+\n+    /// Compute the transitive closure derived from the edges, and converted to\n+    /// the final result. After this, all elements will be immutable to maintain\n+    /// the correctness of the result.\n+    pub fn freeze(self) -> TransitiveRelation<T> {\n+        let mut matrix = BitMatrix::new(self.elements.len(), self.elements.len());\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+            for edge in &self.edges {\n+                // add an edge from S -> T\n+                changed |= matrix.insert(edge.source.0, edge.target.0);\n \n-            // added an edge, clear the cache\n-            *self.closure.get_mut() = None;\n+                // add all outgoing edges from T into S\n+                changed |= matrix.union_rows(edge.target.0, edge.source.0);\n+            }\n         }\n+        TransitiveRelation { builder: Frozen::freeze(self), closure: Frozen::freeze(matrix) }\n+    }\n+}\n+\n+impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n+    /// Applies the (partial) function to each edge and returns a new\n+    /// relation including transitive closures.\n+    pub fn maybe_map<F, U>(&self, f: F) -> Option<TransitiveRelation<U>>\n+    where\n+        F: FnMut(T) -> Option<U>,\n+        U: Clone + Debug + Eq + Hash + Copy,\n+    {\n+        Some(self.builder.maybe_map(f)?.freeze())\n     }\n \n     /// Checks whether `a < target` (transitively)\n@@ -322,30 +358,7 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     where\n         OP: FnOnce(&BitMatrix<usize, usize>) -> R,\n     {\n-        let mut closure_cell = self.closure.borrow_mut();\n-        let mut closure = closure_cell.take();\n-        if closure.is_none() {\n-            closure = Some(self.compute_closure());\n-        }\n-        let result = op(closure.as_ref().unwrap());\n-        *closure_cell = closure;\n-        result\n-    }\n-\n-    fn compute_closure(&self) -> BitMatrix<usize, usize> {\n-        let mut matrix = BitMatrix::new(self.elements.len(), self.elements.len());\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            for edge in &self.edges {\n-                // add an edge from S -> T\n-                changed |= matrix.insert(edge.source.0, edge.target.0);\n-\n-                // add all outgoing edges from T into S\n-                changed |= matrix.union_rows(edge.target.0, edge.source.0);\n-            }\n-        }\n-        matrix\n+        op(&self.closure)\n     }\n \n     /// Lists all the base edges in the graph: the initial _non-transitive_ set of element"}, {"sha": "e756c546e41ba705f0b6fe4a839199acd8633d23", "filename": "compiler/rustc_data_structures/src/transitive_relation/tests.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -10,9 +10,10 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n \n #[test]\n fn test_one_step() {\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"b\");\n     relation.add(\"a\", \"c\");\n+    let relation = relation.freeze();\n     assert!(relation.contains(\"a\", \"c\"));\n     assert!(relation.contains(\"a\", \"b\"));\n     assert!(!relation.contains(\"b\", \"a\"));\n@@ -21,7 +22,7 @@ fn test_one_step() {\n \n #[test]\n fn test_many_steps() {\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"b\");\n     relation.add(\"a\", \"c\");\n     relation.add(\"a\", \"f\");\n@@ -31,6 +32,7 @@ fn test_many_steps() {\n     relation.add(\"b\", \"e\");\n \n     relation.add(\"e\", \"g\");\n+    let relation = relation.freeze();\n \n     assert!(relation.contains(\"a\", \"b\"));\n     assert!(relation.contains(\"a\", \"c\"));\n@@ -51,9 +53,10 @@ fn mubs_triangle() {\n     //      ^\n     //      |\n     //      b\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"tcx\");\n     relation.add(\"b\", \"tcx\");\n+    let relation = relation.freeze();\n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"tcx\"]);\n     assert_eq!(relation.parents(\"a\"), vec![\"tcx\"]);\n     assert_eq!(relation.parents(\"b\"), vec![\"tcx\"]);\n@@ -72,14 +75,15 @@ fn mubs_best_choice1() {\n     // need the second pare down call to get the right result (after\n     // intersection, we have [1, 2], but 2 -> 1).\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"2\", \"1\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"2\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"2\"]);\n@@ -99,14 +103,15 @@ fn mubs_best_choice2() {\n     // Like the preceding test, but in this case intersection is [2,\n     // 1], and hence we rely on the first pare down call.\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"1\", \"2\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\"]);\n@@ -118,12 +123,13 @@ fn mubs_best_choice2() {\n fn mubs_no_best_choice() {\n     // in this case, the intersection yields [1, 2], and the \"pare\n     // down\" calls find nothing to remove.\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\", \"2\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\", \"2\"]);\n@@ -135,7 +141,7 @@ fn mubs_best_choice_scc() {\n     // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n     // consistently).\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n \n@@ -144,6 +150,7 @@ fn mubs_best_choice_scc() {\n \n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\"]);\n     assert_eq!(relation.parents(\"0\"), vec![\"1\"]);\n@@ -157,13 +164,14 @@ fn pdub_crisscross() {\n     //   /\\       |\n     // b -> b1 ---+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"a\", \"b1\");\n     relation.add(\"b\", \"a1\");\n     relation.add(\"b\", \"b1\");\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"a1\", \"b1\"]);\n     assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n@@ -179,7 +187,7 @@ fn pdub_crisscross_more() {\n     //   /\\    /\\             |\n     // b -> b1 -> b2 ---------+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"a\", \"b1\");\n     relation.add(\"b\", \"a1\");\n@@ -194,6 +202,7 @@ fn pdub_crisscross_more() {\n \n     relation.add(\"a3\", \"x\");\n     relation.add(\"b2\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"a1\", \"b1\"]);\n     assert_eq!(relation.minimal_upper_bounds(\"a1\", \"b1\"), vec![\"a2\", \"b2\"]);\n@@ -210,11 +219,12 @@ fn pdub_lub() {\n     //            |\n     // b -> b1 ---+\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"a1\");\n     relation.add(\"b\", \"b1\");\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"x\"]);\n     assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n@@ -233,10 +243,11 @@ fn mubs_intermediate_node_on_one_side_only() {\n     //           b\n \n     // \"digraph { a -> c -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"b\", \"d\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"d\"]);\n }\n@@ -252,12 +263,13 @@ fn mubs_scc_1() {\n     //           b\n \n     // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"c\");\n     relation.add(\"a\", \"d\");\n     relation.add(\"b\", \"d\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -272,12 +284,13 @@ fn mubs_scc_2() {\n     //      +--- b\n \n     // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"c\");\n     relation.add(\"b\", \"d\");\n     relation.add(\"b\", \"c\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -292,13 +305,14 @@ fn mubs_scc_3() {\n     //           b ---+\n \n     // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"e\");\n     relation.add(\"e\", \"c\");\n     relation.add(\"b\", \"d\");\n     relation.add(\"b\", \"e\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -314,13 +328,14 @@ fn mubs_scc_4() {\n     //           b ---+\n \n     // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     relation.add(\"a\", \"c\");\n     relation.add(\"c\", \"d\");\n     relation.add(\"d\", \"e\");\n     relation.add(\"e\", \"c\");\n     relation.add(\"a\", \"d\");\n     relation.add(\"b\", \"e\");\n+    let relation = relation.freeze();\n \n     assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n@@ -352,10 +367,11 @@ fn parent() {\n         (1, /*->*/ 3),\n     ];\n \n-    let mut relation = TransitiveRelation::default();\n+    let mut relation = TransitiveRelationBuilder::default();\n     for (a, b) in pairs {\n         relation.add(a, b);\n     }\n+    let relation = relation.freeze();\n \n     let p = relation.postdom_parent(3);\n     assert_eq!(p, Some(0));"}, {"sha": "4570c1448337eec7b661868deb0d81d64f219916", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -19,6 +19,7 @@ rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }"}, {"sha": "a193d5db6916a08af8eaf61d186d86210a13c998", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -9,14 +9,16 @@\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n use rustc_ast as ast;\n-use rustc_codegen_ssa::{traits::CodegenBackend, CodegenResults};\n+use rustc_codegen_ssa::{traits::CodegenBackend, CodegenErrors, CodegenResults};\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n@@ -56,6 +58,12 @@ use std::time::Instant;\n \n pub mod args;\n pub mod pretty;\n+mod session_diagnostics;\n+\n+use crate::session_diagnostics::{\n+    RLinkEmptyVersionNumber, RLinkEncodingVersionMismatch, RLinkRustcVersionMismatch,\n+    RLinkWrongFileType, RlinkNotAFile, RlinkUnableToRead,\n+};\n \n /// Exit status code used for successful compilation and help output.\n pub const EXIT_SUCCESS: i32 = 0;\n@@ -581,18 +589,35 @@ pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Comp\n             sess.init_crate_types(collect_crate_types(sess, &[]));\n             let outputs = compiler.build_output_filenames(sess, &[]);\n             let rlink_data = fs::read(file).unwrap_or_else(|err| {\n-                sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n+                sess.emit_fatal(RlinkUnableToRead { err });\n             });\n             let codegen_results = match CodegenResults::deserialize_rlink(rlink_data) {\n                 Ok(codegen) => codegen,\n-                Err(error) => {\n-                    sess.fatal(&format!(\"Could not deserialize .rlink file: {error}\"));\n+                Err(err) => {\n+                    match err {\n+                        CodegenErrors::WrongFileType => sess.emit_fatal(RLinkWrongFileType),\n+                        CodegenErrors::EmptyVersionNumber => {\n+                            sess.emit_fatal(RLinkEmptyVersionNumber)\n+                        }\n+                        CodegenErrors::EncodingVersionMismatch { version_array, rlink_version } => {\n+                            sess.emit_fatal(RLinkEncodingVersionMismatch {\n+                                version_array,\n+                                rlink_version,\n+                            })\n+                        }\n+                        CodegenErrors::RustcVersionMismatch { rustc_version, current_version } => {\n+                            sess.emit_fatal(RLinkRustcVersionMismatch {\n+                                rustc_version,\n+                                current_version,\n+                            })\n+                        }\n+                    };\n                 }\n             };\n             let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n             abort_on_err(result, sess);\n         } else {\n-            sess.fatal(\"rlink must be a file\")\n+            sess.emit_fatal(RlinkNotAFile {})\n         }\n         Compilation::Stop\n     } else {\n@@ -1070,7 +1095,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     Some(matches)\n }\n \n-fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<ast::Attribute>> {\n+fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::AttrVec> {\n     match input {\n         Input::File(ifile) => rustc_parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess),\n         Input::Str { name, input } => rustc_parse::parse_crate_attrs_from_source_str("}, {"sha": "fe64d0fca9b20c58771ce834bdb5c28a594e3912", "filename": "compiler/rustc_driver/src/session_diagnostics.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,33 @@\n+use rustc_macros::SessionDiagnostic;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_unable_to_read)]\n+pub(crate) struct RlinkUnableToRead {\n+    pub err: std::io::Error,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_wrong_file_type)]\n+pub(crate) struct RLinkWrongFileType;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_empty_version_number)]\n+pub(crate) struct RLinkEmptyVersionNumber;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_encoding_version_mismatch)]\n+pub(crate) struct RLinkEncodingVersionMismatch {\n+    pub version_array: String,\n+    pub rlink_version: u32,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_rustc_version_mismatch)]\n+pub(crate) struct RLinkRustcVersionMismatch<'a> {\n+    pub rustc_version: String,\n+    pub current_version: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(driver::rlink_no_a_file)]\n+pub(crate) struct RlinkNotAFile;"}, {"sha": "577f42ef3017c81f071bdd6fa9ca0697ab9241b9", "filename": "compiler/rustc_error_codes/src/error_codes/E0695.md", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0695.md", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0695.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0695.md?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -3,7 +3,6 @@ A `break` statement without a label appeared inside a labeled block.\n Erroneous code example:\n \n ```compile_fail,E0695\n-# #![feature(label_break_value)]\n loop {\n     'a: {\n         break;\n@@ -14,7 +13,6 @@ loop {\n Make sure to always label the `break`:\n \n ```\n-# #![feature(label_break_value)]\n 'l: loop {\n     'a: {\n         break 'l;\n@@ -25,7 +23,6 @@ Make sure to always label the `break`:\n Or if you want to `break` the labeled block:\n \n ```\n-# #![feature(label_break_value)]\n loop {\n     'a: {\n         break 'a;"}, {"sha": "bd424dd9d068580fdaf7935eaf72b3ebfe77abff", "filename": "compiler/rustc_error_codes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,4 +1,6 @@\n #![deny(rustdoc::invalid_codeblock_attributes)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This library is used to gather all error codes into one place,\n //! the goal being to make their maintenance easier.\n "}, {"sha": "f2790531aba44de40e247d6d7a8b4d956fd08684", "filename": "compiler/rustc_error_messages/locales/en-US/ast_lowering.ftl", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,133 @@\n+ast_lowering_generic_type_with_parentheses =\n+    parenthesized type parameters may only be used with a `Fn` trait\n+    .label = only `Fn` traits may use parentheses\n+\n+ast_lowering_use_angle_brackets = use angle brackets instead\n+\n+ast_lowering_invalid_abi =\n+    invalid ABI: found `{$abi}`\n+    .label = invalid ABI\n+    .help = valid ABIs: {$valid_abis}\n+\n+ast_lowering_assoc_ty_parentheses =\n+    parenthesized generic arguments cannot be used in associated type constraints\n+\n+ast_lowering_remove_parentheses = remove these parentheses\n+\n+ast_lowering_misplaced_impl_trait =\n+    `impl Trait` only allowed in function and inherent method return types, not in {$position}\n+\n+ast_lowering_rustc_box_attribute_error =\n+    #[rustc_box] requires precisely one argument and no other attributes are allowed\n+\n+ast_lowering_underscore_expr_lhs_assign =\n+    in expressions, `_` can only be used on the left-hand side of an assignment\n+    .label = `_` not allowed here\n+\n+ast_lowering_base_expression_double_dot =\n+    base expression required after `..`\n+    .label = add a base expression here\n+\n+ast_lowering_await_only_in_async_fn_and_blocks =\n+    `await` is only allowed inside `async` functions and blocks\n+    .label = only allowed inside `async` functions and blocks\n+\n+ast_lowering_this_not_async = this is not `async`\n+\n+ast_lowering_generator_too_many_parameters =\n+    too many parameters for a generator (expected 0 or 1 parameters)\n+\n+ast_lowering_closure_cannot_be_static = closures cannot be static\n+\n+ast_lowering_async_non_move_closure_not_supported =\n+    `async` non-`move` closures with parameters are not currently supported\n+    .help = consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n+\n+ast_lowering_functional_record_update_destructuring_assignment =\n+    functional record updates are not allowed in destructuring assignments\n+    .suggestion = consider removing the trailing pattern\n+\n+ast_lowering_async_generators_not_supported =\n+    `async` generators are not yet supported\n+\n+ast_lowering_inline_asm_unsupported_target =\n+    inline assembly is unsupported on this target\n+\n+ast_lowering_att_syntax_only_x86 =\n+    the `att_syntax` option is only supported on x86\n+\n+ast_lowering_abi_specified_multiple_times =\n+    `{$prev_name}` ABI specified multiple times\n+    .label = previously specified here\n+    .note = these ABIs are equivalent on the current target\n+\n+ast_lowering_clobber_abi_not_supported =\n+    `clobber_abi` is not supported on this target\n+\n+ast_lowering_invalid_abi_clobber_abi =\n+    invalid ABI for `clobber_abi`\n+    .note = the following ABIs are supported on this target: {$supported_abis}\n+\n+ast_lowering_invalid_register =\n+    invalid register `{$reg}`: {$error}\n+\n+ast_lowering_invalid_register_class =\n+    invalid register class `{$reg_class}`: {$error}\n+\n+ast_lowering_invalid_asm_template_modifier_reg_class =\n+    invalid asm template modifier for this register class\n+\n+ast_lowering_argument = argument\n+\n+ast_lowering_template_modifier = template modifier\n+\n+ast_lowering_support_modifiers =\n+    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n+\n+ast_lowering_does_not_support_modifiers =\n+    the `{$class_name}` register class does not support template modifiers\n+\n+ast_lowering_invalid_asm_template_modifier_const =\n+    asm template modifiers are not allowed for `const` arguments\n+\n+ast_lowering_invalid_asm_template_modifier_sym =\n+    asm template modifiers are not allowed for `sym` arguments\n+\n+ast_lowering_register_class_only_clobber =\n+    register class `{$reg_class_name}` can only be used as a clobber, not as an input or output\n+\n+ast_lowering_register_conflict =\n+    register `{$reg1_name}` conflicts with register `{$reg2_name}`\n+    .help = use `lateout` instead of `out` to avoid conflict\n+\n+ast_lowering_register1 = register `{$reg1_name}`\n+\n+ast_lowering_register2 = register `{$reg2_name}`\n+\n+ast_lowering_sub_tuple_binding =\n+    `{$ident_name} @` is not allowed in a {$ctx}\n+    .label = this is only allowed in slice patterns\n+    .help = remove this and bind each tuple field independently\n+\n+ast_lowering_sub_tuple_binding_suggestion = if you don't need to use the contents of {$ident}, discard the tuple's remaining fields\n+\n+ast_lowering_extra_double_dot =\n+    `..` can only be used once per {$ctx} pattern\n+    .label = can only be used once per {$ctx} pattern\n+\n+ast_lowering_previously_used_here = previously used here\n+\n+ast_lowering_misplaced_double_dot =\n+    `..` patterns are not allowed here\n+    .note = only allowed in tuple, tuple struct, and slice patterns\n+\n+ast_lowering_misplaced_relax_trait_bound =\n+    `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+ast_lowering_not_supported_for_lifetime_binder_async_closure =\n+    `for<...>` binders on `async` closures are not currently supported\n+\n+ast_lowering_arbitrary_expression_in_pattern =\n+    arbitrary expressions aren't allowed in patterns\n+\n+ast_lowering_inclusive_range_with_no_end = inclusive range with no end"}, {"sha": "d7108e1e2de35e5dbc22da59213a42b39cf8388b", "filename": "compiler/rustc_error_messages/locales/en-US/ast_passes.ftl", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_passes.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,97 @@\n+ast_passes_forbidden_let =\n+    `let` expressions are not supported here\n+    .note = only supported directly in conditions of `if` and `while` expressions\n+    .not_supported_or = `||` operators are not supported in let chain expressions\n+    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n+\n+ast_passes_forbidden_let_stable =\n+    expected expression, found statement (`let`)\n+    .note = variable declaration using `let` is a statement\n+\n+ast_passes_deprecated_where_clause_location =\n+    where clause not allowed here\n+\n+ast_passes_forbidden_assoc_constraint =\n+    associated type bounds are not allowed within structs, enums, or unions\n+\n+ast_passes_keyword_lifetime =\n+    lifetimes cannot use keyword names\n+\n+ast_passes_invalid_label =\n+    invalid label name `{$name}`\n+\n+ast_passes_invalid_visibility =\n+    unnecessary visibility qualifier\n+    .implied = `pub` not permitted here because it's implied\n+    .individual_impl_items = place qualifiers on individual impl items instead\n+    .individual_foreign_items = place qualifiers on individual foreign items instead\n+\n+ast_passes_trait_fn_async =\n+    functions in traits cannot be declared `async`\n+    .label = `async` because of this\n+    .note = `async` trait functions are not currently supported\n+    .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+ast_passes_trait_fn_const =\n+    functions in traits cannot be declared const\n+    .label = functions in traits cannot be const\n+\n+ast_passes_forbidden_lifetime_bound =\n+    lifetime bounds cannot be used in this context\n+\n+ast_passes_forbidden_non_lifetime_param =\n+    only lifetime parameters can be used in this context\n+\n+ast_passes_fn_param_too_many =\n+    function can not have more than {$max_num_args} arguments\n+\n+ast_passes_fn_param_c_var_args_only =\n+    C-variadic function must be declared with at least one named argument\n+\n+ast_passes_fn_param_c_var_args_not_last =\n+    `...` must be the last argument of a C-variadic function\n+\n+ast_passes_fn_param_doc_comment =\n+    documentation comments cannot be applied to function parameters\n+    .label = doc comments are not allowed here\n+\n+ast_passes_fn_param_forbidden_attr =\n+    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n+\n+ast_passes_fn_param_forbidden_self =\n+    `self` parameter is only allowed in associated functions\n+    .label = not semantically valid as function parameter\n+    .note = associated functions are those in `impl` or `trait` definitions\n+\n+ast_passes_forbidden_default =\n+    `default` is only allowed on items in trait impls\n+    .label = `default` because of this\n+\n+ast_passes_assoc_const_without_body =\n+    associated constant in `impl` without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_assoc_fn_without_body =\n+    associated function in `impl` without body\n+    .suggestion = provide a definition for the function\n+\n+ast_passes_assoc_type_without_body =\n+    associated type in `impl` without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_const_without_body =\n+    free constant item without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_static_without_body =\n+    free static item without body\n+    .suggestion = provide a definition for the static\n+\n+ast_passes_ty_alias_without_body =\n+    free type alias without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_fn_without_body =\n+    free function without a body\n+    .suggestion = provide a definition for the function\n+    .extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block"}, {"sha": "a7f8c993d4225316129e515ef4e2a84bbe872137", "filename": "compiler/rustc_error_messages/locales/en-US/attr.ftl", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fattr.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,107 @@\n+attr_expected_one_cfg_pattern =\n+    expected 1 cfg-pattern\n+\n+attr_invalid_predicate =\n+    invalid predicate `{$predicate}`\n+\n+attr_multiple_item =\n+    multiple '{$item}' items\n+\n+attr_incorrect_meta_item =\n+    incorrect meta item\n+\n+attr_unknown_meta_item =\n+    unknown meta item '{$item}'\n+    .label = expected one of {$expected}\n+\n+attr_missing_since =\n+    missing 'since'\n+\n+attr_missing_note =\n+    missing 'note'\n+\n+attr_multiple_stability_levels =\n+    multiple stability levels\n+\n+attr_invalid_issue_string =\n+    `issue` must be a non-zero numeric string or \"none\"\n+    .must_not_be_zero = `issue` must not be \"0\", use \"none\" instead\n+    .empty = cannot parse integer from empty string\n+    .invalid_digit = invalid digit found in string\n+    .pos_overflow = number too large to fit in target type\n+    .neg_overflow = number too small to fit in target type\n+\n+attr_missing_feature =\n+    missing 'feature'\n+\n+attr_non_ident_feature =\n+    'feature' is not an identifier\n+\n+attr_missing_issue =\n+    missing 'issue'\n+\n+attr_incorrect_repr_format_packed_one_or_zero_arg =\n+    incorrect `repr(packed)` attribute format: `packed` takes exactly one parenthesized argument, or no parentheses at all\n+\n+attr_invalid_repr_hint_no_paren =\n+    invalid representation hint: `{$name}` does not take a parenthesized argument list\n+\n+attr_invalid_repr_hint_no_value =\n+    invalid representation hint: `{$name}` does not take a value\n+\n+attr_unsupported_literal_generic =\n+    unsupported literal\n+attr_unsupported_literal_cfg_string =\n+    literal in `cfg` predicate value must be a string\n+attr_unsupported_literal_deprecated_string =\n+    literal in `deprecated` value must be a string\n+attr_unsupported_literal_deprecated_kv_pair =\n+    item in `deprecated` must be a key/value pair\n+attr_unsupported_literal_suggestion =\n+    consider removing the prefix\n+\n+attr_invalid_repr_align_need_arg =\n+    invalid `repr(align)` attribute: `align` needs an argument\n+    .suggestion = supply an argument here\n+\n+attr_invalid_repr_generic =\n+    invalid `repr({$repr_arg})` attribute: {$error_part}\n+\n+attr_incorrect_repr_format_align_one_arg =\n+    incorrect `repr(align)` attribute format: `align` takes exactly one argument in parentheses\n+\n+attr_incorrect_repr_format_generic =\n+    incorrect `repr({$repr_arg})` attribute format\n+    .suggestion = use parentheses instead\n+\n+attr_rustc_promotable_pairing =\n+    `rustc_promotable` attribute must be paired with either a `rustc_const_unstable` or a `rustc_const_stable` attribute\n+\n+attr_rustc_allowed_unstable_pairing =\n+    `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n+\n+attr_cfg_predicate_identifier =\n+    `cfg` predicate key must be an identifier\n+\n+attr_deprecated_item_suggestion =\n+    suggestions on deprecated items are unstable\n+    .help = add `#![feature(deprecated_suggestion)]` to the crate root\n+    .note = see #94785 for more details\n+\n+attr_expected_single_version_literal =\n+    expected single version literal\n+\n+attr_expected_version_literal =\n+    expected a version literal\n+\n+attr_expects_feature_list =\n+    `{$name}` expects a list of feature names\n+\n+attr_expects_features =\n+    `{$name}` expects feature names\n+\n+attr_soft_no_args =\n+    `soft` should not have any arguments\n+\n+attr_unknown_version_literal =\n+    unknown version literal format, assuming it refers to a future version"}, {"sha": "67f2156f32e509eb78fb18267f48330d5fae2356", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -13,6 +13,48 @@ borrowck_could_not_normalize =\n \n borrowck_higher_ranked_subtype_error =\n     higher-ranked subtype error\n-  \n-generic_does_not_live_long_enough =\n-    `{$kind}` does not live long enough\n\\ No newline at end of file\n+\n+borrowck_generic_does_not_live_long_enough =\n+    `{$kind}` does not live long enough\n+\n+borrowck_move_borrowed =\n+    cannot move out of `{$desc}` beacause it is borrowed\n+\n+borrowck_var_does_not_need_mut =\n+    variable does not need to be mutable\n+    .suggestion = remove this `mut`\n+\n+borrowck_const_not_used_in_type_alias =\n+    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+\n+borrowck_var_cannot_escape_closure =\n+    captured variable cannot escape `FnMut` closure body\n+    .note = `FnMut` closures only have access to their captured variables while they are executing...\n+    .cannot_escape = ...therefore, they cannot allow references to captured variables to escape\n+\n+borrowck_var_here_defined = variable defined here\n+\n+borrowck_var_here_captured = variable captured here\n+\n+borrowck_closure_inferred_mut =  inferred to be a `FnMut` closure\n+\n+borrowck_returned_closure_escaped =\n+    returns a closure that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_async_block_escaped =\n+    returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_ref_escaped =\n+    returns a reference to a captured variable which escapes the closure body\n+\n+borrowck_lifetime_constraints_error =\n+    lifetime may not live long enough\n+\n+borrowck_returned_lifetime_wrong =\n+    {$mir_def_name} was supposed to return data with lifetime `{$outlived_fr_name}` but it is returning data with lifetime `{$fr_name}`\n+\n+borrowck_returned_lifetime_short =\n+    {$category_desc}requires that `{$free_region_name}` must outlive `{$outlived_fr_name}`\n+\n+borrowck_used_impl_require_static =\n+    the used `impl` has a `'static` requirement"}, {"sha": "33bb116d6fa23f01c513d1b34b0d7e8ed9007070", "filename": "compiler/rustc_error_messages/locales/en-US/const_eval.ftl", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fconst_eval.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -29,3 +29,55 @@ const_eval_mut_deref =\n const_eval_transient_mut_borrow = mutable references are not allowed in {$kind}s\n \n const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {$kind}s\n+\n+const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n+\n+const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {$kind}s\n+\n+const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n+\n+const_eval_unallowed_mutable_refs =\n+    mutable references are not allowed in the final value of {$kind}s\n+    .teach_note =\n+        References in statics and constants may only refer to immutable values.\\n\\n\n+        Statics are shared everywhere, and if they refer to mutable data one might violate memory\n+        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        If you really want global mutable state, try using static mut or a global UnsafeCell.\n+\n+const_eval_unallowed_mutable_refs_raw =\n+    raw mutable references are not allowed in the final value of {$kind}s\n+    .teach_note =\n+        References in statics and constants may only refer to immutable values.\\n\\n\n+        Statics are shared everywhere, and if they refer to mutable data one might violate memory\n+        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        If you really want global mutable state, try using static mut or a global UnsafeCell.\n+\n+const_eval_non_const_fmt_macro_call =\n+    cannot call non-const formatting macro in {$kind}s\n+\n+const_eval_non_const_fn_call =\n+    cannot call non-const fn `{$def_path_str}` in {$kind}s\n+\n+const_eval_unallowed_op_in_const_context =\n+    {$msg}\n+\n+const_eval_unallowed_heap_allocations =\n+    allocations are not allowed in {$kind}s\n+    .label = allocation not allowed in {$kind}s\n+    .teach_note =\n+        The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n+\n+const_eval_unallowed_inline_asm =\n+    inline assembly is not allowed in {$kind}s\n+\n+const_eval_interior_mutable_data_refer =\n+    {$kind}s cannot refer to interior mutable data\n+    .label = this borrow of an interior mutable value may end up in the final value\n+    .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n+    .teach_note =\n+        A constant containing interior mutable data behind a reference can allow you to modify that data.\n+        This would make multiple uses of a constant to be able to see different values and allow circumventing\n+        the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n+\n+const_eval_interior_mutability_borrow =\n+    cannot borrow here, since the borrowed element may contain interior mutability"}, {"sha": "73f084cf3290bf7d1d8e7a0af03b4a35410aafa4", "filename": "compiler/rustc_error_messages/locales/en-US/driver.ftl", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,11 @@\n+driver_rlink_unable_to_read = failed to read rlink file: `{$err}`\n+\n+driver_rlink_wrong_file_type = The input does not look like a .rlink file\n+\n+driver_rlink_empty_version_number = The input does not contain version number\n+\n+driver_rlink_encoding_version_mismatch = .rlink file was produced with encoding version `{$version_array}`, but the current version is `{$rlink_version}`\n+\n+driver_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n+\n+driver_rlink_no_a_file = rlink must be a file"}, {"sha": "5720591154f9914e2ff3f9ada81c45edb4252118", "filename": "compiler/rustc_error_messages/locales/en-US/expand.ftl", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -4,10 +4,10 @@ expand_explain_doc_comment_outer =\n expand_explain_doc_comment_inner =\n     inner doc comments expand to `#![doc = \"...\"]`, which is what this macro attempted to match\n \n-expand_expr_repeat_no_syntax_vars = \n+expand_expr_repeat_no_syntax_vars =\n     attempted to repeat an expression containing no syntax variables matched as repeating at this depth\n \n-expand_must_repeat_once = \n+expand_must_repeat_once =\n     this must repeat at least once\n \n expand_count_repetition_misplaced =\n@@ -19,4 +19,4 @@ expand_meta_var_expr_unrecognized_var =\n expand_var_still_repeating =\n     variable '{$ident}' is still repeating at this depth\n \n-expand_meta_var_dif_seq_matchers = {$msg}\n\\ No newline at end of file\n+expand_meta_var_dif_seq_matchers = {$msg}"}, {"sha": "60086cd6e477f430bff9432081f32af0d7583b40", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,112 @@\n+infer_opaque_hidden_type =\n+    opaque type's hidden type cannot be another opaque type from the same scope\n+    .label = one of the two opaque types used here has to be outside its defining scope\n+    .opaque_type = opaque type whose hidden type is being assigned\n+    .hidden_type = opaque type being used as hidden type\n+\n+infer_type_annotations_needed = {$source_kind ->\n+    [closure] type annotations needed for the closure `{$source_name}`\n+    [normal] type annotations needed for `{$source_name}`\n+    *[other] type annotations needed\n+}\n+    .label = type must be known at this point\n+\n+infer_label_bad = {$bad_kind ->\n+    *[other] cannot infer type\n+    [more_info] cannot infer {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$name}`{$has_parent ->\n+        [true] {\" \"}declared on the {$parent_prefix} `{$parent_name}`\n+        *[false] {\"\"}\n+    }\n+}\n+\n+infer_source_kind_subdiag_let = {$kind ->\n+    [with_pattern] consider giving `{$name}` an explicit type\n+    [closure] consider giving this closure parameter an explicit type\n+    *[other] consider giving this pattern a type\n+}{$x_kind ->\n+    [has_name] , where the {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$arg_name}` is specified\n+    [underscore] , where the placeholders `_` are specified\n+    *[empty] {\"\"}\n+}\n+\n+infer_source_kind_subdiag_generic_label =\n+    cannot infer {$is_type ->\n+    [true] type\n+    *[false] the value\n+    } of the {$is_type ->\n+    [true] type\n+    *[false] const\n+    } {$parent_exists ->\n+    [true] parameter `{$param_name}` declared on the {$parent_prefix} `{$parent_name}`\n+    *[false] parameter {$param_name}\n+    }\n+\n+infer_source_kind_subdiag_generic_suggestion =\n+    consider specifying the generic {$arg_count ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+infer_source_kind_fully_qualified =\n+    try using a fully qualified path to specify the expected types\n+\n+infer_source_kind_closure_return =\n+    try giving this closure an explicit return type\n+\n+# generator_kind  may need to be translated\n+infer_need_type_info_in_generator =\n+    type inside {$generator_kind ->\n+    [async_block] `async` block\n+    [async_closure] `async` closure\n+    [async_fn] `async fn` body\n+    *[generator] generator\n+    } must be known in this context\n+\n+\n+infer_subtype = ...so that the {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] #[start]` function has the correct type\n+    [intristic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n+infer_subtype_2 = ...so that {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] #[start]` function has the correct type\n+    [intristic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n+\n+infer_reborrow = ...so that reference does not outlive borrowed content\n+infer_reborrow_upvar = ...so that closure can access `{$name}`\n+infer_relate_object_bound = ...so that it can be closed over into an object\n+infer_data_borrowed = ...so that the type `{$name}` is not borrowed for too long\n+infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n+infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n+[true] ...\n+*[false] {\"\"}\n+}\n+infer_relate_param_bound_2 = ...that is required by this bound\n+infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n+infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait"}, {"sha": "bbcb8fc28cffa1a24a5f5f0d7d44303185562703", "filename": "compiler/rustc_error_messages/locales/en-US/interface.ftl", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finterface.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -4,3 +4,40 @@ interface_ferris_identifier =\n \n interface_emoji_identifier =\n     identifiers cannot contain emoji: `{$ident}`\n+\n+interface_mixed_bin_crate =\n+    cannot mix `bin` crate type with others\n+\n+interface_mixed_proc_macro_crate =\n+    cannot mix `proc-macro` crate type with others\n+\n+interface_proc_macro_doc_without_arg =\n+    Trying to document proc macro crate without passing '--crate-type proc-macro to rustdoc\n+    .warn = The generated documentation may be incorrect\n+\n+interface_error_writing_dependencies =\n+    error writing dependencies to `{$path}`: {$error}\n+\n+interface_input_file_would_be_overwritten =\n+    the input file \"{$path}\" would be overwritten by the generated executable\n+\n+interface_generated_file_conflicts_with_directory =\n+    the generated executable for the input file \"{$input_path}\" conflicts with the existing directory \"{$dir_path}\"\n+\n+interface_temps_dir_error =\n+    failed to find or create the directory specified by `--temps-dir`\n+\n+interface_out_dir_error =\n+    failed to find or create the directory specified by `--out-dir`\n+\n+interface_cant_emit_mir =\n+    could not emit MIR: {$error}\n+\n+interface_rustc_error_fatal =\n+    fatal error triggered by #[rustc_error]\n+\n+interface_rustc_error_unexpected_annotation =\n+    unexpected annotation used with `#[rustc_error(...)]!\n+\n+interface_failed_writing_file =\n+    failed to write file {$path}: {$error}\""}, {"sha": "27ad3e453660188727a674a59593a4cf71d39397", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -393,3 +393,37 @@ lint_builtin_deref_nullptr = dereferencing a null pointer\n     .label = this code causes undefined behavior when executed\n \n lint_builtin_asm_labels = avoid using named labels in inline assembly\n+\n+lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n+    .label = overruled by previous forbid\n+\n+lint_default_source = `forbid` lint level is the default for {$id}\n+\n+lint_node_source = `forbid` level set here\n+    .note = {$reason}\n+\n+lint_command_line_source = `forbid` lint level was set on command line\n+\n+lint_malformed_attribute = malformed lint attribute input\n+\n+lint_bad_attribute_argument = bad attribute argument\n+\n+lint_reason_must_be_string_literal = reason must be a string literal\n+\n+lint_reason_must_come_last = reason in lint attribute must come last\n+\n+lint_unknown_tool_in_scoped_lint = unknown tool name `{$tool_name}` found in scoped lint: `{$tool_name}::{$lint_name}`\n+    .help = add `#![register_tool({$tool_name})]` to the crate root\n+\n+lint_unsupported_group = `{$lint_group}` lint group is not supported with \u00b4--force-warn\u00b4\n+\n+lint_requested_level = requested on the command line with `{$level} {$lint_name}`\n+\n+lint_check_name_unknown = unknown lint: `{$lint_name}`\n+    .help = did you mean: `{$suggestion}`\n+\n+lint_check_name_unknown_tool = unknown lint tool: `{$tool_name}`\n+\n+lint_check_name_warning = {$msg}\n+\n+lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}"}, {"sha": "988541525088367d86439fb99cbecf25753c2466", "filename": "compiler/rustc_error_messages/locales/en-US/mir_dataflow.ftl", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_dataflow.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_dataflow.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_dataflow.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,29 @@\n+mir_dataflow_path_must_end_in_filename =\n+    path must end in a filename\n+\n+mir_dataflow_unknown_formatter =\n+    unknown formatter\n+\n+mir_dataflow_duplicate_values_for =\n+    duplicate values for `{$name}`\n+\n+mir_dataflow_requires_an_argument =\n+    `{$name}` requires an argument\n+\n+mir_dataflow_stop_after_dataflow_ended_compilation =\n+    stop_after_dataflow ended compilation\n+\n+mir_dataflow_peek_must_be_place_or_ref_place =\n+    rustc_peek: argument expression must be either `place` or `&place`\n+\n+mir_dataflow_peek_must_be_not_temporary =\n+    dataflow::sanity_check cannot feed a non-temp to rustc_peek\n+\n+mir_dataflow_peek_bit_not_set =\n+    rustc_peek: bit not set\n+\n+mir_dataflow_peek_argument_not_a_local =\n+    rustc_peek: argument was not a local\n+\n+mir_dataflow_peek_argument_untracked =\n+    rustc_peek: argument untracked"}, {"sha": "42c84fdd2d14be92a8ff43dbb3f3768f3a291222", "filename": "compiler/rustc_error_messages/locales/en-US/monomorphize.ftl", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,26 @@\n+monomorphize_recursion_limit =\n+    reached the recursion limit while instantiating `{$shrunk}`\n+    .note = `{$def_path_str}` defined here\n+\n+monomorphize_written_to_path = the full type name has been written to '{$path}'\n+\n+monomorphize_type_length_limit = reached the type-length limit while instantiating `{$shrunk}`\n+\n+monomorphize_consider_type_length_limit =\n+    consider adding a `#![type_length_limit=\"{$type_length}\"]` attribute to your crate\n+\n+monomorphize_fatal_error = {$error_message}\n+\n+monomorphize_unknown_partition_strategy = unknown partitioning strategy\n+\n+monomorphize_symbol_already_defined = symbol `{$symbol}` is already defined\n+\n+monomorphize_unused_generic_params = item has unused generic parameters\n+\n+monomorphize_large_assignments =\n+    moving {$size} bytes\n+    .label = value moved from here\n+    .note = The current maximum size is {$limit}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n+\n+monomorphize_requires_lang_item =\n+    requires `{$lang_item}` lang_item"}, {"sha": "3b37a393846b2abfe58bea09d5d6c719a41f7481", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -32,3 +32,121 @@ parser_incorrect_use_of_await =\n parser_in_in_typo =\n     expected iterable, found keyword `in`\n     .suggestion = remove the duplicated `in`\n+\n+parser_invalid_variable_declaration =\n+    invalid variable declaration\n+\n+parser_switch_mut_let_order =\n+    switch the order of `mut` and `let`\n+parser_missing_let_before_mut = missing keyword\n+parser_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n+parser_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+\n+parser_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n+    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n+    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n+\n+parser_invalid_logical_operator = `{$incorrect}` is not a logical operator\n+    .note = unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n+    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n+    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n+\n+parser_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n+    .suggestion = use `!` to perform bitwise not\n+\n+parser_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n+    .suggestion = use `!` to perform logical negation\n+\n+parser_malformed_loop_label = malformed loop label\n+    .suggestion = use the correct loop label format\n+\n+parser_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n+    .suggestion = remove the lifetime annotation\n+    .label = annotated with lifetime here\n+\n+parser_field_expression_with_generic = field expressions cannot have generic arguments\n+\n+parser_macro_invocation_with_qualified_path = macros cannot use qualified paths\n+\n+parser_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+\n+parser_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n+    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+    .label = the label\n+    .suggestion = add `:` after the label\n+\n+parser_do_catch_syntax_removed = found removed `do catch` syntax\n+    .note = following RFC #2388, the new non-placeholder syntax is `try`\n+    .suggestion = replace with the new syntax\n+\n+parser_float_literal_requires_integer_part = float literals must have an integer part\n+    .suggestion = must have an integer part\n+\n+parser_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128\n+\n+parser_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n+\n+parser_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+\n+parser_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n+\n+parser_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n+\n+parser_int_literal_too_large = integer literal is too large\n+\n+parser_missing_semicolon_before_array = expected `;`, found `[`\n+    .suggestion = consider adding `;` here\n+\n+parser_invalid_block_macro_segment = cannot use a `block` macro fragment here\n+    .label = the `block` fragment is within this context\n+\n+parser_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n+    .add_then_block = add a block here\n+    .condition_possibly_unfinished = this binary operation is possibly unfinished\n+\n+parser_if_expression_missing_condition = missing condition for `if` expression\n+    .condition_label = expected condition here\n+    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n+\n+parser_expected_expression_found_let = expected expression, found `let` statement\n+\n+parser_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n+    .label = expected an `if` or a block after this `else`\n+    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+\n+parser_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n+    .branch_label = the attributes are attached to this branch\n+    .ctx_label = the branch belongs to this `{$ctx}`\n+    .suggestion = remove the attributes\n+\n+parser_missing_in_in_for_loop = missing `in` in `for` loop\n+    .use_in_not_of = try using `in` here instead\n+    .add_in = try adding `in` here\n+\n+parser_missing_comma_after_match_arm = expected `,` following `match` arm\n+    .suggestion = missing a comma here to end this `match` arm\n+\n+parser_catch_after_try = keyword `catch` cannot follow a `try` block\n+    .help = try using `match` on the result of the `try` block instead\n+\n+parser_comma_after_base_struct = cannot use a comma after the base struct\n+    .note = the base struct must always be the last field\n+    .suggestion = remove this comma\n+\n+parser_eq_field_init = expected `:`, found `=`\n+    .suggestion = replace equals symbol with a colon\n+\n+parser_dotdotdot = unexpected token: `...`\n+    .suggest_exclusive_range = use `..` for an exclusive range\n+    .suggest_inclusive_range = or `..=` for an inclusive range\n+\n+parser_left_arrow_operator = unexpected token: `<-`\n+    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`"}, {"sha": "8db32a42c1deac0c1a01520c4e0cfe607c85b028", "filename": "compiler/rustc_error_messages/locales/en-US/plugin_impl.ftl", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fplugin_impl.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fplugin_impl.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fplugin_impl.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,4 @@\n+plugin_impl_load_plugin_error = {$msg}\n+\n+plugin_impl_malformed_plugin_attribute = malformed `plugin` attribute\n+    .label = malformed attribute"}, {"sha": "223092a74bd97cf00d62ed229dcbae3493e985c4", "filename": "compiler/rustc_error_messages/locales/en-US/privacy.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -14,7 +14,7 @@ privacy_in_public_interface = {$vis_descr} {$kind} `{$descr}` in public interfac\n privacy_from_private_dep_in_public_interface =\n     {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n \n-private_in_public_lint =\n+privacy_private_in_public_lint =\n     {$vis_descr} {$kind} `{$descr}` in public interface (error {$kind ->\n         [trait] E0445\n         *[other] E0446"}, {"sha": "36c2ff4682301c967c1656e4ac8441d9f6c92196", "filename": "compiler/rustc_error_messages/locales/en-US/save_analysis.ftl", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsave_analysis.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1 @@\n+save_analysis_could_not_open = Could not open `{$file_name}`: `{$err}`"}, {"sha": "983e5cee8237d801c8295fb85e706c993f0d5e7e", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,16 @@\n+session_incorrect_cgu_reuse_type =\n+    CGU-reuse for `{$cgu_user_name}` is `{$actual_reuse}` but should be {$at_least ->\n+    [one] {\"at least \"}\n+    *[other] {\"\"}\n+    }`{$expected_reuse}`\n+\n+session_cgu_not_recorded =\n+    CGU-reuse for `{$cgu_user_name}` is (mangled: `{$cgu_name}`) was not recorded`\n+\n+session_feature_gate_error = {$explain}\n+\n+session_feature_diagnostic_for_issue =\n+    see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n+\n+session_feature_diagnostic_help =\n+    add `#![feature({$feature})]` to the crate attributes to enable"}, {"sha": "55d6fbbf86f33029d86bae9e7cdf6f3f968922eb", "filename": "compiler/rustc_error_messages/locales/en-US/symbol_mangling.ftl", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsymbol_mangling.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,7 @@\n+symbol_mangling_invalid_symbol_name = symbol-name({$mangled_formatted})\n+\n+symbol_mangling_invalid_trait_item = demangling({$demangling_formatted})\n+\n+symbol_mangling_alt_invalid_trait_item = demangling-alt({$alt_demangling_formatted})\n+\n+symbol_mangling_invalid_def_path = def-path({$def_path})"}, {"sha": "1040ee1c97d814b8a04c97bcb2a88fcfa68c30c6", "filename": "compiler/rustc_error_messages/locales/en-US/ty_utils.ftl", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fty_utils.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,47 @@\n+ty_utils_needs_drop_overflow = overflow while checking whether `{$query_ty}` requires drop\n+\n+ty_utils_generic_constant_too_complex = overly complex generic constant\n+    .help = consider moving this anonymous constant into a `const` function\n+    .maybe_supported = this operation may be supported in the future\n+\n+ty_utils_borrow_not_supported = borrowing is not supported in generic constants\n+\n+ty_utils_address_and_deref_not_supported = dereferencing or taking the address is not supported in generic constants\n+\n+ty_utils_array_not_supported = array construction is not supported in generic constants\n+\n+ty_utils_block_not_supported = blocks are not supported in generic constant\n+\n+ty_utils_never_to_any_not_supported = converting nevers to any is not supported in generic constant\n+\n+ty_utils_tuple_not_supported = tuple construction is not supported in generic constants\n+\n+ty_utils_index_not_supported = indexing is not supported in generic constant\n+\n+ty_utils_field_not_supported = field access is not supported in generic constant\n+\n+ty_utils_const_block_not_supported = const blocks are not supported in generic constant\n+\n+ty_utils_adt_not_supported = struct/enum construction is not supported in generic constants\n+\n+ty_utils_pointer_not_supported = pointer casts are not allowed in generic constants\n+\n+ty_utils_yield_not_supported = generator control flow is not allowed in generic constants\n+\n+ty_utils_loop_not_supported = loops and loop control flow are not supported in generic constants\n+\n+ty_utils_box_not_supported = allocations are not allowed in generic constants\n+\n+ty_utils_binary_not_supported = unsupported binary operation in generic constants\n+\n+ty_utils_logical_op_not_supported = unsupported operation in generic constants, short-circuiting operations would imply control flow\n+\n+ty_utils_assign_not_supported = assignment is not supported in generic constants\n+\n+ty_utils_closure_and_return_not_supported = closures and function keywords are not supported in generic constants\n+\n+ty_utils_control_flow_not_supported = control flow is not supported in generic constants\n+\n+ty_utils_inline_asm_not_supported = assembly is not supported in generic constants\n+\n+ty_utils_operation_not_supported = unsupported operation in generic constant"}, {"sha": "272731d9914cc4cb48df34369c03e0e86fa2c028", "filename": "compiler/rustc_error_messages/locales/en-US/typeck.ftl", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -24,8 +24,8 @@ typeck_lifetimes_or_bounds_mismatch_on_trait =\n     .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n \n typeck_drop_impl_on_wrong_item =\n-    the `Drop` trait may only be implemented for structs, enums, and unions\n-    .label = must be a struct, enum, or union\n+    the `Drop` trait may only be implemented for local structs, enums, and unions\n+    .label = must be a struct, enum, or union in the current crate\n \n typeck_field_already_declared =\n     field `{$field_name}` is already declared\n@@ -131,3 +131,5 @@ typeck_unused_extern_crate =\n typeck_extern_crate_not_idiomatic =\n     `extern crate` is not idiomatic in the new edition\n     .suggestion = convert it to a `{$msg_code}`\n+\n+typeck_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`"}, {"sha": "42fb2d538b04d2027cbb3b841cbf3fcd334b83f6", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,6 +1,9 @@\n+#![feature(let_chains)]\n #![feature(once_cell)]\n #![feature(rustc_attrs)]\n #![feature(type_alias_impl_trait)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n use fluent_bundle::FluentResource;\n use fluent_syntax::parser::ParserError;\n@@ -30,16 +33,28 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n+    ast_lowering => \"../locales/en-US/ast_lowering.ftl\",\n+    ast_passes => \"../locales/en-US/ast_passes.ftl\",\n+    attr => \"../locales/en-US/attr.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n+    driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n+    session => \"../locales/en-US/session.ftl\",\n     interface => \"../locales/en-US/interface.ftl\",\n+    infer => \"../locales/en-US/infer.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n+    monomorphize => \"../locales/en-US/monomorphize.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n+    plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n+    save_analysis => \"../locales/en-US/save_analysis.ftl\",\n+    ty_utils => \"../locales/en-US/ty_utils.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n+    mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n+    symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\",\n }\n \n pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};"}, {"sha": "f75e2596f361b7549233878bccf2aa570baf3c5e", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -13,6 +13,7 @@ use rustc_span::{edition::Edition, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::path::{Path, PathBuf};\n \n /// Error type for `Diagnostic`'s `suggestions` field, indicating that\n /// `.disable_suggestions()` was called on the `Diagnostic`.\n@@ -83,6 +84,7 @@ into_diagnostic_arg_using_display!(\n     u64,\n     i128,\n     u128,\n+    std::io::Error,\n     std::num::NonZeroU32,\n     hir::Target,\n     Edition,\n@@ -124,6 +126,18 @@ impl IntoDiagnosticArg for String {\n     }\n }\n \n+impl<'a> IntoDiagnosticArg for &'a Path {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for PathBuf {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for usize {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Number(self)\n@@ -672,19 +686,12 @@ impl Diagnostic {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        assert!(!suggestion.is_empty());\n-        self.push_suggestion(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: suggestion\n-                    .into_iter()\n-                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                    .collect(),\n-            }],\n-            msg: self.subdiagnostic_message_to_diagnostic_message(msg),\n-            style: SuggestionStyle::CompletelyHidden,\n+        self.multipart_suggestion_with_style(\n+            msg,\n+            suggestion,\n             applicability,\n-        });\n-        self\n+            SuggestionStyle::CompletelyHidden,\n+        )\n     }\n \n     /// Prints out a message with a suggested edit of the code."}, {"sha": "61d767a1cc6b4f97d806c45b8a0d3a127ec2d59a", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -84,6 +84,13 @@ pub trait EmissionGuarantee: Sized {\n     /// of `Self` without actually performing the emission.\n     #[track_caller]\n     fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self;\n+\n+    /// Creates a new `DiagnosticBuilder` that will return this type of guarantee.\n+    #[track_caller]\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self>;\n }\n \n /// Private module for sealing the `IsError` helper trait.\n@@ -166,6 +173,15 @@ impl EmissionGuarantee for ErrorGuaranteed {\n             }\n         }\n     }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_guaranteeing_error::<_, { Level::Error { lint: false } }>(\n+            handler, msg,\n+        )\n+    }\n }\n \n impl<'a> DiagnosticBuilder<'a, ()> {\n@@ -208,6 +224,13 @@ impl EmissionGuarantee for () {\n             DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n         }\n     }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new(handler, Level::Warning(None), msg)\n+    }\n }\n \n impl<'a> DiagnosticBuilder<'a, !> {\n@@ -247,6 +270,13 @@ impl EmissionGuarantee for ! {\n         // Then fatally error, returning `!`\n         crate::FatalError.raise()\n     }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_fatal(handler, msg)\n+    }\n }\n \n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n@@ -566,7 +596,7 @@ impl Drop for DiagnosticBuilderInner<'_> {\n                         ),\n                     ));\n                     handler.emit_diagnostic(&mut self.diagnostic);\n-                    panic!();\n+                    panic!(\"error was constructed but not emitted\");\n                 }\n             }\n             // `.emit()` was previously called, or maybe we're during `.cancel()`."}, {"sha": "68abdd0bad1ff06165317a28d1f20392b33ba96e", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -6,6 +6,7 @@\n #![feature(drain_filter)]\n #![feature(if_let_guard)]\n #![feature(adt_const_params)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![feature(result_option_inspect)]\n@@ -459,6 +460,7 @@ struct HandlerInner {\n pub enum StashKey {\n     ItemNoType,\n     UnderscoreForArrayLengths,\n+    EarlySyntaxWarning,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n@@ -626,26 +628,29 @@ impl Handler {\n     /// Stash a given diagnostic with the given `Span` and `StashKey` as the key for later stealing.\n     pub fn stash_diagnostic(&self, span: Span, key: StashKey, diag: Diagnostic) {\n         let mut inner = self.inner.borrow_mut();\n-        // FIXME(Centril, #69537): Consider reintroducing panic on overwriting a stashed diagnostic\n-        // if/when we have a more robust macro-friendly replacement for `(span, key)` as a key.\n-        // See the PR for a discussion.\n-        inner.stashed_diagnostics.insert((span, key), diag);\n+        inner.stash((span, key), diag);\n     }\n \n     /// Steal a previously stashed diagnostic with the given `Span` and `StashKey` as the key.\n     pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_, ()>> {\n-        self.inner\n-            .borrow_mut()\n-            .stashed_diagnostics\n-            .remove(&(span, key))\n-            .map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n+        let mut inner = self.inner.borrow_mut();\n+        inner.steal((span, key)).map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n     }\n \n     /// Emit all stashed diagnostics.\n     pub fn emit_stashed_diagnostics(&self) -> Option<ErrorGuaranteed> {\n         self.inner.borrow_mut().emit_stashed_diagnostics()\n     }\n \n+    /// Construct a builder with the `msg` at the level appropriate for the specific `EmissionGuarantee`.\n+    #[rustc_lint_diagnostics]\n+    pub fn struct_diagnostic<G: EmissionGuarantee>(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, G> {\n+        G::make_diagnostic_builder(self, msg)\n+    }\n+\n     /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n     ///\n     /// Attempting to `.emit()` the builder will only emit if either:\n@@ -1106,13 +1111,31 @@ impl HandlerInner {\n \n     /// Emit all stashed diagnostics.\n     fn emit_stashed_diagnostics(&mut self) -> Option<ErrorGuaranteed> {\n+        let has_errors = self.has_errors();\n         let diags = self.stashed_diagnostics.drain(..).map(|x| x.1).collect::<Vec<_>>();\n         let mut reported = None;\n         for mut diag in diags {\n+            // Decrement the count tracking the stash; emitting will increment it.\n             if diag.is_error() {\n-                reported = Some(ErrorGuaranteed(()));\n+                if matches!(diag.level, Level::Error { lint: true }) {\n+                    self.lint_err_count -= 1;\n+                } else {\n+                    self.err_count -= 1;\n+                }\n+            } else {\n+                if diag.is_force_warn() {\n+                    self.warn_count -= 1;\n+                } else {\n+                    // Unless they're forced, don't flush stashed warnings when\n+                    // there are errors, to avoid causing warning overload. The\n+                    // stash would've been stolen already if it were important.\n+                    if has_errors {\n+                        continue;\n+                    }\n+                }\n             }\n-            self.emit_diagnostic(&mut diag);\n+            let reported_this = self.emit_diagnostic(&mut diag);\n+            reported = reported.or(reported_this);\n         }\n         reported\n     }\n@@ -1226,9 +1249,13 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags\n-            .treat_err_as_bug\n-            .map_or(false, |c| self.err_count() + self.lint_err_count >= c.get())\n+        self.flags.treat_err_as_bug.map_or(false, |c| {\n+            self.err_count()\n+                + self.lint_err_count\n+                + self.delayed_span_bugs.len()\n+                + self.delayed_good_path_bugs.len()\n+                >= c.get()\n+        })\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n@@ -1302,9 +1329,47 @@ impl HandlerInner {\n         }\n     }\n \n+    fn stash(&mut self, key: (Span, StashKey), diagnostic: Diagnostic) {\n+        // Track the diagnostic for counts, but don't panic-if-treat-err-as-bug\n+        // yet; that happens when we actually emit the diagnostic.\n+        if diagnostic.is_error() {\n+            if matches!(diagnostic.level, Level::Error { lint: true }) {\n+                self.lint_err_count += 1;\n+            } else {\n+                self.err_count += 1;\n+            }\n+        } else {\n+            // Warnings are only automatically flushed if they're forced.\n+            if diagnostic.is_force_warn() {\n+                self.warn_count += 1;\n+            }\n+        }\n+\n+        // FIXME(Centril, #69537): Consider reintroducing panic on overwriting a stashed diagnostic\n+        // if/when we have a more robust macro-friendly replacement for `(span, key)` as a key.\n+        // See the PR for a discussion.\n+        self.stashed_diagnostics.insert(key, diagnostic);\n+    }\n+\n+    fn steal(&mut self, key: (Span, StashKey)) -> Option<Diagnostic> {\n+        let diagnostic = self.stashed_diagnostics.remove(&key)?;\n+        if diagnostic.is_error() {\n+            if matches!(diagnostic.level, Level::Error { lint: true }) {\n+                self.lint_err_count -= 1;\n+            } else {\n+                self.err_count -= 1;\n+            }\n+        } else {\n+            if diagnostic.is_force_warn() {\n+                self.warn_count -= 1;\n+            }\n+        }\n+        Some(diagnostic)\n+    }\n+\n     #[inline]\n     fn err_count(&self) -> usize {\n-        self.err_count + self.stashed_diagnostics.len()\n+        self.err_count\n     }\n \n     fn has_errors(&self) -> bool {\n@@ -1346,7 +1411,14 @@ impl HandlerInner {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n-        if self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() + 1 >= c.get()) {\n+        if self.flags.treat_err_as_bug.map_or(false, |c| {\n+            self.err_count()\n+                + self.lint_err_count\n+                + self.delayed_span_bugs.len()\n+                + self.delayed_good_path_bugs.len()\n+                + 1\n+                >= c.get()\n+        }) {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n         }"}, {"sha": "2bb522caa2d418b2e292119ed7e84a08d1909c5d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, Attribute, HasAttrs, Item, NodeId, PatKind};\n+use rustc_ast::{self as ast, AttrVec, Attribute, HasAttrs, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::sync::{self, Lrc};\n@@ -71,7 +71,7 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    pub fn visit_attrs(&mut self, f: impl FnOnce(&mut AttrVec)) {\n         match self {\n             Annotatable::Item(item) => item.visit_attrs(f),\n             Annotatable::TraitItem(trait_item) => trait_item.visit_attrs(f),\n@@ -1227,7 +1227,7 @@ pub fn expr_to_spanned_string<'a>(\n                 );\n                 Some((err, true))\n             }\n-            ast::LitKind::Err(_) => None,\n+            ast::LitKind::Err => None,\n             _ => Some((cx.struct_span_err(l.span, err_msg), false)),\n         },\n         ast::ExprKind::Err => None,"}, {"sha": "c4890b4a9c41378e14fdc07cf4ae6a2f883a9a45", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -575,7 +575,7 @@ impl<'a> ExtCtxt<'a> {\n         &self,\n         span: Span,\n         name: Ident,\n-        attrs: Vec<ast::Attribute>,\n+        attrs: ast::AttrVec,\n         kind: ast::ItemKind,\n     ) -> P<ast::Item> {\n         // FIXME: Would be nice if our generated code didn't violate\n@@ -603,7 +603,7 @@ impl<'a> ExtCtxt<'a> {\n         mutbl: ast::Mutability,\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, Some(expr)))\n+        self.item(span, name, AttrVec::new(), ast::ItemKind::Static(ty, mutbl, Some(expr)))\n     }\n \n     pub fn item_const(\n@@ -614,7 +614,7 @@ impl<'a> ExtCtxt<'a> {\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n         let def = ast::Defaultness::Final;\n-        self.item(span, name, Vec::new(), ast::ItemKind::Const(def, ty, Some(expr)))\n+        self.item(span, name, AttrVec::new(), ast::ItemKind::Const(def, ty, Some(expr)))\n     }\n \n     pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {"}, {"sha": "48ee23d2c3d18e50fb2712cfa3198f36a08ea7f1", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -215,7 +215,7 @@ pub fn features(\n     let features = match strip_unconfigured.configure_krate_attrs(krate.attrs) {\n         None => {\n             // The entire crate is unconfigured.\n-            krate.attrs = Vec::new();\n+            krate.attrs = ast::AttrVec::new();\n             krate.items = Vec::new();\n             Features::default()\n         }\n@@ -265,7 +265,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_krate_attrs(&self, mut attrs: Vec<ast::Attribute>) -> Option<Vec<ast::Attribute>> {\n+    fn configure_krate_attrs(&self, mut attrs: ast::AttrVec) -> Option<ast::AttrVec> {\n         attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         if self.in_cfg(&attrs) { Some(attrs) } else { None }\n     }\n@@ -292,9 +292,7 @@ impl<'a> StripUnconfigured<'a> {\n             .iter()\n             .flat_map(|(tree, spacing)| match tree.clone() {\n                 AttrAnnotatedTokenTree::Attributes(mut data) => {\n-                    let mut attrs: Vec<_> = std::mem::take(&mut data.attrs).into();\n-                    attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n-                    data.attrs = attrs.into();\n+                    data.attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n \n                     if self.in_cfg(&data.attrs) {\n                         data.tokens = LazyTokenStream::new("}, {"sha": "0feae0debd22750a4b5d1a0fb80b000d3ed6497f", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -3,44 +3,44 @@ use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n #[derive(SessionDiagnostic)]\n-#[error(expand::expr_repeat_no_syntax_vars)]\n+#[diag(expand::expr_repeat_no_syntax_vars)]\n pub(crate) struct NoSyntaxVarsExprRepeat {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(expand::must_repeat_once)]\n+#[diag(expand::must_repeat_once)]\n pub(crate) struct MustRepeatOnce {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(expand::count_repetition_misplaced)]\n+#[diag(expand::count_repetition_misplaced)]\n pub(crate) struct CountRepetitionMisplaced {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(expand::meta_var_expr_unrecognized_var)]\n+#[diag(expand::meta_var_expr_unrecognized_var)]\n pub(crate) struct MetaVarExprUnrecognizedVar {\n     #[primary_span]\n     pub span: Span,\n     pub key: MacroRulesNormalizedIdent,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(expand::var_still_repeating)]\n+#[diag(expand::var_still_repeating)]\n pub(crate) struct VarStillRepeating {\n     #[primary_span]\n     pub span: Span,\n     pub ident: MacroRulesNormalizedIdent,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(expand::meta_var_dif_seq_matchers)]\n+#[diag(expand::meta_var_dif_seq_matchers)]\n pub(crate) struct MetaVarsDifSeqMatchers {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "c2add852a0679672e97a5ae8a1714d29c1ad8c1c", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrStyle, ExprKind, ForeignItemKind};\n+use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrStyle, AttrVec, ExprKind, ForeignItemKind};\n use rustc_ast::{HasAttrs, HasNodeId};\n use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind};\n use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n@@ -306,7 +306,7 @@ pub struct Invocation {\n \n pub enum InvocationKind {\n     Bang {\n-        mac: ast::MacCall,\n+        mac: P<ast::MacCall>,\n         span: Span,\n     },\n     Attr {\n@@ -1001,7 +1001,7 @@ enum AddSemicolon {\n /// of functionality used by `InvocationCollector`.\n trait InvocationCollectorNode: HasAttrs + HasNodeId + Sized {\n     type OutputTy = SmallVec<[Self; 1]>;\n-    type AttrsTy: Deref<Target = [ast::Attribute]> = Vec<ast::Attribute>;\n+    type AttrsTy: Deref<Target = [ast::Attribute]> = ast::AttrVec;\n     const KIND: AstFragmentKind;\n     fn to_annotatable(self) -> Annotatable;\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy;\n@@ -1017,7 +1017,7 @@ trait InvocationCollectorNode: HasAttrs + HasNodeId + Sized {\n     fn is_mac_call(&self) -> bool {\n         false\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         unreachable!()\n     }\n     fn pre_flat_map_node_collect_attr(_cfg: &StripUnconfigured<'_>, _attr: &ast::Attribute) {}\n@@ -1046,7 +1046,7 @@ impl InvocationCollectorNode for P<ast::Item> {\n     fn is_mac_call(&self) -> bool {\n         matches!(self.kind, ItemKind::MacCall(..))\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n             ItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n@@ -1154,7 +1154,7 @@ impl InvocationCollectorNode for AstNodeWrapper<P<ast::AssocItem>, TraitItemTag>\n     fn is_mac_call(&self) -> bool {\n         matches!(self.wrapped.kind, AssocItemKind::MacCall(..))\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let item = self.wrapped.into_inner();\n         match item.kind {\n             AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n@@ -1179,7 +1179,7 @@ impl InvocationCollectorNode for AstNodeWrapper<P<ast::AssocItem>, ImplItemTag>\n     fn is_mac_call(&self) -> bool {\n         matches!(self.wrapped.kind, AssocItemKind::MacCall(..))\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let item = self.wrapped.into_inner();\n         match item.kind {\n             AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n@@ -1202,7 +1202,7 @@ impl InvocationCollectorNode for P<ast::ForeignItem> {\n     fn is_mac_call(&self) -> bool {\n         matches!(self.kind, ForeignItemKind::MacCall(..))\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n             ForeignItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n@@ -1323,7 +1323,7 @@ impl InvocationCollectorNode for ast::Stmt {\n             StmtKind::Local(..) | StmtKind::Empty => false,\n         }\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         // We pull macro invocations (both attributes and fn-like macro calls) out of their\n         // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n         let (add_semicolon, mac, attrs) = match self.kind {\n@@ -1333,7 +1333,7 @@ impl InvocationCollectorNode for ast::Stmt {\n             }\n             StmtKind::Item(item) => match item.into_inner() {\n                 ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n-                    (mac.args.need_semicolon(), mac, attrs.into())\n+                    (mac.args.need_semicolon(), mac, attrs)\n                 }\n                 _ => unreachable!(),\n             },\n@@ -1387,10 +1387,10 @@ impl InvocationCollectorNode for P<ast::Ty> {\n     fn is_mac_call(&self) -> bool {\n         matches!(self.kind, ast::TyKind::MacCall(..))\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            TyKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            TyKind::MacCall(mac) => (mac, AttrVec::new(), AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1411,10 +1411,10 @@ impl InvocationCollectorNode for P<ast::Pat> {\n     fn is_mac_call(&self) -> bool {\n         matches!(self.kind, PatKind::MacCall(..))\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n-            PatKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            PatKind::MacCall(mac) => (mac, AttrVec::new(), AddSemicolon::No),\n             _ => unreachable!(),\n         }\n     }\n@@ -1439,7 +1439,7 @@ impl InvocationCollectorNode for P<ast::Expr> {\n     fn is_mac_call(&self) -> bool {\n         matches!(self.kind, ExprKind::MacCall(..))\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let node = self.into_inner();\n         match node.kind {\n             ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n@@ -1466,7 +1466,7 @@ impl InvocationCollectorNode for AstNodeWrapper<P<ast::Expr>, OptExprTag> {\n     fn is_mac_call(&self) -> bool {\n         matches!(self.wrapped.kind, ast::ExprKind::MacCall(..))\n     }\n-    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n         let node = self.wrapped.into_inner();\n         match node.kind {\n             ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n@@ -1512,7 +1512,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         placeholder(fragment_kind, NodeId::placeholder_from_expn_id(expn_id), vis)\n     }\n \n-    fn collect_bang(&mut self, mac: ast::MacCall, kind: AstFragmentKind) -> AstFragment {\n+    fn collect_bang(&mut self, mac: P<ast::MacCall>, kind: AstFragmentKind) -> AstFragment {\n         // cache the macro call span so that it can be\n         // easily adjusted for incremental compilation\n         let span = mac.span();\n@@ -1646,7 +1646,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn expand_cfg_attr(&self, node: &mut impl HasAttrs, attr: ast::Attribute, pos: usize) {\n         node.visit_attrs(|attrs| {\n-            attrs.splice(pos..pos, self.cfg().expand_cfg_attr(attr, false));\n+            // Repeated `insert` calls is inefficient, but the number of\n+            // insertions is almost always 0 or 1 in practice.\n+            for cfg in self.cfg().expand_cfg_attr(attr, false).into_iter().rev() {\n+                attrs.insert(pos, cfg)\n+            }\n         });\n     }\n "}, {"sha": "75dcbd69674d652c5897b8db9c596fc74307eabc", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -2,6 +2,7 @@\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n #![feature(if_let_guard)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(macro_metavar_expr)]\n #![feature(proc_macro_diagnostic)]"}, {"sha": "9002a24e42f9df671dc913fe744306dd480909ef", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,6 +1,6 @@\n use crate::base::ModuleData;\n use rustc_ast::ptr::P;\n-use rustc_ast::{token, Attribute, Inline, Item, ModSpans};\n+use rustc_ast::{token, AttrVec, Attribute, Inline, Item, ModSpans};\n use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_parse::new_parser_from_file;\n use rustc_parse::validate_attr;\n@@ -48,7 +48,7 @@ pub(crate) fn parse_external_mod(\n     span: Span, // The span to blame on errors.\n     module: &ModuleData,\n     mut dir_ownership: DirOwnership,\n-    attrs: &mut Vec<Attribute>,\n+    attrs: &mut AttrVec,\n ) -> ParsedExternalMod {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n     let result: Result<_, ModError<'_>> = try {\n@@ -63,9 +63,9 @@ pub(crate) fn parse_external_mod(\n \n         // Actually parse the external file as a module.\n         let mut parser = new_parser_from_file(&sess.parse_sess, &mp.file_path, Some(span));\n-        let (mut inner_attrs, items, inner_span) =\n+        let (inner_attrs, items, inner_span) =\n             parser.parse_mod(&token::Eof).map_err(|err| ModError::ParserError(err))?;\n-        attrs.append(&mut inner_attrs);\n+        attrs.extend(inner_attrs);\n         (items, inner_span, mp.file_path)\n     };\n     // (1) ...instead, we return a dummy module."}, {"sha": "3b0d5ddb97b4e184e11b2608a37dbb05a71c719d", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -15,16 +15,16 @@ pub fn placeholder(\n     id: ast::NodeId,\n     vis: Option<ast::Visibility>,\n ) -> AstFragment {\n-    fn mac_placeholder() -> ast::MacCall {\n-        ast::MacCall {\n+    fn mac_placeholder() -> P<ast::MacCall> {\n+        P(ast::MacCall {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new(), tokens: None },\n             args: P(ast::MacArgs::Empty),\n             prior_type_ascription: None,\n-        }\n+        })\n     }\n \n     let ident = Ident::empty();\n-    let attrs = Vec::new();\n+    let attrs = ast::AttrVec::new();\n     let vis = vis.unwrap_or(ast::Visibility {\n         span: DUMMY_SP,\n         kind: ast::VisibilityKind::Inherited,"}, {"sha": "c22adf77a27f6c4ffaae83ee1ffce37e98bd457e", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -186,8 +186,8 @@ declare_features! (\n     /// Allows some increased flexibility in the name resolution rules,\n     /// especially around globs and shadowing (RFC 1560).\n     (accepted, item_like_imports, \"1.15.0\", Some(35120), None),\n-    /// Allows `if/while p && let q = r && ...` chains.\n-    (accepted, let_chains, \"1.64.0\", Some(53667), None),\n+    /// Allows `'a: { break 'a; }`.\n+    (accepted, label_break_value, \"CURRENT_RUSTC_VERSION\", Some(48594), None),\n     /// Allows `break {expr}` with a value inside `loop`s.\n     (accepted, loop_break_value, \"1.19.0\", Some(37339), None),\n     /// Allows use of `?` as the Kleene \"at most one\" operator in macros."}, {"sha": "e09c3ccbc75abdd9f873ab92e30c41c132e99455", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -420,10 +420,10 @@ declare_features! (\n     (active, intra_doc_pointers, \"1.51.0\", Some(80896), None),\n     /// Allows `#[instruction_set(_)]` attribute\n     (active, isa_attribute, \"1.48.0\", Some(74727), None),\n-    /// Allows `'a: { break 'a; }`.\n-    (active, label_break_value, \"1.28.0\", Some(48594), None),\n     // Allows setting the threshold for the `large_assignments` lint.\n     (active, large_assignments, \"1.52.0\", Some(83518), None),\n+    /// Allows `if/while p && let q = r && ...` chains.\n+    (active, let_chains, \"1.37.0\", Some(53667), None),\n     /// Allows `let...else` statements.\n     (active, let_else, \"1.56.0\", Some(87335), None),\n     /// Allows `#[link(..., cfg(..))]`.\n@@ -481,8 +481,6 @@ declare_features! (\n     (incomplete, raw_dylib, \"1.40.0\", Some(58713), None),\n     /// Allows `&raw const $place_expr` and `&raw mut $place_expr` expressions.\n     (active, raw_ref_op, \"1.41.0\", Some(64490), None),\n-    /// Allows using the `#[register_attr]` attribute.\n-    (active, register_attr, \"1.41.0\", Some(66080), None),\n     /// Allows using the `#[register_tool]` attribute.\n     (active, register_tool, \"1.41.0\", Some(66079), None),\n     /// Allows the `#[repr(i128)]` attribute for enums."}, {"sha": "0487270b52a9aaad0e0dce49ac753a2c8ba84b98", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -335,7 +335,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ABI, linking, symbols, and FFI\n     ungated!(\n         link, Normal,\n-        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\"\"#),\n+        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\", /*opt*/ import_name_type = \"decorated|noprefix|undecorated\"\"#),\n         DuplicatesOk,\n     ),\n     ungated!(link_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n@@ -458,10 +458,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     gated!(ffi_pure, Normal, template!(Word), WarnFollowing, experimental!(ffi_pure)),\n     gated!(ffi_const, Normal, template!(Word), WarnFollowing, experimental!(ffi_const)),\n-    gated!(\n-        register_attr, CrateLevel, template!(List: \"attr1, attr2, ...\"), DuplicatesOk,\n-        experimental!(register_attr),\n-    ),\n     gated!(\n         register_tool, CrateLevel, template!(List: \"tool1, tool2, ...\"), DuplicatesOk,\n         experimental!(register_tool),"}, {"sha": "e44c9291f84838c7f66a152b05b211ee4d0171ac", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -12,6 +12,8 @@\n //! symbol to the `accepted` or `removed` modules respectively.\n \n #![feature(once_cell)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n mod accepted;\n mod active;"}, {"sha": "13f275bb6a0c923c8faf88df743e4409fc28b686", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -163,6 +163,9 @@ declare_features! (\n     (removed, quad_precision_float, \"1.0.0\", None, None, None),\n     (removed, quote, \"1.33.0\", Some(29601), None, None),\n     (removed, reflect, \"1.0.0\", Some(27749), None, None),\n+    /// Allows using the `#[register_attr]` attribute.\n+    (removed, register_attr, \"CURRENT_RUSTC_VERSION\", Some(66080), None,\n+     Some(\"removed in favor of `#![register_tool]`\")),\n     /// Allows using the macros:\n     /// + `__diagnostic_used`\n     /// + `__register_diagnostic`"}, {"sha": "63998bb6b00cf8467305edaad139b7d9d9fd80de", "filename": "compiler/rustc_fs_util/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use std::ffi::CString;\n use std::fs;\n use std::io;"}, {"sha": "3c1bb5532661aa20c4bdc454936ddf4fd0e4d2d5", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -273,6 +273,8 @@\n     html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\",\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n use LabelText::*;\n "}, {"sha": "2d2648a8f35af5e586d70b998e4407a8e5251713", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -45,8 +45,6 @@ pub enum NonMacroAttrKind {\n     /// Single-segment custom attribute registered by a derive macro\n     /// but used before that derive macro was expanded (deprecated).\n     DeriveHelperCompat,\n-    /// Single-segment custom attribute registered with `#[register_attr]`.\n-    Registered,\n }\n \n /// What kind of definition something is; e.g., `mod` vs `struct`.\n@@ -564,15 +562,11 @@ impl NonMacroAttrKind {\n             NonMacroAttrKind::DeriveHelper | NonMacroAttrKind::DeriveHelperCompat => {\n                 \"derive helper attribute\"\n             }\n-            NonMacroAttrKind::Registered => \"explicitly registered attribute\",\n         }\n     }\n \n     pub fn article(self) -> &'static str {\n-        match self {\n-            NonMacroAttrKind::Registered => \"an\",\n-            _ => \"a\",\n-        }\n+        \"a\"\n     }\n \n     /// Users of some attributes cannot mark them as used, so they are considered always used.\n@@ -581,7 +575,7 @@ impl NonMacroAttrKind {\n             NonMacroAttrKind::Tool\n             | NonMacroAttrKind::DeriveHelper\n             | NonMacroAttrKind::DeriveHelperCompat => true,\n-            NonMacroAttrKind::Builtin(..) | NonMacroAttrKind::Registered => false,\n+            NonMacroAttrKind::Builtin(..) => false,\n         }\n     }\n }"}, {"sha": "e593ed1044a5818e1f4cdb7765bd9bd75cb393d9", "filename": "compiler/rustc_hir/src/errors.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,10 @@\n+use crate::LangItem;\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable)]\n+pub struct LangItemError(pub LangItem);\n+\n+impl ToString for LangItemError {\n+    fn to_string(&self) -> String {\n+        format!(\"requires `{}` lang_item\", self.0.name())\n+    }\n+}"}, {"sha": "a069c49b0cc1eff6b8d8618a789bbcba1e0eba2b", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -3216,7 +3216,7 @@ impl<'hir> OwnerNode<'hir> {\n         }\n     }\n \n-    pub fn fn_decl(&self) -> Option<&FnDecl<'hir>> {\n+    pub fn fn_decl(self) -> Option<&'hir FnDecl<'hir>> {\n         match self {\n             OwnerNode::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n             | OwnerNode::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })\n@@ -3400,19 +3400,20 @@ impl<'hir> Node<'hir> {\n         }\n     }\n \n-    pub fn fn_decl(&self) -> Option<&'hir FnDecl<'hir>> {\n+    pub fn fn_decl(self) -> Option<&'hir FnDecl<'hir>> {\n         match self {\n             Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n             | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })\n             | Node::Item(Item { kind: ItemKind::Fn(fn_sig, _, _), .. }) => Some(fn_sig.decl),\n-            Node::ForeignItem(ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n+            Node::Expr(Expr { kind: ExprKind::Closure(Closure { fn_decl, .. }), .. })\n+            | Node::ForeignItem(ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n                 Some(fn_decl)\n             }\n             _ => None,\n         }\n     }\n \n-    pub fn fn_sig(&self) -> Option<&'hir FnSig<'hir>> {\n+    pub fn fn_sig(self) -> Option<&'hir FnSig<'hir>> {\n         match self {\n             Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n             | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })"}, {"sha": "0c01326d0032ac61842af06569cf493b714d7ed5", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -8,6 +8,7 @@\n //! * Functions called by the compiler itself.\n \n use crate::def_id::DefId;\n+use crate::errors::LangItemError;\n use crate::{MethodKind, Target};\n \n use rustc_ast as ast;\n@@ -115,9 +116,9 @@ macro_rules! language_item_table {\n \n             /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n             /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-            /// returns an error message as a string.\n-            pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n-                self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n+            /// returns an error encapsulating the `LangItem`.\n+            pub fn require(&self, it: LangItem) -> Result<DefId, LangItemError> {\n+                self.items[it as usize].ok_or_else(|| LangItemError(it))\n             }\n \n             /// Returns the [`DefId`]s of all lang items in a group."}, {"sha": "092029ef09ec80e6cab087b6b63838e94ed25f4e", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -11,6 +11,8 @@\n #![feature(never_type)]\n #![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -25,6 +27,7 @@ pub mod def;\n pub mod def_path_hash_map;\n pub mod definitions;\n pub mod diagnostic_items;\n+pub mod errors;\n pub use rustc_span::def_id;\n mod hir;\n pub mod hir_id;"}, {"sha": "42663da8a3f9c173d400e46eca4660dcea8b0c5c", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,4 +1,6 @@\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n use rustc_ast as ast;\n use rustc_ast::util::parser::{self, AssocOp, Fixity};"}, {"sha": "aa34673de81d77063902c7575db6f8979223a626", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(allow_internal_unstable)]\n #![feature(bench_black_box)]\n #![feature(extend_one)]"}, {"sha": "aced787d6711600ee0337b7ee4dd16a3c736973b", "filename": "compiler/rustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2FCargo.toml?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -15,6 +15,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "938f8aa77a5b4589f6e5eb2f5ed5956fce22ee8b", "filename": "compiler/rustc_infer/src/errors.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -0,0 +1,254 @@\n+use rustc_errors::{fluent, AddSubdiagnostic, DiagnosticMessage, DiagnosticStyledString};\n+use rustc_hir::FnRetTy;\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{BytePos, Span};\n+\n+use crate::infer::error_reporting::{\n+    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n+    ObligationCauseAsDiagArg,\n+};\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::opaque_hidden_type)]\n+pub struct OpaqueHiddenTypeDiag {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(infer::opaque_type)]\n+    pub opaque_type: Span,\n+    #[note(infer::hidden_type)]\n+    pub hidden_type: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+pub struct AnnotationRequired<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0283\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+pub struct AmbigousImpl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0284\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+pub struct AmbigousReturn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+pub struct NeedTypeInfoInGenerator<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub generator_kind: GeneratorKindAsDiagArg,\n+    #[subdiagnostic]\n+    pub bad_label: InferenceBadError<'a>,\n+}\n+\n+// Used when a better one isn't available\n+#[derive(SessionSubdiagnostic)]\n+#[label(infer::label_bad)]\n+pub struct InferenceBadError<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub bad_kind: &'static str,\n+    pub prefix_kind: UnderspecifiedArgKind,\n+    pub has_parent: bool,\n+    pub prefix: &'a str,\n+    pub parent_prefix: &'a str,\n+    pub parent_name: String,\n+    pub name: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum SourceKindSubdiag<'a> {\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_let,\n+        code = \": {type_name}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    LetLike {\n+        #[primary_span]\n+        span: Span,\n+        name: String,\n+        type_name: String,\n+        kind: &'static str,\n+        x_kind: &'static str,\n+        prefix_kind: UnderspecifiedArgKind,\n+        prefix: &'a str,\n+        arg_name: String,\n+    },\n+    #[label(infer::source_kind_subdiag_generic_label)]\n+    GenericLabel {\n+        #[primary_span]\n+        span: Span,\n+        is_type: bool,\n+        param_name: String,\n+        parent_exists: bool,\n+        parent_prefix: String,\n+        parent_name: String,\n+    },\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_generic_suggestion,\n+        code = \"::<{args}>\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    GenericSuggestion {\n+        #[primary_span]\n+        span: Span,\n+        arg_count: usize,\n+        args: String,\n+    },\n+}\n+\n+// Has to be implemented manually because multipart suggestions are not supported by the derive macro.\n+// Would be a part of `SourceKindSubdiag` otherwise.\n+pub enum SourceKindMultiSuggestion<'a> {\n+    FullyQualified {\n+        span: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor: (&'a str, BytePos),\n+    },\n+    ClosureReturn {\n+        ty_info: String,\n+        data: &'a FnRetTy<'a>,\n+        should_wrap_expr: Option<Span>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for SourceKindMultiSuggestion<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            Self::FullyQualified { span, def_path, adjustment, successor } => {\n+                let suggestion = vec![\n+                    (span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n+                    (span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n+                ];\n+                diag.multipart_suggestion_verbose(\n+                    fluent::infer::source_kind_fully_qualified,\n+                    suggestion,\n+                    rustc_errors::Applicability::HasPlaceholders,\n+                );\n+            }\n+            Self::ClosureReturn { ty_info, data, should_wrap_expr } => {\n+                let (arrow, post) = match data {\n+                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+                    _ => (\"\", \"\"),\n+                };\n+                let suggestion = match should_wrap_expr {\n+                    Some(end_span) => vec![\n+                        (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post)),\n+                        (end_span, \" }\".to_string()),\n+                    ],\n+                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ty_info, post))],\n+                };\n+                diag.multipart_suggestion_verbose(\n+                    fluent::infer::source_kind_closure_return,\n+                    suggestion,\n+                    rustc_errors::Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+pub enum RegionOriginNote<'a> {\n+    Plain {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+    },\n+    WithName {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+        name: &'a str,\n+        continues: bool,\n+    },\n+    WithRequirement {\n+        span: Span,\n+        requirement: ObligationCauseAsDiagArg<'a>,\n+        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for RegionOriginNote<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut label_or_note = |span, msg: DiagnosticMessage| {\n+            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                diag.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                diag.note(msg);\n+            } else {\n+                diag.span_note(span, msg);\n+            }\n+        };\n+        match self {\n+            RegionOriginNote::Plain { span, msg } => {\n+                label_or_note(span, msg);\n+            }\n+            RegionOriginNote::WithName { span, msg, name, continues } => {\n+                label_or_note(span, msg);\n+                diag.set_arg(\"name\", name);\n+                diag.set_arg(\"continues\", continues);\n+            }\n+            RegionOriginNote::WithRequirement {\n+                span,\n+                requirement,\n+                expected_found: Some((expected, found)),\n+            } => {\n+                label_or_note(span, fluent::infer::subtype);\n+                diag.set_arg(\"requirement\", requirement);\n+\n+                diag.note_expected_found(&\"\", expected, &\"\", found);\n+            }\n+            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n+                // FIXME: this really should be handled at some earlier stage. Our\n+                // handling of region checking when type errors are present is\n+                // *terrible*.\n+                label_or_note(span, fluent::infer::subtype_2);\n+                diag.set_arg(\"requirement\", requirement);\n+            }\n+        };\n+    }\n+}"}, {"sha": "00e238648712ffaf103d6750c4c5c3b9ce6fbede", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -74,10 +74,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             evaluation_cache: self.evaluation_cache.clone(),\n             reported_trait_errors: self.reported_trait_errors.clone(),\n             reported_closure_mismatch: self.reported_closure_mismatch.clone(),\n-            tainted_by_errors_flag: self.tainted_by_errors_flag.clone(),\n+            tainted_by_errors: self.tainted_by_errors.clone(),\n             err_count_on_creation: self.err_count_on_creation,\n             in_snapshot: self.in_snapshot.clone(),\n             universe: self.universe.clone(),\n+            normalize_fn_sig_for_diagnostic: self\n+                .normalize_fn_sig_for_diagnostic\n+                .as_ref()\n+                .map(|f| f.clone()),\n         }\n     }\n }"}, {"sha": "46f8c0e8d8b9acad49d334fcc9d3dc04852b53b8", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -372,7 +372,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 debug!(\n                     \"canonical: region var found with vid {:?}, \\\n                      opportunistically resolved to {:?}\",\n-                    vid, r\n+                    vid, resolved_vid\n                 );\n                 let r = self.tcx.reuse_or_mk_region(r, ty::ReVar(resolved_vid));\n                 self.canonicalize_mode.canonicalize_free_region(self, r)"}, {"sha": "64c759f73d410323cc08d6eeb8c688c5b5d7942f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -63,8 +63,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n+        debug!(\"query_response = {:#?}\", query_response);\n         let canonical_result = self.canonicalize_response(query_response);\n-\n         debug!(\"canonical_result = {:#?}\", canonical_result);\n \n         Ok(self.tcx.arena.alloc(canonical_result))\n@@ -125,13 +125,15 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         debug!(\"ambig_errors = {:#?}\", ambig_errors);\n \n         let region_obligations = self.take_registered_region_obligations();\n+        debug!(?region_obligations);\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n                 region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n                 region_constraints,\n             )\n         });\n+        debug!(?region_constraints);\n \n         let certainty =\n             if ambig_errors.is_empty() { Certainty::Proven } else { Certainty::Ambiguous };\n@@ -632,6 +634,8 @@ pub fn make_query_region_constraints<'tcx>(\n     assert!(verifys.is_empty());\n     assert!(givens.is_empty());\n \n+    debug!(?constraints);\n+\n     let outlives: Vec<_> = constraints\n         .iter()\n         .map(|(k, _)| match *k {"}, {"sha": "3a6119a627368fb18da0c9e7f4638546ce339428", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 144, "deletions": 74, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24", "patch": "@@ -58,14 +58,15 @@ use crate::traits::{\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n+use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n     self, error::TypeError, Binder, List, Region, Subst, Ty, TyCtxt, TypeFoldable,\n     TypeSuperVisitable, TypeVisitable,\n@@ -77,7 +78,7 @@ use std::{cmp, fmt, iter};\n \n mod note;\n \n-mod need_type_info;\n+pub(crate) mod need_type_info;\n pub use need_type_info::TypeAnnotationNeeded;\n \n pub mod nice_region_error;\n@@ -739,12 +740,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.help(\"...or use `match` instead of `let...else`\");\n             }\n             _ => {\n-                if let ObligationCauseCode::BindingObligation(_, binding_span) =\n-                    cause.code().peel_derives()\n+                if let ObligationCauseCode::BindingObligation(_, span)\n+                | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n+                    = cause.code().peel_derives()\n+                    && let TypeError::RegionsPlaceholderMismatch = terr\n                 {\n-                    if matches!(terr, TypeError::RegionsPlaceholderMismatch) {\n-                        err.span_note(*binding_span, \"the lifetime requirement is introduced here\");\n-                    }\n+                    err.span_note(*span, \"the lifetime requirement is introduced here\");\n                 }\n             }\n         }\n@@ -960,12 +961,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn normalize_fn_sig_for_diagnostic(&self, sig: ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx> {\n+        if let Some(normalize) = &self.normalize_fn_sig_for_diagnostic {\n+            normalize(self, sig)\n+        } else {\n+            sig\n+        }\n+    }\n+\n     /// Given two `fn` signatures highlight only sub-parts that are different.\n     fn cmp_fn_sig(\n         &self,\n         sig1: &ty::PolyFnSig<'tcx>,\n         sig2: &ty::PolyFnSig<'tcx>,\n     ) -> (DiagnosticStyledString, DiagnosticStyledString) {\n+        let sig1 = &self.normalize_fn_sig_for_diagnostic(*sig1);\n+        let sig2 = &self.normalize_fn_sig_for_diagnostic(*sig2);\n+\n         let get_lifetimes = |sig| {\n             use rustc_hir::def::Namespace;\n             let (_, sig, reg) = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS)\n@@ -1587,9 +1599,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             Mismatch::Variable(infer::ExpectedFound { expected, found }),\n                         )\n                     }\n+                    ValuePairs::Terms(infer::ExpectedFound {\n+                        expected: ty::Term::Const(_),\n+                        found: ty::Term::Const(_),\n+                    }) => (false, Mismatch::Fixed(\"constant\")),\n                     ValuePairs::TraitRefs(_) | ValuePairs::PolyTraitRefs(_) => {\n                         (false, Mismatch::Fixed(\"trait\"))\n                     }\n+                    ValuePairs::Regions(_) => (false, Mismatch::Fixed(\"lifetime\")),\n                     _ => (false, Mismatch::Fixed(\"type\")),\n                 };\n                 let vals = match self.values_str(values) {\n@@ -2038,22 +2055,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             (exp_found.expected.kind(), exp_found.found.kind())\n         {\n             if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n-                let path_str = format!(\"{:?}\", exp_def);\n                 if exp_def == &found_def {\n-                    let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n-                                       `.as_ref()`\";\n-                    let result_msg = \"you can convert from `&Result<T, E>` to \\\n-                                          `Result<&T, &E>` using `.as_ref()`\";\n                     let have_as_ref = &[\n-                        (\"std::option::Option\", opt_msg),\n-                        (\"core::option::Option\", opt_msg),\n-                        (\"std::result::Result\", result_msg),\n-                        (\"core::result::Result\", result_msg),\n+                        (\n+                            sym::Option,\n+                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+                        `.as_ref()`\",\n+                        ),\n+                        (\n+                            sym::Result,\n+                            \"you can convert from `&Result<T, E>` to \\\n+                        `Result<&T, &E>` using `.as_ref()`\",\n+                        ),\n                     ];\n-                    if let Some(msg) = have_as_ref\n-                        .iter()\n-                        .find_map(|(path, msg)| (&path_str == path).then_some(msg))\n-                    {\n+                    if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n+                        self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n+                    }) {\n                         let mut show_suggestion = true;\n                         for (exp_ty, found_ty) in\n                             iter::zip(exp_substs.types(), found_substs.types())\n@@ -2079,7 +2096,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             diag.span_suggestion(\n                                 span,\n                                 *msg,\n-                                format!(\"{}.as_ref()\", snippet),\n+                                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+                                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n                                 Applicability::MachineApplicable,\n                             );\n                         }\n@@ -2660,67 +2678,95 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n     pub fn same_type_modulo_infer(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         let (a, b) = self.resolve_vars_if_possible((a, b));\n-        match (a.kind(), b.kind()) {\n-            (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) => {\n-                if def_a != def_b {\n-                    return false;\n-                }\n+        SameTypeModuloInfer(self).relate(a, b).is_ok()\n+    }\n+}\n \n-                substs_a\n-                    .types()\n-                    .zip(substs_b.types())\n-                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n-            }\n-            (&ty::FnDef(did_a, substs_a), &ty::FnDef(did_b, substs_b)) => {\n-                if did_a != did_b {\n-                    return false;\n-                }\n+struct SameTypeModuloInfer<'a, 'tcx>(&'a InferCtxt<'a, 'tcx>);\n \n-                substs_a\n-                    .types()\n-                    .zip(substs_b.types())\n-                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n-            }\n-            (&ty::Int(_) | &ty::Uint(_), &ty::Infer(ty::InferTy::IntVar(_)))\n+impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.0.tcx\n+    }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        // Unused, only for consts which we treat as always equal\n+        ty::ParamEnv::empty()\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"SameTypeModuloInfer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: relate::Relate<'tcx>>(\n+        &mut self,\n+        _variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> relate::RelateResult<'tcx, T> {\n+        self.relate(a, b)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        match (a.kind(), b.kind()) {\n+            (ty::Int(_) | ty::Uint(_), ty::Infer(ty::InferTy::IntVar(_)))\n             | (\n-                &ty::Infer(ty::InferTy::IntVar(_)),\n-                &ty::Int(_) | &ty::Uint(_) | &ty::Infer(ty::InferTy::IntVar(_)),\n+                ty::Infer(ty::InferTy::IntVar(_)),\n+                ty::Int(_) | ty::Uint(_) | ty::Infer(ty::InferTy::IntVar(_)),\n             )\n-            | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n+            | (ty::Float(_), ty::Infer(ty::InferTy::FloatVar(_)))\n             | (\n-                &ty::Infer(ty::InferTy::FloatVar(_)),\n-                &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n+                ty::Infer(ty::InferTy::FloatVar(_)),\n+                ty::Float(_) | ty::Infer(ty::InferTy::FloatVar(_)),\n             )\n-            | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n-            | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n-            (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n-                mut_a == mut_b && self.same_type_modulo_infer(ty_a, ty_b)\n-            }\n-            (&ty::RawPtr(a), &ty::RawPtr(b)) => {\n-                a.mutbl == b.mutbl && self.same_type_modulo_infer(a.ty, b.ty)\n-            }\n-            (&ty::Slice(a), &ty::Slice(b)) => self.same_type_modulo_infer(a, b),\n-            (&ty::Array(a_ty, a_ct), &ty::Array(b_ty, b_ct)) => {\n-                self.same_type_modulo_infer(a_ty, b_ty) && a_ct == b_ct\n-            }\n-            (&ty::Tuple(a), &ty::Tuple(b)) => {\n-                if a.len() != b.len() {\n-                    return false;\n-                }\n-                std::iter::zip(a.iter(), b.iter()).all(|(a, b)| self.same_type_modulo_infer(a, b))\n-            }\n-            (&ty::FnPtr(a), &ty::FnPtr(b)) => {\n-                let a = a.skip_binder().inputs_and_output;\n-                let b = b.skip_binder().inputs_and_output;\n-                if a.len() != b.len() {\n-                    return false;\n-                }\n-                std::iter::zip(a.iter(), b.iter()).all(|(a, b)| self.same_type_modulo_infer(a, b))\n-            }\n-            // FIXME(compiler-errors): This needs to be generalized more\n-            _ => a == b,\n+            | (ty::Infer(ty::InferTy::TyVar(_)), _)\n+            | (_, ty::Infer(ty::InferTy::TyVar(_))) => Ok(a),\n+            (ty::Infer(_), _) | (_, ty::Infer(_)) => Err(TypeError::Mismatch),\n+            _ => relate::super_relate_tys(self, a, b),\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        if (a.is_var() && b.is_free_or_static())\n+            || (b.is_var() && a.is_free_or_static())\n+            || (a.is_var() && b.is_var())\n+            || a == b\n+        {\n+            Ok(a)\n+        } else {\n+            Err(TypeError::Mismatch)\n         }\n     }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> relate::RelateResult<'tcx, ty::Binder<'tcx, T>>\n+    where\n+        T: relate::Relate<'tcx>,\n+    {\n+        Ok(ty::Binder::dummy(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+\n+    fn consts(\n+        &mut self,\n+        a: ty::Const<'tcx>,\n+        _b: ty::Const<'tcx>,\n+    ) -> relate::RelateResult<'tcx, ty::Const<'tcx>> {\n+        // FIXME(compiler-errors): This could at least do some first-order\n+        // relation\n+        Ok(a)\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -2854,6 +2900,30 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     }\n }\n \n+/// Newtype to allow implementing IntoDiagnosticArg\n+pub struct ObligationCauseAsDiagArg<'tcx>(pub ObligationCause<'tcx>);\n+\n+impl IntoDiagnosticArg for ObligationCauseAsDiagArg<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        use crate::traits::ObligationCauseCode::*;\n+        let kind = match self.0.code() {\n+            CompareImplItemObligation { kind: ty::AssocKind::Fn, .. } => \"method_compat\",\n+            CompareImplItemObligation { kind: ty::AssocKind::Type, .. } => \"type_compat\",\n+            CompareImplItemObligation { kind: ty::AssocKind::Const, .. } => \"const_compat\",\n+            ExprAssignable => \"expr_assignable\",\n+            IfExpression { .. } => \"if_else_different\",\n+            IfExpressionWithNoElse => \"no_else\",\n+            MainFunctionType => \"fn_main_correct_type\",\n+            StartFunctionType => \"fn_start_correct_type\",\n+            IntrinsicType => \"intristic_correct_type\",\n+            MethodReceiver => \"method_correct_type\",\n+            _ => \"other\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n /// This is a bare signal of what kind of type we're dealing with. `ty::TyKind` tracks\n /// extra information about each type, but we only care about the category.\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "e990fe7ecb50427edb13538bd0a4a0b985cf7fa0", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "ddad72fdab93d9dfabeba68820cef3edfac199a1", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "c20b96cae2e4f000a28da7346e06c14b1b40e2f0", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "d4db0751212f7ce8033af90f00171a9ccb697fcc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "f804569b0747ea0c45771f7f6be92de3fc603e02", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "cffdf56bb6d48f78a28eb2856b4a9816e3386a39", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 51, "deletions": 67, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "728d691a2be7d27bc42121264409fe23e33a6138", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "60ebf8b949d26a6ae72868d758b7de75931a4ff4", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "e7e93116a66d146c9d3b74ad4bb5cd79324cc06b", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "233a5004a3931f53444eaf75538edc8f89d65e6a", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "872886da3626108ca370bfb942d650bced1a1775", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "fe78890ff6ed7648b309d0b095b284b25c0dd4b3", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "b7eab5d43285b121e16f34f0ec291e42f31703a7", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "931ebca7d014524a579c16c78355a2c0e0c74c03", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "6a497aed4aba75900410fe8b166cd56b92293a21", "filename": "compiler/rustc_interface/src/errors.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "258e38c3bdb9e09197fc006865defaa66903149a", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "66c6a229b89e4564b4e9130f3191eded516adcf7", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 23, "deletions": 54, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "65fa8d7495a4bf16cc76277a97bf5593e3e29fd9", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "178366f7d8045a9263ec22a7081bef423f103ffa", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "868555a72b0d1284f94982c90cc8dcd600a9f486", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "002bba4759be820ace8e656cd52a36f9fe52edca", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 42, "deletions": 60, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "cdb5b3c4284a8d37afc0dd2f6bb7b4f8c3006937", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "606d8bda8aafe6c7548731caaacdb9d75ca1c44c", "filename": "compiler/rustc_lint/src/errors.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "89409b58f88b90af3d5762e537c33ac986f7c131", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 55, "deletions": 43, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "c3065e4a2d9383c13d7bb147f2540c5b6d3efef4", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "90c554c2e040bf248c36969efdbccb8409cca4ea", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "484e541afc5879c477a6fefc674ba50bd642e08a", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "2dca6acdd6d6fb562331476c6bec93a59df7f847", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "9c6530c8a08438e8afc2eaddced942affe1df3db", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "28e092c1eb72c1c9205068aa388bc5d912dc0a8c", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "448a1f62f69edce1a815b7221a3ac05ccd0a26d2", "filename": "compiler/rustc_llvm/llvm-wrapper/ArchiveWrapper.cpp", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FArchiveWrapper.cpp?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "05d2a214d0b79374b73454ab9c7592fe2d7b9255", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "8542dcf5bf0fe4012215e4b58daeb2ee9f3508d3", "filename": "compiler/rustc_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "458f5e87baeacff3d4d72e44cb95b8f5c2874ef0", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "244edec2841591260cfef4c53bfc807851a13880", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 62, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "a4ccfcace1923e6bc81cc18519649c75c407eb59", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "f7d8b494ee257f528444552127716ee296672f22", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "2ff21e18ff853aef531789b8642abe33ffba7ba6", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "8b40e295bd8a7aa33c4e5a52034d61adb2065cbc", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 447, "deletions": 255, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "ad9ecd39b9e85a29989670027afba4cdeed1bf97", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "20ee5dfc7279844b171ab30f71fd380fc101b0ed", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "f93fe2d519508e1e301d75134b2a592ad8ae7d61", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 148, "deletions": 274, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "92590c33b9d1e90b765492e3894a35854d7f6c80", "filename": "compiler/rustc_macros/src/symbols.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}, {"sha": "6440f3e390cf1fde772fe34a0b50f79eef8faf20", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eda2a401457ba645a32bdc5b9e7e90214e3e4e24/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=eda2a401457ba645a32bdc5b9e7e90214e3e4e24"}]}