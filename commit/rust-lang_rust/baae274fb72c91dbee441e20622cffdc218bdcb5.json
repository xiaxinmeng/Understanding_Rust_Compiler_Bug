{"sha": "baae274fb72c91dbee441e20622cffdc218bdcb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYWUyNzRmYjcyYzkxZGJlZTQ0MWUyMDYyMmNmZmRjMjE4YmRjYjU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-17T23:57:23Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-06T08:46:26Z"}, "message": "Use `Span` instead of `SyntaxContext` in `Ident`", "tree": {"sha": "fb2a1dbed9ee24d5a8731bec7cb7d0dab6e383ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb2a1dbed9ee24d5a8731bec7cb7d0dab6e383ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baae274fb72c91dbee441e20622cffdc218bdcb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baae274fb72c91dbee441e20622cffdc218bdcb5", "html_url": "https://github.com/rust-lang/rust/commit/baae274fb72c91dbee441e20622cffdc218bdcb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baae274fb72c91dbee441e20622cffdc218bdcb5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48fa6f9631868b07309b02f479e2ec523bb58c2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/48fa6f9631868b07309b02f479e2ec523bb58c2b", "html_url": "https://github.com/rust-lang/rust/commit/48fa6f9631868b07309b02f479e2ec523bb58c2b"}], "stats": {"total": 239, "additions": 146, "deletions": 93}, "files": [{"sha": "124815a88493103413f567f1dc13431a077357d9", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -1097,7 +1097,7 @@ impl TokenTree {\n                 }).into();\n             },\n             self::TokenTree::Term(tt) => {\n-                let ident = ast::Ident { name: tt.sym, ctxt: tt.span.0.ctxt() };\n+                let ident = ast::Ident::new(tt.sym, tt.span.0);\n                 let sym_str = tt.sym.as_str();\n                 let token =\n                     if sym_str.starts_with(\"'\") { Lifetime(ident) }"}, {"sha": "c47f67ec74093f52796a98227e856b9fecf903f4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -909,7 +909,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ident(&mut self, ident: Ident) -> Name {\n         let ident = ident.modern();\n-        if ident.ctxt == SyntaxContext::empty() {\n+        if ident.span.ctxt() == SyntaxContext::empty() {\n             return ident.name;\n         }\n         *self.name_map\n@@ -2089,10 +2089,7 @@ impl<'a> LoweringContext<'a> {\n             name: self.lower_ident(match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried) positional field hygiene\n-                None => Ident {\n-                    name: Symbol::intern(&index.to_string()),\n-                    ctxt: f.span.ctxt(),\n-                },\n+                None => Ident::new(Symbol::intern(&index.to_string()), f.span),\n             }),\n             vis: self.lower_visibility(&f.vis, None),\n             ty: self.lower_ty(&f.ty, ImplTraitContext::Disallowed),"}, {"sha": "7335511a5a051c083e0de1e666d1c4e89c634f29", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -655,7 +655,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Ident {\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n-            ctxt: _ // Ignore this\n+            span: _ // Ignore this\n         } = *self;\n \n         name.hash_stable(hcx, hasher);"}, {"sha": "b920553ec369835e663256d96768b20af7446278", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -2088,8 +2088,8 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n             return Some(index);\n         }\n         let mut ident = name.to_ident();\n-        while ident.ctxt != SyntaxContext::empty() {\n-            ident.ctxt.remove_mark();\n+        while ident.span.ctxt() != SyntaxContext::empty() {\n+            ident.span.remove_mark();\n             if let Some(field) = self.fields.iter().position(|f| f.name.to_ident() == ident) {\n                 return Some(field);\n             }\n@@ -2558,7 +2558,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             LOCAL_CRATE => self.hir.definitions().expansion(scope.index),\n             _ => Mark::root(),\n         };\n-        let scope = match ident.ctxt.adjust(expansion) {\n+        let scope = match ident.span.adjust(expansion) {\n             Some(macro_def) => self.hir.definitions().macro_def_scope(macro_def),\n             None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n             None => self.hir.get_module_parent(block),"}, {"sha": "70b73ebb8cdeb476f5b978bdf9579a8e017542a7", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -466,11 +466,11 @@ impl<'a> PrinterSupport for HygieneAnnotation<'a> {\n impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(&ast::Ident { name, ctxt }) => {\n+            pprust::NodeIdent(&ast::Ident { name, span }) => {\n                 s.s.space()?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}{:?}\", name.as_u32(), ctxt))\n+                s.synth_comment(format!(\"{}{:?}\", name.as_u32(), span.ctxt()))\n             }\n             pprust::NodeName(&name) => {\n                 s.s.space()?;"}, {"sha": "d951a7f1cc1cdb90835c1adc8ecafaede64e1510", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -35,7 +35,6 @@ use rustc::util::nodemap::NodeSet;\n use syntax::ast::{self, CRATE_NODE_ID, Ident};\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use syntax_pos::hygiene::SyntaxContext;\n \n use std::cmp;\n use std::mem::replace;\n@@ -495,11 +494,11 @@ struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     // Checks that a field in a struct constructor (expression or pattern) is accessible.\n     fn check_field(&mut self,\n-                   use_ctxt: SyntaxContext, // Syntax context of the field name at the use site\n+                   use_ctxt: Span, // Syntax context of the field name at the use site\n                    span: Span, // Span of the field pattern, e.g. `x: 0`\n                    def: &'tcx ty::AdtDef, // Definition of the struct or enum\n                    field: &'tcx ty::FieldDef) { // Definition of the field\n-        let ident = Ident { ctxt: use_ctxt.modern(), ..keywords::Invalid.ident() };\n+        let ident = Ident::new(keywords::Invalid.name(), use_ctxt.modern());\n         let def_id = self.tcx.adjust_ident(ident, def.did, self.current_item).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n@@ -573,14 +572,14 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                     for variant_field in &variant.fields {\n                         let field = fields.iter().find(|f| f.name.node == variant_field.name);\n                         let (use_ctxt, span) = match field {\n-                            Some(field) => (field.name.node.to_ident().ctxt, field.span),\n-                            None => (base.span.ctxt(), base.span),\n+                            Some(field) => (field.name.node.to_ident().span, field.span),\n+                            None => (base.span, base.span),\n                         };\n                         self.check_field(use_ctxt, span, adt, variant_field);\n                     }\n                 } else {\n                     for field in fields {\n-                        let use_ctxt = field.name.node.to_ident().ctxt;\n+                        let use_ctxt = field.name.node.to_ident().span;\n                         let field_def = variant.field_named(field.name.node);\n                         self.check_field(use_ctxt, field.span, adt, field_def);\n                     }\n@@ -599,7 +598,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n-                    let use_ctxt = field.node.name.to_ident().ctxt;\n+                    let use_ctxt = field.node.name.to_ident().span;\n                     let field_def = variant.field_named(field.node.name);\n                     self.check_field(use_ctxt, field.span, adt, field_def);\n                 }"}, {"sha": "f7fd190af0c29fa48eb51b1adb3a2bffbe71c229", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -157,7 +157,7 @@ impl<'a> Resolver<'a> {\n \n                     // Disallow `use $crate;`\n                     if source.name == keywords::DollarCrate.name() && path.segments.len() == 1 {\n-                        let crate_root = self.resolve_crate_root(source.ctxt, true);\n+                        let crate_root = self.resolve_crate_root(source.span.ctxt(), true);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),"}, {"sha": "cb5c6f8ec5f87467b9295d2799459a69b373e8fb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -1912,10 +1912,11 @@ impl<'a> Resolver<'a> {\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident.ctxt = if ident.name == keywords::SelfType.name() {\n-                SyntaxContext::empty() // FIXME(jseyfried) improve `Self` hygiene\n+            ident.span = if ident.name == keywords::SelfType.name() {\n+                // FIXME(jseyfried) improve `Self` hygiene\n+                ident.span.with_ctxt(SyntaxContext::empty())\n             } else {\n-                ident.ctxt.modern()\n+                ident.span.modern()\n             }\n         }\n \n@@ -1931,10 +1932,10 @@ impl<'a> Resolver<'a> {\n \n             module = match self.ribs[ns][i].kind {\n                 ModuleRibKind(module) => module,\n-                MacroDefinition(def) if def == self.macro_def(ident.ctxt) => {\n+                MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n                     // If an invocation of this macro created `ident`, give up on `ident`\n                     // and switch to `ident`'s source from the macro definition.\n-                    ident.ctxt.remove_mark();\n+                    ident.span.remove_mark();\n                     continue\n                 }\n                 _ => continue,\n@@ -1954,9 +1955,9 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        ident.ctxt = ident.ctxt.modern();\n+        ident.span = ident.span.modern();\n         loop {\n-            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.ctxt), break);\n+            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.span), break);\n             let orig_current_module = self.current_module;\n             self.current_module = module; // Lexical resolutions can never be a privacy error.\n             let result = self.resolve_ident_in_module_unadjusted(\n@@ -1980,10 +1981,10 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, ctxt: &mut SyntaxContext)\n+    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, span: &mut Span)\n                                -> Option<Module<'a>> {\n-        if !module.expansion.is_descendant_of(ctxt.outer()) {\n-            return Some(self.macro_def_scope(ctxt.remove_mark()));\n+        if !module.expansion.is_descendant_of(span.ctxt().outer()) {\n+            return Some(self.macro_def_scope(span.remove_mark()));\n         }\n \n         if let ModuleKind::Block(..) = module.kind {\n@@ -1995,7 +1996,7 @@ impl<'a> Resolver<'a> {\n             let parent_expansion = parent.expansion.modern();\n             if module_expansion.is_descendant_of(parent_expansion) &&\n                parent_expansion != module_expansion {\n-                return if parent_expansion.is_descendant_of(ctxt.outer()) {\n+                return if parent_expansion.is_descendant_of(span.ctxt().outer()) {\n                     Some(parent)\n                 } else {\n                     None\n@@ -2016,9 +2017,9 @@ impl<'a> Resolver<'a> {\n                                record_used: bool,\n                                span: Span)\n                                -> Result<&'a NameBinding<'a>, Determinacy> {\n-        ident.ctxt = ident.ctxt.modern();\n+        ident.span = ident.span.modern();\n         let orig_current_module = self.current_module;\n-        if let Some(def) = ident.ctxt.adjust(module.expansion) {\n+        if let Some(def) = ident.span.adjust(module.expansion) {\n             self.current_module = self.macro_def_scope(def);\n         }\n         let result = self.resolve_ident_in_module_unadjusted(\n@@ -2108,8 +2109,8 @@ impl<'a> Resolver<'a> {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n                 MacroDefinition(def) => {\n-                    if def == self.macro_def(ident.ctxt) {\n-                        ident.ctxt.remove_mark();\n+                    if def == self.macro_def(ident.span.ctxt()) {\n+                        ident.span.remove_mark();\n                     }\n                 }\n                 _ => {\n@@ -2873,7 +2874,7 @@ impl<'a> Resolver<'a> {\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n                 if let Some(candidate) = this.lookup_assoc_candidate(ident.node, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].node.ctxt, span);\n+                    let self_is_available = this.self_value_is_available(path[0].node.span, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_suggestion(span, \"try\",\n@@ -3084,9 +3085,9 @@ impl<'a> Resolver<'a> {\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n-    fn self_value_is_available(&mut self, ctxt: SyntaxContext, span: Span) -> bool {\n-        let ident = Ident { name: keywords::SelfValue.name(), ctxt: ctxt };\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, false, span);\n+    fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n+        let ident = Ident::new(keywords::SelfValue.name(), self_span);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, false, path_span);\n         if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n     }\n \n@@ -3219,11 +3220,11 @@ impl<'a> Resolver<'a> {\n             let name = ident.node.name;\n \n             if i == 0 && ns == TypeNS && name == keywords::SelfValue.name() {\n-                let mut ctxt = ident.node.ctxt.modern();\n+                let mut ctxt = ident.node.span.ctxt().modern();\n                 module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n             } else if allow_super && ns == TypeNS && name == keywords::Super.name() {\n-                let mut ctxt = ident.node.ctxt.modern();\n+                let mut ctxt = ident.node.span.ctxt().modern();\n                 let self_module = match i {\n                     0 => self.resolve_self(&mut ctxt, self.current_module),\n                     _ => module.unwrap(),\n@@ -3245,11 +3246,11 @@ impl<'a> Resolver<'a> {\n                    (i == 1 && name == keywords::Crate.name() &&\n                               path[0].node.name == keywords::CrateRoot.name()) {\n                     // `::a::b` or `::crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.node.ctxt, false));\n+                    module = Some(self.resolve_crate_root(ident.node.span.ctxt(), false));\n                     continue\n                 } else if i == 0 && name == keywords::DollarCrate.name() {\n                     // `$crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident.node.ctxt, true));\n+                    module = Some(self.resolve_crate_root(ident.node.span.ctxt(), true));\n                     continue\n                 } else if i == 1 && !token::is_path_segment_keyword(ident.node) {\n                     let prev_name = path[0].node.name;\n@@ -3771,12 +3772,12 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        ident.ctxt = ident.ctxt.modern();\n+        ident.span = ident.span.modern();\n         let mut search_module = self.current_module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n             search_module =\n-                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.ctxt), break);\n+                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.span), break);\n         }\n \n         if let Some(prelude) = self.prelude {\n@@ -3808,7 +3809,7 @@ impl<'a> Resolver<'a> {\n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n             let module = binding.module().unwrap();\n             let mut ident = ident;\n-            if ident.ctxt.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n+            if ident.span.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n                 continue\n             }\n             if self.resolve_ident_in_module_unadjusted(module, ident, ns, false, false, module.span)"}, {"sha": "289556cd45e0fc8bf7fac116644e7add08dbf1c1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -140,7 +140,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 let ident = path.segments[0].identifier;\n                 if ident.name == keywords::DollarCrate.name() {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n-                    let module = self.0.resolve_crate_root(ident.ctxt, true);\n+                    let module = self.0.resolve_crate_root(ident.span.ctxt(), true);\n                     if !module.is_local() {\n                         let span = path.segments[0].span;\n                         path.segments.insert(1, match module.kind {\n@@ -534,7 +534,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             module = match module {\n-                Some(module) => self.hygienic_lexical_parent(module, &mut ident.ctxt),\n+                Some(module) => self.hygienic_lexical_parent(module, &mut ident.span),\n                 None => return potential_illegal_shadower,\n             }\n         }"}, {"sha": "90a90d731534bf9d4d72c8a139a5effd4ef1708f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -238,7 +238,7 @@ impl<'a> Resolver<'a> {\n             }\n             let module = unwrap_or!(directive.imported_module.get(), return Err(Undetermined));\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n-            match ident.ctxt.glob_adjust(module.expansion, directive.span.ctxt().modern()) {\n+            match ident.span.glob_adjust(module.expansion, directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n                 Some(None) => {}\n                 None => continue,\n@@ -398,7 +398,7 @@ impl<'a> Resolver<'a> {\n         // Define `binding` in `module`s glob importers.\n         for directive in module.glob_importers.borrow_mut().iter() {\n             let mut ident = ident.modern();\n-            let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion,\n                                                              directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => directive.parent,\n@@ -623,7 +623,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                          \"crate root imports need to be explicitly named: \\\n                                           `use crate as name;`\".to_string()));\n                         } else {\n-                            Some(self.resolve_crate_root(source.ctxt.modern(), false))\n+                            Some(self.resolve_crate_root(source.span.ctxt().modern(), false))\n                         }\n                     } else if is_extern && !token::is_path_segment_keyword(source) {\n                         let crate_id =\n@@ -860,7 +860,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n-            let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion,\n                                                              directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => self.current_module,"}, {"sha": "6d85e949d6bd8506edf2156cbcd5c7b9d0fdf0d9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -3213,10 +3213,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if !tuple_like { continue }\n \n                     debug!(\"tuple struct named {:?}\",  base_t);\n-                    let ident = ast::Ident {\n-                        name: Symbol::intern(&idx.node.to_string()),\n-                        ctxt: idx.span.ctxt().modern(),\n-                    };\n+                    let ident =\n+                        ast::Ident::new(Symbol::intern(&idx.node.to_string()), idx.span.modern());\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident(ident, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;"}, {"sha": "ec5dd7dfd179ac5d17cc4b29cbdd2f168505f910", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -150,7 +150,7 @@ impl PathSegment {\n     }\n     pub fn crate_root(span: Span) -> Self {\n         PathSegment {\n-            identifier: Ident { ctxt: span.ctxt(), ..keywords::CrateRoot.ident() },\n+            identifier: Ident::new(keywords::CrateRoot.name(), span),\n             span,\n             parameters: None,\n         }"}, {"sha": "1e264369f918d82df38c42b2a8f9fe6fab67d982", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -876,8 +876,8 @@ impl<'a> ExtCtxt<'a> {\n         ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[&str]) -> Vec<ast::Ident> {\n-        let def_site = SyntaxContext::empty().apply_mark(self.current_expansion.mark);\n-        iter::once(Ident { ctxt: def_site, ..keywords::DollarCrate.ident() })\n+        let def_site = DUMMY_SP.apply_mark(self.current_expansion.mark);\n+        iter::once(Ident::new(keywords::DollarCrate.name(), def_site))\n             .chain(components.iter().map(|s| self.ident_of(s)))\n             .collect()\n     }"}, {"sha": "31072159ab3f8372ae2066ab4dd4bf16c5dc79af", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -1378,7 +1378,7 @@ pub struct Marker(pub Mark);\n \n impl Folder for Marker {\n     fn fold_ident(&mut self, mut ident: Ident) -> Ident {\n-        ident.ctxt = ident.ctxt.apply_mark(self.0);\n+        ident.span = ident.span.apply_mark(self.0);\n         ident\n     }\n "}, {"sha": "01b971976a763c3d49bf72f5283e2303e52f0442", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -289,14 +289,11 @@ where\n             // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n             // metavariable that names the crate of the invokation.\n             Some(tokenstream::TokenTree::Token(ident_span, ref token)) if token.is_ident() => {\n-                let (ident, _) = token.ident().unwrap();\n+                let (ident, is_raw) = token.ident().unwrap();\n                 let span = ident_span.with_lo(span.lo());\n-                if ident.name == keywords::Crate.name() {\n-                    let ident = ast::Ident {\n-                        name: keywords::DollarCrate.name(),\n-                        ..ident\n-                    };\n-                    TokenTree::Token(span, token::Ident(ident, false))\n+                if ident.name == keywords::Crate.name() && !is_raw {\n+                    let ident = ast::Ident::new(keywords::DollarCrate.name(), ident.span);\n+                    TokenTree::Token(span, token::Ident(ident, is_raw))\n                 } else {\n                     TokenTree::MetaVar(span, ident)\n                 }"}, {"sha": "12ada3bdbc0b90e4cc70c4e1c22639ad58607f2a", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -166,7 +166,7 @@ pub fn transcribe(cx: &ExtCtxt,\n                     }\n                 } else {\n                     let ident =\n-                        Ident { ctxt: ident.ctxt.apply_mark(cx.current_expansion.mark), ..ident };\n+                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.mark));\n                     sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n                     result.push(TokenTree::Token(sp, token::Dollar).into());\n                     result.push(TokenTree::Token(sp, token::Token::from_ast_ident(ident)).into());"}, {"sha": "152c4c31eb3e3669ee7731958a4b6333503bae1a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -76,7 +76,7 @@ impl<'a> StringReader<'a> {\n     fn mk_ident(&self, string: &str) -> Ident {\n         let mut ident = Ident::from_str(string);\n         if let Some(span) = self.override_span {\n-            ident.ctxt = span.ctxt();\n+            ident.span = span;\n         }\n         ident\n     }"}, {"sha": "30be2389e7e3fc22ceda0e0daecbba8050cac8e7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -743,7 +743,7 @@ pub trait PrintState<'a> {\n                        segment.identifier.name != keywords::DollarCrate.name() {\n                         self.writer().word(&segment.identifier.name.as_str())?;\n                     } else if segment.identifier.name == keywords::DollarCrate.name() {\n-                        self.print_dollar_crate(segment.identifier.ctxt)?;\n+                        self.print_dollar_crate(segment.identifier.span.ctxt())?;\n                     }\n                 }\n                 self.writer().space()?;\n@@ -2424,7 +2424,7 @@ impl<'a> State<'a> {\n                 self.print_path_parameters(parameters, colons_before_params)?;\n             }\n         } else if segment.identifier.name == keywords::DollarCrate.name() {\n-            self.print_dollar_crate(segment.identifier.ctxt)?;\n+            self.print_dollar_crate(segment.identifier.span.ctxt())?;\n         }\n         Ok(())\n     }"}, {"sha": "2b80d6987642339c218ed401146e6547eea38d63", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n use syntax::ast;\n+use syntax::codemap::DUMMY_SP;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n-use syntax_pos::hygiene::SyntaxContext;\n use syntax::tokenstream::TokenTree;\n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n@@ -53,11 +53,8 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n             }\n         }\n     }\n-    let res = ast::Ident {\n-        name: Symbol::intern(&res_str),\n-        ctxt: SyntaxContext::empty().apply_mark(cx.current_expansion.mark),\n-    };\n-\n+    let res = ast::Ident::new(Symbol::intern(&res_str),\n+                              DUMMY_SP.apply_mark(cx.current_expansion.mark));\n     struct Result {\n         ident: ast::Ident,\n         span: Span,"}, {"sha": "25a2969448835dca4ba648e9be841b01dd61ee0f", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -18,10 +18,9 @@ use syntax::ast;\n use syntax::ast::{Expr, GenericParam, Generics, Ident, SelfKind};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::respan;\n+use syntax::codemap::{respan, DUMMY_SP};\n use syntax::ptr::P;\n use syntax_pos::Span;\n-use syntax_pos::hygiene::SyntaxContext;\n use syntax_pos::symbol::keywords;\n \n /// The types of pointers\n@@ -93,8 +92,8 @@ impl<'a> Path<'a> {\n             PathKind::Global => cx.path_all(span, true, idents, lt, tys, Vec::new()),\n             PathKind::Local => cx.path_all(span, false, idents, lt, tys, Vec::new()),\n             PathKind::Std => {\n-                let def_site = SyntaxContext::empty().apply_mark(cx.current_expansion.mark);\n-                idents.insert(0, Ident { ctxt: def_site, ..keywords::DollarCrate.ident() });\n+                let def_site = DUMMY_SP.apply_mark(cx.current_expansion.mark);\n+                idents.insert(0, Ident::new(keywords::DollarCrate.name(), def_site));\n                 cx.path_all(span, false, idents, lt, tys, Vec::new())\n             }\n         }"}, {"sha": "c180563450f83ebf712ea05dda99a1aeba64d2ff", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -123,7 +123,7 @@ pub struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n-    gensym_to_ctxt: HashMap<Symbol, SyntaxContext>,\n+    gensym_to_ctxt: HashMap<Symbol, Span>,\n }\n \n impl HygieneData {\n@@ -461,15 +461,15 @@ impl Symbol {\n     pub fn from_ident(ident: Ident) -> Symbol {\n         HygieneData::with(|data| {\n             let gensym = ident.name.gensymed();\n-            data.gensym_to_ctxt.insert(gensym, ident.ctxt);\n+            data.gensym_to_ctxt.insert(gensym, ident.span);\n             gensym\n         })\n     }\n \n     pub fn to_ident(self) -> Ident {\n         HygieneData::with(|data| {\n             match data.gensym_to_ctxt.get(&self) {\n-                Some(&ctxt) => Ident { name: self.interned(), ctxt: ctxt },\n+                Some(&span) => Ident::new(self.interned(), span),\n                 None => Ident::with_empty_ctxt(self),\n             }\n         })"}, {"sha": "8b2ebfef2504e13aa4b6ddeb7341eeaa45ac5890", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -50,7 +50,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n extern crate unicode_width;\n \n pub mod hygiene;\n-pub use hygiene::{SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan, CompilerDesugaringKind};\n+pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan, CompilerDesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -422,6 +422,52 @@ impl Span {\n             if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n         )\n     }\n+\n+    #[inline]\n+    pub fn apply_mark(self, mark: Mark) -> Span {\n+        let span = self.data();\n+        span.with_ctxt(span.ctxt.apply_mark(mark))\n+    }\n+\n+    #[inline]\n+    pub fn remove_mark(&mut self) -> Mark {\n+        let mut span = self.data();\n+        let mark = span.ctxt.remove_mark();\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn adjust(&mut self, expansion: Mark) -> Option<Mark> {\n+        let mut span = self.data();\n+        let mark = span.ctxt.adjust(expansion);\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn glob_adjust(&mut self, expansion: Mark, glob_ctxt: SyntaxContext)\n+                       -> Option<Option<Mark>> {\n+        let mut span = self.data();\n+        let mark = span.ctxt.glob_adjust(expansion, glob_ctxt);\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn reverse_glob_adjust(&mut self, expansion: Mark, glob_ctxt: SyntaxContext)\n+                               -> Option<Option<Mark>> {\n+        let mut span = self.data();\n+        let mark = span.ctxt.reverse_glob_adjust(expansion, glob_ctxt);\n+        *self = Span::new(span.lo, span.hi, span.ctxt);\n+        mark\n+    }\n+\n+    #[inline]\n+    pub fn modern(self) -> Span {\n+        let span = self.data();\n+        span.with_ctxt(span.ctxt.modern())\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "661a28d837535818929dfab88a0c7ae76aa30815", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baae274fb72c91dbee441e20622cffdc218bdcb5/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=baae274fb72c91dbee441e20622cffdc218bdcb5", "patch": "@@ -13,21 +13,27 @@\n //! type, and vice versa.\n \n use hygiene::SyntaxContext;\n-use GLOBALS;\n+use {Span, DUMMY_SP, GLOBALS};\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::collections::HashMap;\n use std::fmt;\n+use std::hash::{Hash, Hasher};\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Eq)]\n pub struct Ident {\n     pub name: Symbol,\n-    pub ctxt: SyntaxContext,\n+    pub span: Span,\n }\n \n impl Ident {\n+    #[inline]\n+    pub const fn new(name: Symbol, span: Span) -> Ident {\n+        Ident { name, span }\n+    }\n+    #[inline]\n     pub const fn with_empty_ctxt(name: Symbol) -> Ident {\n-        Ident { name: name, ctxt: SyntaxContext::empty() }\n+        Ident::new(name, DUMMY_SP)\n     }\n \n     /// Maps a string to an identifier with an empty syntax context.\n@@ -36,17 +42,30 @@ impl Ident {\n     }\n \n     pub fn without_first_quote(&self) -> Ident {\n-        Ident { name: Symbol::from(self.name.as_str().trim_left_matches('\\'')), ctxt: self.ctxt }\n+        Ident::new(Symbol::from(self.name.as_str().trim_left_matches('\\'')), self.span)\n     }\n \n     pub fn modern(self) -> Ident {\n-        Ident { name: self.name, ctxt: self.ctxt.modern() }\n+        Ident::new(self.name, self.span.modern())\n+    }\n+}\n+\n+impl PartialEq for Ident {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.name == rhs.name && self.span.ctxt() == rhs.span.ctxt()\n+    }\n+}\n+\n+impl Hash for Ident {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.name.hash(state);\n+        self.span.ctxt().hash(state);\n     }\n }\n \n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}{:?}\", self.name, self.ctxt)\n+        write!(f, \"{}{:?}\", self.name, self.span.ctxt())\n     }\n }\n \n@@ -58,7 +77,7 @@ impl fmt::Display for Ident {\n \n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        if self.ctxt.modern() == SyntaxContext::empty() {\n+        if self.span.ctxt().modern() == SyntaxContext::empty() {\n             s.emit_str(&self.name.as_str())\n         } else { // FIXME(jseyfried) intercrate hygiene\n             let mut string = \"#\".to_owned();"}]}