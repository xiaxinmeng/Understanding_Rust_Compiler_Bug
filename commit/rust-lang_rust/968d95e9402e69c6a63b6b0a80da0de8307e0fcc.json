{"sha": "968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2OGQ5NWU5NDAyZTY5YzZhNjNiNmIwYTgwZGEwZGU4MzA3ZTBmY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-08T17:36:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-08T17:36:09Z"}, "message": "Auto merge of #53903 - GabrielMajeri:opt-miri-array-slice, r=oli-obk\n\nOptimize miri checking of integer array/slices\n\nThis pull request implements the optimization described in #53845 (the  `E-easy` part of that issue, not the refactoring). Instead of checking every element of an integral array, we can check the whole memory range at once.\n\nr? @RalfJung", "tree": {"sha": "e3721941e00bbda03a71f45205cf74438a097543", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3721941e00bbda03a71f45205cf74438a097543"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "html_url": "https://github.com/rust-lang/rust/commit/968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b24330fb7d9e89d63eb03d81fe577172aad49525", "url": "https://api.github.com/repos/rust-lang/rust/commits/b24330fb7d9e89d63eb03d81fe577172aad49525", "html_url": "https://github.com/rust-lang/rust/commit/b24330fb7d9e89d63eb03d81fe577172aad49525"}, {"sha": "82cde902c544c4b13a2d0b4aebd406241cca19d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/82cde902c544c4b13a2d0b4aebd406241cca19d8", "html_url": "https://github.com/rust-lang/rust/commit/82cde902c544c4b13a2d0b4aebd406241cca19d8"}], "stats": {"total": 112, "additions": 81, "deletions": 31}, "files": [{"sha": "16175e159dd23e81baa6ca51e5eea10f8ea6065f", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "patch": "@@ -521,7 +521,6 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             ReadBytesAsPointer |\n             ReadForeignStatic |\n             InvalidPointerMath |\n-            ReadUndefBytes |\n             DeadLocal |\n             StackFrameLimitReached |\n             OutOfTls |\n@@ -548,6 +547,7 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             GeneratorResumedAfterReturn |\n             GeneratorResumedAfterPanic |\n             InfiniteLoop => {}\n+            ReadUndefBytes(offset) => offset.hash_stable(hcx, hasher),\n             InvalidDiscriminant(val) => val.hash_stable(hcx, hasher),\n             Panic { ref msg, ref file, line, col } => {\n                 msg.hash_stable(hcx, hasher);"}, {"sha": "cccde692bf7895ad13173ef323fa851723176e3a", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "patch": "@@ -205,7 +205,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     ReadBytesAsPointer,\n     ReadForeignStatic,\n     InvalidPointerMath,\n-    ReadUndefBytes,\n+    ReadUndefBytes(Size),\n     DeadLocal,\n     InvalidBoolOp(mir::BinOp),\n     Unimplemented(String),\n@@ -331,7 +331,7 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n             InvalidPointerMath =>\n                 \"attempted to do invalid arithmetic on pointers that would leak base addresses, \\\n                 e.g. comparing pointers into different allocations\",\n-            ReadUndefBytes =>\n+            ReadUndefBytes(_) =>\n                 \"attempted to read undefined bytes\",\n             DeadLocal =>\n                 \"tried to access a dead local variable\","}, {"sha": "5fa47ef42ec3507287cfc4a3ff85ed593d2fac75", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "patch": "@@ -645,16 +645,23 @@ impl UndefMask {\n     }\n \n     /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n-    pub fn is_range_defined(&self, start: Size, end: Size) -> bool {\n+    ///\n+    /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n+    /// at which the first undefined access begins.\n+    #[inline]\n+    pub fn is_range_defined(&self, start: Size, end: Size) -> Result<(), Size> {\n         if end > self.len {\n-            return false;\n+            return Err(self.len);\n         }\n-        for i in start.bytes()..end.bytes() {\n-            if !self.get(Size::from_bytes(i)) {\n-                return false;\n-            }\n+\n+        let idx = (start.bytes()..end.bytes())\n+            .map(|i| Size::from_bytes(i))\n+            .find(|&i| !self.get(i));\n+\n+        match idx {\n+            Some(idx) => Err(idx),\n+            None => Ok(())\n         }\n-        true\n     }\n \n     pub fn set_range(&mut self, start: Size, end: Size, new_state: bool) {"}, {"sha": "be7d9b06fb4532cad7d1c2e7009f9b3a9245dfde", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "patch": "@@ -359,7 +359,7 @@ impl<'tcx> ScalarMaybeUndef {\n     pub fn not_undef(self) -> EvalResult<'static, Scalar> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => err!(ReadUndefBytes),\n+            ScalarMaybeUndef::Undef => err!(ReadUndefBytes(Size::from_bytes(0))),\n         }\n     }\n "}, {"sha": "955f2740b929451a1ef68bbee2fc30777e3a37c0", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "patch": "@@ -511,7 +511,7 @@ impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n             ReadBytesAsPointer => ReadBytesAsPointer,\n             ReadForeignStatic => ReadForeignStatic,\n             InvalidPointerMath => InvalidPointerMath,\n-            ReadUndefBytes => ReadUndefBytes,\n+            ReadUndefBytes(offset) => ReadUndefBytes(offset),\n             DeadLocal => DeadLocal,\n             InvalidBoolOp(bop) => InvalidBoolOp(bop),\n             Unimplemented(ref s) => Unimplemented(s.clone()),"}, {"sha": "3a8723ec2fd9b5ea57dd45fbc5e8731a755ff5b0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "patch": "@@ -400,7 +400,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                     }\n                     relocations.push((i, target_id));\n                 }\n-                if alloc.undef_mask.is_range_defined(i, i + Size::from_bytes(1)) {\n+                if alloc.undef_mask.is_range_defined(i, i + Size::from_bytes(1)).is_ok() {\n                     // this `as usize` is fine, since `i` came from a `usize`\n                     write!(msg, \"{:02x} \", alloc.bytes[i.bytes() as usize]).unwrap();\n                 } else {\n@@ -736,7 +736,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         )?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n-        if !self.is_defined(ptr, size)? {\n+        if self.check_defined(ptr, size).is_err() {\n             // this inflates undefined bytes to the entire scalar, even if only a few\n             // bytes are undefined\n             return Ok(ScalarMaybeUndef::Undef);\n@@ -938,21 +938,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn is_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx, bool> {\n+    /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n+    /// error which will report the first byte which is undefined.\n+    #[inline]\n+    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n-        Ok(alloc.undef_mask.is_range_defined(\n+        alloc.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        ))\n-    }\n-\n-    #[inline]\n-    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n-        if self.is_defined(ptr, size)? {\n-            Ok(())\n-        } else {\n-            err!(ReadUndefBytes)\n-        }\n+        ).or_else(|idx| err!(ReadUndefBytes(idx)))\n     }\n \n     pub fn mark_definedness("}, {"sha": "8292869ca588e8e01ba21c533e6e7b59a0986f06", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "patch": "@@ -290,7 +290,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             Ok(val) => val,\n                             Err(err) => match err.kind {\n                                 EvalErrorKind::PointerOutOfBounds { .. } |\n-                                EvalErrorKind::ReadUndefBytes =>\n+                                EvalErrorKind::ReadUndefBytes(_) =>\n                                     return validation_failure!(\n                                         \"uninitialized or out-of-bounds memory\", path\n                                     ),\n@@ -333,16 +333,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // The fields don't need to correspond to any bit pattern of the union's fields.\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n             },\n-            layout::FieldPlacement::Array { .. } if !dest.layout.is_zst() => {\n+            layout::FieldPlacement::Array { stride, .. } if !dest.layout.is_zst() => {\n                 let dest = dest.to_mem_place(); // non-ZST array/slice/str cannot be immediate\n-                // Special handling for strings to verify UTF-8\n                 match dest.layout.ty.sty {\n+                    // Special handling for strings to verify UTF-8\n                     ty::Str => {\n                         match self.read_str(dest) {\n                             Ok(_) => {},\n                             Err(err) => match err.kind {\n                                 EvalErrorKind::PointerOutOfBounds { .. } |\n-                                EvalErrorKind::ReadUndefBytes =>\n+                                EvalErrorKind::ReadUndefBytes(_) =>\n                                     // The error here looks slightly different than it does\n                                     // for slices, because we do not report the index into the\n                                     // str at which we are OOB.\n@@ -356,6 +356,55 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             }\n                         }\n                     }\n+                    // Special handling for arrays/slices of builtin integer types\n+                    ty::Array(tys, ..) | ty::Slice(tys) if {\n+                        // This optimization applies only for integer types\n+                        match tys.sty {\n+                            ty::Int(..) | ty::Uint(..) => true,\n+                            _ => false,\n+                        }\n+                    } => {\n+                        // This is the length of the array/slice.\n+                        let len = dest.len(self)?;\n+                        // Since primitive types are naturally aligned and tightly packed in arrays,\n+                        // we can use the stride to get the size of the integral type.\n+                        let ty_size = stride.bytes();\n+                        // This is the size in bytes of the whole array.\n+                        let size = Size::from_bytes(ty_size * len);\n+\n+                        match self.memory.read_bytes(dest.ptr, size) {\n+                            // In the happy case, we needn't check anything else.\n+                            Ok(_) => {},\n+                            // Some error happened, try to provide a more detailed description.\n+                            Err(err) => {\n+                                // For some errors we might be able to provide extra information\n+                                match err.kind {\n+                                    EvalErrorKind::ReadUndefBytes(offset) => {\n+                                        // Some byte was undefined, determine which\n+                                        // element that byte belongs to so we can\n+                                        // provide an index.\n+                                        let i = (offset.bytes() / ty_size) as usize;\n+                                        path.push(PathElem::ArrayElem(i));\n+\n+                                        return validation_failure!(\n+                                            \"undefined bytes\", path\n+                                        )\n+                                    },\n+                                    EvalErrorKind::PointerOutOfBounds { allocation_size, .. } => {\n+                                        // If the array access is out-of-bounds, the first\n+                                        // undefined access is the after the end of the array.\n+                                        let i = (allocation_size.bytes() * ty_size) as usize;\n+                                        path.push(PathElem::ArrayElem(i));\n+                                    },\n+                                    _ => (),\n+                                }\n+\n+                                return validation_failure!(\n+                                    \"uninitialized or out-of-bounds memory\", path\n+                                )\n+                            }\n+                        }\n+                    },\n                     _ => {\n                         // This handles the unsized case correctly as well, as well as\n                         // SIMD an all sorts of other array-like types."}, {"sha": "aaf4cf69b3a4ad9b7e9f5a8128664ab65a52be40", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/968d95e9402e69c6a63b6b0a80da0de8307e0fcc/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=968d95e9402e69c6a63b6b0a80da0de8307e0fcc", "patch": "@@ -180,7 +180,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     | InvalidMemoryLockRelease { .. }\n                     | DeallocatedLockedMemory { .. }\n                     | InvalidPointerMath\n-                    | ReadUndefBytes\n+                    | ReadUndefBytes(_)\n                     | DeadLocal\n                     | InvalidBoolOp(_)\n                     | DerefFunctionPointer"}]}