{"sha": "001e9f349087124165ed6deea6a87e0b158bba21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMWU5ZjM0OTA4NzEyNDE2NWVkNmRlZWE2YTg3ZTBiMTU4YmJhMjE=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-05T01:41:43Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:23:57Z"}, "message": "Move code into Step trait implementations.\n\nNo changes are introduced to code body. This commit will not build; it\nis done to permit a better diff in later commits.", "tree": {"sha": "5251aa0a732f529b15062b3657f7c254bd592c68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5251aa0a732f529b15062b3657f7c254bd592c68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/001e9f349087124165ed6deea6a87e0b158bba21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/001e9f349087124165ed6deea6a87e0b158bba21", "html_url": "https://github.com/rust-lang/rust/commit/001e9f349087124165ed6deea6a87e0b158bba21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/001e9f349087124165ed6deea6a87e0b158bba21/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "html_url": "https://github.com/rust-lang/rust/commit/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9"}], "stats": {"total": 5108, "additions": 2861, "deletions": 2247}, "files": [{"sha": "0278b8d5dbf2b3bc9de4c576e94af3ae7385acfe", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 585, "deletions": 420, "changes": 1005, "blob_url": "https://github.com/rust-lang/rust/blob/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=001e9f349087124165ed6deea6a87e0b158bba21", "patch": "@@ -25,9 +25,14 @@ use std::io::Read;\n \n use build_helper::{self, output};\n \n-use {Build, Compiler, Mode};\n+use {Build, Mode};\n use dist;\n-use util::{self, dylib_path, dylib_path_var, exe};\n+use util::{self, dylib_path, dylib_path_var};\n+\n+use compile;\n+use native;\n+use builder::{Kind, Builder, Compiler, Step};\n+use tool::Tool;\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n@@ -87,83 +92,151 @@ fn try_run_quiet(build: &Build, cmd: &mut Command) {\n //      .default(build.config.docs)\n //      .host(true)\n //      .run(move |s| check::linkcheck(build, s.target));\n-/// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n-///\n-/// This tool in `src/tools` will verify the validity of all our links in the\n-/// documentation to ensure we don't have a bunch of dead ones.\n-pub fn linkcheck(build: &Build, host: &str) {\n-    println!(\"Linkcheck ({})\", host);\n-    let compiler = Compiler::new(0, host);\n \n-    let _time = util::timeit();\n-    try_run(build, build.tool_cmd(&compiler, \"linkchecker\")\n-                        .arg(build.out.join(host).join(\"doc\")));\n+#[derive(Serialize)]\n+pub struct Linkcheck<'a> {\n+    host: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Linkcheck<'a> {\n+    type Output = ();\n+\n+    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will verify the validity of all our links in the\n+    /// documentation to ensure we don't have a bunch of dead ones.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        println!(\"Linkcheck ({})\", host);\n+        let compiler = Compiler::new(0, host);\n+\n+        let _time = util::timeit();\n+        try_run(build, build.tool_cmd(&compiler, \"linkchecker\")\n+                            .arg(build.out.join(host).join(\"doc\")));\n+    }\n }\n \n // rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n //      .dep(|s| s.name(\"tool-cargotest\").stage(0))\n //      .dep(|s| s.name(\"librustc\"))\n //      .host(true)\n //      .run(move |s| check::cargotest(build, s.stage, s.target));\n-/// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n-///\n-/// This tool in `src/tools` will check out a few Rust projects and run `cargo\n-/// test` to ensure that we don't regress the test suites there.\n-pub fn cargotest(build: &Build, stage: u32, host: &str) {\n-    let compiler = Compiler::new(stage, host);\n \n-    // Note that this is a short, cryptic, and not scoped directory name. This\n-    // is currently to minimize the length of path on Windows where we otherwise\n-    // quickly run into path name limit constraints.\n-    let out_dir = build.out.join(\"ct\");\n-    t!(fs::create_dir_all(&out_dir));\n+#[derive(Serialize)]\n+pub struct Cargotest<'a> {\n+    stage: u32,\n+    host: &'a str,\n+}\n \n-    let _time = util::timeit();\n-    let mut cmd = Command::new(build.tool(&Compiler::new(0, host), \"cargotest\"));\n-    build.prepare_tool_cmd(&compiler, &mut cmd);\n-    try_run(build, cmd.arg(&build.initial_cargo)\n-                      .arg(&out_dir)\n-                      .env(\"RUSTC\", build.compiler_path(&compiler))\n-                      .env(\"RUSTDOC\", build.rustdoc(&compiler)));\n+impl<'a> Step<'a> for Cargotest<'a> {\n+    type Output = ();\n+\n+    /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n+    /// test` to ensure that we don't regress the test suites there.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = Compiler::new(stage, host);\n+\n+        // Note that this is a short, cryptic, and not scoped directory name. This\n+        // is currently to minimize the length of path on Windows where we otherwise\n+        // quickly run into path name limit constraints.\n+        let out_dir = build.out.join(\"ct\");\n+        t!(fs::create_dir_all(&out_dir));\n+\n+        let _time = util::timeit();\n+        let mut cmd = Command::new(build.tool(&Compiler::new(0, host), \"cargotest\"));\n+        build.prepare_tool_cmd(&compiler, &mut cmd);\n+        try_run(build, cmd.arg(&build.initial_cargo)\n+                          .arg(&out_dir)\n+                          .env(\"RUSTC\", build.compiler_path(&compiler))\n+                          .env(\"RUSTDOC\", build.rustdoc(&compiler)));\n+    }\n }\n \n //rules.test(\"check-cargo\", \"cargo\")\n //     .dep(|s| s.name(\"tool-cargo\"))\n //     .host(true)\n //     .run(move |s| check::cargo(build, s.stage, s.target));\n-/// Runs `cargo test` for `cargo` packaged with Rust.\n-pub fn cargo(build: &Build, stage: u32, host: &str) {\n-    let compiler = &Compiler::new(stage, host);\n \n-    let mut cargo = build.cargo(compiler, Mode::Tool, host, \"test\");\n-    cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n-    if !build.fail_fast {\n-        cargo.arg(\"--no-fail-fast\");\n-    }\n+#[derive(Serialize)]\n+pub struct Cargo<'a> {\n+    stage: u32,\n+    host: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Cargo<'a> {\n+    type Output = ();\n+\n+    /// Runs `cargo test` for `cargo` packaged with Rust.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let ref compiler = Compiler::new(stage, host);\n+\n+        // Configure PATH to find the right rustc. NB. we have to use PATH\n+        // and not RUSTC because the Cargo test suite has tests that will\n+        // fail if rustc is not spelled `rustc`.\n+        let path = build.sysroot(compiler).join(\"bin\");\n+        let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+        let newpath = env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\");\n+\n+        let mut cargo = build.cargo(compiler, Mode::Tool, host, \"test\");\n+        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n+        if !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n \n-    // Don't build tests dynamically, just a pain to work with\n-    cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+        let compiler = &Compiler::new(stage, host);\n \n-    // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n-    // available.\n-    cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n+        let mut cargo = build.cargo(compiler, Mode::Tool, host, \"test\");\n+        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n+        if !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        // Don't build tests dynamically, just a pain to work with\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n+        // available.\n+        cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n \n-    try_run(build, cargo.env(\"PATH\", &path_for_cargo(build, compiler)));\n+        try_run(build, cargo.env(\"PATH\", &path_for_cargo(build, compiler)));\n+    }\n }\n \n-/// Runs `cargo test` for the rls.\n-pub fn rls(build: &Build, stage: u32, host: &str) {\n-    let compiler = &Compiler::new(stage, host);\n+#[derive(Serialize)]\n+pub struct Rls<'a> {\n+    stage: u32,\n+    host: &'a str,\n+}\n \n-    let mut cargo = build.cargo(compiler, Mode::Tool, host, \"test\");\n-    cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rls/Cargo.toml\"));\n+impl<'a> Step<'a> for Rls<'a> {\n+    type Output = ();\n \n-    // Don't build tests dynamically, just a pain to work with\n-    cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+    /// Runs `cargo test` for the rls.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = &Compiler::new(stage, host);\n \n-    build.add_rustc_lib_path(compiler, &mut cargo);\n+        let mut cargo = build.cargo(compiler, Mode::Tool, host, \"test\");\n+        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/rls/Cargo.toml\"));\n \n-    try_run(build, &mut cargo);\n+        // Don't build tests dynamically, just a pain to work with\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        build.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        try_run(build, &mut cargo);\n+    }\n }\n \n fn path_for_cargo(build: &Build, compiler: &Compiler) -> OsString {\n@@ -173,6 +246,13 @@ fn path_for_cargo(build: &Build, compiler: &Compiler) -> OsString {\n     let path = build.sysroot(compiler).join(\"bin\");\n     let old_path = env::var_os(\"PATH\").unwrap_or_default();\n     env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n+||||||| parent of adabe3889e... Move code into Step trait implementations.\n+    try_run(build, cargo.env(\"PATH\", newpath));\n+=======\n+        try_run(build, cargo.env(\"PATH\", newpath));\n+        let host = self.host;\n+    }\n+>>>>>>> adabe3889e... Move code into Step trait implementations.\n }\n \n //rules.test(\"check-tidy\", \"src/tools/tidy\")\n@@ -181,24 +261,37 @@ fn path_for_cargo(build: &Build, compiler: &Compiler) -> OsString {\n //     .host(true)\n //     .only_build(true)\n //     .run(move |s| check::tidy(build, s.target));\n-/// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n-///\n-/// This tool in `src/tools` checks up on various bits and pieces of style and\n-/// otherwise just implements a few lint-like checks that are specific to the\n-/// compiler itself.\n-pub fn tidy(build: &Build, host: &str) {\n-    let _folder = build.fold_output(|| \"tidy\");\n-    println!(\"tidy check ({})\", host);\n-    let compiler = Compiler::new(0, host);\n-    let mut cmd = build.tool_cmd(&compiler, \"tidy\");\n-    cmd.arg(build.src.join(\"src\"));\n-    if !build.config.vendor {\n-        cmd.arg(\"--no-vendor\");\n-    }\n-    if build.config.quiet_tests {\n-        cmd.arg(\"--quiet\");\n+\n+#[derive(Serialize)]\n+pub struct Tidy<'a> {\n+    host: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Tidy<'a> {\n+    type Output = ();\n+\n+    /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` checks up on various bits and pieces of style and\n+    /// otherwise just implements a few lint-like checks that are specific to the\n+    /// compiler itself.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        let _folder = build.fold_output(|| \"tidy\");\n+        println!(\"tidy check ({})\", host);\n+        let compiler = Compiler::new(0, host);\n+        let mut cmd = build.tool_cmd(&compiler, \"tidy\");\n+        cmd.arg(build.src.join(\"src\"));\n+        if !build.config.vendor {\n+            cmd.arg(\"--no-vendor\");\n+        }\n+        if build.config.quiet_tests {\n+            cmd.arg(\"--quiet\");\n+        }\n+        try_run(build, &mut cmd);\n     }\n-    try_run(build, &mut cmd);\n }\n \n fn testdir(build: &Build, host: &str) -> PathBuf {\n@@ -303,158 +396,171 @@ fn testdir(build: &Build, host: &str) -> PathBuf {\n //              \"pretty\", \"run-fail-fulldeps\");\n //    }\n \n-/// Executes the `compiletest` tool to run a suite of tests.\n-///\n-/// Compiles all tests with `compiler` for `target` with the specified\n-/// compiletest `mode` and `suite` arguments. For example `mode` can be\n-/// \"run-pass\" or `suite` can be something like `debuginfo`.\n-pub fn compiletest(build: &Build,\n-                   compiler: &Compiler,\n-                   target: &str,\n-                   mode: &str,\n-                   suite: &str) {\n-    let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n-    println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-             suite, mode, compiler.host, target);\n-    let mut cmd = Command::new(build.tool(&Compiler::new(0, compiler.host),\n-                                          \"compiletest\"));\n-    build.prepare_tool_cmd(compiler, &mut cmd);\n-\n-    // compiletest currently has... a lot of arguments, so let's just pass all\n-    // of them!\n-\n-    cmd.arg(\"--compile-lib-path\").arg(build.rustc_libdir(compiler));\n-    cmd.arg(\"--run-lib-path\").arg(build.sysroot_libdir(compiler, target));\n-    cmd.arg(\"--rustc-path\").arg(build.compiler_path(compiler));\n-    cmd.arg(\"--rustdoc-path\").arg(build.rustdoc(compiler));\n-    cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n-    cmd.arg(\"--build-base\").arg(testdir(build, compiler.host).join(suite));\n-    cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n-    cmd.arg(\"--mode\").arg(mode);\n-    cmd.arg(\"--target\").arg(target);\n-    cmd.arg(\"--host\").arg(compiler.host);\n-    cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.build));\n-\n-    if let Some(ref nodejs) = build.config.nodejs {\n-        cmd.arg(\"--nodejs\").arg(nodejs);\n-    }\n-\n-    let mut flags = vec![\"-Crpath\".to_string()];\n-    if build.config.rust_optimize_tests {\n-        flags.push(\"-O\".to_string());\n-    }\n-    if build.config.rust_debuginfo_tests {\n-        flags.push(\"-g\".to_string());\n-    }\n-\n-    let mut hostflags = build.rustc_flags(&compiler.host);\n-    hostflags.extend(flags.clone());\n-    cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n+#[derive(Serialize)]\n+pub struct Compiletest<'a> {\n+    compiler: Compiler<'a>,\n+    target: &'a str,\n+    mode: &'a str,\n+    suite: &'a str,\n+}\n \n-    let mut targetflags = build.rustc_flags(&target);\n-    targetflags.extend(flags);\n-    targetflags.push(format!(\"-Lnative={}\",\n-                             build.test_helpers_out(target).display()));\n-    cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n+impl<'a> Step<'a> for Compiletest<'a> {\n+    type Output = ();\n+\n+    /// Executes the `compiletest` tool to run a suite of tests.\n+    ///\n+    /// Compiles all tests with `compiler` for `target` with the specified\n+    /// compiletest `mode` and `suite` arguments. For example `mode` can be\n+    /// \"run-pass\" or `suite` can be something like `debuginfo`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let mode = self.mode;\n+        let suite = self.suite;\n+        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n+        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+                 suite, mode, compiler.host, target);\n+        let mut cmd = Command::new(build.tool(&Compiler::new(0, compiler.host),\n+                                              \"compiletest\"));\n+        build.prepare_tool_cmd(compiler, &mut cmd);\n+\n+        // compiletest currently has... a lot of arguments, so let's just pass all\n+        // of them!\n+\n+        cmd.arg(\"--compile-lib-path\").arg(build.rustc_libdir(compiler));\n+        cmd.arg(\"--run-lib-path\").arg(build.sysroot_libdir(compiler, target));\n+        cmd.arg(\"--rustc-path\").arg(build.compiler_path(compiler));\n+        cmd.arg(\"--rustdoc-path\").arg(build.rustdoc(compiler));\n+        cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n+        cmd.arg(\"--build-base\").arg(testdir(build, compiler.host).join(suite));\n+        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n+        cmd.arg(\"--mode\").arg(mode);\n+        cmd.arg(\"--target\").arg(target);\n+        cmd.arg(\"--host\").arg(compiler.host);\n+        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.build));\n+\n+        if let Some(ref nodejs) = build.config.nodejs {\n+            cmd.arg(\"--nodejs\").arg(nodejs);\n+        }\n \n-    cmd.arg(\"--docck-python\").arg(build.python());\n+        let mut flags = vec![\"-Crpath\".to_string()];\n+        if build.config.rust_optimize_tests {\n+            flags.push(\"-O\".to_string());\n+        }\n+        if build.config.rust_debuginfo_tests {\n+            flags.push(\"-g\".to_string());\n+        }\n \n-    if build.build.ends_with(\"apple-darwin\") {\n-        // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n-        // LLDB plugin's compiled module which only works with the system python\n-        // (namely not Homebrew-installed python)\n-        cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n-    } else {\n-        cmd.arg(\"--lldb-python\").arg(build.python());\n-    }\n+        let mut hostflags = build.rustc_flags(&compiler.host);\n+        hostflags.extend(flags.clone());\n+        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n+\n+        let mut targetflags = build.rustc_flags(&target);\n+        targetflags.extend(flags);\n+        targetflags.push(format!(\"-Lnative={}\",\n+                                 build.test_helpers_out(target).display()));\n+        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n+\n+        cmd.arg(\"--docck-python\").arg(build.python());\n+\n+        if build.build.ends_with(\"apple-darwin\") {\n+            // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n+            // LLDB plugin's compiled module which only works with the system python\n+            // (namely not Homebrew-installed python)\n+            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n+        } else {\n+            cmd.arg(\"--lldb-python\").arg(build.python());\n+        }\n \n-    if let Some(ref gdb) = build.config.gdb {\n-        cmd.arg(\"--gdb\").arg(gdb);\n-    }\n-    if let Some(ref vers) = build.lldb_version {\n-        cmd.arg(\"--lldb-version\").arg(vers);\n-    }\n-    if let Some(ref dir) = build.lldb_python_dir {\n-        cmd.arg(\"--lldb-python-dir\").arg(dir);\n-    }\n-    let llvm_config = build.llvm_config(target);\n-    let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n-    cmd.arg(\"--llvm-version\").arg(llvm_version);\n-    if !build.is_rust_llvm(target) {\n-        cmd.arg(\"--system-llvm\");\n-    }\n+        if let Some(ref gdb) = build.config.gdb {\n+            cmd.arg(\"--gdb\").arg(gdb);\n+        }\n+        if let Some(ref vers) = build.lldb_version {\n+            cmd.arg(\"--lldb-version\").arg(vers);\n+        }\n+        if let Some(ref dir) = build.lldb_python_dir {\n+            cmd.arg(\"--lldb-python-dir\").arg(dir);\n+        }\n+        let llvm_config = build.llvm_config(target);\n+        let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+        cmd.arg(\"--llvm-version\").arg(llvm_version);\n+        if !build.is_rust_llvm(target) {\n+            cmd.arg(\"--system-llvm\");\n+        }\n \n-    cmd.args(&build.flags.cmd.test_args());\n+        cmd.args(&build.flags.cmd.test_args());\n \n-    if build.is_verbose() {\n-        cmd.arg(\"--verbose\");\n-    }\n+        if build.is_verbose() {\n+            cmd.arg(\"--verbose\");\n+        }\n \n-    if build.config.quiet_tests {\n-        cmd.arg(\"--quiet\");\n-    }\n+        if build.config.quiet_tests {\n+            cmd.arg(\"--quiet\");\n+        }\n \n-    // Only pass correct values for these flags for the `run-make` suite as it\n-    // requires that a C++ compiler was configured which isn't always the case.\n-    if suite == \"run-make\" {\n-        let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n-        let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n-        cmd.arg(\"--cc\").arg(build.cc(target))\n-           .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n-           .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n-           .arg(\"--llvm-components\").arg(llvm_components.trim())\n-           .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n-    } else {\n-        cmd.arg(\"--cc\").arg(\"\")\n-           .arg(\"--cxx\").arg(\"\")\n-           .arg(\"--cflags\").arg(\"\")\n-           .arg(\"--llvm-components\").arg(\"\")\n-           .arg(\"--llvm-cxxflags\").arg(\"\");\n-    }\n+        // Only pass correct values for these flags for the `run-make` suite as it\n+        // requires that a C++ compiler was configured which isn't always the case.\n+        if suite == \"run-make\" {\n+            let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n+            let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n+            cmd.arg(\"--cc\").arg(build.cc(target))\n+               .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n+               .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n+               .arg(\"--llvm-components\").arg(llvm_components.trim())\n+               .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+        } else {\n+            cmd.arg(\"--cc\").arg(\"\")\n+               .arg(\"--cxx\").arg(\"\")\n+               .arg(\"--cflags\").arg(\"\")\n+               .arg(\"--llvm-components\").arg(\"\")\n+               .arg(\"--llvm-cxxflags\").arg(\"\");\n+        }\n \n-    if build.remote_tested(target) {\n-        cmd.arg(\"--remote-test-client\")\n-           .arg(build.tool(&Compiler::new(0, &build.build),\n-                           \"remote-test-client\"));\n-    }\n+        if build.remote_tested(target) {\n+            cmd.arg(\"--remote-test-client\")\n+               .arg(build.tool(&Compiler::new(0, &build.build),\n+                               \"remote-test-client\"));\n+        }\n \n-    // Running a C compiler on MSVC requires a few env vars to be set, to be\n-    // sure to set them here.\n-    //\n-    // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n-    // rather than stomp over it.\n-    if target.contains(\"msvc\") {\n-        for &(ref k, ref v) in build.cc[target].0.env() {\n-            if k != \"PATH\" {\n-                cmd.env(k, v);\n+        // Running a C compiler on MSVC requires a few env vars to be set, to be\n+        // sure to set them here.\n+        //\n+        // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n+        // rather than stomp over it.\n+        if target.contains(\"msvc\") {\n+            for &(ref k, ref v) in build.cc[target].0.env() {\n+                if k != \"PATH\" {\n+                    cmd.env(k, v);\n+                }\n             }\n         }\n-    }\n-    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-    build.add_rust_test_threads(&mut cmd);\n+        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        build.add_rust_test_threads(&mut cmd);\n \n-    if build.config.sanitizers {\n-        cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n-    }\n+        if build.config.sanitizers {\n+            cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n+        }\n \n-    if build.config.profiler {\n-        cmd.env(\"PROFILER_SUPPORT\", \"1\");\n-    }\n+        if build.config.profiler {\n+            cmd.env(\"PROFILER_SUPPORT\", \"1\");\n+        }\n \n-    cmd.arg(\"--adb-path\").arg(\"adb\");\n-    cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n-    if target.contains(\"android\") {\n-        // Assume that cc for this target comes from the android sysroot\n-        cmd.arg(\"--android-cross-path\")\n-           .arg(build.cc(target).parent().unwrap().parent().unwrap());\n-    } else {\n-        cmd.arg(\"--android-cross-path\").arg(\"\");\n-    }\n+        cmd.arg(\"--adb-path\").arg(\"adb\");\n+        cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n+        if target.contains(\"android\") {\n+            // Assume that cc for this target comes from the android sysroot\n+            cmd.arg(\"--android-cross-path\")\n+               .arg(build.cc(target).parent().unwrap().parent().unwrap());\n+        } else {\n+            cmd.arg(\"--android-cross-path\").arg(\"\");\n+        }\n \n-    build.ci_env.force_coloring_in_ci(&mut cmd);\n+        build.ci_env.force_coloring_in_ci(&mut cmd);\n \n-    let _time = util::timeit();\n-    try_run(build, &mut cmd);\n+        let _time = util::timeit();\n+        try_run(build, &mut cmd);\n+    }\n }\n \n // rules.test(\"check-docs\", \"src/doc\")\n@@ -500,28 +606,41 @@ pub fn docs(build: &Build, compiler: &Compiler) {\n //     .default(true)\n //     .host(true)\n //     .run(move |s| check::error_index(build, &s.compiler()));\n-/// Run the error index generator tool to execute the tests located in the error\n-/// index.\n-///\n-/// The `error_index_generator` tool lives in `src/tools` and is used to\n-/// generate a markdown file from the error indexes of the code base which is\n-/// then passed to `rustdoc --test`.\n-pub fn error_index(build: &Build, compiler: &Compiler) {\n-    let _folder = build.fold_output(|| \"test_error_index\");\n-    println!(\"Testing error-index stage{}\", compiler.stage);\n \n-    let dir = testdir(build, compiler.host);\n-    t!(fs::create_dir_all(&dir));\n-    let output = dir.join(\"error-index.md\");\n-\n-    let _time = util::timeit();\n-    build.run(build.tool_cmd(&Compiler::new(0, compiler.host),\n-                             \"error_index_generator\")\n-                   .arg(\"markdown\")\n-                   .arg(&output)\n-                   .env(\"CFG_BUILD\", &build.build));\n+#[derive(Serialize)]\n+pub struct ErrorIndex<'a> {\n+    compiler: Compiler<'a>,\n+}\n \n-    markdown_test(build, compiler, &output);\n+impl<'a> Step<'a> for ErrorIndex<'a> {\n+    type Output = ();\n+\n+    /// Run the error index generator tool to execute the tests located in the error\n+    /// index.\n+    ///\n+    /// The `error_index_generator` tool lives in `src/tools` and is used to\n+    /// generate a markdown file from the error indexes of the code base which is\n+    /// then passed to `rustdoc --test`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+\n+        let _folder = build.fold_output(|| \"test_error_index\");\n+        println!(\"Testing error-index stage{}\", compiler.stage);\n+\n+        let dir = testdir(build, compiler.host);\n+        t!(fs::create_dir_all(&dir));\n+        let output = dir.join(\"error-index.md\");\n+\n+        let _time = util::timeit();\n+        build.run(build.tool_cmd(&Compiler::new(0, compiler.host),\n+                                \"error_index_generator\")\n+                    .arg(\"markdown\")\n+                    .arg(&output)\n+                    .env(\"CFG_BUILD\", &build.build));\n+\n+        markdown_test(build, compiler, &output);\n+    }\n }\n \n fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n@@ -612,120 +731,135 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n //         .run(move |s| check::krate(build, &s.compiler(), s.target,\n //                                    Mode::Librustc, TestKind::Test, None));\n \n-/// Run all unit tests plus documentation tests for an entire crate DAG defined\n-/// by a `Cargo.toml`\n-///\n-/// This is what runs tests for crates like the standard library, compiler, etc.\n-/// It essentially is the driver for running `cargo test`.\n-///\n-/// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n-/// arguments, and those arguments are discovered from `cargo metadata`.\n-pub fn krate(build: &Build,\n-             compiler: &Compiler,\n-             target: &str,\n-             mode: Mode,\n-             test_kind: TestKind,\n-             krate: Option<&str>) {\n-    let (name, path, features, root) = match mode {\n-        Mode::Libstd => {\n-            (\"libstd\", \"src/libstd\", build.std_features(), \"std\")\n-        }\n-        Mode::Libtest => {\n-            (\"libtest\", \"src/libtest\", String::new(), \"test\")\n-        }\n-        Mode::Librustc => {\n-            (\"librustc\", \"src/rustc\", build.rustc_features(), \"rustc-main\")\n-        }\n-        _ => panic!(\"can only test libraries\"),\n-    };\n-    let _folder = build.fold_output(|| {\n-        format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n-    });\n-    println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n-             compiler.host, target);\n-\n-    // If we're not doing a full bootstrap but we're testing a stage2 version of\n-    // libstd, then what we're actually testing is the libstd produced in\n-    // stage1. Reflect that here by updating the compiler that we're working\n-    // with automatically.\n-    let compiler = if build.force_use_stage1(compiler, target) {\n-        Compiler::new(1, compiler.host)\n-    } else {\n-        compiler.clone()\n-    };\n-\n-    // Build up the base `cargo test` command.\n-    //\n-    // Pass in some standard flags then iterate over the graph we've discovered\n-    // in `cargo metadata` with the maps above and figure out what `-p`\n-    // arguments need to get passed.\n-    let mut cargo = build.cargo(&compiler, mode, target, test_kind.subcommand());\n-    cargo.arg(\"--manifest-path\")\n-         .arg(build.src.join(path).join(\"Cargo.toml\"))\n-         .arg(\"--features\").arg(features);\n-    if test_kind.subcommand() == \"test\" && !build.fail_fast {\n-        cargo.arg(\"--no-fail-fast\");\n-    }\n+#[derive(Serialize)]\n+pub struct Krate<'a> {\n+    compiler: Compiler<'a>,\n+    target: &'a str,\n+    mode: Mode,\n+    test_kind: TestKind,\n+    krate: Option<&'a str>,\n+}\n \n-    match krate {\n-        Some(krate) => {\n-            cargo.arg(\"-p\").arg(krate);\n-        }\n-        None => {\n-            let mut visited = HashSet::new();\n-            let mut next = vec![root];\n-            while let Some(name) = next.pop() {\n-                // Right now jemalloc is our only target-specific crate in the\n-                // sense that it's not present on all platforms. Custom skip it\n-                // here for now, but if we add more this probably wants to get\n-                // more generalized.\n-                //\n-                // Also skip `build_helper` as it's not compiled normally for\n-                // target during the bootstrap and it's just meant to be a\n-                // helper crate, not tested. If it leaks through then it ends up\n-                // messing with various mtime calculations and such.\n-                if !name.contains(\"jemalloc\") && name != \"build_helper\" {\n-                    cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n-                }\n-                for dep in build.crates[name].deps.iter() {\n-                    if visited.insert(dep) {\n-                        next.push(dep);\n+impl<'a> Step<'a> for Krate<'a> {\n+    type Output = ();\n+\n+    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n+    /// by a `Cargo.toml`\n+    ///\n+    /// This is what runs tests for crates like the standard library, compiler, etc.\n+    /// It essentially is the driver for running `cargo test`.\n+    ///\n+    /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n+    /// arguments, and those arguments are discovered from `cargo metadata`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let mode = self.mode;\n+        let test_kind = self.test_kind;\n+        let krate = self.krate;\n+\n+        let (name, path, features, root) = match mode {\n+            Mode::Libstd => {\n+                (\"libstd\", \"src/libstd\", build.std_features(), \"std\")\n+            }\n+            Mode::Libtest => {\n+                (\"libtest\", \"src/libtest\", String::new(), \"test\")\n+            }\n+            Mode::Librustc => {\n+                (\"librustc\", \"src/rustc\", build.rustc_features(), \"rustc-main\")\n+            }\n+            _ => panic!(\"can only test libraries\"),\n+        };\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n+        });\n+        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n+                compiler.host, target);\n+\n+        // If we're not doing a full bootstrap but we're testing a stage2 version of\n+        // libstd, then what we're actually testing is the libstd produced in\n+        // stage1. Reflect that here by updating the compiler that we're working\n+        // with automatically.\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            Compiler::new(1, compiler.host)\n+        } else {\n+            compiler.clone()\n+        };\n+\n+        // Build up the base `cargo test` command.\n+        //\n+        // Pass in some standard flags then iterate over the graph we've discovered\n+        // in `cargo metadata` with the maps above and figure out what `-p`\n+        // arguments need to get passed.\n+        let mut cargo = build.cargo(&compiler, mode, target, test_kind.subcommand());\n+        cargo.arg(\"--manifest-path\")\n+            .arg(build.src.join(path).join(\"Cargo.toml\"))\n+            .arg(\"--features\").arg(features);\n+        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        match krate {\n+            Some(krate) => {\n+                cargo.arg(\"-p\").arg(krate);\n+            }\n+            None => {\n+                let mut visited = HashSet::new();\n+                let mut next = vec![root];\n+                while let Some(name) = next.pop() {\n+                    // Right now jemalloc is our only target-specific crate in the\n+                    // sense that it's not present on all platforms. Custom skip it\n+                    // here for now, but if we add more this probably wants to get\n+                    // more generalized.\n+                    //\n+                    // Also skip `build_helper` as it's not compiled normally for\n+                    // target during the bootstrap and it's just meant to be a\n+                    // helper crate, not tested. If it leaks through then it ends up\n+                    // messing with various mtime calculations and such.\n+                    if !name.contains(\"jemalloc\") && name != \"build_helper\" {\n+                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n+                    }\n+                    for dep in build.crates[name].deps.iter() {\n+                        if visited.insert(dep) {\n+                            next.push(dep);\n+                        }\n                     }\n                 }\n             }\n         }\n-    }\n-\n-    // The tests are going to run with the *target* libraries, so we need to\n-    // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n-    //\n-    // Note that to run the compiler we need to run with the *host* libraries,\n-    // but our wrapper scripts arrange for that to be the case anyway.\n-    let mut dylib_path = dylib_path();\n-    dylib_path.insert(0, build.sysroot_libdir(&compiler, target));\n-    cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n-\n-    if target.contains(\"emscripten\") || build.remote_tested(target) {\n-        cargo.arg(\"--no-run\");\n-    }\n \n-    cargo.arg(\"--\");\n+        // The tests are going to run with the *target* libraries, so we need to\n+        // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n+        //\n+        // Note that to run the compiler we need to run with the *host* libraries,\n+        // but our wrapper scripts arrange for that to be the case anyway.\n+        let mut dylib_path = dylib_path();\n+        dylib_path.insert(0, build.sysroot_libdir(&compiler, target));\n+        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+\n+        if target.contains(\"emscripten\") || build.remote_tested(target) {\n+            cargo.arg(\"--no-run\");\n+        }\n \n-    if build.config.quiet_tests {\n-        cargo.arg(\"--quiet\");\n-    }\n+        cargo.arg(\"--\");\n \n-    let _time = util::timeit();\n+        if build.config.quiet_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n \n-    if target.contains(\"emscripten\") {\n-        build.run(&mut cargo);\n-        krate_emscripten(build, &compiler, target, mode);\n-    } else if build.remote_tested(target) {\n-        build.run(&mut cargo);\n-        krate_remote(build, &compiler, target, mode);\n-    } else {\n-        cargo.args(&build.flags.cmd.test_args());\n-        try_run(build, &mut cargo);\n+        let _time = util::timeit();\n+\n+        if target.contains(\"emscripten\") {\n+            build.run(&mut cargo);\n+            krate_emscripten(build, &compiler, target, mode);\n+        } else if build.remote_tested(target) {\n+            build.run(&mut cargo);\n+            krate_remote(build, &compiler, target, mode);\n+        } else {\n+            cargo.args(&build.flags.cmd.test_args());\n+            try_run(build, &mut cargo);\n+        }\n     }\n }\n \n@@ -816,38 +950,52 @@ fn find_tests(dir: &Path, target: &str) -> Vec<PathBuf> {\n //         })\n //         .run(move |s| check::remote_copy_libs(build, &s.compiler(), s.target));\n //\n-pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n-    if !build.remote_tested(target) {\n-        return\n-    }\n \n-    println!(\"REMOTE copy libs to emulator ({})\", target);\n-    t!(fs::create_dir_all(build.out.join(\"tmp\")));\n+#[derive(Serialize)]\n+pub struct RemoteCopyLibs<'a> {\n+    compiler: Compiler<'a>,\n+    target: &'a str,\n+}\n \n-    let server = build.cargo_out(compiler, Mode::Tool, target)\n-                      .join(exe(\"remote-test-server\", target));\n+impl<'a> Step<'a> for RemoteCopyLibs<'a> {\n+    type Output = ();\n \n-    // Spawn the emulator and wait for it to come online\n-    let tool = build.tool(&Compiler::new(0, &build.build),\n-                          \"remote-test-client\");\n-    let mut cmd = Command::new(&tool);\n-    cmd.arg(\"spawn-emulator\")\n-       .arg(target)\n-       .arg(&server)\n-       .arg(build.out.join(\"tmp\"));\n-    if let Some(rootfs) = build.qemu_rootfs(target) {\n-        cmd.arg(rootfs);\n-    }\n-    build.run(&mut cmd);\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        if !build.remote_tested(target) {\n+            return\n+        }\n+\n+        println!(\"REMOTE copy libs to emulator ({})\", target);\n+        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n \n-    // Push all our dylibs to the emulator\n-    for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {\n-        let f = t!(f);\n-        let name = f.file_name().into_string().unwrap();\n-        if util::is_dylib(&name) {\n-            build.run(Command::new(&tool)\n-                              .arg(\"push\")\n-                              .arg(f.path()));\n+        let server = build.cargo_out(compiler, Mode::Tool, target)\n+                          .join(exe(\"remote-test-server\", target));\n+\n+        // Spawn the emulator and wait for it to come online\n+        let tool = build.tool(&Compiler::new(0, &build.build),\n+                              \"remote-test-client\");\n+        let mut cmd = Command::new(&tool);\n+        cmd.arg(\"spawn-emulator\")\n+           .arg(target)\n+           .arg(&server)\n+           .arg(build.out.join(\"tmp\"));\n+        if let Some(rootfs) = build.qemu_rootfs(target) {\n+            cmd.arg(rootfs);\n+        }\n+        build.run(&mut cmd);\n+\n+        // Push all our dylibs to the emulator\n+        for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {\n+            let f = t!(f);\n+            let name = f.file_name().into_string().unwrap();\n+            if util::is_dylib(&name) {\n+                build.run(Command::new(&tool)\n+                                  .arg(\"push\")\n+                                  .arg(f.path()));\n+            }\n         }\n     }\n }\n@@ -857,75 +1005,92 @@ pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n //     .dep(|s| s.name(\"dist-src\"))\n //     .run(move |_| check::distcheck(build));\n \n-/// Run \"distcheck\", a 'make check' from a tarball\n-pub fn distcheck(build: &Build) {\n-    if build.build != \"x86_64-unknown-linux-gnu\" {\n-        return\n-    }\n-    if !build.config.host.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n-        return\n-    }\n-    if !build.config.target.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n-        return\n-    }\n+#[derive(Serialize)]\n+pub struct Distcheck;\n \n-    println!(\"Distcheck\");\n-    let dir = build.out.join(\"tmp\").join(\"distcheck\");\n-    let _ = fs::remove_dir_all(&dir);\n-    t!(fs::create_dir_all(&dir));\n-\n-    let mut cmd = Command::new(\"tar\");\n-    cmd.arg(\"-xzf\")\n-       .arg(dist::rust_src_location(build))\n-       .arg(\"--strip-components=1\")\n-       .current_dir(&dir);\n-    build.run(&mut cmd);\n-    build.run(Command::new(\"./configure\")\n-                     .args(&build.config.configure_args)\n-                     .arg(\"--enable-vendor\")\n-                     .current_dir(&dir));\n-    build.run(Command::new(build_helper::make(&build.build))\n-                     .arg(\"check\")\n-                     .current_dir(&dir));\n-\n-    // Now make sure that rust-src has all of libstd's dependencies\n-    println!(\"Distcheck rust-src\");\n-    let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n-    let _ = fs::remove_dir_all(&dir);\n-    t!(fs::create_dir_all(&dir));\n-\n-    let mut cmd = Command::new(\"tar\");\n-    cmd.arg(\"-xzf\")\n-       .arg(dist::rust_src_installer(build))\n-       .arg(\"--strip-components=1\")\n-       .current_dir(&dir);\n-    build.run(&mut cmd);\n-\n-    let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-    build.run(Command::new(&build.initial_cargo)\n-                     .arg(\"generate-lockfile\")\n-                     .arg(\"--manifest-path\")\n-                     .arg(&toml)\n-                     .current_dir(&dir));\n+impl<'a> Step<'a> for Distcheck {\n+    type Output = ();\n+\n+    /// Run \"distcheck\", a 'make check' from a tarball\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+\n+        if build.build != \"x86_64-unknown-linux-gnu\" {\n+            return\n+        }\n+        if !build.config.host.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n+            return\n+        }\n+        if !build.config.target.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n+            return\n+        }\n+\n+        println!(\"Distcheck\");\n+        let dir = build.out.join(\"tmp\").join(\"distcheck\");\n+        let _ = fs::remove_dir_all(&dir);\n+        t!(fs::create_dir_all(&dir));\n+\n+        let mut cmd = Command::new(\"tar\");\n+        cmd.arg(\"-xzf\")\n+           .arg(dist::rust_src_location(build))\n+           .arg(\"--strip-components=1\")\n+           .current_dir(&dir);\n+        build.run(&mut cmd);\n+        build.run(Command::new(\"./configure\")\n+                         .args(&build.config.configure_args)\n+                         .arg(\"--enable-vendor\")\n+                         .current_dir(&dir));\n+        build.run(Command::new(build_helper::make(&build.build))\n+                         .arg(\"check\")\n+                         .current_dir(&dir));\n+\n+        // Now make sure that rust-src has all of libstd's dependencies\n+        println!(\"Distcheck rust-src\");\n+        let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n+        let _ = fs::remove_dir_all(&dir);\n+        t!(fs::create_dir_all(&dir));\n+\n+        let mut cmd = Command::new(\"tar\");\n+        cmd.arg(\"-xzf\")\n+           .arg(dist::rust_src_installer(build))\n+           .arg(\"--strip-components=1\")\n+           .current_dir(&dir);\n+        build.run(&mut cmd);\n+\n+        let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n+        build.run(Command::new(&build.initial_cargo)\n+                         .arg(\"generate-lockfile\")\n+                         .arg(\"--manifest-path\")\n+                         .arg(&toml)\n+                         .current_dir(&dir));\n+    }\n }\n \n //rules.test(\"check-bootstrap\", \"src/bootstrap\")\n //     .default(true)\n //     .host(true)\n //     .only_build(true)\n //     .run(move |_| check::bootstrap(build));\n-//\n-/// Test the build system itself\n-pub fn bootstrap(build: &Build) {\n-    let mut cmd = Command::new(&build.initial_cargo);\n-    cmd.arg(\"test\")\n-       .current_dir(build.src.join(\"src/bootstrap\"))\n-       .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n-       .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-       .env(\"RUSTC\", &build.initial_rustc);\n-    if !build.fail_fast {\n-        cmd.arg(\"--no-fail-fast\");\n+\n+#[derive(Serialize)]\n+pub struct Bootstrap;\n+\n+impl<'a> for Step<'a> Bootstrap {\n+    type Output = ();\n+\n+    /// Test the build system itself\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let mut cmd = Command::new(&build.initial_cargo);\n+        cmd.arg(\"test\")\n+           .current_dir(build.src.join(\"src/bootstrap\"))\n+           .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n+           .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+           .env(\"RUSTC\", &build.initial_rustc);\n+        if !build.fail_fast {\n+            cmd.arg(\"--no-fail-fast\");\n+        }\n+        cmd.arg(\"--\").args(&build.flags.cmd.test_args());\n+        try_run(build, &mut cmd);\n     }\n-    cmd.arg(\"--\").args(&build.flags.cmd.test_args());\n-    try_run(build, &mut cmd);\n }"}, {"sha": "cf1e11f7ac8205f943c48d2749f61a5756939130", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 419, "deletions": 451, "changes": 870, "blob_url": "https://github.com/rust-lang/rust/blob/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=001e9f349087124165ed6deea6a87e0b158bba21", "patch": "@@ -32,24 +32,6 @@ use channel::GitInfo;\n use util::{exe, libdir, is_dylib, copy};\n use {Build, Compiler, Mode};\n \n-//    for (krate, path, _default) in krates(\"std\") {\n-//        rules.build(&krate.build_step, path)\n-//             .dep(|s| s.name(\"startup-objects\"))\n-//             .dep(move |s| s.name(\"rustc\").host(&build.build).target(s.host))\n-//             .run(move |s| compile::std(build, s.target, &s.compiler()));\n-//    }\n-//    for (krate, path, _default) in krates(\"test\") {\n-//        rules.build(&krate.build_step, path)\n-//             .dep(|s| s.name(\"libstd-link\"))\n-//             .run(move |s| compile::test(build, s.target, &s.compiler()));\n-//    }\n-//    for (krate, path, _default) in krates(\"rustc-main\") {\n-//        rules.build(&krate.build_step, path)\n-//             .dep(|s| s.name(\"libtest-link\"))\n-//             .dep(move |s| s.name(\"llvm\").host(&build.build).stage(0))\n-//             .dep(|s| s.name(\"may-run-build-script\"))\n-//             .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n-//    }\n //\n //    // Crates which have build scripts need to rely on this rule to ensure that\n //    // the necessary prerequisites for a build script are linked and located in\n@@ -147,65 +129,84 @@ fn crate_rule<'a, 'b>(build: &'a Build,\n         rule\n }\n \n-/// Build the standard library.\n-///\n-/// This will build the standard library for a particular stage of the build\n-/// using the `compiler` targeting the `target` architecture. The artifacts\n-/// created will also be linked into the sysroot directory.\n-pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n-    let libdir = build.sysroot_libdir(compiler, target);\n-    t!(fs::create_dir_all(&libdir));\n-\n-    let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-             compiler.host, target);\n-\n-    let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n-    build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n-    let mut cargo = build.cargo(compiler, Mode::Libstd, target, \"build\");\n-    let mut features = build.std_features();\n-\n-    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n-        cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n-    }\n+//    for (krate, path, _default) in krates(\"std\") {\n+//        rules.build(&krate.build_step, path)\n+//             .dep(|s| s.name(\"startup-objects\"))\n+//             .dep(move |s| s.name(\"rustc\").host(&build.build).target(s.host))\n+//             .run(move |s| compile::std(build, s.target, &s.compiler()));\n+//    }\n+#[derive(Serialize)]\n+pub struct Std<'a> {\n+    pub target: &'a str,\n+    pub compiler: &'a Compiler<'a>,\n+}\n \n-    // When doing a local rebuild we tell cargo that we're stage1 rather than\n-    // stage0. This works fine if the local rust and being-built rust have the\n-    // same view of what the default allocator is, but fails otherwise. Since\n-    // we don't have a way to express an allocator preference yet, work\n-    // around the issue in the case of a local rebuild with jemalloc disabled.\n-    if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n-        features.push_str(\" force_alloc_system\");\n-    }\n+impl<'a> Step<'a> for Std<'a> {\n+    type Output = ();\n+\n+    /// Build the standard library.\n+    ///\n+    /// This will build the standard library for a particular stage of the build\n+    /// using the `compiler` targeting the `target` architecture. The artifacts\n+    /// created will also be linked into the sysroot directory.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        let compiler = self.compiler;\n+        let libdir = build.sysroot_libdir(compiler, target);\n+        t!(fs::create_dir_all(&libdir));\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+                compiler.host, target);\n+\n+        let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n+        build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n+        let mut cargo = build.cargo(compiler, Mode::Libstd, target, \"build\");\n+        let mut features = build.std_features();\n+\n+        if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n+            cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n+        }\n \n-    if compiler.stage != 0 && build.config.sanitizers {\n-        // This variable is used by the sanitizer runtime crates, e.g.\n-        // rustc_lsan, to build the sanitizer runtime from C code\n-        // When this variable is missing, those crates won't compile the C code,\n-        // so we don't set this variable during stage0 where llvm-config is\n-        // missing\n-        // We also only build the runtimes when --enable-sanitizers (or its\n-        // config.toml equivalent) is used\n-        cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n-    }\n-    cargo.arg(\"--features\").arg(features)\n-         .arg(\"--manifest-path\")\n-         .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n+        // When doing a local rebuild we tell cargo that we're stage1 rather than\n+        // stage0. This works fine if the local rust and being-built rust have the\n+        // same view of what the default allocator is, but fails otherwise. Since\n+        // we don't have a way to express an allocator preference yet, work\n+        // around the issue in the case of a local rebuild with jemalloc disabled.\n+        if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n+            features.push_str(\" force_alloc_system\");\n+        }\n \n-    if let Some(target) = build.config.target_config.get(target) {\n-        if let Some(ref jemalloc) = target.jemalloc {\n-            cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+        if compiler.stage != 0 && build.config.sanitizers {\n+            // This variable is used by the sanitizer runtime crates, e.g.\n+            // rustc_lsan, to build the sanitizer runtime from C code\n+            // When this variable is missing, those crates won't compile the C code,\n+            // so we don't set this variable during stage0 where llvm-config is\n+            // missing\n+            // We also only build the runtimes when --enable-sanitizers (or its\n+            // config.toml equivalent) is used\n+            cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n         }\n-    }\n-    if target.contains(\"musl\") {\n-        if let Some(p) = build.musl_root(target) {\n-            cargo.env(\"MUSL_ROOT\", p);\n+        cargo.arg(\"--features\").arg(features)\n+            .arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n+\n+        if let Some(target) = build.config.target_config.get(target) {\n+            if let Some(ref jemalloc) = target.jemalloc {\n+                cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+            }\n+        }\n+        if target.contains(\"musl\") {\n+            if let Some(p) = build.musl_root(target) {\n+                cargo.env(\"MUSL_ROOT\", p);\n+            }\n         }\n-    }\n \n-    run_cargo(build,\n-              &mut cargo,\n-              &libstd_stamp(build, &compiler, target));\n+        run_cargo(build,\n+                &mut cargo,\n+                &libstd_stamp(build, &compiler, target));\n+    }\n }\n \n \n@@ -216,36 +217,49 @@ pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n //            compile::std_link)\n //     .dep(|s| s.name(\"startup-objects\"))\n //     .dep(|s| s.name(\"create-sysroot\").target(s.host));\n-/// Link all libstd rlibs/dylibs into the sysroot location.\n-///\n-/// Links those artifacts generated by `compiler` to a the `stage` compiler's\n-/// sysroot for the specified `host` and `target`.\n-///\n-/// Note that this assumes that `compiler` has already generated the libstd\n-/// libraries for `target`, and this method will find them in the relevant\n-/// output directory.\n-pub fn std_link(build: &Build,\n-                compiler: &Compiler,\n-                target_compiler: &Compiler,\n-                target: &str) {\n-    println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n-             target_compiler.stage,\n-             compiler.stage,\n-             compiler.host,\n-             target_compiler.host,\n-             target);\n-    let libdir = build.sysroot_libdir(target_compiler, target);\n-    add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n-\n-    if target.contains(\"musl\") && !target.contains(\"mips\") {\n-        copy_musl_third_party_objects(build, target, &libdir);\n-    }\n \n-    if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n-        // The sanitizers are only built in stage1 or above, so the dylibs will\n-        // be missing in stage0 and causes panic. See the `std()` function above\n-        // for reason why the sanitizers are not built in stage0.\n-        copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n+#[derive(Serialize)]\n+pub struct StdLink<'a> {\n+    pub compiler: Compiler<'a>,\n+    pub target_compiler: Compiler<'a>,\n+    pub target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for StdLink<'a> {\n+    type Output = ();\n+\n+    /// Link all libstd rlibs/dylibs into the sysroot location.\n+    ///\n+    /// Links those artifacts generated by `compiler` to a the `stage` compiler's\n+    /// sysroot for the specified `host` and `target`.\n+    ///\n+    /// Note that this assumes that `compiler` has already generated the libstd\n+    /// libraries for `target`, and this method will find them in the relevant\n+    /// output directory.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target_compiler = self.target_compiler;\n+        let target = self.target;\n+        println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+                target_compiler.stage,\n+                compiler.stage,\n+                compiler.host,\n+                target_compiler.host,\n+                target);\n+        let libdir = build.sysroot_libdir(target_compiler, target);\n+        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+\n+        if target.contains(\"musl\") && !target.contains(\"mips\") {\n+            copy_musl_third_party_objects(build, target, &libdir);\n+        }\n+\n+        if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n+            // The sanitizers are only built in stage1 or above, so the dylibs will\n+            // be missing in stage0 and causes panic. See the `std()` function above\n+            // for reason why the sanitizers are not built in stage0.\n+            copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n+        }\n     }\n }\n \n@@ -274,66 +288,97 @@ fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n //      .dep(|s| s.name(\"create-sysroot\").target(s.host))\n //      .run(move |s| compile::build_startup_objects(build, &s.compiler(), s.target));\n \n-/// Build and prepare startup objects like rsbegin.o and rsend.o\n-///\n-/// These are primarily used on Windows right now for linking executables/dlls.\n-/// They don't require any library support as they're just plain old object\n-/// files, so we just use the nightly snapshot compiler to always build them (as\n-/// no other compilers are guaranteed to be available).\n-pub fn build_startup_objects(build: &Build, for_compiler: &Compiler, target: &str) {\n-    if !target.contains(\"pc-windows-gnu\") {\n-        return\n-    }\n+#[derive(Serialize)]\n+pub struct StartupObjects<'a> {\n+    pub for_compiler: Compiler<'a>,\n+    pub target: &'a str,\n+}\n \n-    let compiler = Compiler::new(0, &build.build);\n-    let compiler_path = build.compiler_path(&compiler);\n-    let src_dir = &build.src.join(\"src/rtstartup\");\n-    let dst_dir = &build.native_dir(target).join(\"rtstartup\");\n-    let sysroot_dir = &build.sysroot_libdir(for_compiler, target);\n-    t!(fs::create_dir_all(dst_dir));\n-    t!(fs::create_dir_all(sysroot_dir));\n-\n-    for file in &[\"rsbegin\", \"rsend\"] {\n-        let src_file = &src_dir.join(file.to_string() + \".rs\");\n-        let dst_file = &dst_dir.join(file.to_string() + \".o\");\n-        if !up_to_date(src_file, dst_file) {\n-            let mut cmd = Command::new(&compiler_path);\n-            build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n-                        .arg(\"--cfg\").arg(format!(\"stage{}\", compiler.stage))\n-                        .arg(\"--target\").arg(target)\n-                        .arg(\"--emit=obj\")\n-                        .arg(\"--out-dir\").arg(dst_dir)\n-                        .arg(src_file));\n+impl<'a> Step<'a> for StartupObjects<'a> {\n+    type Output = ();\n+\n+    /// Build and prepare startup objects like rsbegin.o and rsend.o\n+    ///\n+    /// These are primarily used on Windows right now for linking executables/dlls.\n+    /// They don't require any library support as they're just plain old object\n+    /// files, so we just use the nightly snapshot compiler to always build them (as\n+    /// no other compilers are guaranteed to be available).\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let for_compiler = self.for_compiler;\n+        let target = self.target;\n+        if !target.contains(\"pc-windows-gnu\") {\n+            return\n         }\n \n-        copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n-    }\n+        let compiler = Compiler::new(0, &build.build);\n+        let compiler_path = build.compiler_path(&compiler);\n+        let src_dir = &build.src.join(\"src/rtstartup\");\n+        let dst_dir = &build.native_dir(target).join(\"rtstartup\");\n+        let sysroot_dir = &build.sysroot_libdir(for_compiler, target);\n+        t!(fs::create_dir_all(dst_dir));\n+        t!(fs::create_dir_all(sysroot_dir));\n+\n+        for file in &[\"rsbegin\", \"rsend\"] {\n+            let src_file = &src_dir.join(file.to_string() + \".rs\");\n+            let dst_file = &dst_dir.join(file.to_string() + \".o\");\n+            if !up_to_date(src_file, dst_file) {\n+                let mut cmd = Command::new(&compiler_path);\n+                build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n+                            .arg(\"--cfg\").arg(format!(\"stage{}\", compiler.stage))\n+                            .arg(\"--target\").arg(target)\n+                            .arg(\"--emit=obj\")\n+                            .arg(\"--out-dir\").arg(dst_dir)\n+                            .arg(src_file));\n+            }\n \n-    for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-        copy(&compiler_file(build.cc(target), obj), &sysroot_dir.join(obj));\n+            copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+        }\n+\n+        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n+            copy(&compiler_file(build.cc(target), obj), &sysroot_dir.join(obj));\n+        }\n     }\n }\n \n-/// Build libtest.\n-///\n-/// This will build libtest and supporting libraries for a particular stage of\n-/// the build using the `compiler` targeting the `target` architecture. The\n-/// artifacts created will also be linked into the sysroot directory.\n-pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n-    let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-    println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-             compiler.host, target);\n-    let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n-    build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n-    let mut cargo = build.cargo(compiler, Mode::Libtest, target, \"build\");\n-    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n-        cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n+//    for (krate, path, _default) in krates(\"test\") {\n+//        rules.build(&krate.build_step, path)\n+//             .dep(|s| s.name(\"libstd-link\"))\n+//             .run(move |s| compile::test(build, s.target, &s.compiler()));\n+//    }\n+#[derive(Serialize)]\n+pub struct Test<'a> {\n+    pub compiler: Compiler<'a>,\n+    pub target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Test<'a> {\n+    type Output = ();\n+\n+    /// Build libtest.\n+    ///\n+    /// This will build libtest and supporting libraries for a particular stage of\n+    /// the build using the `compiler` targeting the `target` architecture. The\n+    /// artifacts created will also be linked into the sysroot directory.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        let compiler = self.compiler;\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n+                compiler.host, target);\n+        let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n+        build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n+        let mut cargo = build.cargo(compiler, Mode::Libtest, target, \"build\");\n+        if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n+            cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n+        }\n+        cargo.arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/libtest/Cargo.toml\"));\n+        run_cargo(build,\n+                &mut cargo,\n+                &libtest_stamp(build, compiler, target));\n     }\n-    cargo.arg(\"--manifest-path\")\n-         .arg(build.src.join(\"src/libtest/Cargo.toml\"));\n-    run_cargo(build,\n-              &mut cargo,\n-              &libtest_stamp(build, compiler, target));\n }\n \n \n@@ -344,98 +389,131 @@ pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n //            compile::test_link)\n //     .dep(|s| s.name(\"libstd-link\"));\n \n-/// Same as `std_link`, only for libtest\n-pub fn test_link(build: &Build,\n-                 compiler: &Compiler,\n-                 target_compiler: &Compiler,\n-                 target: &str) {\n-    println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n-             target_compiler.stage,\n-             compiler.stage,\n-             compiler.host,\n-             target_compiler.host,\n-             target);\n-    add_to_sysroot(&build.sysroot_libdir(target_compiler, target),\n-                   &libtest_stamp(build, compiler, target));\n+#[derive(Serialize)]\n+pub struct TestLink<'a> {\n+    pub compiler: Compiler<'a>,\n+    pub target_compiler: Compiler<'a>,\n+    pub target: &'a str,\n }\n \n-/// Build the compiler.\n-///\n-/// This will build the compiler for a particular stage of the build using\n-/// the `compiler` targeting the `target` architecture. The artifacts\n-/// created will also be linked into the sysroot directory.\n-pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n-    let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-    println!(\"Building stage{} compiler artifacts ({} -> {})\",\n-             compiler.stage, compiler.host, target);\n-\n-    let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n-    build.clear_if_dirty(&out_dir, &libtest_stamp(build, compiler, target));\n-\n-    let mut cargo = build.cargo(compiler, Mode::Librustc, target, \"build\");\n-    cargo.arg(\"--features\").arg(build.rustc_features())\n-         .arg(\"--manifest-path\")\n-         .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n-\n-    // Set some configuration variables picked up by build scripts and\n-    // the compiler alike\n-    cargo.env(\"CFG_RELEASE\", build.rust_release())\n-         .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n-         .env(\"CFG_VERSION\", build.rust_version())\n-         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default());\n-\n-    if compiler.stage == 0 {\n-        cargo.env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n-    } else {\n-        let libdir_relative = build.config.libdir_relative.clone().unwrap_or(PathBuf::from(\"lib\"));\n-        cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n+impl<'a> Step<'a> for Step<'a> {\n+    type Output = ();\n+\n+    /// Same as `std_link`, only for libtest\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target_compiler = self.target_compiler;\n+        let target = self.target;\n+        println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n+                target_compiler.stage,\n+                compiler.stage,\n+                compiler.host,\n+                target_compiler.host,\n+                target);\n+        add_to_sysroot(&build.sysroot_libdir(target_compiler, target),\n+                    &libtest_stamp(build, compiler, target));\n     }\n+}\n \n-    // If we're not building a compiler with debugging information then remove\n-    // these two env vars which would be set otherwise.\n-    if build.config.rust_debuginfo_only_std {\n-        cargo.env_remove(\"RUSTC_DEBUGINFO\");\n-        cargo.env_remove(\"RUSTC_DEBUGINFO_LINES\");\n-    }\n+//    for (krate, path, _default) in krates(\"rustc-main\") {\n+//        rules.build(&krate.build_step, path)\n+//             .dep(|s| s.name(\"libtest-link\"))\n+//             .dep(move |s| s.name(\"llvm\").host(&build.build).stage(0))\n+//             .dep(|s| s.name(\"may-run-build-script\"))\n+//             .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n+//    }\n \n-    if let Some(ref ver_date) = build.rust_info.commit_date() {\n-        cargo.env(\"CFG_VER_DATE\", ver_date);\n-    }\n-    if let Some(ref ver_hash) = build.rust_info.sha() {\n-        cargo.env(\"CFG_VER_HASH\", ver_hash);\n-    }\n-    if !build.unstable_features() {\n-        cargo.env(\"CFG_DISABLE_UNSTABLE_FEATURES\", \"1\");\n-    }\n-    // Flag that rust llvm is in use\n-    if build.is_rust_llvm(target) {\n-        cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n-    }\n-    cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n-    let target_config = build.config.target_config.get(target);\n-    if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-        cargo.env(\"CFG_LLVM_ROOT\", s);\n-    }\n-    // Building with a static libstdc++ is only supported on linux right now,\n-    // not for MSVC or macOS\n-    if build.config.llvm_static_stdcpp &&\n-       !target.contains(\"windows\") &&\n-       !target.contains(\"apple\") {\n-        cargo.env(\"LLVM_STATIC_STDCPP\",\n-                  compiler_file(build.cxx(target).unwrap(), \"libstdc++.a\"));\n-    }\n-    if build.config.llvm_link_shared {\n-        cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n-    }\n-    if let Some(ref s) = build.config.rustc_default_linker {\n-        cargo.env(\"CFG_DEFAULT_LINKER\", s);\n-    }\n-    if let Some(ref s) = build.config.rustc_default_ar {\n-        cargo.env(\"CFG_DEFAULT_AR\", s);\n+#[derive(Serialize)]\n+pub struct Rustc<'a> {\n+    pub compiler: Compiler<'a>,\n+    pub target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Rustc<'a> {\n+    type Output = ();\n+\n+    /// Build the compiler.\n+    ///\n+    /// This will build the compiler for a particular stage of the build using\n+    /// the `compiler` targeting the `target` architecture. The artifacts\n+    /// created will also be linked into the sysroot directory.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Building stage{} compiler artifacts ({} -> {})\",\n+                 compiler.stage, compiler.host, target);\n+\n+        let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n+        build.clear_if_dirty(&out_dir, &libtest_stamp(build, compiler, target));\n+\n+        let mut cargo = build.cargo(compiler, Mode::Librustc, target, \"build\");\n+        cargo.arg(\"--features\").arg(build.rustc_features())\n+             .arg(\"--manifest-path\")\n+             .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n+\n+        // Set some configuration variables picked up by build scripts and\n+        // the compiler alike\n+        cargo.env(\"CFG_RELEASE\", build.rust_release())\n+             .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n+             .env(\"CFG_VERSION\", build.rust_version())\n+             .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default());\n+\n+        if compiler.stage == 0 {\n+            cargo.env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n+        } else {\n+            let libdir_relative = build.config.libdir_relative.clone().unwrap_or(PathBuf::from(\"lib\"));\n+            cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n+        }\n+\n+        // If we're not building a compiler with debugging information then remove\n+        // these two env vars which would be set otherwise.\n+        if build.config.rust_debuginfo_only_std {\n+            cargo.env_remove(\"RUSTC_DEBUGINFO\");\n+            cargo.env_remove(\"RUSTC_DEBUGINFO_LINES\");\n+        }\n+\n+        if let Some(ref ver_date) = build.rust_info.commit_date() {\n+            cargo.env(\"CFG_VER_DATE\", ver_date);\n+        }\n+        if let Some(ref ver_hash) = build.rust_info.sha() {\n+            cargo.env(\"CFG_VER_HASH\", ver_hash);\n+        }\n+        if !build.unstable_features() {\n+            cargo.env(\"CFG_DISABLE_UNSTABLE_FEATURES\", \"1\");\n+        }\n+        // Flag that rust llvm is in use\n+        if build.is_rust_llvm(target) {\n+            cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n+        }\n+        cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n+        let target_config = build.config.target_config.get(target);\n+        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+            cargo.env(\"CFG_LLVM_ROOT\", s);\n+        }\n+        // Building with a static libstdc++ is only supported on linux right now,\n+        // not for MSVC or macOS\n+        if build.config.llvm_static_stdcpp &&\n+           !target.contains(\"windows\") &&\n+           !target.contains(\"apple\") {\n+            cargo.env(\"LLVM_STATIC_STDCPP\",\n+                      compiler_file(build.cxx(target).unwrap(), \"libstdc++.a\"));\n+        }\n+        if build.config.llvm_link_shared {\n+            cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n+        }\n+        if let Some(ref s) = build.config.rustc_default_linker {\n+            cargo.env(\"CFG_DEFAULT_LINKER\", s);\n+        }\n+        if let Some(ref s) = build.config.rustc_default_ar {\n+            cargo.env(\"CFG_DEFAULT_AR\", s);\n+        }\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &librustc_stamp(build, compiler, target));\n     }\n-    run_cargo(build,\n-              &mut cargo,\n-              &librustc_stamp(build, compiler, target));\n }\n \n // crate_rule(build,\n@@ -444,19 +522,31 @@ pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n //            \"build-crate-rustc-main\",\n //            compile::rustc_link)\n //     .dep(|s| s.name(\"libtest-link\"));\n-/// Same as `std_link`, only for librustc\n-pub fn rustc_link(build: &Build,\n-                  compiler: &Compiler,\n-                  target_compiler: &Compiler,\n-                  target: &str) {\n-    println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n-             target_compiler.stage,\n-             compiler.stage,\n-             compiler.host,\n-             target_compiler.host,\n-             target);\n-    add_to_sysroot(&build.sysroot_libdir(target_compiler, target),\n-                   &librustc_stamp(build, compiler, target));\n+#[derive(Serialize)]\n+pub struct RustcLink<'a> {\n+    pub compiler: Compiler<'a>,\n+    pub target_compiler: Compiler<'a>,\n+    pub target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for RustcLink<'a> {\n+    type Output = ();\n+\n+    /// Same as `std_link`, only for librustc\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target_compiler = self.target_compiler;\n+        let target = self.target;\n+        println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+                 target_compiler.stage,\n+                 compiler.stage,\n+                 compiler.host,\n+                 target_compiler.host,\n+                 target);\n+        add_to_sysroot(&build.sysroot_libdir(target_compiler, target),\n+                       &librustc_stamp(build, compiler, target));\n+    }\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n@@ -485,10 +575,28 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n \n // rules.build(\"create-sysroot\", \"path/to/nowhere\")\n //      .run(move |s| compile::create_sysroot(build, &s.compiler()));\n-pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n-    let sysroot = build.sysroot(compiler);\n-    let _ = fs::remove_dir_all(&sysroot);\n-    t!(fs::create_dir_all(&sysroot));\n+\n+#[derive(Serialize)]\n+pub struct Sysroot<'a> {\n+    pub compiler: Compiler<'a>,\n+}\n+\n+impl<'a> Step<'a> for Sysroot<'a> {\n+    type Output = ();\n+\n+    /// Returns the sysroot for the `compiler` specified that *this build system\n+    /// generates*.\n+    ///\n+    /// That is, the sysroot for the stage0 compiler is not what the compiler\n+    /// thinks it is by default, but it's the same as the default for stages\n+    /// 1-3.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let sysroot = build.sysroot(compiler);\n+        let _ = fs::remove_dir_all(&sysroot);\n+        t!(fs::create_dir_all(&sysroot));\n+    }\n }\n \n // the compiler with no target libraries ready to go\n@@ -504,54 +612,68 @@ pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n //          }\n //      })\n //      .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n-/// Prepare a new compiler from the artifacts in `stage`\n-///\n-/// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n-/// must have been previously produced by the `stage - 1` build.build\n-/// compiler.\n-pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n-    // nothing to do in stage0\n-    if stage == 0 {\n-        return\n-    }\n \n-    println!(\"Copying stage{} compiler ({})\", stage, host);\n+#[derive(Serialize)]\n+pub struct Assemble<'a> {\n+    pub stage: u32,\n+    pub host: &'a str,\n+}\n \n-    // The compiler that we're assembling\n-    let target_compiler = Compiler::new(stage, host);\n+impl<'a> Step<'a> for Assemble<'a> {\n+    type Output = ();\n+\n+    /// Prepare a new compiler from the artifacts in `stage`\n+    ///\n+    /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n+    /// must have been previously produced by the `stage - 1` build.build\n+    /// compiler.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        // nothing to do in stage0\n+        if stage == 0 {\n+            return\n+        }\n+\n+        println!(\"Copying stage{} compiler ({})\", stage, host);\n \n-    // The compiler that compiled the compiler we're assembling\n-    let build_compiler = Compiler::new(stage - 1, &build.build);\n+        // The compiler that we're assembling\n+        let target_compiler = Compiler::new(stage, host);\n \n-    // Link in all dylibs to the libdir\n-    let sysroot = build.sysroot(&target_compiler);\n-    let sysroot_libdir = sysroot.join(libdir(host));\n-    t!(fs::create_dir_all(&sysroot_libdir));\n-    let src_libdir = build.sysroot_libdir(&build_compiler, host);\n-    for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n-        let filename = f.file_name().into_string().unwrap();\n-        if is_dylib(&filename) {\n-            copy(&f.path(), &sysroot_libdir.join(&filename));\n+        // The compiler that compiled the compiler we're assembling\n+        let build_compiler = Compiler::new(stage - 1, &build.build);\n+\n+        // Link in all dylibs to the libdir\n+        let sysroot = build.sysroot(&target_compiler);\n+        let sysroot_libdir = sysroot.join(libdir(host));\n+        t!(fs::create_dir_all(&sysroot_libdir));\n+        let src_libdir = build.sysroot_libdir(&build_compiler, host);\n+        for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n+            let filename = f.file_name().into_string().unwrap();\n+            if is_dylib(&filename) {\n+                copy(&f.path(), &sysroot_libdir.join(&filename));\n+            }\n         }\n-    }\n \n-    let out_dir = build.cargo_out(&build_compiler, Mode::Librustc, host);\n-\n-    // Link the compiler binary itself into place\n-    let rustc = out_dir.join(exe(\"rustc\", host));\n-    let bindir = sysroot.join(\"bin\");\n-    t!(fs::create_dir_all(&bindir));\n-    let compiler = build.compiler_path(&target_compiler);\n-    let _ = fs::remove_file(&compiler);\n-    copy(&rustc, &compiler);\n-\n-    // See if rustdoc exists to link it into place\n-    let rustdoc = exe(\"rustdoc\", host);\n-    let rustdoc_src = out_dir.join(&rustdoc);\n-    let rustdoc_dst = bindir.join(&rustdoc);\n-    if fs::metadata(&rustdoc_src).is_ok() {\n-        let _ = fs::remove_file(&rustdoc_dst);\n-        copy(&rustdoc_src, &rustdoc_dst);\n+        let out_dir = build.cargo_out(&build_compiler, Mode::Librustc, host);\n+\n+        // Link the compiler binary itself into place\n+        let rustc = out_dir.join(exe(\"rustc\", host));\n+        let bindir = sysroot.join(\"bin\");\n+        t!(fs::create_dir_all(&bindir));\n+        let compiler = build.compiler_path(&target_compiler);\n+        let _ = fs::remove_file(&compiler);\n+        copy(&rustc, &compiler);\n+\n+        // See if rustdoc exists to link it into place\n+        let rustdoc = exe(\"rustdoc\", host);\n+        let rustdoc_src = out_dir.join(&rustdoc);\n+        let rustdoc_dst = bindir.join(&rustdoc);\n+        if fs::metadata(&rustdoc_src).is_ok() {\n+            let _ = fs::remove_file(&rustdoc_dst);\n+            copy(&rustdoc_src, &rustdoc_dst);\n+        }\n     }\n }\n \n@@ -574,160 +696,6 @@ fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     }\n }\n \n-//// ========================================================================\n-//// Build tools\n-////\n-//// Tools used during the build system but not shipped\n-//// \"pseudo rule\" which represents completely cleaning out the tools dir in\n-//// one stage. This needs to happen whenever a dependency changes (e.g.\n-//// libstd, libtest, librustc) and all of the tool compilations above will\n-//// be sequenced after this rule.\n-//rules.build(\"maybe-clean-tools\", \"path/to/nowhere\")\n-//     .after(\"librustc-tool\")\n-//     .after(\"libtest-tool\")\n-//     .after(\"libstd-tool\");\n-//\n-//rules.build(\"librustc-tool\", \"path/to/nowhere\")\n-//     .dep(|s| s.name(\"librustc\"))\n-//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Librustc));\n-//rules.build(\"libtest-tool\", \"path/to/nowhere\")\n-//     .dep(|s| s.name(\"libtest\"))\n-//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libtest));\n-//rules.build(\"libstd-tool\", \"path/to/nowhere\")\n-//     .dep(|s| s.name(\"libstd\"))\n-//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libstd));\n-//\n-/// Build a tool in `src/tools`\n-///\n-/// This will build the specified tool with the specified `host` compiler in\n-/// `stage` into the normal cargo output directory.\n-pub fn maybe_clean_tools(build: &Build, stage: u32, target: &str, mode: Mode) {\n-    let compiler = Compiler::new(stage, &build.build);\n-\n-    let stamp = match mode {\n-        Mode::Libstd => libstd_stamp(build, &compiler, target),\n-        Mode::Libtest => libtest_stamp(build, &compiler, target),\n-        Mode::Librustc => librustc_stamp(build, &compiler, target),\n-        _ => panic!(),\n-    };\n-    let out_dir = build.cargo_out(&compiler, Mode::Tool, target);\n-    build.clear_if_dirty(&out_dir, &stamp);\n-}\n-\n-\n-// rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"librustc-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n-// rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"librustc-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n-// rules.build(\"tool-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"unstable-book-gen\"));\n-// rules.build(\"tool-tidy\", \"src/tools/tidy\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n-// rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n-// rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n-// rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libtest-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n-// rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n-// rules.build(\"tool-remote-test-server\", \"src/tools/remote-test-server\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-server\"));\n-// rules.build(\"tool-remote-test-client\", \"src/tools/remote-test-client\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n-// rules.build(\"tool-rust-installer\", \"src/tools/rust-installer\")\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"rust-installer\"));\n-// rules.build(\"tool-cargo\", \"src/tools/cargo\")\n-//      .host(true)\n-//      .default(build.config.extended)\n-//      .dep(|s| s.name(\"maybe-clean-tools\"))\n-//      .dep(|s| s.name(\"libstd-tool\"))\n-//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n-//      .dep(move |s| {\n-//          // Cargo depends on procedural macros, which requires a full host\n-//          // compiler to be available, so we need to depend on that.\n-//          s.name(\"librustc-link\")\n-//           .target(&build.build)\n-//           .host(&build.build)\n-//      })\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n-// rules.build(\"tool-rls\", \"src/tools/rls\")\n-//      .host(true)\n-//      .default(build.config.extended)\n-//      .dep(|s| s.name(\"librustc-tool\"))\n-//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n-//      .dep(move |s| {\n-//          // rls, like cargo, uses procedural macros\n-//          s.name(\"librustc-link\")\n-//           .target(&build.build)\n-//           .host(&build.build)\n-//      })\n-//      .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n-//\n-\n-/// Build a tool in `src/tools`\n-///\n-/// This will build the specified tool with the specified `host` compiler in\n-/// `stage` into the normal cargo output directory.\n-pub fn tool(build: &Build, stage: u32, target: &str, tool: &str) {\n-    let _folder = build.fold_output(|| format!(\"stage{}-{}\", stage, tool));\n-    println!(\"Building stage{} tool {} ({})\", stage, tool, target);\n-\n-    let compiler = Compiler::new(stage, &build.build);\n-\n-    let mut cargo = build.cargo(&compiler, Mode::Tool, target, \"build\");\n-    let dir = build.src.join(\"src/tools\").join(tool);\n-    cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n-\n-    // We don't want to build tools dynamically as they'll be running across\n-    // stages and such and it's just easier if they're not dynamically linked.\n-    cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-    if let Some(dir) = build.openssl_install_dir(target) {\n-        cargo.env(\"OPENSSL_STATIC\", \"1\");\n-        cargo.env(\"OPENSSL_DIR\", dir);\n-        cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n-    }\n-\n-    cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n-\n-    let info = GitInfo::new(&dir);\n-    if let Some(sha) = info.sha() {\n-        cargo.env(\"CFG_COMMIT_HASH\", sha);\n-    }\n-    if let Some(sha_short) = info.sha_short() {\n-        cargo.env(\"CFG_SHORT_COMMIT_HASH\", sha_short);\n-    }\n-    if let Some(date) = info.commit_date() {\n-        cargo.env(\"CFG_COMMIT_DATE\", date);\n-    }\n-\n-    build.run(&mut cargo);\n-}\n-\n-\n // Avoiding a dependency on winapi to keep compile times down\n #[cfg(unix)]\n fn stderr_isatty() -> bool {"}, {"sha": "8aa9ad7021e6f632511b02a6e8b77ea00232fd2c", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 944, "deletions": 821, "changes": 1765, "blob_url": "https://github.com/rust-lang/rust/blob/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=001e9f349087124165ed6deea6a87e0b158bba21", "patch": "@@ -67,46 +67,61 @@ fn rust_installer(build: &Build) -> Command {\n //      .dep(|s| s.name(\"default:doc\"))\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::docs(build, s.stage, s.target));\n-/// Builds the `rust-docs` installer component.\n-///\n-/// Slurps up documentation from the `stage`'s `host`.\n-pub fn docs(build: &Build, stage: u32, host: &str) {\n-    println!(\"Dist docs stage{} ({})\", stage, host);\n-    if !build.config.docs {\n-        println!(\"\\tskipping - docs disabled\");\n-        return\n-    }\n \n-    let name = pkgname(build, \"rust-docs\");\n-    let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n-    let _ = fs::remove_dir_all(&image);\n+#[derive(Serialize)]\n+pub struct Docs<'a> {\n+    stage: u32,\n+    host: &'a str,\n+}\n \n-    let dst = image.join(\"share/doc/rust/html\");\n-    t!(fs::create_dir_all(&dst));\n-    let src = build.out.join(host).join(\"doc\");\n-    cp_r(&src, &dst);\n+impl<'a> Step<'a> for Docs<'a> {\n+    type Output = ();\n+\n+    /// Builds the `rust-docs` installer component.\n+    ///\n+    /// Slurps up documentation from the `stage`'s `host`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+\n+        println!(\"Dist docs stage{} ({})\", stage, host);\n+        if !build.config.docs {\n+            println!(\"\\tskipping - docs disabled\");\n+            return\n+        }\n \n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"generate\")\n-       .arg(\"--product-name=Rust-Documentation\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=Rust-documentation-is-installed.\")\n-       .arg(\"--image-dir\").arg(&image)\n-       .arg(\"--work-dir\").arg(&tmpdir(build))\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(format!(\"--package-name={}-{}\", name, host))\n-       .arg(\"--component-name=rust-docs\")\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-       .arg(\"--bulk-dirs=share/doc/rust/html\");\n-    build.run(&mut cmd);\n-    t!(fs::remove_dir_all(&image));\n+        let name = pkgname(build, \"rust-docs\");\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let _ = fs::remove_dir_all(&image);\n \n-    // As part of this step, *also* copy the docs directory to a directory which\n-    // buildbot typically uploads.\n-    if host == build.build {\n-        let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n+        let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n+        let src = build.out.join(host).join(\"doc\");\n         cp_r(&src, &dst);\n+\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust-Documentation\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rust-documentation-is-installed.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(\"--component-name=rust-docs\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--bulk-dirs=share/doc/rust/html\");\n+        build.run(&mut cmd);\n+        t!(fs::remove_dir_all(&image));\n+\n+        // As part of this step, *also* copy the docs directory to a directory which\n+        // buildbot typically uploads.\n+        if host == build.build {\n+            let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n+            t!(fs::create_dir_all(&dst));\n+            cp_r(&src, &dst);\n+        }\n     }\n }\n \n@@ -245,37 +260,48 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n //              dist::mingw(build, s.target)\n //          }\n //      });\n-//\n-/// Build the `rust-mingw` installer component.\n-///\n-/// This contains all the bits and pieces to run the MinGW Windows targets\n-/// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n-pub fn mingw(build: &Build, host: &str) {\n-    println!(\"Dist mingw ({})\", host);\n-    let name = pkgname(build, \"rust-mingw\");\n-    let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n-    let _ = fs::remove_dir_all(&image);\n-    t!(fs::create_dir_all(&image));\n \n-    // The first argument is a \"temporary directory\" which is just\n-    // thrown away (this contains the runtime DLLs included in the rustc package\n-    // above) and the second argument is where to place all the MinGW components\n-    // (which is what we want).\n-    make_win_dist(&tmpdir(build), &image, host, &build);\n+#[derive(Serialize)]\n+pub struct Mingw<'a> {\n+    host: &'a str,\n+}\n \n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"generate\")\n-       .arg(\"--product-name=Rust-MinGW\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=Rust-MinGW-is-installed.\")\n-       .arg(\"--image-dir\").arg(&image)\n-       .arg(\"--work-dir\").arg(&tmpdir(build))\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(format!(\"--package-name={}-{}\", name, host))\n-       .arg(\"--component-name=rust-mingw\")\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-    build.run(&mut cmd);\n-    t!(fs::remove_dir_all(&image));\n+impl<'a> Step<'a> for Mingw<'a> {\n+    type Output = ();\n+\n+    /// Build the `rust-mingw` installer component.\n+    ///\n+    /// This contains all the bits and pieces to run the MinGW Windows targets\n+    /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let host = self.host;\n+        println!(\"Dist mingw ({})\", host);\n+        let name = pkgname(build, \"rust-mingw\");\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let _ = fs::remove_dir_all(&image);\n+        t!(fs::create_dir_all(&image));\n+\n+        // The first argument is a \"temporary directory\" which is just\n+        // thrown away (this contains the runtime DLLs included in the rustc package\n+        // above) and the second argument is where to place all the MinGW components\n+        // (which is what we want).\n+        make_win_dist(&tmpdir(build), &image, host, &build);\n+\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust-MinGW\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rust-MinGW-is-installed.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(\"--component-name=rust-mingw\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+        build.run(&mut cmd);\n+        t!(fs::remove_dir_all(&image));\n+    }\n }\n \n // rules.dist(\"dist-rustc\", \"src/librustc\")\n@@ -285,138 +311,166 @@ pub fn mingw(build: &Build, host: &str) {\n //      .default(true)\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::rustc(build, s.stage, s.target));\n-/// Creates the `rustc` installer component.\n-pub fn rustc(build: &Build, stage: u32, host: &str) {\n-    println!(\"Dist rustc stage{} ({})\", stage, host);\n-    let name = pkgname(build, \"rustc\");\n-    let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n-    let _ = fs::remove_dir_all(&image);\n-    let overlay = tmpdir(build).join(format!(\"{}-{}-overlay\", name, host));\n-    let _ = fs::remove_dir_all(&overlay);\n-\n-    // Prepare the rustc \"image\", what will actually end up getting installed\n-    prepare_image(build, stage, host, &image);\n-\n-    // Prepare the overlay which is part of the tarball but won't actually be\n-    // installed\n-    let cp = |file: &str| {\n-        install(&build.src.join(file), &overlay, 0o644);\n-    };\n-    cp(\"COPYRIGHT\");\n-    cp(\"LICENSE-APACHE\");\n-    cp(\"LICENSE-MIT\");\n-    cp(\"README.md\");\n-    // tiny morsel of metadata is used by rust-packaging\n-    let version = build.rust_version();\n-    t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n-\n-    // On MinGW we've got a few runtime DLL dependencies that we need to\n-    // include. The first argument to this script is where to put these DLLs\n-    // (the image we're creating), and the second argument is a junk directory\n-    // to ignore all other MinGW stuff the script creates.\n-    //\n-    // On 32-bit MinGW we're always including a DLL which needs some extra\n-    // licenses to distribute. On 64-bit MinGW we don't actually distribute\n-    // anything requiring us to distribute a license, but it's likely the\n-    // install will *also* include the rust-mingw package, which also needs\n-    // licenses, so to be safe we just include it here in all MinGW packages.\n-    if host.contains(\"pc-windows-gnu\") {\n-        make_win_dist(&image, &tmpdir(build), host, build);\n-\n-        let dst = image.join(\"share/doc\");\n-        t!(fs::create_dir_all(&dst));\n-        cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n-    }\n \n-    // Finally, wrap everything up in a nice tarball!\n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"generate\")\n-       .arg(\"--product-name=Rust\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-       .arg(\"--image-dir\").arg(&image)\n-       .arg(\"--work-dir\").arg(&tmpdir(build))\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(\"--non-installed-overlay\").arg(&overlay)\n-       .arg(format!(\"--package-name={}-{}\", name, host))\n-       .arg(\"--component-name=rustc\")\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-    build.run(&mut cmd);\n-    t!(fs::remove_dir_all(&image));\n-    t!(fs::remove_dir_all(&overlay));\n-\n-    fn prepare_image(build: &Build, stage: u32, host: &str, image: &Path) {\n-        let src = build.sysroot(&Compiler::new(stage, host));\n-        let libdir = libdir(host);\n-\n-        // Copy rustc/rustdoc binaries\n-        t!(fs::create_dir_all(image.join(\"bin\")));\n-        cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n-\n-        // Copy runtime DLLs needed by the compiler\n-        if libdir != \"bin\" {\n-            for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n-                let name = entry.file_name();\n-                if let Some(s) = name.to_str() {\n-                    if is_dylib(s) {\n-                        install(&entry.path(), &image.join(libdir), 0o644);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Man pages\n-        t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n-        cp_r(&build.src.join(\"man\"), &image.join(\"share/man/man1\"));\n-\n-        // Debugger scripts\n-        debugger_scripts(build, &image, host);\n+#[derive(Serialize)]\n+pub struct Rustc<'a> {\n+    stage: u32,\n+    host: &'a str,\n+}\n \n-        // Misc license info\n+impl<'a> Step<'a> for Rustc<'a> {\n+    type Output = ();\n+\n+    /// Creates the `rustc` installer component.\n+    fn run(self, builder: &builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let host = self.host;\n+        println!(\"Dist rustc stage{} ({})\", stage, host);\n+        let name = pkgname(build, \"rustc\");\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let _ = fs::remove_dir_all(&image);\n+        let overlay = tmpdir(build).join(format!(\"{}-{}-overlay\", name, host));\n+        let _ = fs::remove_dir_all(&overlay);\n+\n+        // Prepare the rustc \"image\", what will actually end up getting installed\n+        prepare_image(build, stage, host, &image);\n+\n+        // Prepare the overlay which is part of the tarball but won't actually be\n+        // installed\n         let cp = |file: &str| {\n-            install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n+            install(&build.src.join(file), &overlay, 0o644);\n         };\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n         cp(\"README.md\");\n+        // tiny morsel of metadata is used by rust-packaging\n+        let version = build.rust_version();\n+        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+\n+        // On MinGW we've got a few runtime DLL dependencies that we need to\n+        // include. The first argument to this script is where to put these DLLs\n+        // (the image we're creating), and the second argument is a junk directory\n+        // to ignore all other MinGW stuff the script creates.\n+        //\n+        // On 32-bit MinGW we're always including a DLL which needs some extra\n+        // licenses to distribute. On 64-bit MinGW we don't actually distribute\n+        // anything requiring us to distribute a license, but it's likely the\n+        // install will *also* include the rust-mingw package, which also needs\n+        // licenses, so to be safe we just include it here in all MinGW packages.\n+        if host.contains(\"pc-windows-gnu\") {\n+            make_win_dist(&image, &tmpdir(build), host, build);\n+\n+            let dst = image.join(\"share/doc\");\n+            t!(fs::create_dir_all(&dst));\n+            cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n+        }\n+\n+        // Finally, wrap everything up in a nice tarball!\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rust-is-ready-to-roll.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--non-installed-overlay\").arg(&overlay)\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(\"--component-name=rustc\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+        build.run(&mut cmd);\n+        t!(fs::remove_dir_all(&image));\n+        t!(fs::remove_dir_all(&overlay));\n+\n+        fn prepare_image(build: &Build, stage: u32, host: &str, image: &Path) {\n+            let src = build.sysroot(&Compiler::new(stage, host));\n+            let libdir = libdir(host);\n+\n+            // Copy rustc/rustdoc binaries\n+            t!(fs::create_dir_all(image.join(\"bin\")));\n+            cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n+\n+            // Copy runtime DLLs needed by the compiler\n+            if libdir != \"bin\" {\n+                for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n+                    let name = entry.file_name();\n+                    if let Some(s) = name.to_str() {\n+                        if is_dylib(s) {\n+                            install(&entry.path(), &image.join(libdir), 0o644);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Man pages\n+            t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n+            cp_r(&build.src.join(\"man\"), &image.join(\"share/man/man1\"));\n+\n+            // Debugger scripts\n+            debugger_scripts(build, &image, host);\n+\n+            // Misc license info\n+            let cp = |file: &str| {\n+                install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n+            };\n+            cp(\"COPYRIGHT\");\n+            cp(\"LICENSE-APACHE\");\n+            cp(\"LICENSE-MIT\");\n+            cp(\"README.md\");\n+        }\n     }\n }\n \n+\n+\n //rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n //     .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n //                                     s.target));\n-/// Copies debugger scripts for `host` into the `sysroot` specified.\n-pub fn debugger_scripts(build: &Build,\n-                        sysroot: &Path,\n-                        host: &str) {\n-    let dst = sysroot.join(\"lib/rustlib/etc\");\n-    t!(fs::create_dir_all(&dst));\n-    let cp_debugger_script = |file: &str| {\n-        install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n-    };\n-    if host.contains(\"windows-msvc\") {\n-        // windbg debugger scripts\n-        install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n-            0o755);\n-\n-        cp_debugger_script(\"natvis/liballoc.natvis\");\n-        cp_debugger_script(\"natvis/libcore.natvis\");\n-    } else {\n-        cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n-        // gdb debugger scripts\n-        install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n-                0o755);\n+#[derive(Serialize)]\n+pub struct DebuggerScripts<'a> {\n+    sysroot: &'a Path,\n+    host: &'a str,\n+}\n \n-        cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n-        cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n+impl<'a> Step<'a> for DebuggerScripts<'a> {\n+    type Output = ();\n \n-        // lldb debugger scripts\n-        install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n+    /// Copies debugger scripts for `host` into the `sysroot` specified.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let host = self.host;\n+        let sysroot = self.sysroot;\n+        let dst = sysroot.join(\"lib/rustlib/etc\");\n+        t!(fs::create_dir_all(&dst));\n+        let cp_debugger_script = |file: &str| {\n+            install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n+        };\n+        if host.contains(\"windows-msvc\") {\n+            // windbg debugger scripts\n+            install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n \n-        cp_debugger_script(\"lldb_rust_formatters.py\");\n+            cp_debugger_script(\"natvis/liballoc.natvis\");\n+            cp_debugger_script(\"natvis/libcore.natvis\");\n+        } else {\n+            cp_debugger_script(\"debugger_pretty_printers_common.py\");\n+\n+            // gdb debugger scripts\n+            install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n+                    0o755);\n+\n+            cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n+            cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n+\n+            // lldb debugger scripts\n+            install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n+                    0o755);\n+\n+            cp_debugger_script(\"lldb_rust_formatters.py\");\n+        }\n     }\n }\n \n@@ -435,18 +489,6 @@ pub fn debugger_scripts(build: &Build,\n //      .only_host_build(true)\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::std(build, &s.compiler(), s.target));\n-/// Creates the `rust-std` installer component as compiled by `compiler` for the\n-/// target `target`.\n-pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n-    println!(\"Dist std stage{} ({} -> {})\", compiler.stage, compiler.host,\n-             target);\n-\n-    // The only true set of target libraries came from the build triple, so\n-    // let's reduce redundant work by only producing archives from that host.\n-    if compiler.host != build.build {\n-        println!(\"\\tskipping, not a build host\");\n-        return\n-    }\n \n     let name = pkgname(build, \"rust-std\");\n     let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n@@ -491,48 +533,62 @@ pub fn rust_src_installer(build: &Build) -> PathBuf {\n //      .only_host_build(true)\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::analysis(build, &s.compiler(), s.target));\n-/// Creates a tarball of save-analysis metadata, if available.\n-pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n-    assert!(build.config.extended);\n-    println!(\"Dist analysis\");\n-\n-    if compiler.host != build.build {\n-        println!(\"\\tskipping, not a build host\");\n-        return;\n-    }\n \n-    // Package save-analysis from stage1 if not doing a full bootstrap, as the\n-    // stage2 artifacts is simply copied from stage1 in that case.\n-    let compiler = if build.force_use_stage1(compiler, target) {\n-        Compiler::new(1, compiler.host)\n-    } else {\n-        compiler.clone()\n-    };\n+#[derive(Serialize)]\n+pub struct Analysis<'a> {\n+    compiler: Compiler<'a>,\n+    target: &'a str,\n+}\n \n-    let name = pkgname(build, \"rust-analysis\");\n-    let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+impl<'a> Step<'a> for Analysis<'a> {\n+    type Output = ();\n \n-    let src = build.stage_out(&compiler, Mode::Libstd).join(target).join(\"release\").join(\"deps\");\n+    /// Creates a tarball of save-analysis metadata, if available.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        assert!(build.config.extended);\n+        println!(\"Dist analysis\");\n \n-    let image_src = src.join(\"save-analysis\");\n-    let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n-    t!(fs::create_dir_all(&dst));\n-    println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n-    cp_r(&image_src, &dst);\n+        if compiler.host != build.build {\n+            println!(\"\\tskipping, not a build host\");\n+            return;\n+        }\n \n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"generate\")\n-       .arg(\"--product-name=Rust\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=save-analysis-saved.\")\n-       .arg(\"--image-dir\").arg(&image)\n-       .arg(\"--work-dir\").arg(&tmpdir(build))\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(format!(\"--package-name={}-{}\", name, target))\n-       .arg(format!(\"--component-name=rust-analysis-{}\", target))\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-    build.run(&mut cmd);\n-    t!(fs::remove_dir_all(&image));\n+        // Package save-analysis from stage1 if not doing a full bootstrap, as the\n+        // stage2 artifacts is simply copied from stage1 in that case.\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            Compiler::new(1, compiler.host)\n+        } else {\n+            compiler.clone()\n+        };\n+\n+        let name = pkgname(build, \"rust-analysis\");\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+\n+        let src = build.stage_out(&compiler, Mode::Libstd).join(target).join(\"release\").join(\"deps\");\n+\n+        let image_src = src.join(\"save-analysis\");\n+        let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n+        t!(fs::create_dir_all(&dst));\n+        println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n+        cp_r(&image_src, &dst);\n+\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=save-analysis-saved.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(format!(\"--component-name=rust-analysis-{}\", target))\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+        build.run(&mut cmd);\n+        t!(fs::remove_dir_all(&image));\n+    }\n }\n \n fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n@@ -582,69 +638,78 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n //      .only_host_build(true)\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |_| dist::rust_src(build));\n-/// Creates the `rust-src` installer component\n-pub fn rust_src(build: &Build) {\n-    println!(\"Dist src\");\n-\n-    let name = pkgname(build, \"rust-src\");\n-    let image = tmpdir(build).join(format!(\"{}-image\", name));\n-    let _ = fs::remove_dir_all(&image);\n \n-    let dst = image.join(\"lib/rustlib/src\");\n-    let dst_src = dst.join(\"rust\");\n-    t!(fs::create_dir_all(&dst_src));\n-\n-    // This is the reduced set of paths which will become the rust-src component\n-    // (essentially libstd and all of its path dependencies)\n-    let std_src_dirs = [\n-        \"src/build_helper\",\n-        \"src/liballoc\",\n-        \"src/liballoc_jemalloc\",\n-        \"src/liballoc_system\",\n-        \"src/libbacktrace\",\n-        \"src/libcollections\",\n-        \"src/libcompiler_builtins\",\n-        \"src/libcore\",\n-        \"src/liblibc\",\n-        \"src/libpanic_abort\",\n-        \"src/libpanic_unwind\",\n-        \"src/librand\",\n-        \"src/librustc_asan\",\n-        \"src/librustc_lsan\",\n-        \"src/librustc_msan\",\n-        \"src/librustc_tsan\",\n-        \"src/libstd\",\n-        \"src/libstd_unicode\",\n-        \"src/libunwind\",\n-        \"src/rustc/compiler_builtins_shim\",\n-        \"src/rustc/libc_shim\",\n-        \"src/libtest\",\n-        \"src/libterm\",\n-        \"src/jemalloc\",\n-        \"src/libprofiler_builtins\",\n-    ];\n-    let std_src_dirs_exclude = [\n-        \"src/compiler-rt/test\",\n-        \"src/jemalloc/test/unit\",\n-    ];\n-\n-    copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n+#[derive(Serialize)]\n+pub struct Src;\n+\n+impl<'a> Step<'a> for Src {\n+    type Output = ();\n+\n+    /// Creates the `rust-src` installer component\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        println!(\"Dist src\");\n+\n+        let name = pkgname(build, \"rust-src\");\n+        let image = tmpdir(build).join(format!(\"{}-image\", name));\n+        let _ = fs::remove_dir_all(&image);\n+\n+        let dst = image.join(\"lib/rustlib/src\");\n+        let dst_src = dst.join(\"rust\");\n+        t!(fs::create_dir_all(&dst_src));\n+\n+        // This is the reduced set of paths which will become the rust-src component\n+        // (essentially libstd and all of its path dependencies)\n+        let std_src_dirs = [\n+            \"src/build_helper\",\n+            \"src/liballoc\",\n+            \"src/liballoc_jemalloc\",\n+            \"src/liballoc_system\",\n+            \"src/libbacktrace\",\n+            \"src/libcollections\",\n+            \"src/libcompiler_builtins\",\n+            \"src/libcore\",\n+            \"src/liblibc\",\n+            \"src/libpanic_abort\",\n+            \"src/libpanic_unwind\",\n+            \"src/librand\",\n+            \"src/librustc_asan\",\n+            \"src/librustc_lsan\",\n+            \"src/librustc_msan\",\n+            \"src/librustc_tsan\",\n+            \"src/libstd\",\n+            \"src/libstd_unicode\",\n+            \"src/libunwind\",\n+            \"src/rustc/compiler_builtins_shim\",\n+            \"src/rustc/libc_shim\",\n+            \"src/libtest\",\n+            \"src/libterm\",\n+            \"src/jemalloc\",\n+            \"src/libprofiler_builtins\",\n+        ];\n+        let std_src_dirs_exclude = [\n+            \"src/compiler-rt/test\",\n+            \"src/jemalloc/test/unit\",\n+        ];\n \n-    // Create source tarball in rust-installer format\n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"generate\")\n-       .arg(\"--product-name=Rust\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=Awesome-Source.\")\n-       .arg(\"--image-dir\").arg(&image)\n-       .arg(\"--work-dir\").arg(&tmpdir(build))\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(format!(\"--package-name={}\", name))\n-       .arg(\"--component-name=rust-src\")\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-    build.run(&mut cmd);\n+        copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n+\n+        // Create source tarball in rust-installer format\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Awesome-Source.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(format!(\"--package-name={}\", name))\n+           .arg(\"--component-name=rust-src\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+        build.run(&mut cmd);\n \n-    t!(fs::remove_dir_all(&image));\n+        t!(fs::remove_dir_all(&image));\n+    }\n }\n \n const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n@@ -656,82 +721,91 @@ const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n //      .only_host_build(true)\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |_| dist::plain_source_tarball(build));\n-/// Creates the plain source tarball\n-pub fn plain_source_tarball(build: &Build) {\n-    println!(\"Create plain source tarball\");\n-\n-    // Make sure that the root folder of tarball has the correct name\n-    let plain_name = format!(\"{}-src\", pkgname(build, \"rustc\"));\n-    let plain_dst_src = tmpdir(build).join(&plain_name);\n-    let _ = fs::remove_dir_all(&plain_dst_src);\n-    t!(fs::create_dir_all(&plain_dst_src));\n-\n-    // This is the set of root paths which will become part of the source package\n-    let src_files = [\n-        \"COPYRIGHT\",\n-        \"LICENSE-APACHE\",\n-        \"LICENSE-MIT\",\n-        \"CONTRIBUTING.md\",\n-        \"README.md\",\n-        \"RELEASES.md\",\n-        \"configure\",\n-        \"x.py\",\n-    ];\n-    let src_dirs = [\n-        \"man\",\n-        \"src\",\n-    ];\n-\n-    copy_src_dirs(build, &src_dirs[..], &[], &plain_dst_src);\n \n-    // Copy the files normally\n-    for item in &src_files {\n-        copy(&build.src.join(item), &plain_dst_src.join(item));\n-    }\n+#[derive(Serialize)]\n+pub struct PlainSourceTarball;\n+\n+impl<'a> Step<'a> for PlainSourceTarball {\n+    type Output = ();\n+\n+    /// Creates the plain source tarball\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        println!(\"Create plain source tarball\");\n+\n+        // Make sure that the root folder of tarball has the correct name\n+        let plain_name = format!(\"{}-src\", pkgname(build, \"rustc\"));\n+        let plain_dst_src = tmpdir(build).join(&plain_name);\n+        let _ = fs::remove_dir_all(&plain_dst_src);\n+        t!(fs::create_dir_all(&plain_dst_src));\n+\n+        // This is the set of root paths which will become part of the source package\n+        let src_files = [\n+            \"COPYRIGHT\",\n+            \"LICENSE-APACHE\",\n+            \"LICENSE-MIT\",\n+            \"CONTRIBUTING.md\",\n+            \"README.md\",\n+            \"RELEASES.md\",\n+            \"configure\",\n+            \"x.py\",\n+        ];\n+        let src_dirs = [\n+            \"man\",\n+            \"src\",\n+        ];\n \n-    // Create the version file\n-    write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n+        copy_src_dirs(build, &src_dirs[..], &[], &plain_dst_src);\n \n-    // If we're building from git sources, we need to vendor a complete distribution.\n-    if build.rust_info.is_git() {\n-        // Get cargo-vendor installed, if it isn't already.\n-        let mut has_cargo_vendor = false;\n-        let mut cmd = Command::new(&build.initial_cargo);\n-        for line in output(cmd.arg(\"install\").arg(\"--list\")).lines() {\n-            has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n+        // Copy the files normally\n+        for item in &src_files {\n+            copy(&build.src.join(item), &plain_dst_src.join(item));\n         }\n-        if !has_cargo_vendor {\n+\n+        // Create the version file\n+        write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n+\n+        // If we're building from git sources, we need to vendor a complete distribution.\n+        if build.rust_info.is_git() {\n+            // Get cargo-vendor installed, if it isn't already.\n+            let mut has_cargo_vendor = false;\n+            let mut cmd = Command::new(&build.initial_cargo);\n+            for line in output(cmd.arg(\"install\").arg(\"--list\")).lines() {\n+                has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n+            }\n+            if !has_cargo_vendor {\n+                let mut cmd = Command::new(&build.initial_cargo);\n+                cmd.arg(\"install\")\n+                   .arg(\"--force\")\n+                   .arg(\"--debug\")\n+                   .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n+                   .arg(\"cargo-vendor\")\n+                   .env(\"RUSTC\", &build.initial_rustc);\n+                build.run(&mut cmd);\n+            }\n+\n+            // Vendor all Cargo dependencies\n             let mut cmd = Command::new(&build.initial_cargo);\n-            cmd.arg(\"install\")\n-               .arg(\"--force\")\n-               .arg(\"--debug\")\n-               .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n-               .arg(\"cargo-vendor\")\n-               .env(\"RUSTC\", &build.initial_rustc);\n+            cmd.arg(\"vendor\")\n+               .current_dir(&plain_dst_src.join(\"src\"));\n             build.run(&mut cmd);\n         }\n \n-        // Vendor all Cargo dependencies\n-        let mut cmd = Command::new(&build.initial_cargo);\n-        cmd.arg(\"vendor\")\n-           .current_dir(&plain_dst_src.join(\"src\"));\n+        // Create plain source tarball\n+        let mut tarball = rust_src_location(build);\n+        tarball.set_extension(\"\"); // strip .gz\n+        tarball.set_extension(\"\"); // strip .tar\n+        if let Some(dir) = tarball.parent() {\n+            t!(fs::create_dir_all(dir));\n+        }\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"tarball\")\n+           .arg(\"--input\").arg(&plain_name)\n+           .arg(\"--output\").arg(&tarball)\n+           .arg(\"--work-dir=.\")\n+           .current_dir(tmpdir(build));\n         build.run(&mut cmd);\n     }\n-\n-    // Create plain source tarball\n-    let mut tarball = rust_src_location(build);\n-    tarball.set_extension(\"\"); // strip .gz\n-    tarball.set_extension(\"\"); // strip .tar\n-    if let Some(dir) = tarball.parent() {\n-        t!(fs::create_dir_all(dir));\n-    }\n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"tarball\")\n-       .arg(\"--input\").arg(&plain_name)\n-       .arg(\"--output\").arg(&tarball)\n-       .arg(\"--work-dir=.\")\n-       .current_dir(tmpdir(build));\n-    build.run(&mut cmd);\n }\n \n fn install(src: &Path, dstdir: &Path, perms: u32) {\n@@ -779,64 +853,78 @@ fn write_file(path: &Path, data: &[u8]) {\n //      .dep(|s| s.name(\"tool-cargo\"))\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::cargo(build, s.stage, s.target));\n-pub fn cargo(build: &Build, stage: u32, target: &str) {\n-    println!(\"Dist cargo stage{} ({})\", stage, target);\n-    let compiler = Compiler::new(stage, &build.build);\n-\n-    let src = build.src.join(\"src/tools/cargo\");\n-    let etc = src.join(\"src/etc\");\n-    let release_num = build.release_num(\"cargo\");\n-    let name = pkgname(build, \"cargo\");\n-    let version = build.cargo_info.version(build, &release_num);\n-\n-    let tmp = tmpdir(build);\n-    let image = tmp.join(\"cargo-image\");\n-    drop(fs::remove_dir_all(&image));\n-    t!(fs::create_dir_all(&image));\n-\n-    // Prepare the image directory\n-    t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n-    t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n-    let cargo = build.cargo_out(&compiler, Mode::Tool, target)\n-                     .join(exe(\"cargo\", target));\n-    install(&cargo, &image.join(\"bin\"), 0o755);\n-    for man in t!(etc.join(\"man\").read_dir()) {\n-        let man = t!(man);\n-        install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n+\n+#[derive(Serialize)]\n+pub struct Cargo<'a> {\n+    stage: u32,\n+    target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Cargo<'a> {\n+    type Output = ();\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        println!(\"Dist cargo stage{} ({})\", stage, target);\n+        let compiler = Compiler::new(stage, &build.build);\n+\n+        let src = build.src.join(\"src/tools/cargo\");\n+        let etc = src.join(\"src/etc\");\n+        let release_num = build.release_num(\"cargo\");\n+        let name = pkgname(build, \"cargo\");\n+        let version = build.cargo_info.version(build, &release_num);\n+\n+        let tmp = tmpdir(build);\n+        let image = tmp.join(\"cargo-image\");\n+        drop(fs::remove_dir_all(&image));\n+        t!(fs::create_dir_all(&image));\n+\n+        // Prepare the image directory\n+        t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n+        t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n+        let cargo = build.cargo_out(&compiler, Mode::Tool, target)\n+                         .join(exe(\"cargo\", target));\n+        install(&cargo, &image.join(\"bin\"), 0o755);\n+        for man in t!(etc.join(\"man\").read_dir()) {\n+            let man = t!(man);\n+            install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n+        }\n+        install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n+        copy(&etc.join(\"cargo.bashcomp.sh\"),\n+             &image.join(\"etc/bash_completion.d/cargo\"));\n+        let doc = image.join(\"share/doc/cargo\");\n+        install(&src.join(\"README.md\"), &doc, 0o644);\n+        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"cargo-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        t!(fs::create_dir_all(&overlay));\n+        install(&src.join(\"README.md\"), &overlay, 0o644);\n+        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n+        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rust-is-ready-to-roll.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--non-installed-overlay\").arg(&overlay)\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(\"--component-name=cargo\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+        build.run(&mut cmd);\n     }\n-    install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-    copy(&etc.join(\"cargo.bashcomp.sh\"),\n-         &image.join(\"etc/bash_completion.d/cargo\"));\n-    let doc = image.join(\"share/doc/cargo\");\n-    install(&src.join(\"README.md\"), &doc, 0o644);\n-    install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-    install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-    install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n-\n-    // Prepare the overlay\n-    let overlay = tmp.join(\"cargo-overlay\");\n-    drop(fs::remove_dir_all(&overlay));\n-    t!(fs::create_dir_all(&overlay));\n-    install(&src.join(\"README.md\"), &overlay, 0o644);\n-    install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-    install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-    install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n-    t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n-\n-    // Generate the installer tarball\n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"generate\")\n-       .arg(\"--product-name=Rust\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-       .arg(\"--image-dir\").arg(&image)\n-       .arg(\"--work-dir\").arg(&tmpdir(build))\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(\"--non-installed-overlay\").arg(&overlay)\n-       .arg(format!(\"--package-name={}-{}\", name, target))\n-       .arg(\"--component-name=cargo\")\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-    build.run(&mut cmd);\n }\n \n // rules.dist(\"dist-rls\", \"rls\")\n@@ -845,53 +933,66 @@ pub fn cargo(build: &Build, stage: u32, target: &str) {\n //      .dep(|s| s.name(\"tool-rls\"))\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::rls(build, s.stage, s.target));\n-pub fn rls(build: &Build, stage: u32, target: &str) {\n-    assert!(build.config.extended);\n-    println!(\"Dist RLS stage{} ({})\", stage, target);\n-    let compiler = Compiler::new(stage, &build.build);\n-\n-    let src = build.src.join(\"src/tools/rls\");\n-    let release_num = build.release_num(\"rls\");\n-    let name = pkgname(build, \"rls\");\n-    let version = build.rls_info.version(build, &release_num);\n-\n-    let tmp = tmpdir(build);\n-    let image = tmp.join(\"rls-image\");\n-    drop(fs::remove_dir_all(&image));\n-    t!(fs::create_dir_all(&image));\n-\n-    // Prepare the image directory\n-    let rls = build.cargo_out(&compiler, Mode::Tool, target)\n-                     .join(exe(\"rls\", target));\n-    install(&rls, &image.join(\"bin\"), 0o755);\n-    let doc = image.join(\"share/doc/rls\");\n-    install(&src.join(\"README.md\"), &doc, 0o644);\n-    install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-    install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-\n-    // Prepare the overlay\n-    let overlay = tmp.join(\"rls-overlay\");\n-    drop(fs::remove_dir_all(&overlay));\n-    t!(fs::create_dir_all(&overlay));\n-    install(&src.join(\"README.md\"), &overlay, 0o644);\n-    install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-    install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-    t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n-\n-    // Generate the installer tarball\n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"generate\")\n-       .arg(\"--product-name=Rust\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=RLS-ready-to-serve.\")\n-       .arg(\"--image-dir\").arg(&image)\n-       .arg(\"--work-dir\").arg(&tmpdir(build))\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(\"--non-installed-overlay\").arg(&overlay)\n-       .arg(format!(\"--package-name={}-{}\", name, target))\n-       .arg(\"--component-name=rls\")\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-    build.run(&mut cmd);\n+#[derive(Serialize)]\n+pub struct Rls<'a> {\n+    stage: u32,\n+    target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Rls<'a> {\n+    type Output = ();\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        assert!(build.config.extended);\n+        println!(\"Dist RLS stage{} ({})\", stage, target);\n+        let compiler = Compiler::new(stage, &build.build);\n+\n+        let src = build.src.join(\"src/tools/rls\");\n+        let release_num = build.release_num(\"rls\");\n+        let name = pkgname(build, \"rls\");\n+        let version = build.rls_info.version(build, &release_num);\n+\n+        let tmp = tmpdir(build);\n+        let image = tmp.join(\"rls-image\");\n+        drop(fs::remove_dir_all(&image));\n+        t!(fs::create_dir_all(&image));\n+\n+        // Prepare the image directory\n+        let rls = build.cargo_out(&compiler, Mode::Tool, target)\n+                         .join(exe(\"rls\", target));\n+        install(&rls, &image.join(\"bin\"), 0o755);\n+        let doc = image.join(\"share/doc/rls\");\n+        install(&src.join(\"README.md\"), &doc, 0o644);\n+        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"rls-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        t!(fs::create_dir_all(&overlay));\n+        install(&src.join(\"README.md\"), &overlay, 0o644);\n+        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=RLS-ready-to-serve.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--non-installed-overlay\").arg(&overlay)\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(\"--component-name=rls\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+        build.run(&mut cmd);\n+    }\n }\n \n // rules.dist(\"dist-extended\", \"extended\")\n@@ -908,358 +1009,372 @@ pub fn rls(build: &Build, stage: u32, target: &str) {\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::extended(build, s.stage, s.target));\n \n-/// Creates a combined installer for the specified target in the provided stage.\n-pub fn extended(build: &Build, stage: u32, target: &str) {\n-    println!(\"Dist extended stage{} ({})\", stage, target);\n-\n-    let dist = distdir(build);\n-    let rustc_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                            pkgname(build, \"rustc\"),\n-                                            target));\n-    let cargo_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                            pkgname(build, \"cargo\"),\n-                                            target));\n-    let rls_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                          pkgname(build, \"rls\"),\n-                                          target));\n-    let analysis_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                               pkgname(build, \"rust-analysis\"),\n-                                               target));\n-    let docs_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                           pkgname(build, \"rust-docs\"),\n-                                           target));\n-    let mingw_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                            pkgname(build, \"rust-mingw\"),\n-                                            target));\n-    let std_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                          pkgname(build, \"rust-std\"),\n-                                          target));\n-\n-    let tmp = tmpdir(build);\n-    let overlay = tmp.join(\"extended-overlay\");\n-    let etc = build.src.join(\"src/etc/installer\");\n-    let work = tmp.join(\"work\");\n-\n-    let _ = fs::remove_dir_all(&overlay);\n-    install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n-    install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-    install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-    let version = build.rust_version();\n-    t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n-    install(&etc.join(\"README.md\"), &overlay, 0o644);\n-\n-    // When rust-std package split from rustc, we needed to ensure that during\n-    // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n-    // the std files during uninstall. To do this ensure that rustc comes\n-    // before rust-std in the list below.\n-    let mut tarballs = vec![rustc_installer, cargo_installer, rls_installer,\n-                            analysis_installer, docs_installer, std_installer];\n-    if target.contains(\"pc-windows-gnu\") {\n-        tarballs.push(mingw_installer);\n-    }\n-    let mut input_tarballs = tarballs[0].as_os_str().to_owned();\n-    for tarball in &tarballs[1..] {\n-        input_tarballs.push(\",\");\n-        input_tarballs.push(tarball);\n-    }\n+#[derive(Serialize)]\n+pub struct Extended<'a> {\n+    stage: u32,\n+    target: &'a str,\n+}\n \n-    let mut cmd = rust_installer(build);\n-    cmd.arg(\"combine\")\n-       .arg(\"--product-name=Rust\")\n-       .arg(\"--rel-manifest-dir=rustlib\")\n-       .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-       .arg(\"--work-dir\").arg(&work)\n-       .arg(\"--output-dir\").arg(&distdir(build))\n-       .arg(format!(\"--package-name={}-{}\", pkgname(build, \"rust\"), target))\n-       .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-       .arg(\"--input-tarballs\").arg(input_tarballs)\n-       .arg(\"--non-installed-overlay\").arg(&overlay);\n-    build.run(&mut cmd);\n+impl<'a> Step<'a> for Extended<'a> {\n+    type Output = ();\n+\n+    /// Creates a combined installer for the specified target in the provided stage.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+\n+        println!(\"Dist extended stage{} ({})\", stage, target);\n+\n+        let dist = distdir(build);\n+        let rustc_installer = dist.join(format!(\"{}-{}.tar.gz\",\n+                                                pkgname(build, \"rustc\"),\n+                                                target));\n+        let cargo_installer = dist.join(format!(\"{}-{}.tar.gz\",\n+                                                pkgname(build, \"cargo\"),\n+                                                target));\n+        let rls_installer = dist.join(format!(\"{}-{}.tar.gz\",\n+                                                pkgname(build, \"rls\"),\n+                                                target));\n+        let analysis_installer = dist.join(format!(\"{}-{}.tar.gz\",\n+                                                    pkgname(build, \"rust-analysis\"),\n+                                                    target));\n+        let docs_installer = dist.join(format!(\"{}-{}.tar.gz\",\n+                                                pkgname(build, \"rust-docs\"),\n+                                                target));\n+        let mingw_installer = dist.join(format!(\"{}-{}.tar.gz\",\n+                                                pkgname(build, \"rust-mingw\"),\n+                                                target));\n+        let std_installer = dist.join(format!(\"{}-{}.tar.gz\",\n+                                                pkgname(build, \"rust-std\"),\n+                                                target));\n+\n+        let tmp = tmpdir(build);\n+        let overlay = tmp.join(\"extended-overlay\");\n+        let etc = build.src.join(\"src/etc/installer\");\n+        let work = tmp.join(\"work\");\n+\n+        let _ = fs::remove_dir_all(&overlay);\n+        install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n+        install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        let version = build.rust_version();\n+        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        install(&etc.join(\"README.md\"), &overlay, 0o644);\n+\n+        // When rust-std package split from rustc, we needed to ensure that during\n+        // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n+        // the std files during uninstall. To do this ensure that rustc comes\n+        // before rust-std in the list below.\n+        let mut tarballs = vec![rustc_installer, cargo_installer, rls_installer,\n+                                analysis_installer, docs_installer, std_installer];\n+        if target.contains(\"pc-windows-gnu\") {\n+            tarballs.push(mingw_installer);\n+        }\n+        let mut input_tarballs = tarballs[0].as_os_str().to_owned();\n+        for tarball in &tarballs[1..] {\n+            input_tarballs.push(\",\");\n+            input_tarballs.push(tarball);\n+        }\n \n-    let mut license = String::new();\n-    t!(t!(File::open(build.src.join(\"COPYRIGHT\"))).read_to_string(&mut license));\n-    license.push_str(\"\\n\");\n-    t!(t!(File::open(build.src.join(\"LICENSE-APACHE\"))).read_to_string(&mut license));\n-    license.push_str(\"\\n\");\n-    t!(t!(File::open(build.src.join(\"LICENSE-MIT\"))).read_to_string(&mut license));\n-\n-    let rtf = r\"{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\\nowwrap\\fs18\";\n-    let mut rtf = rtf.to_string();\n-    rtf.push_str(\"\\n\");\n-    for line in license.lines() {\n-        rtf.push_str(line);\n-        rtf.push_str(\"\\\\line \");\n-    }\n-    rtf.push_str(\"}\");\n-\n-    if target.contains(\"apple-darwin\") {\n-        let pkg = tmp.join(\"pkg\");\n-        let _ = fs::remove_dir_all(&pkg);\n-        t!(fs::create_dir_all(pkg.join(\"rustc\")));\n-        t!(fs::create_dir_all(pkg.join(\"cargo\")));\n-        t!(fs::create_dir_all(pkg.join(\"rust-docs\")));\n-        t!(fs::create_dir_all(pkg.join(\"rust-std\")));\n-        t!(fs::create_dir_all(pkg.join(\"rls\")));\n-        t!(fs::create_dir_all(pkg.join(\"rust-analysis\")));\n-\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target)),\n-             &pkg.join(\"rustc\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target)),\n-             &pkg.join(\"cargo\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target)),\n-             &pkg.join(\"rust-docs\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target)),\n-             &pkg.join(\"rust-std\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)),\n-             &pkg.join(\"rls\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target)),\n-             &pkg.join(\"rust-analysis\"));\n-\n-        install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rustc\"), 0o755);\n-        install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"cargo\"), 0o755);\n-        install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-docs\"), 0o755);\n-        install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-std\"), 0o755);\n-        install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rls\"), 0o755);\n-        install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-analysis\"), 0o755);\n-\n-        let pkgbuild = |component: &str| {\n-            let mut cmd = Command::new(\"pkgbuild\");\n-            cmd.arg(\"--identifier\").arg(format!(\"org.rust-lang.{}\", component))\n-               .arg(\"--scripts\").arg(pkg.join(component))\n-               .arg(\"--nopayload\")\n-               .arg(pkg.join(component).with_extension(\"pkg\"));\n-            build.run(&mut cmd);\n-        };\n-        pkgbuild(\"rustc\");\n-        pkgbuild(\"cargo\");\n-        pkgbuild(\"rust-docs\");\n-        pkgbuild(\"rust-std\");\n-        pkgbuild(\"rls\");\n-        pkgbuild(\"rust-analysis\");\n-\n-        // create an 'uninstall' package\n-        install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n-        pkgbuild(\"uninstall\");\n-\n-        t!(fs::create_dir_all(pkg.join(\"res\")));\n-        t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n-        install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n-        let mut cmd = Command::new(\"productbuild\");\n-        cmd.arg(\"--distribution\").arg(etc.join(\"pkg/Distribution.xml\"))\n-           .arg(\"--resources\").arg(pkg.join(\"res\"))\n-           .arg(distdir(build).join(format!(\"{}-{}.pkg\",\n-                                             pkgname(build, \"rust\"),\n-                                             target)))\n-           .arg(\"--package-path\").arg(&pkg);\n+        let mut cmd = rust_installer(build);\n+        cmd.arg(\"combine\")\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n+            .arg(\"--work-dir\").arg(&work)\n+            .arg(\"--output-dir\").arg(&distdir(build))\n+            .arg(format!(\"--package-name={}-{}\", pkgname(build, \"rust\"), target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--input-tarballs\").arg(input_tarballs)\n+            .arg(\"--non-installed-overlay\").arg(&overlay);\n         build.run(&mut cmd);\n-    }\n \n-    if target.contains(\"windows\") {\n-        let exe = tmp.join(\"exe\");\n-        let _ = fs::remove_dir_all(&exe);\n-        t!(fs::create_dir_all(exe.join(\"rustc\")));\n-        t!(fs::create_dir_all(exe.join(\"cargo\")));\n-        t!(fs::create_dir_all(exe.join(\"rls\")));\n-        t!(fs::create_dir_all(exe.join(\"rust-analysis\")));\n-        t!(fs::create_dir_all(exe.join(\"rust-docs\")));\n-        t!(fs::create_dir_all(exe.join(\"rust-std\")));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target))\n-                  .join(\"rustc\"),\n-             &exe.join(\"rustc\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target))\n-                  .join(\"cargo\"),\n-             &exe.join(\"cargo\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target))\n-                  .join(\"rust-docs\"),\n-             &exe.join(\"rust-docs\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target))\n-                  .join(format!(\"rust-std-{}\", target)),\n-             &exe.join(\"rust-std\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target))\n-                  .join(\"rls\"),\n-             &exe.join(\"rls\"));\n-        cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target))\n-                  .join(format!(\"rust-analysis-{}\", target)),\n-             &exe.join(\"rust-analysis\"));\n-\n-        t!(fs::remove_file(exe.join(\"rustc/manifest.in\")));\n-        t!(fs::remove_file(exe.join(\"cargo/manifest.in\")));\n-        t!(fs::remove_file(exe.join(\"rust-docs/manifest.in\")));\n-        t!(fs::remove_file(exe.join(\"rust-std/manifest.in\")));\n-        t!(fs::remove_file(exe.join(\"rls/manifest.in\")));\n-        t!(fs::remove_file(exe.join(\"rust-analysis/manifest.in\")));\n-\n-        if target.contains(\"windows-gnu\") {\n-            t!(fs::create_dir_all(exe.join(\"rust-mingw\")));\n-            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-mingw\"), target))\n-                      .join(\"rust-mingw\"),\n-                 &exe.join(\"rust-mingw\"));\n-            t!(fs::remove_file(exe.join(\"rust-mingw/manifest.in\")));\n+        let mut license = String::new();\n+        t!(t!(File::open(build.src.join(\"COPYRIGHT\"))).read_to_string(&mut license));\n+        license.push_str(\"\\n\");\n+        t!(t!(File::open(build.src.join(\"LICENSE-APACHE\"))).read_to_string(&mut license));\n+        license.push_str(\"\\n\");\n+        t!(t!(File::open(build.src.join(\"LICENSE-MIT\"))).read_to_string(&mut license));\n+\n+        let rtf = r\"{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\\nowwrap\\fs18\";\n+        let mut rtf = rtf.to_string();\n+        rtf.push_str(\"\\n\");\n+        for line in license.lines() {\n+            rtf.push_str(line);\n+            rtf.push_str(\"\\\\line \");\n         }\n-\n-        install(&etc.join(\"exe/rust.iss\"), &exe, 0o644);\n-        install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-        install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n-        install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n-        t!(t!(File::create(exe.join(\"LICENSE.txt\"))).write_all(license.as_bytes()));\n-\n-        // Generate exe installer\n-        let mut cmd = Command::new(\"iscc\");\n-        cmd.arg(\"rust.iss\")\n-           .current_dir(&exe);\n-        if target.contains(\"windows-gnu\") {\n-            cmd.arg(\"/dMINGW\");\n+        rtf.push_str(\"}\");\n+\n+        if target.contains(\"apple-darwin\") {\n+            let pkg = tmp.join(\"pkg\");\n+            let _ = fs::remove_dir_all(&pkg);\n+            t!(fs::create_dir_all(pkg.join(\"rustc\")));\n+            t!(fs::create_dir_all(pkg.join(\"cargo\")));\n+            t!(fs::create_dir_all(pkg.join(\"rust-docs\")));\n+            t!(fs::create_dir_all(pkg.join(\"rust-std\")));\n+            t!(fs::create_dir_all(pkg.join(\"rls\")));\n+            t!(fs::create_dir_all(pkg.join(\"rust-analysis\")));\n+\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target)),\n+                    &pkg.join(\"rustc\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target)),\n+                    &pkg.join(\"cargo\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target)),\n+                    &pkg.join(\"rust-docs\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target)),\n+                    &pkg.join(\"rust-std\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)),\n+                    &pkg.join(\"rls\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target)),\n+                    &pkg.join(\"rust-analysis\"));\n+\n+            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rustc\"), 0o755);\n+            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"cargo\"), 0o755);\n+            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-docs\"), 0o755);\n+            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-std\"), 0o755);\n+            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rls\"), 0o755);\n+            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"rust-analysis\"), 0o755);\n+\n+            let pkgbuild = |component: &str| {\n+                let mut cmd = Command::new(\"pkgbuild\");\n+                cmd.arg(\"--identifier\").arg(format!(\"org.rust-lang.{}\", component))\n+                    .arg(\"--scripts\").arg(pkg.join(component))\n+                    .arg(\"--nopayload\")\n+                    .arg(pkg.join(component).with_extension(\"pkg\"));\n+                build.run(&mut cmd);\n+            };\n+            pkgbuild(\"rustc\");\n+            pkgbuild(\"cargo\");\n+            pkgbuild(\"rust-docs\");\n+            pkgbuild(\"rust-std\");\n+            pkgbuild(\"rls\");\n+            pkgbuild(\"rust-analysis\");\n+\n+            // create an 'uninstall' package\n+            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n+            pkgbuild(\"uninstall\");\n+\n+            t!(fs::create_dir_all(pkg.join(\"res\")));\n+            t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n+            install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n+            let mut cmd = Command::new(\"productbuild\");\n+            cmd.arg(\"--distribution\").arg(etc.join(\"pkg/Distribution.xml\"))\n+                .arg(\"--resources\").arg(pkg.join(\"res\"))\n+                .arg(distdir(build).join(format!(\"{}-{}.pkg\",\n+                                                    pkgname(build, \"rust\"),\n+                                                    target)))\n+                .arg(\"--package-path\").arg(&pkg);\n+            build.run(&mut cmd);\n         }\n-        add_env(build, &mut cmd, target);\n-        build.run(&mut cmd);\n-        install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n-                &distdir(build),\n-                0o755);\n \n-        // Generate msi installer\n-        let wix = PathBuf::from(env::var_os(\"WIX\").unwrap());\n-        let heat = wix.join(\"bin/heat.exe\");\n-        let candle = wix.join(\"bin/candle.exe\");\n-        let light = wix.join(\"bin/light.exe\");\n-\n-        let heat_flags = [\"-nologo\", \"-gg\", \"-sfrag\", \"-srd\", \"-sreg\"];\n-        build.run(Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"rustc\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\").arg(\"RustcGroup\")\n-                        .arg(\"-dr\").arg(\"Rustc\")\n-                        .arg(\"-var\").arg(\"var.RustcDir\")\n-                        .arg(\"-out\").arg(exe.join(\"RustcGroup.wxs\")));\n-        build.run(Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"rust-docs\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\").arg(\"DocsGroup\")\n-                        .arg(\"-dr\").arg(\"Docs\")\n-                        .arg(\"-var\").arg(\"var.DocsDir\")\n-                        .arg(\"-out\").arg(exe.join(\"DocsGroup.wxs\"))\n-                        .arg(\"-t\").arg(etc.join(\"msi/squash-components.xsl\")));\n-        build.run(Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"cargo\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\").arg(\"CargoGroup\")\n-                        .arg(\"-dr\").arg(\"Cargo\")\n-                        .arg(\"-var\").arg(\"var.CargoDir\")\n-                        .arg(\"-out\").arg(exe.join(\"CargoGroup.wxs\"))\n-                        .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n-        build.run(Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"rust-std\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\").arg(\"StdGroup\")\n-                        .arg(\"-dr\").arg(\"Std\")\n-                        .arg(\"-var\").arg(\"var.StdDir\")\n-                        .arg(\"-out\").arg(exe.join(\"StdGroup.wxs\")));\n-        build.run(Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"rls\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\").arg(\"RlsGroup\")\n-                        .arg(\"-dr\").arg(\"Rls\")\n-                        .arg(\"-var\").arg(\"var.RlsDir\")\n-                        .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n-                        .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n-        build.run(Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"rust-analysis\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\").arg(\"AnalysisGroup\")\n-                        .arg(\"-dr\").arg(\"Analysis\")\n-                        .arg(\"-var\").arg(\"var.AnalysisDir\")\n-                        .arg(\"-out\").arg(exe.join(\"AnalysisGroup.wxs\"))\n-                        .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n-        if target.contains(\"windows-gnu\") {\n+        if target.contains(\"windows\") {\n+            let exe = tmp.join(\"exe\");\n+            let _ = fs::remove_dir_all(&exe);\n+            t!(fs::create_dir_all(exe.join(\"rustc\")));\n+            t!(fs::create_dir_all(exe.join(\"cargo\")));\n+            t!(fs::create_dir_all(exe.join(\"rls\")));\n+            t!(fs::create_dir_all(exe.join(\"rust-analysis\")));\n+            t!(fs::create_dir_all(exe.join(\"rust-docs\")));\n+            t!(fs::create_dir_all(exe.join(\"rust-std\")));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rustc\"), target))\n+                        .join(\"rustc\"),\n+                    &exe.join(\"rustc\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"cargo\"), target))\n+                        .join(\"cargo\"),\n+                    &exe.join(\"cargo\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-docs\"), target))\n+                        .join(\"rust-docs\"),\n+                    &exe.join(\"rust-docs\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target))\n+                        .join(format!(\"rust-std-{}\", target)),\n+                    &exe.join(\"rust-std\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target))\n+                        .join(\"rls\"),\n+                    &exe.join(\"rls\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target))\n+                        .join(format!(\"rust-analysis-{}\", target)),\n+                    &exe.join(\"rust-analysis\"));\n+\n+            t!(fs::remove_file(exe.join(\"rustc/manifest.in\")));\n+            t!(fs::remove_file(exe.join(\"cargo/manifest.in\")));\n+            t!(fs::remove_file(exe.join(\"rust-docs/manifest.in\")));\n+            t!(fs::remove_file(exe.join(\"rust-std/manifest.in\")));\n+            t!(fs::remove_file(exe.join(\"rls/manifest.in\")));\n+            t!(fs::remove_file(exe.join(\"rust-analysis/manifest.in\")));\n+\n+            if target.contains(\"windows-gnu\") {\n+                t!(fs::create_dir_all(exe.join(\"rust-mingw\")));\n+                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-mingw\"), target))\n+                            .join(\"rust-mingw\"),\n+                        &exe.join(\"rust-mingw\"));\n+                t!(fs::remove_file(exe.join(\"rust-mingw/manifest.in\")));\n+            }\n+\n+            install(&etc.join(\"exe/rust.iss\"), &exe, 0o644);\n+            install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n+            install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n+            install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n+            t!(t!(File::create(exe.join(\"LICENSE.txt\"))).write_all(license.as_bytes()));\n+\n+            // Generate exe installer\n+            let mut cmd = Command::new(\"iscc\");\n+            cmd.arg(\"rust.iss\")\n+                .current_dir(&exe);\n+            if target.contains(\"windows-gnu\") {\n+                cmd.arg(\"/dMINGW\");\n+            }\n+            add_env(build, &mut cmd, target);\n+            build.run(&mut cmd);\n+            install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n+                    &distdir(build),\n+                    0o755);\n+\n+            // Generate msi installer\n+            let wix = PathBuf::from(env::var_os(\"WIX\").unwrap());\n+            let heat = wix.join(\"bin/heat.exe\");\n+            let candle = wix.join(\"bin/candle.exe\");\n+            let light = wix.join(\"bin/light.exe\");\n+\n+            let heat_flags = [\"-nologo\", \"-gg\", \"-sfrag\", \"-srd\", \"-sreg\"];\n             build.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n-                            .arg(\"rust-mingw\")\n+                            .arg(\"rustc\")\n                             .args(&heat_flags)\n-                            .arg(\"-cg\").arg(\"GccGroup\")\n-                            .arg(\"-dr\").arg(\"Gcc\")\n-                            .arg(\"-var\").arg(\"var.GccDir\")\n-                            .arg(\"-out\").arg(exe.join(\"GccGroup.wxs\")));\n-        }\n+                            .arg(\"-cg\").arg(\"RustcGroup\")\n+                            .arg(\"-dr\").arg(\"Rustc\")\n+                            .arg(\"-var\").arg(\"var.RustcDir\")\n+                            .arg(\"-out\").arg(exe.join(\"RustcGroup.wxs\")));\n+            build.run(Command::new(&heat)\n+                            .current_dir(&exe)\n+                            .arg(\"dir\")\n+                            .arg(\"rust-docs\")\n+                            .args(&heat_flags)\n+                            .arg(\"-cg\").arg(\"DocsGroup\")\n+                            .arg(\"-dr\").arg(\"Docs\")\n+                            .arg(\"-var\").arg(\"var.DocsDir\")\n+                            .arg(\"-out\").arg(exe.join(\"DocsGroup.wxs\"))\n+                            .arg(\"-t\").arg(etc.join(\"msi/squash-components.xsl\")));\n+            build.run(Command::new(&heat)\n+                            .current_dir(&exe)\n+                            .arg(\"dir\")\n+                            .arg(\"cargo\")\n+                            .args(&heat_flags)\n+                            .arg(\"-cg\").arg(\"CargoGroup\")\n+                            .arg(\"-dr\").arg(\"Cargo\")\n+                            .arg(\"-var\").arg(\"var.CargoDir\")\n+                            .arg(\"-out\").arg(exe.join(\"CargoGroup.wxs\"))\n+                            .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            build.run(Command::new(&heat)\n+                            .current_dir(&exe)\n+                            .arg(\"dir\")\n+                            .arg(\"rust-std\")\n+                            .args(&heat_flags)\n+                            .arg(\"-cg\").arg(\"StdGroup\")\n+                            .arg(\"-dr\").arg(\"Std\")\n+                            .arg(\"-var\").arg(\"var.StdDir\")\n+                            .arg(\"-out\").arg(exe.join(\"StdGroup.wxs\")));\n+            build.run(Command::new(&heat)\n+                            .current_dir(&exe)\n+                            .arg(\"dir\")\n+                            .arg(\"rls\")\n+                            .args(&heat_flags)\n+                            .arg(\"-cg\").arg(\"RlsGroup\")\n+                            .arg(\"-dr\").arg(\"Rls\")\n+                            .arg(\"-var\").arg(\"var.RlsDir\")\n+                            .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n+                            .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            build.run(Command::new(&heat)\n+                            .current_dir(&exe)\n+                            .arg(\"dir\")\n+                            .arg(\"rust-analysis\")\n+                            .args(&heat_flags)\n+                            .arg(\"-cg\").arg(\"AnalysisGroup\")\n+                            .arg(\"-dr\").arg(\"Analysis\")\n+                            .arg(\"-var\").arg(\"var.AnalysisDir\")\n+                            .arg(\"-out\").arg(exe.join(\"AnalysisGroup.wxs\"))\n+                            .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            if target.contains(\"windows-gnu\") {\n+                build.run(Command::new(&heat)\n+                                .current_dir(&exe)\n+                                .arg(\"dir\")\n+                                .arg(\"rust-mingw\")\n+                                .args(&heat_flags)\n+                                .arg(\"-cg\").arg(\"GccGroup\")\n+                                .arg(\"-dr\").arg(\"Gcc\")\n+                                .arg(\"-var\").arg(\"var.GccDir\")\n+                                .arg(\"-out\").arg(exe.join(\"GccGroup.wxs\")));\n+            }\n \n-        let candle = |input: &Path| {\n-            let output = exe.join(input.file_stem().unwrap())\n-                            .with_extension(\"wixobj\");\n-            let arch = if target.contains(\"x86_64\") {\"x64\"} else {\"x86\"};\n-            let mut cmd = Command::new(&candle);\n-            cmd.current_dir(&exe)\n-               .arg(\"-nologo\")\n-               .arg(\"-dRustcDir=rustc\")\n-               .arg(\"-dDocsDir=rust-docs\")\n-               .arg(\"-dCargoDir=cargo\")\n-               .arg(\"-dStdDir=rust-std\")\n-               .arg(\"-dRlsDir=rls\")\n-               .arg(\"-dAnalysisDir=rust-analysis\")\n-               .arg(\"-arch\").arg(&arch)\n-               .arg(\"-out\").arg(&output)\n-               .arg(&input);\n-            add_env(build, &mut cmd, target);\n+            let candle = |input: &Path| {\n+                let output = exe.join(input.file_stem().unwrap())\n+                                .with_extension(\"wixobj\");\n+                let arch = if target.contains(\"x86_64\") {\"x64\"} else {\"x86\"};\n+                let mut cmd = Command::new(&candle);\n+                cmd.current_dir(&exe)\n+                    .arg(\"-nologo\")\n+                    .arg(\"-dRustcDir=rustc\")\n+                    .arg(\"-dDocsDir=rust-docs\")\n+                    .arg(\"-dCargoDir=cargo\")\n+                    .arg(\"-dStdDir=rust-std\")\n+                    .arg(\"-dRlsDir=rls\")\n+                    .arg(\"-dAnalysisDir=rust-analysis\")\n+                    .arg(\"-arch\").arg(&arch)\n+                    .arg(\"-out\").arg(&output)\n+                    .arg(&input);\n+                add_env(build, &mut cmd, target);\n+\n+                if target.contains(\"windows-gnu\") {\n+                    cmd.arg(\"-dGccDir=rust-mingw\");\n+                }\n+                build.run(&mut cmd);\n+            };\n+            candle(&etc.join(\"msi/rust.wxs\"));\n+            candle(&etc.join(\"msi/ui.wxs\"));\n+            candle(&etc.join(\"msi/rustwelcomedlg.wxs\"));\n+            candle(\"RustcGroup.wxs\".as_ref());\n+            candle(\"DocsGroup.wxs\".as_ref());\n+            candle(\"CargoGroup.wxs\".as_ref());\n+            candle(\"StdGroup.wxs\".as_ref());\n+            candle(\"RlsGroup.wxs\".as_ref());\n+            candle(\"AnalysisGroup.wxs\".as_ref());\n \n             if target.contains(\"windows-gnu\") {\n-               cmd.arg(\"-dGccDir=rust-mingw\");\n+                candle(\"GccGroup.wxs\".as_ref());\n             }\n-            build.run(&mut cmd);\n-        };\n-        candle(&etc.join(\"msi/rust.wxs\"));\n-        candle(&etc.join(\"msi/ui.wxs\"));\n-        candle(&etc.join(\"msi/rustwelcomedlg.wxs\"));\n-        candle(\"RustcGroup.wxs\".as_ref());\n-        candle(\"DocsGroup.wxs\".as_ref());\n-        candle(\"CargoGroup.wxs\".as_ref());\n-        candle(\"StdGroup.wxs\".as_ref());\n-        candle(\"RlsGroup.wxs\".as_ref());\n-        candle(\"AnalysisGroup.wxs\".as_ref());\n-\n-        if target.contains(\"windows-gnu\") {\n-            candle(\"GccGroup.wxs\".as_ref());\n-        }\n \n-        t!(t!(File::create(exe.join(\"LICENSE.rtf\"))).write_all(rtf.as_bytes()));\n-        install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n-        install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n-\n-        let filename = format!(\"{}-{}.msi\", pkgname(build, \"rust\"), target);\n-        let mut cmd = Command::new(&light);\n-        cmd.arg(\"-nologo\")\n-           .arg(\"-ext\").arg(\"WixUIExtension\")\n-           .arg(\"-ext\").arg(\"WixUtilExtension\")\n-           .arg(\"-out\").arg(exe.join(&filename))\n-           .arg(\"rust.wixobj\")\n-           .arg(\"ui.wixobj\")\n-           .arg(\"rustwelcomedlg.wixobj\")\n-           .arg(\"RustcGroup.wixobj\")\n-           .arg(\"DocsGroup.wixobj\")\n-           .arg(\"CargoGroup.wixobj\")\n-           .arg(\"StdGroup.wixobj\")\n-           .arg(\"RlsGroup.wixobj\")\n-           .arg(\"AnalysisGroup.wixobj\")\n-           .current_dir(&exe);\n-\n-        if target.contains(\"windows-gnu\") {\n-           cmd.arg(\"GccGroup.wixobj\");\n-        }\n-        // ICE57 wrongly complains about the shortcuts\n-        cmd.arg(\"-sice:ICE57\");\n+            t!(t!(File::create(exe.join(\"LICENSE.rtf\"))).write_all(rtf.as_bytes()));\n+            install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n+            install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n+\n+            let filename = format!(\"{}-{}.msi\", pkgname(build, \"rust\"), target);\n+            let mut cmd = Command::new(&light);\n+            cmd.arg(\"-nologo\")\n+                .arg(\"-ext\").arg(\"WixUIExtension\")\n+                .arg(\"-ext\").arg(\"WixUtilExtension\")\n+                .arg(\"-out\").arg(exe.join(&filename))\n+                .arg(\"rust.wixobj\")\n+                .arg(\"ui.wixobj\")\n+                .arg(\"rustwelcomedlg.wixobj\")\n+                .arg(\"RustcGroup.wixobj\")\n+                .arg(\"DocsGroup.wixobj\")\n+                .arg(\"CargoGroup.wixobj\")\n+                .arg(\"StdGroup.wixobj\")\n+                .arg(\"RlsGroup.wixobj\")\n+                .arg(\"AnalysisGroup.wixobj\")\n+                .current_dir(&exe);\n \n-        build.run(&mut cmd);\n+            if target.contains(\"windows-gnu\") {\n+                cmd.arg(\"GccGroup.wixobj\");\n+            }\n+            // ICE57 wrongly complains about the shortcuts\n+            cmd.arg(\"-sice:ICE57\");\n+\n+            build.run(&mut cmd);\n \n-        t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+        }\n     }\n }\n \n@@ -1299,36 +1414,44 @@ fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n //      .only_host_build(true)\n //      .dep(move |s| s.name(\"tool-build-manifest\").target(&build.build).stage(0))\n //      .run(move |_| dist::hash_and_sign(build));\n-//\n-pub fn hash_and_sign(build: &Build) {\n-    let compiler = Compiler::new(0, &build.build);\n-    let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");\n-    let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n-        panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n-    });\n-    let addr = build.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n-        panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n-    });\n-    let file = build.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n-        panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n-    });\n-    let mut pass = String::new();\n-    t!(t!(File::open(&file)).read_to_string(&mut pass));\n-\n-    let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n-\n-    cmd.arg(sign);\n-    cmd.arg(distdir(build));\n-    cmd.arg(today.trim());\n-    cmd.arg(build.rust_package_vers());\n-    cmd.arg(build.package_vers(&build.release_num(\"cargo\")));\n-    cmd.arg(build.package_vers(&build.release_num(\"rls\")));\n-    cmd.arg(addr);\n-\n-    t!(fs::create_dir_all(distdir(build)));\n-\n-    let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n-    t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));\n-    let status = t!(child.wait());\n-    assert!(status.success());\n+\n+#[derive(Serialize)]\n+pub struct HashSign;\n+\n+impl<'a> Step<'a> for HashSign {\n+    type Output = ();\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = Compiler::new(0, &build.build);\n+        let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");\n+        let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n+            panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n+        });\n+        let addr = build.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n+            panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n+        });\n+        let file = build.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+            panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n+        });\n+        let mut pass = String::new();\n+        t!(t!(File::open(&file)).read_to_string(&mut pass));\n+\n+        let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n+\n+        cmd.arg(sign);\n+        cmd.arg(distdir(build));\n+        cmd.arg(today.trim());\n+        cmd.arg(build.rust_package_vers());\n+        cmd.arg(build.package_vers(&build.release_num(\"cargo\")));\n+        cmd.arg(build.package_vers(&build.release_num(\"rls\")));\n+        cmd.arg(addr);\n+\n+        t!(fs::create_dir_all(distdir(build)));\n+\n+        let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n+        t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));\n+        let status = t!(child.wait());\n+        assert!(status.success());\n+    }\n }"}, {"sha": "466d63a15acbdd6ce23d2970aa114ccf0f58cd4b", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 384, "deletions": 267, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=001e9f349087124165ed6deea6a87e0b158bba21", "patch": "@@ -45,13 +45,27 @@ use build_helper::up_to_date;\n //      })\n //      .default(build.config.docs)\n //      .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n-/// Invoke `rustbook` for `target` for the doc book `name`.\n-///\n-/// This will not actually generate any documentation if the documentation has\n-/// already been generated.\n-pub fn rustbook(build: &Build, target: &str, name: &str) {\n-    let src = build.src.join(\"src/doc\");\n-    rustbook_src(build, target, name, &src);\n+\n+#[derive(Serialize)]\n+pub struct Rustbook<'a> {\n+    target: &'a str,\n+    name: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Rustbook<'a> {\n+    type Output = ();\n+\n+    /// Invoke `rustbook` for `target` for the doc book `name`.\n+    ///\n+    /// This will not actually generate any documentation if the documentation has\n+    /// already been generated.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        let name = self.name;\n+        let src = build.src.join(\"src/doc\");\n+        rustbook_src(build, target, name, &src);\n+    }\n }\n \n //rules.doc(\"doc-unstable-book\", \"src/doc/unstable-book\")\n@@ -68,30 +82,44 @@ pub fn rustbook(build: &Build, target: &str, name: &str) {\n //                                     \"unstable-book\",\n //                                     &build.md_doc_out(s.target)));\n \n+#[derive(Serialize)]\n+pub struct RustbookSrc<'a> {\n+    target: &'a str,\n+    name: &'a str,\n+    src: &'a Path,\n+}\n \n-/// Invoke `rustbook` for `target` for the doc book `name` from the `src` path.\n-///\n-/// This will not actually generate any documentation if the documentation has\n-/// already been generated.\n-pub fn rustbook_src(build: &Build, target: &str, name: &str, src: &Path) {\n-    let out = build.doc_out(target);\n-    t!(fs::create_dir_all(&out));\n-\n-    let out = out.join(name);\n-    let compiler = Compiler::new(0, &build.build);\n-    let src = src.join(name);\n-    let index = out.join(\"index.html\");\n-    let rustbook = build.tool(&compiler, \"rustbook\");\n-    if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n-        return\n+impl<'a> Step<'a> for RustbookSrc<'a> {\n+    type Output = ();\n+\n+    /// Invoke `rustbook` for `target` for the doc book `name` from the `src` path.\n+    ///\n+    /// This will not actually generate any documentation if the documentation has\n+    /// already been generated.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        let name = self.name;\n+        let src = self.src;\n+        let out = build.doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+\n+        let out = out.join(name);\n+        let compiler = Compiler::new(0, &build.build);\n+        let src = src.join(name);\n+        let index = out.join(\"index.html\");\n+        let rustbook = build.tool(&compiler, \"rustbook\");\n+        if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n+            return\n+        }\n+        println!(\"Rustbook ({}) - {}\", target, name);\n+        let _ = fs::remove_dir_all(&out);\n+        build.run(build.tool_cmd(&compiler, \"rustbook\")\n+                       .arg(\"build\")\n+                       .arg(&src)\n+                       .arg(\"-d\")\n+                       .arg(out));\n     }\n-    println!(\"Rustbook ({}) - {}\", target, name);\n-    let _ = fs::remove_dir_all(&out);\n-    build.run(build.tool_cmd(&compiler, \"rustbook\")\n-                   .arg(\"build\")\n-                   .arg(&src)\n-                   .arg(\"-d\")\n-                   .arg(out));\n }\n \n // rules.doc(\"doc-book\", \"src/doc/book\")\n@@ -103,34 +131,48 @@ pub fn rustbook_src(build: &Build, target: &str, name: &str, src: &Path) {\n //      })\n //      .default(build.config.docs)\n //      .run(move |s| doc::book(build, s.target, \"book\"));\n-/// Build the book and associated stuff.\n-///\n-/// We need to build:\n-///\n-/// * Book (first edition)\n-/// * Book (second edition)\n-/// * Index page\n-/// * Redirect pages\n-pub fn book(build: &Build, target: &str, name: &str) {\n-    // build book first edition\n-    rustbook(build, target, &format!(\"{}/first-edition\", name));\n-\n-    // build book second edition\n-    rustbook(build, target, &format!(\"{}/second-edition\", name));\n-\n-    // build the index page\n-    let index = format!(\"{}/index.md\", name);\n-    println!(\"Documenting book index ({})\", target);\n-    invoke_rustdoc(build, target, &index);\n-\n-    // build the redirect pages\n-    println!(\"Documenting book redirect pages ({})\", target);\n-    for file in t!(fs::read_dir(build.src.join(\"src/doc/book/redirects\"))) {\n-        let file = t!(file);\n-        let path = file.path();\n-        let path = path.to_str().unwrap();\n-\n-        invoke_rustdoc(build, target, path);\n+\n+#[derive(Serialize)]\n+pub struct TheBook<'a> {\n+    target: &'a str,\n+    name: &'a str,\n+}\n+\n+impl<'a> Step<'a> for TheBook<'a> {\n+    type Output = ();\n+\n+    /// Build the book and associated stuff.\n+    ///\n+    /// We need to build:\n+    ///\n+    /// * Book (first edition)\n+    /// * Book (second edition)\n+    /// * Index page\n+    /// * Redirect pages\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        let name = self.name;\n+        // build book first edition\n+        rustbook(build, target, &format!(\"{}/first-edition\", name));\n+\n+        // build book second edition\n+        rustbook(build, target, &format!(\"{}/second-edition\", name));\n+\n+        // build the index page\n+        let index = format!(\"{}/index.md\", name);\n+        println!(\"Documenting book index ({})\", target);\n+        invoke_rustdoc(build, target, &index);\n+\n+        // build the redirect pages\n+        println!(\"Documenting book redirect pages ({})\", target);\n+        for file in t!(fs::read_dir(build.src.join(\"src/doc/book/redirects\"))) {\n+            let file = t!(file);\n+            let path = file.path();\n+            let path = path.to_str().unwrap();\n+\n+            invoke_rustdoc(build, target, path);\n+        }\n     }\n }\n \n@@ -188,75 +230,87 @@ fn invoke_rustdoc(build: &Build, target: &str, markdown: &str) {\n //      })\n //      .default(build.config.docs)\n //      .run(move |s| doc::standalone(build, s.target));\n-/// Generates all standalone documentation as compiled by the rustdoc in `stage`\n-/// for the `target` into `out`.\n-///\n-/// This will list all of `src/doc` looking for markdown files and appropriately\n-/// perform transformations like substituting `VERSION`, `SHORT_HASH`, and\n-/// `STAMP` alongw ith providing the various header/footer HTML we've cutomized.\n-///\n-/// In the end, this is just a glorified wrapper around rustdoc!\n-pub fn standalone(build: &Build, target: &str) {\n-    println!(\"Documenting standalone ({})\", target);\n-    let out = build.doc_out(target);\n-    t!(fs::create_dir_all(&out));\n-\n-    let compiler = Compiler::new(0, &build.build);\n-\n-    let favicon = build.src.join(\"src/doc/favicon.inc\");\n-    let footer = build.src.join(\"src/doc/footer.inc\");\n-    let full_toc = build.src.join(\"src/doc/full-toc.inc\");\n-    t!(fs::copy(build.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n \n-    let version_input = build.src.join(\"src/doc/version_info.html.template\");\n-    let version_info = out.join(\"version_info.html\");\n-\n-    if !up_to_date(&version_input, &version_info) {\n-        let mut info = String::new();\n-        t!(t!(File::open(&version_input)).read_to_string(&mut info));\n-        let info = info.replace(\"VERSION\", &build.rust_release())\n-                       .replace(\"SHORT_HASH\", build.rust_info.sha_short().unwrap_or(\"\"))\n-                       .replace(\"STAMP\", build.rust_info.sha().unwrap_or(\"\"));\n-        t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n-    }\n+#[derive(Serialize)]\n+pub struct Standalone<'a> {\n+    target: &'a str,\n+}\n \n-    for file in t!(fs::read_dir(build.src.join(\"src/doc\"))) {\n-        let file = t!(file);\n-        let path = file.path();\n-        let filename = path.file_name().unwrap().to_str().unwrap();\n-        if !filename.ends_with(\".md\") || filename == \"README.md\" {\n-            continue\n+impl<'a> Step<'a> for Standalone<'a> {\n+    type Output = ();\n+\n+    /// Generates all standalone documentation as compiled by the rustdoc in `stage`\n+    /// for the `target` into `out`.\n+    ///\n+    /// This will list all of `src/doc` looking for markdown files and appropriately\n+    /// perform transformations like substituting `VERSION`, `SHORT_HASH`, and\n+    /// `STAMP` alongw ith providing the various header/footer HTML we've cutomized.\n+    ///\n+    /// In the end, this is just a glorified wrapper around rustdoc!\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        println!(\"Documenting standalone ({})\", target);\n+        let out = build.doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+\n+        let compiler = Compiler::new(0, &build.build);\n+\n+        let favicon = build.src.join(\"src/doc/favicon.inc\");\n+        let footer = build.src.join(\"src/doc/footer.inc\");\n+        let full_toc = build.src.join(\"src/doc/full-toc.inc\");\n+        t!(fs::copy(build.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n+\n+        let version_input = build.src.join(\"src/doc/version_info.html.template\");\n+        let version_info = out.join(\"version_info.html\");\n+\n+        if !up_to_date(&version_input, &version_info) {\n+            let mut info = String::new();\n+            t!(t!(File::open(&version_input)).read_to_string(&mut info));\n+            let info = info.replace(\"VERSION\", &build.rust_release())\n+                           .replace(\"SHORT_HASH\", build.rust_info.sha_short().unwrap_or(\"\"))\n+                           .replace(\"STAMP\", build.rust_info.sha().unwrap_or(\"\"));\n+            t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n         }\n \n-        let html = out.join(filename).with_extension(\"html\");\n-        let rustdoc = build.rustdoc(&compiler);\n-        if up_to_date(&path, &html) &&\n-           up_to_date(&footer, &html) &&\n-           up_to_date(&favicon, &html) &&\n-           up_to_date(&full_toc, &html) &&\n-           up_to_date(&version_info, &html) &&\n-           up_to_date(&rustdoc, &html) {\n-            continue\n+        for file in t!(fs::read_dir(build.src.join(\"src/doc\"))) {\n+            let file = t!(file);\n+            let path = file.path();\n+            let filename = path.file_name().unwrap().to_str().unwrap();\n+            if !filename.ends_with(\".md\") || filename == \"README.md\" {\n+                continue\n+            }\n+\n+            let html = out.join(filename).with_extension(\"html\");\n+            let rustdoc = build.rustdoc(&compiler);\n+            if up_to_date(&path, &html) &&\n+               up_to_date(&footer, &html) &&\n+               up_to_date(&favicon, &html) &&\n+               up_to_date(&full_toc, &html) &&\n+               up_to_date(&version_info, &html) &&\n+               up_to_date(&rustdoc, &html) {\n+                continue\n+            }\n+\n+            let mut cmd = Command::new(&rustdoc);\n+            build.add_rustc_lib_path(&compiler, &mut cmd);\n+            cmd.arg(\"--html-after-content\").arg(&footer)\n+               .arg(\"--html-before-content\").arg(&version_info)\n+               .arg(\"--html-in-header\").arg(&favicon)\n+               .arg(\"--markdown-playground-url\")\n+               .arg(\"https://play.rust-lang.org/\")\n+               .arg(\"-o\").arg(&out)\n+               .arg(&path);\n+\n+            if filename == \"not_found.md\" {\n+                cmd.arg(\"--markdown-no-toc\")\n+                   .arg(\"--markdown-css\")\n+                   .arg(\"https://doc.rust-lang.org/rust.css\");\n+            } else {\n+                cmd.arg(\"--markdown-css\").arg(\"rust.css\");\n+            }\n+            build.run(&mut cmd);\n         }\n-\n-        let mut cmd = Command::new(&rustdoc);\n-        build.add_rustc_lib_path(&compiler, &mut cmd);\n-        cmd.arg(\"--html-after-content\").arg(&footer)\n-           .arg(\"--html-before-content\").arg(&version_info)\n-           .arg(\"--html-in-header\").arg(&favicon)\n-           .arg(\"--markdown-playground-url\")\n-           .arg(\"https://play.rust-lang.org/\")\n-           .arg(\"-o\").arg(&out)\n-           .arg(&path);\n-\n-        if filename == \"not_found.md\" {\n-            cmd.arg(\"--markdown-no-toc\")\n-               .arg(\"--markdown-css\")\n-               .arg(\"https://doc.rust-lang.org/rust.css\");\n-        } else {\n-            cmd.arg(\"--markdown-css\").arg(\"rust.css\");\n-        }\n-        build.run(&mut cmd);\n     }\n }\n \n@@ -266,63 +320,77 @@ pub fn standalone(build: &Build, target: &str) {\n //          .default(default && build.config.docs)\n //          .run(move |s| doc::std(build, s.stage, s.target));\n // }\n-/// Compile all standard library documentation.\n-///\n-/// This will generate all documentation for the standard library and its\n-/// dependencies. This is largely just a wrapper around `cargo doc`.\n-pub fn std(build: &Build, stage: u32, target: &str) {\n-    println!(\"Documenting stage{} std ({})\", stage, target);\n-    let out = build.doc_out(target);\n-    t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.build);\n-    let compiler = if build.force_use_stage1(&compiler, target) {\n-        Compiler::new(1, compiler.host)\n-    } else {\n-        compiler\n-    };\n-    let out_dir = build.stage_out(&compiler, Mode::Libstd)\n-                       .join(target).join(\"doc\");\n-    let rustdoc = build.rustdoc(&compiler);\n \n-    // Here what we're doing is creating a *symlink* (directory junction on\n-    // Windows) to the final output location. This is not done as an\n-    // optimization but rather for correctness. We've got three trees of\n-    // documentation, one for std, one for test, and one for rustc. It's then\n-    // our job to merge them all together.\n-    //\n-    // Unfortunately rustbuild doesn't know nearly as well how to merge doc\n-    // trees as rustdoc does itself, so instead of actually having three\n-    // separate trees we just have rustdoc output to the same location across\n-    // all of them.\n-    //\n-    // This way rustdoc generates output directly into the output, and rustdoc\n-    // will also directly handle merging.\n-    let my_out = build.crate_doc_out(target);\n-    build.clear_if_dirty(&my_out, &rustdoc);\n-    t!(symlink_dir_force(&my_out, &out_dir));\n-\n-    let mut cargo = build.cargo(&compiler, Mode::Libstd, target, \"doc\");\n-    cargo.arg(\"--manifest-path\")\n-         .arg(build.src.join(\"src/libstd/Cargo.toml\"))\n-         .arg(\"--features\").arg(build.std_features());\n-\n-    // We don't want to build docs for internal std dependencies unless\n-    // in compiler-docs mode. When not in that mode, we whitelist the crates\n-    // for which docs must be built.\n-    if !build.config.compiler_docs {\n-        cargo.arg(\"--no-deps\");\n-        for krate in &[\"alloc\", \"collections\", \"core\", \"std\", \"std_unicode\"] {\n-            cargo.arg(\"-p\").arg(krate);\n-            // Create all crate output directories first to make sure rustdoc uses\n-            // relative links.\n-            // FIXME: Cargo should probably do this itself.\n-            t!(fs::create_dir_all(out_dir.join(krate)));\n+#[derive(Serialize)]\n+pub struct Std<'a> {\n+    stage: u32,\n+    target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Std<'a> {\n+    type Output = ();\n+\n+    /// Compile all standard library documentation.\n+    ///\n+    /// This will generate all documentation for the standard library and its\n+    /// dependencies. This is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        println!(\"Documenting stage{} std ({})\", stage, target);\n+        let out = build.doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+        let compiler = Compiler::new(stage, &build.build);\n+        let compiler = if build.force_use_stage1(&compiler, target) {\n+            Compiler::new(1, compiler.host)\n+        } else {\n+            compiler\n+        };\n+        let out_dir = build.stage_out(&compiler, Mode::Libstd)\n+                           .join(target).join(\"doc\");\n+        let rustdoc = build.rustdoc(&compiler);\n+\n+        // Here what we're doing is creating a *symlink* (directory junction on\n+        // Windows) to the final output location. This is not done as an\n+        // optimization but rather for correctness. We've got three trees of\n+        // documentation, one for std, one for test, and one for rustc. It's then\n+        // our job to merge them all together.\n+        //\n+        // Unfortunately rustbuild doesn't know nearly as well how to merge doc\n+        // trees as rustdoc does itself, so instead of actually having three\n+        // separate trees we just have rustdoc output to the same location across\n+        // all of them.\n+        //\n+        // This way rustdoc generates output directly into the output, and rustdoc\n+        // will also directly handle merging.\n+        let my_out = build.crate_doc_out(target);\n+        build.clear_if_dirty(&my_out, &rustdoc);\n+        t!(symlink_dir_force(&my_out, &out_dir));\n+\n+        let mut cargo = build.cargo(&compiler, Mode::Libstd, target, \"doc\");\n+        cargo.arg(\"--manifest-path\")\n+             .arg(build.src.join(\"src/libstd/Cargo.toml\"))\n+             .arg(\"--features\").arg(build.std_features());\n+\n+        // We don't want to build docs for internal std dependencies unless\n+        // in compiler-docs mode. When not in that mode, we whitelist the crates\n+        // for which docs must be built.\n+        if !build.config.compiler_docs {\n+            cargo.arg(\"--no-deps\");\n+            for krate in &[\"alloc\", \"collections\", \"core\", \"std\", \"std_unicode\"] {\n+                cargo.arg(\"-p\").arg(krate);\n+                // Create all crate output directories first to make sure rustdoc uses\n+                // relative links.\n+                // FIXME: Cargo should probably do this itself.\n+                t!(fs::create_dir_all(out_dir.join(krate)));\n+            }\n         }\n-    }\n \n \n-    build.run(&mut cargo);\n-    cp_r(&my_out, &out);\n+        build.run(&mut cargo);\n+        cp_r(&my_out, &out);\n+    }\n }\n \n // for (krate, path, default) in krates(\"test\") {\n@@ -333,36 +401,49 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n //          .default(default && build.config.compiler_docs)\n //          .run(move |s| doc::test(build, s.stage, s.target));\n // }\n-/// Compile all libtest documentation.\n-///\n-/// This will generate all documentation for libtest and its dependencies. This\n-/// is largely just a wrapper around `cargo doc`.\n-pub fn test(build: &Build, stage: u32, target: &str) {\n-    println!(\"Documenting stage{} test ({})\", stage, target);\n-    let out = build.doc_out(target);\n-    t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.build);\n-    let compiler = if build.force_use_stage1(&compiler, target) {\n-        Compiler::new(1, compiler.host)\n-    } else {\n-        compiler\n-    };\n-    let out_dir = build.stage_out(&compiler, Mode::Libtest)\n-                       .join(target).join(\"doc\");\n-    let rustdoc = build.rustdoc(&compiler);\n \n-    // See docs in std above for why we symlink\n-    let my_out = build.crate_doc_out(target);\n-    build.clear_if_dirty(&my_out, &rustdoc);\n-    t!(symlink_dir_force(&my_out, &out_dir));\n-\n-    let mut cargo = build.cargo(&compiler, Mode::Libtest, target, \"doc\");\n-    cargo.arg(\"--manifest-path\")\n-         .arg(build.src.join(\"src/libtest/Cargo.toml\"));\n-    build.run(&mut cargo);\n-    cp_r(&my_out, &out);\n+#[derive(Serialize)]\n+pub struct Test<'a> {\n+    stage: u32,\n+    test: &'a str,\n }\n \n+impl<'a> Step<'a> for Test<'a> {\n+    type Output = ();\n+\n+    /// Compile all libtest documentation.\n+    ///\n+    /// This will generate all documentation for libtest and its dependencies. This\n+    /// is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        println!(\"Documenting stage{} test ({})\", stage, target);\n+        let out = build.doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+        let compiler = Compiler::new(stage, &build.build);\n+        let compiler = if build.force_use_stage1(&compiler, target) {\n+            Compiler::new(1, compiler.host)\n+        } else {\n+            compiler\n+        };\n+        let out_dir = build.stage_out(&compiler, Mode::Libtest)\n+                           .join(target).join(\"doc\");\n+        let rustdoc = build.rustdoc(&compiler);\n+\n+        // See docs in std above for why we symlink\n+        let my_out = build.crate_doc_out(target);\n+        build.clear_if_dirty(&my_out, &rustdoc);\n+        t!(symlink_dir_force(&my_out, &out_dir));\n+\n+        let mut cargo = build.cargo(&compiler, Mode::Libtest, target, \"doc\");\n+        cargo.arg(\"--manifest-path\")\n+             .arg(build.src.join(\"src/libtest/Cargo.toml\"));\n+        build.run(&mut cargo);\n+        cp_r(&my_out, &out);\n+    }\n+}\n \n // for (krate, path, default) in krates(\"rustc-main\") {\n //     rules.doc(&krate.doc_step, path)\n@@ -374,51 +455,65 @@ pub fn test(build: &Build, stage: u32, target: &str) {\n //          .run(move |s| doc::rustc(build, s.stage, s.target));\n // }\n //\n-/// Generate all compiler documentation.\n-///\n-/// This will generate all documentation for the compiler libraries and their\n-/// dependencies. This is largely just a wrapper around `cargo doc`.\n-pub fn rustc(build: &Build, stage: u32, target: &str) {\n-    println!(\"Documenting stage{} compiler ({})\", stage, target);\n-    let out = build.doc_out(target);\n-    t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.build);\n-    let compiler = if build.force_use_stage1(&compiler, target) {\n-        Compiler::new(1, compiler.host)\n-    } else {\n-        compiler\n-    };\n-    let out_dir = build.stage_out(&compiler, Mode::Librustc)\n-                       .join(target).join(\"doc\");\n-    let rustdoc = build.rustdoc(&compiler);\n \n-    // See docs in std above for why we symlink\n-    let my_out = build.crate_doc_out(target);\n-    build.clear_if_dirty(&my_out, &rustdoc);\n-    t!(symlink_dir_force(&my_out, &out_dir));\n-\n-    let mut cargo = build.cargo(&compiler, Mode::Librustc, target, \"doc\");\n-    cargo.arg(\"--manifest-path\")\n-         .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n-         .arg(\"--features\").arg(build.rustc_features());\n-\n-    if build.config.compiler_docs {\n-        // src/rustc/Cargo.toml contains bin crates called rustc and rustdoc\n-        // which would otherwise overwrite the docs for the real rustc and\n-        // rustdoc lib crates.\n-        cargo.arg(\"-p\").arg(\"rustc_driver\")\n-             .arg(\"-p\").arg(\"rustdoc\");\n-    } else {\n-        // Like with libstd above if compiler docs aren't enabled then we're not\n-        // documenting internal dependencies, so we have a whitelist.\n-        cargo.arg(\"--no-deps\");\n-        for krate in &[\"proc_macro\"] {\n-            cargo.arg(\"-p\").arg(krate);\n+#[derive(Serialize)]\n+pub struct Rustc<'a> {\n+    stage: u32,\n+    target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Rustc<'a> {\n+    type Output = ();\n+\n+    /// Generate all compiler documentation.\n+    ///\n+    /// This will generate all documentation for the compiler libraries and their\n+    /// dependencies. This is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        println!(\"Documenting stage{} compiler ({})\", stage, target);\n+        let out = build.doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+        let compiler = Compiler::new(stage, &build.build);\n+        let compiler = if build.force_use_stage1(&compiler, target) {\n+            Compiler::new(1, compiler.host)\n+        } else {\n+            compiler\n+        };\n+        let out_dir = build.stage_out(&compiler, Mode::Librustc)\n+                           .join(target).join(\"doc\");\n+        let rustdoc = build.rustdoc(&compiler);\n+\n+        // See docs in std above for why we symlink\n+        let my_out = build.crate_doc_out(target);\n+        build.clear_if_dirty(&my_out, &rustdoc);\n+        t!(symlink_dir_force(&my_out, &out_dir));\n+\n+        let mut cargo = build.cargo(&compiler, Mode::Librustc, target, \"doc\");\n+        cargo.arg(\"--manifest-path\")\n+             .arg(build.src.join(\"src/rustc/Cargo.toml\"))\n+             .arg(\"--features\").arg(build.rustc_features());\n+\n+        if build.config.compiler_docs {\n+            // src/rustc/Cargo.toml contains bin crates called rustc and rustdoc\n+            // which would otherwise overwrite the docs for the real rustc and\n+            // rustdoc lib crates.\n+            cargo.arg(\"-p\").arg(\"rustc_driver\")\n+                 .arg(\"-p\").arg(\"rustdoc\");\n+        } else {\n+            // Like with libstd above if compiler docs aren't enabled then we're not\n+            // documenting internal dependencies, so we have a whitelist.\n+            cargo.arg(\"--no-deps\");\n+            for krate in &[\"proc_macro\"] {\n+                cargo.arg(\"-p\").arg(krate);\n+            }\n         }\n-    }\n \n-    build.run(&mut cargo);\n-    cp_r(&my_out, &out);\n+        build.run(&mut cargo);\n+        cp_r(&my_out, &out);\n+    }\n }\n \n // rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n@@ -428,21 +523,32 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n //      .host(true)\n //      .run(move |s| doc::error_index(build, s.target));\n \n-/// Generates the HTML rendered error-index by running the\n-/// `error_index_generator` tool.\n-pub fn error_index(build: &Build, target: &str) {\n-    println!(\"Documenting error index ({})\", target);\n-    let out = build.doc_out(target);\n-    t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(0, &build.build);\n-    let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n-    index.arg(\"html\");\n-    index.arg(out.join(\"error-index.html\"));\n-\n-    // FIXME: shouldn't have to pass this env var\n-    index.env(\"CFG_BUILD\", &build.build);\n+#[derive(Serialize)]\n+pub struct ErrorIndex<'a> {\n+    target: &'a str,\n+}\n \n-    build.run(&mut index);\n+impl<'a> Step<'a> for ErrorIndex<'a> {\n+    type Output = ();\n+\n+    /// Generates the HTML rendered error-index by running the\n+    /// `error_index_generator` tool.\n+    fn run(self, builder: &Builder) {\n+        let builder = builder.build;\n+        let target = self.target;\n+        println!(\"Documenting error index ({})\", target);\n+        let out = build.doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+        let compiler = Compiler::new(0, &build.build);\n+        let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n+        index.arg(\"html\");\n+        index.arg(out.join(\"error-index.html\"));\n+\n+        // FIXME: shouldn't have to pass this env var\n+        index.env(\"CFG_BUILD\", &build.build);\n+\n+        build.run(&mut index);\n+    }\n }\n \n // rules.doc(\"doc-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n@@ -457,17 +563,28 @@ pub fn error_index(build: &Build, target: &str) {\n //      .host(true)\n //      .run(move |s| doc::unstable_book_gen(build, s.target));\n \n-pub fn unstable_book_gen(build: &Build, target: &str) {\n-    println!(\"Generating unstable book md files ({})\", target);\n-    let out = build.md_doc_out(target).join(\"unstable-book\");\n-    t!(fs::create_dir_all(&out));\n-    t!(fs::remove_dir_all(&out));\n-    let compiler = Compiler::new(0, &build.build);\n-    let mut cmd = build.tool_cmd(&compiler, \"unstable-book-gen\");\n-    cmd.arg(build.src.join(\"src\"));\n-    cmd.arg(out);\n+#[derive(Serialize)]\n+pub struct UnstableBookGen<'a> {\n+    target: &'a str,\n+}\n \n-    build.run(&mut cmd);\n+impl<'a> Step<'a> for UnstableBookGen<'a> {\n+    type Output = ();\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        println!(\"Generating unstable book md files ({})\", target);\n+        let out = build.md_doc_out(target).join(\"unstable-book\");\n+        t!(fs::create_dir_all(&out));\n+        t!(fs::remove_dir_all(&out));\n+        let compiler = Compiler::new(0, &build.build);\n+        let mut cmd = build.tool_cmd(&compiler, \"unstable-book-gen\");\n+        cmd.arg(build.src.join(\"src\"));\n+        cmd.arg(out);\n+\n+        build.run(&mut cmd);\n+    }\n }\n \n fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {"}, {"sha": "6ae5c03bfeb4c8b86a039f99d4c641fcee659ee2", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 324, "deletions": 288, "changes": 612, "blob_url": "https://github.com/rust-lang/rust/blob/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=001e9f349087124165ed6deea6a87e0b158bba21", "patch": "@@ -33,7 +33,7 @@ use Build;\n use util;\n use build_helper::up_to_date;\n \n-/ rules.build(\"llvm\", \"src/llvm\")\n+/j/ rules.build(\"llvm\", \"src/llvm\")\n //      .host(true)\n //      .dep(move |s| {\n //          if s.target == build.build {\n@@ -43,173 +43,185 @@ use build_helper::up_to_date;\n //          }\n //      })\n //      .run(move |s| native::llvm(build, s.target));\n-/// Compile LLVM for `target`.\n-pub fn llvm(build: &Build, target: &str) {\n-    // If we're using a custom LLVM bail out here, but we can only use a\n-    // custom LLVM for the build triple.\n-    if let Some(config) = build.config.target_config.get(target) {\n-        if let Some(ref s) = config.llvm_config {\n-            return check_llvm_version(build, s);\n+\n+#[derive(Serialize)]\n+pub struct Llvm<'a> {\n+    pub target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Llvm<'a> {\n+    type Output = ();\n+\n+    /// Compile LLVM for `target`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        // If we're using a custom LLVM bail out here, but we can only use a\n+        // custom LLVM for the build triple.\n+        if let Some(config) = build.config.target_config.get(target) {\n+            if let Some(ref s) = config.llvm_config {\n+                return check_llvm_version(build, s);\n+            }\n         }\n-    }\n \n-    let rebuild_trigger = build.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n-    let mut rebuild_trigger_contents = String::new();\n-    t!(t!(File::open(&rebuild_trigger)).read_to_string(&mut rebuild_trigger_contents));\n+        let rebuild_trigger = build.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n+        let mut rebuild_trigger_contents = String::new();\n+        t!(t!(File::open(&rebuild_trigger)).read_to_string(&mut rebuild_trigger_contents));\n \n-    let out_dir = build.llvm_out(target);\n-    let done_stamp = out_dir.join(\"llvm-finished-building\");\n-    if done_stamp.exists() {\n-        let mut done_contents = String::new();\n-        t!(t!(File::open(&done_stamp)).read_to_string(&mut done_contents));\n+        let out_dir = build.llvm_out(target);\n+        let done_stamp = out_dir.join(\"llvm-finished-building\");\n+        if done_stamp.exists() {\n+            let mut done_contents = String::new();\n+            t!(t!(File::open(&done_stamp)).read_to_string(&mut done_contents));\n \n-        // If LLVM was already built previously and contents of the rebuild-trigger file\n-        // didn't change from the previous build, then no action is required.\n-        if done_contents == rebuild_trigger_contents {\n-            return\n+            // If LLVM was already built previously and contents of the rebuild-trigger file\n+            // didn't change from the previous build, then no action is required.\n+            if done_contents == rebuild_trigger_contents {\n+                return\n+            }\n+        }\n+        if build.config.llvm_clean_rebuild {\n+            drop(fs::remove_dir_all(&out_dir));\n         }\n-    }\n-    if build.config.llvm_clean_rebuild {\n-        drop(fs::remove_dir_all(&out_dir));\n-    }\n \n-    let _folder = build.fold_output(|| \"llvm\");\n-    println!(\"Building LLVM for {}\", target);\n-    let _time = util::timeit();\n-    t!(fs::create_dir_all(&out_dir));\n+        let _folder = build.fold_output(|| \"llvm\");\n+        println!(\"Building LLVM for {}\", target);\n+        let _time = util::timeit();\n+        t!(fs::create_dir_all(&out_dir));\n \n-    // http://llvm.org/docs/CMake.html\n-    let mut cfg = cmake::Config::new(build.src.join(\"src/llvm\"));\n-    if build.config.ninja {\n-        cfg.generator(\"Ninja\");\n-    }\n+        // http://llvm.org/docs/CMake.html\n+        let mut cfg = cmake::Config::new(build.src.join(\"src/llvm\"));\n+        if build.config.ninja {\n+            cfg.generator(\"Ninja\");\n+        }\n \n-    let profile = match (build.config.llvm_optimize, build.config.llvm_release_debuginfo) {\n-        (false, _) => \"Debug\",\n-        (true, false) => \"Release\",\n-        (true, true) => \"RelWithDebInfo\",\n-    };\n-\n-    // NOTE: remember to also update `config.toml.example` when changing the defaults!\n-    let llvm_targets = match build.config.llvm_targets {\n-        Some(ref s) => s,\n-        None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX;Hexagon\",\n-    };\n-\n-    let llvm_exp_targets = match build.config.llvm_experimental_targets {\n-        Some(ref s) => s,\n-        None => \"\",\n-    };\n-\n-    let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n-\n-    cfg.target(target)\n-       .host(&build.build)\n-       .out_dir(&out_dir)\n-       .profile(profile)\n-       .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n-       .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n-       .define(\"LLVM_EXPERIMENTAL_TARGETS_TO_BUILD\", llvm_exp_targets)\n-       .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n-       .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n-       .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n-       .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n-       .define(\"WITH_POLLY\", \"OFF\")\n-       .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n-       .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n-       .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string())\n-       .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n-       .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n-\n-    if target.contains(\"msvc\") {\n-        cfg.define(\"LLVM_USE_CRT_DEBUG\", \"MT\");\n-        cfg.define(\"LLVM_USE_CRT_RELEASE\", \"MT\");\n-        cfg.define(\"LLVM_USE_CRT_RELWITHDEBINFO\", \"MT\");\n-        cfg.static_crt(true);\n-    }\n+        let profile = match (build.config.llvm_optimize, build.config.llvm_release_debuginfo) {\n+            (false, _) => \"Debug\",\n+            (true, false) => \"Release\",\n+            (true, true) => \"RelWithDebInfo\",\n+        };\n \n-    if target.starts_with(\"i686\") {\n-        cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n-    }\n+        // NOTE: remember to also update `config.toml.example` when changing the defaults!\n+        let llvm_targets = match build.config.llvm_targets {\n+            Some(ref s) => s,\n+            None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX;Hexagon\",\n+        };\n \n-    if let Some(num_linkers) = build.config.llvm_link_jobs {\n-        if num_linkers > 0 {\n-            cfg.define(\"LLVM_PARALLEL_LINK_JOBS\", num_linkers.to_string());\n-        }\n-    }\n+        let llvm_exp_targets = match build.config.llvm_experimental_targets {\n+            Some(ref s) => s,\n+            None => \"\",\n+        };\n \n-    // http://llvm.org/docs/HowToCrossCompileLLVM.html\n-    if target != build.build {\n-        // FIXME: if the llvm root for the build triple is overridden then we\n-        //        should use llvm-tblgen from there, also should verify that it\n-        //        actually exists most of the time in normal installs of LLVM.\n-        let host = build.llvm_out(&build.build).join(\"bin/llvm-tblgen\");\n-        cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n-           .define(\"LLVM_TABLEGEN\", &host);\n-    }\n+        let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n+\n+        cfg.target(target)\n+           .host(&build.build)\n+           .out_dir(&out_dir)\n+           .profile(profile)\n+           .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n+           .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n+           .define(\"LLVM_EXPERIMENTAL_TARGETS_TO_BUILD\", llvm_exp_targets)\n+           .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n+           .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n+           .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n+           .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n+           .define(\"WITH_POLLY\", \"OFF\")\n+           .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n+           .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n+           .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string())\n+           .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n+           .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n-    let sanitize_cc = |cc: &Path| {\n         if target.contains(\"msvc\") {\n-            OsString::from(cc.to_str().unwrap().replace(\"\\\\\", \"/\"))\n-        } else {\n-            cc.as_os_str().to_owned()\n+            cfg.define(\"LLVM_USE_CRT_DEBUG\", \"MT\");\n+            cfg.define(\"LLVM_USE_CRT_RELEASE\", \"MT\");\n+            cfg.define(\"LLVM_USE_CRT_RELWITHDEBINFO\", \"MT\");\n+            cfg.static_crt(true);\n         }\n-    };\n \n-    let configure_compilers = |cfg: &mut cmake::Config| {\n-        // MSVC with CMake uses msbuild by default which doesn't respect these\n-        // vars that we'd otherwise configure. In that case we just skip this\n-        // entirely.\n-        if target.contains(\"msvc\") && !build.config.ninja {\n-            return\n+        if target.starts_with(\"i686\") {\n+            cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n         }\n \n-        let cc = build.cc(target);\n-        let cxx = build.cxx(target).unwrap();\n-\n-        // Handle msvc + ninja + ccache specially (this is what the bots use)\n-        if target.contains(\"msvc\") &&\n-           build.config.ninja &&\n-           build.config.ccache.is_some() {\n-            let mut cc = env::current_exe().expect(\"failed to get cwd\");\n-            cc.set_file_name(\"sccache-plus-cl.exe\");\n-\n-           cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n-              .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n-           cfg.env(\"SCCACHE_PATH\",\n-                   build.config.ccache.as_ref().unwrap())\n-              .env(\"SCCACHE_TARGET\", target);\n-\n-        // If ccache is configured we inform the build a little differently hwo\n-        // to invoke ccache while also invoking our compilers.\n-        } else if let Some(ref ccache) = build.config.ccache {\n-           cfg.define(\"CMAKE_C_COMPILER\", ccache)\n-              .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n-              .define(\"CMAKE_CXX_COMPILER\", ccache)\n-              .define(\"CMAKE_CXX_COMPILER_ARG1\", sanitize_cc(cxx));\n-        } else {\n-           cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n-              .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n+        if let Some(num_linkers) = build.config.llvm_link_jobs {\n+            if num_linkers > 0 {\n+                cfg.define(\"LLVM_PARALLEL_LINK_JOBS\", num_linkers.to_string());\n+            }\n         }\n \n-        cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n-        cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n-        cfg.define(\"CMAKE_CXX_FLAGS\", build.cflags(target).join(\" \"));\n-    };\n+        // http://llvm.org/docs/HowToCrossCompileLLVM.html\n+        if target != build.build {\n+            // FIXME: if the llvm root for the build triple is overridden then we\n+            //        should use llvm-tblgen from there, also should verify that it\n+            //        actually exists most of the time in normal installs of LLVM.\n+            let host = build.llvm_out(&build.build).join(\"bin/llvm-tblgen\");\n+            cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n+               .define(\"LLVM_TABLEGEN\", &host);\n+        }\n \n-    configure_compilers(&mut cfg);\n+        let sanitize_cc = |cc: &Path| {\n+            if target.contains(\"msvc\") {\n+                OsString::from(cc.to_str().unwrap().replace(\"\\\\\", \"/\"))\n+            } else {\n+                cc.as_os_str().to_owned()\n+            }\n+        };\n \n-    if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n-        cfg.env(\"RUST_LOG\", \"sccache=warn\");\n-    }\n+        let configure_compilers = |cfg: &mut cmake::Config| {\n+            // MSVC with CMake uses msbuild by default which doesn't respect these\n+            // vars that we'd otherwise configure. In that case we just skip this\n+            // entirely.\n+            if target.contains(\"msvc\") && !build.config.ninja {\n+                return\n+            }\n+\n+            let cc = build.cc(target);\n+            let cxx = build.cxx(target).unwrap();\n+\n+            // Handle msvc + ninja + ccache specially (this is what the bots use)\n+            if target.contains(\"msvc\") &&\n+               build.config.ninja &&\n+               build.config.ccache.is_some() {\n+                let mut cc = env::current_exe().expect(\"failed to get cwd\");\n+                cc.set_file_name(\"sccache-plus-cl.exe\");\n+\n+               cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n+                  .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n+               cfg.env(\"SCCACHE_PATH\",\n+                       build.config.ccache.as_ref().unwrap())\n+                  .env(\"SCCACHE_TARGET\", target);\n+\n+            // If ccache is configured we inform the build a little differently hwo\n+            // to invoke ccache while also invoking our compilers.\n+            } else if let Some(ref ccache) = build.config.ccache {\n+               cfg.define(\"CMAKE_C_COMPILER\", ccache)\n+                  .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n+                  .define(\"CMAKE_CXX_COMPILER\", ccache)\n+                  .define(\"CMAKE_CXX_COMPILER_ARG1\", sanitize_cc(cxx));\n+            } else {\n+               cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n+                  .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n+            }\n+\n+            cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n+            cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n+            cfg.define(\"CMAKE_CXX_FLAGS\", build.cflags(target).join(\" \"));\n+        };\n \n-    // FIXME: we don't actually need to build all LLVM tools and all LLVM\n-    //        libraries here, e.g. we just want a few components and a few\n-    //        tools. Figure out how to filter them down and only build the right\n-    //        tools and libs on all platforms.\n-    cfg.build();\n+        configure_compilers(&mut cfg);\n \n-    t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n+        if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n+            cfg.env(\"RUST_LOG\", \"sccache=warn\");\n+        }\n+\n+        // FIXME: we don't actually need to build all LLVM tools and all LLVM\n+        //        libraries here, e.g. we just want a few components and a few\n+        //        tools. Figure out how to filter them down and only build the right\n+        //        tools and libs on all platforms.\n+        cfg.build();\n+\n+        t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n+    }\n }\n \n fn check_llvm_version(build: &Build, llvm_config: &Path) {\n@@ -228,164 +240,188 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n \n //rules.build(\"test-helpers\", \"src/rt/rust_test_helpers.c\")\n //     .run(move |s| native::test_helpers(build, s.target));\n-/// Compiles the `rust_test_helpers.c` library which we used in various\n-/// `run-pass` test suites for ABI testing.\n-pub fn test_helpers(build: &Build, target: &str) {\n-    let dst = build.test_helpers_out(target);\n-    let src = build.src.join(\"src/rt/rust_test_helpers.c\");\n-    if up_to_date(&src, &dst.join(\"librust_test_helpers.a\")) {\n-        return\n-    }\n \n-    let _folder = build.fold_output(|| \"build_test_helpers\");\n-    println!(\"Building test helpers\");\n-    t!(fs::create_dir_all(&dst));\n-    let mut cfg = gcc::Config::new();\n-\n-    // We may have found various cross-compilers a little differently due to our\n-    // extra configuration, so inform gcc of these compilers. Note, though, that\n-    // on MSVC we still need gcc's detection of env vars (ugh).\n-    if !target.contains(\"msvc\") {\n-        if let Some(ar) = build.ar(target) {\n-            cfg.archiver(ar);\n+#[derive(Serialize)]\n+pub struct TestHelpers<'a> {\n+    target: &'a str,\n+}\n+\n+impl<'a> Step<'a> for TestHelpers<'a> {\n+    type Output = ();\n+\n+    /// Compiles the `rust_test_helpers.c` library which we used in various\n+    /// `run-pass` test suites for ABI testing.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        let dst = build.test_helpers_out(target);\n+        let src = build.src.join(\"src/rt/rust_test_helpers.c\");\n+        if up_to_date(&src, &dst.join(\"librust_test_helpers.a\")) {\n+            return\n+        }\n+\n+        let _folder = build.fold_output(|| \"build_test_helpers\");\n+        println!(\"Building test helpers\");\n+        t!(fs::create_dir_all(&dst));\n+        let mut cfg = gcc::Config::new();\n+\n+        // We may have found various cross-compilers a little differently due to our\n+        // extra configuration, so inform gcc of these compilers. Note, though, that\n+        // on MSVC we still need gcc's detection of env vars (ugh).\n+        if !target.contains(\"msvc\") {\n+            if let Some(ar) = build.ar(target) {\n+                cfg.archiver(ar);\n+            }\n+            cfg.compiler(build.cc(target));\n         }\n-        cfg.compiler(build.cc(target));\n-    }\n \n-    cfg.cargo_metadata(false)\n-       .out_dir(&dst)\n-       .target(target)\n-       .host(&build.build)\n-       .opt_level(0)\n-       .debug(false)\n-       .file(build.src.join(\"src/rt/rust_test_helpers.c\"))\n-       .compile(\"librust_test_helpers.a\");\n+        cfg.cargo_metadata(false)\n+           .out_dir(&dst)\n+           .target(target)\n+           .host(&build.build)\n+           .opt_level(0)\n+           .debug(false)\n+           .file(build.src.join(\"src/rt/rust_test_helpers.c\"))\n+           .compile(\"librust_test_helpers.a\");\n+    }\n }\n+\n const OPENSSL_VERS: &'static str = \"1.0.2k\";\n const OPENSSL_SHA256: &'static str =\n     \"6b3977c61f2aedf0f96367dcfb5c6e578cf37e7b8d913b4ecb6643c3cb88d8c0\";\n \n //rules.build(\"openssl\", \"path/to/nowhere\")\n //     .run(move |s| native::openssl(build, s.target));\n \n-pub fn openssl(build: &Build, target: &str) {\n-    let out = match build.openssl_dir(target) {\n-        Some(dir) => dir,\n-        None => return,\n-    };\n+#[derive(Serialize)]\n+pub struct Openssl<'a> {\n+    target: &'a str,\n+}\n \n-    let stamp = out.join(\".stamp\");\n-    let mut contents = String::new();\n-    drop(File::open(&stamp).and_then(|mut f| f.read_to_string(&mut contents)));\n-    if contents == OPENSSL_VERS {\n-        return\n-    }\n-    t!(fs::create_dir_all(&out));\n-\n-    let name = format!(\"openssl-{}.tar.gz\", OPENSSL_VERS);\n-    let tarball = out.join(&name);\n-    if !tarball.exists() {\n-        let tmp = tarball.with_extension(\"tmp\");\n-        // originally from https://www.openssl.org/source/...\n-        let url = format!(\"https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/{}\",\n-                          name);\n-        let mut ok = false;\n-        for _ in 0..3 {\n-            let status = Command::new(\"curl\")\n-                            .arg(\"-o\").arg(&tmp)\n-                            .arg(&url)\n-                            .status()\n-                            .expect(\"failed to spawn curl\");\n-            if status.success() {\n-                ok = true;\n-                break\n-            }\n+impl<'a> Step<'a> for Openssl<'a> {\n+    type Output = ();\n+\n+    fn run(self, builder: &Builder) {\n+        let build = bulder.build;\n+        let target = self.target;\n+        let out = match build.openssl_dir(target) {\n+            Some(dir) => dir,\n+            None => return,\n+        };\n+\n+        let stamp = out.join(\".stamp\");\n+        let mut contents = String::new();\n+        drop(File::open(&stamp).and_then(|mut f| f.read_to_string(&mut contents)));\n+        if contents == OPENSSL_VERS {\n+            return\n         }\n-        if !ok {\n-            panic!(\"failed to download openssl source\")\n+        t!(fs::create_dir_all(&out));\n+\n+        let name = format!(\"openssl-{}.tar.gz\", OPENSSL_VERS);\n+        let tarball = out.join(&name);\n+        if !tarball.exists() {\n+            let tmp = tarball.with_extension(\"tmp\");\n+            // originally from https://www.openssl.org/source/...\n+            let url = format!(\"https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/{}\",\n+                              name);\n+            let mut ok = false;\n+            for _ in 0..3 {\n+                let status = Command::new(\"curl\")\n+                                .arg(\"-o\").arg(&tmp)\n+                                .arg(&url)\n+                                .status()\n+                                .expect(\"failed to spawn curl\");\n+                if status.success() {\n+                    ok = true;\n+                    break\n+                }\n+            }\n+            if !ok {\n+                panic!(\"failed to download openssl source\")\n+            }\n+            let mut shasum = if target.contains(\"apple\") {\n+                let mut cmd = Command::new(\"shasum\");\n+                cmd.arg(\"-a\").arg(\"256\");\n+                cmd\n+            } else {\n+                Command::new(\"sha256sum\")\n+            };\n+            let output = output(&mut shasum.arg(&tmp));\n+            let found = output.split_whitespace().next().unwrap();\n+            if found != OPENSSL_SHA256 {\n+                panic!(\"downloaded openssl sha256 different\\n\\\n+                        expected: {}\\n\\\n+                        found:    {}\\n\", OPENSSL_SHA256, found);\n+            }\n+            t!(fs::rename(&tmp, &tarball));\n         }\n-        let mut shasum = if target.contains(\"apple\") {\n-            let mut cmd = Command::new(\"shasum\");\n-            cmd.arg(\"-a\").arg(\"256\");\n-            cmd\n-        } else {\n-            Command::new(\"sha256sum\")\n+        let obj = out.join(format!(\"openssl-{}\", OPENSSL_VERS));\n+        let dst = build.openssl_install_dir(target).unwrap();\n+        drop(fs::remove_dir_all(&obj));\n+        drop(fs::remove_dir_all(&dst));\n+        build.run(Command::new(\"tar\").arg(\"xf\").arg(&tarball).current_dir(&out));\n+\n+        let mut configure = Command::new(obj.join(\"Configure\"));\n+        configure.arg(format!(\"--prefix={}\", dst.display()));\n+        configure.arg(\"no-dso\");\n+        configure.arg(\"no-ssl2\");\n+        configure.arg(\"no-ssl3\");\n+\n+        let os = match target {\n+            \"aarch64-linux-android\" => \"linux-aarch64\",\n+            \"aarch64-unknown-linux-gnu\" => \"linux-aarch64\",\n+            \"arm-linux-androideabi\" => \"android\",\n+            \"arm-unknown-linux-gnueabi\" => \"linux-armv4\",\n+            \"arm-unknown-linux-gnueabihf\" => \"linux-armv4\",\n+            \"armv7-linux-androideabi\" => \"android-armv7\",\n+            \"armv7-unknown-linux-gnueabihf\" => \"linux-armv4\",\n+            \"i686-apple-darwin\" => \"darwin-i386-cc\",\n+            \"i686-linux-android\" => \"android-x86\",\n+            \"i686-unknown-freebsd\" => \"BSD-x86-elf\",\n+            \"i686-unknown-linux-gnu\" => \"linux-elf\",\n+            \"i686-unknown-linux-musl\" => \"linux-elf\",\n+            \"mips-unknown-linux-gnu\" => \"linux-mips32\",\n+            \"mips64-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n+            \"mips64el-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n+            \"mipsel-unknown-linux-gnu\" => \"linux-mips32\",\n+            \"powerpc-unknown-linux-gnu\" => \"linux-ppc\",\n+            \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n+            \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n+            \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n+            \"x86_64-apple-darwin\" => \"darwin64-x86_64-cc\",\n+            \"x86_64-linux-android\" => \"linux-x86_64\",\n+            \"x86_64-unknown-freebsd\" => \"BSD-x86_64\",\n+            \"x86_64-unknown-linux-gnu\" => \"linux-x86_64\",\n+            \"x86_64-unknown-linux-musl\" => \"linux-x86_64\",\n+            \"x86_64-unknown-netbsd\" => \"BSD-x86_64\",\n+            _ => panic!(\"don't know how to configure OpenSSL for {}\", target),\n         };\n-        let output = output(&mut shasum.arg(&tmp));\n-        let found = output.split_whitespace().next().unwrap();\n-        if found != OPENSSL_SHA256 {\n-            panic!(\"downloaded openssl sha256 different\\n\\\n-                    expected: {}\\n\\\n-                    found:    {}\\n\", OPENSSL_SHA256, found);\n+        configure.arg(os);\n+        configure.env(\"CC\", build.cc(target));\n+        for flag in build.cflags(target) {\n+            configure.arg(flag);\n         }\n-        t!(fs::rename(&tmp, &tarball));\n-    }\n-    let obj = out.join(format!(\"openssl-{}\", OPENSSL_VERS));\n-    let dst = build.openssl_install_dir(target).unwrap();\n-    drop(fs::remove_dir_all(&obj));\n-    drop(fs::remove_dir_all(&dst));\n-    build.run(Command::new(\"tar\").arg(\"xf\").arg(&tarball).current_dir(&out));\n-\n-    let mut configure = Command::new(obj.join(\"Configure\"));\n-    configure.arg(format!(\"--prefix={}\", dst.display()));\n-    configure.arg(\"no-dso\");\n-    configure.arg(\"no-ssl2\");\n-    configure.arg(\"no-ssl3\");\n-\n-    let os = match target {\n-        \"aarch64-linux-android\" => \"linux-aarch64\",\n-        \"aarch64-unknown-linux-gnu\" => \"linux-aarch64\",\n-        \"arm-linux-androideabi\" => \"android\",\n-        \"arm-unknown-linux-gnueabi\" => \"linux-armv4\",\n-        \"arm-unknown-linux-gnueabihf\" => \"linux-armv4\",\n-        \"armv7-linux-androideabi\" => \"android-armv7\",\n-        \"armv7-unknown-linux-gnueabihf\" => \"linux-armv4\",\n-        \"i686-apple-darwin\" => \"darwin-i386-cc\",\n-        \"i686-linux-android\" => \"android-x86\",\n-        \"i686-unknown-freebsd\" => \"BSD-x86-elf\",\n-        \"i686-unknown-linux-gnu\" => \"linux-elf\",\n-        \"i686-unknown-linux-musl\" => \"linux-elf\",\n-        \"mips-unknown-linux-gnu\" => \"linux-mips32\",\n-        \"mips64-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n-        \"mips64el-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n-        \"mipsel-unknown-linux-gnu\" => \"linux-mips32\",\n-        \"powerpc-unknown-linux-gnu\" => \"linux-ppc\",\n-        \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n-        \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n-        \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n-        \"x86_64-apple-darwin\" => \"darwin64-x86_64-cc\",\n-        \"x86_64-linux-android\" => \"linux-x86_64\",\n-        \"x86_64-unknown-freebsd\" => \"BSD-x86_64\",\n-        \"x86_64-unknown-linux-gnu\" => \"linux-x86_64\",\n-        \"x86_64-unknown-linux-musl\" => \"linux-x86_64\",\n-        \"x86_64-unknown-netbsd\" => \"BSD-x86_64\",\n-        _ => panic!(\"don't know how to configure OpenSSL for {}\", target),\n-    };\n-    configure.arg(os);\n-    configure.env(\"CC\", build.cc(target));\n-    for flag in build.cflags(target) {\n-        configure.arg(flag);\n-    }\n-    // There is no specific os target for android aarch64 or x86_64,\n-    // so we need to pass some extra cflags\n-    if target == \"aarch64-linux-android\" || target == \"x86_64-linux-android\" {\n-        configure.arg(\"-mandroid\");\n-        configure.arg(\"-fomit-frame-pointer\");\n-    }\n-    // Make PIE binaries\n-    // Non-PIE linker support was removed in Lollipop\n-    // https://source.android.com/security/enhancements/enhancements50\n-    if target == \"i686-linux-android\" {\n-        configure.arg(\"no-asm\");\n+        // There is no specific os target for android aarch64 or x86_64,\n+        // so we need to pass some extra cflags\n+        if target == \"aarch64-linux-android\" || target == \"x86_64-linux-android\" {\n+            configure.arg(\"-mandroid\");\n+            configure.arg(\"-fomit-frame-pointer\");\n+        }\n+        // Make PIE binaries\n+        // Non-PIE linker support was removed in Lollipop\n+        // https://source.android.com/security/enhancements/enhancements50\n+        if target == \"i686-linux-android\" {\n+            configure.arg(\"no-asm\");\n+        }\n+        configure.current_dir(&obj);\n+        println!(\"Configuring openssl for {}\", target);\n+        build.run_quiet(&mut configure);\n+        println!(\"Building openssl for {}\", target);\n+        build.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n+        println!(\"Installing openssl for {}\", target);\n+        build.run_quiet(Command::new(\"make\").arg(\"install\").current_dir(&obj));\n+\n+        let mut f = t!(File::create(&stamp));\n+        t!(f.write_all(OPENSSL_VERS.as_bytes()));\n     }\n-    configure.current_dir(&obj);\n-    println!(\"Configuring openssl for {}\", target);\n-    build.run_quiet(&mut configure);\n-    println!(\"Building openssl for {}\", target);\n-    build.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n-    println!(\"Installing openssl for {}\", target);\n-    build.run_quiet(Command::new(\"make\").arg(\"install\").current_dir(&obj));\n-\n-    let mut f = t!(File::create(&stamp));\n-    t!(f.write_all(OPENSSL_VERS.as_bytes()));\n }"}, {"sha": "52ec273c3e8cd2239f51aec83aba2bba494ec256", "filename": "src/bootstrap/tool.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001e9f349087124165ed6deea6a87e0b158bba21/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=001e9f349087124165ed6deea6a87e0b158bba21", "patch": "@@ -0,0 +1,205 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use Mode;\n+use builder::{Step, Builder};\n+use util::{exe, add_lib_path};\n+use compile::{self, stamp, Rustc};\n+use native;\n+use channel::GitInfo;\n+\n+//// ========================================================================\n+//// Build tools\n+////\n+//// Tools used during the build system but not shipped\n+//// \"pseudo rule\" which represents completely cleaning out the tools dir in\n+//// one stage. This needs to happen whenever a dependency changes (e.g.\n+//// libstd, libtest, librustc) and all of the tool compilations above will\n+//// be sequenced after this rule.\n+//rules.build(\"maybe-clean-tools\", \"path/to/nowhere\")\n+//     .after(\"librustc-tool\")\n+//     .after(\"libtest-tool\")\n+//     .after(\"libstd-tool\");\n+//\n+//rules.build(\"librustc-tool\", \"path/to/nowhere\")\n+//     .dep(|s| s.name(\"librustc\"))\n+//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Librustc));\n+//rules.build(\"libtest-tool\", \"path/to/nowhere\")\n+//     .dep(|s| s.name(\"libtest\"))\n+//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libtest));\n+//rules.build(\"libstd-tool\", \"path/to/nowhere\")\n+//     .dep(|s| s.name(\"libstd\"))\n+//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libstd));\n+//\n+\n+#[derive(Serialize)]\n+pub struct CleanTools<'a> {\n+    pub stage: u32,\n+    pub target: &'a str,\n+    pub mode: Mode,\n+}\n+\n+impl<'a> Step<'a> for CleanTools<'a> {\n+    type Output = ();\n+\n+    /// Build a tool in `src/tools`\n+    ///\n+    /// This will build the specified tool with the specified `host` compiler in\n+    /// `stage` into the normal cargo output directory.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        let mode = self.mode;\n+\n+        let compiler = Compiler::new(stage, &build.build);\n+\n+        let stamp = match mode {\n+            Mode::Libstd => libstd_stamp(build, &compiler, target),\n+            Mode::Libtest => libtest_stamp(build, &compiler, target),\n+            Mode::Librustc => librustc_stamp(build, &compiler, target),\n+            _ => panic!(),\n+        };\n+        let out_dir = build.cargo_out(&compiler, Mode::Tool, target);\n+        build.clear_if_dirty(&out_dir, &stamp);\n+    }\n+}\n+\n+// rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"librustc-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n+// rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"librustc-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n+// rules.build(\"tool-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"unstable-book-gen\"));\n+// rules.build(\"tool-tidy\", \"src/tools/tidy\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n+// rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n+// rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n+// rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libtest-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+// rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n+// rules.build(\"tool-remote-test-server\", \"src/tools/remote-test-server\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-server\"));\n+// rules.build(\"tool-remote-test-client\", \"src/tools/remote-test-client\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n+// rules.build(\"tool-rust-installer\", \"src/tools/rust-installer\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"rust-installer\"));\n+// rules.build(\"tool-cargo\", \"src/tools/cargo\")\n+//      .host(true)\n+//      .default(build.config.extended)\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n+//      .dep(move |s| {\n+//          // Cargo depends on procedural macros, which requires a full host\n+//          // compiler to be available, so we need to depend on that.\n+//          s.name(\"librustc-link\")\n+//           .target(&build.build)\n+//           .host(&build.build)\n+//      })\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n+// rules.build(\"tool-rls\", \"src/tools/rls\")\n+//      .host(true)\n+//      .default(build.config.extended)\n+//      .dep(|s| s.name(\"librustc-tool\"))\n+//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n+//      .dep(move |s| {\n+//          // rls, like cargo, uses procedural macros\n+//          s.name(\"librustc-link\")\n+//           .target(&build.build)\n+//           .host(&build.build)\n+//      })\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n+//\n+\n+#[derive(Serialize)]\n+pub struct Tool<'a> {\n+    pub stage: u32,\n+    pub target: &'a str,\n+    pub tool: &'a str,\n+}\n+\n+impl<'a> Step<'a> for Tool<'a> {\n+    type Output = ();\n+\n+    /// Build a tool in `src/tools`\n+    ///\n+    /// This will build the specified tool with the specified `host` compiler in\n+    /// `stage` into the normal cargo output directory.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        let tool = self.tool;\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-{}\", stage, tool));\n+        println!(\"Building stage{} tool {} ({})\", stage, tool, target);\n+\n+        let compiler = Compiler::new(stage, &build.build);\n+\n+        let mut cargo = build.cargo(&compiler, Mode::Tool, target, \"build\");\n+        let dir = build.src.join(\"src/tools\").join(tool);\n+        cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n+\n+        // We don't want to build tools dynamically as they'll be running across\n+        // stages and such and it's just easier if they're not dynamically linked.\n+        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+        if let Some(dir) = build.openssl_install_dir(target) {\n+            cargo.env(\"OPENSSL_STATIC\", \"1\");\n+            cargo.env(\"OPENSSL_DIR\", dir);\n+            cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n+        }\n+\n+        cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n+\n+        let info = GitInfo::new(&dir);\n+        if let Some(sha) = info.sha() {\n+            cargo.env(\"CFG_COMMIT_HASH\", sha);\n+        }\n+        if let Some(sha_short) = info.sha_short() {\n+            cargo.env(\"CFG_SHORT_COMMIT_HASH\", sha_short);\n+        }\n+        if let Some(date) = info.commit_date() {\n+            cargo.env(\"CFG_COMMIT_DATE\", date);\n+        }\n+\n+        build.run(&mut cargo);\n+    }\n+}"}]}