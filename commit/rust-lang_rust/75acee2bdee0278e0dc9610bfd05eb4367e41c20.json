{"sha": "75acee2bdee0278e0dc9610bfd05eb4367e41c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YWNlZTJiZGVlMDI3OGUwZGM5NjEwYmZkMDVlYjQzNjdlNDFjMjA=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2016-02-10T02:15:29Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2016-02-10T02:20:41Z"}, "message": "Rustdoc - display `since` version for stable items\n\nFixes #27607", "tree": {"sha": "62cd19af696adf82ca19dad72bcf55774ffdd15f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62cd19af696adf82ca19dad72bcf55774ffdd15f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75acee2bdee0278e0dc9610bfd05eb4367e41c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75acee2bdee0278e0dc9610bfd05eb4367e41c20", "html_url": "https://github.com/rust-lang/rust/commit/75acee2bdee0278e0dc9610bfd05eb4367e41c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75acee2bdee0278e0dc9610bfd05eb4367e41c20/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32b2ef7add2836cba5867d2e5ac9610cef416447", "url": "https://api.github.com/repos/rust-lang/rust/commits/32b2ef7add2836cba5867d2e5ac9610cef416447", "html_url": "https://github.com/rust-lang/rust/commit/32b2ef7add2836cba5867d2e5ac9610cef416447"}], "stats": {"total": 121, "additions": 94, "deletions": 27}, "files": [{"sha": "5e8b1194da015ce8c7a18c9838fd06966605657e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75acee2bdee0278e0dc9610bfd05eb4367e41c20/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75acee2bdee0278e0dc9610bfd05eb4367e41c20/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=75acee2bdee0278e0dc9610bfd05eb4367e41c20", "patch": "@@ -339,6 +339,14 @@ impl Item {\n             _ => String::new(),\n         }\n     }\n+\n+    pub fn stable_since(&self) -> Option<&str> {\n+        if let Some(ref s) = self.stability {\n+            return Some(&s.since[..]);\n+        }\n+\n+        None\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "12a17afcc7c502a281ca4245e69d649bf4f87bb0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 71, "deletions": 27, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/75acee2bdee0278e0dc9610bfd05eb4367e41c20/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75acee2bdee0278e0dc9610bfd05eb4367e41c20/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=75acee2bdee0278e0dc9610bfd05eb4367e41c20", "patch": "@@ -1913,6 +1913,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n            decl = f.decl));\n+    try!(render_stability_since_raw(w, it.stable_since(), None));\n     document(w, cx, it)\n }\n \n@@ -1992,15 +1993,17 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Trait documentation\n     try!(document(w, cx, it));\n \n-    fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item)\n+    fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n         let id = derive_id(format!(\"{}.{}\", shortty(m), name));\n         try!(write!(w, \"<h3 id='{id}' class='method stab {stab}'><code>\",\n                        id = id,\n                        stab = m.stability_class()));\n         try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n-        try!(write!(w, \"</code></h3>\"));\n+        try!(write!(w, \"</code>\"));\n+        try!(render_stability_since(w, m, t));\n+        try!(write!(w, \"</h3>\"));\n         try!(document(w, cx, m));\n         Ok(())\n     }\n@@ -2011,7 +2014,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for t in &types {\n-            try!(trait_item(w, cx, *t));\n+            try!(trait_item(w, cx, *t, it));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n@@ -2022,7 +2025,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for t in &consts {\n-            try!(trait_item(w, cx, *t));\n+            try!(trait_item(w, cx, *t, it));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n@@ -2034,7 +2037,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for m in &required {\n-            try!(trait_item(w, cx, *m));\n+            try!(trait_item(w, cx, *m, it));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n@@ -2044,13 +2047,13 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             <div class='methods'>\n         \"));\n         for m in &provided {\n-            try!(trait_item(w, cx, *m));\n+            try!(trait_item(w, cx, *m, it));\n         }\n         try!(write!(w, \"</div>\"));\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    try!(render_assoc_items(w, cx, it.def_id, AssocItemRender::All));\n+    try!(render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All));\n \n     let cache = cache();\n     try!(write!(w, \"\n@@ -2106,6 +2109,29 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n+fn render_stability_since_raw<'a>(w: &mut fmt::Formatter,\n+                                  ver: Option<&'a str>,\n+                                  containing_ver: Option<&'a str>) -> fmt::Result {\n+    if containing_ver != ver {\n+        match ver {\n+            Some(v) =>\n+                if v.len() > 0 {\n+                        try!(write!(w, \"<span class=\\\"since\\\">{}</span>\",\n+                                    v))\n+                },\n+            None => {}\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn render_stability_since(w: &mut fmt::Formatter,\n+                          item: &clean::Item,\n+                          containing_item: &clean::Item) -> fmt::Result {\n+    render_stability_since_raw(w, item.stable_since(), containing_item.stable_since())\n+}\n+\n fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n                      link: AssocItemLink) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter,\n@@ -2178,6 +2204,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                        \"\",\n                        true));\n     try!(write!(w, \"</pre>\"));\n+    try!(render_stability_since_raw(w, it.stable_since(), None));\n \n     try!(document(w, cx, it));\n     let mut fields = s.fields.iter().filter(|f| {\n@@ -2202,7 +2229,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             try!(write!(w, \"</table>\"));\n         }\n     }\n-    render_assoc_items(w, cx, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n@@ -2257,10 +2284,11 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"}}\"));\n     }\n     try!(write!(w, \"</pre>\"));\n+    try!(render_stability_since_raw(w, it.stable_since(), None));\n \n     try!(document(w, cx, it));\n     if !e.variants.is_empty() {\n-        try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n+        try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table class='variants_table'>\"));\n         for variant in &e.variants {\n             try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n                           name = variant.name.as_ref().unwrap()));\n@@ -2296,12 +2324,14 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 }\n                 _ => ()\n             }\n+            try!(write!(w, \"</td><td>\"));\n+            try!(render_stability_since(w, variant, it));\n             try!(write!(w, \"</td></tr>\"));\n         }\n         try!(write!(w, \"</table>\"));\n \n     }\n-    try!(render_assoc_items(w, cx, it.def_id, AssocItemRender::All));\n+    try!(render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All));\n     Ok(())\n }\n \n@@ -2397,6 +2427,7 @@ enum AssocItemRender<'a> {\n \n fn render_assoc_items(w: &mut fmt::Formatter,\n                       cx: &Context,\n+                      containing_item: &clean::Item,\n                       it: DefId,\n                       what: AssocItemRender) -> fmt::Result {\n     let c = cache();\n@@ -2420,7 +2451,8 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             }\n         };\n         for i in &non_trait {\n-            try!(render_impl(w, cx, i, AssocItemLink::Anchor, render_header));\n+            try!(render_impl(w, cx, i, AssocItemLink::Anchor, render_header,\n+                             containing_item.stable_since()));\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n@@ -2436,7 +2468,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             }\n         });\n         if let Some(impl_) = deref_impl {\n-            try!(render_deref_methods(w, cx, impl_));\n+            try!(render_deref_methods(w, cx, impl_, containing_item));\n         }\n         try!(write!(w, \"<h2 id='implementations'>Trait \\\n                           Implementations</h2>\"));\n@@ -2445,22 +2477,25 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            try!(render_impl(w, cx, i, AssocItemLink::GotoSource(did), true));\n+            try!(render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n+                             containing_item.stable_since()));\n         }\n         if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                try!(render_impl(w, cx, i, AssocItemLink::GotoSource(did), true));\n+                try!(render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n+                                 containing_item.stable_since()));\n             }\n         }\n     }\n     Ok(())\n }\n \n-fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl) -> fmt::Result {\n+fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n+                        container_item: &clean::Item) -> fmt::Result {\n     let deref_type = impl_.impl_.trait_.as_ref().unwrap();\n     let target = impl_.impl_.items.iter().filter_map(|item| {\n         match item.inner {\n@@ -2470,12 +2505,12 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl) -> f\n     }).next().expect(\"Expected associated type binding\");\n     let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target };\n     match *target {\n-        clean::ResolvedPath { did, .. } => render_assoc_items(w, cx, did, what),\n+        clean::ResolvedPath { did, .. } => render_assoc_items(w, cx, container_item, did, what),\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n                     let did = DefId { krate: *c, index: prim.to_def_index() };\n-                    try!(render_assoc_items(w, cx, did, what));\n+                    try!(render_assoc_items(w, cx, container_item, did, what));\n                 }\n             }\n             Ok(())\n@@ -2487,24 +2522,30 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl) -> f\n // otherwise. If render_header is false, we will avoid rendering static\n // methods, since they are not accessible for the type implementing `Deref`\n fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n-               render_header: bool) -> fmt::Result {\n+               render_header: bool, outer_version: Option<&str>) -> fmt::Result {\n     if render_header {\n-        try!(write!(w, \"<h3 class='impl'><code>{}</code></h3>\", i.impl_));\n+        try!(write!(w, \"<h3 class='impl'><code>{}</code>\", i.impl_));\n+        let since = i.stability.as_ref().map(|s| &s.since[..]);\n+        try!(render_stability_since_raw(w, since, outer_version));\n+        try!(write!(w, \"</h3>\"));\n         if let Some(ref dox) = i.dox {\n             try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox)));\n         }\n     }\n \n     fn doctraititem(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item,\n-                    link: AssocItemLink, render_static: bool) -> fmt::Result {\n+                    link: AssocItemLink, render_static: bool,\n+                    outer_version: Option<&str>) -> fmt::Result {\n         let name = item.name.as_ref().unwrap();\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n                 if !is_static_method(item) || render_static {\n                     let id = derive_id(format!(\"method.{}\", name));\n-                    try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n-                try!(render_assoc_item(w, item, link));\n+                    try!(write!(w, \"<h4 id='{}' class='{}'>\", id, shortty(item)));\n+                    try!(render_stability_since_raw(w, item.stable_since(), outer_version));\n+                    try!(write!(w, \"<code>\"));\n+                    try!(render_assoc_item(w, item, link));\n                     try!(write!(w, \"</code></h4>\\n\"));\n                 }\n             }\n@@ -2556,23 +2597,25 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n     try!(write!(w, \"<div class='impl-items'>\"));\n     for trait_item in &i.impl_.items {\n-        try!(doctraititem(w, cx, trait_item, link, render_header));\n+        try!(doctraititem(w, cx, trait_item, link, render_header, outer_version));\n     }\n \n     fn render_default_items(w: &mut fmt::Formatter,\n                             cx: &Context,\n                             did: DefId,\n                             t: &clean::Trait,\n                               i: &clean::Impl,\n-                              render_static: bool) -> fmt::Result {\n+                              render_static: bool,\n+                              outer_version: Option<&str>) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n             match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n                 None => {}\n             }\n \n-            try!(doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static));\n+            try!(doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static,\n+                              outer_version));\n         }\n         Ok(())\n     }\n@@ -2583,7 +2626,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     // for them work.\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n-            try!(render_default_items(w, cx, did, t, &i.impl_, render_header));\n+            try!(render_default_items(w, cx, did, t, &i.impl_, render_header, outer_version));\n \n         }\n     }\n@@ -2675,14 +2718,15 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     try!(w.write_str(&highlight::highlight(&t.source,\n                                           Some(\"macro\"),\n                                           None)));\n+    try!(render_stability_since_raw(w, it.stable_since(), None));\n     document(w, cx, it)\n }\n \n fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n     try!(document(w, cx, it));\n-    render_assoc_items(w, cx, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn get_basic_keywords() -> &'static str {"}, {"sha": "1cadc4e476ac4512d18004cdb42a6caaa569cb82", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75acee2bdee0278e0dc9610bfd05eb4367e41c20/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/75acee2bdee0278e0dc9610bfd05eb4367e41c20/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=75acee2bdee0278e0dc9610bfd05eb4367e41c20", "patch": "@@ -498,6 +498,21 @@ em.stab p {\n     opacity: 0.65;\n }\n \n+span.since {\n+    float: right;\n+    font-weight: normal;\n+    font-size: initial;\n+    color: grey;\n+}\n+\n+.variants_table {\n+    width: 100%;\n+}\n+\n+.variants_table tbody tr td:first-child {\n+    width: 1%; /* make the variant name as small as possible */\n+}\n+\n td.summary-column {\n     width: 100%;\n }"}]}