{"sha": "da569fa9ddf8369a9809184d43c600dc06bd4b4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNTY5ZmE5ZGRmODM2OWE5ODA5MTg0ZDQzYzYwMGRjMDZiZDRiNGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-16T08:06:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-16T08:06:15Z"}, "message": "Auto merge of #47209 - eddyb:ccx, r=nikomatsakis\n\nrustc_trans: reorganize CrateContext and rename context types.\n\nFirstly, the `{Shared,Local}CrateContext` hasn't been meaningful for a while now, and this PR resolves it by moving all their fields to `CrateContext` and removing redundant accessor methods.\n\nSecondly, this PR contains the following mass-renames:\n* `ccx: CrateContext` -> `cx: CodegenCx`\n* `mircx: MirContext` -> `fx: FunctionCx`\n* `bcx: Builder` -> `bx: Builder`\n\nr? @nikomatsakis", "tree": {"sha": "ab2525d5f06e049c2d5092631fe781d79b9037c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab2525d5f06e049c2d5092631fe781d79b9037c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da569fa9ddf8369a9809184d43c600dc06bd4b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da569fa9ddf8369a9809184d43c600dc06bd4b4d", "html_url": "https://github.com/rust-lang/rust/commit/da569fa9ddf8369a9809184d43c600dc06bd4b4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da569fa9ddf8369a9809184d43c600dc06bd4b4d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79a521bb9a8ace1a6663578a4c409906adde620d", "url": "https://api.github.com/repos/rust-lang/rust/commits/79a521bb9a8ace1a6663578a4c409906adde620d", "html_url": "https://github.com/rust-lang/rust/commit/79a521bb9a8ace1a6663578a4c409906adde620d"}, {"sha": "4e40a0d43640a5cf26f28cea35ec16445966a000", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e40a0d43640a5cf26f28cea35ec16445966a000", "html_url": "https://github.com/rust-lang/rust/commit/4e40a0d43640a5cf26f28cea35ec16445966a000"}], "stats": {"total": 4508, "additions": 2137, "deletions": 2371}, "files": [{"sha": "b97e37f4c8fb903cd43b15ea926cd258ee7122f7", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -1661,7 +1661,6 @@ extern \"C\" {\n     pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n \n     pub fn LLVMRustSetDataLayoutFromTargetMachine(M: ModuleRef, TM: TargetMachineRef);\n-    pub fn LLVMRustGetModuleDataLayout(M: ModuleRef) -> TargetDataRef;\n \n     pub fn LLVMRustBuildOperandBundleDef(Name: *const c_char,\n                                          Inputs: *const ValueRef,"}, {"sha": "07f9b8fed8b57593c709d94cbef020083e8b732a", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -12,7 +12,7 @@ use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n use common::{ty_fn_sig, C_usize};\n-use context::CrateContext;\n+use context::CodegenCx;\n use cabi_x86;\n use cabi_x86_64;\n use cabi_x86_win64;\n@@ -209,8 +209,8 @@ impl Reg {\n }\n \n impl Reg {\n-    pub fn align(&self, ccx: &CrateContext) -> Align {\n-        let dl = ccx.data_layout();\n+    pub fn align(&self, cx: &CodegenCx) -> Align {\n+        let dl = cx.data_layout();\n         match self.kind {\n             RegKind::Integer => {\n                 match self.size.bits() {\n@@ -234,18 +234,18 @@ impl Reg {\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n         match self.kind {\n-            RegKind::Integer => Type::ix(ccx, self.size.bits()),\n+            RegKind::Integer => Type::ix(cx, self.size.bits()),\n             RegKind::Float => {\n                 match self.size.bits() {\n-                    32 => Type::f32(ccx),\n-                    64 => Type::f64(ccx),\n+                    32 => Type::f32(cx),\n+                    64 => Type::f64(cx),\n                     _ => bug!(\"unsupported float: {:?}\", self)\n                 }\n             }\n             RegKind::Vector => {\n-                Type::vector(&Type::i8(ccx), self.size.bytes())\n+                Type::vector(&Type::i8(cx), self.size.bytes())\n             }\n         }\n     }\n@@ -276,12 +276,12 @@ impl From<Reg> for Uniform {\n }\n \n impl Uniform {\n-    pub fn align(&self, ccx: &CrateContext) -> Align {\n-        self.unit.align(ccx)\n+    pub fn align(&self, cx: &CodegenCx) -> Align {\n+        self.unit.align(cx)\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n-        let llunit = self.unit.llvm_type(ccx);\n+    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n+        let llunit = self.unit.llvm_type(cx);\n \n         if self.total <= self.unit.size {\n             return llunit;\n@@ -298,16 +298,16 @@ impl Uniform {\n         assert_eq!(self.unit.kind, RegKind::Integer);\n \n         let args: Vec<_> = (0..count).map(|_| llunit)\n-            .chain(iter::once(Type::ix(ccx, rem_bytes * 8)))\n+            .chain(iter::once(Type::ix(cx, rem_bytes * 8)))\n             .collect();\n \n-        Type::struct_(ccx, &args, false)\n+        Type::struct_(cx, &args, false)\n     }\n }\n \n pub trait LayoutExt<'tcx> {\n     fn is_aggregate(&self) -> bool;\n-    fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg>;\n+    fn homogeneous_aggregate<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<Reg>;\n }\n \n impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n@@ -321,7 +321,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n+    fn homogeneous_aggregate<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Option<Reg> {\n         match self.abi {\n             layout::Abi::Uninhabited => None,\n \n@@ -354,7 +354,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                 let is_union = match self.fields {\n                     layout::FieldPlacement::Array { count, .. } => {\n                         if count > 0 {\n-                            return self.field(ccx, 0).homogeneous_aggregate(ccx);\n+                            return self.field(cx, 0).homogeneous_aggregate(cx);\n                         } else {\n                             return None;\n                         }\n@@ -368,8 +368,8 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                         return None;\n                     }\n \n-                    let field = self.field(ccx, i);\n-                    match (result, field.homogeneous_aggregate(ccx)) {\n+                    let field = self.field(cx, i);\n+                    match (result, field.homogeneous_aggregate(cx)) {\n                         // The field itself must be a homogeneous aggregate.\n                         (_, None) => return None,\n                         // If this is the first field, record the unit.\n@@ -423,34 +423,34 @@ impl From<Uniform> for CastTarget {\n }\n \n impl CastTarget {\n-    pub fn size(&self, ccx: &CrateContext) -> Size {\n+    pub fn size(&self, cx: &CodegenCx) -> Size {\n         match *self {\n             CastTarget::Uniform(u) => u.total,\n             CastTarget::Pair(a, b) => {\n-                (a.size.abi_align(a.align(ccx)) + b.size)\n-                    .abi_align(self.align(ccx))\n+                (a.size.abi_align(a.align(cx)) + b.size)\n+                    .abi_align(self.align(cx))\n             }\n         }\n     }\n \n-    pub fn align(&self, ccx: &CrateContext) -> Align {\n+    pub fn align(&self, cx: &CodegenCx) -> Align {\n         match *self {\n-            CastTarget::Uniform(u) => u.align(ccx),\n+            CastTarget::Uniform(u) => u.align(cx),\n             CastTarget::Pair(a, b) => {\n-                ccx.data_layout().aggregate_align\n-                    .max(a.align(ccx))\n-                    .max(b.align(ccx))\n+                cx.data_layout().aggregate_align\n+                    .max(a.align(cx))\n+                    .max(b.align(cx))\n             }\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn llvm_type(&self, cx: &CodegenCx) -> Type {\n         match *self {\n-            CastTarget::Uniform(u) => u.llvm_type(ccx),\n+            CastTarget::Uniform(u) => u.llvm_type(cx),\n             CastTarget::Pair(a, b) => {\n-                Type::struct_(ccx, &[\n-                    a.llvm_type(ccx),\n-                    b.llvm_type(ccx)\n+                Type::struct_(cx, &[\n+                    a.llvm_type(cx),\n+                    b.llvm_type(cx)\n                 ], false)\n             }\n         }\n@@ -547,28 +547,28 @@ impl<'a, 'tcx> ArgType<'tcx> {\n \n     /// Get the LLVM type for an place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n-    pub fn memory_ty(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n-        self.layout.llvm_type(ccx)\n+    pub fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+        self.layout.llvm_type(cx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n+    pub fn store(&self, bx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n-        let ccx = bcx.ccx;\n+        let cx = bx.cx;\n         if self.is_indirect() {\n-            OperandValue::Ref(val, self.layout.align).store(bcx, dst)\n+            OperandValue::Ref(val, self.layout.align).store(bx, dst)\n         } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bcx.pointercast(dst.llval, cast.llvm_type(ccx).ptr_to());\n-                bcx.store(val, cast_dst, self.layout.align);\n+                let cast_dst = bx.pointercast(dst.llval, cast.llvm_type(cx).ptr_to());\n+                bx.store(val, cast_dst, self.layout.align);\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -585,44 +585,44 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let scratch_size = cast.size(ccx);\n-                let scratch_align = cast.align(ccx);\n-                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", scratch_align);\n-                bcx.lifetime_start(llscratch, scratch_size);\n+                let scratch_size = cast.size(cx);\n+                let scratch_align = cast.align(cx);\n+                let llscratch = bx.alloca(cast.llvm_type(cx), \"abi_cast\", scratch_align);\n+                bx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value...\n-                bcx.store(val, llscratch, scratch_align);\n+                bx.store(val, llscratch, scratch_align);\n \n                 // ...and then memcpy it to the intended destination.\n-                base::call_memcpy(bcx,\n-                                  bcx.pointercast(dst.llval, Type::i8p(ccx)),\n-                                  bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_usize(ccx, self.layout.size.bytes()),\n+                base::call_memcpy(bx,\n+                                  bx.pointercast(dst.llval, Type::i8p(cx)),\n+                                  bx.pointercast(llscratch, Type::i8p(cx)),\n+                                  C_usize(cx, self.layout.size.bytes()),\n                                   self.layout.align.min(scratch_align));\n \n-                bcx.lifetime_end(llscratch, scratch_size);\n+                bx.lifetime_end(llscratch, scratch_size);\n             }\n         } else {\n-            OperandValue::Immediate(val).store(bcx, dst);\n+            OperandValue::Immediate(val).store(bx, dst);\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n+    pub fn store_fn_arg(&self, bx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n         let mut next = || {\n-            let val = llvm::get_param(bcx.llfn(), *idx as c_uint);\n+            let val = llvm::get_param(bx.llfn(), *idx as c_uint);\n             *idx += 1;\n             val\n         };\n         match self.mode {\n             PassMode::Ignore => {},\n             PassMode::Pair(..) => {\n-                OperandValue::Pair(next(), next()).store(bcx, dst);\n+                OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n             PassMode::Direct(_) | PassMode::Indirect(_) | PassMode::Cast(_) => {\n-                self.store(bcx, next(), dst);\n+                self.store(bx, next(), dst);\n             }\n         }\n     }\n@@ -647,26 +647,26 @@ pub struct FnType<'tcx> {\n }\n \n impl<'a, 'tcx> FnType<'tcx> {\n-    pub fn of_instance(ccx: &CrateContext<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+    pub fn of_instance(cx: &CodegenCx<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n-        let fn_ty = instance.ty(ccx.tcx());\n-        let sig = ty_fn_sig(ccx, fn_ty);\n-        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-        FnType::new(ccx, sig, &[])\n+        let fn_ty = instance.ty(cx.tcx);\n+        let sig = ty_fn_sig(cx, fn_ty);\n+        let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+        FnType::new(cx, sig, &[])\n     }\n \n-    pub fn new(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn new(cx: &CodegenCx<'a, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n-        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n-        fn_ty.adjust_for_abi(ccx, sig.abi);\n+        let mut fn_ty = FnType::unadjusted(cx, sig, extra_args);\n+        fn_ty.adjust_for_abi(cx, sig.abi);\n         fn_ty\n     }\n \n-    pub fn new_vtable(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn new_vtable(cx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n-        let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n+        let mut fn_ty = FnType::unadjusted(cx, sig, extra_args);\n         // Don't pass the vtable, it's not an argument of the virtual fn.\n         {\n             let self_arg = &mut fn_ty.args[0];\n@@ -681,20 +681,20 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 .unwrap_or_else(|| {\n                     bug!(\"FnType::new_vtable: non-pointer self {:?}\", self_arg)\n                 }).ty;\n-            let fat_ptr_ty = ccx.tcx().mk_mut_ptr(pointee);\n-            self_arg.layout = ccx.layout_of(fat_ptr_ty).field(ccx, 0);\n+            let fat_ptr_ty = cx.tcx.mk_mut_ptr(pointee);\n+            self_arg.layout = cx.layout_of(fat_ptr_ty).field(cx, 0);\n         }\n-        fn_ty.adjust_for_abi(ccx, sig.abi);\n+        fn_ty.adjust_for_abi(cx, sig.abi);\n         fn_ty\n     }\n \n-    pub fn unadjusted(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn unadjusted(cx: &CodegenCx<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         debug!(\"FnType::unadjusted({:?}, {:?})\", sig, extra_args);\n \n         use self::Abi::*;\n-        let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n+        let cconv = match cx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |\n             Rust | RustCall => llvm::CCallConv,\n \n@@ -737,7 +737,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n             extra_args\n         };\n \n-        let target = &ccx.sess().target.target;\n+        let target = &cx.sess().target.target;\n         let win_x64_gnu = target.target_os == \"windows\"\n                        && target.arch == \"x86_64\"\n                        && target.target_env == \"gnu\";\n@@ -772,7 +772,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 }\n             }\n \n-            if let Some(pointee) = layout.pointee_info_at(ccx, offset) {\n+            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n                 if let Some(kind) = pointee.safe {\n                     attrs.pointee_size = pointee.size;\n                     attrs.pointee_align = Some(pointee.align);\n@@ -809,7 +809,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n         };\n \n         let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n-            let mut arg = ArgType::new(ccx.layout_of(ty));\n+            let mut arg = ArgType::new(cx.layout_of(ty));\n             if arg.layout.is_zst() {\n                 // For some forsaken reason, x86_64-pc-windows-gnu\n                 // doesn't ignore zero-sized struct arguments.\n@@ -832,7 +832,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                     adjust_for_rust_scalar(&mut b_attrs,\n                                            b,\n                                            arg.layout,\n-                                           a.value.size(ccx).abi_align(b.value.align(ccx)),\n+                                           a.value.size(cx).abi_align(b.value.align(cx)),\n                                            false);\n                     arg.mode = PassMode::Pair(a_attrs, b_attrs);\n                     return arg;\n@@ -863,7 +863,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n     }\n \n     fn adjust_for_abi(&mut self,\n-                      ccx: &CrateContext<'a, 'tcx>,\n+                      cx: &CodegenCx<'a, 'tcx>,\n                       abi: Abi) {\n         if abi == Abi::Unadjusted { return }\n \n@@ -878,7 +878,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 }\n \n                 let size = arg.layout.size;\n-                if size > layout::Pointer.size(ccx) {\n+                if size > layout::Pointer.size(cx) {\n                     arg.make_indirect();\n                 } else {\n                     // We want to pass small aggregates as immediates, but using\n@@ -900,76 +900,76 @@ impl<'a, 'tcx> FnType<'tcx> {\n             return;\n         }\n \n-        match &ccx.sess().target.target.arch[..] {\n+        match &cx.sess().target.target.arch[..] {\n             \"x86\" => {\n                 let flavor = if abi == Abi::Fastcall {\n                     cabi_x86::Flavor::Fastcall\n                 } else {\n                     cabi_x86::Flavor::General\n                 };\n-                cabi_x86::compute_abi_info(ccx, self, flavor);\n+                cabi_x86::compute_abi_info(cx, self, flavor);\n             },\n             \"x86_64\" => if abi == Abi::SysV64 {\n-                cabi_x86_64::compute_abi_info(ccx, self);\n-            } else if abi == Abi::Win64 || ccx.sess().target.target.options.is_like_windows {\n+                cabi_x86_64::compute_abi_info(cx, self);\n+            } else if abi == Abi::Win64 || cx.sess().target.target.options.is_like_windows {\n                 cabi_x86_win64::compute_abi_info(self);\n             } else {\n-                cabi_x86_64::compute_abi_info(ccx, self);\n+                cabi_x86_64::compute_abi_info(cx, self);\n             },\n-            \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, self),\n-            \"arm\" => cabi_arm::compute_abi_info(ccx, self),\n-            \"mips\" => cabi_mips::compute_abi_info(ccx, self),\n-            \"mips64\" => cabi_mips64::compute_abi_info(ccx, self),\n-            \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, self),\n-            \"powerpc64\" => cabi_powerpc64::compute_abi_info(ccx, self),\n-            \"s390x\" => cabi_s390x::compute_abi_info(ccx, self),\n-            \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, self),\n-            \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n+            \"aarch64\" => cabi_aarch64::compute_abi_info(cx, self),\n+            \"arm\" => cabi_arm::compute_abi_info(cx, self),\n+            \"mips\" => cabi_mips::compute_abi_info(cx, self),\n+            \"mips64\" => cabi_mips64::compute_abi_info(cx, self),\n+            \"powerpc\" => cabi_powerpc::compute_abi_info(cx, self),\n+            \"powerpc64\" => cabi_powerpc64::compute_abi_info(cx, self),\n+            \"s390x\" => cabi_s390x::compute_abi_info(cx, self),\n+            \"asmjs\" => cabi_asmjs::compute_abi_info(cx, self),\n+            \"wasm32\" => cabi_asmjs::compute_abi_info(cx, self),\n             \"msp430\" => cabi_msp430::compute_abi_info(self),\n-            \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n-            \"sparc64\" => cabi_sparc64::compute_abi_info(ccx, self),\n+            \"sparc\" => cabi_sparc::compute_abi_info(cx, self),\n+            \"sparc64\" => cabi_sparc64::compute_abi_info(cx, self),\n             \"nvptx\" => cabi_nvptx::compute_abi_info(self),\n             \"nvptx64\" => cabi_nvptx64::compute_abi_info(self),\n             \"hexagon\" => cabi_hexagon::compute_abi_info(self),\n-            a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n+            a => cx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n         if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n             attrs.set(ArgAttribute::StructRet);\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+    pub fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore => Type::void(ccx),\n+            PassMode::Ignore => Type::void(cx),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n-                self.ret.layout.immediate_llvm_type(ccx)\n+                self.ret.layout.immediate_llvm_type(cx)\n             }\n-            PassMode::Cast(cast) => cast.llvm_type(ccx),\n+            PassMode::Cast(cast) => cast.llvm_type(cx),\n             PassMode::Indirect(_) => {\n-                llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n-                Type::void(ccx)\n+                llargument_tys.push(self.ret.memory_ty(cx).ptr_to());\n+                Type::void(cx)\n             }\n         };\n \n         for arg in &self.args {\n             // add padding\n             if let Some(ty) = arg.pad {\n-                llargument_tys.push(ty.llvm_type(ccx));\n+                llargument_tys.push(ty.llvm_type(cx));\n             }\n \n             let llarg_ty = match arg.mode {\n                 PassMode::Ignore => continue,\n-                PassMode::Direct(_) => arg.layout.immediate_llvm_type(ccx),\n+                PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n-                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(ccx, 0));\n-                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(ccx, 1));\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 0));\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1));\n                     continue;\n                 }\n-                PassMode::Cast(cast) => cast.llvm_type(ccx),\n-                PassMode::Indirect(_) => arg.memory_ty(ccx).ptr_to(),\n+                PassMode::Cast(cast) => cast.llvm_type(cx),\n+                PassMode::Indirect(_) => arg.memory_ty(cx).ptr_to(),\n             };\n             llargument_tys.push(llarg_ty);\n         }"}, {"sha": "c7be0c4e67d712a3617e9a16f5884f23314dbedd", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -27,7 +27,7 @@ use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n pub fn trans_inline_asm<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     ia: &hir::InlineAsm,\n     outputs: Vec<PlaceRef<'tcx>>,\n     mut inputs: Vec<ValueRef>\n@@ -39,13 +39,13 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     let mut indirect_outputs = vec![];\n     for (i, (out, place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n         if out.is_rw {\n-            inputs.push(place.load(bcx).immediate());\n+            inputs.push(place.load(bx).immediate());\n             ext_constraints.push(i.to_string());\n         }\n         if out.is_indirect {\n-            indirect_outputs.push(place.load(bcx).immediate());\n+            indirect_outputs.push(place.load(bx).immediate());\n         } else {\n-            output_types.push(place.layout.llvm_type(bcx.ccx));\n+            output_types.push(place.layout.llvm_type(bx.cx));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -58,7 +58,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n \n     // Default per-arch clobbers\n     // Basically what clang does\n-    let arch_clobbers = match &bcx.sess().target.target.arch[..] {\n+    let arch_clobbers = match &bx.sess().target.target.arch[..] {\n         \"x86\" | \"x86_64\" => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n         _                => Vec::new()\n     };\n@@ -76,9 +76,9 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     // Depending on how many outputs we have, the return type is different\n     let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n-        0 => Type::void(bcx.ccx),\n+        0 => Type::void(bx.cx),\n         1 => output_types[0],\n-        _ => Type::struct_(bcx.ccx, &output_types, false)\n+        _ => Type::struct_(bx.cx, &output_types, false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -88,7 +88,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n \n     let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n     let constraint_cstr = CString::new(all_constraints).unwrap();\n-    let r = bcx.inline_asm_call(\n+    let r = bx.inline_asm_call(\n         asm.as_ptr(),\n         constraint_cstr.as_ptr(),\n         &inputs,\n@@ -101,28 +101,28 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     // Again, based on how many outputs we have\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n     for (i, (_, &place)) in outputs.enumerate() {\n-        let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i as u64) };\n-        OperandValue::Immediate(v).store(bcx, place);\n+        let v = if num_outputs == 1 { r } else { bx.extract_value(r, i as u64) };\n+        OperandValue::Immediate(v).store(bx, place);\n     }\n \n     // Store mark in a metadata node so we can map LLVM errors\n     // back to source locations.  See #17552.\n     unsafe {\n         let key = \"srcloc\";\n-        let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx.llcx(),\n+        let kind = llvm::LLVMGetMDKindIDInContext(bx.cx.llcx,\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bcx.ccx, ia.ctxt.outer().as_u32() as i32);\n+        let val: llvm::ValueRef = C_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n-            llvm::LLVMMDNodeInContext(bcx.ccx.llcx(), &val, 1));\n+            llvm::LLVMMDNodeInContext(bx.cx.llcx, &val, 1));\n     }\n }\n \n-pub fn trans_global_asm<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn trans_global_asm<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   ga: &hir::GlobalAsm) {\n     let asm = CString::new(ga.asm.as_str().as_bytes()).unwrap();\n     unsafe {\n-        llvm::LLVMRustAppendModuleInlineAsm(ccx.llmod(), asm.as_ptr());\n+        llvm::LLVMRustAppendModuleInlineAsm(cx.llmod, asm.as_ptr());\n     }\n }"}, {"sha": "6c8088375c4b0548fc7d84f0b41a77827e137224", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -24,7 +24,7 @@ use llvm::AttributePlace::Function;\n use llvm_util;\n pub use syntax::attr::{self, InlineAttr};\n use syntax::ast;\n-use context::CrateContext;\n+use context::CodegenCx;\n \n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n@@ -67,27 +67,27 @@ pub fn naked(val: ValueRef, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n }\n \n-pub fn set_frame_pointer_elimination(ccx: &CrateContext, llfn: ValueRef) {\n+pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {\n     // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n     // parameter.\n-    if ccx.sess().must_not_eliminate_frame_pointers() {\n+    if cx.sess().must_not_eliminate_frame_pointers() {\n         llvm::AddFunctionAttrStringValue(\n             llfn, llvm::AttributePlace::Function,\n             cstr(\"no-frame-pointer-elim\\0\"), cstr(\"true\\0\"));\n     }\n }\n \n-pub fn set_probestack(ccx: &CrateContext, llfn: ValueRef) {\n+pub fn set_probestack(cx: &CodegenCx, llfn: ValueRef) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n-    if !ccx.sess().target.target.options.stack_probes {\n+    if !cx.sess().target.target.options.stack_probes {\n         return\n     }\n \n     // Currently stack probes seem somewhat incompatible with the address\n     // sanitizer. With asan we're already protected from stack overflow anyway\n     // so we don't really need stack probes regardless.\n-    match ccx.sess().opts.debugging_opts.sanitizer {\n+    match cx.sess().opts.debugging_opts.sanitizer {\n         Some(Sanitizer::Address) => return,\n         _ => {}\n     }\n@@ -101,13 +101,13 @@ pub fn set_probestack(ccx: &CrateContext, llfn: ValueRef) {\n \n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n-pub fn from_fn_attrs(ccx: &CrateContext, llfn: ValueRef, id: DefId) {\n+pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n     use syntax::attr::*;\n-    let attrs = ccx.tcx().get_attrs(id);\n-    inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), &attrs));\n+    let attrs = cx.tcx.get_attrs(id);\n+    inline(llfn, find_inline_attr(Some(cx.sess().diagnostic()), &attrs));\n \n-    set_frame_pointer_elimination(ccx, llfn);\n-    set_probestack(ccx, llfn);\n+    set_frame_pointer_elimination(cx, llfn);\n+    set_probestack(cx, llfn);\n \n     for attr in attrs.iter() {\n         if attr.check_name(\"cold\") {\n@@ -124,7 +124,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, llfn: ValueRef, id: DefId) {\n         }\n     }\n \n-    let target_features = ccx.tcx().target_features_enabled(id);\n+    let target_features = cx.tcx.target_features_enabled(id);\n     if !target_features.is_empty() {\n         let val = CString::new(target_features.join(\",\")).unwrap();\n         llvm::AddFunctionAttrStringValue("}, {"sha": "633ed9b32cd1e59880f0708182e7027495810ec2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 126, "deletions": 129, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -57,9 +57,9 @@ use builder::Builder;\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n-use common::{self, C_struct_in_context, C_array, CrateContext, val_ty};\n+use common::{self, C_struct_in_context, C_array, val_ty};\n use consts;\n-use context::{self, LocalCrateContext, SharedCrateContext};\n+use context::{self, CodegenCx};\n use debuginfo;\n use declare;\n use meth;\n@@ -94,16 +94,16 @@ pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    cx: &'a CodegenCx<'a, 'tcx>,\n     name: Option<String>,\n     istart: usize,\n }\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n-    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n-        let istart = ccx.stats().borrow().n_llvm_insns;\n+    pub fn new(cx: &'a CodegenCx<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n+        let istart = cx.stats.borrow().n_llvm_insns;\n         StatRecorder {\n-            ccx,\n+            cx,\n             name: Some(name),\n             istart,\n         }\n@@ -112,8 +112,8 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n \n impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n-        if self.ccx.sess().trans_stats() {\n-            let mut stats = self.ccx.stats().borrow_mut();\n+        if self.cx.sess().trans_stats() {\n+            let mut stats = self.cx.stats.borrow_mut();\n             let iend = stats.n_llvm_insns;\n             stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n             stats.n_fns += 1;\n@@ -158,7 +158,7 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n }\n \n pub fn compare_simd_types<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef,\n     t: Ty<'tcx>,\n@@ -168,7 +168,7 @@ pub fn compare_simd_types<'a, 'tcx>(\n     let signed = match t.sty {\n         ty::TyFloat(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n-            return bcx.sext(bcx.fcmp(cmp, lhs, rhs), ret_ty);\n+            return bx.sext(bx.fcmp(cmp, lhs, rhs), ret_ty);\n         },\n         ty::TyUint(_) => false,\n         ty::TyInt(_) => true,\n@@ -180,7 +180,7 @@ pub fn compare_simd_types<'a, 'tcx>(\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n     // by the target architecture.\n-    bcx.sext(bcx.icmp(cmp, lhs, rhs), ret_ty)\n+    bx.sext(bx.icmp(cmp, lhs, rhs), ret_ty)\n }\n \n /// Retrieve the information we are losing (making dynamic) in an unsizing\n@@ -189,15 +189,15 @@ pub fn compare_simd_types<'a, 'tcx>(\n /// The `old_info` argument is a bit funny. It is intended for use\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n-pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n+pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n                                 source: Ty<'tcx>,\n                                 target: Ty<'tcx>,\n                                 old_info: Option<ValueRef>)\n                                 -> ValueRef {\n-    let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n+    let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n-            C_usize(ccx, len.val.to_const_int().unwrap().to_u64().unwrap())\n+            C_usize(cx, len.val.to_const_int().unwrap().to_u64().unwrap())\n         }\n         (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n@@ -206,10 +206,10 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n         (_, &ty::TyDynamic(ref data, ..)) => {\n-            let vtable_ptr = ccx.layout_of(ccx.tcx().mk_mut_ptr(target))\n-                .field(ccx, abi::FAT_PTR_EXTRA);\n-            consts::ptrcast(meth::get_vtable(ccx, source, data.principal()),\n-                            vtable_ptr.llvm_type(ccx))\n+            let vtable_ptr = cx.layout_of(cx.tcx.mk_mut_ptr(target))\n+                .field(cx, abi::FAT_PTR_EXTRA);\n+            consts::ptrcast(meth::get_vtable(cx, source, data.principal()),\n+                            vtable_ptr.llvm_type(cx))\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n                                      source,\n@@ -219,7 +219,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n pub fn unsize_thin_ptr<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     src: ValueRef,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>\n@@ -232,68 +232,68 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            assert!(bcx.ccx.shared().type_is_sized(a));\n-            let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n-            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n+            assert!(bx.cx.type_is_sized(a));\n+            let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n         }\n         (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bcx.ccx.shared().type_is_sized(a));\n-            let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n-            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n+            assert!(bx.cx.type_is_sized(a));\n+            let ptr_ty = bx.cx.layout_of(b).llvm_type(bx.cx).ptr_to();\n+            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx, a, b, None))\n         }\n         (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            let src_layout = bcx.ccx.layout_of(src_ty);\n-            let dst_layout = bcx.ccx.layout_of(dst_ty);\n+            let src_layout = bx.cx.layout_of(src_ty);\n+            let dst_layout = bx.cx.layout_of(dst_ty);\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n-                let src_f = src_layout.field(bcx.ccx, i);\n+                let src_f = src_layout.field(bx.cx, i);\n                 assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n                 assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n                 if src_f.is_zst() {\n                     continue;\n                 }\n                 assert_eq!(src_layout.size, src_f.size);\n \n-                let dst_f = dst_layout.field(bcx.ccx, i);\n+                let dst_f = dst_layout.field(bx.cx, i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(bcx, src, src_f.ty, dst_f.ty));\n+                result = Some(unsize_thin_ptr(bx, src, src_f.ty, dst_f.ty));\n             }\n             let (lldata, llextra) = result.unwrap();\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-            (bcx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bcx.ccx, 0)),\n-             bcx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bcx.ccx, 1)))\n+            (bx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bx.cx, 0)),\n+             bx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bx.cx, 1)))\n         }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n }\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+pub fn coerce_unsized_into<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                                      src: PlaceRef<'tcx>,\n                                      dst: PlaceRef<'tcx>) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n     let coerce_ptr = || {\n-        let (base, info) = match src.load(bcx).val {\n+        let (base, info) = match src.load(bx).val {\n             OperandValue::Pair(base, info) => {\n                 // fat-ptr to fat-ptr unsize preserves the vtable\n                 // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n                 // So we need to pointercast the base to ensure\n                 // the types match up.\n-                let thin_ptr = dst.layout.field(bcx.ccx, abi::FAT_PTR_ADDR);\n-                (bcx.pointercast(base, thin_ptr.llvm_type(bcx.ccx)), info)\n+                let thin_ptr = dst.layout.field(bx.cx, abi::FAT_PTR_ADDR);\n+                (bx.pointercast(base, thin_ptr.llvm_type(bx.cx)), info)\n             }\n             OperandValue::Immediate(base) => {\n-                unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n+                unsize_thin_ptr(bx, base, src_ty, dst_ty)\n             }\n             OperandValue::Ref(..) => bug!()\n         };\n-        OperandValue::Pair(base, info).store(bcx, dst);\n+        OperandValue::Pair(base, info).store(bx, dst);\n     };\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n@@ -309,18 +309,18 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             assert_eq!(def_a, def_b);\n \n             for i in 0..def_a.variants[0].fields.len() {\n-                let src_f = src.project_field(bcx, i);\n-                let dst_f = dst.project_field(bcx, i);\n+                let src_f = src.project_field(bx, i);\n+                let dst_f = dst.project_field(bx, i);\n \n                 if dst_f.layout.is_zst() {\n                     continue;\n                 }\n \n                 if src_f.layout.ty == dst_f.layout.ty {\n-                    memcpy_ty(bcx, dst_f.llval, src_f.llval, src_f.layout,\n+                    memcpy_ty(bx, dst_f.llval, src_f.llval, src_f.layout,\n                         src_f.align.min(dst_f.align));\n                 } else {\n-                    coerce_unsized_into(bcx, src_f, dst_f);\n+                    coerce_unsized_into(bx, src_f, dst_f);\n                 }\n             }\n         }\n@@ -388,47 +388,47 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n-    let assume_intrinsic = b.ccx.get_intrinsic(\"llvm.assume\");\n-    b.call(assume_intrinsic, &[val], None);\n+pub fn call_assume<'a, 'tcx>(bx: &Builder<'a, 'tcx>, val: ValueRef) {\n+    let assume_intrinsic = bx.cx.get_intrinsic(\"llvm.assume\");\n+    bx.call(assume_intrinsic, &[val], None);\n }\n \n-pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n-    if val_ty(val) == Type::i1(bcx.ccx) {\n-        bcx.zext(val, Type::i8(bcx.ccx))\n+pub fn from_immediate(bx: &Builder, val: ValueRef) -> ValueRef {\n+    if val_ty(val) == Type::i1(bx.cx) {\n+        bx.zext(val, Type::i8(bx.cx))\n     } else {\n         val\n     }\n }\n \n-pub fn to_immediate(bcx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n+pub fn to_immediate(bx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n     if let layout::Abi::Scalar(ref scalar) = layout.abi {\n         if scalar.is_bool() {\n-            return bcx.trunc(val, Type::i1(bcx.ccx));\n+            return bx.trunc(val, Type::i1(bx.cx));\n         }\n     }\n     val\n }\n \n-pub fn call_memcpy(b: &Builder,\n+pub fn call_memcpy(bx: &Builder,\n                    dst: ValueRef,\n                    src: ValueRef,\n                    n_bytes: ValueRef,\n                    align: Align) {\n-    let ccx = b.ccx;\n-    let ptr_width = &ccx.sess().target.target.target_pointer_width;\n+    let cx = bx.cx;\n+    let ptr_width = &cx.sess().target.target.target_pointer_width;\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n-    let memcpy = ccx.get_intrinsic(&key);\n-    let src_ptr = b.pointercast(src, Type::i8p(ccx));\n-    let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n-    let size = b.intcast(n_bytes, ccx.isize_ty(), false);\n-    let align = C_i32(ccx, align.abi() as i32);\n-    let volatile = C_bool(ccx, false);\n-    b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n+    let memcpy = cx.get_intrinsic(&key);\n+    let src_ptr = bx.pointercast(src, Type::i8p(cx));\n+    let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n+    let size = bx.intcast(n_bytes, cx.isize_ty, false);\n+    let align = C_i32(cx, align.abi() as i32);\n+    let volatile = C_bool(cx, false);\n+    bx.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n pub fn memcpy_ty<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     dst: ValueRef,\n     src: ValueRef,\n     layout: TyLayout<'tcx>,\n@@ -439,28 +439,28 @@ pub fn memcpy_ty<'a, 'tcx>(\n         return;\n     }\n \n-    call_memcpy(bcx, dst, src, C_usize(bcx.ccx, size), align);\n+    call_memcpy(bx, dst, src, C_usize(bx.cx, size), align);\n }\n \n-pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n+pub fn call_memset<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                              ptr: ValueRef,\n                              fill_byte: ValueRef,\n                              size: ValueRef,\n                              align: ValueRef,\n                              volatile: bool) -> ValueRef {\n-    let ptr_width = &b.ccx.sess().target.target.target_pointer_width;\n+    let ptr_width = &bx.cx.sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-    let llintrinsicfn = b.ccx.get_intrinsic(&intrinsic_key);\n-    let volatile = C_bool(b.ccx, volatile);\n-    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n+    let llintrinsicfn = bx.cx.get_intrinsic(&intrinsic_key);\n+    let volatile = C_bool(bx.cx, volatile);\n+    bx.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n-    let _s = if ccx.sess().trans_stats() {\n+pub fn trans_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {\n+    let _s = if cx.sess().trans_stats() {\n         let mut instance_name = String::new();\n-        DefPathBasedNames::new(ccx.tcx(), true, true)\n+        DefPathBasedNames::new(cx.tcx, true, true)\n             .push_def_path(instance.def_id(), &mut instance_name);\n-        Some(StatRecorder::new(ccx, instance_name))\n+        Some(StatRecorder::new(cx, instance_name))\n     } else {\n         None\n     };\n@@ -470,16 +470,16 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = instance.ty(ccx.tcx());\n-    let sig = common::ty_fn_sig(ccx, fn_ty);\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+    let fn_ty = instance.ty(cx.tcx);\n+    let sig = common::ty_fn_sig(cx, fn_ty);\n+    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n \n-    let lldecl = match ccx.instances().borrow().get(&instance) {\n+    let lldecl = match cx.instances.borrow().get(&instance) {\n         Some(&val) => val,\n         None => bug!(\"Instance `{:?}` not already declared\", instance)\n     };\n \n-    ccx.stats().borrow_mut().n_closures += 1;\n+    cx.stats.borrow_mut().n_closures += 1;\n \n     // The `uwtable` attribute according to LLVM is:\n     //\n@@ -497,21 +497,21 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     //\n     // You can also find more info on why Windows is whitelisted here in:\n     //      https://bugzilla.mozilla.org/show_bug.cgi?id=1302078\n-    if !ccx.sess().no_landing_pads() ||\n-       ccx.sess().target.target.options.is_like_windows {\n+    if !cx.sess().no_landing_pads() ||\n+       cx.sess().target.target.options.is_like_windows {\n         attributes::emit_uwtable(lldecl, true);\n     }\n \n-    let mir = ccx.tcx().instance_mir(instance.def);\n-    mir::trans_mir(ccx, lldecl, &mir, instance, sig);\n+    let mir = cx.tcx.instance_mir(instance.def);\n+    mir::trans_mir(cx, lldecl, &mir, instance, sig);\n }\n \n-pub fn set_link_section(ccx: &CrateContext,\n+pub fn set_link_section(cx: &CodegenCx,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {\n     if let Some(sect) = attr::first_attr_value_str_by_name(attrs, \"link_section\") {\n         if contains_null(&sect.as_str()) {\n-            ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n+            cx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n         }\n         unsafe {\n             let buf = CString::new(sect.as_str().as_bytes()).unwrap();\n@@ -522,82 +522,82 @@ pub fn set_link_section(ccx: &CrateContext,\n \n /// Create the `main` function which will initialize the rust runtime and call\n /// users main function.\n-fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n-    let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n+fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n+    let (main_def_id, span) = match *cx.sess().entry_fn.borrow() {\n         Some((id, span)) => {\n-            (ccx.tcx().hir.local_def_id(id), span)\n+            (cx.tcx.hir.local_def_id(id), span)\n         }\n         None => return,\n     };\n \n-    let instance = Instance::mono(ccx.tcx(), main_def_id);\n+    let instance = Instance::mono(cx.tcx, main_def_id);\n \n-    if !ccx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n+    if !cx.codegen_unit.contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n     }\n \n-    let main_llfn = callee::get_fn(ccx, instance);\n+    let main_llfn = callee::get_fn(cx, instance);\n \n-    let et = ccx.sess().entry_type.get().unwrap();\n+    let et = cx.sess().entry_type.get().unwrap();\n     match et {\n-        config::EntryMain => create_entry_fn(ccx, span, main_llfn, main_def_id, true),\n-        config::EntryStart => create_entry_fn(ccx, span, main_llfn, main_def_id, false),\n+        config::EntryMain => create_entry_fn(cx, span, main_llfn, main_def_id, true),\n+        config::EntryStart => create_entry_fn(cx, span, main_llfn, main_def_id, false),\n         config::EntryNone => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn<'ccx>(ccx: &'ccx CrateContext,\n+    fn create_entry_fn<'cx>(cx: &'cx CodegenCx,\n                        sp: Span,\n                        rust_main: ValueRef,\n                        rust_main_def_id: DefId,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func(&[Type::c_int(ccx), Type::i8p(ccx).ptr_to()], &Type::c_int(ccx));\n+        let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], &Type::c_int(cx));\n \n-        let main_ret_ty = ccx.tcx().fn_sig(rust_main_def_id).output();\n+        let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n         // then its return type cannot have\n         // late-bound regions, since late-bound\n         // regions must appear in the argument\n         // listing.\n         let main_ret_ty = main_ret_ty.no_late_bound_regions().unwrap();\n \n-        if declare::get_defined_value(ccx, \"main\").is_some() {\n+        if declare::get_defined_value(cx, \"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here.\n-            ccx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n+            cx.sess().struct_span_err(sp, \"entry symbol `main` defined multiple times\")\n                       .help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\")\n                       .emit();\n-            ccx.sess().abort_if_errors();\n+            cx.sess().abort_if_errors();\n             bug!();\n         }\n-        let llfn = declare::declare_cfn(ccx, \"main\", llfty);\n+        let llfn = declare::declare_cfn(cx, \"main\", llfty);\n \n         // `main` should respect same config for frame pointer elimination as rest of code\n-        attributes::set_frame_pointer_elimination(ccx, llfn);\n+        attributes::set_frame_pointer_elimination(cx, llfn);\n \n-        let bld = Builder::new_block(ccx, llfn, \"top\");\n+        let bx = Builder::new_block(cx, llfn, \"top\");\n \n-        debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx, &bld);\n+        debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(&bx);\n \n         // Params from native main() used as args for rust start function\n         let param_argc = get_param(llfn, 0);\n         let param_argv = get_param(llfn, 1);\n-        let arg_argc = bld.intcast(param_argc, ccx.isize_ty(), true);\n+        let arg_argc = bx.intcast(param_argc, cx.isize_ty, true);\n         let arg_argv = param_argv;\n \n         let (start_fn, args) = if use_start_lang_item {\n-            let start_def_id = ccx.tcx().require_lang_item(StartFnLangItem);\n-            let start_fn = callee::resolve_and_get_fn(ccx, start_def_id, ccx.tcx().mk_substs(\n+            let start_def_id = cx.tcx.require_lang_item(StartFnLangItem);\n+            let start_fn = callee::resolve_and_get_fn(cx, start_def_id, cx.tcx.mk_substs(\n                 iter::once(Kind::from(main_ret_ty))));\n-            (start_fn, vec![bld.pointercast(rust_main, Type::i8p(ccx).ptr_to()),\n+            (start_fn, vec![bx.pointercast(rust_main, Type::i8p(cx).ptr_to()),\n                             arg_argc, arg_argv])\n         } else {\n             debug!(\"using user-defined start fn\");\n             (rust_main, vec![arg_argc, arg_argv])\n         };\n \n-        let result = bld.call(start_fn, &args, None);\n-        bld.ret(bld.intcast(result, Type::c_int(ccx), true));\n+        let result = bx.call(start_fn, &args, None);\n+        bx.ret(bx.intcast(result, Type::c_int(cx), true));\n     }\n }\n \n@@ -721,7 +721,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let link_meta = link::build_link_meta(crate_hash);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n-    let shared_ccx = SharedCrateContext::new(tcx);\n     // Translate the metadata.\n     let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n@@ -770,7 +769,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n     let codegen_units =\n-        shared_ccx.tcx().collect_and_partition_translation_items(LOCAL_CRATE).1;\n+        tcx.collect_and_partition_translation_items(LOCAL_CRATE).1;\n     let codegen_units = (*codegen_units).clone();\n \n     // Force all codegen_unit queries so they are already either red or green\n@@ -910,7 +909,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     symbol_names_test::report_symbol_names(tcx);\n \n-    if shared_ccx.sess().trans_stats() {\n+    if tcx.sess.trans_stats() {\n         println!(\"--- trans stats ---\");\n         println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n         println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n@@ -926,7 +925,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    if shared_ccx.sess().count_llvm_insns() {\n+    if tcx.sess.count_llvm_insns() {\n         for (k, v) in all_stats.llvm_insns.iter() {\n             println!(\"{:7} {}\", *v, *k);\n         }\n@@ -1204,27 +1203,25 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    .to_fingerprint().to_hex());\n \n         // Instantiate translation items without filling out definitions yet...\n-        let scx = SharedCrateContext::new(tcx);\n-        let lcx = LocalCrateContext::new(&scx, cgu, &llmod_id);\n+        let cx = CodegenCx::new(tcx, cgu, &llmod_id);\n         let module = {\n-            let ccx = CrateContext::new(&scx, &lcx);\n-            let trans_items = ccx.codegen_unit()\n-                                 .items_in_deterministic_order(ccx.tcx());\n+            let trans_items = cx.codegen_unit\n+                                 .items_in_deterministic_order(cx.tcx);\n             for &(trans_item, (linkage, visibility)) in &trans_items {\n-                trans_item.predefine(&ccx, linkage, visibility);\n+                trans_item.predefine(&cx, linkage, visibility);\n             }\n \n             // ... and now that we have everything pre-defined, fill out those definitions.\n             for &(trans_item, _) in &trans_items {\n-                trans_item.define(&ccx);\n+                trans_item.define(&cx);\n             }\n \n             // If this codegen unit contains the main function, also create the\n             // wrapper here\n-            maybe_create_entry_wrapper(&ccx);\n+            maybe_create_entry_wrapper(&cx);\n \n             // Run replace-all-uses-with for statics that need it\n-            for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n+            for &(old_g, new_g) in cx.statics_to_rauw.borrow().iter() {\n                 unsafe {\n                     let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n                     llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n@@ -1234,13 +1231,13 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             // Create the llvm.used variable\n             // This variable has type [N x i8*] and is stored in the llvm.metadata section\n-            if !ccx.used_statics().borrow().is_empty() {\n+            if !cx.used_statics.borrow().is_empty() {\n                 let name = CString::new(\"llvm.used\").unwrap();\n                 let section = CString::new(\"llvm.metadata\").unwrap();\n-                let array = C_array(Type::i8(&ccx).ptr_to(), &*ccx.used_statics().borrow());\n+                let array = C_array(Type::i8(&cx).ptr_to(), &*cx.used_statics.borrow());\n \n                 unsafe {\n-                    let g = llvm::LLVMAddGlobal(ccx.llmod(),\n+                    let g = llvm::LLVMAddGlobal(cx.llmod,\n                                                 val_ty(array).to_ref(),\n                                                 name.as_ptr());\n                     llvm::LLVMSetInitializer(g, array);\n@@ -1250,14 +1247,14 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             // Finalize debuginfo\n-            if ccx.sess().opts.debuginfo != NoDebugInfo {\n-                debuginfo::finalize(&ccx);\n+            if cx.sess().opts.debuginfo != NoDebugInfo {\n+                debuginfo::finalize(&cx);\n             }\n \n             let llvm_module = ModuleLlvm {\n-                llcx: ccx.llcx(),\n-                llmod: ccx.llmod(),\n-                tm: create_target_machine(ccx.sess()),\n+                llcx: cx.llcx,\n+                llmod: cx.llmod,\n+                tm: create_target_machine(cx.sess()),\n             };\n \n             ModuleTranslation {\n@@ -1268,7 +1265,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n-        (lcx.into_stats(), module)\n+        (cx.into_stats(), module)\n     }\n }\n "}, {"sha": "5ab8d03b8c71893c1522e3a107b9f5eba23def6c", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -32,7 +32,7 @@ use syntax_pos::Span;\n #[must_use]\n pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n+    pub cx: &'a CodegenCx<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> Drop for Builder<'a, 'tcx> {\n@@ -51,41 +51,41 @@ fn noname() -> *const c_char {\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn new_block<'b>(ccx: &'a CrateContext<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n-        let builder = Builder::with_ccx(ccx);\n+    pub fn new_block<'b>(cx: &'a CodegenCx<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+        let bx = Builder::with_cx(cx);\n         let llbb = unsafe {\n             let name = CString::new(name).unwrap();\n             llvm::LLVMAppendBasicBlockInContext(\n-                ccx.llcx(),\n+                cx.llcx,\n                 llfn,\n                 name.as_ptr()\n             )\n         };\n-        builder.position_at_end(llbb);\n-        builder\n+        bx.position_at_end(llbb);\n+        bx\n     }\n \n-    pub fn with_ccx(ccx: &'a CrateContext<'a, 'tcx>) -> Self {\n+    pub fn with_cx(cx: &'a CodegenCx<'a, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n-            llvm::LLVMCreateBuilderInContext(ccx.llcx())\n+            llvm::LLVMCreateBuilderInContext(cx.llcx)\n         };\n         Builder {\n             llbuilder,\n-            ccx,\n+            cx,\n         }\n     }\n \n     pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'tcx> {\n-        Builder::new_block(self.ccx, self.llfn(), name)\n+        Builder::new_block(self.cx, self.llfn(), name)\n     }\n \n     pub fn sess(&self) -> &Session {\n-        self.ccx.sess()\n+        self.cx.sess()\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.ccx.tcx()\n+        self.cx.tcx\n     }\n \n     pub fn llfn(&self) -> ValueRef {\n@@ -101,11 +101,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     fn count_insn(&self, category: &str) {\n-        if self.ccx.sess().trans_stats() {\n-            self.ccx.stats().borrow_mut().n_llvm_insns += 1;\n+        if self.cx.sess().trans_stats() {\n+            self.cx.stats.borrow_mut().n_llvm_insns += 1;\n         }\n-        if self.ccx.sess().count_llvm_insns() {\n-            *self.ccx.stats()\n+        if self.cx.sess().count_llvm_insns() {\n+            *self.cx.stats\n                 .borrow_mut()\n                 .llvm_insns\n                 .entry(category.to_string())\n@@ -489,11 +489,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n-        let builder = Builder::with_ccx(self.ccx);\n-        builder.position_at_start(unsafe {\n+        let bx = Builder::with_cx(self.cx);\n+        bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n-        builder.dynamic_alloca(ty, name, align)\n+        bx.dynamic_alloca(ty, name, align)\n     }\n \n     pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n@@ -558,7 +558,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ];\n \n             llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n+                                  llvm::LLVMMDNodeInContext(self.cx.llcx,\n                                                             v.as_ptr(),\n                                                             v.len() as c_uint));\n         }\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn nonnull_metadata(&self, load: ValueRef) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_nonnull as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(), ptr::null(), 0));\n+                                  llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n@@ -620,8 +620,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // point to a metadata value of the integer 1. Who knew?\n             //\n             // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n-            let one = C_i32(self.ccx, 1);\n-            let node = llvm::LLVMMDNodeInContext(self.ccx.llcx(),\n+            let one = C_i32(self.cx, 1);\n+            let node = llvm::LLVMMDNodeInContext(self.cx.llcx,\n                                                  &one,\n                                                  1);\n             llvm::LLVMSetMetadata(insn,\n@@ -840,24 +840,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n-        if self.ccx.sess().asm_comments() {\n+        if self.cx.sess().asm_comments() {\n             let s = format!(\"{} ({})\",\n                             text,\n-                            self.ccx.sess().codemap().span_to_string(sp));\n+                            self.cx.sess().codemap().span_to_string(sp));\n             debug!(\"{}\", s);\n             self.add_comment(&s);\n         }\n     }\n \n     pub fn add_comment(&self, text: &str) {\n-        if self.ccx.sess().asm_comments() {\n+        if self.cx.sess().asm_comments() {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = format!(\"{} {}\", \"#\",\n                                        sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n             let comment_text = CString::new(comment_text).unwrap();\n             let asm = unsafe {\n-                llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n+                llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.cx)).to_ref(),\n                                          comment_text.as_ptr(), noname(), False,\n                                          False)\n             };\n@@ -949,8 +949,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let elt_ty = val_ty(elt);\n             let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n-            let vec = self.insert_element(undef, elt, C_i32(self.ccx, 0));\n-            let vec_i32_ty = Type::vector(&Type::i32(self.ccx), num_elts as u64);\n+            let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n+            let vec_i32_ty = Type::vector(&Type::i32(self.cx), num_elts as u64);\n             self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n@@ -1160,7 +1160,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn set_invariant_load(&self, load: ValueRef) {\n         unsafe {\n             llvm::LLVMSetMetadata(load, llvm::MD_invariant_load as c_uint,\n-                                  llvm::LLVMMDNodeInContext(self.ccx.llcx(), ptr::null(), 0));\n+                                  llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0));\n         }\n     }\n \n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n     /// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n     fn call_lifetime_intrinsic(&self, intrinsic: &str, ptr: ValueRef, size: Size) {\n-        if self.ccx.sess().opts.optimize == config::OptLevel::No {\n+        if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;\n         }\n \n@@ -1254,9 +1254,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             return;\n         }\n \n-        let lifetime_intrinsic = self.ccx.get_intrinsic(intrinsic);\n+        let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n \n-        let ptr = self.pointercast(ptr, Type::i8p(self.ccx));\n-        self.call(lifetime_intrinsic, &[C_u64(self.ccx, size), ptr], None);\n+        let ptr = self.pointercast(ptr, Type::i8p(self.cx));\n+        self.call(lifetime_intrinsic, &[C_u64(self.cx, size), ptr], None);\n     }\n }"}, {"sha": "72ae1449de04ea7968c05097e24727598dfd869b", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members.\n-        if size > unit.size.checked_mul(4, ccx).unwrap() {\n+        if size > unit.size.checked_mul(4, cx).unwrap() {\n             return None;\n         }\n \n@@ -38,12 +38,12 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut Ar\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, ret) {\n         ret.cast_to(uniform);\n         return;\n     }\n@@ -69,12 +69,12 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n         arg.cast_to(uniform);\n         return;\n     }\n@@ -100,13 +100,13 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     arg.make_indirect();\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(cx, arg);\n     }\n }"}, {"sha": "b6cf16cb8d50855747a409e5d884a7b1157e11c4", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n use llvm::CallConv;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members.\n-        if size > unit.size.checked_mul(4, ccx).unwrap() {\n+        if size > unit.size.checked_mul(4, cx).unwrap() {\n             return None;\n         }\n \n@@ -39,14 +39,14 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut Ar\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>, vfp: bool) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, vfp: bool) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n \n     if vfp {\n-        if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+        if let Some(uniform) = is_homogeneous_aggregate(cx, ret) {\n             ret.cast_to(uniform);\n             return;\n         }\n@@ -71,14 +71,14 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n \n     if vfp {\n-        if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+        if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n             arg.cast_to(uniform);\n             return;\n         }\n@@ -92,19 +92,19 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     // If this is a target with a hard-float ABI, and the function is not explicitly\n     // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates.\n-    let vfp = ccx.sess().target.target.llvm_target.ends_with(\"hf\")\n+    let vfp = cx.sess().target.target.llvm_target.ends_with(\"hf\")\n         && fty.cconv != CallConv::ArmAapcsCallConv\n         && !fty.variadic;\n \n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, vfp);\n+        classify_ret_ty(cx, &mut fty.ret, vfp);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, vfp);\n+        classify_arg_ty(cx, arg, vfp);\n     }\n }"}, {"sha": "b182f833dd699d0f9013c851ca75a075c90ed6ae", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use abi::{FnType, ArgType, LayoutExt, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n \n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if ret.layout.is_aggregate() {\n-        if let Some(unit) = ret.layout.homogeneous_aggregate(ccx) {\n+        if let Some(unit) = ret.layout.homogeneous_aggregate(cx) {\n             let size = ret.layout.size;\n             if unit.size == size {\n                 ret.cast_to(Uniform {\n@@ -39,9 +39,9 @@ fn classify_arg_ty(arg: &mut ArgType) {\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {"}, {"sha": "cd567f517fe8c2deec3e4957a0c6bf6a828600ec", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -9,23 +9,23 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx().data_layout.pointer_size;\n+        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx().data_layout;\n+fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,14 +44,14 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, &mut offset);\n+        classify_arg_ty(cx, arg, &mut offset);\n     }\n }"}, {"sha": "e44063faab8105e3160432b67e97c3aea46ea1df", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -9,23 +9,23 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx().data_layout.pointer_size;\n+        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx().data_layout;\n+fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,14 +44,14 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, &mut offset);\n+        classify_arg_ty(cx, arg, &mut offset);\n     }\n }"}, {"sha": "1ea6e9b26952dfe906ba080cdf71251f2af86c47", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -9,23 +9,23 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx().data_layout.pointer_size;\n+        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx().data_layout;\n+fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,14 +44,14 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, &mut offset);\n+        classify_arg_ty(cx, arg, &mut offset);\n     }\n }"}, {"sha": "c614cf3a5a9eadd872e2e9d2fd943cfcdc0ff2ef", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -13,7 +13,7 @@\n // need to be fixed when PowerPC vector support is added.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n use rustc::ty::layout;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n@@ -23,15 +23,15 @@ enum ABI {\n }\n use self::ABI::*;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                       arg: &mut ArgType<'tcx>,\n                                       abi: ABI)\n                                      -> Option<Uniform> {\n-    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n         if (abi == ELFv1 && arg.layout.size > unit.size)\n-                || arg.layout.size > unit.size.checked_mul(8, ccx).unwrap() {\n+                || arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;\n         }\n \n@@ -52,7 +52,7 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n@@ -64,7 +64,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret, abi) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, ret, abi) {\n         ret.cast_to(uniform);\n         return;\n     }\n@@ -92,13 +92,13 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg, abi) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, arg, abi) {\n         arg.cast_to(uniform);\n         return;\n     }\n@@ -128,19 +128,19 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n-    let abi = match ccx.sess().target.target.target_endian.as_str() {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let abi = match cx.sess().target.target.target_endian.as_str() {\n         \"big\" => ELFv1,\n         \"little\" => ELFv2,\n         _ => unimplemented!(),\n     };\n \n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, abi);\n+        classify_ret_ty(cx, &mut fty.ret, abi);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, abi);\n+        classify_arg_ty(cx, arg, abi);\n     }\n }"}, {"sha": "5e817686defe262fe023cdabff28cf5cdf80b9a7", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -12,7 +12,7 @@\n // for a pre-z13 machine or using -mno-vx.\n \n use abi::{FnType, ArgType, LayoutExt, Reg};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::{self, TyLayout};\n \n@@ -24,7 +24,7 @@ fn classify_ret_ty(ret: &mut ArgType) {\n     }\n }\n \n-fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn is_single_fp_element<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n         layout::Abi::Scalar(ref scalar) => {\n@@ -35,7 +35,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         layout::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n-                is_single_fp_element(ccx, layout.field(ccx, 0))\n+                is_single_fp_element(cx, layout.field(cx, 0))\n             } else {\n                 false\n             }\n@@ -44,13 +44,13 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if is_single_fp_element(ccx, arg.layout) {\n+    if is_single_fp_element(cx, arg.layout) {\n         match arg.layout.size.bytes() {\n             4 => arg.cast_to(Reg::f32()),\n             8 => arg.cast_to(Reg::f64()),\n@@ -67,13 +67,13 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(cx, arg);\n     }\n }"}, {"sha": "cd567f517fe8c2deec3e4957a0c6bf6a828600ec", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -9,23 +9,23 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::Size;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              ret: &mut ArgType<'tcx>,\n                              offset: &mut Size) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect();\n-        *offset += ccx.tcx().data_layout.pointer_size;\n+        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n-    let dl = &ccx.tcx().data_layout;\n+fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+    let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n@@ -44,14 +44,14 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     *offset = offset.abi_align(align) + size.abi_align(align);\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, &mut offset);\n+        classify_arg_ty(cx, arg, &mut offset);\n     }\n }"}, {"sha": "fb94b09d626bd7fde4a17d8e4600e84ecd7b9d8f", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -11,13 +11,13 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+fn is_homogeneous_aggregate<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n-    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+    arg.layout.homogeneous_aggregate(cx).and_then(|unit| {\n         // Ensure we have at most eight uniquely addressable members.\n-        if arg.layout.size > unit.size.checked_mul(8, ccx).unwrap() {\n+        if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n             return None;\n         }\n \n@@ -38,13 +38,13 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut Ar\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, ret) {\n         ret.cast_to(uniform);\n         return;\n     }\n@@ -72,13 +72,13 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect();\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n         arg.cast_to(uniform);\n         return;\n     }\n@@ -90,13 +90,13 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n     });\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(cx, arg);\n     }\n }"}, {"sha": "60347ba0945f91beb880d2a520c18b2b5ac07748", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use abi::{ArgAttribute, FnType, LayoutExt, PassMode, Reg, RegKind};\n-use common::CrateContext;\n+use common::CodegenCx;\n \n use rustc::ty::layout::{self, TyLayout};\n \n@@ -19,7 +19,7 @@ pub enum Flavor {\n     Fastcall\n }\n \n-fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn is_single_fp_element<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n         layout::Abi::Scalar(ref scalar) => {\n@@ -30,7 +30,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         layout::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n-                is_single_fp_element(ccx, layout.field(ccx, 0))\n+                is_single_fp_element(cx, layout.field(cx, 0))\n             } else {\n                 false\n             }\n@@ -39,7 +39,7 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   fty: &mut FnType<'tcx>,\n                                   flavor: Flavor) {\n     if !fty.ret.is_ignore() {\n@@ -51,12 +51,12 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // Some links:\n             // http://www.angelcode.com/dev/callconv/callconv.html\n             // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-            let t = &ccx.sess().target.target;\n+            let t = &cx.sess().target.target;\n             if t.options.is_like_osx || t.options.is_like_windows\n                 || t.options.is_like_openbsd {\n                 // According to Clang, everyone but MSVC returns single-element\n                 // float aggregates directly in a floating-point register.\n-                if !t.options.is_like_msvc && is_single_fp_element(ccx, fty.ret.layout) {\n+                if !t.options.is_like_msvc && is_single_fp_element(cx, fty.ret.layout) {\n                     match fty.ret.layout.size.bytes() {\n                         4 => fty.ret.cast_to(Reg::f32()),\n                         8 => fty.ret.cast_to(Reg::f64()),\n@@ -112,7 +112,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             };\n \n             // At this point we know this must be a primitive of sorts.\n-            let unit = arg.layout.homogeneous_aggregate(ccx).unwrap();\n+            let unit = arg.layout.homogeneous_aggregate(cx).unwrap();\n             assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;"}, {"sha": "6db18bfecf258b2799be9dac80e5c725eabdb4f0", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -12,7 +12,7 @@\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n use abi::{ArgType, CastTarget, FnType, LayoutExt, Reg, RegKind};\n-use context::CrateContext;\n+use context::CodegenCx;\n \n use rustc::ty::layout::{self, TyLayout, Size};\n \n@@ -31,7 +31,7 @@ struct Memory;\n const LARGEST_VECTOR_SIZE: usize = 512;\n const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n-fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n+fn classify_arg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &ArgType<'tcx>)\n                           -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n     fn unify(cls: &mut [Class],\n              off: Size,\n@@ -52,7 +52,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n         cls[i] = to_write;\n     }\n \n-    fn classify<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+    fn classify<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                           layout: TyLayout<'tcx>,\n                           cls: &mut [Class],\n                           off: Size)\n@@ -82,7 +82,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n \n                 // everything after the first one is the upper\n                 // half of a register.\n-                let stride = element.value.size(ccx);\n+                let stride = element.value.size(cx);\n                 for i in 1..count {\n                     let field_off = off + stride * i;\n                     unify(cls, field_off, Class::SseUp);\n@@ -95,7 +95,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                     layout::Variants::Single { .. } => {\n                         for i in 0..layout.fields.count() {\n                             let field_off = off + layout.fields.offset(i);\n-                            classify(ccx, layout.field(ccx, i), cls, field_off)?;\n+                            classify(cx, layout.field(cx, i), cls, field_off)?;\n                         }\n                     }\n                     layout::Variants::Tagged { .. } |\n@@ -114,7 +114,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n     }\n \n     let mut cls = [Class::None; MAX_EIGHTBYTES];\n-    classify(ccx, arg.layout, &mut cls, Size::from_bytes(0))?;\n+    classify(cx, arg.layout, &mut cls, Size::from_bytes(0))?;\n     if n > 2 {\n         if cls[0] != Class::Sse {\n             return Err(Memory);\n@@ -189,12 +189,12 @@ fn cast_target(cls: &[Class], size: Size) -> CastTarget {\n     target\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n     let mut sse_regs = 8; // XMM0-7\n \n     let mut x86_64_ty = |arg: &mut ArgType<'tcx>, is_arg: bool| {\n-        let cls = classify_arg(ccx, arg);\n+        let cls = classify_arg(cx, arg);\n \n         let mut needed_int = 0;\n         let mut needed_sse = 0;"}, {"sha": "c3d5e08c73e7ec88d1a6f6448f40915287c83d6d", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -15,7 +15,7 @@\n //! closure.\n \n use attributes;\n-use common::{self, CrateContext};\n+use common::{self, CodegenCx};\n use consts;\n use declare;\n use llvm::{self, ValueRef};\n@@ -34,33 +34,33 @@ use rustc_back::PanicStrategy;\n ///\n /// # Parameters\n ///\n-/// - `ccx`: the crate context\n+/// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                         instance: Instance<'tcx>)\n                         -> ValueRef\n {\n-    let tcx = ccx.tcx();\n+    let tcx = cx.tcx;\n \n     debug!(\"get_fn(instance={:?})\", instance);\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_regions());\n     assert!(!instance.substs.has_param_types());\n \n-    let fn_ty = instance.ty(ccx.tcx());\n-    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n+    let fn_ty = instance.ty(cx.tcx);\n+    if let Some(&llfn) = cx.instances.borrow().get(&instance) {\n         return llfn;\n     }\n \n     let sym = tcx.symbol_name(instance);\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // Create a fn pointer with the substituted signature.\n-    let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(ccx, fn_ty));\n-    let llptrty = ccx.layout_of(fn_ptr_ty).llvm_type(ccx);\n+    let fn_ptr_ty = tcx.mk_fn_ptr(common::ty_fn_sig(cx, fn_ty));\n+    let llptrty = cx.layout_of(fn_ptr_ty).llvm_type(cx);\n \n-    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n+    let llfn = if let Some(llfn) = declare::get_declared_value(cx, &sym) {\n         // This is subtle and surprising, but sometimes we have to bitcast\n         // the resulting fn pointer.  The reason has to do with external\n         // functions.  If you have two crates that both bind the same C\n@@ -92,14 +92,14 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             llfn\n         }\n     } else {\n-        let llfn = declare::declare_fn(ccx, &sym, fn_ty);\n+        let llfn = declare::declare_fn(cx, &sym, fn_ty);\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n         if instance.def.is_inline(tcx) {\n             attributes::inline(llfn, attributes::InlineAttr::Hint);\n         }\n-        attributes::from_fn_attrs(ccx, llfn, instance.def.def_id());\n+        attributes::from_fn_attrs(cx, llfn, instance.def.def_id());\n \n         let instance_def_id = instance.def_id();\n \n@@ -149,9 +149,9 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            if ccx.tcx().is_translated_function(instance_def_id) {\n+            if cx.tcx.is_translated_function(instance_def_id) {\n                 if instance_def_id.is_local() {\n-                    if !ccx.tcx().is_exported_symbol(instance_def_id) {\n+                    if !cx.tcx.is_exported_symbol(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n                     }\n                 } else {\n@@ -160,7 +160,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n \n-        if ccx.use_dll_storage_attrs() &&\n+        if cx.use_dll_storage_attrs &&\n             tcx.is_dllimport_foreign_item(instance_def_id)\n         {\n             unsafe {\n@@ -171,20 +171,20 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         llfn\n     };\n \n-    ccx.instances().borrow_mut().insert(instance, llfn);\n+    cx.instances.borrow_mut().insert(instance, llfn);\n \n     llfn\n }\n \n-pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn resolve_and_get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     def_id: DefId,\n                                     substs: &'tcx Substs<'tcx>)\n                                     -> ValueRef\n {\n     get_fn(\n-        ccx,\n+        cx,\n         ty::Instance::resolve(\n-            ccx.tcx(),\n+            cx.tcx,\n             ty::ParamEnv::empty(traits::Reveal::All),\n             def_id,\n             substs"}, {"sha": "9e745c3a1f5dd77d46c38b4c5c34832a5801d9b4", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -38,7 +38,7 @@ use syntax::abi::Abi;\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n \n-pub use context::{CrateContext, SharedCrateContext};\n+pub use context::CodegenCx;\n \n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))\n@@ -152,46 +152,46 @@ pub fn C_uint_big(t: Type, u: u128) -> ValueRef {\n     }\n }\n \n-pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n-    C_uint(Type::i1(ccx), val as u64)\n+pub fn C_bool(cx: &CodegenCx, val: bool) -> ValueRef {\n+    C_uint(Type::i1(cx), val as u64)\n }\n \n-pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n-    C_int(Type::i32(ccx), i as i64)\n+pub fn C_i32(cx: &CodegenCx, i: i32) -> ValueRef {\n+    C_int(Type::i32(cx), i as i64)\n }\n \n-pub fn C_u32(ccx: &CrateContext, i: u32) -> ValueRef {\n-    C_uint(Type::i32(ccx), i as u64)\n+pub fn C_u32(cx: &CodegenCx, i: u32) -> ValueRef {\n+    C_uint(Type::i32(cx), i as u64)\n }\n \n-pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n-    C_uint(Type::i64(ccx), i)\n+pub fn C_u64(cx: &CodegenCx, i: u64) -> ValueRef {\n+    C_uint(Type::i64(cx), i)\n }\n \n-pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n-    let bit_size = ccx.data_layout().pointer_size.bits();\n+pub fn C_usize(cx: &CodegenCx, i: u64) -> ValueRef {\n+    let bit_size = cx.data_layout().pointer_size.bits();\n     if bit_size < 64 {\n         // make sure it doesn't overflow\n         assert!(i < (1<<bit_size));\n     }\n \n-    C_uint(ccx.isize_ty(), i)\n+    C_uint(cx.isize_ty, i)\n }\n \n-pub fn C_u8(ccx: &CrateContext, i: u8) -> ValueRef {\n-    C_uint(Type::i8(ccx), i as u64)\n+pub fn C_u8(cx: &CodegenCx, i: u8) -> ValueRef {\n+    C_uint(Type::i8(cx), i as u64)\n }\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n+pub fn C_cstr(cx: &CodegenCx, s: InternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n-        if let Some(&llval) = cx.const_cstr_cache().borrow().get(&s) {\n+        if let Some(&llval) = cx.const_cstr_cache.borrow().get(&s) {\n             return llval;\n         }\n \n-        let sc = llvm::LLVMConstStringInContext(cx.llcx(),\n+        let sc = llvm::LLVMConstStringInContext(cx.llcx,\n                                                 s.as_ptr() as *const c_char,\n                                                 s.len() as c_uint,\n                                                 !null_terminated as Bool);\n@@ -203,28 +203,28 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         llvm::LLVMSetGlobalConstant(g, True);\n         llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n \n-        cx.const_cstr_cache().borrow_mut().insert(s, g);\n+        cx.const_cstr_cache.borrow_mut().insert(s, g);\n         g\n     }\n }\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n+pub fn C_str_slice(cx: &CodegenCx, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false),\n-        cx.layout_of(cx.tcx().mk_str()).llvm_type(cx).ptr_to());\n+        cx.layout_of(cx.tcx.mk_str()).llvm_type(cx).ptr_to());\n     C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n }\n \n-pub fn C_fat_ptr(cx: &CrateContext, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n+pub fn C_fat_ptr(cx: &CodegenCx, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n     C_struct(cx, &[ptr, meta], false)\n }\n \n-pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n-    C_struct_in_context(cx.llcx(), elts, packed)\n+pub fn C_struct(cx: &CodegenCx, elts: &[ValueRef], packed: bool) -> ValueRef {\n+    C_struct_in_context(cx.llcx, elts, packed)\n }\n \n pub fn C_struct_in_context(llcx: ContextRef, elts: &[ValueRef], packed: bool) -> ValueRef {\n@@ -247,8 +247,8 @@ pub fn C_vector(elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n-    C_bytes_in_context(cx.llcx(), bytes)\n+pub fn C_bytes(cx: &CodegenCx, bytes: &[u8]) -> ValueRef {\n+    C_bytes_in_context(cx.llcx, bytes)\n }\n \n pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n@@ -328,37 +328,37 @@ pub fn langcall(tcx: TyCtxt,\n // of Java. (See related discussion on #1877 and #10183.)\n \n pub fn build_unchecked_lshift<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef\n ) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShl, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOp_::BiShl, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bcx, rhs);\n-    bcx.shl(lhs, rhs)\n+    let rhs = shift_mask_rhs(bx, rhs);\n+    bx.shl(lhs, rhs)\n }\n \n pub fn build_unchecked_rshift<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n+    bx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n-    let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOp_::BiShr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n-    let rhs = shift_mask_rhs(bcx, rhs);\n+    let rhs = shift_mask_rhs(bx, rhs);\n     let is_signed = lhs_t.is_signed();\n     if is_signed {\n-        bcx.ashr(lhs, rhs)\n+        bx.ashr(lhs, rhs)\n     } else {\n-        bcx.lshr(lhs, rhs)\n+        bx.lshr(lhs, rhs)\n     }\n }\n \n-fn shift_mask_rhs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n+fn shift_mask_rhs<'a, 'tcx>(bx: &Builder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n     let rhs_llty = val_ty(rhs);\n-    bcx.and(rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false))\n+    bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n }\n \n pub fn shift_mask_val<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     llty: Type,\n     mask_llty: Type,\n     invert: bool\n@@ -375,23 +375,23 @@ pub fn shift_mask_val<'a, 'tcx>(\n             }\n         },\n         TypeKind::Vector => {\n-            let mask = shift_mask_val(bcx, llty.element_type(), mask_llty.element_type(), invert);\n-            bcx.vector_splat(mask_llty.vector_length(), mask)\n+            let mask = shift_mask_val(bx, llty.element_type(), mask_llty.element_type(), invert);\n+            bx.vector_splat(mask_llty.vector_length(), mask)\n         },\n         _ => bug!(\"shift_mask_val: expected Integer or Vector, found {:?}\", kind),\n     }\n }\n \n-pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn ty_fn_sig<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                            ty: Ty<'tcx>)\n                            -> ty::PolyFnSig<'tcx>\n {\n     match ty.sty {\n         ty::TyFnDef(..) |\n         // Shims currently have type TyFnPtr. Not sure this should remain.\n-        ty::TyFnPtr(_) => ty.fn_sig(ccx.tcx()),\n+        ty::TyFnPtr(_) => ty.fn_sig(cx.tcx),\n         ty::TyClosure(def_id, substs) => {\n-            let tcx = ccx.tcx();\n+            let tcx = cx.tcx;\n             let sig = substs.closure_sig(def_id, tcx);\n \n             let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n@@ -404,8 +404,8 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ))\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n-            let tcx = ccx.tcx();\n-            let sig = substs.generator_poly_sig(def_id, ccx.tcx());\n+            let tcx = cx.tcx;\n+            let sig = substs.generator_poly_sig(def_id, cx.tcx);\n \n             let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n             let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);"}, {"sha": "d5b33d837c5bd92e4440fd2440e26839a0a368c9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -17,7 +17,7 @@ use rustc::middle::const_val::ConstEvalErr;\n use debuginfo;\n use base;\n use monomorphize::{MonoItem, MonoItemExt};\n-use common::{CrateContext, val_ty};\n+use common::{CodegenCx, val_ty};\n use declare;\n use monomorphize::Instance;\n use type_::Type;\n@@ -43,17 +43,17 @@ pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n-fn set_global_alignment(ccx: &CrateContext,\n+fn set_global_alignment(cx: &CodegenCx,\n                         gv: ValueRef,\n                         mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n-    if let Some(min) = ccx.sess().target.target.options.min_global_align {\n+    if let Some(min) = cx.sess().target.target.options.min_global_align {\n         match ty::layout::Align::from_bits(min, min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n-                ccx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n+                cx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n             }\n         }\n     }\n@@ -62,30 +62,30 @@ fn set_global_alignment(ccx: &CrateContext,\n     }\n }\n \n-pub fn addr_of_mut(ccx: &CrateContext,\n+pub fn addr_of_mut(cx: &CodegenCx,\n                    cv: ValueRef,\n                    align: Align,\n                    kind: &str)\n                     -> ValueRef {\n     unsafe {\n-        let name = ccx.generate_local_symbol_name(kind);\n-        let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n+        let name = cx.generate_local_symbol_name(kind);\n+        let gv = declare::define_global(cx, &name[..], val_ty(cv)).unwrap_or_else(||{\n             bug!(\"symbol `{}` is already defined\", name);\n         });\n         llvm::LLVMSetInitializer(gv, cv);\n-        set_global_alignment(ccx, gv, align);\n+        set_global_alignment(cx, gv, align);\n         llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n         SetUnnamedAddr(gv, true);\n         gv\n     }\n }\n \n-pub fn addr_of(ccx: &CrateContext,\n+pub fn addr_of(cx: &CodegenCx,\n                cv: ValueRef,\n                align: Align,\n                kind: &str)\n                -> ValueRef {\n-    if let Some(&gv) = ccx.const_globals().borrow().get(&cv) {\n+    if let Some(&gv) = cx.const_globals.borrow().get(&cv) {\n         unsafe {\n             // Upgrade the alignment in cases where the same constant is used with different\n             // alignment requirements\n@@ -96,42 +96,42 @@ pub fn addr_of(ccx: &CrateContext,\n         }\n         return gv;\n     }\n-    let gv = addr_of_mut(ccx, cv, align, kind);\n+    let gv = addr_of_mut(cx, cv, align, kind);\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gv, True);\n     }\n-    ccx.const_globals().borrow_mut().insert(cv, gv);\n+    cx.const_globals.borrow_mut().insert(cv, gv);\n     gv\n }\n \n-pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n-    let instance = Instance::mono(ccx.tcx(), def_id);\n-    if let Some(&g) = ccx.instances().borrow().get(&instance) {\n+pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n+    let instance = Instance::mono(cx.tcx, def_id);\n+    if let Some(&g) = cx.instances.borrow().get(&instance) {\n         return g;\n     }\n \n-    let ty = instance.ty(ccx.tcx());\n-    let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n+    let ty = instance.ty(cx.tcx);\n+    let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n \n-        let llty = ccx.layout_of(ty).llvm_type(ccx);\n-        let (g, attrs) = match ccx.tcx().hir.get(id) {\n+        let llty = cx.layout_of(ty).llvm_type(cx);\n+        let (g, attrs) = match cx.tcx.hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = MonoItem::Static(id).symbol_name(ccx.tcx());\n+                let sym = MonoItem::Static(id).symbol_name(cx.tcx);\n \n-                let defined_in_current_codegen_unit = ccx.codegen_unit()\n+                let defined_in_current_codegen_unit = cx.codegen_unit\n                                                          .items()\n                                                          .contains_key(&MonoItem::Static(id));\n                 assert!(!defined_in_current_codegen_unit);\n \n-                if declare::get_declared_value(ccx, &sym[..]).is_some() {\n+                if declare::get_declared_value(cx, &sym[..]).is_some() {\n                     span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n \n-                let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n+                let g = declare::define_global(cx, &sym[..], llty).unwrap();\n \n-                if !ccx.tcx().is_exported_symbol(def_id) {\n+                if !cx.tcx.is_exported_symbol(def_id) {\n                     unsafe {\n                         llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                     }\n@@ -143,7 +143,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = ccx.tcx().symbol_name(instance);\n+                let sym = cx.tcx.symbol_name(instance);\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -154,18 +154,18 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                     let linkage = match base::linkage_by_name(&name.as_str()) {\n                         Some(linkage) => linkage,\n                         None => {\n-                            ccx.sess().span_fatal(span, \"invalid linkage specified\");\n+                            cx.sess().span_fatal(span, \"invalid linkage specified\");\n                         }\n                     };\n                     let llty2 = match ty.sty {\n-                        ty::TyRawPtr(ref mt) => ccx.layout_of(mt.ty).llvm_type(ccx),\n+                        ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n                         _ => {\n-                            ccx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n+                            cx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\");\n                         }\n                     };\n                     unsafe {\n                         // Declare a symbol `foo` with the desired linkage.\n-                        let g1 = declare::declare_global(ccx, &sym, llty2);\n+                        let g1 = declare::declare_global(cx, &sym, llty2);\n                         llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n                         // Declare an internal global `extern_with_linkage_foo` which\n@@ -176,8 +176,8 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                         // zero.\n                         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                         real_name.push_str(&sym);\n-                        let g2 = declare::define_global(ccx, &real_name, llty).unwrap_or_else(||{\n-                            ccx.sess().span_fatal(span,\n+                        let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n+                            cx.sess().span_fatal(span,\n                                 &format!(\"symbol `{}` is already defined\", &sym))\n                         });\n                         llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n@@ -186,7 +186,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                     }\n                 } else {\n                     // Generate an external declaration.\n-                    declare::declare_global(ccx, &sym, llty)\n+                    declare::declare_global(cx, &sym, llty)\n                 };\n \n                 (g, attrs)\n@@ -197,29 +197,29 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         for attr in attrs {\n             if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, ccx.tls_model());\n+                llvm::set_thread_local_mode(g, cx.tls_model);\n             }\n         }\n \n         g\n     } else {\n-        let sym = ccx.tcx().symbol_name(instance);\n+        let sym = cx.tcx.symbol_name(instance);\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let g = declare::declare_global(ccx, &sym, ccx.layout_of(ty).llvm_type(ccx));\n+        let g = declare::declare_global(cx, &sym, cx.layout_of(ty).llvm_type(cx));\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        for attr in ccx.tcx().get_attrs(def_id).iter() {\n+        for attr in cx.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, ccx.tls_model());\n+                llvm::set_thread_local_mode(g, cx.tls_model);\n             }\n         }\n-        if ccx.use_dll_storage_attrs() && !ccx.tcx().is_foreign_item(def_id) {\n+        if cx.use_dll_storage_attrs && !cx.tcx.is_foreign_item(def_id) {\n             // This item is external but not foreign, i.e. it originates from an external Rust\n             // crate. Since we don't know whether this crate will be linked dynamically or\n             // statically in the final application, we always mark such symbols as 'dllimport'.\n@@ -232,42 +232,42 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         g\n     };\n \n-    if ccx.use_dll_storage_attrs() && ccx.tcx().is_dllimport_foreign_item(def_id) {\n+    if cx.use_dll_storage_attrs && cx.tcx.is_dllimport_foreign_item(def_id) {\n         // For foreign (native) libs we know the exact storage type to use.\n         unsafe {\n             llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n         }\n     }\n \n-    ccx.instances().borrow_mut().insert(instance, g);\n-    ccx.statics().borrow_mut().insert(g, def_id);\n+    cx.instances.borrow_mut().insert(instance, g);\n+    cx.statics.borrow_mut().insert(g, def_id);\n     g\n }\n \n-pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                               m: hir::Mutability,\n                               id: ast::NodeId,\n                               attrs: &[ast::Attribute])\n                               -> Result<ValueRef, ConstEvalErr<'tcx>> {\n     unsafe {\n-        let def_id = ccx.tcx().hir.local_def_id(id);\n-        let g = get_static(ccx, def_id);\n+        let def_id = cx.tcx.hir.local_def_id(id);\n+        let g = get_static(cx, def_id);\n \n-        let v = ::mir::trans_static_initializer(ccx, def_id)?;\n+        let v = ::mir::trans_static_initializer(cx, def_id)?;\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let mut val_llty = val_ty(v);\n-        let v = if val_llty == Type::i1(ccx) {\n-            val_llty = Type::i8(ccx);\n+        let v = if val_llty == Type::i1(cx) {\n+            val_llty = Type::i8(cx);\n             llvm::LLVMConstZExt(v, val_llty.to_ref())\n         } else {\n             v\n         };\n \n-        let instance = Instance::mono(ccx.tcx(), def_id);\n-        let ty = instance.ty(ccx.tcx());\n-        let llty = ccx.layout_of(ty).llvm_type(ccx);\n+        let instance = Instance::mono(cx.tcx, def_id);\n+        let ty = instance.ty(cx.tcx);\n+        let llty = cx.layout_of(ty).llvm_type(cx);\n         let g = if val_llty == llty {\n             g\n         } else {\n@@ -282,40 +282,40 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let visibility = llvm::LLVMRustGetVisibility(g);\n \n             let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                ccx.llmod(), name_string.as_ptr(), val_llty.to_ref());\n+                cx.llmod, name_string.as_ptr(), val_llty.to_ref());\n \n             llvm::LLVMRustSetLinkage(new_g, linkage);\n             llvm::LLVMRustSetVisibility(new_g, visibility);\n \n             // To avoid breaking any invariants, we leave around the old\n             // global for the moment; we'll replace all references to it\n             // with the new global later. (See base::trans_crate.)\n-            ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n+            cx.statics_to_rauw.borrow_mut().push((g, new_g));\n             new_g\n         };\n-        set_global_alignment(ccx, g, ccx.align_of(ty));\n+        set_global_alignment(cx, g, cx.align_of(ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != hir::MutMutable {\n-            if ccx.shared().type_is_freeze(ty) {\n+            if cx.type_is_freeze(ty) {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }\n \n-        debuginfo::create_global_var_metadata(ccx, id, g);\n+        debuginfo::create_global_var_metadata(cx, id, g);\n \n         if attr::contains_name(attrs, \"thread_local\") {\n-            llvm::set_thread_local_mode(g, ccx.tls_model());\n+            llvm::set_thread_local_mode(g, cx.tls_model);\n         }\n \n-        base::set_link_section(ccx, g, attrs);\n+        base::set_link_section(cx, g, attrs);\n \n         if attr::contains_name(attrs, \"used\") {\n             // This static will be stored in the llvm.used variable which is an array of i8*\n-            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(ccx).to_ref());\n-            ccx.used_statics().borrow_mut().push(cast);\n+            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n+            cx.used_statics.borrow_mut().push(cast);\n         }\n \n         Ok(g)"}, {"sha": "06b8d9ff7b306d1e8ae9eacfb1662baa72e90d08", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 102, "deletions": 326, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -11,10 +11,9 @@\n use common;\n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n-use rustc::dep_graph::{DepGraph, DepGraphSafe};\n+use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ich::StableHashingContext;\n use rustc::traits;\n use debuginfo;\n use callee;\n@@ -28,7 +27,6 @@ use type_of::PointeeInfo;\n \n use rustc_data_structures::base_n;\n use rustc::mir::mono::Stats;\n-use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout};\n@@ -41,38 +39,30 @@ use std::ptr;\n use std::iter;\n use std::str;\n use std::sync::Arc;\n-use std::marker::PhantomData;\n use syntax::symbol::InternedString;\n use abi::Abi;\n \n-/// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n-/// per crate.  The data here is shared between all compilation units of the\n-/// crate, so it must not contain references to any LLVM data structures\n-/// (aside from metadata-related ones).\n-pub struct SharedCrateContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    check_overflow: bool,\n-    use_dll_storage_attrs: bool,\n-    tls_model: llvm::ThreadLocalMode,\n-}\n+/// There is one `CodegenCx` per compilation unit. Each one has its own LLVM\n+/// `ContextRef` so that several compilation units may be optimized in parallel.\n+/// All other LLVM data structures in the `CodegenCx` are tied to that `ContextRef`.\n+pub struct CodegenCx<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub check_overflow: bool,\n+    pub use_dll_storage_attrs: bool,\n+    pub tls_model: llvm::ThreadLocalMode,\n \n-/// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n-/// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n-/// several compilation units may be optimized in parallel.  All other LLVM\n-/// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n-pub struct LocalCrateContext<'a, 'tcx: 'a> {\n-    llmod: ModuleRef,\n-    llcx: ContextRef,\n-    stats: RefCell<Stats>,\n-    codegen_unit: Arc<CodegenUnit<'tcx>>,\n+    pub llmod: ModuleRef,\n+    pub llcx: ContextRef,\n+    pub stats: RefCell<Stats>,\n+    pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n-    instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n+    pub instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FxHashMap<(Ty<'tcx>,\n+    pub vtables: RefCell<FxHashMap<(Ty<'tcx>,\n                                 Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n-    const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n+    pub const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n     /// Key is a ValueRef holding a *T,\n@@ -82,72 +72,42 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// when we ptrcast, and we have to ptrcast during translation\n     /// of a [T] const because we form a slice, a (*T,usize) pair, not\n     /// a pointer to an LLVM array type. Similar for trait objects.\n-    const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n+    pub const_unsized: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const globals (value -> global)\n-    const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n+    pub const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n     /// Mapping from static definitions to their DefId's.\n-    statics: RefCell<FxHashMap<ValueRef, DefId>>,\n+    pub statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n     /// List of globals for static variables which need to be passed to the\n     /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n     /// (We have to make sure we don't invalidate any ValueRefs referring\n     /// to constants.)\n-    statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n+    pub statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n \n     /// Statics that will be placed in the llvm.used variable\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n-    used_statics: RefCell<Vec<ValueRef>>,\n+    pub used_statics: RefCell<Vec<ValueRef>>,\n \n-    lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n-    scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n-    isize_ty: Type,\n+    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n+    pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n+    pub isize_ty: Type,\n \n-    dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n+    pub dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: Cell<Option<ValueRef>>,\n     eh_unwind_resume: Cell<Option<ValueRef>>,\n-    rust_try_fn: Cell<Option<ValueRef>>,\n+    pub rust_try_fn: Cell<Option<ValueRef>>,\n \n     intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n-\n-    /// A placeholder so we can add lifetimes\n-    placeholder: PhantomData<&'a ()>,\n-}\n-\n-/// A CrateContext value binds together one LocalCrateContext with the\n-/// SharedCrateContext. It exists as a convenience wrapper, so we don't have to\n-/// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n-pub struct CrateContext<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccx: &'a LocalCrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n-    pub fn new(shared: &'a SharedCrateContext<'a, 'tcx>,\n-               local_ccx: &'a LocalCrateContext<'a, 'tcx>)\n-               -> Self {\n-        CrateContext { shared, local_ccx }\n-    }\n-}\n-\n-impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n-}\n-\n-impl<'a, 'tcx> DepGraphSafe for SharedCrateContext<'a, 'tcx> {\n }\n \n-impl<'a, 'tcx> StableHashingContextProvider for SharedCrateContext<'a, 'tcx> {\n-    type ContextType = StableHashingContext<'tcx>;\n-\n-    fn create_stable_hashing_context(&self) -> Self::ContextType {\n-        self.tcx.create_stable_hashing_context()\n-    }\n+impl<'a, 'tcx> DepGraphSafe for CodegenCx<'a, 'tcx> {\n }\n \n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n@@ -252,8 +212,11 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n     (llcx, llmod)\n }\n \n-impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>) -> SharedCrateContext<'b, 'tcx> {\n+impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               codegen_unit: Arc<CodegenUnit<'tcx>>,\n+               llmod_id: &str)\n+               -> CodegenCx<'a, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -303,78 +266,25 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n         let tls_model = get_tls_model(&tcx.sess);\n \n-        SharedCrateContext {\n-            tcx,\n-            check_overflow,\n-            use_dll_storage_attrs,\n-            tls_model,\n-        }\n-    }\n-\n-    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_needs_drop(self.tcx, ty)\n-    }\n-\n-    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_sized(self.tcx, ty)\n-    }\n-\n-    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        common::type_is_freeze(self.tcx, ty)\n-    }\n-\n-    pub fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n-        use syntax_pos::DUMMY_SP;\n-        if ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP) {\n-            return false;\n-        }\n-\n-        let tail = self.tcx.struct_tail(ty);\n-        match tail.sty {\n-            ty::TyForeign(..) => false,\n-            ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n-            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n-        }\n-    }\n-\n-    pub fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    pub fn sess<'a>(&'a self) -> &'a Session {\n-        &self.tcx.sess\n-    }\n-\n-    pub fn dep_graph<'a>(&'a self) -> &'a DepGraph {\n-        &self.tcx.dep_graph\n-    }\n-\n-    pub fn use_dll_storage_attrs(&self) -> bool {\n-        self.use_dll_storage_attrs\n-    }\n-}\n-\n-impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n-    pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: Arc<CodegenUnit<'tcx>>,\n-               llmod_id: &str)\n-               -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n-            let (llcx, llmod) = create_context_and_module(&shared.tcx.sess,\n+            let (llcx, llmod) = create_context_and_module(&tcx.sess,\n                                                           &llmod_id[..]);\n \n-            let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n+            let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 let dctx = debuginfo::CrateDebugContext::new(llmod);\n-                debuginfo::metadata::compile_unit_metadata(shared,\n+                debuginfo::metadata::compile_unit_metadata(tcx,\n                                                            codegen_unit.name(),\n-                                                           &dctx,\n-                                                           shared.tcx.sess);\n+                                                           &dctx);\n                 Some(dctx)\n             } else {\n                 None\n             };\n \n-            let local_ccx = LocalCrateContext {\n+            let mut cx = CodegenCx {\n+                tcx,\n+                check_overflow,\n+                use_dll_storage_attrs,\n+                tls_model,\n                 llmod,\n                 llcx,\n                 stats: RefCell::new(Stats::default()),\n@@ -397,41 +307,9 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n                 local_gen_sym_counter: Cell::new(0),\n-                placeholder: PhantomData,\n             };\n-\n-            let (isize_ty, mut local_ccx) = {\n-                // Do a little dance to create a dummy CrateContext, so we can\n-                // create some things in the LLVM module of this codegen unit\n-                let mut local_ccxs = vec![local_ccx];\n-                let isize_ty = {\n-                    let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n-                                                                 local_ccxs.as_mut_slice());\n-                    Type::isize(&dummy_ccx)\n-                };\n-                (isize_ty, local_ccxs.pop().unwrap())\n-            };\n-\n-            local_ccx.isize_ty = isize_ty;\n-\n-            local_ccx\n-        }\n-    }\n-\n-    /// Create a dummy `CrateContext` from `self` and  the provided\n-    /// `SharedCrateContext`.  This is somewhat dangerous because `self` may\n-    /// not be fully initialized.\n-    ///\n-    /// This is used in the `LocalCrateContext` constructor to allow calling\n-    /// functions that expect a complete `CrateContext`, even before the local\n-    /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx(shared: &'a SharedCrateContext<'a, 'tcx>,\n-                 local_ccxs: &'a [LocalCrateContext<'a, 'tcx>])\n-                 -> CrateContext<'a, 'tcx> {\n-        assert!(local_ccxs.len() == 1);\n-        CrateContext {\n-            shared,\n-            local_ccx: &local_ccxs[0]\n+            cx.isize_ty = Type::isize(&cx);\n+            cx\n         }\n     }\n \n@@ -440,25 +318,13 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n-    pub fn shared(&self) -> &'b SharedCrateContext<'b, 'tcx> {\n-        self.shared\n-    }\n-\n-    fn local(&self) -> &'b LocalCrateContext<'b, 'tcx> {\n-        self.local_ccx\n-    }\n-\n-    pub fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.shared.tcx\n-    }\n-\n+impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     pub fn sess<'a>(&'a self) -> &'a Session {\n-        &self.shared.tcx.sess\n+        &self.tcx.sess\n     }\n \n     pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n-        if let Some(v) = self.intrinsics().borrow().get(key).cloned() {\n+        if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n         match declare_intrinsic(self, key) {\n@@ -467,106 +333,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n     }\n \n-    pub fn llmod(&self) -> ModuleRef {\n-        self.local().llmod\n-    }\n-\n-    pub fn llcx(&self) -> ContextRef {\n-        self.local().llcx\n-    }\n-\n-    pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n-        &self.local().codegen_unit\n-    }\n-\n-    pub fn td(&self) -> llvm::TargetDataRef {\n-        unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n-    }\n-\n-    pub fn instances<'a>(&'a self) -> &'a RefCell<FxHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.local().instances\n-    }\n-\n-    pub fn vtables<'a>(&'a self)\n-        -> &'a RefCell<FxHashMap<(Ty<'tcx>,\n-                                  Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>> {\n-        &self.local().vtables\n-    }\n-\n-    pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FxHashMap<InternedString, ValueRef>> {\n-        &self.local().const_cstr_cache\n-    }\n-\n-    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n-        &self.local().const_unsized\n-    }\n-\n-    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, ValueRef>> {\n-        &self.local().const_globals\n-    }\n-\n-    pub fn statics<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, DefId>> {\n-        &self.local().statics\n-    }\n-\n-    pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n-        &self.local().statics_to_rauw\n-    }\n-\n-    pub fn used_statics<'a>(&'a self) -> &'a RefCell<Vec<ValueRef>> {\n-        &self.local().used_statics\n-    }\n-\n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>> {\n-        &self.local().lltypes\n-    }\n-\n-    pub fn scalar_lltypes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Type>> {\n-        &self.local().scalar_lltypes\n-    }\n-\n-    pub fn pointee_infos<'a>(&'a self)\n-                             -> &'a RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>> {\n-        &self.local().pointee_infos\n-    }\n-\n-    pub fn stats<'a>(&'a self) -> &'a RefCell<Stats> {\n-        &self.local().stats\n-    }\n-\n-    pub fn isize_ty(&self) -> Type {\n-        self.local().isize_ty\n-    }\n-\n-    pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n-        &self.local().dbg_cx\n-    }\n-\n-    pub fn rust_try_fn<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local().rust_try_fn\n-    }\n-\n-    fn intrinsics<'a>(&'a self) -> &'a RefCell<FxHashMap<&'static str, ValueRef>> {\n-        &self.local().intrinsics\n-    }\n-\n-    pub fn check_overflow(&self) -> bool {\n-        self.shared.check_overflow\n-    }\n-\n-    pub fn use_dll_storage_attrs(&self) -> bool {\n-        self.shared.use_dll_storage_attrs()\n-    }\n-\n-    pub fn tls_model(&self) -> llvm::ThreadLocalMode {\n-        self.shared.tls_model\n-    }\n-\n     /// Generate a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n-        let idx = self.local().local_gen_sym_counter.get();\n-        self.local().local_gen_sym_counter.set(idx + 1);\n+        let idx = self.local_gen_sym_counter.get();\n+        self.local_gen_sym_counter.set(idx + 1);\n         // Include a '.' character, so there can be no accidental conflicts with\n         // user defined names\n         let mut name = String::with_capacity(prefix.len() + 6);\n@@ -597,10 +368,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         // `rust_eh_personality` function, but rather we wired it up to the\n         // CRT's custom personality function, which forces LLVM to consider\n         // landing pads as \"landing pads for SEH\".\n-        if let Some(llpersonality) = self.local().eh_personality.get() {\n+        if let Some(llpersonality) = self.eh_personality.get() {\n             return llpersonality\n         }\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         let llfn = match tcx.lang_items().eh_personality() {\n             Some(def_id) if !base::wants_msvc_seh(self.sess()) => {\n                 callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]))\n@@ -615,20 +386,20 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n                 declare::declare_cfn(self, name, fty)\n             }\n         };\n-        self.local().eh_personality.set(Some(llfn));\n+        self.eh_personality.set(Some(llfn));\n         llfn\n     }\n \n     // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n     // otherwise declares it as an external function.\n     pub fn eh_unwind_resume(&self) -> ValueRef {\n         use attributes;\n-        let unwresume = &self.local().eh_unwind_resume;\n+        let unwresume = &self.eh_unwind_resume;\n         if let Some(llfn) = unwresume.get() {\n             return llfn;\n         }\n \n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         assert!(self.sess().target.target.options.custom_unwind_resume);\n         if let Some(def_id) = tcx.lang_items().eh_unwind_resume() {\n             let llfn = callee::resolve_and_get_fn(self, def_id, tcx.intern_substs(&[]));\n@@ -649,33 +420,47 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         unwresume.set(Some(llfn));\n         llfn\n     }\n-}\n \n-impl<'a, 'tcx> ty::layout::HasDataLayout for &'a SharedCrateContext<'a, 'tcx> {\n-    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n-        &self.tcx.data_layout\n+    pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_needs_drop(self.tcx, ty)\n     }\n-}\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n+    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_is_sized(self.tcx, ty)\n+    }\n+\n+    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_is_freeze(self.tcx, ty)\n+    }\n+\n+    pub fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n+        use syntax_pos::DUMMY_SP;\n+        if ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP) {\n+            return false;\n+        }\n+\n+        let tail = self.tcx.struct_tail(ty);\n+        match tail.sty {\n+            ty::TyForeign(..) => false,\n+            ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n+            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+        }\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CodegenCx<'a, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n-        &self.shared.tcx.data_layout\n+        &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CodegenCx<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.shared.tcx\n+        self.tcx\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a SharedCrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CodegenCx<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n@@ -688,57 +473,48 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a SharedCrateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for &'a CrateContext<'a, 'tcx> {\n-    type TyLayout = TyLayout<'tcx>;\n-\n-\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        self.shared.layout_of(ty)\n-    }\n-}\n-\n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n+fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n+                cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name, Type::variadic_func(&[], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n+                cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], &$ret));\n                 llvm::SetUnnamedAddr(f, false);\n-                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n+                cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n     }\n     macro_rules! mk_struct {\n-        ($($field_ty:expr),*) => (Type::struct_(ccx, &[$($field_ty),*], false))\n+        ($($field_ty:expr),*) => (Type::struct_(cx, &[$($field_ty),*], false))\n     }\n \n-    let i8p = Type::i8p(ccx);\n-    let void = Type::void(ccx);\n-    let i1 = Type::i1(ccx);\n-    let t_i8 = Type::i8(ccx);\n-    let t_i16 = Type::i16(ccx);\n-    let t_i32 = Type::i32(ccx);\n-    let t_i64 = Type::i64(ccx);\n-    let t_i128 = Type::i128(ccx);\n-    let t_f32 = Type::f32(ccx);\n-    let t_f64 = Type::f64(ccx);\n+    let i8p = Type::i8p(cx);\n+    let void = Type::void(cx);\n+    let i1 = Type::i1(cx);\n+    let t_i8 = Type::i8(cx);\n+    let t_i16 = Type::i16(cx);\n+    let t_i32 = Type::i32(cx);\n+    let t_i64 = Type::i64(cx);\n+    let t_i128 = Type::i128(cx);\n+    let t_f32 = Type::f32(cx);\n+    let t_f64 = Type::f64(cx);\n \n     ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n@@ -870,9 +646,9 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.assume\", fn(i1) -> void);\n     ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n-    if ccx.sess().opts.debuginfo != NoDebugInfo {\n-        ifn!(\"llvm.dbg.declare\", fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n-        ifn!(\"llvm.dbg.value\", fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n+    if cx.sess().opts.debuginfo != NoDebugInfo {\n+        ifn!(\"llvm.dbg.declare\", fn(Type::metadata(cx), Type::metadata(cx)) -> void);\n+        ifn!(\"llvm.dbg.value\", fn(Type::metadata(cx), t_i64, Type::metadata(cx)) -> void);\n     }\n     return None;\n }"}, {"sha": "bddb3d909402e323905f3f944cd872df672f7f48", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -14,7 +14,7 @@ use super::utils::{DIB, span_start};\n \n use llvm;\n use llvm::debuginfo::DIScope;\n-use common::CrateContext;\n+use common::CodegenCx;\n use rustc::mir::{Mir, VisibilityScope};\n \n use libc::c_uint;\n@@ -44,7 +44,7 @@ impl MirDebugScope {\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &FunctionDebugContext)\n+pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebugContext)\n     -> IndexVec<VisibilityScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n@@ -71,13 +71,13 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n     // Instantiate all scopes.\n     for idx in 0..mir.visibility_scopes.len() {\n         let scope = VisibilityScope::new(idx);\n-        make_mir_scope(ccx, &mir, &has_variables, debug_context, scope, &mut scopes);\n+        make_mir_scope(cx, &mir, &has_variables, debug_context, scope, &mut scopes);\n     }\n \n     scopes\n }\n \n-fn make_mir_scope(ccx: &CrateContext,\n+fn make_mir_scope(cx: &CodegenCx,\n                   mir: &Mir,\n                   has_variables: &BitVector,\n                   debug_context: &FunctionDebugContextData,\n@@ -89,11 +89,11 @@ fn make_mir_scope(ccx: &CrateContext,\n \n     let scope_data = &mir.visibility_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(ccx, mir, has_variables, debug_context, parent, scopes);\n+        make_mir_scope(cx, mir, has_variables, debug_context, parent, scopes);\n         scopes[parent]\n     } else {\n         // The root is the function itself.\n-        let loc = span_start(ccx, mir.span);\n+        let loc = span_start(cx, mir.span);\n         scopes[scope] = MirDebugScope {\n             scope_metadata: debug_context.fn_metadata,\n             file_start_pos: loc.file.start_pos,\n@@ -115,14 +115,14 @@ fn make_mir_scope(ccx: &CrateContext,\n         }\n     }\n \n-    let loc = span_start(ccx, scope_data.span);\n-    let file_metadata = file_metadata(ccx,\n+    let loc = span_start(cx, scope_data.span);\n+    let file_metadata = file_metadata(cx,\n                                       &loc.file.name,\n                                       debug_context.defining_crate);\n \n     let scope_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlock(\n-            DIB(ccx),\n+            DIB(cx),\n             parent_scope.scope_metadata,\n             file_metadata,\n             loc.line as c_uint,"}, {"sha": "cbecc0eb7d1b5e708cc86168b336f3ca512aae42", "filename": "src/librustc_trans/debuginfo/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -32,7 +32,7 @@\n //! The public API of the module is a set of functions that will insert the\n //! correct metadata into the LLVM IR when called with the right parameters.\n //! The module is thus driven from an outside client with functions like\n-//! `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n+//! `debuginfo::create_local_var_metadata(bx: block, local: &ast::local)`.\n //!\n //! Internally the module will try to reuse already created metadata by\n //! utilizing a cache. The way to get a shared metadata node when needed is\n@@ -44,8 +44,8 @@\n //! that exact file path.\n //!\n //! All private state used by the module is stored within either the\n-//! CrateDebugContext struct (owned by the CrateContext) or the\n-//! FunctionDebugContext (owned by the MirContext).\n+//! CrateDebugContext struct (owned by the CodegenCx) or the\n+//! FunctionDebugContext (owned by the FunctionCx).\n //!\n //! This file consists of three conceptual sections:\n //! 1. The public interface of the module"}, {"sha": "03e7c63dbca36a87a2c3a2677ebafc441e524847", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -12,7 +12,7 @@\n \n use llvm;\n \n-use common::{C_bytes, CrateContext, C_i32};\n+use common::{C_bytes, CodegenCx, C_i32};\n use builder::Builder;\n use declare;\n use type_::Type;\n@@ -24,14 +24,14 @@ use syntax::attr;\n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n-pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext, builder: &Builder) {\n-    if needs_gdb_debug_scripts_section(ccx) {\n-        let gdb_debug_scripts_section_global = get_or_insert_gdb_debug_scripts_section_global(ccx);\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &Builder) {\n+    if needs_gdb_debug_scripts_section(bx.cx) {\n+        let gdb_debug_scripts_section = get_or_insert_gdb_debug_scripts_section_global(bx.cx);\n         // Load just the first byte as that's all that's necessary to force\n         // LLVM to keep around the reference to the global.\n-        let indices = [C_i32(ccx, 0), C_i32(ccx, 0)];\n-        let element = builder.inbounds_gep(gdb_debug_scripts_section_global, &indices);\n-        let volative_load_instruction = builder.volatile_load(element);\n+        let indices = [C_i32(bx.cx, 0), C_i32(bx.cx, 0)];\n+        let element = bx.inbounds_gep(gdb_debug_scripts_section, &indices);\n+        let volative_load_instruction = bx.volatile_load(element);\n         unsafe {\n             llvm::LLVMSetAlignment(volative_load_instruction, 1);\n         }\n@@ -40,13 +40,13 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext,\n \n /// Allocates the global variable responsible for the .debug_gdb_scripts binary\n /// section.\n-pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n+pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n                                                   -> llvm::ValueRef {\n     let c_section_var_name = \"__rustc_debug_gdb_scripts_section__\\0\";\n     let section_var_name = &c_section_var_name[..c_section_var_name.len()-1];\n \n     let section_var = unsafe {\n-        llvm::LLVMGetNamedGlobal(ccx.llmod(),\n+        llvm::LLVMGetNamedGlobal(cx.llmod,\n                                  c_section_var_name.as_ptr() as *const _)\n     };\n \n@@ -55,15 +55,15 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = Type::array(&Type::i8(ccx),\n+            let llvm_type = Type::array(&Type::i8(cx),\n                                         section_contents.len() as u64);\n \n-            let section_var = declare::define_global(ccx, section_var_name,\n+            let section_var = declare::define_global(cx, section_var_name,\n                                                      llvm_type).unwrap_or_else(||{\n                 bug!(\"symbol `{}` is already defined\", section_var_name)\n             });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n-            llvm::LLVMSetInitializer(section_var, C_bytes(ccx, section_contents));\n+            llvm::LLVMSetInitializer(section_var, C_bytes(cx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n             llvm::LLVMRustSetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);\n@@ -77,13 +77,13 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(ccx: &CrateContext)\n     }\n }\n \n-pub fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n+pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&ccx.tcx().hir.krate_attrs(),\n+        attr::contains_name(&cx.tcx.hir.krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");\n \n     !omit_gdb_pretty_printer_section &&\n-    !ccx.sess().target.target.options.is_like_osx &&\n-    !ccx.sess().target.target.options.is_like_windows &&\n-    ccx.sess().opts.debuginfo != NoDebugInfo\n+    !cx.sess().target.target.options.is_like_osx &&\n+    !cx.sess().target.target.options.is_like_windows &&\n+    cx.sess().opts.debuginfo != NoDebugInfo\n }"}, {"sha": "62ba91840d95e4c4281fd36566742acc881725b6", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 74, "deletions": 76, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -18,7 +18,6 @@ use super::namespace::mangled_name_of_item;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use abi;\n-use context::SharedCrateContext;\n \n use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n@@ -30,10 +29,10 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::util::TypeIdHasher;\n use rustc::ich::Fingerprint;\n use rustc::ty::Instance;\n-use common::CrateContext;\n-use rustc::ty::{self, AdtKind, Ty};\n+use common::CodegenCx;\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n-use rustc::session::{Session, config};\n+use rustc::session::config;\n use rustc::util::nodemap::FxHashMap;\n use rustc::util::common::path2cstr;\n \n@@ -134,7 +133,7 @@ impl<'tcx> TypeMap<'tcx> {\n     // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given\n     // type has been requested before, this is just a table lookup. Otherwise an\n     // ID will be generated and stored for later lookup.\n-    fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n+    fn get_unique_type_id_of_type<'a>(&mut self, cx: &CodegenCx<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n         // Let's see if we already have something in the cache\n         match self.type_to_unique_id.get(&type_).cloned() {\n@@ -144,7 +143,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n         // The hasher we are using to generate the UniqueTypeId. We want\n         // something that provides more than the 64 bits of the DefaultHasher.\n-        let mut type_id_hasher = TypeIdHasher::<Fingerprint>::new(cx.tcx());\n+        let mut type_id_hasher = TypeIdHasher::<Fingerprint>::new(cx.tcx);\n         type_id_hasher.visit_ty(type_);\n         let unique_type_id = type_id_hasher.finish().to_hex();\n \n@@ -158,7 +157,7 @@ impl<'tcx> TypeMap<'tcx> {\n     // types of their own, so they need special handling. We still need a\n     // UniqueTypeId for them, since to debuginfo they *are* real types.\n     fn get_unique_type_id_of_enum_variant<'a>(&mut self,\n-                                              cx: &CrateContext<'a, 'tcx>,\n+                                              cx: &CodegenCx<'a, 'tcx>,\n                                               enum_type: Ty<'tcx>,\n                                               variant_name: &str)\n                                               -> UniqueTypeId {\n@@ -187,7 +186,7 @@ enum RecursiveTypeDescription<'tcx> {\n }\n \n fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n-    cx: &CrateContext<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n     metadata_stub: DICompositeType,\n@@ -211,7 +210,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n     // Finishes up the description of the type in question (mostly by providing\n     // descriptions of the fields of the given type) and returns the final type\n     // metadata.\n-    fn finalize<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> MetadataCreationResult {\n+    fn finalize<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> MetadataCreationResult {\n         match *self {\n             FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n             UnfinishedMetadata {\n@@ -263,7 +262,7 @@ macro_rules! return_if_metadata_created_in_meantime {\n     )\n }\n \n-fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 array_or_slice_type: Ty<'tcx>,\n                                 element_type: Ty<'tcx>,\n@@ -299,13 +298,13 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return MetadataCreationResult::new(metadata, false);\n }\n \n-fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn vec_slice_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 slice_ptr_type: Ty<'tcx>,\n                                 element_type: Ty<'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n-    let data_ptr_type = cx.tcx().mk_imm_ptr(element_type);\n+    let data_ptr_type = cx.tcx.mk_imm_ptr(element_type);\n \n     let data_ptr_metadata = type_metadata(cx, data_ptr_type, span);\n \n@@ -314,7 +313,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let slice_type_name = compute_debuginfo_type_name(cx, slice_ptr_type, true);\n \n     let (pointer_size, pointer_align) = cx.size_and_align_of(data_ptr_type);\n-    let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx().types.usize);\n+    let (usize_size, usize_align) = cx.size_and_align_of(cx.tcx.types.usize);\n \n     let member_descriptions = [\n         MemberDescription {\n@@ -327,7 +326,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         MemberDescription {\n             name: \"length\".to_string(),\n-            type_metadata: type_metadata(cx, cx.tcx().types.usize, span),\n+            type_metadata: type_metadata(cx, cx.tcx.types.usize, span),\n             offset: pointer_size,\n             size: usize_size,\n             align: usize_align,\n@@ -348,13 +347,13 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     MetadataCreationResult::new(metadata, false)\n }\n \n-fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn subroutine_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                       unique_type_id: UniqueTypeId,\n                                       signature: ty::PolyFnSig<'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult\n {\n-    let signature = cx.tcx().erase_late_bound_regions_and_normalize(&signature);\n+    let signature = cx.tcx.erase_late_bound_regions_and_normalize(&signature);\n \n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs().len() + 1);\n \n@@ -387,7 +386,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n // trait_type should be the actual trait (e.g., Trait). Where the trait is part\n // of a DST struct, there is no trait_object_type and the results of this\n // function will be a little bit weird.\n-fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn trait_pointer_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     trait_type: Ty<'tcx>,\n                                     trait_object_type: Option<Ty<'tcx>>,\n                                     unique_type_id: UniqueTypeId)\n@@ -416,7 +415,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let file_metadata = unknown_file_metadata(cx);\n \n-    let layout = cx.layout_of(cx.tcx().mk_mut_ptr(trait_type));\n+    let layout = cx.layout_of(cx.tcx.mk_mut_ptr(trait_type));\n \n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n@@ -427,7 +426,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         MemberDescription {\n             name: \"pointer\".to_string(),\n             type_metadata: type_metadata(cx,\n-                cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n+                cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n                 syntax_pos::DUMMY_SP),\n             offset: layout.fields.offset(0),\n             size: data_ptr_field.size,\n@@ -454,7 +453,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             syntax_pos::DUMMY_SP)\n }\n \n-pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                t: Ty<'tcx>,\n                                usage_site_span: Span)\n                                -> DIType {\n@@ -499,7 +498,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span))\n             }\n             ty::TyStr => {\n-                Ok(vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span))\n+                Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span))\n             }\n             ty::TyDynamic(..) => {\n                 Ok(MetadataCreationResult::new(\n@@ -539,7 +538,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n         }\n         ty::TyStr => {\n-            fixed_vec_metadata(cx, unique_type_id, t, cx.tcx().types.i8, usage_site_span)\n+            fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8, usage_site_span)\n         }\n         ty::TyDynamic(..) => {\n             MetadataCreationResult::new(\n@@ -567,7 +566,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n             let fn_metadata = subroutine_type_metadata(cx,\n                                                        unique_type_id,\n-                                                       t.fn_sig(cx.tcx()),\n+                                                       t.fn_sig(cx.tcx),\n                                                        usage_site_span).metadata;\n             match debug_context(cx).type_map\n                                    .borrow()\n@@ -581,16 +580,16 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         }\n         ty::TyClosure(def_id, substs) => {\n-            let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx()).collect();\n+            let upvar_tys : Vec<_> = substs.upvar_tys(def_id, cx.tcx).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n                                    &upvar_tys,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n         ty::TyGenerator(def_id, substs, _) => {\n-            let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx()).map(|t| {\n-                cx.tcx().fully_normalize_associated_types_in(&t)\n+            let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx).map(|t| {\n+                cx.tcx.fully_normalize_associated_types_in(&t)\n             }).collect();\n             prepare_tuple_metadata(cx,\n                                    t,\n@@ -674,7 +673,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     metadata\n }\n \n-pub fn file_metadata(cx: &CrateContext,\n+pub fn file_metadata(cx: &CodegenCx,\n                      file_name: &FileName,\n                      defining_crate: CrateNum) -> DIFile {\n     debug!(\"file_metadata: file_name: {}, defining_crate: {}\",\n@@ -692,11 +691,11 @@ pub fn file_metadata(cx: &CrateContext,\n     file_metadata_raw(cx, &file_name.to_string(), &directory.to_string_lossy())\n }\n \n-pub fn unknown_file_metadata(cx: &CrateContext) -> DIFile {\n+pub fn unknown_file_metadata(cx: &CodegenCx) -> DIFile {\n     file_metadata_raw(cx, \"<unknown>\", \"\")\n }\n \n-fn file_metadata_raw(cx: &CrateContext,\n+fn file_metadata_raw(cx: &CodegenCx,\n                      file_name: &str,\n                      directory: &str)\n                      -> DIFile {\n@@ -722,7 +721,7 @@ fn file_metadata_raw(cx: &CrateContext,\n     file_metadata\n }\n \n-fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn basic_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                  t: Ty<'tcx>) -> DIType {\n \n     debug!(\"basic_type_metadata: {:?}\", t);\n@@ -759,7 +758,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return ty_metadata;\n }\n \n-fn foreign_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn foreign_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    t: Ty<'tcx>,\n                                    unique_type_id: UniqueTypeId) -> DIType {\n     debug!(\"foreign_type_metadata: {:?}\", t);\n@@ -768,7 +767,7 @@ fn foreign_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     create_struct_stub(cx, t, &name, unique_type_id, NO_SCOPE_METADATA)\n }\n \n-fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn pointer_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    pointer_type: Ty<'tcx>,\n                                    pointee_type_metadata: DIType)\n                                    -> DIType {\n@@ -785,21 +784,20 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn compile_unit_metadata(scc: &SharedCrateContext,\n+pub fn compile_unit_metadata(tcx: TyCtxt,\n                              codegen_unit_name: &str,\n-                             debug_context: &CrateDebugContext,\n-                             sess: &Session)\n+                             debug_context: &CrateDebugContext)\n                              -> DIDescriptor {\n-    let mut name_in_debuginfo = match sess.local_crate_source_file {\n+    let mut name_in_debuginfo = match tcx.sess.local_crate_source_file {\n         Some(ref path) => path.clone(),\n-        None => PathBuf::from(&*scc.tcx().crate_name(LOCAL_CRATE).as_str()),\n+        None => PathBuf::from(&*tcx.crate_name(LOCAL_CRATE).as_str()),\n     };\n \n     // The OSX linker has an idiosyncrasy where it will ignore some debuginfo\n     // if multiple object files with the same DW_AT_name are linked together.\n     // As a workaround we generate unique names for each object file. Those do\n     // not correspond to an actual source file but that should be harmless.\n-    if scc.sess().target.target.options.is_like_osx {\n+    if tcx.sess.target.target.options.is_like_osx {\n         name_in_debuginfo.push(\"@\");\n         name_in_debuginfo.push(codegen_unit_name);\n     }\n@@ -811,7 +809,7 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy().into_owned();\n     let name_in_debuginfo = CString::new(name_in_debuginfo).unwrap();\n-    let work_dir = CString::new(&sess.working_dir.0.to_string_lossy()[..]).unwrap();\n+    let work_dir = CString::new(&tcx.sess.working_dir.0.to_string_lossy()[..]).unwrap();\n     let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n@@ -825,20 +823,20 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n             DW_LANG_RUST,\n             file_metadata,\n             producer.as_ptr(),\n-            sess.opts.optimize != config::OptLevel::No,\n+            tcx.sess.opts.optimize != config::OptLevel::No,\n             flags.as_ptr() as *const _,\n             0,\n             split_name.as_ptr() as *const _);\n \n-        if sess.opts.debugging_opts.profile {\n+        if tcx.sess.opts.debugging_opts.profile {\n             let cu_desc_metadata = llvm::LLVMRustMetadataAsValue(debug_context.llcontext,\n                                                                  unit_metadata);\n \n             let gcov_cu_info = [\n                 path_to_mdstring(debug_context.llcontext,\n-                                 &scc.tcx().output_filenames(LOCAL_CRATE).with_extension(\"gcno\")),\n+                                 &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcno\")),\n                 path_to_mdstring(debug_context.llcontext,\n-                                 &scc.tcx().output_filenames(LOCAL_CRATE).with_extension(\"gcda\")),\n+                                 &tcx.output_filenames(LOCAL_CRATE).with_extension(\"gcda\")),\n                 cu_desc_metadata,\n             ];\n             let gcov_metadata = llvm::LLVMMDNodeInContext(debug_context.llcontext,\n@@ -903,7 +901,7 @@ enum MemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> MemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         match *self {\n             StructMDF(ref this) => {\n@@ -937,7 +935,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n@@ -961,7 +959,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n }\n \n \n-fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn prepare_struct_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                      struct_type: Ty<'tcx>,\n                                      unique_type_id: UniqueTypeId,\n                                      span: Span)\n@@ -1006,7 +1004,7 @@ struct TupleMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n         self.component_types.iter().enumerate().map(|(i, &component_type)| {\n@@ -1023,7 +1021,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn prepare_tuple_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     tuple_type: Ty<'tcx>,\n                                     component_types: &[Ty<'tcx>],\n                                     unique_type_id: UniqueTypeId,\n@@ -1059,7 +1057,7 @@ struct UnionMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n@@ -1076,7 +1074,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     }\n }\n \n-fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn prepare_union_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     union_type: Ty<'tcx>,\n                                     unique_type_id: UniqueTypeId,\n                                     span: Span)\n@@ -1127,7 +1125,7 @@ struct EnumMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n         match self.layout.variants {\n@@ -1212,7 +1210,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // of discriminant instead of us having to recover its path.\n                 // Right now it's not even going to work for `niche_start > 0`,\n                 // and for multiple niche variants it only supports the first.\n-                fn compute_field_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                fn compute_field_path<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                                 name: &mut String,\n                                                 layout: TyLayout<'tcx>,\n                                                 offset: Size,\n@@ -1223,10 +1221,10 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             continue;\n                         }\n                         let inner_offset = offset - field_offset;\n-                        let field = layout.field(ccx, i);\n+                        let field = layout.field(cx, i);\n                         if inner_offset + size <= field.size {\n                             write!(name, \"{}$\", i).unwrap();\n-                            compute_field_path(ccx, name, field, inner_offset, size);\n+                            compute_field_path(cx, name, field, inner_offset, size);\n                         }\n                     }\n                 }\n@@ -1262,7 +1260,7 @@ struct VariantMemberDescriptionFactory<'tcx> {\n }\n \n impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n-    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+    fn create_member_descriptions<'a>(&self, cx: &CodegenCx<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             let (size, align) = cx.size_and_align_of(ty);\n@@ -1292,7 +1290,7 @@ enum EnumDiscriminantInfo {\n // of the variant, and (3) a MemberDescriptionFactory for producing the\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n-fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    layout: layout::TyLayout<'tcx>,\n                                    variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n@@ -1352,7 +1350,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     (metadata_stub, member_description_factory)\n }\n \n-fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n                                    enum_def_id: DefId,\n                                    unique_type_id: UniqueTypeId,\n@@ -1370,7 +1368,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let file_metadata = unknown_file_metadata(cx);\n \n     let def = enum_type.ty_adt_def().unwrap();\n-    let enumerators_metadata: Vec<DIDescriptor> = def.discriminants(cx.tcx())\n+    let enumerators_metadata: Vec<DIDescriptor> = def.discriminants(cx.tcx)\n         .zip(&def.variants)\n         .map(|(discr, v)| {\n             let token = v.name.as_str();\n@@ -1396,7 +1394,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let (discriminant_size, discriminant_align) =\n                     (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n-                    type_metadata(cx, discr.to_ty(cx.tcx()), syntax_pos::DUMMY_SP);\n+                    type_metadata(cx, discr.to_ty(cx.tcx), syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n                 let name = CString::new(discriminant_name.as_bytes()).unwrap();\n@@ -1472,18 +1470,18 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }),\n     );\n \n-    fn get_enum_discriminant_name(cx: &CrateContext,\n+    fn get_enum_discriminant_name(cx: &CodegenCx,\n                                   def_id: DefId)\n                                   -> InternedString {\n-        cx.tcx().item_name(def_id)\n+        cx.tcx.item_name(def_id)\n     }\n }\n \n /// Creates debug information for a composite type, that is, anything that\n /// results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn composite_type_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                      composite_type: Ty<'tcx>,\n                                      composite_type_name: &str,\n                                      composite_type_unique_id: UniqueTypeId,\n@@ -1509,7 +1507,7 @@ fn composite_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return composite_type_metadata;\n }\n \n-fn set_members_of_composite_type(cx: &CrateContext,\n+fn set_members_of_composite_type(cx: &CodegenCx,\n                                  composite_type_metadata: DICompositeType,\n                                  member_descriptions: &[MemberDescription]) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n@@ -1560,7 +1558,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n // A convenience wrapper around LLVMRustDIBuilderCreateStructType(). Does not do\n // any caching, does not add any fields to the struct. This can be done later\n // with set_members_of_composite_type().\n-fn create_struct_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn create_struct_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 struct_type: Ty<'tcx>,\n                                 struct_type_name: &str,\n                                 unique_type_id: UniqueTypeId,\n@@ -1597,7 +1595,7 @@ fn create_struct_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return metadata_stub;\n }\n \n-fn create_union_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                union_type: Ty<'tcx>,\n                                union_type_name: &str,\n                                unique_type_id: UniqueTypeId,\n@@ -1635,20 +1633,20 @@ fn create_union_stub<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n /// Creates debug information for the given global variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_global_var_metadata(cx: &CrateContext,\n+pub fn create_global_var_metadata(cx: &CodegenCx,\n                                   node_id: ast::NodeId,\n                                   global: ValueRef) {\n-    if cx.dbg_cx().is_none() {\n+    if cx.dbg_cx.is_none() {\n         return;\n     }\n \n-    let tcx = cx.tcx();\n+    let tcx = cx.tcx;\n     let node_def_id = tcx.hir.local_def_id(node_id);\n     let no_mangle = attr::contains_name(&tcx.get_attrs(node_def_id), \"no_mangle\");\n     // We may want to remove the namespace scope if we're in an extern block, see:\n     // https://github.com/rust-lang/rust/pull/46457#issuecomment-351750952\n     let var_scope = get_namespace_for_item(cx, node_def_id);\n-    let span = cx.tcx().def_span(node_def_id);\n+    let span = cx.tcx.def_span(node_def_id);\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n         let loc = span_start(cx, span);\n@@ -1658,7 +1656,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = Instance::mono(cx.tcx(), node_def_id).ty(cx.tcx());\n+    let variable_type = Instance::mono(cx.tcx, node_def_id).ty(cx.tcx);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let var_name = CString::new(var_name).unwrap();\n@@ -1691,15 +1689,15 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n }\n \n // Creates an \"extension\" of an existing DIScope into another file.\n-pub fn extend_scope_to_file(ccx: &CrateContext,\n+pub fn extend_scope_to_file(cx: &CodegenCx,\n                             scope_metadata: DIScope,\n                             file: &syntax_pos::FileMap,\n                             defining_crate: CrateNum)\n                             -> DILexicalBlock {\n-    let file_metadata = file_metadata(ccx, &file.name, defining_crate);\n+    let file_metadata = file_metadata(cx, &file.name, defining_crate);\n     unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n-            DIB(ccx),\n+            DIB(cx),\n             scope_metadata,\n             file_metadata)\n     }\n@@ -1709,10 +1707,10 @@ pub fn extend_scope_to_file(ccx: &CrateContext,\n /// given type.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn create_vtable_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                         ty: ty::Ty<'tcx>,\n                                         vtable: ValueRef) {\n-    if cx.dbg_cx().is_none() {\n+    if cx.dbg_cx.is_none() {\n         return;\n     }\n \n@@ -1736,7 +1734,7 @@ pub fn create_vtable_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             Size::from_bytes(0).bits(),\n-            cx.tcx().data_layout.pointer_align.abi_bits() as u32,\n+            cx.tcx.data_layout.pointer_align.abi_bits() as u32,\n             DIFlags::FlagArtificial,\n             ptr::null_mut(),\n             empty_array,"}, {"sha": "b46e12d9d5b67e8f9a68b9aacb42447bdfd3f9f4", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n-use common::CrateContext;\n+use common::CodegenCx;\n use builder::Builder;\n use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n@@ -150,8 +150,8 @@ pub enum VariableKind {\n }\n \n /// Create any deferred debug metadata nodes\n-pub fn finalize(cx: &CrateContext) {\n-    if cx.dbg_cx().is_none() {\n+pub fn finalize(cx: &CodegenCx) {\n+    if cx.dbg_cx.is_none() {\n         return;\n     }\n \n@@ -176,21 +176,21 @@ pub fn finalize(cx: &CrateContext) {\n         // Android has the same issue (#22398)\n         if cx.sess().target.target.options.is_like_osx ||\n            cx.sess().target.target.options.is_like_android {\n-            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+            llvm::LLVMRustAddModuleFlag(cx.llmod,\n                                         \"Dwarf Version\\0\".as_ptr() as *const _,\n                                         2)\n         }\n \n         // Indicate that we want CodeView debug information on MSVC\n         if cx.sess().target.target.options.is_like_msvc {\n-            llvm::LLVMRustAddModuleFlag(cx.llmod(),\n+            llvm::LLVMRustAddModuleFlag(cx.llmod,\n                                         \"CodeView\\0\".as_ptr() as *const _,\n                                         1)\n         }\n \n         // Prevent bitcode readers from deleting the debug info.\n         let ptr = \"Debug Info Version\\0\".as_ptr();\n-        llvm::LLVMRustAddModuleFlag(cx.llmod(), ptr as *const _,\n+        llvm::LLVMRustAddModuleFlag(cx.llmod, ptr as *const _,\n                                     llvm::LLVMRustDebugMetadataVersion());\n     };\n }\n@@ -201,7 +201,7 @@ pub fn finalize(cx: &CrateContext) {\n /// for debug info creation. The function may also return another variant of the\n /// FunctionDebugContext enum which indicates why no debuginfo should be created\n /// for the function.\n-pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                                instance: Instance<'tcx>,\n                                                sig: ty::FnSig<'tcx>,\n                                                llfn: ValueRef,\n@@ -210,7 +210,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n-    for attr in instance.def.attrs(cx.tcx()).iter() {\n+    for attr in instance.def.attrs(cx.tcx).iter() {\n         if attr.check_name(\"no_debug\") {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n@@ -235,15 +235,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n \n     // Find the enclosing function, in case this is a closure.\n-    let def_key = cx.tcx().def_key(def_id);\n+    let def_key = cx.tcx.def_key(def_id);\n     let mut name = def_key.disambiguated_data.data.to_string();\n \n-    let enclosing_fn_def_id = cx.tcx().closure_base_def_id(def_id);\n+    let enclosing_fn_def_id = cx.tcx.closure_base_def_id(def_id);\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let generics = cx.tcx().generics_of(enclosing_fn_def_id);\n-    let substs = instance.substs.truncate_to(cx.tcx(), generics);\n+    let generics = cx.tcx.generics_of(enclosing_fn_def_id);\n+    let substs = instance.substs.truncate_to(cx.tcx, generics);\n     let template_parameters = get_template_parameters(cx,\n                                                       &generics,\n                                                       substs,\n@@ -255,7 +255,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let scope_line = span_start(cx, span).line;\n \n-    let local_id = cx.tcx().hir.as_local_node_id(instance.def_id());\n+    let local_id = cx.tcx.hir.as_local_node_id(instance.def_id());\n     let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n \n     let function_name = CString::new(name).unwrap();\n@@ -299,7 +299,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     return FunctionDebugContext::RegularContext(fn_debug_context);\n \n-    fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+    fn get_function_signature<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                         sig: ty::FnSig<'tcx>) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), &[]);\n@@ -334,8 +334,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.extend(inputs.iter().map(|&t| {\n                 let t = match t.sty {\n                     ty::TyArray(ct, _)\n-                        if (ct == cx.tcx().types.u8) || cx.layout_of(ct).is_zst() => {\n-                        cx.tcx().mk_imm_ptr(ct)\n+                        if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n+                        cx.tcx.mk_imm_ptr(ct)\n                     }\n                     _ => t\n                 };\n@@ -358,7 +358,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &signature[..]);\n     }\n \n-    fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+    fn get_template_parameters<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                          generics: &ty::Generics,\n                                          substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n@@ -375,7 +375,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n-            let actual_type = cx.tcx().fully_normalize_associated_types_in(&actual_type);\n+            let actual_type = cx.tcx.fully_normalize_associated_types_in(&actual_type);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n@@ -388,7 +388,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n             let names = get_type_parameter_names(cx, generics);\n             substs.types().zip(names).map(|(ty, name)| {\n-                let actual_type = cx.tcx().fully_normalize_associated_types_in(&ty);\n+                let actual_type = cx.tcx.fully_normalize_associated_types_in(&ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {\n@@ -409,24 +409,24 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n \n-    fn get_type_parameter_names(cx: &CrateContext, generics: &ty::Generics) -> Vec<ast::Name> {\n+    fn get_type_parameter_names(cx: &CodegenCx, generics: &ty::Generics) -> Vec<ast::Name> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_type_parameter_names(cx, cx.tcx().generics_of(def_id))\n+            get_type_parameter_names(cx, cx.tcx.generics_of(def_id))\n         });\n         names.extend(generics.types.iter().map(|param| param.name));\n         names\n     }\n \n-    fn get_containing_scope<'ccx, 'tcx>(cx: &CrateContext<'ccx, 'tcx>,\n+    fn get_containing_scope<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n                                         instance: Instance<'tcx>)\n                                         -> DIScope {\n         // First, let's see if this is a method within an inherent impl. Because\n         // if yes, we want to make the result subroutine DIE a child of the\n         // subroutine's self-type.\n-        let self_type = cx.tcx().impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n+        let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n-            if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx().trans_impl_self_ty(impl_def_id, instance.substs);\n+            if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n+                let impl_self_ty = cx.tcx.trans_impl_self_ty(impl_def_id, instance.substs);\n \n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`).\n@@ -446,7 +446,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         self_type.unwrap_or_else(|| {\n             namespace::item_namespace(cx, DefId {\n                 krate: instance.def_id().krate,\n-                index: cx.tcx()\n+                index: cx.tcx\n                          .def_key(instance.def_id())\n                          .parent\n                          .expect(\"get_containing_scope: missing parent?\")\n@@ -455,15 +455,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+pub fn declare_local<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                                dbg_context: &FunctionDebugContext,\n                                variable_name: ast::Name,\n                                variable_type: Ty<'tcx>,\n                                scope_metadata: DIScope,\n                                variable_access: VariableAccess,\n                                variable_kind: VariableKind,\n                                span: Span) {\n-    let cx = bcx.ccx;\n+    let cx = bx.cx;\n \n     let file = span_start(cx, span).file;\n     let file_metadata = file_metadata(cx,\n@@ -499,28 +499,28 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     align.abi() as u32,\n                 )\n             };\n-            source_loc::set_debug_location(bcx,\n+            source_loc::set_debug_location(bx,\n                 InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n             unsafe {\n-                let debug_loc = llvm::LLVMGetCurrentDebugLocation(bcx.llbuilder);\n+                let debug_loc = llvm::LLVMGetCurrentDebugLocation(bx.llbuilder);\n                 let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n                     DIB(cx),\n                     alloca,\n                     metadata,\n                     address_operations.as_ptr(),\n                     address_operations.len() as c_uint,\n                     debug_loc,\n-                    bcx.llbb());\n+                    bx.llbb());\n \n-                llvm::LLVMSetInstDebugLocation(bcx.llbuilder, instr);\n+                llvm::LLVMSetInstDebugLocation(bx.llbuilder, instr);\n             }\n         }\n     }\n \n     match variable_kind {\n         ArgumentVariable(_) | CapturedVariable => {\n             assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n-            source_loc::set_debug_location(bcx, UnknownLocation);\n+            source_loc::set_debug_location(bx, UnknownLocation);\n         }\n         _ => { /* nothing to do */ }\n     }"}, {"sha": "46067a4330396e384b9d25871ef2270f7d459ad0", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -20,58 +20,58 @@ use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use common::CrateContext;\n+use common::CodegenCx;\n \n use std::ffi::CString;\n use std::ptr;\n \n pub fn mangled_name_of_instance<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     instance: Instance<'tcx>,\n ) -> ty::SymbolName {\n-     let tcx = ccx.tcx();\n+     let tcx = cx.tcx;\n      tcx.symbol_name(instance)\n }\n \n pub fn mangled_name_of_item<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     node_id: ast::NodeId,\n ) -> ty::SymbolName {\n-    let tcx = ccx.tcx();\n+    let tcx = cx.tcx;\n     let node_def_id = tcx.hir.local_def_id(node_id);\n     let instance = Instance::mono(tcx, node_def_id);\n     tcx.symbol_name(instance)\n }\n \n-pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n-    if let Some(&scope) = debug_context(ccx).namespace_map.borrow().get(&def_id) {\n+pub fn item_namespace(cx: &CodegenCx, def_id: DefId) -> DIScope {\n+    if let Some(&scope) = debug_context(cx).namespace_map.borrow().get(&def_id) {\n         return scope;\n     }\n \n-    let def_key = ccx.tcx().def_key(def_id);\n+    let def_key = cx.tcx.def_key(def_id);\n     let parent_scope = def_key.parent.map_or(ptr::null_mut(), |parent| {\n-        item_namespace(ccx, DefId {\n+        item_namespace(cx, DefId {\n             krate: def_id.krate,\n             index: parent\n         })\n     });\n \n     let namespace_name = match def_key.disambiguated_data.data {\n-        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate).as_str(),\n+        DefPathData::CrateRoot => cx.tcx.crate_name(def_id.krate).as_str(),\n         data => data.as_interned_str()\n     };\n \n     let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n \n     let scope = unsafe {\n         llvm::LLVMRustDIBuilderCreateNameSpace(\n-            DIB(ccx),\n+            DIB(cx),\n             parent_scope,\n             namespace_name.as_ptr(),\n-            unknown_file_metadata(ccx),\n+            unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER)\n     };\n \n-    debug_context(ccx).namespace_map.borrow_mut().insert(def_id, scope);\n+    debug_context(cx).namespace_map.borrow_mut().insert(def_id, scope);\n     scope\n }"}, {"sha": "7440296ce5d7bae7c8323d1cf47fa08e543e3b6c", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -26,25 +26,25 @@ use syntax_pos::{Span, Pos};\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n pub fn set_source_location(\n-    debug_context: &FunctionDebugContext, builder: &Builder, scope: DIScope, span: Span\n+    debug_context: &FunctionDebugContext, bx: &Builder, scope: DIScope, span: Span\n ) {\n     let function_debug_context = match *debug_context {\n         FunctionDebugContext::DebugInfoDisabled => return,\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(builder, UnknownLocation);\n+            set_debug_location(bx, UnknownLocation);\n             return;\n         }\n         FunctionDebugContext::RegularContext(ref data) => data\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", builder.sess().codemap().span_to_string(span));\n-        let loc = span_start(builder.ccx, span);\n+        debug!(\"set_source_location: {}\", bx.sess().codemap().span_to_string(span));\n+        let loc = span_start(bx.cx, span);\n         InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n     };\n-    set_debug_location(builder, dbg_loc);\n+    set_debug_location(bx, dbg_loc);\n }\n \n /// Enables emitting source locations for the given functions.\n@@ -79,7 +79,7 @@ impl InternalDebugLocation {\n     }\n }\n \n-pub fn set_debug_location(builder: &Builder, debug_location: InternalDebugLocation) {\n+pub fn set_debug_location(bx: &Builder, debug_location: InternalDebugLocation) {\n     let metadata_node = match debug_location {\n         KnownLocation { scope, line, .. } => {\n             // Always set the column to zero like Clang and GCC\n@@ -88,7 +88,7 @@ pub fn set_debug_location(builder: &Builder, debug_location: InternalDebugLocati\n \n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                    debug_context(builder.ccx).llcontext,\n+                    debug_context(bx.cx).llcontext,\n                     line as c_uint,\n                     col as c_uint,\n                     scope,\n@@ -102,6 +102,6 @@ pub fn set_debug_location(builder: &Builder, debug_location: InternalDebugLocati\n     };\n \n     unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(builder.llbuilder, metadata_node);\n+        llvm::LLVMSetCurrentDebugLocation(bx.llbuilder, metadata_node);\n     }\n }"}, {"sha": "0aec92b0d66cf3b4c6b4ffbc2879056f4c9be818", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -10,7 +10,7 @@\n \n // Type Names for Debug Info.\n \n-use common::CrateContext;\n+use common::CodegenCx;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n@@ -21,7 +21,7 @@ use rustc::hir;\n // any caching, i.e. calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e. type parameters) are always fully qualified.\n-pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                              t: Ty<'tcx>,\n                                              qualified: bool)\n                                              -> String {\n@@ -32,7 +32,7 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n-pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                           t: Ty<'tcx>,\n                                           qualified: bool,\n                                           output: &mut String) {\n@@ -117,14 +117,14 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         ty::TyDynamic(ref trait_data, ..) => {\n             if let Some(principal) = trait_data.principal() {\n-                let principal = cx.tcx().erase_late_bound_regions_and_normalize(\n+                let principal = cx.tcx.erase_late_bound_regions_and_normalize(\n                     &principal);\n                 push_item_name(cx, principal.def_id, false, output);\n                 push_type_params(cx, principal.substs, output);\n             }\n         },\n         ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-            let sig = t.fn_sig(cx.tcx());\n+            let sig = t.fn_sig(cx.tcx);\n             if sig.unsafety() == hir::Unsafety::Unsafe {\n                 output.push_str(\"unsafe \");\n             }\n@@ -138,7 +138,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            let sig = cx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+            let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n@@ -179,18 +179,18 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    fn push_item_name(cx: &CrateContext,\n+    fn push_item_name(cx: &CodegenCx,\n                       def_id: DefId,\n                       qualified: bool,\n                       output: &mut String) {\n         if qualified {\n-            output.push_str(&cx.tcx().crate_name(def_id.krate).as_str());\n-            for path_element in cx.tcx().def_path(def_id).data {\n+            output.push_str(&cx.tcx.crate_name(def_id.krate).as_str());\n+            for path_element in cx.tcx.def_path(def_id).data {\n                 output.push_str(\"::\");\n                 output.push_str(&path_element.data.as_interned_str());\n             }\n         } else {\n-            output.push_str(&cx.tcx().item_name(def_id));\n+            output.push_str(&cx.tcx.item_name(def_id));\n         }\n     }\n \n@@ -199,7 +199,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // reconstructed for items from non-local crates. For local crates, this\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n-    fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+    fn push_type_params<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                   substs: &Substs<'tcx>,\n                                   output: &mut String) {\n         if substs.types().next().is_none() {"}, {"sha": "c571b84b8e9edd64c8268f5ec9f6be5490c3343f", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -18,12 +18,12 @@ use rustc::ty::DefIdTree;\n \n use llvm;\n use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n-use common::{CrateContext};\n+use common::{CodegenCx};\n \n use syntax_pos::{self, Span};\n use syntax::ast;\n \n-pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n+pub fn is_node_local_to_unit(cx: &CodegenCx, node_id: ast::NodeId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n     // current compilation unit (i.e. if it is *static* in the C-sense). The\n@@ -33,8 +33,8 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    let def_id = cx.tcx().hir.local_def_id(node_id);\n-    !cx.tcx().is_exported_symbol(def_id)\n+    let def_id = cx.tcx.hir.local_def_id(node_id);\n+    !cx.tcx.is_exported_symbol(def_id)\n }\n \n #[allow(non_snake_case)]\n@@ -45,23 +45,23 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n }\n \n /// Return syntax_pos::Loc corresponding to the beginning of the span\n-pub fn span_start(cx: &CrateContext, span: Span) -> syntax_pos::Loc {\n+pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n     cx.sess().codemap().lookup_char_pos(span.lo())\n }\n \n #[inline]\n-pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n+pub fn debug_context<'a, 'tcx>(cx: &'a CodegenCx<'a, 'tcx>)\n                            -> &'a CrateDebugContext<'tcx> {\n-    cx.dbg_cx().as_ref().unwrap()\n+    cx.dbg_cx.as_ref().unwrap()\n }\n \n #[inline]\n #[allow(non_snake_case)]\n-pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx().as_ref().unwrap().builder\n+pub fn DIB(cx: &CodegenCx) -> DIBuilderRef {\n+    cx.dbg_cx.as_ref().unwrap().builder\n }\n \n-pub fn get_namespace_for_item(cx: &CrateContext, def_id: DefId) -> DIScope {\n-    item_namespace(cx, cx.tcx().parent(def_id)\n+pub fn get_namespace_for_item(cx: &CodegenCx, def_id: DefId) -> DIScope {\n+    item_namespace(cx, cx.tcx.parent(def_id)\n         .expect(\"get_namespace_for_item: missing parent?\"))\n }"}, {"sha": "aa1cd0c27e795977287702ed50890a6ccff4122c", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -27,7 +27,7 @@ use rustc::session::config::Sanitizer;\n use rustc_back::PanicStrategy;\n use abi::{Abi, FnType};\n use attributes;\n-use context::CrateContext;\n+use context::CodegenCx;\n use common;\n use type_::Type;\n use value::Value;\n@@ -39,13 +39,13 @@ use std::ffi::CString;\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// return its ValueRef instead.\n-pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRef {\n+pub fn declare_global(cx: &CodegenCx, name: &str, ty: Type) -> llvm::ValueRef {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     unsafe {\n-        llvm::LLVMRustGetOrInsertGlobal(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty.to_ref())\n     }\n }\n \n@@ -54,26 +54,26 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n+fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let llfn = unsafe {\n-        llvm::LLVMRustGetOrInsertFunction(ccx.llmod(), namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertFunction(cx.llmod, namebuf.as_ptr(), ty.to_ref())\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n     // Function addresses in Rust are never significant, allowing functions to\n     // be merged.\n     llvm::SetUnnamedAddr(llfn, true);\n \n-    if ccx.tcx().sess.opts.cg.no_redzone\n-        .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n+    if cx.tcx.sess.opts.cg.no_redzone\n+        .unwrap_or(cx.tcx.sess.target.target.options.disable_redzone) {\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n \n-    if let Some(ref sanitizer) = ccx.tcx().sess.opts.debugging_opts.sanitizer {\n+    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {\n         match *sanitizer {\n             Sanitizer::Address => {\n                 llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n@@ -88,7 +88,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         }\n     }\n \n-    match ccx.tcx().sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n+    match cx.tcx.sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n         Some(\"s\") => {\n             llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);\n         },\n@@ -99,7 +99,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         _ => {},\n     }\n \n-    if ccx.tcx().sess.panic_strategy() != PanicStrategy::Unwind {\n+    if cx.tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n         attributes::unwind(llfn, false);\n     }\n \n@@ -114,24 +114,24 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n-    declare_raw_fn(ccx, name, llvm::CCallConv, fn_type)\n+pub fn declare_cfn(cx: &CodegenCx, name: &str, fn_type: Type) -> ValueRef {\n+    declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n }\n \n \n /// Declare a Rust function.\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n+pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n                             fn_type: Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n-    let sig = common::ty_fn_sig(ccx, fn_type);\n-    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+    let sig = common::ty_fn_sig(cx, fn_type);\n+    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-    let fty = FnType::new(ccx, sig, &[]);\n-    let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n+    let fty = FnType::new(cx, sig, &[]);\n+    let llfn = declare_raw_fn(cx, name, fty.cconv, fty.llvm_type(cx));\n \n     // FIXME(canndrew): This is_never should really be an is_uninhabited\n     if sig.output().is_never() {\n@@ -154,11 +154,11 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n /// return None if the name already has a definition associated with it. In that\n /// case an error should be reported to the user, because it usually happens due\n /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRef> {\n-    if get_defined_value(ccx, name).is_some() {\n+pub fn define_global(cx: &CodegenCx, name: &str, ty: Type) -> Option<ValueRef> {\n+    if get_defined_value(cx, name).is_some() {\n         None\n     } else {\n-        Some(declare_global(ccx, name, ty))\n+        Some(declare_global(cx, name, ty))\n     }\n }\n \n@@ -167,13 +167,13 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn define_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                            name: &str,\n                            fn_type: Ty<'tcx>) -> ValueRef {\n-    if get_defined_value(ccx, name).is_some() {\n-        ccx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n+    if get_defined_value(cx, name).is_some() {\n+        cx.sess().fatal(&format!(\"symbol `{}` already defined\", name))\n     } else {\n-        declare_fn(ccx, name, fn_type)\n+        declare_fn(cx, name, fn_type)\n     }\n }\n \n@@ -182,22 +182,22 @@ pub fn define_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n /// Use this function when you intend to define a function. This function will\n /// return panic if the name already has a definition associated with it. This\n /// can happen with #[no_mangle] or #[export_name], for example.\n-pub fn define_internal_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn define_internal_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                     name: &str,\n                                     fn_type: Ty<'tcx>) -> ValueRef {\n-    let llfn = define_fn(ccx, name, fn_type);\n+    let llfn = define_fn(cx, name, fn_type);\n     unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n     llfn\n }\n \n \n /// Get declared value by name.\n-pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+pub fn get_declared_value(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n     debug!(\"get_declared_value(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n-    let val = unsafe { llvm::LLVMRustGetNamedValue(ccx.llmod(), namebuf.as_ptr()) };\n+    let val = unsafe { llvm::LLVMRustGetNamedValue(cx.llmod, namebuf.as_ptr()) };\n     if val.is_null() {\n         debug!(\"get_declared_value: {:?} value is null\", name);\n         None\n@@ -209,8 +209,8 @@ pub fn get_declared_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n \n /// Get defined or externally defined (AvailableExternally linkage) value by\n /// name.\n-pub fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n-    get_declared_value(ccx, name).and_then(|val|{\n+pub fn get_defined_value(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n+    get_declared_value(cx, name).and_then(|val|{\n         let declaration = unsafe {\n             llvm::LLVMIsDeclaration(val) != 0\n         };"}, {"sha": "c7275d094018567f7221192ea2cec1c20ecaf7a7", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -23,53 +23,53 @@ use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n use value::Value;\n \n-pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+pub fn size_and_align_of_dst<'a, 'tcx>(bx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n-    if bcx.ccx.shared().type_is_sized(t) {\n-        let (size, align) = bcx.ccx.size_and_align_of(t);\n+    if bx.cx.type_is_sized(t) {\n+        let (size, align) = bx.cx.size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, Value(info), size, align);\n-        let size = C_usize(bcx.ccx, size.bytes());\n-        let align = C_usize(bcx.ccx, align.abi());\n+        let size = C_usize(bx.cx, size.bytes());\n+        let align = C_usize(bx.cx, align.abi());\n         return (size, align);\n     }\n     assert!(!info.is_null());\n     match t.sty {\n         ty::TyDynamic(..) => {\n             // load size/align from vtable\n-            (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n+            (meth::SIZE.get_usize(bx, info), meth::ALIGN.get_usize(bx, info))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit = t.sequence_element_type(bcx.tcx());\n+            let unit = t.sequence_element_type(bx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let (size, align) = bcx.ccx.size_and_align_of(unit);\n-            (bcx.mul(info, C_usize(bcx.ccx, size.bytes())),\n-             C_usize(bcx.ccx, align.abi()))\n+            let (size, align) = bx.cx.size_and_align_of(unit);\n+            (bx.mul(info, C_usize(bx.cx, size.bytes())),\n+             C_usize(bx.cx, align.abi()))\n         }\n         _ => {\n-            let ccx = bcx.ccx;\n+            let cx = bx.cx;\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n             // want to avoid, as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n-            let layout = ccx.layout_of(t);\n+            let layout = cx.layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n \n             let i = layout.fields.count() - 1;\n             let sized_size = layout.fields.offset(i).bytes();\n             let sized_align = layout.align.abi();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n-            let sized_size = C_usize(ccx, sized_size);\n-            let sized_align = C_usize(ccx, sized_align);\n+            let sized_size = C_usize(cx, sized_size);\n+            let sized_align = C_usize(cx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let field_ty = layout.field(ccx, i).ty;\n-            let (unsized_size, mut unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n+            let field_ty = layout.field(cx, i).ty;\n+            let (unsized_size, mut unsized_align) = size_and_align_of_dst(bx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n             // to `sized_size` (to accommodate the `unsized_align`\n@@ -79,7 +79,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             // here. But this is where the add would go.)\n \n             // Return the sum of sizes and max of aligns.\n-            let size = bcx.add(sized_size, unsized_size);\n+            let size = bx.add(sized_size, unsized_size);\n \n             // Packed types ignore the alignment of their fields.\n             if let ty::TyAdt(def, _) = t.sty {\n@@ -95,9 +95,9 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_usize(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n+                    C_usize(cx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n-                _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n+                _ => bx.select(bx.icmp(llvm::IntUGT, sized_align, unsized_align),\n                                 sized_align,\n                                 unsized_align)\n             };\n@@ -113,8 +113,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bcx.sub(align, C_usize(bcx.ccx, 1));\n-            let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n+            let addend = bx.sub(align, C_usize(bx.cx, 1));\n+            let size = bx.and(bx.add(size, addend), bx.neg(align));\n \n             (size, align)\n         }"}, {"sha": "b1f1fb52c907d099c6a5d75b69344ee5e57a5248", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 254, "deletions": 254, "changes": 508, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -35,7 +35,7 @@ use syntax_pos::Span;\n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n+fn get_simple_intrinsic(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n     let llvm_name = match name {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n@@ -79,20 +79,20 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n         \"abort\" => \"llvm.trap\",\n         _ => return None\n     };\n-    Some(ccx.get_intrinsic(&llvm_name))\n+    Some(cx.get_intrinsic(&llvm_name))\n }\n \n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs\n-pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                                       callee_ty: Ty<'tcx>,\n                                       fn_ty: &FnType<'tcx>,\n                                       args: &[OperandRef<'tcx>],\n                                       llresult: ValueRef,\n                                       span: Span) {\n-    let ccx = bcx.ccx;\n-    let tcx = ccx.tcx();\n+    let cx = bx.cx;\n+    let tcx = cx.tcx;\n \n     let (def_id, substs) = match callee_ty.sty {\n         ty::TyFnDef(def_id, substs) => (def_id, substs),\n@@ -105,87 +105,87 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let ret_ty = sig.output();\n     let name = &*tcx.item_name(def_id);\n \n-    let llret_ty = ccx.layout_of(ret_ty).llvm_type(ccx);\n+    let llret_ty = cx.layout_of(ret_ty).llvm_type(cx);\n     let result = PlaceRef::new_sized(llresult, fn_ty.ret.layout, fn_ty.ret.layout.align);\n \n-    let simple = get_simple_intrinsic(ccx, name);\n+    let simple = get_simple_intrinsic(cx, name);\n     let llval = match name {\n         _ if simple.is_some() => {\n-            bcx.call(simple.unwrap(),\n+            bx.call(simple.unwrap(),\n                      &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                      None)\n         }\n         \"unreachable\" => {\n             return;\n         },\n         \"likely\" => {\n-            let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[args[0].immediate(), C_bool(ccx, true)], None)\n+            let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n+            bx.call(expect, &[args[0].immediate(), C_bool(cx, true)], None)\n         }\n         \"unlikely\" => {\n-            let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bcx.call(expect, &[args[0].immediate(), C_bool(ccx, false)], None)\n+            let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n+            bx.call(expect, &[args[0].immediate(), C_bool(cx, false)], None)\n         }\n         \"try\" => {\n-            try_intrinsic(bcx, ccx,\n+            try_intrinsic(bx, cx,\n                           args[0].immediate(),\n                           args[1].immediate(),\n                           args[2].immediate(),\n                           llresult);\n             return;\n         }\n         \"breakpoint\" => {\n-            let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            bcx.call(llfn, &[], None)\n+            let llfn = cx.get_intrinsic(&(\"llvm.debugtrap\"));\n+            bx.call(llfn, &[], None)\n         }\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(ccx, ccx.size_of(tp_ty).bytes())\n+            C_usize(cx, cx.size_of(tp_ty).bytes())\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n             if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (llsize, _) =\n-                    glue::size_and_align_of_dst(bcx, tp_ty, meta);\n+                    glue::size_and_align_of_dst(bx, tp_ty, meta);\n                 llsize\n             } else {\n-                C_usize(ccx, ccx.size_of(tp_ty).bytes())\n+                C_usize(cx, cx.size_of(tp_ty).bytes())\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(ccx, ccx.align_of(tp_ty).abi())\n+            C_usize(cx, cx.align_of(tp_ty).abi())\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n             if let OperandValue::Pair(_, meta) = args[0].val {\n                 let (_, llalign) =\n-                    glue::size_and_align_of_dst(bcx, tp_ty, meta);\n+                    glue::size_and_align_of_dst(bx, tp_ty, meta);\n                 llalign\n             } else {\n-                C_usize(ccx, ccx.align_of(tp_ty).abi())\n+                C_usize(cx, cx.align_of(tp_ty).abi())\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(ccx, ccx.align_of(tp_ty).pref())\n+            C_usize(cx, cx.align_of(tp_ty).pref())\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n             let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n-            C_str_slice(ccx, ty_name)\n+            C_str_slice(cx, ty_name)\n         }\n         \"type_id\" => {\n-            C_u64(ccx, ccx.tcx().type_id_hash(substs.type_at(0)))\n+            C_u64(cx, cx.tcx.type_id_hash(substs.type_at(0)))\n         }\n         \"init\" => {\n             let ty = substs.type_at(0);\n-            if !ccx.layout_of(ty).is_zst() {\n+            if !cx.layout_of(ty).is_zst() {\n                 // Just zero out the stack slot.\n                 // If we store a zero constant, LLVM will drown in vreg allocation for large data\n                 // structures, and the generated code will be awful. (A telltale sign of this is\n                 // large quantities of `mov [byte ptr foo],0` in the generated code.)\n-                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_usize(ccx, 1));\n+                memset_intrinsic(bx, false, ty, llresult, C_u8(cx, 0), C_usize(cx, 1));\n             }\n             return;\n         }\n@@ -196,167 +196,167 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            C_bool(ccx, bcx.ccx.shared().type_needs_drop(tp_ty))\n+            C_bool(cx, bx.cx.type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = args[0].immediate();\n             let offset = args[1].immediate();\n-            bcx.inbounds_gep(ptr, &[offset])\n+            bx.inbounds_gep(ptr, &[offset])\n         }\n         \"arith_offset\" => {\n             let ptr = args[0].immediate();\n             let offset = args[1].immediate();\n-            bcx.gep(ptr, &[offset])\n+            bx.gep(ptr, &[offset])\n         }\n \n         \"copy_nonoverlapping\" => {\n-            copy_intrinsic(bcx, false, false, substs.type_at(0),\n+            copy_intrinsic(bx, false, false, substs.type_at(0),\n                            args[1].immediate(), args[0].immediate(), args[2].immediate())\n         }\n         \"copy\" => {\n-            copy_intrinsic(bcx, true, false, substs.type_at(0),\n+            copy_intrinsic(bx, true, false, substs.type_at(0),\n                            args[1].immediate(), args[0].immediate(), args[2].immediate())\n         }\n         \"write_bytes\" => {\n-            memset_intrinsic(bcx, false, substs.type_at(0),\n+            memset_intrinsic(bx, false, substs.type_at(0),\n                              args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n \n         \"volatile_copy_nonoverlapping_memory\" => {\n-            copy_intrinsic(bcx, false, true, substs.type_at(0),\n+            copy_intrinsic(bx, false, true, substs.type_at(0),\n                            args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_copy_memory\" => {\n-            copy_intrinsic(bcx, true, true, substs.type_at(0),\n+            copy_intrinsic(bx, true, true, substs.type_at(0),\n                            args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_set_memory\" => {\n-            memset_intrinsic(bcx, true, substs.type_at(0),\n+            memset_intrinsic(bx, true, substs.type_at(0),\n                              args[0].immediate(), args[1].immediate(), args[2].immediate())\n         }\n         \"volatile_load\" => {\n             let tp_ty = substs.type_at(0);\n             let mut ptr = args[0].immediate();\n             if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-                ptr = bcx.pointercast(ptr, ty.llvm_type(ccx).ptr_to());\n+                ptr = bx.pointercast(ptr, ty.llvm_type(cx).ptr_to());\n             }\n-            let load = bcx.volatile_load(ptr);\n+            let load = bx.volatile_load(ptr);\n             unsafe {\n-                llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty).abi() as u32);\n+                llvm::LLVMSetAlignment(load, cx.align_of(tp_ty).abi() as u32);\n             }\n-            to_immediate(bcx, load, ccx.layout_of(tp_ty))\n+            to_immediate(bx, load, cx.layout_of(tp_ty))\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n-            let dst = args[0].deref(bcx.ccx);\n+            let dst = args[0].deref(bx.cx);\n             if let OperandValue::Pair(a, b) = args[1].val {\n-                bcx.volatile_store(a, dst.project_field(bcx, 0).llval);\n-                bcx.volatile_store(b, dst.project_field(bcx, 1).llval);\n+                bx.volatile_store(a, dst.project_field(bx, 0).llval);\n+                bx.volatile_store(b, dst.project_field(bx, 1).llval);\n             } else {\n                 let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                    bcx.load(ptr, align)\n+                    bx.load(ptr, align)\n                 } else {\n                     if dst.layout.is_zst() {\n                         return;\n                     }\n-                    from_immediate(bcx, args[1].immediate())\n+                    from_immediate(bx, args[1].immediate())\n                 };\n-                let ptr = bcx.pointercast(dst.llval, val_ty(val).ptr_to());\n-                let store = bcx.volatile_store(val, ptr);\n+                let ptr = bx.pointercast(dst.llval, val_ty(val).ptr_to());\n+                let store = bx.volatile_store(val, ptr);\n                 unsafe {\n-                    llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty).abi() as u32);\n+                    llvm::LLVMSetAlignment(store, cx.align_of(tp_ty).abi() as u32);\n                 }\n             }\n             return;\n         },\n         \"prefetch_read_data\" | \"prefetch_write_data\" |\n         \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n-            let expect = ccx.get_intrinsic(&(\"llvm.prefetch\"));\n+            let expect = cx.get_intrinsic(&(\"llvm.prefetch\"));\n             let (rw, cache_type) = match name {\n                 \"prefetch_read_data\" => (0, 1),\n                 \"prefetch_write_data\" => (1, 1),\n                 \"prefetch_read_instruction\" => (0, 0),\n                 \"prefetch_write_instruction\" => (1, 0),\n                 _ => bug!()\n             };\n-            bcx.call(expect, &[\n+            bx.call(expect, &[\n                 args[0].immediate(),\n-                C_i32(ccx, rw),\n+                C_i32(cx, rw),\n                 args[1].immediate(),\n-                C_i32(ccx, cache_type)\n+                C_i32(cx, cache_type)\n             ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n         \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n             let ty = arg_tys[0];\n-            match int_type_width_signed(ty, ccx) {\n+            match int_type_width_signed(ty, cx) {\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n-                            let y = C_bool(bcx.ccx, false);\n-                            let llfn = ccx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n-                            bcx.call(llfn, &[args[0].immediate(), y], None)\n+                            let y = C_bool(bx.cx, false);\n+                            let llfn = cx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n+                            bx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n-                            let y = C_bool(bcx.ccx, true);\n+                            let y = C_bool(bx.cx, true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n-                            let llfn = ccx.get_intrinsic(llvm_name);\n-                            bcx.call(llfn, &[args[0].immediate(), y], None)\n+                            let llfn = cx.get_intrinsic(llvm_name);\n+                            bx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n-                        \"ctpop\" => bcx.call(ccx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n+                        \"ctpop\" => bx.call(cx.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n                                         &[args[0].immediate()], None),\n                         \"bswap\" => {\n                             if width == 8 {\n                                 args[0].immediate() // byte swap a u8/i8 is just a no-op\n                             } else {\n-                                bcx.call(ccx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n+                                bx.call(cx.get_intrinsic(&format!(\"llvm.bswap.i{}\", width)),\n                                         &[args[0].immediate()], None)\n                             }\n                         }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n                             let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n                                                     if signed { 's' } else { 'u' },\n                                                     &name[..3], width);\n-                            let llfn = bcx.ccx.get_intrinsic(&intrinsic);\n+                            let llfn = bx.cx.get_intrinsic(&intrinsic);\n \n                             // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let pair = bcx.call(llfn, &[\n+                            let pair = bx.call(llfn, &[\n                                 args[0].immediate(),\n                                 args[1].immediate()\n                             ], None);\n-                            let val = bcx.extract_value(pair, 0);\n-                            let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(ccx));\n+                            let val = bx.extract_value(pair, 0);\n+                            let overflow = bx.zext(bx.extract_value(pair, 1), Type::bool(cx));\n \n-                            let dest = result.project_field(bcx, 0);\n-                            bcx.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(bcx, 1);\n-                            bcx.store(overflow, dest.llval, dest.align);\n+                            let dest = result.project_field(bx, 0);\n+                            bx.store(val, dest.llval, dest.align);\n+                            let dest = result.project_field(bx, 1);\n+                            bx.store(overflow, dest.llval, dest.align);\n \n                             return;\n                         },\n-                        \"overflowing_add\" => bcx.add(args[0].immediate(), args[1].immediate()),\n-                        \"overflowing_sub\" => bcx.sub(args[0].immediate(), args[1].immediate()),\n-                        \"overflowing_mul\" => bcx.mul(args[0].immediate(), args[1].immediate()),\n+                        \"overflowing_add\" => bx.add(args[0].immediate(), args[1].immediate()),\n+                        \"overflowing_sub\" => bx.sub(args[0].immediate(), args[1].immediate()),\n+                        \"overflowing_mul\" => bx.mul(args[0].immediate(), args[1].immediate()),\n                         \"unchecked_div\" =>\n                             if signed {\n-                                bcx.sdiv(args[0].immediate(), args[1].immediate())\n+                                bx.sdiv(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.udiv(args[0].immediate(), args[1].immediate())\n+                                bx.udiv(args[0].immediate(), args[1].immediate())\n                             },\n                         \"unchecked_rem\" =>\n                             if signed {\n-                                bcx.srem(args[0].immediate(), args[1].immediate())\n+                                bx.srem(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.urem(args[0].immediate(), args[1].immediate())\n+                                bx.urem(args[0].immediate(), args[1].immediate())\n                             },\n-                        \"unchecked_shl\" => bcx.shl(args[0].immediate(), args[1].immediate()),\n+                        \"unchecked_shl\" => bx.shl(args[0].immediate(), args[1].immediate()),\n                         \"unchecked_shr\" =>\n                             if signed {\n-                                bcx.ashr(args[0].immediate(), args[1].immediate())\n+                                bx.ashr(args[0].immediate(), args[1].immediate())\n                             } else {\n-                                bcx.lshr(args[0].immediate(), args[1].immediate())\n+                                bx.lshr(args[0].immediate(), args[1].immediate())\n                             },\n                         _ => bug!(),\n                     },\n@@ -375,11 +375,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             match float_type_width(sty) {\n                 Some(_width) =>\n                     match name {\n-                        \"fadd_fast\" => bcx.fadd_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fsub_fast\" => bcx.fsub_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fmul_fast\" => bcx.fmul_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fdiv_fast\" => bcx.fdiv_fast(args[0].immediate(), args[1].immediate()),\n-                        \"frem_fast\" => bcx.frem_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fadd_fast\" => bx.fadd_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fsub_fast\" => bx.fsub_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fmul_fast\" => bx.fmul_fast(args[0].immediate(), args[1].immediate()),\n+                        \"fdiv_fast\" => bx.fdiv_fast(args[0].immediate(), args[1].immediate()),\n+                        \"frem_fast\" => bx.frem_fast(args[0].immediate(), args[1].immediate()),\n                         _ => bug!(),\n                     },\n                 None => {\n@@ -394,23 +394,23 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         },\n \n         \"discriminant_value\" => {\n-            args[0].deref(bcx.ccx).trans_get_discr(bcx, ret_ty)\n+            args[0].deref(bx.cx).trans_get_discr(bx, ret_ty)\n         }\n \n         \"align_offset\" => {\n             // `ptr as usize`\n-            let ptr_val = bcx.ptrtoint(args[0].immediate(), bcx.ccx.isize_ty());\n+            let ptr_val = bx.ptrtoint(args[0].immediate(), bx.cx.isize_ty);\n             // `ptr_val % align`\n             let align = args[1].immediate();\n-            let offset = bcx.urem(ptr_val, align);\n-            let zero = C_null(bcx.ccx.isize_ty());\n+            let offset = bx.urem(ptr_val, align);\n+            let zero = C_null(bx.cx.isize_ty);\n             // `offset == 0`\n-            let is_zero = bcx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n+            let is_zero = bx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n             // `if offset == 0 { 0 } else { align - offset }`\n-            bcx.select(is_zero, zero, bcx.sub(align, offset))\n+            bx.select(is_zero, zero, bx.sub(align, offset))\n         }\n         name if name.starts_with(\"simd_\") => {\n-            match generic_simd_intrinsic(bcx, name,\n+            match generic_simd_intrinsic(bx, name,\n                                          callee_ty,\n                                          args,\n                                          ret_ty, llret_ty,\n@@ -439,16 +439,16 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         (SequentiallyConsistent, Monotonic),\n                     \"failacq\" if is_cxchg =>\n                         (SequentiallyConsistent, Acquire),\n-                    _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n+                    _ => cx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 },\n                 4 => match (split[2], split[3]) {\n                     (\"acq\", \"failrelaxed\") if is_cxchg =>\n                         (Acquire, Monotonic),\n                     (\"acqrel\", \"failrelaxed\") if is_cxchg =>\n                         (AcquireRelease, Monotonic),\n-                    _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n+                    _ => cx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 },\n-                _ => ccx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n+                _ => cx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n             };\n \n             let invalid_monomorphization = |ty| {\n@@ -460,22 +460,22 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             match split[1] {\n                 \"cxchg\" | \"cxchgweak\" => {\n                     let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, ccx).is_some() {\n+                    if int_type_width_signed(ty, cx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n-                        let pair = bcx.atomic_cmpxchg(\n+                        let pair = bx.atomic_cmpxchg(\n                             args[0].immediate(),\n                             args[1].immediate(),\n                             args[2].immediate(),\n                             order,\n                             failorder,\n                             weak);\n-                        let val = bcx.extract_value(pair, 0);\n-                        let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.ccx));\n+                        let val = bx.extract_value(pair, 0);\n+                        let success = bx.zext(bx.extract_value(pair, 1), Type::bool(bx.cx));\n \n-                        let dest = result.project_field(bcx, 0);\n-                        bcx.store(val, dest.llval, dest.align);\n-                        let dest = result.project_field(bcx, 1);\n-                        bcx.store(success, dest.llval, dest.align);\n+                        let dest = result.project_field(bx, 0);\n+                        bx.store(val, dest.llval, dest.align);\n+                        let dest = result.project_field(bx, 1);\n+                        bx.store(success, dest.llval, dest.align);\n                         return;\n                     } else {\n                         return invalid_monomorphization(ty);\n@@ -484,32 +484,32 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n                 \"load\" => {\n                     let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, ccx).is_some() {\n-                        let align = ccx.align_of(ty);\n-                        bcx.atomic_load(args[0].immediate(), order, align)\n+                    if int_type_width_signed(ty, cx).is_some() {\n+                        let align = cx.align_of(ty);\n+                        bx.atomic_load(args[0].immediate(), order, align)\n                     } else {\n                         return invalid_monomorphization(ty);\n                     }\n                 }\n \n                 \"store\" => {\n                     let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, ccx).is_some() {\n-                        let align = ccx.align_of(ty);\n-                        bcx.atomic_store(args[1].immediate(), args[0].immediate(), order, align);\n+                    if int_type_width_signed(ty, cx).is_some() {\n+                        let align = cx.align_of(ty);\n+                        bx.atomic_store(args[1].immediate(), args[0].immediate(), order, align);\n                         return;\n                     } else {\n                         return invalid_monomorphization(ty);\n                     }\n                 }\n \n                 \"fence\" => {\n-                    bcx.atomic_fence(order, llvm::SynchronizationScope::CrossThread);\n+                    bx.atomic_fence(order, llvm::SynchronizationScope::CrossThread);\n                     return;\n                 }\n \n                 \"singlethreadfence\" => {\n-                    bcx.atomic_fence(order, llvm::SynchronizationScope::SingleThread);\n+                    bx.atomic_fence(order, llvm::SynchronizationScope::SingleThread);\n                     return;\n                 }\n \n@@ -527,12 +527,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         \"min\"   => llvm::AtomicMin,\n                         \"umax\"  => llvm::AtomicUMax,\n                         \"umin\"  => llvm::AtomicUMin,\n-                        _ => ccx.sess().fatal(\"unknown atomic operation\")\n+                        _ => cx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n                     let ty = substs.type_at(0);\n-                    if int_type_width_signed(ty, ccx).is_some() {\n-                        bcx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n+                    if int_type_width_signed(ty, cx).is_some() {\n+                        bx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n                     } else {\n                         return invalid_monomorphization(ty);\n                     }\n@@ -542,16 +542,16 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"nontemporal_store\" => {\n             let tp_ty = substs.type_at(0);\n-            let dst = args[0].deref(bcx.ccx);\n+            let dst = args[0].deref(bx.cx);\n             let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n-                bcx.load(ptr, align)\n+                bx.load(ptr, align)\n             } else {\n-                from_immediate(bcx, args[1].immediate())\n+                from_immediate(bx, args[1].immediate())\n             };\n-            let ptr = bcx.pointercast(dst.llval, val_ty(val).ptr_to());\n-            let store = bcx.nontemporal_store(val, ptr);\n+            let ptr = bx.pointercast(dst.llval, val_ty(val).ptr_to());\n+            let store = bx.nontemporal_store(val, ptr);\n             unsafe {\n-                llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty).abi() as u32);\n+                llvm::LLVMSetAlignment(store, cx.align_of(tp_ty).abi() as u32);\n             }\n             return\n         }\n@@ -565,39 +565,39 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n             }\n-            fn ty_to_type(ccx: &CrateContext, t: &intrinsics::Type) -> Vec<Type> {\n+            fn ty_to_type(cx: &CodegenCx, t: &intrinsics::Type) -> Vec<Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n-                    Void => vec![Type::void(ccx)],\n+                    Void => vec![Type::void(cx)],\n                     Integer(_signed, _width, llvm_width) => {\n-                        vec![Type::ix(ccx, llvm_width as u64)]\n+                        vec![Type::ix(cx, llvm_width as u64)]\n                     }\n                     Float(x) => {\n                         match x {\n-                            32 => vec![Type::f32(ccx)],\n-                            64 => vec![Type::f64(ccx)],\n+                            32 => vec![Type::f32(cx)],\n+                            64 => vec![Type::f64(cx)],\n                             _ => bug!()\n                         }\n                     }\n                     Pointer(ref t, ref llvm_elem, _const) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t));\n+                        let elem = one(ty_to_type(cx, t));\n                         vec![elem.ptr_to()]\n                     }\n                     Vector(ref t, ref llvm_elem, length) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n-                        let elem = one(ty_to_type(ccx, t));\n+                        let elem = one(ty_to_type(cx, t));\n                         vec![Type::vector(&elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n-                                            .map(|t| one(ty_to_type(ccx, t)))\n+                                            .map(|t| one(ty_to_type(cx, t)))\n                                             .collect::<Vec<_>>();\n-                        vec![Type::struct_(ccx, &elems, false)]\n+                        vec![Type::struct_(cx, &elems, false)]\n                     }\n                     Aggregate(true, ref contents) => {\n                         contents.iter()\n-                                .flat_map(|t| ty_to_type(ccx, t))\n+                                .flat_map(|t| ty_to_type(cx, t))\n                                 .collect()\n                     }\n                 }\n@@ -607,7 +607,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // qux` to be converted into `foo, bar, baz, qux`, integer\n             // arguments to be truncated as needed and pointers to be\n             // cast.\n-            fn modify_as_needed<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+            fn modify_as_needed<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                                           t: &intrinsics::Type,\n                                           arg: &OperandRef<'tcx>)\n                                           -> Vec<ValueRef>\n@@ -620,52 +620,52 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bcx.ccx.shared().type_needs_drop(arg.layout.ty));\n+                        assert!(!bx.cx.type_needs_drop(arg.layout.ty));\n                         let (ptr, align) = match arg.val {\n                             OperandValue::Ref(ptr, align) => (ptr, align),\n                             _ => bug!()\n                         };\n                         let arg = PlaceRef::new_sized(ptr, arg.layout, align);\n                         (0..contents.len()).map(|i| {\n-                            arg.project_field(bcx, i).load(bcx).immediate()\n+                            arg.project_field(bx, i).load(bx).immediate()\n                         }).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem));\n-                        vec![bcx.pointercast(arg.immediate(), llvm_elem.ptr_to())]\n+                        let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n+                        vec![bx.pointercast(arg.immediate(), llvm_elem.ptr_to())]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n-                        let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem));\n-                        vec![bcx.bitcast(arg.immediate(), Type::vector(&llvm_elem, length as u64))]\n+                        let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n+                        vec![bx.bitcast(arg.immediate(), Type::vector(&llvm_elem, length as u64))]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so\n                         // we have to trim it down here.\n-                        vec![bcx.trunc(arg.immediate(), Type::ix(bcx.ccx, llvm_width as u64))]\n+                        vec![bx.trunc(arg.immediate(), Type::ix(bx.cx, llvm_width as u64))]\n                     }\n                     _ => vec![arg.immediate()],\n                 }\n             }\n \n \n             let inputs = intr.inputs.iter()\n-                                    .flat_map(|t| ty_to_type(ccx, t))\n+                                    .flat_map(|t| ty_to_type(cx, t))\n                                     .collect::<Vec<_>>();\n \n-            let outputs = one(ty_to_type(ccx, &intr.output));\n+            let outputs = one(ty_to_type(cx, &intr.output));\n \n             let llargs: Vec<_> = intr.inputs.iter().zip(args).flat_map(|(t, arg)| {\n-                modify_as_needed(bcx, t, arg)\n+                modify_as_needed(bx, t, arg)\n             }).collect();\n             assert_eq!(inputs.len(), llargs.len());\n \n             let val = match intr.definition {\n                 intrinsics::IntrinsicDef::Named(name) => {\n-                    let f = declare::declare_cfn(ccx,\n+                    let f = declare::declare_cfn(cx,\n                                                  name,\n                                                  Type::func(&inputs, &outputs));\n-                    bcx.call(f, &llargs, None)\n+                    bx.call(f, &llargs, None)\n                 }\n             };\n \n@@ -675,9 +675,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     assert!(!flatten);\n \n                     for i in 0..elems.len() {\n-                        let dest = result.project_field(bcx, i);\n-                        let val = bcx.extract_value(val, i as u64);\n-                        bcx.store(val, dest.llval, dest.align);\n+                        let dest = result.project_field(bx, i);\n+                        let val = bx.extract_value(val, i as u64);\n+                        bx.store(val, dest.llval, dest.align);\n                     }\n                     return;\n                 }\n@@ -688,27 +688,27 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n     if !fn_ty.ret.is_ignore() {\n         if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-            let ptr = bcx.pointercast(result.llval, ty.llvm_type(ccx).ptr_to());\n-            bcx.store(llval, ptr, result.align);\n+            let ptr = bx.pointercast(result.llval, ty.llvm_type(cx).ptr_to());\n+            bx.store(llval, ptr, result.align);\n         } else {\n-            OperandRef::from_immediate_or_packed_pair(bcx, llval, result.layout)\n-                .val.store(bcx, result);\n+            OperandRef::from_immediate_or_packed_pair(bx, llval, result.layout)\n+                .val.store(bx, result);\n         }\n     }\n }\n \n-fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+fn copy_intrinsic<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                             allow_overlap: bool,\n                             volatile: bool,\n                             ty: Ty<'tcx>,\n                             dst: ValueRef,\n                             src: ValueRef,\n                             count: ValueRef)\n                             -> ValueRef {\n-    let ccx = bcx.ccx;\n-    let (size, align) = ccx.size_and_align_of(ty);\n-    let size = C_usize(ccx, size.bytes());\n-    let align = C_i32(ccx, align.abi() as i32);\n+    let cx = bx.cx;\n+    let (size, align) = cx.size_and_align_of(ty);\n+    let size = C_usize(cx, size.bytes());\n+    let align = C_i32(cx, align.abi() as i32);\n \n     let operation = if allow_overlap {\n         \"memmove\"\n@@ -717,53 +717,53 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     };\n \n     let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation,\n-                       ccx.data_layout().pointer_size.bits());\n+                       cx.data_layout().pointer_size.bits());\n \n-    let dst_ptr = bcx.pointercast(dst, Type::i8p(ccx));\n-    let src_ptr = bcx.pointercast(src, Type::i8p(ccx));\n-    let llfn = ccx.get_intrinsic(&name);\n+    let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n+    let src_ptr = bx.pointercast(src, Type::i8p(cx));\n+    let llfn = cx.get_intrinsic(&name);\n \n-    bcx.call(llfn,\n+    bx.call(llfn,\n         &[dst_ptr,\n         src_ptr,\n-        bcx.mul(size, count),\n+        bx.mul(size, count),\n         align,\n-        C_bool(ccx, volatile)],\n+        C_bool(cx, volatile)],\n         None)\n }\n \n fn memset_intrinsic<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n     dst: ValueRef,\n     val: ValueRef,\n     count: ValueRef\n ) -> ValueRef {\n-    let ccx = bcx.ccx;\n-    let (size, align) = ccx.size_and_align_of(ty);\n-    let size = C_usize(ccx, size.bytes());\n-    let align = C_i32(ccx, align.abi() as i32);\n-    let dst = bcx.pointercast(dst, Type::i8p(ccx));\n-    call_memset(bcx, dst, val, bcx.mul(size, count), align, volatile)\n+    let cx = bx.cx;\n+    let (size, align) = cx.size_and_align_of(ty);\n+    let size = C_usize(cx, size.bytes());\n+    let align = C_i32(cx, align.abi() as i32);\n+    let dst = bx.pointercast(dst, Type::i8p(cx));\n+    call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n }\n \n fn try_intrinsic<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n-    ccx: &CrateContext,\n+    bx: &Builder<'a, 'tcx>,\n+    cx: &CodegenCx,\n     func: ValueRef,\n     data: ValueRef,\n     local_ptr: ValueRef,\n     dest: ValueRef,\n ) {\n-    if bcx.sess().no_landing_pads() {\n-        bcx.call(func, &[data], None);\n-        let ptr_align = bcx.tcx().data_layout.pointer_align;\n-        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, ptr_align);\n-    } else if wants_msvc_seh(bcx.sess()) {\n-        trans_msvc_try(bcx, ccx, func, data, local_ptr, dest);\n+    if bx.sess().no_landing_pads() {\n+        bx.call(func, &[data], None);\n+        let ptr_align = bx.tcx().data_layout.pointer_align;\n+        bx.store(C_null(Type::i8p(&bx.cx)), dest, ptr_align);\n+    } else if wants_msvc_seh(bx.sess()) {\n+        trans_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n-        trans_gnu_try(bcx, ccx, func, data, local_ptr, dest);\n+        trans_gnu_try(bx, cx, func, data, local_ptr, dest);\n     }\n }\n \n@@ -774,25 +774,25 @@ fn try_intrinsic<'a, 'tcx>(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                            ccx: &CrateContext,\n+fn trans_msvc_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n+                            cx: &CodegenCx,\n                             func: ValueRef,\n                             data: ValueRef,\n                             local_ptr: ValueRef,\n                             dest: ValueRef) {\n-    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n-        let ccx = bcx.ccx;\n+    let llfn = get_rust_try_fn(cx, &mut |bx| {\n+        let cx = bx.cx;\n \n-        bcx.set_personality_fn(bcx.ccx.eh_personality());\n+        bx.set_personality_fn(bx.cx.eh_personality());\n \n-        let normal = bcx.build_sibling_block(\"normal\");\n-        let catchswitch = bcx.build_sibling_block(\"catchswitch\");\n-        let catchpad = bcx.build_sibling_block(\"catchpad\");\n-        let caught = bcx.build_sibling_block(\"caught\");\n+        let normal = bx.build_sibling_block(\"normal\");\n+        let catchswitch = bx.build_sibling_block(\"catchswitch\");\n+        let catchpad = bx.build_sibling_block(\"catchpad\");\n+        let caught = bx.build_sibling_block(\"caught\");\n \n-        let func = llvm::get_param(bcx.llfn(), 0);\n-        let data = llvm::get_param(bcx.llfn(), 1);\n-        let local_ptr = llvm::get_param(bcx.llfn(), 2);\n+        let func = llvm::get_param(bx.llfn(), 0);\n+        let data = llvm::get_param(bx.llfn(), 1);\n+        let local_ptr = llvm::get_param(bx.llfn(), 2);\n \n         // We're generating an IR snippet that looks like:\n         //\n@@ -833,42 +833,42 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64p = Type::i64(ccx).ptr_to();\n-        let ptr_align = bcx.tcx().data_layout.pointer_align;\n-        let slot = bcx.alloca(i64p, \"slot\", ptr_align);\n-        bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n+        let i64p = Type::i64(cx).ptr_to();\n+        let ptr_align = bx.tcx().data_layout.pointer_align;\n+        let slot = bx.alloca(i64p, \"slot\", ptr_align);\n+        bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n \n-        normal.ret(C_i32(ccx, 0));\n+        normal.ret(C_i32(cx, 0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n-        let tcx = ccx.tcx();\n+        let tcx = cx.tcx;\n         let tydesc = match tcx.lang_items().msvc_try_filter() {\n-            Some(did) => ::consts::get_static(ccx, did),\n+            Some(did) => ::consts::get_static(cx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n-        let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(ccx, 0), slot]);\n+        let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(cx, 0), slot]);\n         let addr = catchpad.load(slot, ptr_align);\n \n-        let i64_align = bcx.tcx().data_layout.i64_align;\n+        let i64_align = bx.tcx().data_layout.i64_align;\n         let arg1 = catchpad.load(addr, i64_align);\n-        let val1 = C_i32(ccx, 1);\n+        let val1 = C_i32(cx, 1);\n         let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n         catchpad.store(arg1, local_ptr, i64_align);\n         catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), i64_align);\n         catchpad.catch_ret(tok, caught.llbb());\n \n-        caught.ret(C_i32(ccx, 1));\n+        caught.ret(C_i32(cx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    let i32_align = bcx.tcx().data_layout.i32_align;\n-    bcx.store(ret, dest, i32_align);\n+    let ret = bx.call(llfn, &[func, data, local_ptr], None);\n+    let i32_align = bx.tcx().data_layout.i32_align;\n+    bx.store(ret, dest, i32_align);\n }\n \n // Definition of the standard \"try\" function for Rust using the GNU-like model\n@@ -882,18 +882,18 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                           ccx: &CrateContext,\n+fn trans_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n+                           cx: &CodegenCx,\n                            func: ValueRef,\n                            data: ValueRef,\n                            local_ptr: ValueRef,\n                            dest: ValueRef) {\n-    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n-        let ccx = bcx.ccx;\n+    let llfn = get_rust_try_fn(cx, &mut |bx| {\n+        let cx = bx.cx;\n \n         // Translates the shims described above:\n         //\n-        //   bcx:\n+        //   bx:\n         //      invoke %func(%args...) normal %normal unwind %catch\n         //\n         //   normal:\n@@ -908,72 +908,72 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        let then = bcx.build_sibling_block(\"then\");\n-        let catch = bcx.build_sibling_block(\"catch\");\n+        let then = bx.build_sibling_block(\"then\");\n+        let catch = bx.build_sibling_block(\"catch\");\n \n-        let func = llvm::get_param(bcx.llfn(), 0);\n-        let data = llvm::get_param(bcx.llfn(), 1);\n-        let local_ptr = llvm::get_param(bcx.llfn(), 2);\n-        bcx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n-        then.ret(C_i32(ccx, 0));\n+        let func = llvm::get_param(bx.llfn(), 0);\n+        let data = llvm::get_param(bx.llfn(), 1);\n+        let local_ptr = llvm::get_param(bx.llfn(), 2);\n+        bx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n+        then.ret(C_i32(cx, 0));\n \n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n-        let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n+        let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)],\n                                     false);\n-        let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1);\n-        catch.add_clause(vals, C_null(Type::i8p(ccx)));\n+        let vals = catch.landing_pad(lpad_ty, bx.cx.eh_personality(), 1);\n+        catch.add_clause(vals, C_null(Type::i8p(cx)));\n         let ptr = catch.extract_value(vals, 0);\n-        let ptr_align = bcx.tcx().data_layout.pointer_align;\n-        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), ptr_align);\n-        catch.ret(C_i32(ccx, 1));\n+        let ptr_align = bx.tcx().data_layout.pointer_align;\n+        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(cx).ptr_to()), ptr_align);\n+        catch.ret(C_i32(cx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    let i32_align = bcx.tcx().data_layout.i32_align;\n-    bcx.store(ret, dest, i32_align);\n+    let ret = bx.call(llfn, &[func, data, local_ptr], None);\n+    let i32_align = bx.tcx().data_layout.i32_align;\n+    bx.store(ret, dest, i32_align);\n }\n \n // Helper function to give a Block to a closure to translate a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n-fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n                     trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n-    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ty::Binder(ccx.tcx().mk_fn_sig(\n+    let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder(cx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n         output,\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust\n     )));\n-    let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n-    trans(bcx);\n+    let llfn = declare::define_internal_fn(cx, name, rust_fn_ty);\n+    let bx = Builder::new_block(cx, llfn, \"entry-block\");\n+    trans(bx);\n     llfn\n }\n \n // Helper function used to get a handle to the `__rust_try` function used to\n // catch exceptions.\n //\n // This function is only generated once and is then cached.\n-fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn get_rust_try_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n-    if let Some(llfn) = ccx.rust_try_fn().get() {\n+    if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;\n     }\n \n     // Define the type up front for the signature of the rust_try function.\n-    let tcx = ccx.tcx();\n+    let tcx = cx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n     let fn_ty = tcx.mk_fn_ptr(ty::Binder(tcx.mk_fn_sig(\n         iter::once(i8p),\n@@ -983,8 +983,8 @@ fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Abi::Rust\n     )));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(ccx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n-    ccx.rust_try_fn().set(Some(rust_try));\n+    let rust_try = gen_fn(cx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n+    cx.rust_try_fn.set(Some(rust_try));\n     return rust_try\n }\n \n@@ -993,7 +993,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n }\n \n fn generic_simd_intrinsic<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n     args: &[OperandRef<'tcx>],\n@@ -1008,7 +1008,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         };\n         ($msg: tt, $($fmt: tt)*) => {\n             span_invalid_monomorphization_error(\n-                bcx.sess(), span,\n+                bx.sess(), span,\n                 &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n                                  $msg),\n                          name, $($fmt)*));\n@@ -1030,7 +1030,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n \n \n-    let tcx = bcx.tcx();\n+    let tcx = bx.tcx();\n     let sig = tcx.erase_late_bound_regions_and_normalize(&callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n \n@@ -1064,7 +1064,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                  ret_ty,\n                  ret_ty.simd_type(tcx));\n \n-        return Ok(compare_simd_types(bcx,\n+        return Ok(compare_simd_types(bx,\n                                      args[0].immediate(),\n                                      args[1].immediate(),\n                                      in_elem,\n@@ -1109,7 +1109,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                                     arg_idx, total_len);\n                         None\n                     }\n-                    Some(idx) => Some(C_i32(bcx.ccx, idx as i32)),\n+                    Some(idx) => Some(C_i32(bx.cx, idx as i32)),\n                 }\n             })\n             .collect();\n@@ -1118,7 +1118,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n             None => return Ok(C_null(llret_ty))\n         };\n \n-        return Ok(bcx.shuffle_vector(args[0].immediate(),\n+        return Ok(bx.shuffle_vector(args[0].immediate(),\n                                      args[1].immediate(),\n                                      C_vector(&indices)))\n     }\n@@ -1127,15 +1127,15 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         require!(in_elem == arg_tys[2],\n                  \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, arg_tys[2]);\n-        return Ok(bcx.insert_element(args[0].immediate(),\n+        return Ok(bx.insert_element(args[0].immediate(),\n                                      args[2].immediate(),\n                                      args[1].immediate()))\n     }\n     if name == \"simd_extract\" {\n         require!(ret_ty == in_elem,\n                  \"expected return type `{}` (element of input `{}`), found `{}`\",\n                  in_elem, in_ty, ret_ty);\n-        return Ok(bcx.extract_element(args[0].immediate(), args[1].immediate()))\n+        return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()))\n     }\n \n     if name == \"simd_cast\" {\n@@ -1171,34 +1171,34 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         match (in_style, out_style) {\n             (Style::Int(in_is_signed), Style::Int(_)) => {\n                 return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bcx.trunc(args[0].immediate(), llret_ty),\n+                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n                     Ordering::Equal => args[0].immediate(),\n                     Ordering::Less => if in_is_signed {\n-                        bcx.sext(args[0].immediate(), llret_ty)\n+                        bx.sext(args[0].immediate(), llret_ty)\n                     } else {\n-                        bcx.zext(args[0].immediate(), llret_ty)\n+                        bx.zext(args[0].immediate(), llret_ty)\n                     }\n                 })\n             }\n             (Style::Int(in_is_signed), Style::Float) => {\n                 return Ok(if in_is_signed {\n-                    bcx.sitofp(args[0].immediate(), llret_ty)\n+                    bx.sitofp(args[0].immediate(), llret_ty)\n                 } else {\n-                    bcx.uitofp(args[0].immediate(), llret_ty)\n+                    bx.uitofp(args[0].immediate(), llret_ty)\n                 })\n             }\n             (Style::Float, Style::Int(out_is_signed)) => {\n                 return Ok(if out_is_signed {\n-                    bcx.fptosi(args[0].immediate(), llret_ty)\n+                    bx.fptosi(args[0].immediate(), llret_ty)\n                 } else {\n-                    bcx.fptoui(args[0].immediate(), llret_ty)\n+                    bx.fptoui(args[0].immediate(), llret_ty)\n                 })\n             }\n             (Style::Float, Style::Float) => {\n                 return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bcx.fptrunc(args[0].immediate(), llret_ty),\n+                    Ordering::Greater => bx.fptrunc(args[0].immediate(), llret_ty),\n                     Ordering::Equal => args[0].immediate(),\n-                    Ordering::Less => bcx.fpext(args[0].immediate(), llret_ty)\n+                    Ordering::Less => bx.fpext(args[0].immediate(), llret_ty)\n                 })\n             }\n             _ => {/* Unsupported. Fallthrough. */}\n@@ -1213,7 +1213,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n             $(if name == stringify!($name) {\n                 match in_elem.sty {\n                     $($(ty::$p(_))|* => {\n-                        return Ok(bcx.$call(args[0].immediate(), args[1].immediate()))\n+                        return Ok(bx.$call(args[0].immediate(), args[1].immediate()))\n                     })*\n                     _ => {},\n                 }\n@@ -1243,11 +1243,11 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n // Returns None if the type is not an integer\n // FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n // stuffs.\n-fn int_type_width_signed(ty: Ty, ccx: &CrateContext) -> Option<(u64, bool)> {\n+fn int_type_width_signed(ty: Ty, cx: &CodegenCx) -> Option<(u64, bool)> {\n     match ty.sty {\n         ty::TyInt(t) => Some((match t {\n             ast::IntTy::Isize => {\n-                match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+                match &cx.tcx.sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,\n                     \"32\" => 32,\n                     \"64\" => 64,\n@@ -1262,7 +1262,7 @@ fn int_type_width_signed(ty: Ty, ccx: &CrateContext) -> Option<(u64, bool)> {\n         }, true)),\n         ty::TyUint(t) => Some((match t {\n             ast::UintTy::Usize => {\n-                match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+                match &cx.tcx.sess.target.target.target_pointer_width[..] {\n                     \"16\" => 16,\n                     \"32\" => 32,\n                     \"64\" => 64,"}, {"sha": "6b542ae2e9364cad6e81d2b640baa6956e19af94", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -33,30 +33,30 @@ impl<'a, 'tcx> VirtualIndex {\n         VirtualIndex(index as u64 + 3)\n     }\n \n-    pub fn get_fn(self, bcx: &Builder<'a, 'tcx>,\n+    pub fn get_fn(self, bx: &Builder<'a, 'tcx>,\n                   llvtable: ValueRef,\n                   fn_ty: &FnType<'tcx>) -> ValueRef {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n \n-        let llvtable = bcx.pointercast(llvtable, fn_ty.llvm_type(bcx.ccx).ptr_to().ptr_to());\n-        let ptr_align = bcx.tcx().data_layout.pointer_align;\n-        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), ptr_align);\n-        bcx.nonnull_metadata(ptr);\n+        let llvtable = bx.pointercast(llvtable, fn_ty.llvm_type(bx.cx).ptr_to().ptr_to());\n+        let ptr_align = bx.tcx().data_layout.pointer_align;\n+        let ptr = bx.load(bx.inbounds_gep(llvtable, &[C_usize(bx.cx, self.0)]), ptr_align);\n+        bx.nonnull_metadata(ptr);\n         // Vtable loads are invariant\n-        bcx.set_invariant_load(ptr);\n+        bx.set_invariant_load(ptr);\n         ptr\n     }\n \n-    pub fn get_usize(self, bcx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+    pub fn get_usize(self, bx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n-        let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n-        let usize_align = bcx.tcx().data_layout.pointer_align;\n-        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), usize_align);\n+        let llvtable = bx.pointercast(llvtable, Type::isize(bx.cx).ptr_to());\n+        let usize_align = bx.tcx().data_layout.pointer_align;\n+        let ptr = bx.load(bx.inbounds_gep(llvtable, &[C_usize(bx.cx, self.0)]), usize_align);\n         // Vtable loads are invariant\n-        bcx.set_invariant_load(ptr);\n+        bx.set_invariant_load(ptr);\n         ptr\n     }\n }\n@@ -69,47 +69,47 @@ impl<'a, 'tcx> VirtualIndex {\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n-pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn get_vtable<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                             ty: Ty<'tcx>,\n                             trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>)\n                             -> ValueRef\n {\n-    let tcx = ccx.tcx();\n+    let tcx = cx.tcx;\n \n     debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);\n \n     // Check the cache.\n-    if let Some(&val) = ccx.vtables().borrow().get(&(ty, trait_ref)) {\n+    if let Some(&val) = cx.vtables.borrow().get(&(ty, trait_ref)) {\n         return val;\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = C_null(Type::i8p(ccx));\n+    let nullptr = C_null(Type::i8p(cx));\n \n-    let (size, align) = ccx.size_and_align_of(ty);\n+    let (size, align) = cx.size_and_align_of(ty);\n     let mut components: Vec<_> = [\n-        callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.tcx(), ty)),\n-        C_usize(ccx, size.bytes()),\n-        C_usize(ccx, align.abi())\n+        callee::get_fn(cx, monomorphize::resolve_drop_in_place(cx.tcx, ty)),\n+        C_usize(cx, size.bytes()),\n+        C_usize(cx, align.abi())\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {\n         let trait_ref = trait_ref.with_self_ty(tcx, ty);\n         let methods = tcx.vtable_methods(trait_ref);\n         let methods = methods.iter().cloned().map(|opt_mth| {\n             opt_mth.map_or(nullptr, |(def_id, substs)| {\n-                callee::resolve_and_get_fn(ccx, def_id, substs)\n+                callee::resolve_and_get_fn(cx, def_id, substs)\n             })\n         });\n         components.extend(methods);\n     }\n \n-    let vtable_const = C_struct(ccx, &components, false);\n-    let align = ccx.data_layout().pointer_align;\n-    let vtable = consts::addr_of(ccx, vtable_const, align, \"vtable\");\n+    let vtable_const = C_struct(cx, &components, false);\n+    let align = cx.data_layout().pointer_align;\n+    let vtable = consts::addr_of(cx, vtable_const, align, \"vtable\");\n \n-    debuginfo::create_vtable_metadata(ccx, ty, vtable);\n+    debuginfo::create_vtable_metadata(cx, ty, vtable);\n \n-    ccx.vtables().borrow_mut().insert((ty, trait_ref), vtable);\n+    cx.vtables.borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }"}, {"sha": "bf82e1d50c47387884bb1f46c24e3c4b7a4296cc", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -20,18 +20,18 @@ use rustc::mir::traversal;\n use rustc::ty;\n use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n-use super::MirContext;\n+use super::FunctionCx;\n \n-pub fn memory_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n-    let mir = mircx.mir;\n-    let mut analyzer = LocalAnalyzer::new(mircx);\n+pub fn memory_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n+    let mir = fx.mir;\n+    let mut analyzer = LocalAnalyzer::new(fx);\n \n     analyzer.visit_mir(mir);\n \n     for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n-        let ty = mircx.monomorphize(&ty);\n+        let ty = fx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n-        let layout = mircx.ccx.layout_of(ty);\n+        let layout = fx.cx.layout_of(ty);\n         if layout.is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n@@ -52,21 +52,21 @@ pub fn memory_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n }\n \n struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n-    cx: &'mir MirContext<'a, 'tcx>,\n+    fx: &'mir FunctionCx<'a, 'tcx>,\n     memory_locals: BitVector,\n     seen_assigned: BitVector\n }\n \n impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n-    fn new(mircx: &'mir MirContext<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n+    fn new(fx: &'mir FunctionCx<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n         let mut analyzer = LocalAnalyzer {\n-            cx: mircx,\n-            memory_locals: BitVector::new(mircx.mir.local_decls.len()),\n-            seen_assigned: BitVector::new(mircx.mir.local_decls.len())\n+            fx,\n+            memory_locals: BitVector::new(fx.mir.local_decls.len()),\n+            seen_assigned: BitVector::new(fx.mir.local_decls.len())\n         };\n \n         // Arguments get assigned to by means of the function being called\n-        for idx in 0..mircx.mir.arg_count {\n+        for idx in 0..fx.mir.arg_count {\n             analyzer.seen_assigned.insert(idx + 1);\n         }\n \n@@ -95,7 +95,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n         if let mir::Place::Local(index) = *place {\n             self.mark_assigned(index);\n-            if !self.cx.rvalue_creates_operand(rvalue) {\n+            if !self.fx.rvalue_creates_operand(rvalue) {\n                 self.mark_as_memory(index);\n             }\n         } else {\n@@ -117,7 +117,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     }, ..\n                 }),\n                 ref args, ..\n-            } if Some(def_id) == self.cx.ccx.tcx().lang_items().box_free_fn() => {\n+            } if Some(def_id) == self.fx.cx.tcx.lang_items().box_free_fn() => {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n@@ -136,7 +136,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_place(place={:?}, context={:?})\", place, context);\n-        let ccx = self.cx.ccx;\n+        let cx = self.fx.cx;\n \n         if let mir::Place::Projection(ref proj) = *place {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n@@ -145,18 +145,18 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 _ => false\n             };\n             if is_consume {\n-                let base_ty = proj.base.ty(self.cx.mir, ccx.tcx());\n-                let base_ty = self.cx.monomorphize(&base_ty);\n+                let base_ty = proj.base.ty(self.fx.mir, cx.tcx);\n+                let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty.projection_ty(ccx.tcx(), &proj.elem).to_ty(ccx.tcx());\n-                let elem_ty = self.cx.monomorphize(&elem_ty);\n-                if ccx.layout_of(elem_ty).is_zst() {\n+                let elem_ty = base_ty.projection_ty(cx.tcx, &proj.elem).to_ty(cx.tcx);\n+                let elem_ty = self.fx.monomorphize(&elem_ty);\n+                if cx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = ccx.layout_of(base_ty.to_ty(ccx.tcx()));\n+                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx));\n                     if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n@@ -200,11 +200,11 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             }\n \n             PlaceContext::Drop => {\n-                let ty = mir::Place::Local(index).ty(self.cx.mir, self.cx.ccx.tcx());\n-                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+                let ty = mir::Place::Local(index).ty(self.fx.mir, self.fx.cx.tcx);\n+                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx));\n \n                 // Only need the place if we're actually dropping it.\n-                if self.cx.ccx.shared().type_needs_drop(ty) {\n+                if self.fx.cx.type_needs_drop(ty) {\n                     self.mark_as_memory(index);\n                 }\n             }"}, {"sha": "af1e30a4b19a6c2f5485c92d26988981f64839b7", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 197, "deletions": 197, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -29,35 +29,35 @@ use type_::Type;\n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n \n-use super::{MirContext, LocalRef};\n+use super::{FunctionCx, LocalRef};\n use super::constant::Const;\n use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n-        let mut bcx = self.get_builder(bb);\n+        let mut bx = self.build_block(bb);\n         let data = &self.mir[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n \n         for statement in &data.statements {\n-            bcx = self.trans_statement(bcx, statement);\n+            bx = self.trans_statement(bx, statement);\n         }\n \n-        self.trans_terminator(bcx, bb, data.terminator());\n+        self.trans_terminator(bx, bb, data.terminator());\n     }\n \n     fn trans_terminator(&mut self,\n-                        mut bcx: Builder<'a, 'tcx>,\n+                        mut bx: Builder<'a, 'tcx>,\n                         bb: mir::BasicBlock,\n                         terminator: &mir::Terminator<'tcx>)\n     {\n         debug!(\"trans_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n-        let tcx = bcx.tcx();\n+        let tcx = bx.tcx();\n         let span = terminator.source_info.span;\n         let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n         let funclet = funclet_bb.and_then(|funclet_bb| self.funclets[funclet_bb].as_ref());\n@@ -99,46 +99,46 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         };\n \n-        let funclet_br = |this: &mut Self, bcx: Builder, target: mir::BasicBlock| {\n+        let funclet_br = |this: &mut Self, bx: Builder, target: mir::BasicBlock| {\n             let (lltarget, is_cleanupret) = lltarget(this, target);\n             if is_cleanupret {\n                 // micro-optimization: generate a `ret` rather than a jump\n                 // to a trampoline.\n-                bcx.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n+                bx.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n             } else {\n-                bcx.br(lltarget);\n+                bx.br(lltarget);\n             }\n         };\n \n         let do_call = |\n             this: &mut Self,\n-            bcx: Builder<'a, 'tcx>,\n+            bx: Builder<'a, 'tcx>,\n             fn_ty: FnType<'tcx>,\n             fn_ptr: ValueRef,\n             llargs: &[ValueRef],\n             destination: Option<(ReturnDest<'tcx>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n-                let ret_bcx = if let Some((_, target)) = destination {\n+                let ret_bx = if let Some((_, target)) = destination {\n                     this.blocks[target]\n                 } else {\n                     this.unreachable_block()\n                 };\n-                let invokeret = bcx.invoke(fn_ptr,\n+                let invokeret = bx.invoke(fn_ptr,\n                                            &llargs,\n-                                           ret_bcx,\n+                                           ret_bx,\n                                            llblock(this, cleanup),\n                                            cleanup_bundle);\n                 fn_ty.apply_attrs_callsite(invokeret);\n \n                 if let Some((ret_dest, target)) = destination {\n-                    let ret_bcx = this.get_builder(target);\n-                    this.set_debug_loc(&ret_bcx, terminator.source_info);\n-                    this.store_return(&ret_bcx, ret_dest, &fn_ty.ret, invokeret);\n+                    let ret_bx = this.build_block(target);\n+                    this.set_debug_loc(&ret_bx, terminator.source_info);\n+                    this.store_return(&ret_bx, ret_dest, &fn_ty.ret, invokeret);\n                 }\n             } else {\n-                let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n+                let llret = bx.call(fn_ptr, &llargs, cleanup_bundle);\n                 fn_ty.apply_attrs_callsite(llret);\n                 if this.mir[bb].is_cleanup {\n                     // Cleanup is always the cold path. Don't inline\n@@ -149,83 +149,83 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 if let Some((ret_dest, target)) = destination {\n-                    this.store_return(&bcx, ret_dest, &fn_ty.ret, llret);\n-                    funclet_br(this, bcx, target);\n+                    this.store_return(&bx, ret_dest, &fn_ty.ret, llret);\n+                    funclet_br(this, bx, target);\n                 } else {\n-                    bcx.unreachable();\n+                    bx.unreachable();\n                 }\n             }\n         };\n \n-        self.set_debug_loc(&bcx, terminator.source_info);\n+        self.set_debug_loc(&bx, terminator.source_info);\n         match terminator.kind {\n             mir::TerminatorKind::Resume => {\n                 if let Some(cleanup_pad) = cleanup_pad {\n-                    bcx.cleanup_ret(cleanup_pad, None);\n+                    bx.cleanup_ret(cleanup_pad, None);\n                 } else {\n-                    let slot = self.get_personality_slot(&bcx);\n-                    let lp0 = slot.project_field(&bcx, 0).load(&bcx).immediate();\n-                    let lp1 = slot.project_field(&bcx, 1).load(&bcx).immediate();\n-                    slot.storage_dead(&bcx);\n+                    let slot = self.get_personality_slot(&bx);\n+                    let lp0 = slot.project_field(&bx, 0).load(&bx).immediate();\n+                    let lp1 = slot.project_field(&bx, 1).load(&bx).immediate();\n+                    slot.storage_dead(&bx);\n \n-                    if !bcx.sess().target.target.options.custom_unwind_resume {\n+                    if !bx.sess().target.target.options.custom_unwind_resume {\n                         let mut lp = C_undef(self.landing_pad_type());\n-                        lp = bcx.insert_value(lp, lp0, 0);\n-                        lp = bcx.insert_value(lp, lp1, 1);\n-                        bcx.resume(lp);\n+                        lp = bx.insert_value(lp, lp0, 0);\n+                        lp = bx.insert_value(lp, lp1, 1);\n+                        bx.resume(lp);\n                     } else {\n-                        bcx.call(bcx.ccx.eh_unwind_resume(), &[lp0], cleanup_bundle);\n-                        bcx.unreachable();\n+                        bx.call(bx.cx.eh_unwind_resume(), &[lp0], cleanup_bundle);\n+                        bx.unreachable();\n                     }\n                 }\n             }\n \n             mir::TerminatorKind::Abort => {\n                 // Call core::intrinsics::abort()\n-                let fnname = bcx.ccx.get_intrinsic(&(\"llvm.trap\"));\n-                bcx.call(fnname, &[], None);\n-                bcx.unreachable();\n+                let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n+                bx.call(fnname, &[], None);\n+                bx.unreachable();\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                funclet_br(self, bcx, target);\n+                funclet_br(self, bx, target);\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-                let discr = self.trans_operand(&bcx, discr);\n-                if switch_ty == bcx.tcx().types.bool {\n+                let discr = self.trans_operand(&bx, discr);\n+                if switch_ty == bx.tcx().types.bool {\n                     let lltrue = llblock(self, targets[0]);\n                     let llfalse = llblock(self, targets[1]);\n                     if let [ConstInt::U8(0)] = values[..] {\n-                        bcx.cond_br(discr.immediate(), llfalse, lltrue);\n+                        bx.cond_br(discr.immediate(), llfalse, lltrue);\n                     } else {\n-                        bcx.cond_br(discr.immediate(), lltrue, llfalse);\n+                        bx.cond_br(discr.immediate(), lltrue, llfalse);\n                     }\n                 } else {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n-                    let switch = bcx.switch(discr.immediate(),\n+                    let switch = bx.switch(discr.immediate(),\n                                             llblock(self, *otherwise), values.len());\n                     for (value, target) in values.iter().zip(targets) {\n-                        let val = Const::from_constint(bcx.ccx, value);\n+                        let val = Const::from_constint(bx.cx, value);\n                         let llbb = llblock(self, *target);\n-                        bcx.add_case(switch, val.llval, llbb)\n+                        bx.add_case(switch, val.llval, llbb)\n                     }\n                 }\n             }\n \n             mir::TerminatorKind::Return => {\n                 let llval = match self.fn_ty.ret.mode {\n                     PassMode::Ignore | PassMode::Indirect(_) => {\n-                        bcx.ret_void();\n+                        bx.ret_void();\n                         return;\n                     }\n \n                     PassMode::Direct(_) | PassMode::Pair(..) => {\n-                        let op = self.trans_consume(&bcx, &mir::Place::Local(mir::RETURN_PLACE));\n+                        let op = self.trans_consume(&bx, &mir::Place::Local(mir::RETURN_PLACE));\n                         if let Ref(llval, align) = op.val {\n-                            bcx.load(llval, align)\n+                            bx.load(llval, align)\n                         } else {\n-                            op.immediate_or_packed_pair(&bcx)\n+                            op.immediate_or_packed_pair(&bx)\n                         }\n                     }\n \n@@ -242,8 +242,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         };\n                         let llslot = match op.val {\n                             Immediate(_) | Pair(..) => {\n-                                let scratch = PlaceRef::alloca(&bcx, self.fn_ty.ret.layout, \"ret\");\n-                                op.val.store(&bcx, scratch);\n+                                let scratch = PlaceRef::alloca(&bx, self.fn_ty.ret.layout, \"ret\");\n+                                op.val.store(&bx, scratch);\n                                 scratch.llval\n                             }\n                             Ref(llval, align) => {\n@@ -252,53 +252,53 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 llval\n                             }\n                         };\n-                        bcx.load(\n-                            bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n+                        bx.load(\n+                            bx.pointercast(llslot, cast_ty.llvm_type(bx.cx).ptr_to()),\n                             self.fn_ty.ret.layout.align)\n                     }\n                 };\n-                bcx.ret(llval);\n+                bx.ret(llval);\n             }\n \n             mir::TerminatorKind::Unreachable => {\n-                bcx.unreachable();\n+                bx.unreachable();\n             }\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                let ty = location.ty(self.mir, bcx.tcx()).to_ty(bcx.tcx());\n+                let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.tcx(), ty);\n+                let drop_fn = monomorphize::resolve_drop_in_place(bx.cx.tcx, ty);\n \n                 if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n                     // we don't actually need to drop anything.\n-                    funclet_br(self, bcx, target);\n+                    funclet_br(self, bx, target);\n                     return\n                 }\n \n-                let place = self.trans_place(&bcx, location);\n+                let place = self.trans_place(&bx, location);\n                 let mut args: &[_] = &[place.llval, place.llextra];\n                 args = &args[..1 + place.has_extra() as usize];\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::TyDynamic(..) => {\n-                        let fn_ty = drop_fn.ty(bcx.ccx.tcx());\n-                        let sig = common::ty_fn_sig(bcx.ccx, fn_ty);\n-                        let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-                        let fn_ty = FnType::new_vtable(bcx.ccx, sig, &[]);\n+                        let fn_ty = drop_fn.ty(bx.cx.tcx);\n+                        let sig = common::ty_fn_sig(bx.cx, fn_ty);\n+                        let sig = bx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                        let fn_ty = FnType::new_vtable(bx.cx, sig, &[]);\n                         args = &args[..1];\n-                        (meth::DESTRUCTOR.get_fn(&bcx, place.llextra, &fn_ty), fn_ty)\n+                        (meth::DESTRUCTOR.get_fn(&bx, place.llextra, &fn_ty), fn_ty)\n                     }\n                     _ => {\n-                        (callee::get_fn(bcx.ccx, drop_fn),\n-                         FnType::of_instance(bcx.ccx, &drop_fn))\n+                        (callee::get_fn(bx.cx, drop_fn),\n+                         FnType::of_instance(bx.cx, &drop_fn))\n                     }\n                 };\n-                do_call(self, bcx, fn_ty, drop_fn, args,\n+                do_call(self, bx, fn_ty, drop_fn, args,\n                         Some((ReturnDest::Nothing, target)),\n                         unwind);\n             }\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let cond = self.trans_operand(&bcx, cond).immediate();\n+                let cond = self.trans_operand(&bx, cond).immediate();\n                 let mut const_cond = common::const_to_opt_u128(cond, false).map(|c| c == 1);\n \n                 // This case can currently arise only from functions marked\n@@ -308,7 +308,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // NOTE: Unlike binops, negation doesn't have its own\n                 // checked operation, just a comparison with the minimum\n                 // value, so we have to check for the assert message.\n-                if !bcx.ccx.check_overflow() {\n+                if !bx.cx.check_overflow {\n                     use rustc_const_math::ConstMathErr::Overflow;\n                     use rustc_const_math::Op::Neg;\n \n@@ -319,42 +319,42 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Don't translate the panic block if success if known.\n                 if const_cond == Some(expected) {\n-                    funclet_br(self, bcx, target);\n+                    funclet_br(self, bx, target);\n                     return;\n                 }\n \n                 // Pass the condition through llvm.expect for branch hinting.\n-                let expect = bcx.ccx.get_intrinsic(&\"llvm.expect.i1\");\n-                let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx, expected)], None);\n+                let expect = bx.cx.get_intrinsic(&\"llvm.expect.i1\");\n+                let cond = bx.call(expect, &[cond, C_bool(bx.cx, expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n                 let panic_block = self.new_block(\"panic\");\n                 if expected {\n-                    bcx.cond_br(cond, lltarget, panic_block.llbb());\n+                    bx.cond_br(cond, lltarget, panic_block.llbb());\n                 } else {\n-                    bcx.cond_br(cond, panic_block.llbb(), lltarget);\n+                    bx.cond_br(cond, panic_block.llbb(), lltarget);\n                 }\n \n-                // After this point, bcx is the block for the call to panic.\n-                bcx = panic_block;\n-                self.set_debug_loc(&bcx, terminator.source_info);\n+                // After this point, bx is the block for the call to panic.\n+                bx = panic_block;\n+                self.set_debug_loc(&bx, terminator.source_info);\n \n                 // Get the location information.\n-                let loc = bcx.sess().codemap().lookup_char_pos(span.lo());\n+                let loc = bx.sess().codemap().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                let filename = C_str_slice(bcx.ccx, filename);\n-                let line = C_u32(bcx.ccx, loc.line as u32);\n-                let col = C_u32(bcx.ccx, loc.col.to_usize() as u32 + 1);\n+                let filename = C_str_slice(bx.cx, filename);\n+                let line = C_u32(bx.cx, loc.line as u32);\n+                let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n                 let align = tcx.data_layout.aggregate_align\n                     .max(tcx.data_layout.i32_align)\n                     .max(tcx.data_layout.pointer_align);\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args, const_err) = match *msg {\n                     mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n-                        let len = self.trans_operand(&mut bcx, len).immediate();\n-                        let index = self.trans_operand(&mut bcx, index).immediate();\n+                        let len = self.trans_operand(&mut bx, len).immediate();\n+                        let index = self.trans_operand(&mut bx, index).immediate();\n \n                         let const_err = common::const_to_opt_u128(len, false)\n                             .and_then(|len| common::const_to_opt_u128(index, false)\n@@ -363,8 +363,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     index: index as u64\n                                 }));\n \n-                        let file_line_col = C_struct(bcx.ccx, &[filename, line, col], false);\n-                        let file_line_col = consts::addr_of(bcx.ccx,\n+                        let file_line_col = C_struct(bx.cx, &[filename, line, col], false);\n+                        let file_line_col = consts::addr_of(bx.cx,\n                                                             file_line_col,\n                                                             align,\n                                                             \"panic_bounds_check_loc\");\n@@ -374,11 +374,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n                         let msg_str = Symbol::intern(err.description()).as_str();\n-                        let msg_str = C_str_slice(bcx.ccx, msg_str);\n-                        let msg_file_line_col = C_struct(bcx.ccx,\n+                        let msg_str = C_str_slice(bx.cx, msg_str);\n+                        let msg_file_line_col = C_struct(bx.cx,\n                                                      &[msg_str, filename, line, col],\n                                                      false);\n-                        let msg_file_line_col = consts::addr_of(bcx.ccx,\n+                        let msg_file_line_col = consts::addr_of(bx.cx,\n                                                                 msg_file_line_col,\n                                                                 align,\n                                                                 \"panic_loc\");\n@@ -394,11 +394,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             \"generator resumed after panicking\"\n                         };\n                         let msg_str = Symbol::intern(str).as_str();\n-                        let msg_str = C_str_slice(bcx.ccx, msg_str);\n-                        let msg_file_line_col = C_struct(bcx.ccx,\n+                        let msg_str = C_str_slice(bx.cx, msg_str);\n+                        let msg_file_line_col = C_struct(bx.cx,\n                                                      &[msg_str, filename, line, col],\n                                                      false);\n-                        let msg_file_line_col = consts::addr_of(bcx.ccx,\n+                        let msg_file_line_col = consts::addr_of(bx.cx,\n                                                                 msg_file_line_col,\n                                                                 align,\n                                                                 \"panic_loc\");\n@@ -413,21 +413,21 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if const_cond == Some(!expected) {\n                     if let Some(err) = const_err {\n                         let err = ConstEvalErr{ span: span, kind: err };\n-                        let mut diag = bcx.tcx().sess.struct_span_warn(\n+                        let mut diag = bx.tcx().sess.struct_span_warn(\n                             span, \"this expression will panic at run-time\");\n-                        err.note(bcx.tcx(), span, \"expression\", &mut diag);\n+                        err.note(bx.tcx(), span, \"expression\", &mut diag);\n                         diag.emit();\n                     }\n                 }\n \n                 // Obtain the panic entry point.\n-                let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n-                let instance = ty::Instance::mono(bcx.tcx(), def_id);\n-                let fn_ty = FnType::of_instance(bcx.ccx, &instance);\n-                let llfn = callee::get_fn(bcx.ccx, instance);\n+                let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n+                let instance = ty::Instance::mono(bx.tcx(), def_id);\n+                let fn_ty = FnType::of_instance(bx.cx, &instance);\n+                let llfn = callee::get_fn(bx.cx, instance);\n \n                 // Translate the actual panic invoke/call.\n-                do_call(self, bcx, fn_ty, llfn, &args, None, cleanup);\n+                do_call(self, bx, fn_ty, llfn, &args, None, cleanup);\n             }\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n@@ -436,11 +436,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::TerminatorKind::Call { ref func, ref args, ref destination, cleanup } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n-                let callee = self.trans_operand(&bcx, func);\n+                let callee = self.trans_operand(&bx, func);\n \n                 let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n-                        (Some(ty::Instance::resolve(bcx.ccx.tcx(),\n+                        (Some(ty::Instance::resolve(bx.cx.tcx,\n                                                     ty::ParamEnv::empty(traits::Reveal::All),\n                                                     def_id,\n                                                     substs).unwrap()),\n@@ -452,42 +452,42 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => bug!(\"{} is not callable\", callee.layout.ty)\n                 };\n                 let def = instance.map(|i| i.def);\n-                let sig = callee.layout.ty.fn_sig(bcx.tcx());\n-                let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                let sig = callee.layout.ty.fn_sig(bx.tcx());\n+                let sig = bx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                 let abi = sig.abi;\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match def {\n                     Some(ty::InstanceDef::Intrinsic(def_id))\n-                        => Some(bcx.tcx().item_name(def_id)),\n+                        => Some(bx.tcx().item_name(def_id)),\n                     _ => None\n                 };\n                 let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n                 if intrinsic == Some(\"transmute\") {\n                     let &(ref dest, target) = destination.as_ref().unwrap();\n-                    self.trans_transmute(&bcx, &args[0], dest);\n-                    funclet_br(self, bcx, target);\n+                    self.trans_transmute(&bx, &args[0], dest);\n+                    funclet_br(self, bx, target);\n                     return;\n                 }\n \n                 let extra_args = &args[sig.inputs().len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n-                    let op_ty = op_arg.ty(self.mir, bcx.tcx());\n+                    let op_ty = op_arg.ty(self.mir, bx.tcx());\n                     self.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n \n                 let fn_ty = match def {\n                     Some(ty::InstanceDef::Virtual(..)) => {\n-                        FnType::new_vtable(bcx.ccx, sig, &extra_args)\n+                        FnType::new_vtable(bx.cx, sig, &extra_args)\n                     }\n                     Some(ty::InstanceDef::DropGlue(_, None)) => {\n                         // empty drop glue - a nop.\n                         let &(_, target) = destination.as_ref().unwrap();\n-                        funclet_br(self, bcx, target);\n+                        funclet_br(self, bx, target);\n                         return;\n                     }\n-                    _ => FnType::new(bcx.ccx, sig, &extra_args)\n+                    _ => FnType::new(bx.cx, sig, &extra_args)\n                 };\n \n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n@@ -497,7 +497,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Prepare the return value destination\n                 let ret_dest = if let Some((ref dest, _)) = *destination {\n                     let is_intrinsic = intrinsic.is_some();\n-                    self.make_return_dest(&bcx, dest, &fn_ty.ret, &mut llargs,\n+                    self.make_return_dest(&bx, dest, &fn_ty.ret, &mut llargs,\n                                           is_intrinsic)\n                 } else {\n                     ReturnDest::Nothing\n@@ -509,7 +509,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to())\n+                            C_undef(fn_ty.ret.memory_ty(bx.cx).ptr_to())\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -529,31 +529,31 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     span_bug!(span, \"shuffle indices must be constant\");\n                                 }\n                                 mir::Operand::Constant(ref constant) => {\n-                                    let val = self.trans_constant(&bcx, constant);\n+                                    let val = self.trans_constant(&bx, constant);\n                                     return OperandRef {\n                                         val: Immediate(val.llval),\n-                                        layout: bcx.ccx.layout_of(val.ty)\n+                                        layout: bx.cx.layout_of(val.ty)\n                                     };\n                                 }\n                             }\n                         }\n \n-                        self.trans_operand(&bcx, arg)\n+                        self.trans_operand(&bx, arg)\n                     }).collect();\n \n \n-                    let callee_ty = instance.as_ref().unwrap().ty(bcx.ccx.tcx());\n-                    trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &args, dest,\n+                    let callee_ty = instance.as_ref().unwrap().ty(bx.cx.tcx);\n+                    trans_intrinsic_call(&bx, callee_ty, &fn_ty, &args, dest,\n                                          terminator.source_info.span);\n \n                     if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                        self.store_return(&bcx, ret_dest, &fn_ty.ret, dst.llval);\n+                        self.store_return(&bx, ret_dest, &fn_ty.ret, dst.llval);\n                     }\n \n                     if let Some((_, target)) = *destination {\n-                        funclet_br(self, bcx, target);\n+                        funclet_br(self, bx, target);\n                     } else {\n-                        bcx.unreachable();\n+                        bx.unreachable();\n                     }\n \n                     return;\n@@ -568,11 +568,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n \n                 for (i, arg) in first_args.iter().enumerate() {\n-                    let mut op = self.trans_operand(&bcx, arg);\n+                    let mut op = self.trans_operand(&bx, arg);\n                     if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n                         if let Pair(data_ptr, meta) = op.val {\n                             llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                .get_fn(&bcx, meta, &fn_ty));\n+                                .get_fn(&bx, meta, &fn_ty));\n                             llargs.push(data_ptr);\n                             continue;\n                         }\n@@ -583,27 +583,27 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     match (arg, op.val) {\n                         (&mir::Operand::Copy(_), Ref(..)) |\n                         (&mir::Operand::Constant(_), Ref(..)) => {\n-                            let tmp = PlaceRef::alloca(&bcx, op.layout, \"const\");\n-                            op.val.store(&bcx, tmp);\n+                            let tmp = PlaceRef::alloca(&bx, op.layout, \"const\");\n+                            op.val.store(&bx, tmp);\n                             op.val = Ref(tmp.llval, tmp.align);\n                         }\n                         _ => {}\n                     }\n \n-                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty.args[i]);\n+                    self.trans_argument(&bx, op, &mut llargs, &fn_ty.args[i]);\n                 }\n                 if let Some(tup) = untuple {\n-                    self.trans_arguments_untupled(&bcx, tup, &mut llargs,\n+                    self.trans_arguments_untupled(&bx, tup, &mut llargs,\n                         &fn_ty.args[first_args.len()..])\n                 }\n \n                 let fn_ptr = match (llfn, instance) {\n                     (Some(llfn), _) => llfn,\n-                    (None, Some(instance)) => callee::get_fn(bcx.ccx, instance),\n+                    (None, Some(instance)) => callee::get_fn(bx.cx, instance),\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n-                do_call(self, bcx, fn_ty, fn_ptr, &llargs,\n+                do_call(self, bx, fn_ty, fn_ptr, &llargs,\n                         destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                         cleanup);\n             }\n@@ -614,13 +614,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_argument(&mut self,\n-                      bcx: &Builder<'a, 'tcx>,\n+                      bx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       arg: &ArgType<'tcx>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(C_undef(ty.llvm_type(bcx.ccx)));\n+            llargs.push(C_undef(ty.llvm_type(bx.cx)));\n         }\n \n         if arg.is_ignore() {\n@@ -643,12 +643,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Immediate(_) | Pair(..) => {\n                 match arg.mode {\n                     PassMode::Indirect(_) | PassMode::Cast(_) => {\n-                        let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n-                        op.val.store(bcx, scratch);\n+                        let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                        op.val.store(bx, scratch);\n                         (scratch.llval, scratch.align, true)\n                     }\n                     _ => {\n-                        (op.immediate_or_packed_pair(bcx), arg.layout.align, false)\n+                        (op.immediate_or_packed_pair(bx), arg.layout.align, false)\n                     }\n                 }\n             }\n@@ -658,8 +658,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                     // have scary latent bugs around.\n \n-                    let scratch = PlaceRef::alloca(bcx, arg.layout, \"arg\");\n-                    base::memcpy_ty(bcx, scratch.llval, llval, op.layout, align);\n+                    let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                    base::memcpy_ty(bx, scratch.llval, llval, op.layout, align);\n                     (scratch.llval, scratch.align, true)\n                 } else {\n                     (llval, align, true)\n@@ -670,61 +670,61 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n+                llval = bx.load(bx.pointercast(llval, ty.llvm_type(bx.cx).ptr_to()),\n                                  align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n                 // used for this call is passing it by-value. In that case,\n                 // the load would just produce `OperandValue::Ref` instead\n                 // of the `OperandValue::Immediate` we need for the call.\n-                llval = bcx.load(llval, align);\n+                llval = bx.load(llval, align);\n                 if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n-                        bcx.range_metadata(llval, 0..2);\n+                        bx.range_metadata(llval, 0..2);\n                     }\n                 }\n                 // We store bools as i8 so we need to truncate to i1.\n-                llval = base::to_immediate(bcx, llval, arg.layout);\n+                llval = base::to_immediate(bx, llval, arg.layout);\n             }\n         }\n \n         llargs.push(llval);\n     }\n \n     fn trans_arguments_untupled(&mut self,\n-                                bcx: &Builder<'a, 'tcx>,\n+                                bx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n                                 args: &[ArgType<'tcx>]) {\n-        let tuple = self.trans_operand(bcx, operand);\n+        let tuple = self.trans_operand(bx, operand);\n \n         // Handle both by-ref and immediate tuples.\n         if let Ref(llval, align) = tuple.val {\n             let tuple_ptr = PlaceRef::new_sized(llval, tuple.layout, align);\n             for i in 0..tuple.layout.fields.count() {\n-                let field_ptr = tuple_ptr.project_field(bcx, i);\n-                self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[i]);\n+                let field_ptr = tuple_ptr.project_field(bx, i);\n+                self.trans_argument(bx, field_ptr.load(bx), llargs, &args[i]);\n             }\n         } else {\n             // If the tuple is immediate, the elements are as well.\n             for i in 0..tuple.layout.fields.count() {\n-                let op = tuple.extract_field(bcx, i);\n-                self.trans_argument(bcx, op, llargs, &args[i]);\n+                let op = tuple.extract_field(bx, i);\n+                self.trans_argument(bx, op, llargs, &args[i]);\n             }\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> PlaceRef<'tcx> {\n-        let ccx = bcx.ccx;\n+    fn get_personality_slot(&mut self, bx: &Builder<'a, 'tcx>) -> PlaceRef<'tcx> {\n+        let cx = bx.cx;\n         if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n-            let layout = ccx.layout_of(ccx.tcx().intern_tup(&[\n-                ccx.tcx().mk_mut_ptr(ccx.tcx().types.u8),\n-                ccx.tcx().types.i32\n+            let layout = cx.layout_of(cx.tcx.intern_tup(&[\n+                cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n+                cx.tcx.types.i32\n             ], false));\n-            let slot = PlaceRef::alloca(bcx, layout, \"personalityslot\");\n+            let slot = PlaceRef::alloca(bx, layout, \"personalityslot\");\n             self.personality_slot = Some(slot);\n             slot\n         }\n@@ -745,28 +745,28 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn landing_pad_uncached(&mut self, target_bb: BasicBlockRef) -> BasicBlockRef {\n-        if base::wants_msvc_seh(self.ccx.sess()) {\n+        if base::wants_msvc_seh(self.cx.sess()) {\n             span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n \n-        let bcx = self.new_block(\"cleanup\");\n+        let bx = self.new_block(\"cleanup\");\n \n-        let llpersonality = self.ccx.eh_personality();\n+        let llpersonality = self.cx.eh_personality();\n         let llretty = self.landing_pad_type();\n-        let lp = bcx.landing_pad(llretty, llpersonality, 1);\n-        bcx.set_cleanup(lp);\n+        let lp = bx.landing_pad(llretty, llpersonality, 1);\n+        bx.set_cleanup(lp);\n \n-        let slot = self.get_personality_slot(&bcx);\n-        slot.storage_live(&bcx);\n-        Pair(bcx.extract_value(lp, 0), bcx.extract_value(lp, 1)).store(&bcx, slot);\n+        let slot = self.get_personality_slot(&bx);\n+        slot.storage_live(&bx);\n+        Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&bx, slot);\n \n-        bcx.br(target_bb);\n-        bcx.llbb()\n+        bx.br(target_bb);\n+        bx.llbb()\n     }\n \n     fn landing_pad_type(&self) -> Type {\n-        let ccx = self.ccx;\n-        Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false)\n+        let cx = self.cx;\n+        Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false)\n     }\n \n     fn unreachable_block(&mut self) -> BasicBlockRef {\n@@ -779,16 +779,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n-        Builder::new_block(self.ccx, self.llfn, name)\n+        Builder::new_block(self.cx, self.llfn, name)\n     }\n \n-    pub fn get_builder(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n-        let builder = Builder::with_ccx(self.ccx);\n-        builder.position_at_end(self.blocks[bb]);\n-        builder\n+    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n+        let bx = Builder::with_cx(self.cx);\n+        bx.position_at_end(self.blocks[bb]);\n+        bx\n     }\n \n-    fn make_return_dest(&mut self, bcx: &Builder<'a, 'tcx>,\n+    fn make_return_dest(&mut self, bx: &Builder<'a, 'tcx>,\n                         dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx>,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n                         -> ReturnDest<'tcx> {\n@@ -805,16 +805,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = PlaceRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n-                        tmp.storage_live(bcx);\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        tmp.storage_live(bx);\n                         llargs.push(tmp.llval);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n-                        let tmp = PlaceRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n-                        tmp.storage_live(bcx);\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        tmp.storage_live(bx);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n                         ReturnDest::DirectOperand(index)\n@@ -825,7 +825,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            self.trans_place(bcx, dest)\n+            self.trans_place(bx, dest)\n         };\n         if fn_ret.is_indirect() {\n             if dest.align.abi() < dest.layout.align.abi() {\n@@ -844,20 +844,20 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         }\n     }\n \n-    fn trans_transmute(&mut self, bcx: &Builder<'a, 'tcx>,\n+    fn trans_transmute(&mut self, bx: &Builder<'a, 'tcx>,\n                        src: &mir::Operand<'tcx>,\n                        dst: &mir::Place<'tcx>) {\n         if let mir::Place::Local(index) = *dst {\n             match self.locals[index] {\n-                LocalRef::Place(place) => self.trans_transmute_into(bcx, src, place),\n+                LocalRef::Place(place) => self.trans_transmute_into(bx, src, place),\n                 LocalRef::Operand(None) => {\n-                    let dst_layout = bcx.ccx.layout_of(self.monomorphized_place_ty(dst));\n+                    let dst_layout = bx.cx.layout_of(self.monomorphized_place_ty(dst));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n-                    let place = PlaceRef::alloca(bcx, dst_layout, \"transmute_temp\");\n-                    place.storage_live(bcx);\n-                    self.trans_transmute_into(bcx, src, place);\n-                    let op = place.load(bcx);\n-                    place.storage_dead(bcx);\n+                    let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n+                    place.storage_live(bx);\n+                    self.trans_transmute_into(bx, src, place);\n+                    let op = place.load(bx);\n+                    place.storage_dead(bx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                 }\n                 LocalRef::Operand(Some(op)) => {\n@@ -866,49 +866,49 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            let dst = self.trans_place(bcx, dst);\n-            self.trans_transmute_into(bcx, src, dst);\n+            let dst = self.trans_place(bx, dst);\n+            self.trans_transmute_into(bx, src, dst);\n         }\n     }\n \n-    fn trans_transmute_into(&mut self, bcx: &Builder<'a, 'tcx>,\n+    fn trans_transmute_into(&mut self, bx: &Builder<'a, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n                             dst: PlaceRef<'tcx>) {\n-        let src = self.trans_operand(bcx, src);\n-        let llty = src.layout.llvm_type(bcx.ccx);\n-        let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n+        let src = self.trans_operand(bx, src);\n+        let llty = src.layout.llvm_type(bx.cx);\n+        let cast_ptr = bx.pointercast(dst.llval, llty.ptr_to());\n         let align = src.layout.align.min(dst.layout.align);\n-        src.val.store(bcx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n+        src.val.store(bx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n     }\n \n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n-                    bcx: &Builder<'a, 'tcx>,\n+                    bx: &Builder<'a, 'tcx>,\n                     dest: ReturnDest<'tcx>,\n                     ret_ty: &ArgType<'tcx>,\n                     llval: ValueRef) {\n         use self::ReturnDest::*;\n \n         match dest {\n             Nothing => (),\n-            Store(dst) => ret_ty.store(bcx, llval, dst),\n+            Store(dst) => ret_ty.store(bx, llval, dst),\n             IndirectOperand(tmp, index) => {\n-                let op = tmp.load(bcx);\n-                tmp.storage_dead(bcx);\n+                let op = tmp.load(bx);\n+                tmp.storage_dead(bx);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if let PassMode::Cast(_) = ret_ty.mode {\n-                    let tmp = PlaceRef::alloca(bcx, ret_ty.layout, \"tmp_ret\");\n-                    tmp.storage_live(bcx);\n-                    ret_ty.store(bcx, llval, tmp);\n-                    let op = tmp.load(bcx);\n-                    tmp.storage_dead(bcx);\n+                    let tmp = PlaceRef::alloca(bx, ret_ty.layout, \"tmp_ret\");\n+                    tmp.storage_live(bx);\n+                    ret_ty.store(bx, llval, tmp);\n+                    let op = tmp.load(bx);\n+                    tmp.storage_dead(bx);\n                     op\n                 } else {\n-                    OperandRef::from_immediate_or_packed_pair(bcx, llval, ret_ty.layout)\n+                    OperandRef::from_immediate_or_packed_pair(bx, llval, ret_ty.layout)\n                 };\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }"}, {"sha": "71ce0aa3da96b9db230f20a923a1b53d67792a7d", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 153, "deletions": 153, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -27,7 +27,7 @@ use base;\n use abi::{self, Abi};\n use callee;\n use builder::Builder;\n-use common::{self, CrateContext, const_get_elt, val_ty};\n+use common::{self, CodegenCx, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_uint_big, C_u32, C_u64};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, C_fat_ptr};\n use common::const_to_opt_u128;\n@@ -43,7 +43,7 @@ use std::fmt;\n use std::ptr;\n \n use super::operand::{OperandRef, OperandValue};\n-use super::MirContext;\n+use super::FunctionCx;\n \n /// A sized constant rvalue.\n /// The LLVM type might not be the same for a single Rust type,\n@@ -62,46 +62,46 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn from_constint(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n-        let tcx = ccx.tcx();\n+    pub fn from_constint(cx: &CodegenCx<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n+        let tcx = cx.tcx;\n         let (llval, ty) = match *ci {\n-            I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n-            I16(v) => (C_int(Type::i16(ccx), v as i64), tcx.types.i16),\n-            I32(v) => (C_int(Type::i32(ccx), v as i64), tcx.types.i32),\n-            I64(v) => (C_int(Type::i64(ccx), v as i64), tcx.types.i64),\n-            I128(v) => (C_uint_big(Type::i128(ccx), v as u128), tcx.types.i128),\n-            Isize(v) => (C_int(Type::isize(ccx), v.as_i64()), tcx.types.isize),\n-            U8(v) => (C_uint(Type::i8(ccx), v as u64), tcx.types.u8),\n-            U16(v) => (C_uint(Type::i16(ccx), v as u64), tcx.types.u16),\n-            U32(v) => (C_uint(Type::i32(ccx), v as u64), tcx.types.u32),\n-            U64(v) => (C_uint(Type::i64(ccx), v), tcx.types.u64),\n-            U128(v) => (C_uint_big(Type::i128(ccx), v), tcx.types.u128),\n-            Usize(v) => (C_uint(Type::isize(ccx), v.as_u64()), tcx.types.usize),\n+            I8(v) => (C_int(Type::i8(cx), v as i64), tcx.types.i8),\n+            I16(v) => (C_int(Type::i16(cx), v as i64), tcx.types.i16),\n+            I32(v) => (C_int(Type::i32(cx), v as i64), tcx.types.i32),\n+            I64(v) => (C_int(Type::i64(cx), v as i64), tcx.types.i64),\n+            I128(v) => (C_uint_big(Type::i128(cx), v as u128), tcx.types.i128),\n+            Isize(v) => (C_int(Type::isize(cx), v.as_i64()), tcx.types.isize),\n+            U8(v) => (C_uint(Type::i8(cx), v as u64), tcx.types.u8),\n+            U16(v) => (C_uint(Type::i16(cx), v as u64), tcx.types.u16),\n+            U32(v) => (C_uint(Type::i32(cx), v as u64), tcx.types.u32),\n+            U64(v) => (C_uint(Type::i64(cx), v), tcx.types.u64),\n+            U128(v) => (C_uint_big(Type::i128(cx), v), tcx.types.u128),\n+            Usize(v) => (C_uint(Type::isize(cx), v.as_u64()), tcx.types.usize),\n         };\n         Const { llval: llval, ty: ty }\n     }\n \n     /// Translate ConstVal into a LLVM constant value.\n-    pub fn from_constval(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn from_constval(cx: &CodegenCx<'a, 'tcx>,\n                          cv: &ConstVal,\n                          ty: Ty<'tcx>)\n                          -> Const<'tcx> {\n-        let llty = ccx.layout_of(ty).llvm_type(ccx);\n+        let llty = cx.layout_of(ty).llvm_type(cx);\n         let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n-                    ast::FloatTy::F32 => C_u32(ccx, v.bits as u32),\n-                    ast::FloatTy::F64 => C_u64(ccx, v.bits as u64)\n+                    ast::FloatTy::F32 => C_u32(cx, v.bits as u32),\n+                    ast::FloatTy::F64 => C_u64(cx, v.bits as u64)\n                 };\n                 consts::bitcast(bits, llty)\n             }\n-            ConstVal::Bool(v) => C_bool(ccx, v),\n-            ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n-            ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n+            ConstVal::Bool(v) => C_bool(cx, v),\n+            ConstVal::Integral(ref i) => return Const::from_constint(cx, i),\n+            ConstVal::Str(ref v) => C_str_slice(cx, v.clone()),\n             ConstVal::ByteStr(v) => {\n-                consts::addr_of(ccx, C_bytes(ccx, v.data), ccx.align_of(ty), \"byte_str\")\n+                consts::addr_of(cx, C_bytes(cx, v.data), cx.align_of(ty), \"byte_str\")\n             }\n-            ConstVal::Char(c) => C_uint(Type::char(ccx), c as u64),\n+            ConstVal::Char(c) => C_uint(Type::char(cx), c as u64),\n             ConstVal::Function(..) => C_undef(llty),\n             ConstVal::Variant(_) |\n             ConstVal::Aggregate(..) |\n@@ -115,11 +115,11 @@ impl<'a, 'tcx> Const<'tcx> {\n         Const::new(val, ty)\n     }\n \n-    fn get_field(&self, ccx: &CrateContext<'a, 'tcx>, i: usize) -> ValueRef {\n-        let layout = ccx.layout_of(self.ty);\n-        let field = layout.field(ccx, i);\n+    fn get_field(&self, cx: &CodegenCx<'a, 'tcx>, i: usize) -> ValueRef {\n+        let layout = cx.layout_of(self.ty);\n+        let field = layout.field(cx, i);\n         if field.is_zst() {\n-            return C_undef(field.immediate_llvm_type(ccx));\n+            return C_undef(field.immediate_llvm_type(cx));\n         }\n         let offset = layout.fields.offset(i);\n         match layout.abi {\n@@ -130,12 +130,12 @@ impl<'a, 'tcx> Const<'tcx> {\n \n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(ccx));\n+                    assert_eq!(field.size, a.value.size(cx));\n                     const_get_elt(self.llval, 0)\n                 } else {\n-                    assert_eq!(offset, a.value.size(ccx)\n-                        .abi_align(b.value.align(ccx)));\n-                    assert_eq!(field.size, b.value.size(ccx));\n+                    assert_eq!(offset, a.value.size(cx)\n+                        .abi_align(b.value.align(cx)));\n+                    assert_eq!(field.size, b.value.size(cx));\n                     const_get_elt(self.llval, 1)\n                 }\n             }\n@@ -145,14 +145,14 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    fn get_pair(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n-        (self.get_field(ccx, 0), self.get_field(ccx, 1))\n+    fn get_pair(&self, cx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n+        (self.get_field(cx, 0), self.get_field(cx, 1))\n     }\n \n-    fn get_fat_ptr(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n+    fn get_fat_ptr(&self, cx: &CodegenCx<'a, 'tcx>) -> (ValueRef, ValueRef) {\n         assert_eq!(abi::FAT_PTR_ADDR, 0);\n         assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        self.get_pair(ccx)\n+        self.get_pair(cx)\n     }\n \n     fn as_place(&self) -> ConstPlace<'tcx> {\n@@ -163,9 +163,9 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn to_operand(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n-        let layout = ccx.layout_of(self.ty);\n-        let llty = layout.immediate_llvm_type(ccx);\n+    pub fn to_operand(&self, cx: &CodegenCx<'a, 'tcx>) -> OperandRef<'tcx> {\n+        let layout = cx.layout_of(self.ty);\n+        let llty = layout.immediate_llvm_type(cx);\n         let llvalty = val_ty(self.llval);\n \n         let val = if llty == llvalty && layout.is_llvm_scalar_pair() {\n@@ -178,9 +178,9 @@ impl<'a, 'tcx> Const<'tcx> {\n         } else {\n             // Otherwise, or if the value is not immediate, we create\n             // a constant LLVM global and cast its address if necessary.\n-            let align = ccx.align_of(self.ty);\n-            let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n-            OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(ccx).ptr_to()),\n+            let align = cx.align_of(self.ty);\n+            let ptr = consts::addr_of(cx, self.llval, align, \"const\");\n+            OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(cx).ptr_to()),\n                               layout.align)\n         };\n \n@@ -232,10 +232,10 @@ impl<'tcx> ConstPlace<'tcx> {\n         }\n     }\n \n-    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+    pub fn len<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n         match self.ty.sty {\n             ty::TyArray(_, n) => {\n-                C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n+                C_usize(cx, n.val.to_const_int().unwrap().to_u64().unwrap())\n             }\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n@@ -249,7 +249,7 @@ impl<'tcx> ConstPlace<'tcx> {\n /// Machinery for translating a constant's MIR to LLVM values.\n /// FIXME(eddyb) use miri and lower its allocations to LLVM.\n struct MirConstContext<'a, 'tcx: 'a> {\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    cx: &'a CodegenCx<'a, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n \n     /// Type parameters for const fn and associated constants.\n@@ -270,13 +270,13 @@ fn add_err<'tcx, U, V>(failure: &mut Result<U, ConstEvalErr<'tcx>>,\n }\n \n impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n-    fn new(ccx: &'a CrateContext<'a, 'tcx>,\n+    fn new(cx: &'a CodegenCx<'a, 'tcx>,\n            mir: &'a mir::Mir<'tcx>,\n            substs: &'tcx Substs<'tcx>,\n            args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n            -> MirConstContext<'a, 'tcx> {\n         let mut context = MirConstContext {\n-            ccx,\n+            cx,\n             mir,\n             substs,\n             locals: (0..mir.local_decls.len()).map(|_| None).collect(),\n@@ -289,27 +289,27 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         context\n     }\n \n-    fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n+    fn trans_def(cx: &'a CodegenCx<'a, 'tcx>,\n                  def_id: DefId,\n                  substs: &'tcx Substs<'tcx>,\n                  args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let instance = ty::Instance::resolve(ccx.tcx(),\n+        let instance = ty::Instance::resolve(cx.tcx,\n                                              ty::ParamEnv::empty(traits::Reveal::All),\n                                              def_id,\n                                              substs).unwrap();\n-        let mir = ccx.tcx().instance_mir(instance.def);\n-        MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n+        let mir = cx.tcx.instance_mir(instance.def);\n+        MirConstContext::new(cx, &mir, instance.substs, args).trans()\n     }\n \n     fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        self.ccx.tcx().trans_apply_param_substs(self.substs, value)\n+        self.cx.tcx.trans_apply_param_substs(self.substs, value)\n     }\n \n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.cx.tcx;\n         let mut bb = mir::START_BLOCK;\n \n         // Make sure to evaluate all statemenets to\n@@ -399,13 +399,13 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n                             match &tcx.item_name(def_id)[..] {\n                                 \"size_of\" => {\n-                                    let llval = C_usize(self.ccx,\n-                                        self.ccx.size_of(substs.type_at(0)).bytes());\n+                                    let llval = C_usize(self.cx,\n+                                        self.cx.size_of(substs.type_at(0)).bytes());\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 \"min_align_of\" => {\n-                                    let llval = C_usize(self.ccx,\n-                                        self.ccx.align_of(substs.type_at(0)).abi());\n+                                    let llval = C_usize(self.cx,\n+                                        self.cx.align_of(substs.type_at(0)).abi());\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -430,12 +430,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n                                         Some((llval, of)) => {\n                                             Ok(trans_const_adt(\n-                                                self.ccx,\n+                                                self.cx,\n                                                 binop_ty,\n                                                 &mir::AggregateKind::Tuple,\n                                                 &[\n                                                     Const::new(llval, val_ty),\n-                                                    Const::new(C_bool(self.ccx, of), tcx.types.bool)\n+                                                    Const::new(C_bool(self.cx, of), tcx.types.bool)\n                                                 ]))\n                                         }\n                                         None => {\n@@ -447,7 +447,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 }\n                             })()\n                         } else {\n-                            MirConstContext::trans_def(self.ccx, def_id, substs, arg_vals)\n+                            MirConstContext::trans_def(self.cx, def_id, substs, arg_vals)\n                         };\n                         add_err(&mut failure, &result);\n                         self.store(dest, result, span);\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn is_binop_lang_item(&mut self, def_id: DefId) -> Option<(mir::BinOp, bool)> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.cx.tcx;\n         let items = tcx.lang_items();\n         let def_id = Some(def_id);\n         if items.i128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn const_place(&self, place: &mir::Place<'tcx>, span: Span)\n                     -> Result<ConstPlace<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.cx.tcx;\n \n         if let mir::Place::Local(index) = *place {\n             return self.locals[index].clone().unwrap_or_else(|| {\n@@ -517,7 +517,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             mir::Place::Local(_)  => bug!(), // handled above\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n                 ConstPlace {\n-                    base: Base::Static(consts::get_static(self.ccx, def_id)),\n+                    base: Base::Static(consts::get_static(self.cx, def_id)),\n                     llextra: ptr::null_mut(),\n                     ty: self.monomorphize(&ty),\n                 }\n@@ -528,30 +528,30 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     .projection_ty(tcx, &projection.elem);\n                 let base = tr_base.to_const(span);\n                 let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n-                let has_metadata = self.ccx.shared().type_has_metadata(projected_ty);\n+                let has_metadata = self.cx.type_has_metadata(projected_ty);\n \n                 let (projected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n                         let (base, extra) = if !has_metadata {\n                             (base.llval, ptr::null_mut())\n                         } else {\n-                            base.get_fat_ptr(self.ccx)\n+                            base.get_fat_ptr(self.cx)\n                         };\n-                        if self.ccx.statics().borrow().contains_key(&base) {\n+                        if self.cx.statics.borrow().contains_key(&base) {\n                             (Base::Static(base), extra)\n                         } else if let ty::TyStr = projected_ty.sty {\n                             (Base::Str(base), extra)\n                         } else {\n                             let v = base;\n-                            let v = self.ccx.const_unsized().borrow().get(&v).map_or(v, |&v| v);\n+                            let v = self.cx.const_unsized.borrow().get(&v).map_or(v, |&v| v);\n                             let mut val = unsafe { llvm::LLVMGetInitializer(v) };\n                             if val.is_null() {\n                                 span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n                                           Value(base));\n                             }\n-                            let layout = self.ccx.layout_of(projected_ty);\n+                            let layout = self.cx.layout_of(projected_ty);\n                             if let layout::Abi::Scalar(ref scalar) = layout.abi {\n-                                let i1_type = Type::i1(self.ccx);\n+                                let i1_type = Type::i1(self.cx);\n                                 if scalar.is_bool() && val_ty(val) != i1_type {\n                                     unsafe {\n                                         val = llvm::LLVMConstTrunc(val, i1_type.to_ref());\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let llprojected = base.get_field(self.ccx, field.index());\n+                        let llprojected = base.get_field(self.cx, field.index());\n                         let llextra = if !has_metadata {\n                             ptr::null_mut()\n                         } else {\n@@ -581,11 +581,11 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         };\n \n                         // Produce an undef instead of a LLVM assertion on OOB.\n-                        let len = common::const_to_uint(tr_base.len(self.ccx));\n+                        let len = common::const_to_uint(tr_base.len(self.cx));\n                         let llelem = if iv < len as u128 {\n                             const_get_elt(base.llval, iv as u64)\n                         } else {\n-                            C_undef(self.ccx.layout_of(projected_ty).llvm_type(self.ccx))\n+                            C_undef(self.cx.layout_of(projected_ty).llvm_type(self.cx))\n                         };\n \n                         (Base::Value(llelem), ptr::null_mut())\n@@ -616,14 +616,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 match constant.literal.clone() {\n                     mir::Literal::Promoted { index } => {\n                         let mir = &self.mir.promoted[index];\n-                        MirConstContext::new(self.ccx, mir, self.substs, IndexVec::new()).trans()\n+                        MirConstContext::new(self.cx, mir, self.substs, IndexVec::new()).trans()\n                     }\n                     mir::Literal::Value { value } => {\n                         if let ConstVal::Unevaluated(def_id, substs) = value.val {\n                             let substs = self.monomorphize(&substs);\n-                            MirConstContext::trans_def(self.ccx, def_id, substs, IndexVec::new())\n+                            MirConstContext::trans_def(self.cx, def_id, substs, IndexVec::new())\n                         } else {\n-                            Ok(Const::from_constval(self.ccx, &value.val, ty))\n+                            Ok(Const::from_constval(self.cx, &value.val, ty))\n                         }\n                     }\n                 }\n@@ -640,20 +640,20 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let elem_ty = array_ty.builtin_index().unwrap_or_else(|| {\n             bug!(\"bad array type {:?}\", array_ty)\n         });\n-        let llunitty = self.ccx.layout_of(elem_ty).llvm_type(self.ccx);\n+        let llunitty = self.cx.layout_of(elem_ty).llvm_type(self.cx);\n         // If the array contains enums, an LLVM array won't work.\n         let val = if fields.iter().all(|&f| val_ty(f) == llunitty) {\n             C_array(llunitty, fields)\n         } else {\n-            C_struct(self.ccx, fields, false)\n+            C_struct(self.cx, fields, false)\n         };\n         Const::new(val, array_ty)\n     }\n \n     fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n                     dest_ty: Ty<'tcx>, span: Span)\n                     -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.cx.tcx;\n         debug!(\"const_rvalue({:?}: {:?} @ {:?})\", rvalue, dest_ty, span);\n         let val = match *rvalue {\n             mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n@@ -695,7 +695,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n                 failure?;\n \n-                trans_const_adt(self.ccx, dest_ty, kind, &fields)\n+                trans_const_adt(self.cx, dest_ty, kind, &fields)\n             }\n \n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -706,7 +706,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n-                                callee::resolve_and_get_fn(self.ccx, def_id, substs)\n+                                callee::resolve_and_get_fn(self.cx, def_id, substs)\n                             }\n                             _ => {\n                                 span_bug!(span, \"{} cannot be reified to a fn ptr\",\n@@ -728,7 +728,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 let input = tcx.erase_late_bound_regions_and_normalize(&input);\n                                 let substs = tcx.mk_substs([operand.ty, input]\n                                     .iter().cloned().map(Kind::from));\n-                                callee::resolve_and_get_fn(self.ccx, call_once, substs)\n+                                callee::resolve_and_get_fn(self.cx, call_once, substs)\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n@@ -742,43 +742,43 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::Unsize => {\n                         let pointee_ty = operand.ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer type\").ty;\n-                        let (base, old_info) = if !self.ccx.shared().type_is_sized(pointee_ty) {\n+                        let (base, old_info) = if !self.cx.type_is_sized(pointee_ty) {\n                             // Normally, the source is a thin pointer and we are\n                             // adding extra info to make a fat pointer. The exception\n                             // is when we are upcasting an existing object fat pointer\n                             // to use a different vtable. In that case, we want to\n                             // load out the original data pointer so we can repackage\n                             // it.\n-                            let (base, extra) = operand.get_fat_ptr(self.ccx);\n+                            let (base, extra) = operand.get_fat_ptr(self.cx);\n                             (base, Some(extra))\n                         } else {\n                             (operand.llval, None)\n                         };\n \n                         let unsized_ty = cast_ty.builtin_deref(true, ty::NoPreference)\n                             .expect(\"consts: unsizing got non-pointer target type\").ty;\n-                        let ptr_ty = self.ccx.layout_of(unsized_ty).llvm_type(self.ccx).ptr_to();\n+                        let ptr_ty = self.cx.layout_of(unsized_ty).llvm_type(self.cx).ptr_to();\n                         let base = consts::ptrcast(base, ptr_ty);\n-                        let info = base::unsized_info(self.ccx, pointee_ty,\n+                        let info = base::unsized_info(self.cx, pointee_ty,\n                                                       unsized_ty, old_info);\n \n                         if old_info.is_none() {\n-                            let prev_const = self.ccx.const_unsized().borrow_mut()\n+                            let prev_const = self.cx.const_unsized.borrow_mut()\n                                                      .insert(base, operand.llval);\n                             assert!(prev_const.is_none() || prev_const == Some(operand.llval));\n                         }\n-                        C_fat_ptr(self.ccx, base, info)\n+                        C_fat_ptr(self.cx, base, info)\n                     }\n-                    mir::CastKind::Misc if self.ccx.layout_of(operand.ty).is_llvm_immediate() => {\n+                    mir::CastKind::Misc if self.cx.layout_of(operand.ty).is_llvm_immediate() => {\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let cast_layout = self.ccx.layout_of(cast_ty);\n+                        let cast_layout = self.cx.layout_of(cast_ty);\n                         assert!(cast_layout.is_llvm_immediate());\n-                        let ll_t_out = cast_layout.immediate_llvm_type(self.ccx);\n+                        let ll_t_out = cast_layout.immediate_llvm_type(self.cx);\n                         let llval = operand.llval;\n \n                         let mut signed = false;\n-                        let l = self.ccx.layout_of(operand.ty);\n+                        let l = self.cx.layout_of(operand.ty);\n                         if let layout::Abi::Scalar(ref scalar) = l.abi {\n                             if let layout::Int(_, true) = scalar.value {\n                                 signed = true;\n@@ -792,17 +792,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n                                 }\n                                 (CastTy::Int(_), CastTy::Float) => {\n-                                    cast_const_int_to_float(self.ccx, llval, signed, ll_t_out)\n+                                    cast_const_int_to_float(self.cx, llval, signed, ll_t_out)\n                                 }\n                                 (CastTy::Float, CastTy::Float) => {\n                                     llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n                                 }\n                                 (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                    cast_const_float_to_int(self.ccx, &operand,\n+                                    cast_const_float_to_int(self.cx, &operand,\n                                                             true, ll_t_out, span)\n                                 }\n                                 (CastTy::Float, CastTy::Int(_)) => {\n-                                    cast_const_float_to_int(self.ccx, &operand,\n+                                    cast_const_float_to_int(self.cx, &operand,\n                                                             false, ll_t_out, span)\n                                 }\n                                 (CastTy::Ptr(_), CastTy::Ptr(_)) |\n@@ -813,7 +813,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 (CastTy::Int(_), CastTy::Ptr(_)) => {\n                                     let s = signed as llvm::Bool;\n                                     let usize_llval = llvm::LLVMConstIntCast(llval,\n-                                        self.ccx.isize_ty().to_ref(), s);\n+                                        self.cx.isize_ty.to_ref(), s);\n                                     llvm::LLVMConstIntToPtr(usize_llval, ll_t_out.to_ref())\n                                 }\n                                 (CastTy::Ptr(_), CastTy::Int(_)) |\n@@ -825,18 +825,18 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let l = self.ccx.layout_of(operand.ty);\n-                        let cast = self.ccx.layout_of(cast_ty);\n+                        let l = self.cx.layout_of(operand.ty);\n+                        let cast = self.cx.layout_of(cast_ty);\n                         if l.is_llvm_scalar_pair() {\n-                            let (data_ptr, meta) = operand.get_fat_ptr(self.ccx);\n+                            let (data_ptr, meta) = operand.get_fat_ptr(self.cx);\n                             if cast.is_llvm_scalar_pair() {\n                                 let data_cast = consts::ptrcast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(self.ccx, 0));\n-                                C_fat_ptr(self.ccx, data_cast, meta)\n+                                    cast.scalar_pair_element_llvm_type(self.cx, 0));\n+                                C_fat_ptr(self.cx, data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = cast.immediate_llvm_type(self.ccx);\n+                                let llcast_ty = cast.immediate_llvm_type(self.cx);\n                                 consts::ptrcast(data_ptr, llcast_ty)\n                             }\n                         } else {\n@@ -857,32 +857,32 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let base = match tr_place.base {\n                     Base::Value(llval) => {\n                         // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n-                        let align = if self.ccx.shared().type_is_sized(ty) {\n-                            self.ccx.align_of(ty)\n+                        let align = if self.cx.type_is_sized(ty) {\n+                            self.cx.align_of(ty)\n                         } else {\n-                            self.ccx.tcx().data_layout.pointer_align\n+                            self.cx.tcx.data_layout.pointer_align\n                         };\n                         if bk == mir::BorrowKind::Mut {\n-                            consts::addr_of_mut(self.ccx, llval, align, \"ref_mut\")\n+                            consts::addr_of_mut(self.cx, llval, align, \"ref_mut\")\n                         } else {\n-                            consts::addr_of(self.ccx, llval, align, \"ref\")\n+                            consts::addr_of(self.cx, llval, align, \"ref\")\n                         }\n                     }\n                     Base::Str(llval) |\n                     Base::Static(llval) => llval\n                 };\n \n-                let ptr = if self.ccx.shared().type_is_sized(ty) {\n+                let ptr = if self.cx.type_is_sized(ty) {\n                     base\n                 } else {\n-                    C_fat_ptr(self.ccx, base, tr_place.llextra)\n+                    C_fat_ptr(self.cx, base, tr_place.llextra)\n                 };\n                 Const::new(ptr, ref_ty)\n             }\n \n             mir::Rvalue::Len(ref place) => {\n                 let tr_place = self.const_place(place, span)?;\n-                Const::new(tr_place.len(self.ccx), tcx.types.usize)\n+                Const::new(tr_place.len(self.cx), tcx.types.usize)\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n@@ -905,9 +905,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                 match const_scalar_checked_binop(tcx, op, lhs, rhs, ty) {\n                     Some((llval, of)) => {\n-                        trans_const_adt(self.ccx, binop_ty, &mir::AggregateKind::Tuple, &[\n+                        trans_const_adt(self.cx, binop_ty, &mir::AggregateKind::Tuple, &[\n                             Const::new(llval, val_ty),\n-                            Const::new(C_bool(self.ccx, of), tcx.types.bool)\n+                            Const::new(C_bool(self.cx, of), tcx.types.bool)\n                         ])\n                     }\n                     None => {\n@@ -941,8 +941,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(self.ccx.shared().type_is_sized(ty));\n-                let llval = C_usize(self.ccx, self.ccx.size_of(ty).bytes());\n+                assert!(self.cx.type_is_sized(ty));\n+                let llval = C_usize(self.cx, self.cx.size_of(ty).bytes());\n                 Const::new(llval, tcx.types.usize)\n             }\n \n@@ -1060,7 +1060,7 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n+unsafe fn cast_const_float_to_int(cx: &CodegenCx,\n                                   operand: &Const,\n                                   signed: bool,\n                                   int_ty: Type,\n@@ -1074,7 +1074,7 @@ unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n     // One way that might happen would be if addresses could be turned into integers in constant\n     // expressions, but that doesn't appear to be possible?\n     // In any case, an ICE is better than producing undef.\n-    let llval_bits = consts::bitcast(llval, Type::ix(ccx, float_bits as u64));\n+    let llval_bits = consts::bitcast(llval, Type::ix(cx, float_bits as u64));\n     let bits = const_to_opt_u128(llval_bits, false).unwrap_or_else(|| {\n         panic!(\"could not get bits of constant float {:?}\",\n                Value(llval));\n@@ -1090,12 +1090,12 @@ unsafe fn cast_const_float_to_int(ccx: &CrateContext,\n     };\n     if cast_result.status.contains(Status::INVALID_OP) {\n         let err = ConstEvalErr { span: span, kind: ErrKind::CannotCast };\n-        err.report(ccx.tcx(), span, \"expression\");\n+        err.report(cx.tcx, span, \"expression\");\n     }\n     C_uint_big(int_ty, cast_result.value)\n }\n \n-unsafe fn cast_const_int_to_float(ccx: &CrateContext,\n+unsafe fn cast_const_int_to_float(cx: &CodegenCx,\n                                   llval: ValueRef,\n                                   signed: bool,\n                                   float_ty: Type) -> ValueRef {\n@@ -1111,16 +1111,16 @@ unsafe fn cast_const_int_to_float(ccx: &CrateContext,\n         llvm::LLVMConstSIToFP(llval, float_ty.to_ref())\n     } else if float_ty.float_width() == 32 && value >= MAX_F32_PLUS_HALF_ULP {\n         // We're casting to f32 and the value is > f32::MAX + 0.5 ULP -> round up to infinity.\n-        let infinity_bits = C_u32(ccx, ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity_bits = C_u32(cx, ieee::Single::INFINITY.to_bits() as u32);\n         consts::bitcast(infinity_bits, float_ty)\n     } else {\n         llvm::LLVMConstUIToFP(llval, float_ty.to_ref())\n     }\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_constant(&mut self,\n-                          bcx: &Builder<'a, 'tcx>,\n+                          bx: &Builder<'a, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n                           -> Const<'tcx>\n     {\n@@ -1129,21 +1129,21 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let result = match constant.literal.clone() {\n             mir::Literal::Promoted { index } => {\n                 let mir = &self.mir.promoted[index];\n-                MirConstContext::new(bcx.ccx, mir, self.param_substs, IndexVec::new()).trans()\n+                MirConstContext::new(bx.cx, mir, self.param_substs, IndexVec::new()).trans()\n             }\n             mir::Literal::Value { value } => {\n                 if let ConstVal::Unevaluated(def_id, substs) = value.val {\n                     let substs = self.monomorphize(&substs);\n-                    MirConstContext::trans_def(bcx.ccx, def_id, substs, IndexVec::new())\n+                    MirConstContext::trans_def(bx.cx, def_id, substs, IndexVec::new())\n                 } else {\n-                    Ok(Const::from_constval(bcx.ccx, &value.val, ty))\n+                    Ok(Const::from_constval(bx.cx, &value.val, ty))\n                 }\n             }\n         };\n \n         let result = result.unwrap_or_else(|_| {\n             // We've errored, so we don't have to produce working code.\n-            let llty = bcx.ccx.layout_of(ty).llvm_type(bcx.ccx);\n+            let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n             Const::new(C_undef(llty), ty)\n         });\n \n@@ -1154,11 +1154,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n \n pub fn trans_static_initializer<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>\n {\n-    MirConstContext::trans_def(ccx, def_id, Substs::empty(), IndexVec::new())\n+    MirConstContext::trans_def(cx, def_id, Substs::empty(), IndexVec::new())\n         .map(|c| c.llval)\n }\n \n@@ -1182,19 +1182,19 @@ pub fn trans_static_initializer<'a, 'tcx>(\n /// this could be changed in the future to avoid allocating unnecessary\n /// space after values of shorter-than-maximum cases.\n fn trans_const_adt<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n+    cx: &CodegenCx<'a, 'tcx>,\n     t: Ty<'tcx>,\n     kind: &mir::AggregateKind,\n     vals: &[Const<'tcx>]\n ) -> Const<'tcx> {\n-    let l = ccx.layout_of(t);\n+    let l = cx.layout_of(t);\n     let variant_index = match *kind {\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n     };\n \n     if let layout::Abi::Uninhabited = l.abi {\n-        return Const::new(C_undef(l.llvm_type(ccx)), t);\n+        return Const::new(C_undef(l.llvm_type(cx)), t);\n     }\n \n     match l.variants {\n@@ -1203,39 +1203,39 @@ fn trans_const_adt<'a, 'tcx>(\n             if let layout::FieldPlacement::Union(_) = l.fields {\n                 assert_eq!(variant_index, 0);\n                 assert_eq!(vals.len(), 1);\n-                let (field_size, field_align) = ccx.size_and_align_of(vals[0].ty);\n+                let (field_size, field_align) = cx.size_and_align_of(vals[0].ty);\n                 let contents = [\n                     vals[0].llval,\n-                    padding(ccx, l.size - field_size)\n+                    padding(cx, l.size - field_size)\n                 ];\n \n                 let packed = l.align.abi() < field_align.abi();\n-                Const::new(C_struct(ccx, &contents, packed), t)\n+                Const::new(C_struct(cx, &contents, packed), t)\n             } else {\n                 if let layout::Abi::Vector { .. } = l.abi {\n                     if let layout::FieldPlacement::Array { .. } = l.fields {\n                         return Const::new(C_vector(&vals.iter().map(|x| x.llval)\n                             .collect::<Vec<_>>()), t);\n                     }\n                 }\n-                build_const_struct(ccx, l, vals, None)\n+                build_const_struct(cx, l, vals, None)\n             }\n         }\n         layout::Variants::Tagged { .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n+                    adt_def.discriminant_for_variant(cx.tcx, variant_index)\n                            .to_u128_unchecked() as u64\n                 },\n                 _ => 0,\n             };\n-            let discr_field = l.field(ccx, 0);\n-            let discr = C_int(discr_field.llvm_type(ccx), discr as i64);\n+            let discr_field = l.field(cx, 0);\n+            let discr = C_int(discr_field.llvm_type(cx), discr as i64);\n             if let layout::Abi::Scalar(_) = l.abi {\n                 Const::new(discr, t)\n             } else {\n                 let discr = Const::new(discr, discr_field.ty);\n-                build_const_struct(ccx, l.for_variant(ccx, variant_index), vals, Some(discr))\n+                build_const_struct(cx, l.for_variant(cx, variant_index), vals, Some(discr))\n             }\n         }\n         layout::Variants::NicheFilling {\n@@ -1245,10 +1245,10 @@ fn trans_const_adt<'a, 'tcx>(\n             ..\n         } => {\n             if variant_index == dataful_variant {\n-                build_const_struct(ccx, l.for_variant(ccx, dataful_variant), vals, None)\n+                build_const_struct(cx, l.for_variant(cx, dataful_variant), vals, None)\n             } else {\n-                let niche = l.field(ccx, 0);\n-                let niche_llty = niche.llvm_type(ccx);\n+                let niche = l.field(cx, 0);\n+                let niche_llty = niche.llvm_type(cx);\n                 let niche_value = ((variant_index - niche_variants.start) as u128)\n                     .wrapping_add(niche_start);\n                 // FIXME(eddyb) Check the actual primitive type here.\n@@ -1258,7 +1258,7 @@ fn trans_const_adt<'a, 'tcx>(\n                 } else {\n                     C_uint_big(niche_llty, niche_value)\n                 };\n-                build_const_struct(ccx, l, &[Const::new(niche_llval, niche.ty)], None)\n+                build_const_struct(cx, l, &[Const::new(niche_llval, niche.ty)], None)\n             }\n         }\n     }\n@@ -1272,7 +1272,7 @@ fn trans_const_adt<'a, 'tcx>(\n /// initializer is 4-byte aligned then simply translating the tuple as\n /// a two-element struct will locate it at offset 4, and accesses to it\n /// will read the wrong memory.\n-fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn build_const_struct<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 layout: layout::TyLayout<'tcx>,\n                                 vals: &[Const<'tcx>],\n                                 discr: Option<Const<'tcx>>)\n@@ -1285,16 +1285,16 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         layout::Abi::Vector { .. } if discr.is_none() => {\n             let mut non_zst_fields = vals.iter().enumerate().map(|(i, f)| {\n                 (f, layout.fields.offset(i))\n-            }).filter(|&(f, _)| !ccx.layout_of(f.ty).is_zst());\n+            }).filter(|&(f, _)| !cx.layout_of(f.ty).is_zst());\n             match (non_zst_fields.next(), non_zst_fields.next()) {\n                 (Some((x, offset)), None) if offset.bytes() == 0 => {\n                     return Const::new(x.llval, layout.ty);\n                 }\n                 (Some((a, a_offset)), Some((b, _))) if a_offset.bytes() == 0 => {\n-                    return Const::new(C_struct(ccx, &[a.llval, b.llval], false), layout.ty);\n+                    return Const::new(C_struct(cx, &[a.llval, b.llval], false), layout.ty);\n                 }\n                 (Some((a, _)), Some((b, b_offset))) if b_offset.bytes() == 0 => {\n-                    return Const::new(C_struct(ccx, &[b.llval, a.llval], false), layout.ty);\n+                    return Const::new(C_struct(cx, &[b.llval, a.llval], false), layout.ty);\n                 }\n                 _ => {}\n             }\n@@ -1309,7 +1309,7 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     cfields.reserve(discr.is_some() as usize + 1 + layout.fields.count() * 2);\n \n     if let Some(discr) = discr {\n-        let (field_size, field_align) = ccx.size_and_align_of(discr.ty);\n+        let (field_size, field_align) = cx.size_and_align_of(discr.ty);\n         packed |= layout.align.abi() < field_align.abi();\n         cfields.push(discr.llval);\n         offset = field_size;\n@@ -1319,19 +1319,19 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         (vals[i], layout.fields.offset(i))\n     });\n     for (val, target_offset) in parts {\n-        let (field_size, field_align) = ccx.size_and_align_of(val.ty);\n+        let (field_size, field_align) = cx.size_and_align_of(val.ty);\n         packed |= layout.align.abi() < field_align.abi();\n-        cfields.push(padding(ccx, target_offset - offset));\n+        cfields.push(padding(cx, target_offset - offset));\n         cfields.push(val.llval);\n         offset = target_offset + field_size;\n     }\n \n     // Pad to the size of the whole type, not e.g. the variant.\n-    cfields.push(padding(ccx, ccx.size_of(layout.ty) - offset));\n+    cfields.push(padding(cx, cx.size_of(layout.ty) - offset));\n \n-    Const::new(C_struct(ccx, &cfields, packed), layout.ty)\n+    Const::new(C_struct(cx, &cfields, packed), layout.ty)\n }\n \n-fn padding(ccx: &CrateContext, size: Size) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(ccx), size.bytes()))\n+fn padding(cx: &CodegenCx, size: Size) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(cx), size.bytes()))\n }"}, {"sha": "ddd78f268fadb1e911b2027bd4e293fc6689f206", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -19,7 +19,7 @@ use rustc::infer::TransNormalize;\n use rustc::session::config::FullDebugInfo;\n use base;\n use builder::Builder;\n-use common::{CrateContext, Funclet};\n+use common::{CodegenCx, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n use abi::{ArgAttribute, FnType, PassMode};\n@@ -41,14 +41,14 @@ use rustc::mir::traversal;\n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for translating MIR.\n-pub struct MirContext<'a, 'tcx:'a> {\n+pub struct FunctionCx<'a, 'tcx:'a> {\n     mir: &'a mir::Mir<'tcx>,\n \n     debug_context: debuginfo::FunctionDebugContext,\n \n     llfn: ValueRef,\n \n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    cx: &'a CodegenCx<'a, 'tcx>,\n \n     fn_ty: FnType<'tcx>,\n \n@@ -102,16 +102,16 @@ pub struct MirContext<'a, 'tcx:'a> {\n     param_substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        self.ccx.tcx().trans_apply_param_substs(self.param_substs, value)\n+        self.cx.tcx.trans_apply_param_substs(self.param_substs, value)\n     }\n \n-    pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(&mut self, bx: &Builder, source_info: mir::SourceInfo) {\n         let (scope, span) = self.debug_loc(source_info);\n-        debuginfo::set_source_location(&self.debug_context, bcx, scope, span);\n+        debuginfo::set_source_location(&self.debug_context, bx, scope, span);\n     }\n \n     pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (DIScope, Span) {\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n         if source_info.span.ctxt() == NO_EXPANSION ||\n-           self.ccx.sess().opts.debugging_opts.debug_macros {\n+           self.cx.sess().opts.debugging_opts.debug_macros {\n             let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n             (scope, source_info.span)\n         } else {\n@@ -158,9 +158,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n-            let cm = self.ccx.sess().codemap();\n+            let cm = self.cx.sess().codemap();\n             let defining_crate = self.debug_context.get_ref(DUMMY_SP).defining_crate;\n-            debuginfo::extend_scope_to_file(self.ccx,\n+            debuginfo::extend_scope_to_file(self.cx,\n                                             scope_metadata,\n                                             &cm.lookup_char_pos(pos).file,\n                                             defining_crate)\n@@ -176,12 +176,12 @@ enum LocalRef<'tcx> {\n }\n \n impl<'a, 'tcx> LocalRef<'tcx> {\n-    fn new_operand(ccx: &CrateContext<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n+    fn new_operand(cx: &CodegenCx<'a, 'tcx>, layout: TyLayout<'tcx>) -> LocalRef<'tcx> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(Some(OperandRef::new_zst(ccx, layout)))\n+            LocalRef::Operand(Some(OperandRef::new_zst(cx, layout)))\n         } else {\n             LocalRef::Operand(None)\n         }\n@@ -191,46 +191,46 @@ impl<'a, 'tcx> LocalRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'a, 'tcx: 'a>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    cx: &'a CodegenCx<'a, 'tcx>,\n     llfn: ValueRef,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n-    let fn_ty = FnType::new(ccx, sig, &[]);\n+    let fn_ty = FnType::new(cx, sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n-        debuginfo::create_function_debug_context(ccx, instance, sig, llfn, mir);\n-    let bcx = Builder::new_block(ccx, llfn, \"start\");\n+        debuginfo::create_function_debug_context(cx, instance, sig, llfn, mir);\n+    let bx = Builder::new_block(cx, llfn, \"start\");\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n-        bcx.set_personality_fn(ccx.eh_personality());\n+        bx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n-    let block_bcxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n+    let block_bxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK && !reentrant_start_block {\n-                bcx.llbb()\n+                bx.llbb()\n             } else {\n-                bcx.build_sibling_block(&format!(\"{:?}\", bb)).llbb()\n+                bx.build_sibling_block(&format!(\"{:?}\", bb)).llbb()\n             }\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = debuginfo::create_mir_scopes(ccx, mir, &debug_context);\n-    let (landing_pads, funclets) = create_funclets(&bcx, &cleanup_kinds, &block_bcxs);\n+    let scopes = debuginfo::create_mir_scopes(cx, mir, &debug_context);\n+    let (landing_pads, funclets) = create_funclets(&bx, &cleanup_kinds, &block_bxs);\n \n-    let mut mircx = MirContext {\n+    let mut fx = FunctionCx {\n         mir,\n         llfn,\n         fn_ty,\n-        ccx,\n+        cx,\n         personality_slot: None,\n-        blocks: block_bcxs,\n+        blocks: block_bxs,\n         unreachable_block: None,\n         cleanup_kinds,\n         landing_pads,\n@@ -244,51 +244,51 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         },\n     };\n \n-    let memory_locals = analyze::memory_locals(&mircx);\n+    let memory_locals = analyze::memory_locals(&fx);\n \n     // Allocate variable and temp allocas\n-    mircx.locals = {\n-        let args = arg_local_refs(&bcx, &mircx, &mircx.scopes, &memory_locals);\n+    fx.locals = {\n+        let args = arg_local_refs(&bx, &fx, &fx.scopes, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bcx.ccx.layout_of(mircx.monomorphize(&decl.ty));\n+            let layout = bx.cx.layout_of(fx.monomorphize(&decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if let Some(name) = decl.name {\n                 // User variable\n-                let debug_scope = mircx.scopes[decl.source_info.scope];\n-                let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n+                let debug_scope = fx.scopes[decl.source_info.scope];\n+                let dbg = debug_scope.is_valid() && bx.sess().opts.debuginfo == FullDebugInfo;\n \n                 if !memory_locals.contains(local.index()) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(bcx.ccx, layout);\n+                    return LocalRef::new_operand(bx.cx, layout);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n-                let place = PlaceRef::alloca(&bcx, layout, &name.as_str());\n+                let place = PlaceRef::alloca(&bx, layout, &name.as_str());\n                 if dbg {\n-                    let (scope, span) = mircx.debug_loc(decl.source_info);\n-                    declare_local(&bcx, &mircx.debug_context, name, layout.ty, scope,\n+                    let (scope, span) = fx.debug_loc(decl.source_info);\n+                    declare_local(&bx, &fx.debug_context, name, layout.ty, scope,\n                         VariableAccess::DirectVariable { alloca: place.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n                 LocalRef::Place(place)\n             } else {\n                 // Temporary or return place\n-                if local == mir::RETURN_PLACE && mircx.fn_ty.ret.is_indirect() {\n+                if local == mir::RETURN_PLACE && fx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n                 } else if memory_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> place\", local);\n-                    LocalRef::Place(PlaceRef::alloca(&bcx, layout, &format!(\"{:?}\", local)))\n+                    LocalRef::Place(PlaceRef::alloca(&bx, layout, &format!(\"{:?}\", local)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n                     // definition and update the operand there.\n                     debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(bcx.ccx, layout)\n+                    LocalRef::new_operand(bx.cx, layout)\n                 }\n             }\n         };\n@@ -302,21 +302,21 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n     // Branch to the START block, if it's not the entry block.\n     if reentrant_start_block {\n-        bcx.br(mircx.blocks[mir::START_BLOCK]);\n+        bx.br(fx.blocks[mir::START_BLOCK]);\n     }\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n-    debuginfo::start_emitting_source_locations(&mircx.debug_context);\n+    debuginfo::start_emitting_source_locations(&fx.debug_context);\n \n     let rpo = traversal::reverse_postorder(&mir);\n     let mut visited = BitVector::new(mir.basic_blocks().len());\n \n     // Translate the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n-        mircx.trans_block(bb);\n+        fx.trans_block(bb);\n     }\n \n     // Remove blocks that haven't been visited, or have no\n@@ -326,26 +326,26 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         if !visited.contains(bb.index()) {\n             debug!(\"trans_mir: block {:?} was not visited\", bb);\n             unsafe {\n-                llvm::LLVMDeleteBasicBlock(mircx.blocks[bb]);\n+                llvm::LLVMDeleteBasicBlock(fx.blocks[bb]);\n             }\n         }\n     }\n }\n \n fn create_funclets<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'tcx>,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n-    block_bcxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n+    block_bxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n     -> (IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n         IndexVec<mir::BasicBlock, Option<Funclet>>)\n {\n-    block_bcxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n+    block_bxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n         match *cleanup_kind {\n-            CleanupKind::Funclet if base::wants_msvc_seh(bcx.sess()) => {\n-                let cleanup_bcx = bcx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n-                let cleanup = cleanup_bcx.cleanup_pad(None, &[]);\n-                cleanup_bcx.br(llbb);\n-                (Some(cleanup_bcx.llbb()), Some(Funclet::new(cleanup)))\n+            CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {\n+                let cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n+                let cleanup = cleanup_bx.cleanup_pad(None, &[]);\n+                cleanup_bx.br(llbb);\n+                (Some(cleanup_bx.llbb()), Some(Funclet::new(cleanup)))\n             }\n             _ => (None, None)\n         }\n@@ -355,19 +355,19 @@ fn create_funclets<'a, 'tcx>(\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n-fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                            mircx: &MirContext<'a, 'tcx>,\n+fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n+                            fx: &FunctionCx<'a, 'tcx>,\n                             scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n                             memory_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n-    let mir = mircx.mir;\n-    let tcx = bcx.tcx();\n+    let mir = fx.mir;\n+    let tcx = bx.tcx();\n     let mut idx = 0;\n-    let mut llarg_idx = mircx.fn_ty.ret.is_indirect() as usize;\n+    let mut llarg_idx = fx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n-    let arg_scope = if arg_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo {\n+    let arg_scope = if arg_scope.is_valid() && bx.sess().opts.debuginfo == FullDebugInfo {\n         Some(arg_scope.scope_metadata)\n     } else {\n         None\n@@ -392,17 +392,17 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // to reconstruct it into a tuple local variable, from multiple\n             // individual LLVM function arguments.\n \n-            let arg_ty = mircx.monomorphize(&arg_decl.ty);\n+            let arg_ty = fx.monomorphize(&arg_decl.ty);\n             let tupled_arg_tys = match arg_ty.sty {\n                 ty::TyTuple(ref tys, _) => tys,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let place = PlaceRef::alloca(bcx, bcx.ccx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bx, bx.cx.layout_of(arg_ty), &name);\n             for i in 0..tupled_arg_tys.len() {\n-                let arg = &mircx.fn_ty.args[idx];\n+                let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, place.project_field(bcx, i));\n+                arg.store_fn_arg(bx, &mut llarg_idx, place.project_field(bx, i));\n             }\n \n             // Now that we have one alloca that contains the aggregate value,\n@@ -412,8 +412,8 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     alloca: place.llval\n                 };\n                 declare_local(\n-                    bcx,\n-                    &mircx.debug_context,\n+                    bx,\n+                    &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg_ty, scope,\n                     variable_access,\n@@ -425,7 +425,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             return LocalRef::Place(place);\n         }\n \n-        let arg = &mircx.fn_ty.args[idx];\n+        let arg = &fx.fn_ty.args[idx];\n         idx += 1;\n         if arg.pad.is_some() {\n             llarg_idx += 1;\n@@ -438,22 +438,22 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let local = |op| LocalRef::Operand(Some(op));\n             match arg.mode {\n                 PassMode::Ignore => {\n-                    return local(OperandRef::new_zst(bcx.ccx, arg.layout));\n+                    return local(OperandRef::new_zst(bx.cx, arg.layout));\n                 }\n                 PassMode::Direct(_) => {\n-                    let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-                    bcx.set_value_name(llarg, &name);\n+                    let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    bx.set_value_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n-                        OperandRef::from_immediate_or_packed_pair(bcx, llarg, arg.layout));\n+                        OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n                 }\n                 PassMode::Pair(..) => {\n-                    let a = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-                    bcx.set_value_name(a, &(name.clone() + \".0\"));\n+                    let a = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    bx.set_value_name(a, &(name.clone() + \".0\"));\n                     llarg_idx += 1;\n \n-                    let b = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-                    bcx.set_value_name(b, &(name + \".1\"));\n+                    let b = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+                    bx.set_value_name(b, &(name + \".1\"));\n                     llarg_idx += 1;\n \n                     return local(OperandRef {\n@@ -469,13 +469,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n-            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-            bcx.set_value_name(llarg, &name);\n+            let llarg = llvm::get_param(bx.llfn(), llarg_idx as c_uint);\n+            bx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n             PlaceRef::new_sized(llarg, arg.layout, arg.layout.align)\n         } else {\n-            let tmp = PlaceRef::alloca(bcx, arg.layout, &name);\n-            arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n+            let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+            arg.store_fn_arg(bx, &mut llarg_idx, tmp);\n             tmp\n         };\n         arg_scope.map(|scope| {\n@@ -498,8 +498,8 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 }\n \n                 declare_local(\n-                    bcx,\n-                    &mircx.debug_context,\n+                    bx,\n+                    &fx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                     arg.layout.ty,\n                     scope,\n@@ -512,7 +512,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n             // Or is it the closure environment?\n             let (closure_layout, env_ref) = match arg.layout.ty.sty {\n-                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (bcx.ccx.layout_of(mt.ty), true),\n+                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (bx.cx.layout_of(mt.ty), true),\n                 _ => (arg.layout, false)\n             };\n \n@@ -530,10 +530,10 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let scratch = PlaceRef::alloca(bcx,\n-                    bcx.ccx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n+                let scratch = PlaceRef::alloca(bx,\n+                    bx.cx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n                     \"__debuginfo_env_ptr\");\n-                bcx.store(place.llval, scratch.llval, scratch.align);\n+                bx.store(place.llval, scratch.llval, scratch.align);\n                 scratch.llval\n             } else {\n                 place.llval\n@@ -567,8 +567,8 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     address_operations: &ops\n                 };\n                 declare_local(\n-                    bcx,\n-                    &mircx.debug_context,\n+                    bx,\n+                    &fx.debug_context,\n                     decl.debug_name,\n                     ty,\n                     scope,"}, {"sha": "25db9f9b4c8a80c4c07273a06f65e1839dd5a70c", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -15,7 +15,7 @@ use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{self, CrateContext, C_undef, C_usize};\n+use common::{self, CodegenCx, C_undef, C_usize};\n use builder::Builder;\n use value::Value;\n use type_of::LayoutLlvmExt;\n@@ -24,7 +24,7 @@ use type_::Type;\n use std::fmt;\n use std::ptr;\n \n-use super::{MirContext, LocalRef};\n+use super::{FunctionCx, LocalRef};\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -81,11 +81,11 @@ impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n }\n \n impl<'a, 'tcx> OperandRef<'tcx> {\n-    pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n+    pub fn new_zst(cx: &CodegenCx<'a, 'tcx>,\n                    layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(ccx))),\n+            val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(cx))),\n             layout\n         }\n     }\n@@ -99,15 +99,15 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn deref(self, ccx: &CrateContext<'a, 'tcx>) -> PlaceRef<'tcx> {\n+    pub fn deref(self, cx: &CodegenCx<'a, 'tcx>) -> PlaceRef<'tcx> {\n         let projected_ty = self.layout.ty.builtin_deref(true, ty::NoPreference)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n             OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self)\n         };\n-        let layout = ccx.layout_of(projected_ty);\n+        let layout = cx.layout_of(projected_ty);\n         PlaceRef {\n             llval: llptr,\n             llextra,\n@@ -118,23 +118,23 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a `Pair`, we return an aggregate with the two values.\n     /// For other cases, see `immediate`.\n-    pub fn immediate_or_packed_pair(self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n+    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'tcx>) -> ValueRef {\n         if let OperandValue::Pair(a, b) = self.val {\n-            let llty = self.layout.llvm_type(bcx.ccx);\n+            let llty = self.layout.llvm_type(bx.cx);\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n             let mut llpair = C_undef(llty);\n-            llpair = bcx.insert_value(llpair, a, 0);\n-            llpair = bcx.insert_value(llpair, b, 1);\n+            llpair = bx.insert_value(llpair, a, 0);\n+            llpair = bx.insert_value(llpair, b, 1);\n             llpair\n         } else {\n             self.immediate()\n         }\n     }\n \n     /// If the type is a pair, we return a `Pair`, otherwise, an `Immediate`.\n-    pub fn from_immediate_or_packed_pair(bcx: &Builder<'a, 'tcx>,\n+    pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'tcx>,\n                                          llval: ValueRef,\n                                          layout: TyLayout<'tcx>)\n                                          -> OperandRef<'tcx> {\n@@ -143,23 +143,23 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                     llval, layout);\n \n             // Deconstruct the immediate aggregate.\n-            OperandValue::Pair(bcx.extract_value(llval, 0),\n-                               bcx.extract_value(llval, 1))\n+            OperandValue::Pair(bx.extract_value(llval, 0),\n+                               bx.extract_value(llval, 1))\n         } else {\n             OperandValue::Immediate(llval)\n         };\n         OperandRef { val, layout }\n     }\n \n-    pub fn extract_field(&self, bcx: &Builder<'a, 'tcx>, i: usize) -> OperandRef<'tcx> {\n-        let field = self.layout.field(bcx.ccx, i);\n+    pub fn extract_field(&self, bx: &Builder<'a, 'tcx>, i: usize) -> OperandRef<'tcx> {\n+        let field = self.layout.field(bx.cx, i);\n         let offset = self.layout.fields.offset(i);\n \n         let mut val = match (self.val, &self.layout.abi) {\n             // If we're uninhabited, or the field is ZST, it has no data.\n             _ if self.layout.abi == layout::Abi::Uninhabited || field.is_zst() => {\n                 return OperandRef {\n-                    val: OperandValue::Immediate(C_undef(field.immediate_llvm_type(bcx.ccx))),\n+                    val: OperandValue::Immediate(C_undef(field.immediate_llvm_type(bx.cx))),\n                     layout: field\n                 };\n             }\n@@ -174,20 +174,20 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n             // Extract a scalar component from a pair.\n             (OperandValue::Pair(a_llval, b_llval), &layout::Abi::ScalarPair(ref a, ref b)) => {\n                 if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(bcx.ccx));\n+                    assert_eq!(field.size, a.value.size(bx.cx));\n                     OperandValue::Immediate(a_llval)\n                 } else {\n-                    assert_eq!(offset, a.value.size(bcx.ccx)\n-                        .abi_align(b.value.align(bcx.ccx)));\n-                    assert_eq!(field.size, b.value.size(bcx.ccx));\n+                    assert_eq!(offset, a.value.size(bx.cx)\n+                        .abi_align(b.value.align(bx.cx)));\n+                    assert_eq!(field.size, b.value.size(bx.cx));\n                     OperandValue::Immediate(b_llval)\n                 }\n             }\n \n             // `#[repr(simd)]` types are also immediate.\n             (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n                 OperandValue::Immediate(\n-                    bcx.extract_element(llval, C_usize(bcx.ccx, i as u64)))\n+                    bx.extract_element(llval, C_usize(bx.cx, i as u64)))\n             }\n \n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n@@ -196,11 +196,11 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n         match val {\n             OperandValue::Immediate(ref mut llval) => {\n-                *llval = bcx.bitcast(*llval, field.immediate_llvm_type(bcx.ccx));\n+                *llval = bx.bitcast(*llval, field.immediate_llvm_type(bx.cx));\n             }\n             OperandValue::Pair(ref mut a, ref mut b) => {\n-                *a = bcx.bitcast(*a, field.scalar_pair_element_llvm_type(bcx.ccx, 0));\n-                *b = bcx.bitcast(*b, field.scalar_pair_element_llvm_type(bcx.ccx, 1));\n+                *a = bx.bitcast(*a, field.scalar_pair_element_llvm_type(bx.cx, 0));\n+                *b = bx.bitcast(*b, field.scalar_pair_element_llvm_type(bx.cx, 1));\n             }\n             OperandValue::Ref(..) => bug!()\n         }\n@@ -213,7 +213,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n }\n \n impl<'a, 'tcx> OperandValue {\n-    pub fn store(self, bcx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n@@ -222,28 +222,28 @@ impl<'a, 'tcx> OperandValue {\n         }\n         match self {\n             OperandValue::Ref(r, source_align) =>\n-                base::memcpy_ty(bcx, dest.llval, r, dest.layout,\n+                base::memcpy_ty(bx, dest.llval, r, dest.layout,\n                                 source_align.min(dest.align)),\n             OperandValue::Immediate(s) => {\n-                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.align);\n+                bx.store(base::from_immediate(bx, s), dest.llval, dest.align);\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n-                    let mut llptr = bcx.struct_gep(dest.llval, i as u64);\n+                    let mut llptr = bx.struct_gep(dest.llval, i as u64);\n                     // Make sure to always store i1 as i8.\n-                    if common::val_ty(x) == Type::i1(bcx.ccx) {\n-                        llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n+                    if common::val_ty(x) == Type::i1(bx.cx) {\n+                        llptr = bx.pointercast(llptr, Type::i8p(bx.cx));\n                     }\n-                    bcx.store(base::from_immediate(bcx, x), llptr, dest.align);\n+                    bx.store(base::from_immediate(bx, x), llptr, dest.align);\n                 }\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     fn maybe_trans_consume_direct(&mut self,\n-                                  bcx: &Builder<'a, 'tcx>,\n+                                  bx: &Builder<'a, 'tcx>,\n                                   place: &mir::Place<'tcx>)\n                                    -> Option<OperandRef<'tcx>>\n     {\n@@ -267,19 +267,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         // Moves out of scalar and scalar pair fields are trivial.\n         if let &mir::Place::Projection(ref proj) = place {\n-            if let Some(o) = self.maybe_trans_consume_direct(bcx, &proj.base) {\n+            if let Some(o) = self.maybe_trans_consume_direct(bx, &proj.base) {\n                 match proj.elem {\n                     mir::ProjectionElem::Field(ref f, _) => {\n-                        return Some(o.extract_field(bcx, f.index()));\n+                        return Some(o.extract_field(bx, f.index()));\n                     }\n                     mir::ProjectionElem::Index(_) |\n                     mir::ProjectionElem::ConstantIndex { .. } => {\n                         // ZSTs don't require any actual memory access.\n                         // FIXME(eddyb) deduplicate this with the identical\n                         // checks in `trans_consume` and `extract_field`.\n-                        let elem = o.layout.field(bcx.ccx, 0);\n+                        let elem = o.layout.field(bx.cx, 0);\n                         if elem.is_zst() {\n-                            return Some(OperandRef::new_zst(bcx.ccx, elem));\n+                            return Some(OperandRef::new_zst(bx.cx, elem));\n                         }\n                     }\n                     _ => {}\n@@ -291,31 +291,31 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_consume(&mut self,\n-                         bcx: &Builder<'a, 'tcx>,\n+                         bx: &Builder<'a, 'tcx>,\n                          place: &mir::Place<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n         debug!(\"trans_consume(place={:?})\", place);\n \n         let ty = self.monomorphized_place_ty(place);\n-        let layout = bcx.ccx.layout_of(ty);\n+        let layout = bx.cx.layout_of(ty);\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n-            return OperandRef::new_zst(bcx.ccx, layout);\n+            return OperandRef::new_zst(bx.cx, layout);\n         }\n \n-        if let Some(o) = self.maybe_trans_consume_direct(bcx, place) {\n+        if let Some(o) = self.maybe_trans_consume_direct(bx, place) {\n             return o;\n         }\n \n         // for most places, to consume them we just load them\n         // out from their home\n-        self.trans_place(bcx, place).load(bcx)\n+        self.trans_place(bx, place).load(bx)\n     }\n \n     pub fn trans_operand(&mut self,\n-                         bcx: &Builder<'a, 'tcx>,\n+                         bx: &Builder<'a, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -324,15 +324,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         match *operand {\n             mir::Operand::Copy(ref place) |\n             mir::Operand::Move(ref place) => {\n-                self.trans_consume(bcx, place)\n+                self.trans_consume(bx, place)\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                let val = self.trans_constant(&bcx, constant);\n-                let operand = val.to_operand(bcx.ccx);\n+                let val = self.trans_constant(&bx, constant);\n+                let operand = val.to_operand(bx.cx);\n                 if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it.\n-                    PlaceRef::new_sized(ptr, operand.layout, align).load(bcx)\n+                    PlaceRef::new_sized(ptr, operand.layout, align).load(bx)\n                 } else {\n                     operand\n                 }"}, {"sha": "99770476e12f9233a264bf47fe7a72fc054e6d8d", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::PlaceTy;\n use rustc_data_structures::indexed_vec::Idx;\n use base;\n use builder::Builder;\n-use common::{CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, C_uint_big};\n+use common::{CodegenCx, C_usize, C_u8, C_u32, C_uint, C_int, C_null, C_uint_big};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n@@ -25,7 +25,7 @@ use glue;\n \n use std::ptr;\n \n-use super::{MirContext, LocalRef};\n+use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n \n #[derive(Copy, Clone, Debug)]\n@@ -56,21 +56,21 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n-    pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n+    pub fn alloca(bx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n-        let tmp = bcx.alloca(layout.llvm_type(bcx.ccx), name, layout.align);\n+        let tmp = bx.alloca(layout.llvm_type(bx.cx), name, layout.align);\n         Self::new_sized(tmp, layout, layout.align)\n     }\n \n-    pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+    pub fn len(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n         if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert!(self.has_extra());\n                 assert_eq!(count, 0);\n                 self.llextra\n             } else {\n-                C_usize(ccx, count)\n+                C_usize(cx, count)\n             }\n         } else {\n             bug!(\"unexpected layout `{:#?}` in PlaceRef::len\", self.layout)\n@@ -81,19 +81,19 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         !self.llextra.is_null()\n     }\n \n-    pub fn load(&self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n+    pub fn load(&self, bx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n         assert!(!self.has_extra());\n \n         if self.layout.is_zst() {\n-            return OperandRef::new_zst(bcx.ccx, self.layout);\n+            return OperandRef::new_zst(bx.cx, self.layout);\n         }\n \n         let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n             let (min, max) = (scalar.valid_range.start, scalar.valid_range.end);\n             let max_next = max.wrapping_add(1);\n-            let bits = scalar.value.size(bcx.ccx).bits();\n+            let bits = scalar.value.size(bx.cx).bits();\n             assert!(bits <= 128);\n             let mask = !0u128 >> (128 - bits);\n             // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n@@ -106,10 +106,10 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 layout::Int(..) if max_next & mask != min & mask => {\n                     // llvm::ConstantRange can deal with ranges that wrap around,\n                     // so an overflow on (max + 1) is fine.\n-                    bcx.range_metadata(load, min..max_next);\n+                    bx.range_metadata(load, min..max_next);\n                 }\n                 layout::Pointer if 0 < min && min < max => {\n-                    bcx.nonnull_metadata(load);\n+                    bx.nonnull_metadata(load);\n                 }\n                 _ => {}\n             }\n@@ -127,24 +127,24 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             let llval = if !const_llval.is_null() {\n                 const_llval\n             } else {\n-                let load = bcx.load(self.llval, self.align);\n+                let load = bx.load(self.llval, self.align);\n                 if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n                     scalar_load_metadata(load, scalar);\n                 }\n                 load\n             };\n-            OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout))\n+            OperandValue::Immediate(base::to_immediate(bx, llval, self.layout))\n         } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n             let load = |i, scalar: &layout::Scalar| {\n-                let mut llptr = bcx.struct_gep(self.llval, i as u64);\n+                let mut llptr = bx.struct_gep(self.llval, i as u64);\n                 // Make sure to always load i1 as i8.\n                 if scalar.is_bool() {\n-                    llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n+                    llptr = bx.pointercast(llptr, Type::i8p(bx.cx));\n                 }\n-                let load = bcx.load(llptr, self.align);\n+                let load = bx.load(llptr, self.align);\n                 scalar_load_metadata(load, scalar);\n                 if scalar.is_bool() {\n-                    bcx.trunc(load, Type::i1(bcx.ccx))\n+                    bx.trunc(load, Type::i1(bx.cx))\n                 } else {\n                     load\n                 }\n@@ -158,9 +158,9 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     /// Access a field, at a point when the value's case is known.\n-    pub fn project_field(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> PlaceRef<'tcx> {\n-        let ccx = bcx.ccx;\n-        let field = self.layout.field(ccx, ix);\n+    pub fn project_field(self, bx: &Builder<'a, 'tcx>, ix: usize) -> PlaceRef<'tcx> {\n+        let cx = bx.cx;\n+        let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n         let align = self.align.min(self.layout.align).min(field.align);\n \n@@ -170,15 +170,15 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 self.llval\n             } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n                 // Offsets have to match either first or second field.\n-                assert_eq!(offset, a.value.size(ccx).abi_align(b.value.align(ccx)));\n-                bcx.struct_gep(self.llval, 1)\n+                assert_eq!(offset, a.value.size(cx).abi_align(b.value.align(cx)));\n+                bx.struct_gep(self.llval, 1)\n             } else {\n-                bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n+                bx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n             };\n             PlaceRef {\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                llval: bcx.pointercast(llval, field.llvm_type(ccx).ptr_to()),\n-                llextra: if ccx.shared().type_has_metadata(field.ty) {\n+                llval: bx.pointercast(llval, field.llvm_type(cx).ptr_to()),\n+                llextra: if cx.type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n                     ptr::null_mut()\n@@ -228,42 +228,42 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n         let meta = self.llextra;\n \n-        let unaligned_offset = C_usize(ccx, offset.bytes());\n+        let unaligned_offset = C_usize(cx, offset.bytes());\n \n         // Get the alignment of the field\n-        let (_, unsized_align) = glue::size_and_align_of_dst(bcx, field.ty, meta);\n+        let (_, unsized_align) = glue::size_and_align_of_dst(bx, field.ty, meta);\n \n         // Bump the unaligned offset up to the appropriate alignment using the\n         // following expression:\n         //\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(unsized_align, C_usize(ccx, 1u64));\n-        let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n-        bcx.neg(unsized_align));\n+        let align_sub_1 = bx.sub(unsized_align, C_usize(cx, 1u64));\n+        let offset = bx.and(bx.add(unaligned_offset, align_sub_1),\n+        bx.neg(unsized_align));\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n         // Cast and adjust pointer\n-        let byte_ptr = bcx.pointercast(self.llval, Type::i8p(ccx));\n-        let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n+        let byte_ptr = bx.pointercast(self.llval, Type::i8p(cx));\n+        let byte_ptr = bx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n-        let ll_fty = field.llvm_type(ccx);\n+        let ll_fty = field.llvm_type(cx);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n         PlaceRef {\n-            llval: bcx.pointercast(byte_ptr, ll_fty.ptr_to()),\n+            llval: bx.pointercast(byte_ptr, ll_fty.ptr_to()),\n             llextra: self.llextra,\n             layout: field,\n             align,\n         }\n     }\n \n     /// Obtain the actual discriminant of a value.\n-    pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n-        let cast_to = bcx.ccx.layout_of(cast_to).immediate_llvm_type(bcx.ccx);\n+    pub fn trans_get_discr(self, bx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n+        let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 return C_uint(cast_to, index as u64);\n@@ -272,24 +272,24 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             layout::Variants::NicheFilling { .. } => {},\n         }\n \n-        let discr = self.project_field(bcx, 0);\n-        let lldiscr = discr.load(bcx).immediate();\n+        let discr = self.project_field(bx, 0);\n+        let lldiscr = discr.load(bx).immediate();\n         match self.layout.variants {\n             layout::Variants::Single { .. } => bug!(),\n             layout::Variants::Tagged { ref discr, .. } => {\n                 let signed = match discr.value {\n                     layout::Int(_, signed) => signed,\n                     _ => false\n                 };\n-                bcx.intcast(lldiscr, cast_to, signed)\n+                bx.intcast(lldiscr, cast_to, signed)\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n                 ref niche_variants,\n                 niche_start,\n                 ..\n             } => {\n-                let niche_llty = discr.layout.immediate_llvm_type(bcx.ccx);\n+                let niche_llty = discr.layout.immediate_llvm_type(bx.cx);\n                 if niche_variants.start == niche_variants.end {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n@@ -298,16 +298,16 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                     } else {\n                         C_uint_big(niche_llty, niche_start)\n                     };\n-                    bcx.select(bcx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n+                    bx.select(bx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n                         C_uint(cast_to, niche_variants.start as u64),\n                         C_uint(cast_to, dataful_variant as u64))\n                 } else {\n                     // Rebase from niche values to discriminant values.\n                     let delta = niche_start.wrapping_sub(niche_variants.start as u128);\n-                    let lldiscr = bcx.sub(lldiscr, C_uint_big(niche_llty, delta));\n+                    let lldiscr = bx.sub(lldiscr, C_uint_big(niche_llty, delta));\n                     let lldiscr_max = C_uint(niche_llty, niche_variants.end as u64);\n-                    bcx.select(bcx.icmp(llvm::IntULE, lldiscr, lldiscr_max),\n-                        bcx.intcast(lldiscr, cast_to, false),\n+                    bx.select(bx.icmp(llvm::IntULE, lldiscr, lldiscr_max),\n+                        bx.intcast(lldiscr, cast_to, false),\n                         C_uint(cast_to, dataful_variant as u64))\n                 }\n             }\n@@ -316,20 +316,20 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n-    pub fn trans_set_discr(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize) {\n-        if self.layout.for_variant(bcx.ccx, variant_index).abi == layout::Abi::Uninhabited {\n+    pub fn trans_set_discr(&self, bx: &Builder<'a, 'tcx>, variant_index: usize) {\n+        if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n             return;\n         }\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n             }\n             layout::Variants::Tagged { .. } => {\n-                let ptr = self.project_field(bcx, 0);\n+                let ptr = self.project_field(bx, 0);\n                 let to = self.layout.ty.ty_adt_def().unwrap()\n-                    .discriminant_for_variant(bcx.tcx(), variant_index)\n+                    .discriminant_for_variant(bx.tcx(), variant_index)\n                     .to_u128_unchecked() as u64;\n-                bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n+                bx.store(C_int(ptr.layout.llvm_type(bx.cx), to as i64),\n                     ptr.llval, ptr.align);\n             }\n             layout::Variants::NicheFilling {\n@@ -339,20 +339,20 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n-                    if bcx.sess().target.target.arch == \"arm\" ||\n-                       bcx.sess().target.target.arch == \"aarch64\" {\n+                    if bx.sess().target.target.arch == \"arm\" ||\n+                       bx.sess().target.target.arch == \"aarch64\" {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n-                        let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n-                        let fill_byte = C_u8(bcx.ccx, 0);\n+                        let llptr = bx.pointercast(self.llval, Type::i8(bx.cx).ptr_to());\n+                        let fill_byte = C_u8(bx.cx, 0);\n                         let (size, align) = self.layout.size_and_align();\n-                        let size = C_usize(bcx.ccx, size.bytes());\n-                        let align = C_u32(bcx.ccx, align.abi() as u32);\n-                        base::call_memset(bcx, llptr, fill_byte, size, align, false);\n+                        let size = C_usize(bx.cx, size.bytes());\n+                        let align = C_u32(bx.cx, align.abi() as u32);\n+                        base::call_memset(bx, llptr, fill_byte, size, align, false);\n                     }\n \n-                    let niche = self.project_field(bcx, 0);\n-                    let niche_llty = niche.layout.immediate_llvm_type(bcx.ccx);\n+                    let niche = self.project_field(bx, 0);\n+                    let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n                     let niche_value = ((variant_index - niche_variants.start) as u128)\n                         .wrapping_add(niche_start);\n                     // FIXME(eddyb) Check the actual primitive type here.\n@@ -362,52 +362,52 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                     } else {\n                         C_uint_big(niche_llty, niche_value)\n                     };\n-                    OperandValue::Immediate(niche_llval).store(bcx, niche);\n+                    OperandValue::Immediate(niche_llval).store(bx, niche);\n                 }\n             }\n         }\n     }\n \n-    pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef)\n+    pub fn project_index(&self, bx: &Builder<'a, 'tcx>, llindex: ValueRef)\n                          -> PlaceRef<'tcx> {\n         PlaceRef {\n-            llval: bcx.inbounds_gep(self.llval, &[C_usize(bcx.ccx, 0), llindex]),\n+            llval: bx.inbounds_gep(self.llval, &[C_usize(bx.cx, 0), llindex]),\n             llextra: ptr::null_mut(),\n-            layout: self.layout.field(bcx.ccx, 0),\n+            layout: self.layout.field(bx.cx, 0),\n             align: self.align\n         }\n     }\n \n-    pub fn project_downcast(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize)\n+    pub fn project_downcast(&self, bx: &Builder<'a, 'tcx>, variant_index: usize)\n                             -> PlaceRef<'tcx> {\n         let mut downcast = *self;\n-        downcast.layout = self.layout.for_variant(bcx.ccx, variant_index);\n+        downcast.layout = self.layout.for_variant(bx.cx, variant_index);\n \n         // Cast to the appropriate variant struct type.\n-        let variant_ty = downcast.layout.llvm_type(bcx.ccx);\n-        downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n+        let variant_ty = downcast.layout.llvm_type(bx.cx);\n+        downcast.llval = bx.pointercast(downcast.llval, variant_ty.ptr_to());\n \n         downcast\n     }\n \n-    pub fn storage_live(&self, bcx: &Builder<'a, 'tcx>) {\n-        bcx.lifetime_start(self.llval, self.layout.size);\n+    pub fn storage_live(&self, bx: &Builder<'a, 'tcx>) {\n+        bx.lifetime_start(self.llval, self.layout.size);\n     }\n \n-    pub fn storage_dead(&self, bcx: &Builder<'a, 'tcx>) {\n-        bcx.lifetime_end(self.llval, self.layout.size);\n+    pub fn storage_dead(&self, bx: &Builder<'a, 'tcx>) {\n+        bx.lifetime_end(self.llval, self.layout.size);\n     }\n }\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_place(&mut self,\n-                        bcx: &Builder<'a, 'tcx>,\n+                        bx: &Builder<'a, 'tcx>,\n                         place: &mir::Place<'tcx>)\n                         -> PlaceRef<'tcx> {\n         debug!(\"trans_place(place={:?})\", place);\n \n-        let ccx = bcx.ccx;\n-        let tcx = ccx.tcx();\n+        let cx = bx.cx;\n+        let tcx = cx.tcx;\n \n         if let mir::Place::Local(index) = *place {\n             match self.locals[index] {\n@@ -423,66 +423,66 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let result = match *place {\n             mir::Place::Local(_) => bug!(), // handled above\n             mir::Place::Static(box mir::Static { def_id, ty }) => {\n-                let layout = ccx.layout_of(self.monomorphize(&ty));\n-                PlaceRef::new_sized(consts::get_static(ccx, def_id), layout, layout.align)\n+                let layout = cx.layout_of(self.monomorphize(&ty));\n+                PlaceRef::new_sized(consts::get_static(cx, def_id), layout, layout.align)\n             },\n             mir::Place::Projection(box mir::Projection {\n                 ref base,\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n-                self.trans_consume(bcx, base).deref(bcx.ccx)\n+                self.trans_consume(bx, base).deref(bx.cx)\n             }\n             mir::Place::Projection(ref projection) => {\n-                let tr_base = self.trans_place(bcx, &projection.base);\n+                let tr_base = self.trans_place(bx, &projection.base);\n \n                 match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        tr_base.project_field(bcx, field.index())\n+                        tr_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Copy(mir::Place::Local(index));\n-                        let index = self.trans_operand(bcx, index);\n+                        let index = self.trans_operand(bx, index);\n                         let llindex = index.immediate();\n-                        tr_base.project_index(bcx, llindex)\n+                        tr_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = C_usize(bcx.ccx, offset as u64);\n-                        tr_base.project_index(bcx, lloffset)\n+                        let lloffset = C_usize(bx.cx, offset as u64);\n+                        tr_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = C_usize(bcx.ccx, offset as u64);\n-                        let lllen = tr_base.len(bcx.ccx);\n-                        let llindex = bcx.sub(lllen, lloffset);\n-                        tr_base.project_index(bcx, llindex)\n+                        let lloffset = C_usize(bx.cx, offset as u64);\n+                        let lllen = tr_base.len(bx.cx);\n+                        let llindex = bx.sub(lllen, lloffset);\n+                        tr_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let mut subslice = tr_base.project_index(bcx,\n-                            C_usize(bcx.ccx, from as u64));\n+                        let mut subslice = tr_base.project_index(bx,\n+                            C_usize(bx.cx, from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: tr_base.layout.ty }\n-                            .projection_ty(tcx, &projection.elem).to_ty(bcx.tcx());\n-                        subslice.layout = bcx.ccx.layout_of(self.monomorphize(&projected_ty));\n+                            .projection_ty(tcx, &projection.elem).to_ty(bx.tcx());\n+                        subslice.layout = bx.cx.layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             assert!(tr_base.has_extra());\n-                            subslice.llextra = bcx.sub(tr_base.llextra,\n-                                C_usize(bcx.ccx, (from as u64) + (to as u64)));\n+                            subslice.llextra = bx.sub(tr_base.llextra,\n+                                C_usize(bx.cx, (from as u64) + (to as u64)));\n                         }\n \n                         // Cast the place pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n-                        subslice.llval = bcx.pointercast(subslice.llval,\n-                            subslice.layout.llvm_type(bcx.ccx).ptr_to());\n+                        subslice.llval = bx.pointercast(subslice.llval,\n+                            subslice.layout.llvm_type(bx.cx).ptr_to());\n \n                         subslice\n                     }\n                     mir::ProjectionElem::Downcast(_, v) => {\n-                        tr_base.project_downcast(bcx, v)\n+                        tr_base.project_downcast(bx, v)\n                     }\n                 }\n             }\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.cx.tcx;\n         let place_ty = place.ty(self.mir, tcx);\n         self.monomorphize(&place_ty.to_ty(tcx))\n     }"}, {"sha": "d1bc4fe90014ce9a9638886bd54bca1ea817b06d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 207, "deletions": 207, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -29,14 +29,14 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n \n-use super::{MirContext, LocalRef};\n+use super::{FunctionCx, LocalRef};\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n-                        bcx: Builder<'a, 'tcx>,\n+                        bx: Builder<'a, 'tcx>,\n                         dest: PlaceRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n                         -> Builder<'a, 'tcx>\n@@ -46,11 +46,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         match *rvalue {\n            mir::Rvalue::Use(ref operand) => {\n-               let tr_operand = self.trans_operand(&bcx, operand);\n+               let tr_operand = self.trans_operand(&bx, operand);\n                // FIXME: consider not copying constants through stack. (fixable by translating\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n-               tr_operand.val.store(&bcx, dest);\n-               bcx\n+               tr_operand.val.store(&bx, dest);\n+               bx\n            }\n \n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref source, _) => {\n@@ -59,16 +59,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if dest.layout.is_llvm_scalar_pair() {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n-                    let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    temp.val.store(&bcx, dest);\n-                    return bcx;\n+                    let (bx, temp) = self.trans_rvalue_operand(bx, rvalue);\n+                    temp.val.store(&bx, dest);\n+                    return bx;\n                 }\n \n                 // Unsize of a nontrivial struct. I would prefer for\n                 // this to be eliminated by MIR translation, but\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n-                let operand = self.trans_operand(&bcx, source);\n+                let operand = self.trans_operand(&bx, source);\n                 match operand.val {\n                     OperandValue::Pair(..) |\n                     OperandValue::Immediate(_) => {\n@@ -79,124 +79,124 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let scratch = PlaceRef::alloca(&bcx, operand.layout, \"__unsize_temp\");\n-                        scratch.storage_live(&bcx);\n-                        operand.val.store(&bcx, scratch);\n-                        base::coerce_unsized_into(&bcx, scratch, dest);\n-                        scratch.storage_dead(&bcx);\n+                        let scratch = PlaceRef::alloca(&bx, operand.layout, \"__unsize_temp\");\n+                        scratch.storage_live(&bx);\n+                        operand.val.store(&bx, scratch);\n+                        base::coerce_unsized_into(&bx, scratch, dest);\n+                        scratch.storage_dead(&bx);\n                     }\n                     OperandValue::Ref(llref, align) => {\n                         let source = PlaceRef::new_sized(llref, operand.layout, align);\n-                        base::coerce_unsized_into(&bcx, source, dest);\n+                        base::coerce_unsized_into(&bx, source, dest);\n                     }\n                 }\n-                bcx\n+                bx\n             }\n \n             mir::Rvalue::Repeat(ref elem, count) => {\n-                let tr_elem = self.trans_operand(&bcx, elem);\n+                let tr_elem = self.trans_operand(&bx, elem);\n \n                 // Do not generate the loop for zero-sized elements or empty arrays.\n                 if dest.layout.is_zst() {\n-                    return bcx;\n+                    return bx;\n                 }\n \n-                let start = dest.project_index(&bcx, C_usize(bcx.ccx, 0)).llval;\n+                let start = dest.project_index(&bx, C_usize(bx.cx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n-                    let align = C_i32(bcx.ccx, dest.align.abi() as i32);\n-                    let size = C_usize(bcx.ccx, dest.layout.size.bytes());\n+                    let align = C_i32(bx.cx, dest.align.abi() as i32);\n+                    let size = C_usize(bx.cx, dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n-                        let fill = C_u8(bcx.ccx, 0);\n-                        base::call_memset(&bcx, start, fill, size, align, false);\n-                        return bcx;\n+                        let fill = C_u8(bx.cx, 0);\n+                        base::call_memset(&bx, start, fill, size, align, false);\n+                        return bx;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n-                    let v = base::from_immediate(&bcx, v);\n-                    if common::val_ty(v) == Type::i8(bcx.ccx) {\n-                        base::call_memset(&bcx, start, v, size, align, false);\n-                        return bcx;\n+                    let v = base::from_immediate(&bx, v);\n+                    if common::val_ty(v) == Type::i8(bx.cx) {\n+                        base::call_memset(&bx, start, v, size, align, false);\n+                        return bx;\n                     }\n                 }\n \n                 let count = count.as_u64();\n-                let count = C_usize(bcx.ccx, count);\n-                let end = dest.project_index(&bcx, count).llval;\n+                let count = C_usize(bx.cx, count);\n+                let end = dest.project_index(&bx, count).llval;\n \n-                let header_bcx = bcx.build_sibling_block(\"repeat_loop_header\");\n-                let body_bcx = bcx.build_sibling_block(\"repeat_loop_body\");\n-                let next_bcx = bcx.build_sibling_block(\"repeat_loop_next\");\n+                let header_bx = bx.build_sibling_block(\"repeat_loop_header\");\n+                let body_bx = bx.build_sibling_block(\"repeat_loop_body\");\n+                let next_bx = bx.build_sibling_block(\"repeat_loop_next\");\n \n-                bcx.br(header_bcx.llbb());\n-                let current = header_bcx.phi(common::val_ty(start), &[start], &[bcx.llbb()]);\n+                bx.br(header_bx.llbb());\n+                let current = header_bx.phi(common::val_ty(start), &[start], &[bx.llbb()]);\n \n-                let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n-                header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n+                let keep_going = header_bx.icmp(llvm::IntNE, current, end);\n+                header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n \n-                tr_elem.val.store(&body_bcx,\n+                tr_elem.val.store(&body_bx,\n                     PlaceRef::new_sized(current, tr_elem.layout, dest.align));\n \n-                let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.ccx, 1)]);\n-                body_bcx.br(header_bcx.llbb());\n-                header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n+                let next = body_bx.inbounds_gep(current, &[C_usize(bx.cx, 1)]);\n+                body_bx.br(header_bx.llbb());\n+                header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n \n-                next_bcx\n+                next_bx\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n-                        dest.trans_set_discr(&bcx, variant_index);\n+                        dest.trans_set_discr(&bx, variant_index);\n                         if adt_def.is_enum() {\n-                            (dest.project_downcast(&bcx, variant_index), active_field_index)\n+                            (dest.project_downcast(&bx, variant_index), active_field_index)\n                         } else {\n                             (dest, active_field_index)\n                         }\n                     }\n                     _ => (dest, None)\n                 };\n                 for (i, operand) in operands.iter().enumerate() {\n-                    let op = self.trans_operand(&bcx, operand);\n+                    let op = self.trans_operand(&bx, operand);\n                     // Do not generate stores and GEPis for zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        op.val.store(&bcx, dest.project_field(&bcx, field_index));\n+                        op.val.store(&bx, dest.project_field(&bx, field_index));\n                     }\n                 }\n-                bcx\n+                bx\n             }\n \n             _ => {\n                 assert!(self.rvalue_creates_operand(rvalue));\n-                let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                temp.val.store(&bcx, dest);\n-                bcx\n+                let (bx, temp) = self.trans_rvalue_operand(bx, rvalue);\n+                temp.val.store(&bx, dest);\n+                bx\n             }\n         }\n     }\n \n     pub fn trans_rvalue_operand(&mut self,\n-                                bcx: Builder<'a, 'tcx>,\n+                                bx: Builder<'a, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n                                 -> (Builder<'a, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n-                let operand = self.trans_operand(&bcx, source);\n+                let operand = self.trans_operand(&bx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n-                let cast = bcx.ccx.layout_of(self.monomorphize(&mir_cast_ty));\n+                let cast = bx.cx.layout_of(self.monomorphize(&mir_cast_ty));\n \n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.layout.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n                                 OperandValue::Immediate(\n-                                    callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n+                                    callee::resolve_and_get_fn(bx.cx, def_id, substs))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be reified to a fn ptr\", operand.layout.ty)\n@@ -207,8 +207,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         match operand.layout.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n-                                    bcx.ccx.tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n-                                OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n+                                    bx.cx.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n+                                OperandValue::Immediate(callee::get_fn(bx.cx, instance))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.layout.ty)\n@@ -230,13 +230,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                                 // HACK(eddyb) have to bitcast pointers\n                                 // until LLVM removes pointee types.\n-                                let lldata = bcx.pointercast(lldata,\n-                                    cast.scalar_pair_element_llvm_type(bcx.ccx, 0));\n+                                let lldata = bx.pointercast(lldata,\n+                                    cast.scalar_pair_element_llvm_type(bx.cx, 0));\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n-                                let (lldata, llextra) = base::unsize_thin_ptr(&bcx, lldata,\n+                                let (lldata, llextra) = base::unsize_thin_ptr(&bx, lldata,\n                                     operand.layout.ty, cast.ty);\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n@@ -249,14 +249,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::CastKind::Misc if operand.layout.is_llvm_scalar_pair() => {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n                             if cast.is_llvm_scalar_pair() {\n-                                let data_cast = bcx.pointercast(data_ptr,\n-                                    cast.scalar_pair_element_llvm_type(bcx.ccx, 0));\n+                                let data_cast = bx.pointercast(data_ptr,\n+                                    cast.scalar_pair_element_llvm_type(bx.cx, 0));\n                                 OperandValue::Pair(data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = cast.immediate_llvm_type(bcx.ccx);\n-                                let llval = bcx.pointercast(data_ptr, llcast_ty);\n+                                let llcast_ty = cast.immediate_llvm_type(bx.cx);\n+                                let llval = bx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n                         } else {\n@@ -268,8 +268,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let r_t_in = CastTy::from_ty(operand.layout.ty)\n                             .expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = operand.layout.immediate_llvm_type(bcx.ccx);\n-                        let ll_t_out = cast.immediate_llvm_type(bcx.ccx);\n+                        let ll_t_in = operand.layout.immediate_llvm_type(bx.cx);\n+                        let ll_t_out = cast.immediate_llvm_type(bx.cx);\n                         let llval = operand.immediate();\n \n                         let mut signed = false;\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     // have bound checks, and this is the most\n                                     // convenient place to put the `assume`.\n \n-                                    base::call_assume(&bcx, bcx.icmp(\n+                                    base::call_assume(&bx, bx.icmp(\n                                         llvm::IntULE,\n                                         llval,\n                                         C_uint_big(ll_t_in, scalar.valid_range.end)\n@@ -293,199 +293,199 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                         let newval = match (r_t_in, r_t_out) {\n                             (CastTy::Int(_), CastTy::Int(_)) => {\n-                                bcx.intcast(llval, ll_t_out, signed)\n+                                bx.intcast(llval, ll_t_out, signed)\n                             }\n                             (CastTy::Float, CastTy::Float) => {\n                                 let srcsz = ll_t_in.float_width();\n                                 let dstsz = ll_t_out.float_width();\n                                 if dstsz > srcsz {\n-                                    bcx.fpext(llval, ll_t_out)\n+                                    bx.fpext(llval, ll_t_out)\n                                 } else if srcsz > dstsz {\n-                                    bcx.fptrunc(llval, ll_t_out)\n+                                    bx.fptrunc(llval, ll_t_out)\n                                 } else {\n                                     llval\n                                 }\n                             }\n                             (CastTy::Ptr(_), CastTy::Ptr(_)) |\n                             (CastTy::FnPtr, CastTy::Ptr(_)) |\n                             (CastTy::RPtr(_), CastTy::Ptr(_)) =>\n-                                bcx.pointercast(llval, ll_t_out),\n+                                bx.pointercast(llval, ll_t_out),\n                             (CastTy::Ptr(_), CastTy::Int(_)) |\n                             (CastTy::FnPtr, CastTy::Int(_)) =>\n-                                bcx.ptrtoint(llval, ll_t_out),\n+                                bx.ptrtoint(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                let usize_llval = bcx.intcast(llval, bcx.ccx.isize_ty(), signed);\n-                                bcx.inttoptr(usize_llval, ll_t_out)\n+                                let usize_llval = bx.intcast(llval, bx.cx.isize_ty, signed);\n+                                bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Int(_), CastTy::Float) =>\n-                                cast_int_to_float(&bcx, signed, llval, ll_t_in, ll_t_out),\n+                                cast_int_to_float(&bx, signed, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(IntTy::I)) =>\n-                                cast_float_to_int(&bcx, true, llval, ll_t_in, ll_t_out),\n+                                cast_float_to_int(&bx, true, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n-                                cast_float_to_int(&bcx, false, llval, ll_t_in, ll_t_out),\n+                                cast_float_to_int(&bx, false, llval, ll_t_in, ll_t_out),\n                             _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.layout.ty, cast.ty)\n                         };\n                         OperandValue::Immediate(newval)\n                     }\n                 };\n-                (bcx, OperandRef {\n+                (bx, OperandRef {\n                     val,\n                     layout: cast\n                 })\n             }\n \n             mir::Rvalue::Ref(_, bk, ref place) => {\n-                let tr_place = self.trans_place(&bcx, place);\n+                let tr_place = self.trans_place(&bx, place);\n \n                 let ty = tr_place.layout.ty;\n \n                 // Note: places are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                let val = if !bcx.ccx.shared().type_has_metadata(ty) {\n+                let val = if !bx.cx.type_has_metadata(ty) {\n                     OperandValue::Immediate(tr_place.llval)\n                 } else {\n                     OperandValue::Pair(tr_place.llval, tr_place.llextra)\n                 };\n-                (bcx, OperandRef {\n+                (bx, OperandRef {\n                     val,\n-                    layout: self.ccx.layout_of(self.ccx.tcx().mk_ref(\n-                        self.ccx.tcx().types.re_erased,\n+                    layout: self.cx.layout_of(self.cx.tcx.mk_ref(\n+                        self.cx.tcx.types.re_erased,\n                         ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n                     )),\n                 })\n             }\n \n             mir::Rvalue::Len(ref place) => {\n-                let size = self.evaluate_array_len(&bcx, place);\n+                let size = self.evaluate_array_len(&bx, place);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n-                    layout: bcx.ccx.layout_of(bcx.tcx().types.usize),\n+                    layout: bx.cx.layout_of(bx.tcx().types.usize),\n                 };\n-                (bcx, operand)\n+                (bx, operand)\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.trans_operand(&bcx, lhs);\n-                let rhs = self.trans_operand(&bcx, rhs);\n+                let lhs = self.trans_operand(&bx, lhs);\n+                let rhs = self.trans_operand(&bx, rhs);\n                 let llresult = match (lhs.val, rhs.val) {\n                     (OperandValue::Pair(lhs_addr, lhs_extra),\n                      OperandValue::Pair(rhs_addr, rhs_extra)) => {\n-                        self.trans_fat_ptr_binop(&bcx, op,\n+                        self.trans_fat_ptr_binop(&bx, op,\n                                                  lhs_addr, lhs_extra,\n                                                  rhs_addr, rhs_extra,\n                                                  lhs.layout.ty)\n                     }\n \n                     (OperandValue::Immediate(lhs_val),\n                      OperandValue::Immediate(rhs_val)) => {\n-                        self.trans_scalar_binop(&bcx, op, lhs_val, rhs_val, lhs.layout.ty)\n+                        self.trans_scalar_binop(&bx, op, lhs_val, rhs_val, lhs.layout.ty)\n                     }\n \n                     _ => bug!()\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    layout: bcx.ccx.layout_of(\n-                        op.ty(bcx.tcx(), lhs.layout.ty, rhs.layout.ty)),\n+                    layout: bx.cx.layout_of(\n+                        op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty)),\n                 };\n-                (bcx, operand)\n+                (bx, operand)\n             }\n             mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs = self.trans_operand(&bcx, lhs);\n-                let rhs = self.trans_operand(&bcx, rhs);\n-                let result = self.trans_scalar_checked_binop(&bcx, op,\n+                let lhs = self.trans_operand(&bx, lhs);\n+                let rhs = self.trans_operand(&bx, rhs);\n+                let result = self.trans_scalar_checked_binop(&bx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n                                                              lhs.layout.ty);\n-                let val_ty = op.ty(bcx.tcx(), lhs.layout.ty, rhs.layout.ty);\n-                let operand_ty = bcx.tcx().intern_tup(&[val_ty, bcx.tcx().types.bool], false);\n+                let val_ty = op.ty(bx.tcx(), lhs.layout.ty, rhs.layout.ty);\n+                let operand_ty = bx.tcx().intern_tup(&[val_ty, bx.tcx().types.bool], false);\n                 let operand = OperandRef {\n                     val: result,\n-                    layout: bcx.ccx.layout_of(operand_ty)\n+                    layout: bx.cx.layout_of(operand_ty)\n                 };\n \n-                (bcx, operand)\n+                (bx, operand)\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n-                let operand = self.trans_operand(&bcx, operand);\n+                let operand = self.trans_operand(&bx, operand);\n                 let lloperand = operand.immediate();\n                 let is_float = operand.layout.ty.is_fp();\n                 let llval = match op {\n-                    mir::UnOp::Not => bcx.not(lloperand),\n+                    mir::UnOp::Not => bx.not(lloperand),\n                     mir::UnOp::Neg => if is_float {\n-                        bcx.fneg(lloperand)\n+                        bx.fneg(lloperand)\n                     } else {\n-                        bcx.neg(lloperand)\n+                        bx.neg(lloperand)\n                     }\n                 };\n-                (bcx, OperandRef {\n+                (bx, OperandRef {\n                     val: OperandValue::Immediate(llval),\n                     layout: operand.layout,\n                 })\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(&*self.mir, bcx.tcx());\n-                let discr =  self.trans_place(&bcx, place)\n-                    .trans_get_discr(&bcx, discr_ty);\n-                (bcx, OperandRef {\n+                let discr_ty = rvalue.ty(&*self.mir, bx.tcx());\n+                let discr =  self.trans_place(&bx, place)\n+                    .trans_get_discr(&bx, discr_ty);\n+                (bx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n-                    layout: self.ccx.layout_of(discr_ty)\n+                    layout: self.cx.layout_of(discr_ty)\n                 })\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                assert!(bcx.ccx.shared().type_is_sized(ty));\n-                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty).bytes());\n-                let tcx = bcx.tcx();\n-                (bcx, OperandRef {\n+                assert!(bx.cx.type_is_sized(ty));\n+                let val = C_usize(bx.cx, bx.cx.size_of(ty).bytes());\n+                let tcx = bx.tcx();\n+                (bx, OperandRef {\n                     val: OperandValue::Immediate(val),\n-                    layout: self.ccx.layout_of(tcx.types.usize),\n+                    layout: self.cx.layout_of(tcx.types.usize),\n                 })\n             }\n \n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n-                let (size, align) = bcx.ccx.size_and_align_of(content_ty);\n-                let llsize = C_usize(bcx.ccx, size.bytes());\n-                let llalign = C_usize(bcx.ccx, align.abi());\n-                let box_layout = bcx.ccx.layout_of(bcx.tcx().mk_box(content_ty));\n-                let llty_ptr = box_layout.llvm_type(bcx.ccx);\n+                let (size, align) = bx.cx.size_and_align_of(content_ty);\n+                let llsize = C_usize(bx.cx, size.bytes());\n+                let llalign = C_usize(bx.cx, align.abi());\n+                let box_layout = bx.cx.layout_of(bx.tcx().mk_box(content_ty));\n+                let llty_ptr = box_layout.llvm_type(bx.cx);\n \n                 // Allocate space:\n-                let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n+                let def_id = match bx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => {\n-                        bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n+                        bx.sess().fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n                     }\n                 };\n-                let instance = ty::Instance::mono(bcx.tcx(), def_id);\n-                let r = callee::get_fn(bcx.ccx, instance);\n-                let val = bcx.pointercast(bcx.call(r, &[llsize, llalign], None), llty_ptr);\n+                let instance = ty::Instance::mono(bx.tcx(), def_id);\n+                let r = callee::get_fn(bx.cx, instance);\n+                let val = bx.pointercast(bx.call(r, &[llsize, llalign], None), llty_ptr);\n \n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(val),\n                     layout: box_layout,\n                 };\n-                (bcx, operand)\n+                (bx, operand)\n             }\n             mir::Rvalue::Use(ref operand) => {\n-                let operand = self.trans_operand(&bcx, operand);\n-                (bcx, operand)\n+                let operand = self.trans_operand(&bx, operand);\n+                (bx, operand)\n             }\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(self.mir, self.ccx.tcx());\n-                (bcx, OperandRef::new_zst(self.ccx,\n-                    self.ccx.layout_of(self.monomorphize(&ty))))\n+                let ty = rvalue.ty(self.mir, self.cx.tcx);\n+                (bx, OperandRef::new_zst(self.cx,\n+                    self.cx.layout_of(self.monomorphize(&ty))))\n             }\n         }\n     }\n \n     fn evaluate_array_len(&mut self,\n-                          bcx: &Builder<'a, 'tcx>,\n+                          bx: &Builder<'a, 'tcx>,\n                           place: &mir::Place<'tcx>) -> ValueRef\n     {\n         // ZST are passed as operands and require special handling\n@@ -494,17 +494,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::TyArray(_, n) = op.layout.ty.sty {\n                     let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-                    return common::C_usize(bcx.ccx, n);\n+                    return common::C_usize(bx.cx, n);\n                 }\n             }\n         }\n         // use common size calculation for non zero-sized types\n-        let tr_value = self.trans_place(&bcx, place);\n-        return tr_value.len(bcx.ccx);\n+        let tr_value = self.trans_place(&bx, place);\n+        return tr_value.len(bx.cx);\n     }\n \n     pub fn trans_scalar_binop(&mut self,\n-                              bcx: &Builder<'a, 'tcx>,\n+                              bx: &Builder<'a, 'tcx>,\n                               op: mir::BinOp,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n@@ -515,63 +515,63 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let is_bool = input_ty.is_bool();\n         match op {\n             mir::BinOp::Add => if is_float {\n-                bcx.fadd(lhs, rhs)\n+                bx.fadd(lhs, rhs)\n             } else {\n-                bcx.add(lhs, rhs)\n+                bx.add(lhs, rhs)\n             },\n             mir::BinOp::Sub => if is_float {\n-                bcx.fsub(lhs, rhs)\n+                bx.fsub(lhs, rhs)\n             } else {\n-                bcx.sub(lhs, rhs)\n+                bx.sub(lhs, rhs)\n             },\n             mir::BinOp::Mul => if is_float {\n-                bcx.fmul(lhs, rhs)\n+                bx.fmul(lhs, rhs)\n             } else {\n-                bcx.mul(lhs, rhs)\n+                bx.mul(lhs, rhs)\n             },\n             mir::BinOp::Div => if is_float {\n-                bcx.fdiv(lhs, rhs)\n+                bx.fdiv(lhs, rhs)\n             } else if is_signed {\n-                bcx.sdiv(lhs, rhs)\n+                bx.sdiv(lhs, rhs)\n             } else {\n-                bcx.udiv(lhs, rhs)\n+                bx.udiv(lhs, rhs)\n             },\n             mir::BinOp::Rem => if is_float {\n-                bcx.frem(lhs, rhs)\n+                bx.frem(lhs, rhs)\n             } else if is_signed {\n-                bcx.srem(lhs, rhs)\n+                bx.srem(lhs, rhs)\n             } else {\n-                bcx.urem(lhs, rhs)\n+                bx.urem(lhs, rhs)\n             },\n-            mir::BinOp::BitOr => bcx.or(lhs, rhs),\n-            mir::BinOp::BitAnd => bcx.and(lhs, rhs),\n-            mir::BinOp::BitXor => bcx.xor(lhs, rhs),\n-            mir::BinOp::Offset => bcx.inbounds_gep(lhs, &[rhs]),\n-            mir::BinOp::Shl => common::build_unchecked_lshift(bcx, lhs, rhs),\n-            mir::BinOp::Shr => common::build_unchecked_rshift(bcx, input_ty, lhs, rhs),\n+            mir::BinOp::BitOr => bx.or(lhs, rhs),\n+            mir::BinOp::BitAnd => bx.and(lhs, rhs),\n+            mir::BinOp::BitXor => bx.xor(lhs, rhs),\n+            mir::BinOp::Offset => bx.inbounds_gep(lhs, &[rhs]),\n+            mir::BinOp::Shl => common::build_unchecked_lshift(bx, lhs, rhs),\n+            mir::BinOp::Shr => common::build_unchecked_rshift(bx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_nil {\n-                C_bool(bcx.ccx, match op {\n+                C_bool(bx.cx, match op {\n                     mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n                     mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n                     _ => unreachable!()\n                 })\n             } else if is_float {\n-                bcx.fcmp(\n+                bx.fcmp(\n                     base::bin_op_to_fcmp_predicate(op.to_hir_binop()),\n                     lhs, rhs\n                 )\n             } else {\n                 let (lhs, rhs) = if is_bool {\n                     // FIXME(#36856) -- extend the bools into `i8` because\n                     // LLVM's i1 comparisons are broken.\n-                    (bcx.zext(lhs, Type::i8(bcx.ccx)),\n-                     bcx.zext(rhs, Type::i8(bcx.ccx)))\n+                    (bx.zext(lhs, Type::i8(bx.cx)),\n+                     bx.zext(rhs, Type::i8(bx.cx)))\n                 } else {\n                     (lhs, rhs)\n                 };\n \n-                bcx.icmp(\n+                bx.icmp(\n                     base::bin_op_to_icmp_predicate(op.to_hir_binop(), is_signed),\n                     lhs, rhs\n                 )\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_fat_ptr_binop(&mut self,\n-                               bcx: &Builder<'a, 'tcx>,\n+                               bx: &Builder<'a, 'tcx>,\n                                op: mir::BinOp,\n                                lhs_addr: ValueRef,\n                                lhs_extra: ValueRef,\n@@ -590,15 +590,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                -> ValueRef {\n         match op {\n             mir::BinOp::Eq => {\n-                bcx.and(\n-                    bcx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n-                    bcx.icmp(llvm::IntEQ, lhs_extra, rhs_extra)\n+                bx.and(\n+                    bx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n+                    bx.icmp(llvm::IntEQ, lhs_extra, rhs_extra)\n                 )\n             }\n             mir::BinOp::Ne => {\n-                bcx.or(\n-                    bcx.icmp(llvm::IntNE, lhs_addr, rhs_addr),\n-                    bcx.icmp(llvm::IntNE, lhs_extra, rhs_extra)\n+                bx.or(\n+                    bx.icmp(llvm::IntNE, lhs_addr, rhs_addr),\n+                    bx.icmp(llvm::IntNE, lhs_extra, rhs_extra)\n                 )\n             }\n             mir::BinOp::Le | mir::BinOp::Lt |\n@@ -612,11 +612,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => bug!(),\n                 };\n \n-                bcx.or(\n-                    bcx.icmp(strict_op, lhs_addr, rhs_addr),\n-                    bcx.and(\n-                        bcx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n-                        bcx.icmp(op, lhs_extra, rhs_extra)\n+                bx.or(\n+                    bx.icmp(strict_op, lhs_addr, rhs_addr),\n+                    bx.and(\n+                        bx.icmp(llvm::IntEQ, lhs_addr, rhs_addr),\n+                        bx.icmp(op, lhs_extra, rhs_extra)\n                     )\n                 )\n             }\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_scalar_checked_binop(&mut self,\n-                                      bcx: &Builder<'a, 'tcx>,\n+                                      bx: &Builder<'a, 'tcx>,\n                                       op: mir::BinOp,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -636,17 +636,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // with #[rustc_inherit_overflow_checks] and inlined from\n         // another crate (mostly core::num generic/#[inline] fns),\n         // while the current crate doesn't use overflow checks.\n-        if !bcx.ccx.check_overflow() {\n-            let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, C_bool(bcx.ccx, false));\n+        if !bx.cx.check_overflow {\n+            let val = self.trans_scalar_binop(bx, op, lhs, rhs, input_ty);\n+            return OperandValue::Pair(val, C_bool(bx.cx, false));\n         }\n \n         // First try performing the operation on constants, which\n         // will only succeed if both operands are constant.\n         // This is necessary to determine when an overflow Assert\n         // will always panic at runtime, and produce a warning.\n-        if let Some((val, of)) = const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n-            return OperandValue::Pair(val, C_bool(bcx.ccx, of));\n+        if let Some((val, of)) = const_scalar_checked_binop(bx.tcx(), op, lhs, rhs, input_ty) {\n+            return OperandValue::Pair(val, C_bool(bx.cx, of));\n         }\n \n         let (val, of) = match op {\n@@ -658,20 +658,20 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::BinOp::Mul => OverflowOp::Mul,\n                     _ => unreachable!()\n                 };\n-                let intrinsic = get_overflow_intrinsic(oop, bcx, input_ty);\n-                let res = bcx.call(intrinsic, &[lhs, rhs], None);\n+                let intrinsic = get_overflow_intrinsic(oop, bx, input_ty);\n+                let res = bx.call(intrinsic, &[lhs, rhs], None);\n \n-                (bcx.extract_value(res, 0),\n-                 bcx.extract_value(res, 1))\n+                (bx.extract_value(res, 0),\n+                 bx.extract_value(res, 1))\n             }\n             mir::BinOp::Shl | mir::BinOp::Shr => {\n                 let lhs_llty = val_ty(lhs);\n                 let rhs_llty = val_ty(rhs);\n-                let invert_mask = common::shift_mask_val(&bcx, lhs_llty, rhs_llty, true);\n-                let outer_bits = bcx.and(rhs, invert_mask);\n+                let invert_mask = common::shift_mask_val(&bx, lhs_llty, rhs_llty, true);\n+                let outer_bits = bx.and(rhs, invert_mask);\n \n-                let of = bcx.icmp(llvm::IntNE, outer_bits, C_null(rhs_llty));\n-                let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n+                let of = bx.icmp(llvm::IntNE, outer_bits, C_null(rhs_llty));\n+                let val = self.trans_scalar_binop(bx, op, lhs, rhs, input_ty);\n \n                 (val, of)\n             }\n@@ -697,9 +697,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(self.mir, self.ccx.tcx());\n+                let ty = rvalue.ty(self.mir, self.cx.tcx);\n                 let ty = self.monomorphize(&ty);\n-                self.ccx.layout_of(ty).is_zst()\n+                self.cx.layout_of(ty).is_zst()\n             }\n         }\n \n@@ -712,12 +712,12 @@ enum OverflowOp {\n     Add, Sub, Mul\n }\n \n-fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n+fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder, ty: Ty) -> ValueRef {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{TyInt, TyUint};\n \n-    let tcx = bcx.tcx();\n+    let tcx = bx.tcx();\n \n     let new_sty = match ty.sty {\n         TyInt(Isize) => match &tcx.sess.target.target.target_pointer_width[..] {\n@@ -784,10 +784,10 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n         },\n     };\n \n-    bcx.ccx.get_intrinsic(&name)\n+    bx.cx.get_intrinsic(&name)\n }\n \n-fn cast_int_to_float(bcx: &Builder,\n+fn cast_int_to_float(bx: &Builder,\n                      signed: bool,\n                      x: ValueRef,\n                      int_ty: Type,\n@@ -800,31 +800,31 @@ fn cast_int_to_float(bcx: &Builder,\n         // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n         // and for everything else LLVM's uitofp works just fine.\n         let max = C_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n-        let overflow = bcx.icmp(llvm::IntUGE, x, max);\n-        let infinity_bits = C_u32(bcx.ccx, ieee::Single::INFINITY.to_bits() as u32);\n+        let overflow = bx.icmp(llvm::IntUGE, x, max);\n+        let infinity_bits = C_u32(bx.cx, ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);\n-        bcx.select(overflow, infinity, bcx.uitofp(x, float_ty))\n+        bx.select(overflow, infinity, bx.uitofp(x, float_ty))\n     } else {\n         if signed {\n-            bcx.sitofp(x, float_ty)\n+            bx.sitofp(x, float_ty)\n         } else {\n-            bcx.uitofp(x, float_ty)\n+            bx.uitofp(x, float_ty)\n         }\n     }\n }\n \n-fn cast_float_to_int(bcx: &Builder,\n+fn cast_float_to_int(bx: &Builder,\n                      signed: bool,\n                      x: ValueRef,\n                      float_ty: Type,\n                      int_ty: Type) -> ValueRef {\n     let fptosui_result = if signed {\n-        bcx.fptosi(x, int_ty)\n+        bx.fptosi(x, int_ty)\n     } else {\n-        bcx.fptoui(x, int_ty)\n+        bx.fptoui(x, int_ty)\n     };\n \n-    if !bcx.sess().opts.debugging_opts.saturating_float_casts {\n+    if !bx.sess().opts.debugging_opts.saturating_float_casts {\n         return fptosui_result;\n     }\n     // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n@@ -870,8 +870,8 @@ fn cast_float_to_int(bcx: &Builder,\n     }\n     let float_bits_to_llval = |bits| {\n         let bits_llval = match float_ty.float_width() {\n-            32 => C_u32(bcx.ccx, bits as u32),\n-            64 => C_u64(bcx.ccx, bits as u64),\n+            32 => C_u32(bx.cx, bits as u32),\n+            64 => C_u64(bx.cx, bits as u64),\n             n => bug!(\"unsupported float width {}\", n),\n         };\n         consts::bitcast(bits_llval, float_ty)\n@@ -924,19 +924,19 @@ fn cast_float_to_int(bcx: &Builder,\n     // negation, and the negation can be merged into the select. Therefore, it not necessarily any\n     // more expensive than a ordered (\"normal\") comparison. Whether these optimizations will be\n     // performed is ultimately up to the backend, but at least x86 does perform them.\n-    let less_or_nan = bcx.fcmp(llvm::RealULT, x, f_min);\n-    let greater = bcx.fcmp(llvm::RealOGT, x, f_max);\n+    let less_or_nan = bx.fcmp(llvm::RealULT, x, f_min);\n+    let greater = bx.fcmp(llvm::RealOGT, x, f_max);\n     let int_max = C_uint_big(int_ty, int_max(signed, int_ty));\n     let int_min = C_uint_big(int_ty, int_min(signed, int_ty) as u128);\n-    let s0 = bcx.select(less_or_nan, int_min, fptosui_result);\n-    let s1 = bcx.select(greater, int_max, s0);\n+    let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n+    let s1 = bx.select(greater, int_max, s0);\n \n     // Step 3: NaN replacement.\n     // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n     // Therefore we only need to execute this step for signed integer types.\n     if signed {\n         // LLVM has no isNaN predicate, so we use (x == x) instead\n-        bcx.select(bcx.fcmp(llvm::RealOEQ, x, x), s1, C_uint(int_ty, 0))\n+        bx.select(bx.fcmp(llvm::RealOEQ, x, x), s1, C_uint(int_ty, 0))\n     } else {\n         s1\n     }"}, {"sha": "b5b7484940192a9e82d24ea0d00c8c855ee4f030", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -13,28 +13,28 @@ use rustc::mir;\n use asm;\n use builder::Builder;\n \n-use super::MirContext;\n+use super::FunctionCx;\n use super::LocalRef;\n \n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n+impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n-                           bcx: Builder<'a, 'tcx>,\n+                           bx: Builder<'a, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n                            -> Builder<'a, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n-        self.set_debug_loc(&bcx, statement.source_info);\n+        self.set_debug_loc(&bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(ref place, ref rvalue) => {\n                 if let mir::Place::Local(index) = *place {\n                     match self.locals[index] {\n                         LocalRef::Place(tr_dest) => {\n-                            self.trans_rvalue(bcx, tr_dest, rvalue)\n+                            self.trans_rvalue(bx, tr_dest, rvalue)\n                         }\n                         LocalRef::Operand(None) => {\n-                            let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue);\n+                            let (bx, operand) = self.trans_rvalue_operand(bx, rvalue);\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n-                            bcx\n+                            bx\n                         }\n                         LocalRef::Operand(Some(op)) => {\n                             if !op.layout.is_zst() {\n@@ -45,46 +45,46 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                             // If the type is zero-sized, it's already been set here,\n                             // but we still need to make sure we translate the operand\n-                            self.trans_rvalue_operand(bcx, rvalue).0\n+                            self.trans_rvalue_operand(bx, rvalue).0\n                         }\n                     }\n                 } else {\n-                    let tr_dest = self.trans_place(&bcx, place);\n-                    self.trans_rvalue(bcx, tr_dest, rvalue)\n+                    let tr_dest = self.trans_place(&bx, place);\n+                    self.trans_rvalue(bx, tr_dest, rvalue)\n                 }\n             }\n             mir::StatementKind::SetDiscriminant{ref place, variant_index} => {\n-                self.trans_place(&bcx, place)\n-                    .trans_set_discr(&bcx, variant_index);\n-                bcx\n+                self.trans_place(&bx, place)\n+                    .trans_set_discr(&bx, variant_index);\n+                bx\n             }\n             mir::StatementKind::StorageLive(local) => {\n                 if let LocalRef::Place(tr_place) = self.locals[local] {\n-                    tr_place.storage_live(&bcx);\n+                    tr_place.storage_live(&bx);\n                 }\n-                bcx\n+                bx\n             }\n             mir::StatementKind::StorageDead(local) => {\n                 if let LocalRef::Place(tr_place) = self.locals[local] {\n-                    tr_place.storage_dead(&bcx);\n+                    tr_place.storage_dead(&bx);\n                 }\n-                bcx\n+                bx\n             }\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n-                    self.trans_place(&bcx, output)\n+                    self.trans_place(&bx, output)\n                 }).collect();\n \n                 let input_vals = inputs.iter().map(|input| {\n-                    self.trans_operand(&bcx, input).immediate()\n+                    self.trans_operand(&bx, input).immediate()\n                 }).collect();\n \n-                asm::trans_inline_asm(&bcx, asm, outputs, input_vals);\n-                bcx\n+                asm::trans_inline_asm(&bx, asm, outputs, input_vals);\n+                bx\n             }\n             mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Validate(..) |\n-            mir::StatementKind::Nop => bcx,\n+            mir::StatementKind::Nop => bx,\n         }\n     }\n }"}, {"sha": "cc270ab5f2d25264f9d50ca79a794105bd493fe4", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -18,7 +18,7 @@ use asm;\n use attributes;\n use base;\n use consts;\n-use context::CrateContext;\n+use context::CodegenCx;\n use declare;\n use llvm;\n use monomorphize::Instance;\n@@ -38,18 +38,18 @@ pub use rustc_mir::monomorphize::item::*;\n pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n \n pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n-    fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n+    fn define(&self, cx: &CodegenCx<'a, 'tcx>) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx()),\n+               self.to_string(cx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name());\n+               cx.codegen_unit.name());\n \n         match *self.as_mono_item() {\n             MonoItem::Static(node_id) => {\n-                let tcx = ccx.tcx();\n+                let tcx = cx.tcx;\n                 let item = tcx.hir.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, _) = item.node {\n-                    match consts::trans_static(&ccx, m, item.id, &item.attrs) {\n+                    match consts::trans_static(&cx, m, item.id, &item.attrs) {\n                         Ok(_) => { /* Cool, everything's alright. */ },\n                         Err(err) => {\n                             err.report(tcx, item.span, \"static\");\n@@ -60,51 +60,51 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                 }\n             }\n             MonoItem::GlobalAsm(node_id) => {\n-                let item = ccx.tcx().hir.expect_item(node_id);\n+                let item = cx.tcx.hir.expect_item(node_id);\n                 if let hir::ItemGlobalAsm(ref ga) = item.node {\n-                    asm::trans_global_asm(ccx, ga);\n+                    asm::trans_global_asm(cx, ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n                 }\n             }\n             MonoItem::Fn(instance) => {\n-                base::trans_instance(&ccx, instance);\n+                base::trans_instance(&cx, instance);\n             }\n         }\n \n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx()),\n+               self.to_string(cx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name());\n+               cx.codegen_unit.name());\n     }\n \n     fn predefine(&self,\n-                 ccx: &CrateContext<'a, 'tcx>,\n+                 cx: &CodegenCx<'a, 'tcx>,\n                  linkage: Linkage,\n                  visibility: Visibility) {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx()),\n+               self.to_string(cx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name());\n+               cx.codegen_unit.name());\n \n-        let symbol_name = self.symbol_name(ccx.tcx());\n+        let symbol_name = self.symbol_name(cx.tcx);\n \n         debug!(\"symbol {}\", &symbol_name);\n \n         match *self.as_mono_item() {\n             MonoItem::Static(node_id) => {\n-                predefine_static(ccx, node_id, linkage, visibility, &symbol_name);\n+                predefine_static(cx, node_id, linkage, visibility, &symbol_name);\n             }\n             MonoItem::Fn(instance) => {\n-                predefine_fn(ccx, instance, linkage, visibility, &symbol_name);\n+                predefine_fn(cx, instance, linkage, visibility, &symbol_name);\n             }\n             MonoItem::GlobalAsm(..) => {}\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n-               self.to_string(ccx.tcx()),\n+               self.to_string(cx.tcx),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name());\n+               cx.codegen_unit.name());\n     }\n \n     fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n@@ -138,18 +138,18 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n \n impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n \n-fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn predefine_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                               node_id: ast::NodeId,\n                               linkage: Linkage,\n                               visibility: Visibility,\n                               symbol_name: &str) {\n-    let def_id = ccx.tcx().hir.local_def_id(node_id);\n-    let instance = Instance::mono(ccx.tcx(), def_id);\n-    let ty = instance.ty(ccx.tcx());\n-    let llty = ccx.layout_of(ty).llvm_type(ccx);\n+    let def_id = cx.tcx.hir.local_def_id(node_id);\n+    let instance = Instance::mono(cx.tcx, def_id);\n+    let ty = instance.ty(cx.tcx);\n+    let llty = cx.layout_of(ty).llvm_type(cx);\n \n-    let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n-        ccx.sess().span_fatal(ccx.tcx().hir.span(node_id),\n+    let g = declare::define_global(cx, symbol_name, llty).unwrap_or_else(|| {\n+        cx.sess().span_fatal(cx.tcx.hir.span(node_id),\n             &format!(\"symbol `{}` is already defined\", symbol_name))\n     });\n \n@@ -158,34 +158,34 @@ fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         llvm::LLVMRustSetVisibility(g, base::visibility_to_llvm(visibility));\n     }\n \n-    ccx.instances().borrow_mut().insert(instance, g);\n-    ccx.statics().borrow_mut().insert(g, def_id);\n+    cx.instances.borrow_mut().insert(instance, g);\n+    cx.statics.borrow_mut().insert(g, def_id);\n }\n \n-fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn predefine_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                           instance: Instance<'tcx>,\n                           linkage: Linkage,\n                           visibility: Visibility,\n                           symbol_name: &str) {\n     assert!(!instance.substs.needs_infer() &&\n             !instance.substs.has_param_types());\n \n-    let mono_ty = instance.ty(ccx.tcx());\n-    let attrs = instance.def.attrs(ccx.tcx());\n-    let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n+    let mono_ty = instance.ty(cx.tcx);\n+    let attrs = instance.def.attrs(cx.tcx);\n+    let lldecl = declare::declare_fn(cx, symbol_name, mono_ty);\n     unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n-    base::set_link_section(ccx, lldecl, &attrs);\n+    base::set_link_section(cx, lldecl, &attrs);\n     if linkage == Linkage::LinkOnceODR ||\n         linkage == Linkage::WeakODR {\n-        llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n+        llvm::SetUniqueComdat(cx.llmod, lldecl);\n     }\n \n     // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n     // compiler-rt, then we want to implicitly compile everything with hidden\n     // visibility as we're going to link this object all over the place but\n     // don't want the symbols to get exported.\n     if linkage != Linkage::Internal && linkage != Linkage::Private &&\n-       attr::contains_name(ccx.tcx().hir.krate_attrs(), \"compiler_builtins\") {\n+       attr::contains_name(cx.tcx.hir.krate_attrs(), \"compiler_builtins\") {\n         unsafe {\n             llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n         }\n@@ -196,10 +196,10 @@ fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n-    if instance.def.is_inline(ccx.tcx()) {\n+    if instance.def.is_inline(cx.tcx) {\n         attributes::inline(lldecl, attributes::InlineAttr::Hint);\n     }\n-    attributes::from_fn_attrs(ccx, lldecl, instance.def.def_id());\n+    attributes::from_fn_attrs(cx, lldecl, instance.def.def_id());\n \n-    ccx.instances().borrow_mut().insert(instance, lldecl);\n+    cx.instances.borrow_mut().insert(instance, lldecl);\n }"}, {"sha": "a77acc4f1756f016de71784f726a9a9c64412302", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -14,7 +14,7 @@ use llvm;\n use llvm::{ContextRef, TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n-use context::CrateContext;\n+use context::CodegenCx;\n \n use syntax::ast;\n use rustc::ty::layout::{self, Align, Size};\n@@ -62,115 +62,115 @@ impl Type {\n         unsafe { mem::transmute(slice) }\n     }\n \n-    pub fn void(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx()))\n+    pub fn void(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMVoidTypeInContext(cx.llcx))\n     }\n \n-    pub fn metadata(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMRustMetadataTypeInContext(ccx.llcx()))\n+    pub fn metadata(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMRustMetadataTypeInContext(cx.llcx))\n     }\n \n-    pub fn i1(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx()))\n+    pub fn i1(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt1TypeInContext(cx.llcx))\n     }\n \n-    pub fn i8(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx()))\n+    pub fn i8(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(cx.llcx))\n     }\n \n     pub fn i8_llcx(llcx: ContextRef) -> Type {\n         ty!(llvm::LLVMInt8TypeInContext(llcx))\n     }\n \n-    pub fn i16(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx()))\n+    pub fn i16(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt16TypeInContext(cx.llcx))\n     }\n \n-    pub fn i32(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx()))\n+    pub fn i32(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt32TypeInContext(cx.llcx))\n     }\n \n-    pub fn i64(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n+    pub fn i64(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMInt64TypeInContext(cx.llcx))\n     }\n \n-    pub fn i128(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), 128))\n+    pub fn i128(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMIntTypeInContext(cx.llcx, 128))\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix(ccx: &CrateContext, num_bits: u64) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), num_bits as c_uint))\n+    pub fn ix(cx: &CodegenCx, num_bits: u64) -> Type {\n+        ty!(llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint))\n     }\n \n-    pub fn f32(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx()))\n+    pub fn f32(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMFloatTypeInContext(cx.llcx))\n     }\n \n-    pub fn f64(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx()))\n+    pub fn f64(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMDoubleTypeInContext(cx.llcx))\n     }\n \n-    pub fn bool(ccx: &CrateContext) -> Type {\n-        Type::i8(ccx)\n+    pub fn bool(cx: &CodegenCx) -> Type {\n+        Type::i8(cx)\n     }\n \n-    pub fn char(ccx: &CrateContext) -> Type {\n-        Type::i32(ccx)\n+    pub fn char(cx: &CodegenCx) -> Type {\n+        Type::i32(cx)\n     }\n \n-    pub fn i8p(ccx: &CrateContext) -> Type {\n-        Type::i8(ccx).ptr_to()\n+    pub fn i8p(cx: &CodegenCx) -> Type {\n+        Type::i8(cx).ptr_to()\n     }\n \n     pub fn i8p_llcx(llcx: ContextRef) -> Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn isize(ccx: &CrateContext) -> Type {\n-        match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n-            \"16\" => Type::i16(ccx),\n-            \"32\" => Type::i32(ccx),\n-            \"64\" => Type::i64(ccx),\n+    pub fn isize(cx: &CodegenCx) -> Type {\n+        match &cx.tcx.sess.target.target.target_pointer_width[..] {\n+            \"16\" => Type::i16(cx),\n+            \"32\" => Type::i32(cx),\n+            \"64\" => Type::i64(cx),\n             tws => bug!(\"Unsupported target word size for int: {}\", tws),\n         }\n     }\n \n-    pub fn c_int(ccx: &CrateContext) -> Type {\n-        match &ccx.tcx().sess.target.target.target_c_int_width[..] {\n-            \"16\" => Type::i16(ccx),\n-            \"32\" => Type::i32(ccx),\n-            \"64\" => Type::i64(ccx),\n+    pub fn c_int(cx: &CodegenCx) -> Type {\n+        match &cx.tcx.sess.target.target.target_c_int_width[..] {\n+            \"16\" => Type::i16(cx),\n+            \"32\" => Type::i32(cx),\n+            \"64\" => Type::i64(cx),\n             width => bug!(\"Unsupported target_c_int_width: {}\", width),\n         }\n     }\n \n-    pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n+    pub fn int_from_ty(cx: &CodegenCx, t: ast::IntTy) -> Type {\n         match t {\n-            ast::IntTy::Isize => ccx.isize_ty(),\n-            ast::IntTy::I8 => Type::i8(ccx),\n-            ast::IntTy::I16 => Type::i16(ccx),\n-            ast::IntTy::I32 => Type::i32(ccx),\n-            ast::IntTy::I64 => Type::i64(ccx),\n-            ast::IntTy::I128 => Type::i128(ccx),\n+            ast::IntTy::Isize => cx.isize_ty,\n+            ast::IntTy::I8 => Type::i8(cx),\n+            ast::IntTy::I16 => Type::i16(cx),\n+            ast::IntTy::I32 => Type::i32(cx),\n+            ast::IntTy::I64 => Type::i64(cx),\n+            ast::IntTy::I128 => Type::i128(cx),\n         }\n     }\n \n-    pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n+    pub fn uint_from_ty(cx: &CodegenCx, t: ast::UintTy) -> Type {\n         match t {\n-            ast::UintTy::Usize => ccx.isize_ty(),\n-            ast::UintTy::U8 => Type::i8(ccx),\n-            ast::UintTy::U16 => Type::i16(ccx),\n-            ast::UintTy::U32 => Type::i32(ccx),\n-            ast::UintTy::U64 => Type::i64(ccx),\n-            ast::UintTy::U128 => Type::i128(ccx),\n+            ast::UintTy::Usize => cx.isize_ty,\n+            ast::UintTy::U8 => Type::i8(cx),\n+            ast::UintTy::U16 => Type::i16(cx),\n+            ast::UintTy::U32 => Type::i32(cx),\n+            ast::UintTy::U64 => Type::i64(cx),\n+            ast::UintTy::U128 => Type::i128(cx),\n         }\n     }\n \n-    pub fn float_from_ty(ccx: &CrateContext, t: ast::FloatTy) -> Type {\n+    pub fn float_from_ty(cx: &CodegenCx, t: ast::FloatTy) -> Type {\n         match t {\n-            ast::FloatTy::F32 => Type::f32(ccx),\n-            ast::FloatTy::F64 => Type::f64(ccx),\n+            ast::FloatTy::F32 => Type::f32(cx),\n+            ast::FloatTy::F64 => Type::f64(cx),\n         }\n     }\n \n@@ -186,16 +186,16 @@ impl Type {\n                                    args.len() as c_uint, True))\n     }\n \n-    pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n+    pub fn struct_(cx: &CodegenCx, els: &[Type], packed: bool) -> Type {\n         let els: &[TypeRef] = Type::to_ref_slice(els);\n-        ty!(llvm::LLVMStructTypeInContext(ccx.llcx(), els.as_ptr(),\n+        ty!(llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n                                           packed as Bool))\n     }\n \n-    pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n+    pub fn named_struct(cx: &CodegenCx, name: &str) -> Type {\n         let name = CString::new(name).unwrap();\n-        ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n+        ty!(llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr()))\n     }\n \n \n@@ -265,7 +265,7 @@ impl Type {\n         }\n     }\n \n-    pub fn from_integer(cx: &CrateContext, i: layout::Integer) -> Type {\n+    pub fn from_integer(cx: &CodegenCx, i: layout::Integer) -> Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n             I8 => Type::i8(cx),\n@@ -278,23 +278,23 @@ impl Type {\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// as a conservative approximation for unknown pointee types.\n-    pub fn pointee_for_abi_align(ccx: &CrateContext, align: Align) -> Type {\n+    pub fn pointee_for_abi_align(cx: &CodegenCx, align: Align) -> Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_abi_align(ccx, align);\n-        Type::from_integer(ccx, ity)\n+        let ity = layout::Integer::approximate_abi_align(cx, align);\n+        Type::from_integer(cx, ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    pub fn padding_filler(ccx: &CrateContext, size: Size, align: Align) -> Type {\n-        let unit = layout::Integer::approximate_abi_align(ccx, align);\n+    pub fn padding_filler(cx: &CodegenCx, size: Size, align: Align) -> Type {\n+        let unit = layout::Integer::approximate_abi_align(cx, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n-        Type::array(&Type::from_integer(ccx, unit), size / unit_size)\n+        Type::array(&Type::from_integer(cx, unit), size / unit_size)\n     }\n \n-    pub fn x86_mmx(ccx: &CrateContext) -> Type {\n-        ty!(llvm::LLVMX86MMXTypeInContext(ccx.llcx()))\n+    pub fn x86_mmx(cx: &CodegenCx) -> Type {\n+        ty!(llvm::LLVMX86MMXTypeInContext(cx.llcx))\n     }\n }"}, {"sha": "b1533cfad19f524fd6e0e8baa5bb237fbbc8f0ff", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -19,7 +19,7 @@ use type_::Type;\n \n use std::fmt::Write;\n \n-fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 layout: TyLayout<'tcx>,\n                                 defer: &mut Option<(Type, TyLayout<'tcx>)>)\n                                 -> Type {\n@@ -34,19 +34,19 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // one-element SIMD vectors, so it's assumed this won't clash with\n             // much else.\n             let use_x86_mmx = count == 1 && layout.size.bits() == 64 &&\n-                (ccx.sess().target.target.arch == \"x86\" ||\n-                 ccx.sess().target.target.arch == \"x86_64\");\n+                (cx.sess().target.target.arch == \"x86\" ||\n+                 cx.sess().target.target.arch == \"x86_64\");\n             if use_x86_mmx {\n-                return Type::x86_mmx(ccx)\n+                return Type::x86_mmx(cx)\n             } else {\n-                let element = layout.scalar_llvm_type_at(ccx, element, Size::from_bytes(0));\n+                let element = layout.scalar_llvm_type_at(cx, element, Size::from_bytes(0));\n                 return Type::vector(&element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n-            return Type::struct_(ccx, &[\n-                layout.scalar_pair_element_llvm_type(ccx, 0),\n-                layout.scalar_pair_element_llvm_type(ccx, 1),\n+            return Type::struct_(cx, &[\n+                layout.scalar_pair_element_llvm_type(cx, 0),\n+                layout.scalar_pair_element_llvm_type(cx, 1),\n             ], false);\n         }\n         layout::Abi::Uninhabited |\n@@ -61,7 +61,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyForeign(..) |\n         ty::TyStr => {\n             let mut name = String::with_capacity(32);\n-            let printer = DefPathBasedNames::new(ccx.tcx(), true, true);\n+            let printer = DefPathBasedNames::new(cx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name);\n             match (&layout.ty.sty, &layout.variants) {\n                 (&ty::TyAdt(def, _), &layout::Variants::Single { index }) => {\n@@ -78,30 +78,30 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let fill = Type::padding_filler(ccx, layout.size, layout.align);\n+            let fill = Type::padding_filler(cx, layout.size, layout.align);\n             let packed = false;\n             match name {\n                 None => {\n-                    Type::struct_(ccx, &[fill], packed)\n+                    Type::struct_(cx, &[fill], packed)\n                 }\n                 Some(ref name) => {\n-                    let mut llty = Type::named_struct(ccx, name);\n+                    let mut llty = Type::named_struct(cx, name);\n                     llty.set_struct_body(&[fill], packed);\n                     llty\n                 }\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(&layout.field(ccx, 0).llvm_type(ccx), count)\n+            Type::array(&layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n                 None => {\n-                    let (llfields, packed) = struct_llfields(ccx, layout);\n-                    Type::struct_(ccx, &llfields, packed)\n+                    let (llfields, packed) = struct_llfields(cx, layout);\n+                    Type::struct_(cx, &llfields, packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = Type::named_struct(ccx, name);\n+                    let llty = Type::named_struct(cx, name);\n                     *defer = Some((llty, layout));\n                     llty\n                 }\n@@ -110,7 +110,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              layout: TyLayout<'tcx>)\n                              -> (Vec<Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n@@ -121,7 +121,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut prev_align = layout.align;\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n-        let field = layout.field(ccx, i);\n+        let field = layout.field(cx, i);\n         packed |= layout.align.abi() < field.align.abi();\n \n         let target_offset = layout.fields.offset(i as usize);\n@@ -131,10 +131,10 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let padding = target_offset - offset;\n         let padding_align = layout.align.min(prev_align).min(field.align);\n         assert_eq!(offset.abi_align(padding_align) + padding, target_offset);\n-        result.push(Type::padding_filler(ccx, padding, padding_align));\n+        result.push(Type::padding_filler(cx, padding, padding_align));\n         debug!(\"    padding before: {:?}\", padding);\n \n-        result.push(field.llvm_type(ccx));\n+        result.push(field.llvm_type(cx));\n         offset = target_offset + field.size;\n         prev_align = field.align;\n     }\n@@ -148,7 +148,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(offset.abi_align(padding_align) + padding, layout.size);\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n-        result.push(Type::padding_filler(ccx, padding, padding_align));\n+        result.push(Type::padding_filler(cx, padding, padding_align));\n         assert!(result.len() == 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n@@ -158,7 +158,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     (result, packed)\n }\n \n-impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n         self.layout_of(ty).align\n     }\n@@ -197,14 +197,14 @@ pub struct PointeeInfo {\n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn is_llvm_scalar_pair<'a>(&self) -> bool;\n-    fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n-    fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n-    fn scalar_llvm_type_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> Type;\n-    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+    fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                          index: usize) -> Type;\n     fn llvm_field_index(&self, index: usize) -> u64;\n-    fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n+    fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo>;\n }\n \n@@ -240,28 +240,28 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n-            if let Some(&llty) = ccx.scalar_lltypes().borrow().get(&self.ty) {\n+            if let Some(&llty) = cx.scalar_lltypes.borrow().get(&self.ty) {\n                 return llty;\n             }\n             let llty = match self.ty.sty {\n                 ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n                 ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    ccx.layout_of(ty).llvm_type(ccx).ptr_to()\n+                    cx.layout_of(ty).llvm_type(cx).ptr_to()\n                 }\n                 ty::TyAdt(def, _) if def.is_box() => {\n-                    ccx.layout_of(self.ty.boxed_ty()).llvm_type(ccx).ptr_to()\n+                    cx.layout_of(self.ty.boxed_ty()).llvm_type(cx).ptr_to()\n                 }\n                 ty::TyFnPtr(sig) => {\n-                    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-                    FnType::new(ccx, sig, &[]).llvm_type(ccx).ptr_to()\n+                    let sig = cx.tcx.erase_late_bound_regions_and_normalize(&sig);\n+                    FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n                 }\n-                _ => self.scalar_llvm_type_at(ccx, scalar, Size::from_bytes(0))\n+                _ => self.scalar_llvm_type_at(cx, scalar, Size::from_bytes(0))\n             };\n-            ccx.scalar_lltypes().borrow_mut().insert(self.ty, llty);\n+            cx.scalar_lltypes.borrow_mut().insert(self.ty, llty);\n             return llty;\n         }\n \n@@ -271,7 +271,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             layout::Variants::Single { index } => Some(index),\n             _ => None\n         };\n-        if let Some(&llty) = ccx.lltypes().borrow().get(&(self.ty, variant_index)) {\n+        if let Some(&llty) = cx.lltypes.borrow().get(&(self.ty, variant_index)) {\n             return llty;\n         }\n \n@@ -281,69 +281,69 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         // Make sure lifetimes are erased, to avoid generating distinct LLVM\n         // types for Rust types that only differ in the choice of lifetimes.\n-        let normal_ty = ccx.tcx().erase_regions(&self.ty);\n+        let normal_ty = cx.tcx.erase_regions(&self.ty);\n \n         let mut defer = None;\n         let llty = if self.ty != normal_ty {\n-            let mut layout = ccx.layout_of(normal_ty);\n+            let mut layout = cx.layout_of(normal_ty);\n             if let Some(v) = variant_index {\n-                layout = layout.for_variant(ccx, v);\n+                layout = layout.for_variant(cx, v);\n             }\n-            layout.llvm_type(ccx)\n+            layout.llvm_type(cx)\n         } else {\n-            uncached_llvm_type(ccx, *self, &mut defer)\n+            uncached_llvm_type(cx, *self, &mut defer)\n         };\n         debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n \n-        ccx.lltypes().borrow_mut().insert((self.ty, variant_index), llty);\n+        cx.lltypes.borrow_mut().insert((self.ty, variant_index), llty);\n \n         if let Some((mut llty, layout)) = defer {\n-            let (llfields, packed) = struct_llfields(ccx, layout);\n+            let (llfields, packed) = struct_llfields(cx, layout);\n             llty.set_struct_body(&llfields, packed)\n         }\n \n         llty\n     }\n \n-    fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n-                return Type::i1(ccx);\n+                return Type::i1(cx);\n             }\n         }\n-        self.llvm_type(ccx)\n+        self.llvm_type(cx)\n     }\n \n-    fn scalar_llvm_type_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+    fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> Type {\n         match scalar.value {\n-            layout::Int(i, _) => Type::from_integer(ccx, i),\n-            layout::F32 => Type::f32(ccx),\n-            layout::F64 => Type::f64(ccx),\n+            layout::Int(i, _) => Type::from_integer(cx, i),\n+            layout::F32 => Type::f32(cx),\n+            layout::F64 => Type::f64(cx),\n             layout::Pointer => {\n                 // If we know the alignment, pick something better than i8.\n-                let pointee = if let Some(pointee) = self.pointee_info_at(ccx, offset) {\n-                    Type::pointee_for_abi_align(ccx, pointee.align)\n+                let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n+                    Type::pointee_for_abi_align(cx, pointee.align)\n                 } else {\n-                    Type::i8(ccx)\n+                    Type::i8(cx)\n                 };\n                 pointee.ptr_to()\n             }\n         }\n     }\n \n-    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+    fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                          index: usize) -> Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.sty {\n             ty::TyRef(..) |\n             ty::TyRawPtr(_) => {\n-                return self.field(ccx, index).llvm_type(ccx);\n+                return self.field(cx, index).llvm_type(cx);\n             }\n             ty::TyAdt(def, _) if def.is_box() => {\n-                let ptr_ty = ccx.tcx().mk_mut_ptr(self.ty.boxed_ty());\n-                return ccx.layout_of(ptr_ty).scalar_pair_element_llvm_type(ccx, index);\n+                let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n+                return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index);\n             }\n             _ => {}\n         }\n@@ -362,15 +362,15 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         // load/store `bool` as `i8` to avoid crippling LLVM optimizations,\n         // `i1` in a LLVM aggregate is valid and mostly equivalent to `i8`.\n         if scalar.is_bool() {\n-            return Type::i1(ccx);\n+            return Type::i1(cx);\n         }\n \n         let offset = if index == 0 {\n             Size::from_bytes(0)\n         } else {\n-            a.value.size(ccx).abi_align(b.value.align(ccx))\n+            a.value.size(cx).abi_align(b.value.align(cx))\n         };\n-        self.scalar_llvm_type_at(ccx, scalar, offset)\n+        self.scalar_llvm_type_at(cx, scalar, offset)\n     }\n \n     fn llvm_field_index(&self, index: usize) -> u64 {\n@@ -396,16 +396,16 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n+    fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo> {\n-        if let Some(&pointee) = ccx.pointee_infos().borrow().get(&(self.ty, offset)) {\n+        if let Some(&pointee) = cx.pointee_infos.borrow().get(&(self.ty, offset)) {\n             return pointee;\n         }\n \n         let mut result = None;\n         match self.ty.sty {\n             ty::TyRawPtr(mt) if offset.bytes() == 0 => {\n-                let (size, align) = ccx.size_and_align_of(mt.ty);\n+                let (size, align) = cx.size_and_align_of(mt.ty);\n                 result = Some(PointeeInfo {\n                     size,\n                     align,\n@@ -414,17 +414,17 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             }\n \n             ty::TyRef(_, mt) if offset.bytes() == 0 => {\n-                let (size, align) = ccx.size_and_align_of(mt.ty);\n+                let (size, align) = cx.size_and_align_of(mt.ty);\n \n                 let kind = match mt.mutbl {\n-                    hir::MutImmutable => if ccx.shared().type_is_freeze(mt.ty) {\n+                    hir::MutImmutable => if cx.type_is_freeze(mt.ty) {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared\n                     },\n                     hir::MutMutable => {\n-                        if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n-                           ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n+                        if cx.tcx.sess.opts.debugging_opts.mutable_noalias ||\n+                           cx.tcx.sess.panic_strategy() == PanicStrategy::Abort {\n                             PointerKind::UniqueBorrowed\n                         } else {\n                             PointerKind::Shared\n@@ -454,7 +454,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         // niches than just null (e.g. the first page\n                         // of the address space, or unaligned pointers).\n                         if self.fields.offset(0) == offset {\n-                            Some(self.for_variant(ccx, dataful_variant))\n+                            Some(self.for_variant(cx, dataful_variant))\n                         } else {\n                             None\n                         }\n@@ -470,14 +470,14 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 }\n \n                 if let Some(variant) = data_variant {\n-                    let ptr_end = offset + layout::Pointer.size(ccx);\n+                    let ptr_end = offset + layout::Pointer.size(cx);\n                     for i in 0..variant.fields.count() {\n                         let field_start = variant.fields.offset(i);\n                         if field_start <= offset {\n-                            let field = variant.field(ccx, i);\n+                            let field = variant.field(cx, i);\n                             if ptr_end <= field_start + field.size {\n                                 // We found the right field, look inside it.\n-                                result = field.pointee_info_at(ccx, offset - field_start);\n+                                result = field.pointee_info_at(cx, offset - field_start);\n                                 break;\n                             }\n                         }\n@@ -495,7 +495,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             }\n         }\n \n-        ccx.pointee_infos().borrow_mut().insert((self.ty, offset), result);\n+        cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n         result\n     }\n }"}, {"sha": "54a73a04bfa9ed9a41560dad718c16ccc32eab23", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/da569fa9ddf8369a9809184d43c600dc06bd4b4d/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=da569fa9ddf8369a9809184d43c600dc06bd4b4d", "patch": "@@ -746,10 +746,6 @@ LLVMRustSetDataLayoutFromTargetMachine(LLVMModuleRef Module,\n   unwrap(Module)->setDataLayout(Target->createDataLayout());\n }\n \n-extern \"C\" LLVMTargetDataRef LLVMRustGetModuleDataLayout(LLVMModuleRef M) {\n-  return wrap(&unwrap(M)->getDataLayout());\n-}\n-\n extern \"C\" void LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n   unwrap(M)->setPIELevel(PIELevel::Level::Large);\n }"}]}