{"sha": "58a81a68edb605dabe5f1aa04a087e412ad73936", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YTgxYTY4ZWRiNjA1ZGFiZTVmMWFhMDRhMDg3ZTQxMmFkNzM5MzY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-16T13:41:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-16T21:18:38Z"}, "message": "Finish resolving and calling of crate-external impls\n\nIssue #1227", "tree": {"sha": "66ea1ecac1c2f5c156654f16b43ddfef0d25237a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66ea1ecac1c2f5c156654f16b43ddfef0d25237a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58a81a68edb605dabe5f1aa04a087e412ad73936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58a81a68edb605dabe5f1aa04a087e412ad73936", "html_url": "https://github.com/rust-lang/rust/commit/58a81a68edb605dabe5f1aa04a087e412ad73936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58a81a68edb605dabe5f1aa04a087e412ad73936/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd9693f211f65d4c69a2e65c3e33ccc337d7f695", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9693f211f65d4c69a2e65c3e33ccc337d7f695", "html_url": "https://github.com/rust-lang/rust/commit/dd9693f211f65d4c69a2e65c3e33ccc337d7f695"}], "stats": {"total": 272, "additions": 196, "deletions": 76}, "files": [{"sha": "c87fff86bb905e038b8803bacb95cfb1528494b8", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=58a81a68edb605dabe5f1aa04a087e412ad73936", "patch": "@@ -497,7 +497,7 @@ fn build_session(sopts: @session::options) -> session::session {\n         sopts.target_triple,\n         sopts.addl_lib_search_paths);\n     ret session::session(target_cfg, sopts, cstore,\n-                         @{cm: codemap::new_codemap(), mutable next_id: 0},\n+                         @{cm: codemap::new_codemap(), mutable next_id: 1},\n                          none, 0u, filesearch, false);\n }\n "}, {"sha": "81bd90a0a4199c8e68b2811b2fed429485f93947", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=58a81a68edb605dabe5f1aa04a087e412ad73936", "patch": "@@ -2,13 +2,15 @@\n \n import syntax::ast;\n import middle::ty;\n-import option;\n+import option::{some, none};\n import driver::session;\n \n export get_symbol;\n export get_type_param_count;\n export lookup_defs;\n export get_tag_variants;\n+export get_impls_for_mod;\n+export get_impl_methods;\n export get_type;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n@@ -56,15 +58,38 @@ fn get_tag_variants(tcx: ty::ctxt, def: ast::def_id) -> [ty::variant_info] {\n     let cstore = tcx.sess.get_cstore();\n     let cnum = def.crate;\n     let cdata = cstore::get_crate_data(cstore, cnum).data;\n-    let resolver = bind translate_def_id(tcx.sess, cnum, _);\n+    let resolver = bind translate_def_id(cstore, cnum, _);\n     ret decoder::get_tag_variants(cdata, def, tcx, resolver)\n }\n \n+fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n+                     name: option::t<ast::ident>)\n+    -> [@middle::resolve::_impl] {\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    let result = [];\n+    for did in decoder::get_impls_for_mod(cdata, def.node, def.crate) {\n+        let nm = decoder::lookup_item_name(cdata, did.node);\n+        if alt name { some(n) { n == nm } none. { true } } {\n+            result += [@{did: did,\n+                         ident: nm,\n+                         methods: decoder::lookup_impl_methods(\n+                             cdata, did.node, did.crate)}];\n+        }\n+    }\n+    result\n+}\n+\n+fn get_impl_methods(cstore: cstore::cstore, def: ast::def_id)\n+    -> [@middle::resolve::method_info] {\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    decoder::lookup_impl_methods(cdata, def.node, def.crate)\n+}\n+\n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_kinds_and_ty {\n     let cstore = tcx.sess.get_cstore();\n     let cnum = def.crate;\n     let cdata = cstore::get_crate_data(cstore, cnum).data;\n-    let resolver = bind translate_def_id(tcx.sess, cnum, _);\n+    let resolver = bind translate_def_id(cstore, cnum, _);\n     decoder::get_type(cdata, def, tcx, resolver)\n }\n \n@@ -73,7 +98,7 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_kinds_and_ty {\n // external crates - if those types further refer to types in other crates\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n-fn translate_def_id(sess: session::session, searched_crate: ast::crate_num,\n+fn translate_def_id(cstore: cstore::cstore, searched_crate: ast::crate_num,\n                     def_id: ast::def_id) -> ast::def_id {\n \n     let ext_cnum = def_id.crate;\n@@ -82,13 +107,12 @@ fn translate_def_id(sess: session::session, searched_crate: ast::crate_num,\n     assert (searched_crate != ast::local_crate);\n     assert (ext_cnum != ast::local_crate);\n \n-    let cstore = sess.get_cstore();\n     let cmeta = cstore::get_crate_data(cstore, searched_crate);\n \n     let local_cnum =\n         alt cmeta.cnum_map.find(ext_cnum) {\n           option::some(n) { n }\n-          option::none. { sess.bug(\"didn't find a crate in the cnum_map\") }\n+          option::none. { fail \"didn't find a crate in the cnum_map\"; }\n         };\n \n     ret {crate: local_cnum, node: node_id};"}, {"sha": "9428d420270a8c58733dd71e1f43d5f89cb3a92f", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=58a81a68edb605dabe5f1aa04a087e412ad73936", "patch": "@@ -16,14 +16,16 @@ export get_type;\n export get_type_param_count;\n export get_type_param_kinds;\n export lookup_def;\n+export lookup_item_name;\n export resolve_path;\n export get_crate_attributes;\n export list_crate_metadata;\n export crate_dep;\n export get_crate_deps;\n export get_crate_hash;\n export external_resolver;\n-\n+export get_impls_for_mod;\n+export lookup_impl_methods;\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n@@ -130,6 +132,15 @@ fn item_ty_param_kinds(item: ebml::doc) -> [ast::kind] {\n     ret ks;\n }\n \n+fn item_ty_param_count(item: ebml::doc) -> uint {\n+    let n = 0u;\n+    let tp = tag_items_data_item_ty_param_kinds;\n+    ebml::tagged_docs(item, tp) {|p|\n+        n += ebml::vint_at(ebml::doc_data(p), 0u).val;\n+    }\n+    n\n+}\n+\n fn tag_variant_ids(item: ebml::doc, this_cnum: ast::crate_num) ->\n    [ast::def_id] {\n     let ids: [ast::def_id] = [];\n@@ -159,6 +170,15 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     ret result;\n }\n \n+fn item_name(item: ebml::doc) -> ast::ident {\n+    let name = ebml::get_doc(item, tag_paths_data_name);\n+    str::unsafe_from_bytes(ebml::doc_data(name))\n+}\n+\n+fn lookup_item_name(data: @[u8], id: ast::node_id) -> ast::ident {\n+    item_name(lookup_item(id, data))\n+}\n+\n // FIXME doesn't yet handle renamed re-exported externals\n fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n    ast::def {\n@@ -205,7 +225,7 @@ fn get_type(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n }\n \n fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n-    ret vec::len(get_type_param_kinds(data, id));\n+    item_ty_param_count(lookup_item(id, data))\n }\n \n fn get_type_param_kinds(data: @[u8], id: ast::node_id) -> [ast::kind] {\n@@ -243,6 +263,31 @@ fn get_tag_variants(_data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n     ret infos;\n }\n \n+fn get_impls_for_mod(data: @[u8], node: ast::node_id, cnum: ast::crate_num)\n+    -> [ast::def_id] {\n+    let mod_item = lookup_item(node, data), result = [];\n+    ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n+        let did = parse_def_id(ebml::doc_data(doc));\n+        result += [{crate: cnum with did}];\n+    }\n+    result\n+}\n+\n+fn lookup_impl_methods(data: @[u8], node: ast::node_id, cnum: ast::crate_num)\n+    -> [@middle::resolve::method_info] {\n+    let impl_item = lookup_item(node, data), rslt = [];\n+    let base_tps = item_ty_param_count(impl_item);\n+    ebml::tagged_docs(impl_item, tag_impl_method) {|doc|\n+        let m_did = parse_def_id(ebml::doc_data(doc));\n+        let mth_item = lookup_item(m_did.node, data);\n+        rslt += [@{did: {crate: cnum, node: m_did.node},\n+                   n_tps: item_ty_param_count(mth_item) - base_tps,\n+                   ident: item_name(mth_item)}];\n+    }\n+    rslt\n+}\n+\n+\n fn family_has_type_params(fam_ch: u8) -> bool {\n     ret alt fam_ch as char {\n           'c' { false }\n@@ -258,6 +303,7 @@ fn family_has_type_params(fam_ch: u8) -> bool {\n           'm' { false }\n           'n' { false }\n           'v' { true }\n+          'i' { true }\n         };\n }\n "}, {"sha": "92ab6db903f1677c1b3292218ea23e1f37bf1a5e", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=58a81a68edb605dabe5f1aa04a087e412ad73936", "patch": "@@ -249,6 +249,26 @@ fn encode_tag_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     }\n }\n \n+fn encode_info_for_mod(ebml_w: ebml::writer, md: _mod,\n+                       id: node_id) {\n+    ebml::start_tag(ebml_w, tag_items_data_item);\n+    encode_def_id(ebml_w, local_def(id));\n+    encode_family(ebml_w, 'm' as u8);\n+    for i in md.items {\n+        alt i.node {\n+          item_impl(_, _, _) {\n+            if ast_util::is_exported(i.ident, md) {\n+                ebml::start_tag(ebml_w, tag_mod_impl);\n+                ebml_w.writer.write(str::bytes(def_to_str(local_def(i.id))));\n+                ebml::end_tag(ebml_w);\n+            }\n+          }\n+          _ {}\n+        }\n+    }\n+    ebml::end_tag(ebml_w);\n+}\n+\n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         &index: [entry<int>]) {\n     alt item.node {\n@@ -280,20 +300,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::end_tag(ebml_w);\n       }\n       item_mod(m) {\n-        ebml::start_tag(ebml_w, tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'm' as u8);\n-        for i in m.items {\n-            alt i.node {\n-              item_impl(_, _, _) {\n-                ebml::start_tag(ebml_w, tag_mod_impl);\n-                ebml_w.writer.write(str::bytes(def_to_str(local_def(i.id))));\n-                ebml::end_tag(ebml_w);\n-              }\n-              _ {}\n-            }\n-        }\n-        ebml::end_tag(ebml_w);\n+        encode_info_for_mod(ebml_w, m, item.id);\n       }\n       item_native_mod(_) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -363,9 +370,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n       item_impl(tps, _, methods) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'I' as u8);\n+        encode_family(ebml_w, 'i' as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n+        encode_name(ebml_w, item.ident);\n         for m in methods {\n             ebml::start_tag(ebml_w, tag_impl_method);\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.node.id))));\n@@ -377,10 +385,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             index += [{val: m.node.id, pos: ebml_w.writer.tell()}];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, local_def(m.node.id));\n-            encode_family(ebml_w, 'i' as u8);\n+            encode_family(ebml_w, 'f' as u8);\n+            encode_inlineness(ebml_w, 'n' as u8);\n             encode_type_param_kinds(ebml_w, tps + m.node.tps);\n             encode_type(ecx, ebml_w,\n                         node_id_to_monotype(ecx.ccx.tcx, m.node.id));\n+            encode_name(ebml_w, m.node.ident);\n             encode_symbol(ecx, ebml_w, m.node.id);\n             ebml::end_tag(ebml_w);\n         }\n@@ -415,10 +425,12 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer) ->\n-   [entry<int>] {\n+fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                         crate_mod: _mod) -> [entry<int>] {\n     let index: [entry<int>] = [];\n     ebml::start_tag(ebml_w, tag_items_data);\n+    index += [{val: crate_node_id, pos: ebml_w.writer.tell()}];\n+    encode_info_for_mod(ebml_w, crate_mod, crate_node_id);\n     ecx.ccx.ast_map.items {|key, val|\n         alt val {\n           middle::ast_map::node_item(i) {\n@@ -658,7 +670,7 @@ fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n     // Encode and index the items.\n \n     ebml::start_tag(ebml_w, tag_items);\n-    let items_index = encode_info_for_items(ecx, ebml_w);\n+    let items_index = encode_info_for_items(ecx, ebml_w, crate.node.module);\n     let items_buckets = create_index(items_index, hash_node_id);\n     encode_index(ebml_w, items_buckets, write_int);\n     ebml::end_tag(ebml_w);"}, {"sha": "78e3da6b03037a7efee3e67b1a04b2ea97c989c3", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=58a81a68edb605dabe5f1aa04a087e412ad73936", "patch": "@@ -8,6 +8,7 @@ tag ast_node {\n     node_item(@item);\n     node_obj_ctor(@item);\n     node_native_item(@native_item);\n+    node_method(@method);\n     node_expr(@expr);\n     // Locals are numbered, because the alias analysis needs to know in which\n     // order they are introduced.\n@@ -63,6 +64,9 @@ fn map_item(cx: ctx, i: @item) {\n     cx.map.insert(i.id, node_item(i));\n     alt i.node {\n       item_obj(_, _, ctor_id) { cx.map.insert(ctor_id, node_obj_ctor(i)); }\n+      item_impl(_, _, ms) {\n+        for m in ms { cx.map.insert(m.node.id, node_method(m)); }\n+      }\n       _ { }\n     }\n }"}, {"sha": "484e36be18445a8ad88b40c1f29f3c2f5950dff5", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=58a81a68edb605dabe5f1aa04a087e412ad73936", "patch": "@@ -19,7 +19,8 @@ import option::{some, none, is_none, is_some};\n import syntax::print::pprust::*;\n \n export resolve_crate;\n-export def_map, ext_map, exp_map, impl_map, iscopes;\n+export def_map, ext_map, exp_map, impl_map;\n+export _impl, iscopes, method_info;\n \n // Resolving happens in two passes. The first pass collects defids of all\n // (internal) imports and modules, so that they can be looked up when needed,\n@@ -47,7 +48,7 @@ tag import_state {\n     resolved(option::t<def>, /* value */\n              option::t<def>, /* type */\n              option::t<def>, /* module */\n-             @[@ast::item],\n+             @[@_impl], /* impls */\n              /* used for reporting unused import warning */\n              ast::ident, codemap::span);\n }\n@@ -106,6 +107,7 @@ type def_map = hashmap<node_id, def>;\n type ext_map = hashmap<def_id, [ident]>;\n type exp_map = hashmap<str, def>;\n type impl_map = hashmap<node_id, iscopes>;\n+type impl_cache = hashmap<def_id, @[@_impl]>;\n \n type env =\n     {cstore: cstore::cstore,\n@@ -117,6 +119,7 @@ type env =\n      block_map: hashmap<ast::node_id, [glob_imp_def]>,\n      ext_map: ext_map,\n      impl_map: impl_map,\n+     impl_cache: impl_cache,\n      ext_cache: ext_hash,\n      used_imports: {mutable track: bool,\n                     mutable data: [ast::node_id]},\n@@ -144,6 +147,7 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n           block_map: new_int_hash(),\n           ext_map: new_def_hash(),\n           impl_map: new_int_hash(),\n+          impl_cache: new_def_hash(),\n           ext_cache: new_ext_hash(),\n           used_imports: {mutable track: false, mutable data:  []},\n           mutable reported: [],\n@@ -489,7 +493,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                   ids: [ast::ident], sp: codemap::span, sc: scopes) {\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: block(namespace) -> option::t<def>,\n-                impls: [@ast::item]) {\n+                impls: [@_impl]) {\n         let val = lookup(ns_value), typ = lookup(ns_type),\n             md = lookup(ns_module);\n         if is_none(val) && is_none(typ) && is_none(md) &&\n@@ -1058,7 +1062,7 @@ fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n         if !is_none(cached) { ret cached; }\n         let path = [name];\n         if defid.node != ast::crate_node_id {\n-            path = e.ext_map.get(defid) + path; \n+            path = e.ext_map.get(defid) + path;\n         }\n         let fnd = lookup_external(e, defid.crate, path, ns);\n         if !is_none(fnd) {\n@@ -1631,6 +1635,10 @@ fn check_exports(e: @env) {\n \n // Impl resolution\n \n+type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n+type _impl = {did: def_id, ident: ast::ident, methods: [@method_info]};\n+type iscopes = list<@[@_impl]>;\n+\n fn resolve_impls(e: @env, c: @ast::crate) {\n     visit::visit_crate(*c, nil, visit::mk_vt(@{\n         visit_block: bind visit_block_with_impl_scope(e, _, _, _),\n@@ -1641,21 +1649,25 @@ fn resolve_impls(e: @env, c: @ast::crate) {\n }\n \n fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n-                           &impls: [@ast::item], sc: iscopes) {\n+                           &impls: [@_impl], sc: iscopes) {\n     alt vi.node {\n-      ast::view_item_import(_, pt, id) {\n+      ast::view_item_import(name, pt, id) {\n         let found = [];\n         if vec::len(*pt) == 1u {\n             list::iter(sc) {|level|\n                 if vec::len(found) > 0u { ret; }\n                 for imp in *level {\n-                    if imp.ident == pt[0] { found += [imp]; }\n+                    if imp.ident == pt[0] {\n+                        found += [@{ident: name with *imp}];\n+                    }\n                 }\n                 if vec::len(found) > 0u { impls += found; }\n             }\n         } else {\n             alt e.imports.get(id) {\n-              resolved(_, _, _, is, _, _) { impls += *is; }\n+              resolved(_, _, _, is, _, _) {\n+                for i in *is { impls += [@{ident: name with *i}]; }\n+              }\n             }\n         }\n       }\n@@ -1680,38 +1692,51 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n     }\n }\n \n-fn find_impls_in_item(i: @ast::item, &impls: [@ast::item],\n+fn find_impls_in_item(i: @ast::item, &impls: [@_impl],\n                       name: option::t<ident>,\n                       ck_exports: option::t<ast::_mod>) {\n     alt i.node {\n-      ast::item_impl(_, _, _) {\n+      ast::item_impl(_, _, mthds) {\n         if alt name { some(n) { n == i.ident } _ { true } } &&\n            alt ck_exports { some(m) { is_exported(i.ident, m) } _ { true } } {\n-            impls += [i];\n+            impls += [@{did: local_def(i.id),\n+                        ident: i.ident,\n+                        methods: vec::map({|m| @{did: local_def(m.node.id),\n+                                                 n_tps: vec::len(m.node.tps),\n+                                                 ident: m.node.ident}},\n+                                          mthds)}];\n         }\n       }\n       _ {}\n     }\n }\n \n-// FIXME[impl] external importing of impls\n-fn find_impls_in_mod(e: env, m: def, &impls: [@ast::item],\n+// FIXME[impl] we should probably cache this\n+fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n                      name: option::t<ident>) {\n     alt m {\n       ast::def_mod(defid) {\n-        if defid.crate == ast::local_crate {\n-            let md = option::get(e.mod_map.get(defid.node).m);\n-            for i in md.items {\n-                find_impls_in_item(i, impls, name, some(md));\n+        alt e.impl_cache.find(defid) {\n+          some(v) { impls += *v; }\n+          none. {\n+            let found = [];\n+            if defid.crate == ast::local_crate {\n+                let md = option::get(e.mod_map.get(defid.node).m);\n+                for i in md.items {\n+                    find_impls_in_item(i, found, name, some(md));\n+                }\n+            } else {\n+                found = csearch::get_impls_for_mod(e.cstore, defid, name);\n             }\n+            impls += found;\n+            e.impl_cache.insert(defid, @found);\n+          }\n         }\n       }\n       _ {}\n     }\n }\n \n-type iscopes = list<@[@ast::item]>;\n-\n fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n                                v: vt<iscopes>) {\n     let impls = [];"}, {"sha": "2a8673a265a3b646a9ac157aa2afad04d0cfabd6", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a81a68edb605dabe5f1aa04a087e412ad73936/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=58a81a68edb605dabe5f1aa04a087e412ad73936", "patch": "@@ -1463,33 +1463,36 @@ fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n // FIXME[impl] notice/resolve conflicts\n fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                  name: ast::ident, ty: ty::t)\n-    -> option::t<{method: @ast::method, ids: [int]}> {\n+    -> option::t<{method: @resolve::method_info, ids: [int]}> {\n     let result = none;\n     std::list::iter(isc) {|impls|\n-        for im in *impls {\n-            alt im.node {\n-              ast::item_impl(tps, slf, mthds) {\n-                let self_ty = ast_ty_to_ty_crate(fcx.ccx, slf);\n-                let tp_count = vec::len(tps);\n-                let {ids, ty: self_ty} = if tp_count > 0u {\n-                    bind_params_in_type(ast_util::dummy_sp(), fcx.ccx.tcx,\n-                                        bind next_ty_var_id(fcx), self_ty,\n-                                        tp_count)\n-                } else { {ids: [], ty: self_ty} };\n-                // FIXME[impl] Don't unify in the current fcx, use\n-                // scratch context\n-                alt unify::unify(fcx, ty, self_ty) {\n-                  ures_ok(_) {\n-                    for m in mthds {\n-                        if m.node.ident == name {\n-                            result = some({method: m, ids: ids});\n-                            ret;\n-                        }\n-                    }\n+        for @{did, methods, _} in *impls {\n+            let (n_tps, self_ty) = if did.crate == ast::local_crate {\n+                alt fcx.ccx.tcx.items.get(did.node) {\n+                  ast_map::node_item(@{node: ast::item_impl(tps, st, _), _}) {\n+                    (vec::len(tps), ast_ty_to_ty_crate(fcx.ccx, st))\n                   }\n-                  _ {}\n+                }\n+            } else {\n+                let tpt = csearch::get_type(fcx.ccx.tcx, did);\n+                (vec::len(tpt.kinds), tpt.ty)\n+            };\n+            let {ids, ty: self_ty} = if n_tps > 0u {\n+                bind_params_in_type(ast_util::dummy_sp(), fcx.ccx.tcx,\n+                                    bind next_ty_var_id(fcx), self_ty, n_tps)\n+            } else { {ids: [], ty: self_ty} };\n+            // FIXME[impl] Don't unify in the current fcx, use\n+            // scratch context\n+            alt unify::unify(fcx, ty, self_ty) {\n+              ures_ok(_) {\n+                for m in methods {\n+                    if m.ident == name {\n+                        result = some({method: m, ids: ids});\n+                        ret;\n+                    }\n                 }\n               }\n+              _ {}\n             }\n         }\n     }\n@@ -2129,20 +2132,26 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let iscope = fcx.ccx.impl_map.get(expr.id);\n         alt lookup_method(fcx, iscope, field, base_t) {\n           some({method, ids}) {\n-            let mt = ty_of_method(fcx.ccx.tcx, m_check, method), ids = ids;\n-            let fty = ty::mk_fn(fcx.ccx.tcx, mt.proto, mt.inputs,\n-                                mt.output, mt.cf, mt.constrs);\n-            let tp_count = vec::len(method.node.tps);\n-            if tp_count > 0u {\n+            let fty = if method.did.crate == ast::local_crate {\n+                alt tcx.items.get(method.did.node) {\n+                  ast_map::node_method(m) {\n+                    let mt = ty_of_method(tcx, m_check, m);\n+                    ty::mk_fn(tcx, mt.proto, mt.inputs,\n+                              mt.output, mt.cf, mt.constrs)\n+                  }\n+                }\n+            } else { csearch::get_type(tcx, method.did).ty };\n+            let ids = ids;\n+            if method.n_tps > 0u {\n                 let b = bind_params_in_type(expr.span, tcx,\n                                             bind next_ty_var_id(fcx),\n-                                            fty, tp_count);\n+                                            fty, method.n_tps);\n                 ids += b.ids;\n                 fty = b.ty;\n             }\n             let substs = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n             write::ty_fixup(fcx, id, {substs: some(substs), ty: fty});\n-            fcx.ccx.method_map.insert(id, local_def(method.node.id));\n+            fcx.ccx.method_map.insert(id, method.did);\n           }\n           _ {\n             base_t = do_autoderef(fcx, expr.span, base_t);"}]}