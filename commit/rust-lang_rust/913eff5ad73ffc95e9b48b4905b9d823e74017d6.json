{"sha": "913eff5ad73ffc95e9b48b4905b9d823e74017d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxM2VmZjVhZDczZmZjOTVlOWI0OGI0OTA1YjlkODIzZTc0MDE3ZDY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-29T22:24:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-29T22:24:17Z"}, "message": "Merge #4162\n\n4162: Complete assoc. items on type parameters r=jonas-schievink a=jonas-schievink\n\nThis is fairly messy and seems to leak a lot through the `ra_hir` abstraction (`TypeNs`, `AssocItemId`, ...), so I'd be glad for any advise for how to improve this.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "3f05c054c5c143862b9abde47bda2cd4fab2ded9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f05c054c5c143862b9abde47bda2cd4fab2ded9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/913eff5ad73ffc95e9b48b4905b9d823e74017d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeqf6RCRBK7hj4Ov3rIwAAdHIIADRzYxN+2BA9fMAErcMOJ215\n647g15GQhe7A1vvizHgcm503IBUzRtXYnwIPseZCUAWyyeDs+OaGRhKWGTD84iu2\n/FD1zPw6IToO23PP8Zs8g2BsVtABC3r1UQmNsJxJzGJLHrRVfVu/78aS1HfZ4HKI\nLRR2/O84EB8+wUQ/MSg3mxkd37VmwEZpQtVgLCxODJZc+1UxiFc53w/N0Riw+vr+\n1Ybm45XQEYZlkoMCCF9L1buh9+B68R+141+dNfDlv3u+KemRxibWij48aw0HYh4n\npeS7xXcOHH3OaJ4il2CDGhDyfj1XRbjifIBodPRa3/RNT7YtGaosjJNWSFzTjy4=\n=DKzq\n-----END PGP SIGNATURE-----\n", "payload": "tree 3f05c054c5c143862b9abde47bda2cd4fab2ded9\nparent 4ff3573e18114e044ed74e785f099a023ebfbf5d\nparent 0cd6a88cf6f80d48669c6136f5fa814fcdafe8e2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588199057 +0000\ncommitter GitHub <noreply@github.com> 1588199057 +0000\n\nMerge #4162\n\n4162: Complete assoc. items on type parameters r=jonas-schievink a=jonas-schievink\n\nThis is fairly messy and seems to leak a lot through the `ra_hir` abstraction (`TypeNs`, `AssocItemId`, ...), so I'd be glad for any advise for how to improve this.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/913eff5ad73ffc95e9b48b4905b9d823e74017d6", "html_url": "https://github.com/rust-lang/rust/commit/913eff5ad73ffc95e9b48b4905b9d823e74017d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/913eff5ad73ffc95e9b48b4905b9d823e74017d6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ff3573e18114e044ed74e785f099a023ebfbf5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff3573e18114e044ed74e785f099a023ebfbf5d", "html_url": "https://github.com/rust-lang/rust/commit/4ff3573e18114e044ed74e785f099a023ebfbf5d"}, {"sha": "0cd6a88cf6f80d48669c6136f5fa814fcdafe8e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cd6a88cf6f80d48669c6136f5fa814fcdafe8e2", "html_url": "https://github.com/rust-lang/rust/commit/0cd6a88cf6f80d48669c6136f5fa814fcdafe8e2"}], "stats": {"total": 470, "additions": 402, "deletions": 68}, "files": [{"sha": "af59aa1b6cf4156a462a68623fff5a13db9ab1cf", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=913eff5ad73ffc95e9b48b4905b9d823e74017d6", "patch": "@@ -953,6 +953,16 @@ impl TypeParam {\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         self.id.parent.module(db.upcast()).into()\n     }\n+\n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        let resolver = self.id.parent.resolver(db.upcast());\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        let ty = Ty::Placeholder(self.id);\n+        Type {\n+            krate: self.id.parent.module(db.upcast()).krate,\n+            ty: InEnvironment { value: ty, environment },\n+        }\n+    }\n }\n \n // FIXME: rename from `ImplDef` to `Impl`"}, {"sha": "a0a0f234bf9272aaf468e4f1e11f546eef9e3e96", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=913eff5ad73ffc95e9b48b4905b9d823e74017d6", "patch": "@@ -9,6 +9,7 @@ use hir_def::{\n     AsMacroCall, TraitId,\n };\n use hir_expand::ExpansionInfo;\n+use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n use ra_db::{FileId, FileRange};\n use ra_prof::profile;\n@@ -24,8 +25,9 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n-    Name, Origin, Path, ScopeDef, Trait, Type, TypeParam,\n+    Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam,\n };\n+use resolver::TypeNs;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PathResolution {\n@@ -40,6 +42,44 @@ pub enum PathResolution {\n     AssocItem(AssocItem),\n }\n \n+impl PathResolution {\n+    fn in_type_ns(&self) -> Option<TypeNs> {\n+        match self {\n+            PathResolution::Def(ModuleDef::Adt(adt)) => Some(TypeNs::AdtId((*adt).into())),\n+            PathResolution::Def(ModuleDef::BuiltinType(builtin)) => {\n+                Some(TypeNs::BuiltinType(*builtin))\n+            }\n+            PathResolution::Def(ModuleDef::Const(_))\n+            | PathResolution::Def(ModuleDef::EnumVariant(_))\n+            | PathResolution::Def(ModuleDef::Function(_))\n+            | PathResolution::Def(ModuleDef::Module(_))\n+            | PathResolution::Def(ModuleDef::Static(_))\n+            | PathResolution::Def(ModuleDef::Trait(_)) => None,\n+            PathResolution::Def(ModuleDef::TypeAlias(alias)) => {\n+                Some(TypeNs::TypeAliasId((*alias).into()))\n+            }\n+            PathResolution::Local(_) | PathResolution::Macro(_) => None,\n+            PathResolution::TypeParam(param) => Some(TypeNs::GenericParam((*param).into())),\n+            PathResolution::SelfType(impl_def) => Some(TypeNs::SelfType((*impl_def).into())),\n+            PathResolution::AssocItem(AssocItem::Const(_))\n+            | PathResolution::AssocItem(AssocItem::Function(_)) => None,\n+            PathResolution::AssocItem(AssocItem::TypeAlias(alias)) => {\n+                Some(TypeNs::TypeAliasId((*alias).into()))\n+            }\n+        }\n+    }\n+\n+    /// Returns an iterator over associated types that may be specified after this path (using\n+    /// `Ty::Assoc` syntax).\n+    pub fn assoc_type_shorthand_candidates<R>(\n+        &self,\n+        db: &dyn HirDatabase,\n+        mut cb: impl FnMut(TypeAlias) -> Option<R>,\n+    ) -> Option<R> {\n+        associated_type_shorthand_candidates(db, self.in_type_ns()?, |_, _, id| cb(id.into()))\n+    }\n+}\n+\n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,"}, {"sha": "a6f56c661e2a7b509371b954d58c0dd894c37c88", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=913eff5ad73ffc95e9b48b4905b9d823e74017d6", "patch": "@@ -66,7 +66,8 @@ pub use autoderef::autoderef;\n pub use infer::{InferTy, InferenceResult};\n pub use lower::CallableDef;\n pub use lower::{\n-    callable_item_sig, ImplTraitLoweringMode, TyDefId, TyLoweringContext, ValueTyDefId,\n+    associated_type_shorthand_candidates, callable_item_sig, ImplTraitLoweringMode, TyDefId,\n+    TyLoweringContext, ValueTyDefId,\n };\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n "}, {"sha": "9ad6dbe075a2b26b2cfbfdc014cf43e2bca193c0", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 88, "deletions": 55, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=913eff5ad73ffc95e9b48b4905b9d823e74017d6", "patch": "@@ -17,9 +17,9 @@ use hir_def::{\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AssocContainerId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule,\n-    ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId,\n-    VariantId,\n+    AdtId, AssocContainerId, AssocItemId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n+    HasModule, ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId,\n+    UnionId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -34,6 +34,7 @@ use crate::{\n     Binders, BoundVar, DebruijnIndex, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate,\n     ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n+use hir_expand::name::Name;\n \n #[derive(Debug)]\n pub struct TyLoweringContext<'a> {\n@@ -383,61 +384,38 @@ impl Ty {\n         res: Option<TypeNs>,\n         segment: PathSegment<'_>,\n     ) -> Ty {\n-        let traits_from_env: Vec<_> = match res {\n-            Some(TypeNs::SelfType(impl_id)) => match ctx.db.impl_trait(impl_id) {\n-                None => return Ty::Unknown,\n-                Some(trait_ref) => vec![trait_ref.value],\n-            },\n-            Some(TypeNs::GenericParam(param_id)) => {\n-                let predicates = ctx.db.generic_predicates_for_param(param_id);\n-                let mut traits_: Vec<_> = predicates\n-                    .iter()\n-                    .filter_map(|pred| match &pred.value {\n-                        GenericPredicate::Implemented(tr) => Some(tr.clone()),\n-                        _ => None,\n-                    })\n-                    .collect();\n-                // Handle `Self::Type` referring to own associated type in trait definitions\n-                if let GenericDefId::TraitId(trait_id) = param_id.parent {\n-                    let generics = generics(ctx.db.upcast(), trait_id.into());\n-                    if generics.params.types[param_id.local_id].provenance\n-                        == TypeParamProvenance::TraitSelf\n-                    {\n-                        let trait_ref = TraitRef {\n-                            trait_: trait_id,\n-                            substs: Substs::bound_vars(&generics, DebruijnIndex::INNERMOST),\n+        if let Some(res) = res {\n+            let ty =\n+                associated_type_shorthand_candidates(ctx.db, res, move |name, t, associated_ty| {\n+                    if name == segment.name {\n+                        let substs = match ctx.type_param_mode {\n+                            TypeParamLoweringMode::Placeholder => {\n+                                // if we're lowering to placeholders, we have to put\n+                                // them in now\n+                                let s = Substs::type_params(\n+                                    ctx.db,\n+                                    ctx.resolver.generic_def().expect(\n+                                        \"there should be generics if there's a generic param\",\n+                                    ),\n+                                );\n+                                t.substs.clone().subst_bound_vars(&s)\n+                            }\n+                            TypeParamLoweringMode::Variable => t.substs.clone(),\n                         };\n-                        traits_.push(trait_ref);\n+                        // FIXME handle type parameters on the segment\n+                        return Some(Ty::Projection(ProjectionTy {\n+                            associated_ty,\n+                            parameters: substs,\n+                        }));\n                     }\n-                }\n-                traits_\n-            }\n-            _ => return Ty::Unknown,\n-        };\n-        let traits = traits_from_env.into_iter().flat_map(|t| all_super_trait_refs(ctx.db, t));\n-        for t in traits {\n-            if let Some(associated_ty) =\n-                ctx.db.trait_data(t.trait_).associated_type_by_name(&segment.name)\n-            {\n-                let substs = match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => {\n-                        // if we're lowering to placeholders, we have to put\n-                        // them in now\n-                        let s = Substs::type_params(\n-                            ctx.db,\n-                            ctx.resolver\n-                                .generic_def()\n-                                .expect(\"there should be generics if there's a generic param\"),\n-                        );\n-                        t.substs.subst_bound_vars(&s)\n-                    }\n-                    TypeParamLoweringMode::Variable => t.substs,\n-                };\n-                // FIXME handle (forbid) type parameters on the segment\n-                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n-            }\n+\n+                    None\n+                });\n+\n+            ty.unwrap_or(Ty::Unknown)\n+        } else {\n+            Ty::Unknown\n         }\n-        Ty::Unknown\n     }\n \n     fn from_hir_path_inner(\n@@ -694,6 +672,61 @@ pub fn callable_item_sig(db: &dyn HirDatabase, def: CallableDef) -> PolyFnSig {\n     }\n }\n \n+pub fn associated_type_shorthand_candidates<R>(\n+    db: &dyn HirDatabase,\n+    res: TypeNs,\n+    mut cb: impl FnMut(&Name, &TraitRef, TypeAliasId) -> Option<R>,\n+) -> Option<R> {\n+    let traits_from_env: Vec<_> = match res {\n+        TypeNs::SelfType(impl_id) => match db.impl_trait(impl_id) {\n+            None => vec![],\n+            Some(trait_ref) => vec![trait_ref.value],\n+        },\n+        TypeNs::GenericParam(param_id) => {\n+            let predicates = db.generic_predicates_for_param(param_id);\n+            let mut traits_: Vec<_> = predicates\n+                .iter()\n+                .filter_map(|pred| match &pred.value {\n+                    GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+                    _ => None,\n+                })\n+                .collect();\n+            // Handle `Self::Type` referring to own associated type in trait definitions\n+            if let GenericDefId::TraitId(trait_id) = param_id.parent {\n+                let generics = generics(db.upcast(), trait_id.into());\n+                if generics.params.types[param_id.local_id].provenance\n+                    == TypeParamProvenance::TraitSelf\n+                {\n+                    let trait_ref = TraitRef {\n+                        trait_: trait_id,\n+                        substs: Substs::bound_vars(&generics, DebruijnIndex::INNERMOST),\n+                    };\n+                    traits_.push(trait_ref);\n+                }\n+            }\n+            traits_\n+        }\n+        _ => vec![],\n+    };\n+\n+    for t in traits_from_env.into_iter().flat_map(move |t| all_super_trait_refs(db, t)) {\n+        let data = db.trait_data(t.trait_);\n+\n+        for (name, assoc_id) in &data.items {\n+            match assoc_id {\n+                AssocItemId::TypeAliasId(alias) => {\n+                    if let Some(result) = cb(name, &t, *alias) {\n+                        return Some(result);\n+                    }\n+                }\n+                AssocItemId::FunctionId(_) | AssocItemId::ConstId(_) => {}\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n /// Build the type of all specific fields of a struct or enum variant.\n pub(crate) fn field_types_query(\n     db: &dyn HirDatabase,"}, {"sha": "aa56a5cd870311d45deaef28088552c1977b7378", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 261, "deletions": 11, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913eff5ad73ffc95e9b48b4905b9d823e74017d6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=913eff5ad73ffc95e9b48b4905b9d823e74017d6", "patch": "@@ -5,19 +5,29 @@ use ra_syntax::AstNode;\n use test_utils::tested_by;\n \n use crate::completion::{CompletionContext, Completions};\n+use rustc_hash::FxHashSet;\n \n pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n     let path = match &ctx.path_prefix {\n         Some(path) => path.clone(),\n         _ => return,\n     };\n-    let def = match ctx.scope().resolve_hir_path(&path) {\n-        Some(PathResolution::Def(def)) => def,\n-        _ => return,\n+    let scope = ctx.scope();\n+    let context_module = scope.module();\n+\n+    let res = match scope.resolve_hir_path(&path) {\n+        Some(res) => res,\n+        None => return,\n     };\n-    let context_module = ctx.scope().module();\n-    match def {\n-        hir::ModuleDef::Module(module) => {\n+\n+    // Add associated types on type parameters and `Self`.\n+    res.assoc_type_shorthand_candidates(ctx.db, |alias| {\n+        acc.add_type_alias(ctx, alias);\n+        None::<()>\n+    });\n+\n+    match res {\n+        PathResolution::Def(hir::ModuleDef::Module(module)) => {\n             let module_scope = module.scope(ctx.db, context_module);\n             for (name, def) in module_scope {\n                 if ctx.use_item_syntax.is_some() {\n@@ -35,7 +45,8 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 acc.add_resolution(ctx, name.to_string(), &def);\n             }\n         }\n-        hir::ModuleDef::Adt(_) | hir::ModuleDef::TypeAlias(_) => {\n+        PathResolution::Def(def @ hir::ModuleDef::Adt(_))\n+        | PathResolution::Def(def @ hir::ModuleDef::TypeAlias(_)) => {\n             if let hir::ModuleDef::Adt(Adt::Enum(e)) = def {\n                 for variant in e.variants(ctx.db) {\n                     acc.add_enum_variant(ctx, variant, None);\n@@ -46,8 +57,10 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 hir::ModuleDef::TypeAlias(a) => a.ty(ctx.db),\n                 _ => unreachable!(),\n             };\n-            // Iterate assoc types separately\n-            // FIXME: complete T::AssocType\n+\n+            // XXX: For parity with Rust bug #22519, this does not complete Ty::AssocType.\n+            // (where AssocType is defined on a trait, not an inherent impl)\n+\n             let krate = ctx.krate;\n             if let Some(krate) = krate {\n                 let traits_in_scope = ctx.scope().traits_in_scope();\n@@ -65,6 +78,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     None::<()>\n                 });\n \n+                // Iterate assoc types separately\n                 ty.iterate_impl_items(ctx.db, krate, |item| {\n                     if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n                         return None;\n@@ -77,7 +91,8 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 });\n             }\n         }\n-        hir::ModuleDef::Trait(t) => {\n+        PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n+            // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n             for item in t.items(ctx.db) {\n                 if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n                     continue;\n@@ -91,8 +106,38 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 }\n             }\n         }\n+        PathResolution::TypeParam(_) | PathResolution::SelfType(_) => {\n+            if let Some(krate) = ctx.krate {\n+                let ty = match res {\n+                    PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                    PathResolution::SelfType(impl_def) => impl_def.target_ty(ctx.db),\n+                    _ => return,\n+                };\n+\n+                let traits_in_scope = ctx.scope().traits_in_scope();\n+                let mut seen = FxHashSet::default();\n+                ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n+                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                        return None;\n+                    }\n+\n+                    // We might iterate candidates of a trait multiple times here, so deduplicate\n+                    // them.\n+                    if seen.insert(item) {\n+                        match item {\n+                            hir::AssocItem::Function(func) => {\n+                                acc.add_function(ctx, func, None);\n+                            }\n+                            hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n+                            hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n+                        }\n+                    }\n+                    None::<()>\n+                });\n+            }\n+        }\n         _ => {}\n-    };\n+    }\n }\n \n #[cfg(test)]\n@@ -843,6 +888,211 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_ty_param_assoc_ty() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                trait Super {\n+                    type Ty;\n+                    const CONST: u8;\n+                    fn func() {}\n+                    fn method(&self) {}\n+                }\n+\n+                trait Sub: Super {\n+                    type SubTy;\n+                    const C2: ();\n+                    fn subfunc() {}\n+                    fn submethod(&self) {}\n+                }\n+\n+                fn foo<T: Sub>() {\n+                    T::<|>\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"C2\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"C2\",\n+                kind: Const,\n+                detail: \"const C2: ();\",\n+            },\n+            CompletionItem {\n+                label: \"CONST\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"CONST\",\n+                kind: Const,\n+                detail: \"const CONST: u8;\",\n+            },\n+            CompletionItem {\n+                label: \"SubTy\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"SubTy\",\n+                kind: TypeAlias,\n+                detail: \"type SubTy;\",\n+            },\n+            CompletionItem {\n+                label: \"Ty\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"Ty\",\n+                kind: TypeAlias,\n+                detail: \"type Ty;\",\n+            },\n+            CompletionItem {\n+                label: \"func()\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"func()$0\",\n+                kind: Function,\n+                lookup: \"func\",\n+                detail: \"fn func()\",\n+            },\n+            CompletionItem {\n+                label: \"method()\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"method()$0\",\n+                kind: Method,\n+                lookup: \"method\",\n+                detail: \"fn method(&self)\",\n+            },\n+            CompletionItem {\n+                label: \"subfunc()\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"subfunc()$0\",\n+                kind: Function,\n+                lookup: \"subfunc\",\n+                detail: \"fn subfunc()\",\n+            },\n+            CompletionItem {\n+                label: \"submethod()\",\n+                source_range: 219..219,\n+                delete: 219..219,\n+                insert: \"submethod()$0\",\n+                kind: Method,\n+                lookup: \"submethod\",\n+                detail: \"fn submethod(&self)\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_self_param_assoc_ty() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                \"\n+                //- /lib.rs\n+                trait Super {\n+                    type Ty;\n+                    const CONST: u8 = 0;\n+                    fn func() {}\n+                    fn method(&self) {}\n+                }\n+\n+                trait Sub: Super {\n+                    type SubTy;\n+                    const C2: () = ();\n+                    fn subfunc() {}\n+                    fn submethod(&self) {}\n+                }\n+\n+                struct Wrap<T>(T);\n+                impl<T> Super for Wrap<T> {}\n+                impl<T> Sub for Wrap<T> {\n+                    fn subfunc() {\n+                        // Should be able to assume `Self: Sub + Super`\n+                        Self::<|>\n+                    }\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"C2\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"C2\",\n+                kind: Const,\n+                detail: \"const C2: () = ();\",\n+            },\n+            CompletionItem {\n+                label: \"CONST\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"CONST\",\n+                kind: Const,\n+                detail: \"const CONST: u8 = 0;\",\n+            },\n+            CompletionItem {\n+                label: \"SubTy\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"SubTy\",\n+                kind: TypeAlias,\n+                detail: \"type SubTy;\",\n+            },\n+            CompletionItem {\n+                label: \"Ty\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"Ty\",\n+                kind: TypeAlias,\n+                detail: \"type Ty;\",\n+            },\n+            CompletionItem {\n+                label: \"func()\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"func()$0\",\n+                kind: Function,\n+                lookup: \"func\",\n+                detail: \"fn func()\",\n+            },\n+            CompletionItem {\n+                label: \"method()\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"method()$0\",\n+                kind: Method,\n+                lookup: \"method\",\n+                detail: \"fn method(&self)\",\n+            },\n+            CompletionItem {\n+                label: \"subfunc()\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"subfunc()$0\",\n+                kind: Function,\n+                lookup: \"subfunc\",\n+                detail: \"fn subfunc()\",\n+            },\n+            CompletionItem {\n+                label: \"submethod()\",\n+                source_range: 365..365,\n+                delete: 365..365,\n+                insert: \"submethod()$0\",\n+                kind: Method,\n+                lookup: \"submethod\",\n+                detail: \"fn submethod(&self)\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_type_alias() {\n         assert_debug_snapshot!("}]}