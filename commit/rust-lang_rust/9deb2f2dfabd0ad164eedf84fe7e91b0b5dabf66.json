{"sha": "9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZWIyZjJkZmFiZDBhZDE2NGVlZGY4NGZlN2U5MWIwYjVkYWJmNjY=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-29T17:35:23Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-10T16:15:08Z"}, "message": "libsyntax comments only", "tree": {"sha": "95f1f939b495709b4d0286786aa63ceeb649df57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95f1f939b495709b4d0286786aa63ceeb649df57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66", "html_url": "https://github.com/rust-lang/rust/commit/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05bbaf9e9f72b69804aed6ba37bdbe861203defc", "url": "https://api.github.com/repos/rust-lang/rust/commits/05bbaf9e9f72b69804aed6ba37bdbe861203defc", "html_url": "https://github.com/rust-lang/rust/commit/05bbaf9e9f72b69804aed6ba37bdbe861203defc"}], "stats": {"total": 63, "additions": 46, "deletions": 17}, "files": [{"sha": "0ed371d9c9afe91b87f86ed4f028deafc92faeb4", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66", "patch": "@@ -206,8 +206,12 @@ pub struct FileLines\n     lines: ~[uint]\n }\n \n+// represents the origin of a file:\n pub enum FileSubstr {\n+    // indicates that this is a normal standalone file:\n     pub FssNone,\n+    // indicates that this \"file\" is actually a substring\n+    // of another file that appears earlier in the codemap\n     pub FssInternal(span),\n }\n "}, {"sha": "fb3e8a5ded5a88e02bf2a4478c3551604127dcfb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66", "patch": "@@ -705,6 +705,7 @@ pub impl Parser {\n         @Ty {id: self.get_id(), node: t, span: sp}\n     }\n \n+    // parse the type following a @ or a ~\n     fn parse_box_or_uniq_pointee(\n         &self,\n         sigil: ast::Sigil,\n@@ -988,12 +989,8 @@ pub impl Parser {\n                      .. copy *path }\n     }\n \n+    /// parses 0 or 1 lifetime\n     fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n-        /*!\n-         *\n-         * Parses 0 or 1 lifetime.\n-         */\n-\n         match *self.token {\n             token::LIFETIME(*) => {\n                 Some(@self.parse_lifetime())\n@@ -1022,12 +1019,9 @@ pub impl Parser {\n         }\n     }\n \n+    /// Parses a single lifetime\n+    // matches lifetime = ( LIFETIME ) | ( IDENT / )\n     fn parse_lifetime(&self) -> ast::Lifetime {\n-        /*!\n-         *\n-         * Parses a single lifetime.\n-         */\n-\n         match *self.token {\n             token::LIFETIME(i) => {\n                 let span = copy self.span;\n@@ -1147,6 +1141,9 @@ pub impl Parser {\n         }\n     }\n \n+    // at the bottom (top?) of the precedence hierarchy,\n+    // parse things like parenthesized exprs,\n+    // macros, return, etc.\n     fn parse_bottom_expr(&self) -> @expr {\n         maybe_whole_expr!(self);\n \n@@ -1350,6 +1347,7 @@ pub impl Parser {\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n+    // parse a.b or a(13) or just a\n     fn parse_dot_or_call_expr(&self) -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n@@ -1618,7 +1616,7 @@ pub impl Parser {\n         return spanned(lo, self.span.hi, m);\n     }\n \n-\n+    // parse a prefix-operator expr\n     fn parse_prefix_expr(&self) -> @expr {\n         let lo = self.span.lo;\n         let mut hi;\n@@ -2552,11 +2550,14 @@ pub impl Parser {\n     }\n \n     fn parse_block(&self) -> blk {\n+        // disallow inner attrs:\n         let (attrs, blk) = self.parse_inner_attrs_and_block(false);\n         assert!(vec::is_empty(attrs));\n         return blk;\n     }\n \n+    // I claim the existence of the 'parse_attrs' flag strongly\n+    // suggests a name-change or refactoring for this function.\n     fn parse_inner_attrs_and_block(&self, parse_attrs: bool)\n         -> (~[attribute], blk) {\n \n@@ -2597,6 +2598,7 @@ pub impl Parser {\n         self.parse_block_tail_(lo, s, ~[])\n     }\n \n+    // parse the rest of a block expression or function body\n     fn parse_block_tail_(&self, lo: BytePos, s: blk_check_mode,\n                          +first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n@@ -2793,6 +2795,10 @@ pub impl Parser {\n         ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n+    // parse a set of optional generic type parameter declarations\n+    // matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n+    //                  | ( < lifetimes , typaramseq ( , )? > )\n+    // where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n     fn parse_generics(&self) -> ast::Generics {\n         if self.eat(&token::LT) {\n             let lifetimes = self.parse_lifetimes();\n@@ -2805,6 +2811,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a generic use site\n     fn parse_generic_values(\n         &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n     {\n@@ -3095,6 +3102,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse trait Foo { ... }\n     fn parse_item_trait(&self) -> item_info {\n         let ident = self.parse_ident();\n         self.parse_region_param();\n@@ -3173,13 +3181,15 @@ pub impl Parser {\n         (ident, item_impl(generics, opt_trait, ty, meths), None)\n     }\n \n+    // parse a::B<~str,int>\n     fn parse_trait_ref(&self) -> @trait_ref {\n         @ast::trait_ref {\n             path: self.parse_path_with_tps(false),\n             ref_id: self.get_id(),\n         }\n     }\n \n+    // parse B + C<~str,int> + D\n     fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[@trait_ref] {\n         self.parse_seq_to_before_end(\n             ket,\n@@ -3188,6 +3198,7 @@ pub impl Parser {\n         )\n     }\n \n+    // parse struct Foo { ... }\n     fn parse_item_struct(&self) -> item_info {\n         let class_name = self.parse_ident();\n         self.parse_region_param();\n@@ -3437,6 +3448,7 @@ pub impl Parser {\n         (id, item_const(ty, e), None)\n     }\n \n+    // parse a mod { ...}  item\n     fn parse_item_mod(&self, outer_attrs: ~[ast::attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n@@ -3693,7 +3705,7 @@ pub impl Parser {\n             }\n         };\n \n-        // extern mod { ... }\n+        // extern mod foo { ... } or extern { ... }\n         if items_allowed && self.eat(&token::LBRACE) {\n             let abis = opt_abis.get_or_default(AbiSet::C());\n \n@@ -3728,6 +3740,7 @@ pub impl Parser {\n         (lo, id)\n     }\n \n+    // parse type Foo = Bar;\n     fn parse_item_type(&self) -> item_info {\n         let (_, ident) = self.parse_type_decl();\n         self.parse_region_param();\n@@ -3738,6 +3751,7 @@ pub impl Parser {\n         (ident, item_ty(ty, tps), None)\n     }\n \n+    // parse obsolete region parameter\n     fn parse_region_param(&self) {\n         if self.eat(&token::BINOP(token::SLASH)) {\n             self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n@@ -3855,6 +3869,7 @@ pub impl Parser {\n         let generics = self.parse_generics();\n         // Newtype syntax\n         if *self.token == token::EQ {\n+            // enum x = ty;\n             self.bump();\n             let ty = self.parse_ty(false);\n             self.expect(&token::SEMI);\n@@ -3879,6 +3894,7 @@ pub impl Parser {\n                 None\n             );\n         }\n+        // enum X { ... }\n         self.expect(&token::LBRACE);\n \n         let enum_definition = self.parse_enum_def(&generics);\n@@ -3982,7 +3998,7 @@ pub impl Parser {\n                 (self.is_keyword(&~\"const\") ||\n                 (self.is_keyword(&~\"static\") &&\n                     !self.token_is_keyword(&~\"fn\", &self.look_ahead(1)))) {\n-            // CONST ITEM\n+            // CONST / STATIC ITEM\n             if self.is_keyword(&~\"const\") {\n                 self.obsolete(*self.span, ObsoleteConstItem);\n             }\n@@ -3998,10 +4014,9 @@ pub impl Parser {\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n         }\n-        if items_allowed &&\n-            // FUNCTION ITEM (not sure about lookahead condition...)\n-            self.is_keyword(&~\"fn\") &&\n+        if items_allowed && self.is_keyword(&~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n+            // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(impure_fn, AbiSet::Rust());\n@@ -4010,7 +4025,7 @@ pub impl Parser {\n                                           maybe_append(attrs, extra_attrs)));\n         }\n         if items_allowed && self.eat_keyword(&~\"pure\") {\n-            // PURE FUNCTION ITEM\n+            // PURE FUNCTION ITEM (obsolete)\n             self.obsolete(*self.last_span, ObsoletePurity);\n             self.expect_keyword(&~\"fn\");\n             let (ident, item_, extra_attrs) =\n@@ -4188,6 +4203,12 @@ pub impl Parser {\n         return view_item_use(self.parse_view_paths());\n     }\n \n+\n+    // matches view_path : MOD? IDENT EQ non_global_path\n+    // | MOD? non_global_path MOD_SEP LBRACE RBRACE\n+    // | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n+    // | MOD? non_global_path MOD_SEP STAR\n+    // | MOD? non_global_path\n     fn parse_view_path(&self) -> @view_path {\n         let lo = self.span.lo;\n \n@@ -4277,6 +4298,7 @@ pub impl Parser {\n                      view_path_simple(last, path, namespace, self.get_id()));\n     }\n \n+    // matches view_paths = view_path | view_path , view_paths\n     fn parse_view_paths(&self) -> ~[@view_path] {\n         let mut vp = ~[self.parse_view_path()];\n         while *self.token == token::COMMA {\n@@ -4326,6 +4348,9 @@ pub impl Parser {\n \n     // Parses a sequence of items. Stops when it finds program\n     // text that can't be parsed as an item\n+    // - mod_items uses VIEW_ITEMS_AND_ITEMS_ALLOWED\n+    // - block_tail_ uses IMPORTS_AND_ITEMS_ALLOWED\n+    // - foreign_mod_items uses FOREIGN_ITEMS_ALLOWED\n     fn parse_items_and_view_items(&self, +first_item_attrs: ~[attribute],\n                                   mode: view_item_parse_mode,\n                                   macros_allowed: bool)"}]}