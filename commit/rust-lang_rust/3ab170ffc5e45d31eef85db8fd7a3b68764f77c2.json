{"sha": "3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYjE3MGZmYzVlNDVkMzFlZWY4NWRiOGZkN2EzYjY4NzY0Zjc3YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-30T13:01:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-30T13:01:10Z"}, "message": "auto merge of #16037 : erickt/rust/quote_arm, r=acrichto\n\nThis adds support for `quote_arm!(cx, $pat => $expr)`, and `macro_rules!(($a:arm) => (...))`. It also fixes a bug in pretty printing, where this would generate invalid code:\r\n\r\n```\r\nmatch { 5i } {\r\n    1 => 2,\r\n    _ => 3,\r\n}\r\n```\r\n\r\nIt would generate this code:\r\n\r\n```\r\nmatch { 5i } {\r\n    1 => 2\r\n    _ => 3\r\n}\r\n```\r\n\r\nFinally, it adds a couple helper methods to `ExtCtxt`.", "tree": {"sha": "8146c564ee7c93820cb78da85b9cd9f1d51cc081", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8146c564ee7c93820cb78da85b9cd9f1d51cc081"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "html_url": "https://github.com/rust-lang/rust/commit/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "692077b6431460b96beb0ccf4f38299618d51db2", "url": "https://api.github.com/repos/rust-lang/rust/commits/692077b6431460b96beb0ccf4f38299618d51db2", "html_url": "https://github.com/rust-lang/rust/commit/692077b6431460b96beb0ccf4f38299618d51db2"}, {"sha": "e841a88b9298b0d1fef93192d8e163b44645fc73", "url": "https://api.github.com/repos/rust-lang/rust/commits/e841a88b9298b0d1fef93192d8e163b44645fc73", "html_url": "https://github.com/rust-lang/rust/commit/e841a88b9298b0d1fef93192d8e163b44645fc73"}], "stats": {"total": 257, "additions": 176, "deletions": 81}, "files": [{"sha": "4a59ada441fdb19a21e9d642dea7550c07e59b21", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -334,8 +334,10 @@ pub enum Pat_ {\n     /// records this pattern's NodeId in an auxiliary\n     /// set (of \"PatIdents that refer to nullary enums\")\n     PatIdent(BindingMode, SpannedIdent, Option<Gc<Pat>>),\n-    PatEnum(Path, Option<Vec<Gc<Pat>>>), /* \"none\" means a * pattern where\n-                                     * we don't bind the fields to names */\n+\n+    /// \"None\" means a * pattern where we don't bind the fields to names.\n+    PatEnum(Path, Option<Vec<Gc<Pat>>>),\n+\n     PatStruct(Path, Vec<FieldPat>, bool),\n     PatTup(Vec<Gc<Pat>>),\n     PatBox(Gc<Pat>),"}, {"sha": "d00406e07b77dcacd6066f43c1cbed23e1b7e56d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -382,6 +382,9 @@ fn initial_syntax_expander_table() -> SyntaxEnv {\n     syntax_expanders.insert(intern(\"quote_pat\"),\n                        builtin_normal_expander(\n                             ext::quote::expand_quote_pat));\n+    syntax_expanders.insert(intern(\"quote_arm\"),\n+                       builtin_normal_expander(\n+                            ext::quote::expand_quote_arm));\n     syntax_expanders.insert(intern(\"quote_stmt\"),\n                        builtin_normal_expander(\n                             ext::quote::expand_quote_stmt));"}, {"sha": "6c9e113f41a4c5f2514cfe671b5df77353fe65a9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -170,6 +170,13 @@ pub trait AstBuilder {\n                 subpats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat>;\n     fn pat_struct(&self, span: Span,\n                   path: ast::Path, field_pats: Vec<ast::FieldPat> ) -> Gc<ast::Pat>;\n+    fn pat_tuple(&self, span: Span, pats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat>;\n+\n+    fn pat_some(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n+    fn pat_none(&self, span: Span) -> Gc<ast::Pat>;\n+\n+    fn pat_ok(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n+    fn pat_err(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat>;\n \n     fn arm(&self, span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm;\n     fn arm_unreachable(&self, span: Span) -> ast::Arm;\n@@ -178,6 +185,7 @@ pub trait AstBuilder {\n     fn expr_if(&self, span: Span,\n                cond: Gc<ast::Expr>, then: Gc<ast::Expr>,\n                els: Option<Gc<ast::Expr>>) -> Gc<ast::Expr>;\n+    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> Gc<ast::Expr>;\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr>;\n@@ -777,6 +785,46 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let pat = ast::PatStruct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n+    fn pat_tuple(&self, span: Span, pats: Vec<Gc<ast::Pat>>) -> Gc<ast::Pat> {\n+        let pat = ast::PatTup(pats);\n+        self.pat(span, pat)\n+    }\n+\n+    fn pat_some(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+        let some = vec!(\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"option\"),\n+            self.ident_of(\"Some\"));\n+        let path = self.path_global(span, some);\n+        self.pat_enum(span, path, vec!(pat))\n+    }\n+\n+    fn pat_none(&self, span: Span) -> Gc<ast::Pat> {\n+        let some = vec!(\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"option\"),\n+            self.ident_of(\"None\"));\n+        let path = self.path_global(span, some);\n+        self.pat_enum(span, path, vec!())\n+    }\n+\n+    fn pat_ok(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+        let some = vec!(\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"result\"),\n+            self.ident_of(\"Ok\"));\n+        let path = self.path_global(span, some);\n+        self.pat_enum(span, path, vec!(pat))\n+    }\n+\n+    fn pat_err(&self, span: Span, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+        let some = vec!(\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"result\"),\n+            self.ident_of(\"Err\"));\n+        let path = self.path_global(span, some);\n+        self.pat_enum(span, path, vec!(pat))\n+    }\n \n     fn arm(&self, _span: Span, pats: Vec<Gc<ast::Pat>> , expr: Gc<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n@@ -803,6 +851,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(span, ast::ExprIf(cond, self.block_expr(then), els))\n     }\n \n+    fn expr_loop(&self, span: Span, block: P<ast::Block>) -> Gc<ast::Expr> {\n+        self.expr(span, ast::ExprLoop(block, None))\n+    }\n+\n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> Gc<ast::Expr> {\n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))"}, {"sha": "dcfb019812774ff94ed6b312d0185ff35fc7aee9", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -144,8 +144,10 @@ pub mod rt {\n     impl_to_source!(Generics, generics_to_string)\n     impl_to_source!(Gc<ast::Item>, item_to_string)\n     impl_to_source!(Gc<ast::Method>, method_to_string)\n+    impl_to_source!(Gc<ast::Stmt>, stmt_to_string)\n     impl_to_source!(Gc<ast::Expr>, expr_to_string)\n     impl_to_source!(Gc<ast::Pat>, pat_to_string)\n+    impl_to_source!(ast::Arm, arm_to_string)\n     impl_to_source_slice!(ast::Ty, \", \")\n     impl_to_source_slice!(Gc<ast::Item>, \"\\n\\n\")\n \n@@ -239,11 +241,13 @@ pub mod rt {\n     impl_to_tokens!(ast::Ident)\n     impl_to_tokens!(Gc<ast::Item>)\n     impl_to_tokens!(Gc<ast::Pat>)\n+    impl_to_tokens!(ast::Arm)\n     impl_to_tokens!(Gc<ast::Method>)\n     impl_to_tokens_lifetime!(&'a [Gc<ast::Item>])\n     impl_to_tokens!(ast::Ty)\n     impl_to_tokens_lifetime!(&'a [ast::Ty])\n     impl_to_tokens!(Generics)\n+    impl_to_tokens!(Gc<ast::Stmt>)\n     impl_to_tokens!(Gc<ast::Expr>)\n     impl_to_tokens!(ast::Block)\n     impl_to_tokens!(ast::Arg)\n@@ -345,6 +349,14 @@ pub fn expand_quote_pat(cx: &mut ExtCtxt,\n     base::MacExpr::new(expanded)\n }\n \n+pub fn expand_quote_arm(cx: &mut ExtCtxt,\n+                        sp: Span,\n+                        tts: &[ast::TokenTree])\n+                        -> Box<base::MacResult> {\n+    let expanded = expand_parse_call(cx, sp, \"parse_arm\", vec!(), tts);\n+    base::MacExpr::new(expanded)\n+}\n+\n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[ast::TokenTree])"}, {"sha": "945a643d2b4780d1426db72861e9fe64a9f29d9d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -2727,37 +2727,41 @@ impl<'a> Parser<'a> {\n         self.commit_expr_expecting(discriminant, token::LBRACE);\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::RBRACE {\n-            let attrs = self.parse_outer_attributes();\n-            let pats = self.parse_pats();\n-            let mut guard = None;\n-            if self.eat_keyword(keywords::If) {\n-                guard = Some(self.parse_expr());\n-            }\n-            self.expect(&token::FAT_ARROW);\n-            let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n-\n-            let require_comma =\n-                !classify::expr_is_simple_block(expr)\n-                && self.token != token::RBRACE;\n-\n-            if require_comma {\n-                self.commit_expr(expr, &[token::COMMA], &[token::RBRACE]);\n-            } else {\n-                self.eat(&token::COMMA);\n-            }\n-\n-            arms.push(ast::Arm {\n-                attrs: attrs,\n-                pats: pats,\n-                guard: guard,\n-                body: expr\n-            });\n+            arms.push(self.parse_arm());\n         }\n         let hi = self.span.hi;\n         self.bump();\n         return self.mk_expr(lo, hi, ExprMatch(discriminant, arms));\n     }\n \n+    pub fn parse_arm(&mut self) -> Arm {\n+        let attrs = self.parse_outer_attributes();\n+        let pats = self.parse_pats();\n+        let mut guard = None;\n+        if self.eat_keyword(keywords::If) {\n+            guard = Some(self.parse_expr());\n+        }\n+        self.expect(&token::FAT_ARROW);\n+        let expr = self.parse_expr_res(RESTRICT_STMT_EXPR);\n+\n+        let require_comma =\n+            !classify::expr_is_simple_block(expr)\n+            && self.token != token::RBRACE;\n+\n+        if require_comma {\n+            self.commit_expr(expr, &[token::COMMA], &[token::RBRACE]);\n+        } else {\n+            self.eat(&token::COMMA);\n+        }\n+\n+        ast::Arm {\n+            attrs: attrs,\n+            pats: pats,\n+            guard: guard,\n+            body: expr,\n+        }\n+    }\n+\n     /// Parse an expression\n     pub fn parse_expr(&mut self) -> Gc<Expr> {\n         return self.parse_expr_res(UNRESTRICTED);"}, {"sha": "4ab9d1b486a34170ba9683c044b6207c7b2d190a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -18,7 +18,6 @@ use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{CodeMap, BytePos};\n use codemap;\n use diagnostic;\n-use parse::classify::expr_is_simple_block;\n use parse::token;\n use parse::lexer::comments;\n use parse;\n@@ -151,6 +150,10 @@ pub fn pat_to_string(pat: &ast::Pat) -> String {\n     to_string(|s| s.print_pat(pat))\n }\n \n+pub fn arm_to_string(arm: &ast::Arm) -> String {\n+    to_string(|s| s.print_arm(arm))\n+}\n+\n pub fn expr_to_string(e: &ast::Expr) -> String {\n     to_string(|s| s.print_expr(e))\n }\n@@ -1402,53 +1405,8 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n-                let len = arms.len();\n-                for (i, arm) in arms.iter().enumerate() {\n-                    // I have no idea why this check is necessary, but here it\n-                    // is :(\n-                    if arm.attrs.is_empty() {\n-                        try!(space(&mut self.s));\n-                    }\n-                    try!(self.cbox(indent_unit));\n-                    try!(self.ibox(0u));\n-                    try!(self.print_outer_attributes(arm.attrs.as_slice()));\n-                    let mut first = true;\n-                    for p in arm.pats.iter() {\n-                        if first {\n-                            first = false;\n-                        } else {\n-                            try!(space(&mut self.s));\n-                            try!(self.word_space(\"|\"));\n-                        }\n-                        try!(self.print_pat(&**p));\n-                    }\n-                    try!(space(&mut self.s));\n-                    match arm.guard {\n-                        Some(ref e) => {\n-                            try!(self.word_space(\"if\"));\n-                            try!(self.print_expr(&**e));\n-                            try!(space(&mut self.s));\n-                        }\n-                        None => ()\n-                    }\n-                    try!(self.word_space(\"=>\"));\n-\n-                    match arm.body.node {\n-                        ast::ExprBlock(ref blk) => {\n-                            // the block will close the pattern's ibox\n-                            try!(self.print_block_unclosed_indent(&**blk,\n-                                                                  indent_unit));\n-                        }\n-                        _ => {\n-                            try!(self.end()); // close the ibox for the pattern\n-                            try!(self.print_expr(&*arm.body));\n-                        }\n-                    }\n-                    if !expr_is_simple_block(expr.clone())\n-                        && i < len - 1 {\n-                        try!(word(&mut self.s, \",\"));\n-                    }\n-                    try!(self.end()); // close enclosing cbox\n+                for arm in arms.iter() {\n+                    try!(self.print_arm(arm));\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n             }\n@@ -1882,6 +1840,51 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodePat(pat))\n     }\n \n+    fn print_arm(&mut self, arm: &ast::Arm) -> IoResult<()> {\n+        // I have no idea why this check is necessary, but here it\n+        // is :(\n+        if arm.attrs.is_empty() {\n+            try!(space(&mut self.s));\n+        }\n+        try!(self.cbox(indent_unit));\n+        try!(self.ibox(0u));\n+        try!(self.print_outer_attributes(arm.attrs.as_slice()));\n+        let mut first = true;\n+        for p in arm.pats.iter() {\n+            if first {\n+                first = false;\n+            } else {\n+                try!(space(&mut self.s));\n+                try!(self.word_space(\"|\"));\n+            }\n+            try!(self.print_pat(&**p));\n+        }\n+        try!(space(&mut self.s));\n+        match arm.guard {\n+            Some(ref e) => {\n+                try!(self.word_space(\"if\"));\n+                try!(self.print_expr(&**e));\n+                try!(space(&mut self.s));\n+            }\n+            None => ()\n+        }\n+        try!(self.word_space(\"=>\"));\n+\n+        match arm.body.node {\n+            ast::ExprBlock(ref blk) => {\n+                // the block will close the pattern's ibox\n+                try!(self.print_block_unclosed_indent(&**blk,\n+                                                      indent_unit));\n+            }\n+            _ => {\n+                try!(self.end()); // close the ibox for the pattern\n+                try!(self.print_expr(&*arm.body));\n+                try!(word(&mut self.s, \",\"));\n+            }\n+        }\n+        self.end() // close enclosing cbox\n+    }\n+\n     // Returns whether it printed anything\n     fn print_explicit_self(&mut self,\n                            explicit_self: ast::ExplicitSelf_,"}, {"sha": "44771a29bb4fde1dc3716196821de4105755db3a", "filename": "src/test/pretty/match-block-expr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-block-expr.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pp-exact\n+\n+fn main() {\n+    let x = match { 5i } { 1 => 5i, 2 => 6, _ => 7, };\n+    assert_eq!(x , 7);\n+}"}, {"sha": "d2f8157ef62131e9f9efd82c1e47b1c841833fad", "filename": "src/test/pretty/match-naked-expr-medium.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr-medium.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -19,6 +19,6 @@ fn main() {\n              \"long\".to_string(), \"string\".to_string()],\n             None =>\n             [\"none\".to_string(), \"a\".to_string(), \"a\".to_string(),\n-             \"a\".to_string(), \"a\".to_string()]\n+             \"a\".to_string(), \"a\".to_string()],\n         };\n }"}, {"sha": "6b4f579f9c51c61c966874fe4049f771ce01f003", "filename": "src/test/pretty/match-naked-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -15,6 +15,6 @@ fn main() {\n     let _y =\n         match x {\n             Some(_) => \"some(_)\".to_string(),\n-            None => \"none\".to_string()\n+            None => \"none\".to_string(),\n         };\n }"}, {"sha": "2b7088fbc33ff2e0345af84b22f4658393e45b9a", "filename": "src/test/run-make/graphviz-flowgraph/f07.dot-expected.dot", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff07.dot-expected.dot?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -6,7 +6,7 @@ digraph block {\n     N4[label=\"expr 777i\"];\n     N5[label=\"expr 7777i\"];\n     N6[label=\"expr [7i, 77i, 777i, 7777i]\"];\n-    N7[label=\"expr match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y }\"];\n+    N7[label=\"expr match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y, }\"];\n     N8[label=\"(dummy_node)\"];\n     N9[label=\"local x\"];\n     N10[label=\"local y\"];\n@@ -15,7 +15,7 @@ digraph block {\n     N13[label=\"expr x\"];\n     N14[label=\"expr y\"];\n     N15[label=\"expr x + y\"];\n-    N16[label=\"block { match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y }; }\"];\n+    N16[label=\"block { match [7i, 77i, 777i, 7777i] { [x, y, ..] => x + y, }; }\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;"}, {"sha": "5d1d1253b22386dd5d564d060813a3fbf5229f09", "filename": "src/test/run-make/graphviz-flowgraph/f13.dot-expected.dot", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff13.dot-expected.dot?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -7,7 +7,7 @@ digraph block {\n     N5[label=\"local x\"];\n     N6[label=\"local _y\"];\n     N7[label=\"expr x\"];\n-    N8[label=\"expr match x { E13a => _y = 1, E13b(v) => _y = v + 1 }\"];\n+    N8[label=\"expr match x { E13a => _y = 1, E13b(v) => _y = v + 1, }\"];\n     N9[label=\"(dummy_node)\"];\n     N10[label=\"local E13a\"];\n     N11[label=\"expr 1\"];\n@@ -21,7 +21,7 @@ digraph block {\n     N19[label=\"expr v + 1\"];\n     N20[label=\"expr _y\"];\n     N21[label=\"expr _y = v + 1\"];\n-    N22[label=\"block {\\l    let x = E13b(13);\\l    let _y;\\l    match x { E13a => _y = 1, E13b(v) => _y = v + 1 }\\l}\\l\"];\n+    N22[label=\"block {\\l    let x = E13b(13);\\l    let _y;\\l    match x { E13a => _y = 1, E13b(v) => _y = v + 1, }\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;"}, {"sha": "a5cf8e46b7e43033ba5242913453232fb1724949", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -72,6 +72,8 @@ fn main() {\n     let pat = quote_pat!(cx, Some(_));\n     check_pp(ext_cx, pat, pprust::print_pat, \"Some(_)\".to_string());\n \n+    let arm = quote_arm!(cx, (ref x, ref y) => (x, y));\n+    check_pp(ext_cx, arm, pprust::print_stmt, \"(ref x, ref y) = (x, y)\".to_string());\n }\n \n fn check_pp<T>(cx: fake_ext_ctxt,"}, {"sha": "60b8f09bb3dedcebaea433f0277027eba156717c", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab170ffc5e45d31eef85db8fd7a3b68764f77c2/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=3ab170ffc5e45d31eef85db8fd7a3b68764f77c2", "patch": "@@ -26,6 +26,7 @@ fn syntax_extension(cx: &ExtCtxt) {\n     let _b: Option<Gc<syntax::ast::Item>> = quote_item!(cx, static foo : int = $e_toks; );\n     let _c: Gc<syntax::ast::Pat> = quote_pat!(cx, (x, 1 .. 4, *) );\n     let _d: Gc<syntax::ast::Stmt> = quote_stmt!(cx, let x = $a; );\n+    let _d: syntax::ast::Arm = quote_arm!(cx, (ref x, ref y) = (x, y) );\n     let _e: Gc<syntax::ast::Expr> = quote_expr!(cx, match foo { $p_toks => 10 } );\n \n     let _f: Gc<syntax::ast::Expr> = quote_expr!(cx, ());"}]}