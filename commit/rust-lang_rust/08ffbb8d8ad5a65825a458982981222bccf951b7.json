{"sha": "08ffbb8d8ad5a65825a458982981222bccf951b7", "node_id": "C_kwDOAAsO6NoAKDA4ZmZiYjhkOGFkNWE2NTgyNWE0NTg5ODI5ODEyMjJiY2NmOTUxYjc", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-07-15T08:40:06Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-08-18T02:53:21Z"}, "message": "fix windows join/detach and add tests", "tree": {"sha": "538712f0615b9f98591e4fca2663ecbe3f4ae589", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/538712f0615b9f98591e4fca2663ecbe3f4ae589"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08ffbb8d8ad5a65825a458982981222bccf951b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08ffbb8d8ad5a65825a458982981222bccf951b7", "html_url": "https://github.com/rust-lang/rust/commit/08ffbb8d8ad5a65825a458982981222bccf951b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08ffbb8d8ad5a65825a458982981222bccf951b7/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6fc2fc82a90ee1deb4a65c811764c610155b6b9", "html_url": "https://github.com/rust-lang/rust/commit/b6fc2fc82a90ee1deb4a65c811764c610155b6b9"}], "stats": {"total": 312, "additions": 265, "deletions": 47}, "files": [{"sha": "943d5570f7b7896b9b8c2713005bf4478e7532f3", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -418,6 +418,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         EnvVars::init(this, config)?;\n         Evaluator::init_extern_statics(this)?;\n+        ThreadManager::init(this);\n         Ok(())\n     }\n "}, {"sha": "e495f723668d7095c4c1645fabfd7c11f143b653", "filename": "src/shims/time.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -233,4 +233,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         Ok(0)\n     }\n+\n+    #[allow(non_snake_case)]\n+    fn Sleep(&mut self, timeout: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"`Sleep`\")?;\n+\n+        let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n+\n+        let duration = Duration::from_millis(timeout_ms.into());\n+        let timeout_time = Time::Monotonic(Instant::now().checked_add(duration).unwrap());\n+\n+        let active_thread = this.get_active_thread();\n+        this.block_thread(active_thread);\n+\n+        this.register_timeout_callback(\n+            active_thread,\n+            timeout_time,\n+            Box::new(move |ecx| {\n+                ecx.unblock_thread(active_thread);\n+                Ok(())\n+            }),\n+        );\n+\n+        Ok(())\n+    }\n }"}, {"sha": "d675df0f53f10f3afd5f04268b76fe3a1b687a4e", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -37,7 +37,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n-        this.join_thread(thread_id.try_into().expect(\"thread ID should fit in u32\"))?;\n+        this.join_thread_exclusive(thread_id.try_into().expect(\"thread ID should fit in u32\"))?;\n \n         Ok(0)\n     }\n@@ -46,7 +46,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n-        this.detach_thread(thread_id.try_into().expect(\"thread ID should fit in u32\"))?;\n+        this.detach_thread(thread_id.try_into().expect(\"thread ID should fit in u32\"), false)?;\n \n         Ok(0)\n     }"}, {"sha": "d64be9cc0527f9dc5c00c55a45b9d80585ccdc33", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -5,7 +5,7 @@ use rustc_target::spec::abi::Abi;\n use log::trace;\n \n use crate::helpers::check_arg_count;\n-use crate::shims::windows::handle::Handle;\n+use crate::shims::windows::handle::{EvalContextExt as _, Handle};\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n@@ -118,7 +118,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     match Handle::from_scalar(this.read_scalar(handle)?.check_init()?, this)? {\n                         Some(Handle::Thread(thread)) => thread,\n                         Some(Handle::CurrentThread) => this.get_active_thread(),\n-                        _ => throw_ub_format!(\"invalid handle\"),\n+                        _ => this.invalid_handle(\"SetThreadDescription\")?,\n                     };\n \n                 this.set_thread_name_wide(thread, name);"}, {"sha": "6014281100fc33a1f5fce962d3ece0b1abd65e20", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -228,24 +228,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let [timeout] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n \n-                this.check_no_isolation(\"`Sleep`\")?;\n-\n-                let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n-\n-                let duration = Duration::from_millis(timeout_ms as u64);\n-                let timeout_time = Time::Monotonic(Instant::now().checked_add(duration).unwrap());\n-\n-                let active_thread = this.get_active_thread();\n-                this.block_thread(active_thread);\n-\n-                this.register_timeout_callback(\n-                    active_thread,\n-                    timeout_time,\n-                    Box::new(move |ecx| {\n-                        ecx.unblock_thread(active_thread);\n-                        Ok(())\n-                    }),\n-                );\n+                this.Sleep(timeout)?;\n             }\n \n             // Synchronization primitives"}, {"sha": "e1617ae6a8d910cb3339db979b4bfe4c3e9555be", "filename": "src/shims/windows/handle.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fhandle.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -146,16 +146,19 @@ impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tc\n \n #[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn invalid_handle(&mut self, function_name: &str) -> InterpResult<'tcx, !> {\n+        throw_machine_stop!(TerminationInfo::Abort(format!(\n+            \"invalid handle passed to `{function_name}`\"\n+        )))\n+    }\n+\n     fn CloseHandle(&mut self, handle_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         match Handle::from_scalar(this.read_scalar(handle_op)?.check_init()?, this)? {\n-            Some(Handle::Thread(thread)) => this.detach_thread(thread)?,\n-            _ =>\n-                throw_machine_stop!(TerminationInfo::Abort(\n-                    \"invalid handle passed to `CloseHandle`\".into()\n-                )),\n-        };\n+            Some(Handle::Thread(thread)) => this.detach_thread(thread, true)?,\n+            _ => this.invalid_handle(\"CloseHandle\")?,\n+        }\n \n         Ok(())\n     }"}, {"sha": "6b6c4916dee2bffc5a31d8b0630a4fa7c589f99b", "filename": "src/shims/windows/thread.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fthread.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -1,11 +1,8 @@\n-use std::time::{Duration, Instant};\n-\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_target::spec::abi::Abi;\n \n-use crate::thread::Time;\n use crate::*;\n-use shims::windows::handle::Handle;\n+use shims::windows::handle::{EvalContextExt as _, Handle};\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n \n@@ -59,25 +56,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let thread = match Handle::from_scalar(this.read_scalar(handle)?.check_init()?, this)? {\n             Some(Handle::Thread(thread)) => thread,\n-            Some(Handle::CurrentThread) => throw_ub_format!(\"trying to wait on itself\"),\n-            _ => throw_ub_format!(\"invalid handle\"),\n+            // Unlike on posix, joining the current thread is not UB on windows.\n+            // It will just deadlock.\n+            Some(Handle::CurrentThread) => this.get_active_thread(),\n+            _ => this.invalid_handle(\"WaitForSingleObject\")?,\n         };\n \n         if this.read_scalar(timeout)?.to_u32()? != this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n-            this.check_no_isolation(\"`WaitForSingleObject` with non-infinite timeout\")?;\n+            throw_unsup_format!(\"`WaitForSingleObject` with non-infinite timeout\");\n         }\n \n-        let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n-\n-        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n-            None\n-        } else {\n-            let duration = Duration::from_millis(timeout_ms as u64);\n-\n-            Some(Time::Monotonic(Instant::now().checked_add(duration).unwrap()))\n-        };\n-\n-        this.wait_on_thread(timeout_time, thread)?;\n+        this.join_thread(thread)?;\n \n         Ok(())\n     }"}, {"sha": "f7fcdd5822a281325e3403efc7a46612679600f0", "filename": "src/thread.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -405,6 +405,31 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         Ok(())\n     }\n \n+    /// Mark that the active thread tries to exclusively join the thread with `joined_thread_id`.\n+    /// If the thread is already joined by another thread\n+    fn join_thread_exclusive(\n+        &mut self,\n+        joined_thread_id: ThreadId,\n+        data_race: Option<&mut data_race::GlobalState>,\n+    ) -> InterpResult<'tcx> {\n+        if self.threads[joined_thread_id].join_status == ThreadJoinStatus::Joined {\n+            throw_ub_format!(\"trying to join an already joined thread\");\n+        }\n+\n+        if joined_thread_id == self.active_thread {\n+            throw_ub_format!(\"trying to join itself\");\n+        }\n+\n+        assert!(\n+            self.threads\n+                .iter()\n+                .all(|thread| thread.state != ThreadState::BlockedOnJoin(joined_thread_id)),\n+            \"a joinable thread already has threads waiting for its termination\"\n+        );\n+\n+        self.join_thread(joined_thread_id, data_race)\n+    }\n+\n     /// Set the name of the given thread.\n     pub fn set_thread_name(&mut self, thread: ThreadId, new_thread_name: Vec<u8>) {\n         self.threads[thread].thread_name = Some(new_thread_name);\n@@ -700,6 +725,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n+    #[inline]\n+    fn join_thread_exclusive(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine\n+            .threads\n+            .join_thread_exclusive(joined_thread_id, this.machine.data_race.as_mut())?;\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> ThreadId {\n         let this = self.eval_context_mut();"}, {"sha": "4704cfed03938a9f2d72b571ef7fb752a7154c5a", "filename": "tests/fail/concurrency/unwind_top_of_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-windows: No libc on Windows\n+//@ignore-target-windows: No libc on Windows\n \n //@compile-flags: -Zmiri-disable-abi-check\n "}, {"sha": "548ed63534dbd64be3bc3dece48d30bfbf878c2c", "filename": "tests/fail/concurrency/windows_join_detached.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -0,0 +1,21 @@\n+//@only-target-windows: Uses win32 api functions\n+//@error-pattern: Undefined Behavior: trying to join a detached thread\n+\n+// Joining a detached thread is undefined behavior.\n+\n+use std::os::windows::io::{AsRawHandle, RawHandle};\n+use std::thread;\n+\n+extern \"system\" {\n+    fn CloseHandle(handle: RawHandle) -> u32;\n+}\n+\n+fn main() {\n+    let thread = thread::spawn(|| ());\n+\n+    unsafe {\n+        assert_ne!(CloseHandle(thread.as_raw_handle()), 0);\n+    }\n+\n+    thread.join().unwrap();\n+}"}, {"sha": "a0e85f6ce5ab4f33a5ecb88537b38a24168fe188", "filename": "tests/fail/concurrency/windows_join_detached.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -0,0 +1,22 @@\n+error: Undefined Behavior: trying to join a detached thread\n+  --> RUSTLIB/std/src/sys/PLATFORM/thread.rs:LL:CC\n+   |\n+LL |         let rc = unsafe { c::WaitForSingleObject(self.handle.as_raw_handle(), c::INFINITE) };\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached thread\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: backtrace:\n+   = note: inside `std::sys::PLATFORM::thread::Thread::join` at RUSTLIB/std/src/sys/PLATFORM/thread.rs:LL:CC\n+   = note: inside `std::thread::JoinInner::<()>::join` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n+   = note: inside `std::thread::JoinHandle::<()>::join` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n+note: inside `main` at $DIR/windows_join_detached.rs:LL:CC\n+  --> $DIR/windows_join_detached.rs:LL:CC\n+   |\n+LL |     thread.join().unwrap();\n+   |     ^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "ea52220d44999423b63d44d0ac760cba99a5609d", "filename": "tests/fail/concurrency/windows_join_main.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -0,0 +1,28 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+// On windows, joining main is not UB, but it will block a thread forever.\n+\n+use std::thread;\n+\n+extern \"system\" {\n+    fn WaitForSingleObject(handle: usize, timeout: u32) -> u32;\n+}\n+\n+const INFINITE: u32 = u32::MAX;\n+\n+// This is how miri represents the handle for thread 0.\n+// This value can be \"legitimately\" obtained by using `GetCurrentThread` with `DuplicateHandle`\n+// but miri does not implement `DuplicateHandle` yet.\n+const MAIN_THREAD: usize = 1 << 30;\n+\n+fn main() {\n+    thread::spawn(|| {\n+        unsafe {\n+            assert_eq!(WaitForSingleObject(MAIN_THREAD, INFINITE), 0); //~ ERROR: deadlock: the evaluated program deadlocked\n+        }\n+    })\n+    .join()\n+    .unwrap();\n+}"}, {"sha": "72b854d354a39abda09f4141267565b47c771689", "filename": "tests/fail/concurrency/windows_join_main.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -0,0 +1,12 @@\n+error: deadlock: the evaluated program deadlocked\n+  --> $DIR/windows_join_main.rs:LL:CC\n+   |\n+LL |         WaitForSingleObject(MAIN_THREAD, INFINITE);\n+   |                                                   ^ the evaluated program deadlocked\n+   |\n+   = note: inside closure at $DIR/windows_join_main.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "d9bbf66a7dca5fca6eed97f4a646231a904af751", "filename": "tests/fail/concurrency/windows_join_self.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -0,0 +1,25 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+// On windows, a thread joining itself is not UB, but it will deadlock.\n+\n+use std::thread;\n+\n+extern \"system\" {\n+    fn GetCurrentThread() -> usize;\n+    fn WaitForSingleObject(handle: usize, timeout: u32) -> u32;\n+}\n+\n+const INFINITE: u32 = u32::MAX;\n+\n+fn main() {\n+    thread::spawn(|| {\n+        unsafe {\n+            let native = GetCurrentThread();\n+            assert_eq!(WaitForSingleObject(native, INFINITE), 0); //~ ERROR: deadlock: the evaluated program deadlocked\n+        }\n+    })\n+    .join()\n+    .unwrap();\n+}"}, {"sha": "bbec3f7257ec0d44be556eef3cab1c39b4ec4408", "filename": "tests/fail/concurrency/windows_join_self.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -0,0 +1,12 @@\n+error: deadlock: the evaluated program deadlocked\n+  --> $DIR/windows_join_self.rs:LL:CC\n+   |\n+LL |             assert_eq!(WaitForSingleObject(native, INFINITE), 0);\n+   |                                                            ^ the evaluated program deadlocked\n+   |\n+   = note: inside closure at $DIR/windows_join_self.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "91088ce6aef9b8916bb802551246ae12f27e8dda", "filename": "tests/pass/concurrency/windows_detach_terminated.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Fpass%2Fconcurrency%2Fwindows_detach_terminated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Fpass%2Fconcurrency%2Fwindows_detach_terminated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fwindows_detach_terminated.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -0,0 +1,21 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::os::windows::io::IntoRawHandle;\n+use std::thread;\n+\n+extern \"system\" {\n+    fn CloseHandle(handle: usize) -> i32;\n+}\n+\n+fn main() {\n+    let thread = thread::spawn(|| {}).into_raw_handle() as usize;\n+\n+    // this yield ensures that `thread` is terminated by this point\n+    thread::yield_now();\n+\n+    unsafe {\n+        assert_ne!(CloseHandle(thread), 0);\n+    }\n+}"}, {"sha": "986e2b8cc10f7ddfb6e0cd7daab6b222461625e4", "filename": "tests/pass/concurrency/windows_join_multiple.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Fpass%2Fconcurrency%2Fwindows_join_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ffbb8d8ad5a65825a458982981222bccf951b7/tests%2Fpass%2Fconcurrency%2Fwindows_join_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fwindows_join_multiple.rs?ref=08ffbb8d8ad5a65825a458982981222bccf951b7", "patch": "@@ -0,0 +1,41 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::os::windows::io::IntoRawHandle;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::thread;\n+\n+extern \"system\" {\n+    fn WaitForSingleObject(handle: usize, timeout: u32) -> u32;\n+}\n+\n+const INFINITE: u32 = u32::MAX;\n+\n+fn main() {\n+    static FLAG: AtomicBool = AtomicBool::new(false);\n+\n+    let blocker = thread::spawn(|| {\n+        while !FLAG.load(Ordering::Relaxed) {\n+            thread::yield_now();\n+        }\n+    })\n+    .into_raw_handle() as usize;\n+\n+    let waiter = move || {\n+        unsafe {\n+            assert_eq!(WaitForSingleObject(blocker, INFINITE), 0);\n+        }\n+    };\n+\n+    let waiter1 = thread::spawn(waiter);\n+    let waiter2 = thread::spawn(waiter);\n+\n+    // this yield ensures `waiter1` & `waiter2` are blocked on `blocker` by this point\n+    thread::yield_now();\n+\n+    FLAG.store(true, Ordering::Relaxed);\n+\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+}"}]}