{"sha": "64bc975d27f86aaa1d3d94921c9c042477b4e88b", "node_id": "C_kwDOAAsO6NoAKDY0YmM5NzVkMjdmODZhYWExZDNkOTQ5MjFjOWMwNDI0NzdiNGU4OGI", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-06T20:08:17Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-11T17:46:01Z"}, "message": "Mention only assoc types changes", "tree": {"sha": "4a42afa0108c4c4bbf804ec224f125fe382e352f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a42afa0108c4c4bbf804ec224f125fe382e352f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64bc975d27f86aaa1d3d94921c9c042477b4e88b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64bc975d27f86aaa1d3d94921c9c042477b4e88b", "html_url": "https://github.com/rust-lang/rust/commit/64bc975d27f86aaa1d3d94921c9c042477b4e88b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64bc975d27f86aaa1d3d94921c9c042477b4e88b/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49d5bef5867012a3ec39a04c81694b64b22f0067", "url": "https://api.github.com/repos/rust-lang/rust/commits/49d5bef5867012a3ec39a04c81694b64b22f0067", "html_url": "https://github.com/rust-lang/rust/commit/49d5bef5867012a3ec39a04c81694b64b22f0067"}], "stats": {"total": 144, "additions": 92, "deletions": 52}, "files": [{"sha": "2f9b8c2107153b70ec40481723549616b0626304", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 69, "deletions": 27, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/64bc975d27f86aaa1d3d94921c9c042477b4e88b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bc975d27f86aaa1d3d94921c9c042477b4e88b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=64bc975d27f86aaa1d3d94921c9c042477b4e88b", "patch": "@@ -2865,11 +2865,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         }\n                     }\n \n-                    let span = expr.span;\n-                    let mut multi_span: MultiSpan = match expr.kind {\n-                        hir::ExprKind::MethodCall(_, _, _, span) => span.into(),\n-                        _ => span.into(),\n-                    };\n+                    let mut primary_spans = vec![];\n+                    let mut span_labels = vec![];\n \n                     // FIXME: visit the ty to see if there's any closure involved, and if there is,\n                     // check whether its evaluated return type is the same as the one corresponding\n@@ -2897,25 +2894,28 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         }\n                     }\n                     let point_at_chain = |expr: &hir::Expr<'_>| {\n+                        let mut assocs = vec![];\n+                        // We still want to point at the different methods even if there hasn't\n+                        // been a change of assoc type.\n+                        let mut call_spans = vec![];\n                         let mut expr = expr;\n                         let mut prev_ty = self.resolve_vars_if_possible(\n                             typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n                         );\n-                        let outer_ty = prev_ty;\n-                        let mut assoc_seen = 0;\n                         while let hir::ExprKind::MethodCall(_path_segment, rcvr_expr, _args, span) =\n                             expr.kind\n                         {\n                             // Point at every method call in the chain with the resulting type.\n                             // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n                             //               ^^^^^^ ^^^^^^^^^^^\n                             expr = rcvr_expr;\n+                            let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n+                            call_spans.push(span);\n \n                             let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n                             for diff in &type_diffs {\n                                 let Sorts(expected_found) = diff else { continue; };\n                                 let ty::Projection(proj) = expected_found.expected.kind() else { continue; };\n-                                assoc_seen += 1;\n \n                                 let origin = TypeVariableOrigin {\n                                     kind: TypeVariableOriginKind::TypeInference,\n@@ -2963,23 +2963,17 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 if ocx.select_where_possible().is_empty() {\n                                     // `ty_var` now holds the type that `Item` is for `ExprTy`.\n                                     let assoc = self.tcx.def_path_str(proj.item_def_id);\n-                                    multi_span.push_span_label(\n-                                        span,\n-                                        &format!(\n-                                            \"associated type `{assoc}` is `{}` here\",\n-                                            self.resolve_vars_if_possible(ty_var),\n-                                        ),\n-                                    );\n+                                    let ty_var = self.resolve_vars_if_possible(ty_var);\n+                                    assocs_in_this_method.push(Some((span, (assoc, ty_var))));\n                                 } else {\n                                     // `<ExprTy as Iterator>` didn't select, so likely we've\n                                     // reached the end of the iterator chain, like the originating\n                                     // `Vec<_>`.\n-                                    multi_span.push_span_label(\n-                                        span,\n-                                        format!(\"this call has type `{prev_ty}`\"),\n-                                    );\n+                                    // Keep the space consistent for later zipping.\n+                                    assocs_in_this_method.push(None);\n                                 }\n                             }\n+                            assocs.push(assocs_in_this_method);\n                             prev_ty = self.resolve_vars_if_possible(\n                                 typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n                             );\n@@ -2992,17 +2986,65 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             // Point at the root expression\n                             // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n                             // ^^^^^^^^^^^^^\n-                            multi_span.push_span_label(\n-                                expr.span,\n-                                format!(\"this expression has type `{ty}`\"),\n-                            );\n+                            span_labels\n+                                .push((expr.span, format!(\"this expression has type `{ty}`\")));\n                         };\n-                        if assoc_seen > 0 {\n-                            // Only show this if it is not a \"trivial\" expression (not a method\n-                            // chain) and there are associated types to talk about.\n+                        // Only show this if it is not a \"trivial\" expression (not a method\n+                        // chain) and there are associated types to talk about.\n+                        let mut assocs = assocs.into_iter().peekable();\n+                        while let Some(assocs_in_method) = assocs.next() {\n+                            let Some(prev_assoc_in_method) = assocs.peek() else {\n+                                for entry in assocs_in_method {\n+                                    let Some((span, (assoc, ty))) = entry else { continue; };\n+                                    primary_spans.push(span);\n+                                    span_labels.push((\n+                                        span,\n+                                        format!(\"associated type `{assoc}` is `{ty}` here\"),\n+                                    ));\n+                                }\n+                                break;\n+                            };\n+                            for (entry, prev_entry) in\n+                                assocs_in_method.into_iter().zip(prev_assoc_in_method.into_iter())\n+                            {\n+                                match (entry, prev_entry) {\n+                                    (Some((span, (assoc, ty))), Some((_, (_, prev_ty)))) => {\n+                                        if ty != *prev_ty {\n+                                            primary_spans.push(span);\n+                                            span_labels.push((\n+                                                span,\n+                                                format!(\"associated type `{assoc}` changed to `{ty}` here\"),\n+                                            ));\n+                                        }\n+                                    }\n+                                    (Some((span, (assoc, ty))), None) => {\n+                                        span_labels.push((\n+                                            span,\n+                                            format!(\"associated type `{assoc}` is `{ty}` here\"),\n+                                        ));\n+                                    }\n+                                    (None, Some(_)) | (None, None) => {}\n+                                }\n+                            }\n+                        }\n+                        for span in call_spans {\n+                            if span_labels.iter().find(|(s, _)| *s == span).is_none() {\n+                                // Ensure we are showing the entire chain, even if the assoc types\n+                                // haven't changed.\n+                                span_labels.push((span, String::new()));\n+                            }\n+                        }\n+                        if !primary_spans.is_empty() {\n+                            let mut multi_span: MultiSpan = primary_spans.into();\n+                            for (span, label) in span_labels {\n+                                multi_span.push_span_label(span, label);\n+                            }\n                             err.span_note(\n                                 multi_span,\n-                                format!(\"the expression is of type `{outer_ty}`\"),\n+                                format!(\n+                                    \"the method call chain might not have had the expected \\\n+                                        associated types\",\n+                                ),\n                             );\n                         }\n                     };"}, {"sha": "eca961633dce967cefc2763aafa0b966912595d0", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64bc975d27f86aaa1d3d94921c9c042477b4e88b/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64bc975d27f86aaa1d3d94921c9c042477b4e88b/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=64bc975d27f86aaa1d3d94921c9c042477b4e88b", "patch": "@@ -22,11 +22,11 @@ LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_rece\n    |\n    = help: the trait `FromIterator<()>` is not implemented for `Vec<(u32, _, _)>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n-note: the expression is of type `Map<std::slice::Iter<'_, (_, _, _)>, [closure@$DIR/issue-34334.rs:5:47: 5:82]>`\n-  --> $DIR/issue-34334.rs:5:43\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-34334.rs:5:36\n    |\n LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n-   |                                 -- ------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n+   |                                 -- ^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` changed to `()` here\n    |                                 |  |\n    |                                 |  associated type `std::iter::Iterator::Item` is `&(_, _, _)` here\n    |                                 this expression has type `Vec<(_, _, _)>`"}, {"sha": "7f97b5bfcbe36b639a31f64ba4b0dddeac09e2ff", "filename": "src/test/ui/issues/issue-66923-show-error-for-correct-call.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64bc975d27f86aaa1d3d94921c9c042477b4e88b/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64bc975d27f86aaa1d3d94921c9c042477b4e88b/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr?ref=64bc975d27f86aaa1d3d94921c9c042477b4e88b", "patch": "@@ -8,7 +8,7 @@ LL |     let x2: Vec<f64> = x1.into_iter().collect();\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n-note: the expression is of type `std::slice::Iter<'_, f64>`\n+note: the method call chain might not have had the expected associated types\n   --> $DIR/issue-66923-show-error-for-correct-call.rs:8:27\n    |\n LL |     let x2: Vec<f64> = x1.into_iter().collect();\n@@ -31,7 +31,7 @@ LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n    = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n-note: the expression is of type `std::slice::Iter<'_, f64>`\n+note: the method call chain might not have had the expected associated types\n   --> $DIR/issue-66923-show-error-for-correct-call.rs:12:17\n    |\n LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();"}, {"sha": "57be01a24422d657a725d90bf08b39e9a37b126f", "filename": "src/test/ui/iterators/invalid-iterator-chain.stderr", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/64bc975d27f86aaa1d3d94921c9c042477b4e88b/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64bc975d27f86aaa1d3d94921c9c042477b4e88b/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finvalid-iterator-chain.stderr?ref=64bc975d27f86aaa1d3d94921c9c042477b4e88b", "patch": "@@ -9,20 +9,18 @@ LL |     println!(\"{}\", scores.sum::<i32>());\n    = help: the following other types implement trait `Sum<A>`:\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n-note: the expression is of type `Map<std::slice::Iter<'_, ({integer}, {integer})>, [closure@$DIR/invalid-iterator-chain.rs:4:14: 4:22]>`\n-  --> $DIR/invalid-iterator-chain.rs:7:20\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:3:10\n    |\n LL |       let scores = vec![(0, 0)]\n    |                    ------------ this expression has type `Vec<({integer}, {integer})>`\n LL |           .iter()\n-   |            ------ associated type `std::iter::Iterator::Item` is `&({integer}, {integer})` here\n+   |            ^^^^^^ associated type `std::iter::Iterator::Item` is `&({integer}, {integer})` here\n LL |           .map(|(a, b)| {\n-   |  __________-\n+   |  __________^\n LL | |             a + b;\n LL | |         });\n-   | |__________- associated type `std::iter::Iterator::Item` is `()` here\n-LL |       println!(\"{}\", scores.sum::<i32>());\n-   |                      ^^^^^^\n+   | |__________^ associated type `std::iter::Iterator::Item` changed to `()` here\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n@@ -46,25 +44,25 @@ LL |               .sum::<i32>(),\n    = help: the following other types implement trait `Sum<A>`:\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n-note: the expression is of type `Map<Map<Filter<Map<Map<Map<std::slice::Iter<'_, {integer}>, [closure@$DIR/invalid-iterator-chain.rs:12:18: 12:21]>, [closure@$DIR/invalid-iterator-chain.rs:13:18: 13:21]>, [closure@$DIR/invalid-iterator-chain.rs:14:18: 14:21]>, [closure@$DIR/invalid-iterator-chain.rs:15:21: 15:24]>, [closure@$DIR/invalid-iterator-chain.rs:16:18: 16:21]>, [closure@$DIR/invalid-iterator-chain.rs:17:18: 17:21]>`\n-  --> $DIR/invalid-iterator-chain.rs:17:14\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:11:14\n    |\n LL |         vec![0, 1]\n    |         ---------- this expression has type `Vec<{integer}>`\n LL |             .iter()\n-   |              ------ associated type `std::iter::Iterator::Item` is `&{integer}` here\n+   |              ^^^^^^ associated type `std::iter::Iterator::Item` is `&{integer}` here\n LL |             .map(|x| x * 2)\n-   |              -------------- associated type `std::iter::Iterator::Item` is `{integer}` here\n+   |              ^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` changed to `{integer}` here\n LL |             .map(|x| x as f64)\n-   |              ----------------- associated type `std::iter::Iterator::Item` is `f64` here\n+   |              ^^^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` changed to `f64` here\n LL |             .map(|x| x as i64)\n-   |              ----------------- associated type `std::iter::Iterator::Item` is `i64` here\n+   |              ^^^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` changed to `i64` here\n LL |             .filter(|x| *x > 0)\n-   |              ------------------ associated type `std::iter::Iterator::Item` is `i64` here\n+   |              ------------------\n LL |             .map(|x| { x + 1 })\n-   |              ------------------ associated type `std::iter::Iterator::Item` is `i64` here\n+   |              ------------------\n LL |             .map(|x| { x; })\n-   |              ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n+   |              ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` changed to `()` here\n note: required by a bound in `std::iter::Iterator::sum`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n@@ -82,11 +80,11 @@ LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n    = help: the following other types implement trait `Sum<A>`:\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n-note: the expression is of type `Map<std::slice::Iter<'_, {integer}>, [closure@$DIR/invalid-iterator-chain.rs:20:42: 20:45]>`\n-  --> $DIR/invalid-iterator-chain.rs:20:38\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/invalid-iterator-chain.rs:20:31\n    |\n LL |     println!(\"{}\", vec![0, 1].iter().map(|x| { x; }).sum::<i32>());\n-   |                    ---------- ------ ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` is `()` here\n+   |                    ---------- ^^^^^^ ^^^^^^^^^^^^^^^ associated type `std::iter::Iterator::Item` changed to `()` here\n    |                    |          |\n    |                    |          associated type `std::iter::Iterator::Item` is `&{integer}` here\n    |                    this expression has type `Vec<{integer}>`\n@@ -107,7 +105,7 @@ LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());\n    = help: the following other types implement trait `Sum<A>`:\n              <i32 as Sum<&'a i32>>\n              <i32 as Sum>\n-note: the expression is of type `std::slice::Iter<'_, ()>`\n+note: the method call chain might not have had the expected associated types\n   --> $DIR/invalid-iterator-chain.rs:21:33\n    |\n LL |     println!(\"{}\", vec![(), ()].iter().sum::<i32>());"}]}