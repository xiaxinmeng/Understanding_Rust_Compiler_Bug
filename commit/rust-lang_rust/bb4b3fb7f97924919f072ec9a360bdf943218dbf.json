{"sha": "bb4b3fb7f97924919f072ec9a360bdf943218dbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNGIzZmI3Zjk3OTI0OTE5ZjA3MmVjOWEzNjBiZGY5NDMyMThkYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T02:30:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T02:30:33Z"}, "message": "Auto merge of #32202 - arielb1:slice-patterns, r=nikomatsakis\n\nImplement RFC495 semantics for slice patterns\n\nnon-MIR translation is still not supported for these and will happily ICE.\n\nThis is a [breaking-change] for many uses of slice_patterns.\n\n[RFC 495 text](https://github.com/rust-lang/rfcs/blob/master/text/0495-array-pattern-changes.md)", "tree": {"sha": "3765d3082b94546c8ea1b23ae75e12aa7b43924b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3765d3082b94546c8ea1b23ae75e12aa7b43924b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb4b3fb7f97924919f072ec9a360bdf943218dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb4b3fb7f97924919f072ec9a360bdf943218dbf", "html_url": "https://github.com/rust-lang/rust/commit/bb4b3fb7f97924919f072ec9a360bdf943218dbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb4b3fb7f97924919f072ec9a360bdf943218dbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34505e22289d3b2416ab0922131e8526d0d5cc0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/34505e22289d3b2416ab0922131e8526d0d5cc0b", "html_url": "https://github.com/rust-lang/rust/commit/34505e22289d3b2416ab0922131e8526d0d5cc0b"}, {"sha": "2de6ea7a35fb53ce5e4a7e5541a2adf425b7da23", "url": "https://api.github.com/repos/rust-lang/rust/commits/2de6ea7a35fb53ce5e4a7e5541a2adf425b7da23", "html_url": "https://github.com/rust-lang/rust/commit/2de6ea7a35fb53ce5e4a7e5541a2adf425b7da23"}], "stats": {"total": 1666, "additions": 934, "deletions": 732}, "files": [{"sha": "2b168b8f0e448e2d265550a6928f87204abce5c7", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -109,7 +109,7 @@ DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n \t\t  \t  rustc_const_math\n DEPS_rustc_back := std syntax flate log libc\n-DEPS_rustc_borrowck := rustc rustc_mir log graphviz syntax\n+DEPS_rustc_borrowck := rustc log graphviz syntax rustc_mir\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n@@ -123,9 +123,9 @@ DEPS_rustc_passes := syntax rustc core rustc_const_eval\n DEPS_rustc_mir := rustc syntax rustc_const_math rustc_const_eval rustc_bitflags\n DEPS_rustc_resolve := arena rustc log syntax\n DEPS_rustc_platform_intrinsics := std\n-DEPS_rustc_plugin := rustc rustc_metadata syntax rustc_mir\n+DEPS_rustc_plugin := rustc rustc_metadata syntax\n DEPS_rustc_privacy := rustc log syntax\n-DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir \\\n+DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n                     rustc_const_math rustc_const_eval rustc_incremental\n DEPS_rustc_incremental := rbml rustc serialize rustc_data_structures"}, {"sha": "fcedf0c994f9c6e0e98be4ee689ce8a71ec0e4f7", "filename": "src/doc/book/slice-patterns.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Fdoc%2Fbook%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Fdoc%2Fbook%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fslice-patterns.md?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     let v = vec![\"match_this\", \"1\"];\n \n     match &v[..] {\n-        [\"match_this\", second] => println!(\"The second element is {}\", second),\n+        &[\"match_this\", second] => println!(\"The second element is {}\", second),\n         _ => {},\n     }\n }\n@@ -26,8 +26,8 @@ slice will be bound to that name. For example:\n \n fn is_symmetric(list: &[u32]) -> bool {\n     match list {\n-        [] | [_] => true,\n-        [x, inside.., y] if x == y => is_symmetric(inside),\n+        &[] | &[_] => true,\n+        &[x, ref inside.., y] if x == y => is_symmetric(inside),\n         _ => false\n     }\n }"}, {"sha": "301c6e3dd1c4ab2425b8d01d75ed5a4790d8d259", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -106,6 +106,7 @@ pub mod mir {\n     pub mod tcx;\n     pub mod visit;\n     pub mod transform;\n+    pub mod traversal;\n     pub mod mir_map;\n }\n "}, {"sha": "ba93e8976771602761dc797a963a97c9fe0733cb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -993,40 +993,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                 }\n-                PatKind::Vec(_, Some(ref slice_pat), _) => {\n-                    // The `slice_pat` here creates a slice into\n-                    // the original vector.  This is effectively a\n-                    // borrow of the elements of the vector being\n-                    // matched.\n-\n-                    let (slice_cmt, slice_mutbl, slice_r) =\n-                        return_if_err!(mc.cat_slice_pattern(cmt_pat, &slice_pat));\n-\n-                    // Note: We declare here that the borrow\n-                    // occurs upon entering the `[...]`\n-                    // pattern. This implies that something like\n-                    // `[a; b]` where `a` is a move is illegal,\n-                    // because the borrow is already in effect.\n-                    // In fact such a move would be safe-ish, but\n-                    // it effectively *requires* that we use the\n-                    // nulling out semantics to indicate when a\n-                    // value has been moved, which we are trying\n-                    // to move away from.  Otherwise, how can we\n-                    // indicate that the first element in the\n-                    // vector has been moved?  Eventually, we\n-                    // could perhaps modify this rule to permit\n-                    // `[..a, b]` where `b` is a move, because in\n-                    // that case we can adjust the length of the\n-                    // original vec accordingly, but we'd have to\n-                    // make trans do the right thing, and it would\n-                    // only work for `Box<[T]>`s. It seems simpler\n-                    // to just require that people call\n-                    // `vec.pop()` or `vec.unshift()`.\n-                    let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);\n-                    delegate.borrow(pat.id, pat.span,\n-                                    slice_cmt, slice_r,\n-                                    slice_bk, RefBinding);\n-                }\n                 _ => {}\n             }\n         }));"}, {"sha": "1ea3a469d9c953103607872a3a5018eff87057cf", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 116, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -228,10 +228,10 @@ fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n             Ok(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n-        ty::TyArray(_, _) | ty::TySlice(_) | ty::TyStr => {\n+        ty::TyArray(_, _) | ty::TySlice(_) => {\n             // no deref of indexed content without supplying InteriorOffsetKind\n             if let Some(context) = context {\n-                Ok(deref_interior(InteriorElement(context, element_kind(t))))\n+                Ok(deref_interior(InteriorElement(context, ElementKind::VecElement)))\n             } else {\n                 Err(())\n             }\n@@ -981,121 +981,31 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let method_call = ty::MethodCall::expr(elt.id());\n         let method_ty = self.infcx.node_method_ty(method_call);\n \n-        let element_ty = match method_ty {\n+        let (element_ty, element_kind) = match method_ty {\n             Some(method_ty) => {\n                 let ref_ty = self.overloaded_method_return_ty(method_ty);\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n \n                 // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n                 let self_ty = method_ty.fn_sig().input(0);\n-                self.tcx().no_late_bound_regions(&self_ty).unwrap()\n+                (self.tcx().no_late_bound_regions(&self_ty).unwrap(),\n+                 ElementKind::OtherElement)\n             }\n             None => {\n                 match base_cmt.ty.builtin_index() {\n-                    Some(ty) => ty,\n+                    Some(ty) => (ty, ElementKind::VecElement),\n                     None => {\n                         return Err(());\n                     }\n                 }\n             }\n         };\n \n-        let m = base_cmt.mutbl.inherit();\n-        let ret = interior(elt, base_cmt.clone(), base_cmt.ty,\n-                           m, context, element_ty);\n+        let interior_elem = InteriorElement(context, element_kind);\n+        let ret =\n+            self.cat_imm_interior(elt, base_cmt.clone(), element_ty, interior_elem);\n         debug!(\"cat_index ret {:?}\", ret);\n         return Ok(ret);\n-\n-        fn interior<'tcx, N: ast_node>(elt: &N,\n-                                       of_cmt: cmt<'tcx>,\n-                                       vec_ty: Ty<'tcx>,\n-                                       mutbl: MutabilityCategory,\n-                                       context: InteriorOffsetKind,\n-                                       element_ty: Ty<'tcx>) -> cmt<'tcx>\n-        {\n-            let interior_elem = InteriorElement(context, element_kind(vec_ty));\n-            Rc::new(cmt_ {\n-                id:elt.id(),\n-                span:elt.span(),\n-                cat:Categorization::Interior(of_cmt, interior_elem),\n-                mutbl:mutbl,\n-                ty:element_ty,\n-                note: NoteNone\n-            })\n-        }\n-    }\n-\n-    // Takes either a vec or a reference to a vec and returns the cmt for the\n-    // underlying vec.\n-    fn deref_vec<N:ast_node>(&self,\n-                             elt: &N,\n-                             base_cmt: cmt<'tcx>,\n-                             context: InteriorOffsetKind)\n-                             -> McResult<cmt<'tcx>>\n-    {\n-        let ret = match deref_kind(base_cmt.ty, Some(context))? {\n-            deref_ptr(ptr) => {\n-                // for unique ptrs, we inherit mutability from the\n-                // owning reference.\n-                let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n-\n-                // the deref is explicit in the resulting cmt\n-                Rc::new(cmt_ {\n-                    id:elt.id(),\n-                    span:elt.span(),\n-                    cat:Categorization::Deref(base_cmt.clone(), 0, ptr),\n-                    mutbl:m,\n-                    ty: match base_cmt.ty.builtin_deref(false, ty::NoPreference) {\n-                        Some(mt) => mt.ty,\n-                        None => bug!(\"Found non-derefable type\")\n-                    },\n-                    note: NoteNone\n-                })\n-            }\n-\n-            deref_interior(_) => {\n-                base_cmt\n-            }\n-        };\n-        debug!(\"deref_vec ret {:?}\", ret);\n-        Ok(ret)\n-    }\n-\n-    /// Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is the cmt for `P`, `slice_pat` is\n-    /// the pattern `Q`, returns:\n-    ///\n-    /// * a cmt for `Q`\n-    /// * the mutability and region of the slice `Q`\n-    ///\n-    /// These last two bits of info happen to be things that borrowck needs.\n-    pub fn cat_slice_pattern(&self,\n-                             vec_cmt: cmt<'tcx>,\n-                             slice_pat: &hir::Pat)\n-                             -> McResult<(cmt<'tcx>, hir::Mutability, ty::Region)> {\n-        let slice_ty = self.node_ty(slice_pat.id)?;\n-        let (slice_mutbl, slice_r) = vec_slice_info(slice_pat, slice_ty);\n-        let context = InteriorOffsetKind::Pattern;\n-        let cmt_vec = self.deref_vec(slice_pat, vec_cmt, context)?;\n-        let cmt_slice = self.cat_index(slice_pat, cmt_vec, context)?;\n-        return Ok((cmt_slice, slice_mutbl, slice_r));\n-\n-        /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n-        /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n-        /// have to recurse through rptrs.\n-        fn vec_slice_info(pat: &hir::Pat, slice_ty: Ty)\n-                          -> (hir::Mutability, ty::Region) {\n-            match slice_ty.sty {\n-                ty::TyRef(r, ref mt) => match mt.ty.sty {\n-                    ty::TySlice(_) => (mt.mutbl, *r),\n-                    _ => vec_slice_info(pat, mt.ty),\n-                },\n-\n-                _ => {\n-                    span_bug!(pat.span,\n-                              \"type of slice pattern is not a slice\");\n-                }\n-            }\n-        }\n     }\n \n     pub fn cat_imm_interior<N:ast_node>(&self,\n@@ -1319,15 +1229,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           PatKind::Vec(ref before, ref slice, ref after) => {\n               let context = InteriorOffsetKind::Pattern;\n-              let vec_cmt = self.deref_vec(pat, cmt, context)?;\n-              let elt_cmt = self.cat_index(pat, vec_cmt, context)?;\n+              let elt_cmt = self.cat_index(pat, cmt, context)?;\n               for before_pat in before {\n                   self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n               }\n               if let Some(ref slice_pat) = *slice {\n-                  let slice_ty = self.pat_ty(&slice_pat)?;\n-                  let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  self.cat_pattern_(slice_cmt, &slice_pat, op)?;\n+                  self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n               }\n               for after_pat in after {\n                   self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n@@ -1620,18 +1527,6 @@ impl fmt::Debug for InteriorKind {\n     }\n }\n \n-fn element_kind(t: Ty) -> ElementKind {\n-    match t.sty {\n-        ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-        ty::TyBox(ty) => match ty.sty {\n-            ty::TySlice(_) => VecElement,\n-            _ => OtherElement\n-        },\n-        ty::TyArray(..) | ty::TySlice(_) => VecElement,\n-        _ => OtherElement\n-    }\n-}\n-\n impl fmt::Debug for Upvar {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:?}/{:?}\", self.id, self.kind)"}, {"sha": "7aaaf38400e878586d1e3476e5817a4dfd107e14", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -674,6 +674,14 @@ pub enum ProjectionElem<'tcx, V> {\n         from_end: bool,\n     },\n \n+    /// These indices are generated by slice patterns.\n+    ///\n+    /// slice[from:-to] in Python terms.\n+    Subslice {\n+        from: u32,\n+        to: u32,\n+    },\n+\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n@@ -753,6 +761,14 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n                         write!(fmt, \"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n                         write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n+                    ProjectionElem::Subslice { from, to } if to == 0 =>\n+                        write!(fmt, \"{:?}[{:?}:\", data.base, from),\n+                    ProjectionElem::Subslice { from, to } if from == 0 =>\n+                        write!(fmt, \"{:?}[:-{:?}]\", data.base, to),\n+                    ProjectionElem::Subslice { from, to } =>\n+                        write!(fmt, \"{:?}[{:?}:-{:?}]\", data.base,\n+                               from, to),\n+\n                 },\n         }\n     }\n@@ -856,17 +872,6 @@ pub enum Rvalue<'tcx> {\n     /// away after type-checking and before lowering.\n     Aggregate(AggregateKind<'tcx>, Vec<Operand<'tcx>>),\n \n-    /// Generates a slice of the form `&input[from_start..L-from_end]`\n-    /// where `L` is the length of the slice. This is only created by\n-    /// slice pattern matching, so e.g. a pattern of the form `[x, y,\n-    /// .., z]` might create a slice with `from_start=2` and\n-    /// `from_end=1`.\n-    Slice {\n-        input: Lvalue<'tcx>,\n-        from_start: usize,\n-        from_end: usize,\n-    },\n-\n     InlineAsm {\n         asm: InlineAsm,\n         outputs: Vec<Lvalue<'tcx>>,\n@@ -972,8 +977,6 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n             }\n-            Slice { ref input, from_start, from_end } =>\n-                write!(fmt, \"{:?}[{:?}..-{:?}]\", input, from_start, from_end),\n \n             Ref(_, borrow_kind, ref lv) => {\n                 let kind_str = match borrow_kind {"}, {"sha": "270e33c48f1a0b411b8f38374621eced24ee14ed", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -59,6 +59,20 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n                 LvalueTy::Ty {\n                     ty: self.to_ty(tcx).builtin_index().unwrap()\n                 },\n+            ProjectionElem::Subslice { from, to } => {\n+                let ty = self.to_ty(tcx);\n+                LvalueTy::Ty {\n+                    ty: match ty.sty {\n+                        ty::TyArray(inner, size) => {\n+                            tcx.mk_array(inner, size-(from as usize)-(to as usize))\n+                        }\n+                        ty::TySlice(..) => ty,\n+                        _ => {\n+                            bug!(\"cannot subslice non-array type: `{:?}`\", self)\n+                        }\n+                    }\n+                }\n+            }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match self.to_ty(tcx).sty {\n                     ty::TyEnum(adt_def, substs) => {\n@@ -219,7 +233,6 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n                     }\n                 }\n             }\n-            Rvalue::Slice { .. } => None,\n             Rvalue::InlineAsm { .. } => None\n         }\n     }"}, {"sha": "c4e4936df954194885af2c7d4f56539782fb8290", "filename": "src/librustc/mir/traversal.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -12,7 +12,7 @@ use std::vec;\n \n use rustc_data_structures::bitvec::BitVector;\n \n-use rustc::mir::repr::*;\n+use super::repr::*;\n \n /// Preorder traversal of a graph.\n ///", "previous_filename": "src/librustc_mir/traversal.rs"}, {"sha": "22b3caf6d0c0ff6e60f8668bccc788452fa3b3eb", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -533,15 +533,6 @@ macro_rules! make_mir_visitor {\n                         }\n                     }\n \n-                    Rvalue::Slice { ref $($mutability)* input,\n-                                    from_start,\n-                                    from_end } => {\n-                        self.visit_lvalue(input, LvalueContext::Slice {\n-                            from_start: from_start,\n-                            from_end: from_end,\n-                        });\n-                    }\n-\n                     Rvalue::InlineAsm { ref $($mutability)* outputs,\n                                         ref $($mutability)* inputs,\n                                         asm: _ } => {\n@@ -602,6 +593,8 @@ macro_rules! make_mir_visitor {\n                 match *proj {\n                     ProjectionElem::Deref => {\n                     }\n+                    ProjectionElem::Subslice { from: _, to: _ } => {\n+                    }\n                     ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n                         self.visit_ty(ty);\n                     }"}, {"sha": "d305a772ae5dbae1205010fc176edbca540db5a3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -17,6 +17,8 @@ use session::Session;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n+use util::common::slice_pat;\n+\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n@@ -98,17 +100,17 @@ impl TargetDataLayout {\n \n         let mut dl = TargetDataLayout::default();\n         for spec in sess.target.target.data_layout.split(\"-\") {\n-            match &spec.split(\":\").collect::<Vec<_>>()[..] {\n-                [\"e\"] => dl.endian = Endian::Little,\n-                [\"E\"] => dl.endian = Endian::Big,\n-                [\"a\", a..] => dl.aggregate_align = align(a, \"a\"),\n-                [\"f32\", a..] => dl.f32_align = align(a, \"f32\"),\n-                [\"f64\", a..] => dl.f64_align = align(a, \"f64\"),\n-                [p @ \"p\", s, a..] | [p @ \"p0\", s, a..] => {\n+            match slice_pat(&&spec.split(\":\").collect::<Vec<_>>()[..]) {\n+                &[\"e\"] => dl.endian = Endian::Little,\n+                &[\"E\"] => dl.endian = Endian::Big,\n+                &[\"a\", ref a..] => dl.aggregate_align = align(a, \"a\"),\n+                &[\"f32\", ref a..] => dl.f32_align = align(a, \"f32\"),\n+                &[\"f64\", ref a..] => dl.f64_align = align(a, \"f64\"),\n+                &[p @ \"p\", s, ref a..] | &[p @ \"p0\", s, ref a..] => {\n                     dl.pointer_size = size(s, p);\n                     dl.pointer_align = align(a, p);\n                 }\n-                [s, a..] if s.starts_with(\"i\") => {\n+                &[s, ref a..] if s.starts_with(\"i\") => {\n                     let ty_align = match s[1..].parse::<u64>() {\n                         Ok(1) => &mut dl.i8_align,\n                         Ok(8) => &mut dl.i8_align,\n@@ -123,7 +125,7 @@ impl TargetDataLayout {\n                     };\n                     *ty_align = align(a, s);\n                 }\n-                [s, a..] if s.starts_with(\"v\") => {\n+                &[s, ref a..] if s.starts_with(\"v\") => {\n                     let v_size = size(&s[1..], \"v\");\n                     let a = align(a, s);\n                     if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {"}, {"sha": "57c429152c89935d72c8add0e7d2b551afd760d0", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -247,3 +247,15 @@ pub fn path2cstr(p: &Path) -> CString {\n pub fn path2cstr(p: &Path) -> CString {\n     CString::new(p.to_str().unwrap()).unwrap()\n }\n+\n+// FIXME(stage0): remove this\n+// HACK: this is needed because the interpretation of slice\n+// patterns changed between stage0 and now.\n+#[cfg(stage0)]\n+pub fn slice_pat<'a, 'b, T>(t: &'a &'b [T]) -> &'a &'b [T] {\n+    t\n+}\n+#[cfg(not(stage0))]\n+pub fn slice_pat<'a, 'b, T>(t: &'a &'b [T]) -> &'b [T] {\n+    *t\n+}"}, {"sha": "155b615d83c7b704262e424fc49a652cafab8b27", "filename": "src/librustc_borrowck/borrowck/mir/abs_domain.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -49,6 +49,8 @@ impl<'tcx> Lift for LvalueElem<'tcx> {\n                 ProjectionElem::Field(f.clone(), ty.clone()),\n             ProjectionElem::Index(ref i) =>\n                 ProjectionElem::Index(i.lift()),\n+            ProjectionElem::Subslice {from, to} =>\n+                ProjectionElem::Subslice { from: from, to: to },\n             ProjectionElem::ConstantIndex {offset,min_length,from_end} =>\n                 ProjectionElem::ConstantIndex {\n                     offset: offset,"}, {"sha": "1acee8e64a9af4ffd2b3aa28f160548157977389", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -620,22 +620,6 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                         Rvalue::Ref(..) |\n                         Rvalue::Len(..) |\n                         Rvalue::InlineAsm { .. } => {}\n-\n-                        Rvalue::Slice {..} => {\n-                            // A slice pattern `x..` binds `x` to a\n-                            // reference; thus no move occurs.\n-                            //\n-                            // FIXME: I recall arielb1 questioning\n-                            // whether this is even a legal thing to\n-                            // have as an R-value. The particular\n-                            // example where I am seeing this arise is\n-                            // `TargetDataLayout::parse(&Session)` in\n-                            // `rustc::ty::layout`.\n-                            //\n-                            // this should be removed soon.\n-                            debug!(\"encountered Rvalue::Slice as RHS of Assign, source: {:?}\",\n-                                   source);\n-                        }\n                     }\n                 }\n             }"}, {"sha": "1380e0b45f27916f46dfa8ca7c87dfa0e2292b32", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 152, "deletions": 127, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -42,14 +42,15 @@ use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::common::slice_pat;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n     node: PatKind::Wild,\n     span: DUMMY_SP\n };\n \n-struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n+struct Matrix<'a, 'tcx>(Vec<Vec<(&'a Pat, Option<Ty<'tcx>>)>>);\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n@@ -63,14 +64,14 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n /// ++++++++++++++++++++++++++\n /// + _     + [_, _, ..tail] +\n /// ++++++++++++++++++++++++++\n-impl<'a> fmt::Debug for Matrix<'a> {\n+impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"\\n\")?;\n \n         let &Matrix(ref m) = self;\n         let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n             row.iter()\n-               .map(|&pat| pat_to_string(&pat))\n+               .map(|&(pat,ty)| format!(\"{}: {:?}\", pat_to_string(&pat), ty))\n                .collect::<Vec<String>>()\n         }).collect();\n \n@@ -97,8 +98,10 @@ impl<'a> fmt::Debug for Matrix<'a> {\n     }\n }\n \n-impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n-    fn from_iter<T: IntoIterator<Item=Vec<&'a Pat>>>(iter: T) -> Matrix<'a> {\n+impl<'a, 'tcx> FromIterator<Vec<(&'a Pat, Option<Ty<'tcx>>)>> for Matrix<'a, 'tcx> {\n+    fn from_iter<T: IntoIterator<Item=Vec<(&'a Pat, Option<Ty<'tcx>>)>>>(iter: T)\n+                                                                         -> Self\n+    {\n         Matrix(iter.into_iter().collect())\n     }\n }\n@@ -109,7 +112,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub param_env: ParameterEnvironment<'tcx>,\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum Constructor {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g. struct patterns and fixed-length arrays.\n@@ -229,7 +232,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n-                .map(|pat| vec![&**pat])\n+                .map(|pat| vec![wrap_pat(cx, &pat)])\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix, source);\n         },\n@@ -301,7 +304,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms {\n         for pat in pats {\n-            let v = vec![&**pat];\n+            let v = vec![wrap_pat(cx, &pat)];\n \n             match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n                 NotUseful => {\n@@ -341,8 +344,9 @@ fn check_arms(cx: &MatchCheckCtxt,\n                                                            \"unreachable pattern\");\n                             // if we had a catchall pattern, hint at that\n                             for row in &seen.0 {\n-                                if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0]) {\n-                                    span_note!(err, row[0].span, \"this pattern matches any value\");\n+                                if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0].0) {\n+                                    span_note!(err, row[0].0.span,\n+                                               \"this pattern matches any value\");\n                                 }\n                             }\n                             err.emit();\n@@ -383,20 +387,23 @@ fn raw_pat(p: &Pat) -> &Pat {\n     }\n }\n \n-fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir::MatchSource) {\n-    match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n+fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                              sp: Span,\n+                              matrix: &Matrix<'a, 'tcx>,\n+                              source: hir::MatchSource) {\n+    match is_useful(cx, matrix, &[(DUMMY_WILD_PAT, None)], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n                 vec![DUMMY_WILD_PAT]\n             } else {\n-                pats.iter().map(|w| &**w ).collect()\n+                pats.iter().map(|w| &**w).collect()\n             };\n             match source {\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witnesses[0].node {\n-                        PatKind::TupleStruct(_, ref pats, _) => match &pats[..] {\n-                            [ref pat] => &**pat,\n+                        PatKind::TupleStruct(_, ref pats, _) => match slice_pat(&&pats[..]) {\n+                            &[ref pat] => &**pat,\n                             _ => bug!(),\n                         },\n                         _ => bug!(),\n@@ -584,31 +591,19 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n             }\n         }\n \n-        ty::TyRef(_, ty::TypeAndMut { ty, mutbl }) => {\n-            match ty.sty {\n-               ty::TyArray(_, n) => match ctor {\n-                    &Single => {\n-                        assert_eq!(pats_len, n);\n-                        PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n-                    },\n-                    _ => bug!()\n-                },\n-                ty::TySlice(_) => match ctor {\n-                    &Slice(n) => {\n-                        assert_eq!(pats_len, n);\n-                        PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n-                    },\n-                    _ => bug!()\n-                },\n-                ty::TyStr => PatKind::Wild,\n-\n-                _ => {\n-                    assert_eq!(pats_len, 1);\n-                    PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n-                }\n-            }\n+        ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n+            assert_eq!(pats_len, 1);\n+            PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n         }\n \n+        ty::TySlice(_) => match ctor {\n+            &Slice(n) => {\n+                assert_eq!(pats_len, n);\n+                PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n+            },\n+            _ => unreachable!()\n+        },\n+\n         ty::TyArray(_, len) => {\n             assert_eq!(pats_len, len);\n             PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n@@ -643,7 +638,7 @@ impl Constructor {\n fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length))\n+        .flat_map(|row| pat_constructors(cx, row[0].0, left_ty, max_slice_length))\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n         .into_iter()\n@@ -660,13 +655,8 @@ fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n     match left_ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n-\n-        ty::TyRef(_, ty::TypeAndMut { ty, .. }) => match ty.sty {\n-            ty::TySlice(_) =>\n-                (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n-            _ => vec![Single]\n-        },\n-\n+        ty::TySlice(_) =>\n+            (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n         ty::TyEnum(def, _) => def.variants.iter().map(|v| Variant(v.did)).collect(),\n         _ => vec![Single]\n     }\n@@ -685,13 +675,13 @@ fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt,\n-             matrix: &Matrix,\n-             v: &[&Pat],\n-             witness: WitnessPreference)\n-             -> Usefulness {\n+fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                       matrix: &Matrix<'a, 'tcx>,\n+                       v: &[(&Pat, Option<Ty<'tcx>>)],\n+                       witness: WitnessPreference)\n+                       -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n-    debug!(\"{:?}\", matrix);\n+    debug!(\"is_useful({:?}, {:?})\", matrix, v);\n     if rows.is_empty() {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec!()),\n@@ -702,32 +692,25 @@ fn is_useful(cx: &MatchCheckCtxt,\n         return NotUseful;\n     }\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n-    let real_pat = match rows.iter().find(|r| (*r)[0].id != DUMMY_NODE_ID) {\n-        Some(r) => raw_pat(r[0]),\n-        None if v.is_empty() => return NotUseful,\n-        None => v[0]\n-    };\n-    let left_ty = if real_pat.id == DUMMY_NODE_ID {\n-        cx.tcx.mk_nil()\n-    } else {\n-        let left_ty = cx.tcx.pat_ty(&real_pat);\n-\n-        match real_pat.node {\n-            PatKind::Binding(hir::BindByRef(..), _, _) => {\n-                left_ty.builtin_deref(false, NoPreference).unwrap().ty\n-            }\n-            _ => left_ty,\n+    let left_ty = match rows.iter().filter_map(|r| r[0].1).next().or_else(|| v[0].1) {\n+        Some(ty) => ty,\n+        None => {\n+            // all patterns are wildcards - we can pick any type we want\n+            cx.tcx.types.bool\n         }\n     };\n \n-    let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n+    let max_slice_length = rows.iter().filter_map(|row| match row[0].0.node {\n         PatKind::Vec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n \n-    let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n+    let constructors = pat_constructors(cx, v[0].0, left_ty, max_slice_length);\n+    debug!(\"is_useful - pat_constructors = {:?} left_ty = {:?}\", constructors,\n+           left_ty);\n     if constructors.is_empty() {\n         let constructors = missing_constructors(cx, matrix, left_ty, max_slice_length);\n+        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n         if constructors.is_empty() {\n             all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n                 match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n@@ -748,7 +731,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n             }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n-                match raw_pat(r[0]).node {\n+                match raw_pat(r[0].0).node {\n                     PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n                     _ => None,\n                 }\n@@ -773,9 +756,14 @@ fn is_useful(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n-                         v: &[&Pat], ctor: Constructor, lty: Ty,\n-                         witness: WitnessPreference) -> Usefulness {\n+fn is_useful_specialized<'a, 'tcx>(\n+    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    &Matrix(ref m): &Matrix<'a, 'tcx>,\n+    v: &[(&Pat, Option<Ty<'tcx>>)],\n+    ctor: Constructor,\n+    lty: Ty<'tcx>,\n+    witness: WitnessPreference) -> Usefulness\n+{\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n         specialize(cx, &r[..], &ctor, 0, arity)\n@@ -818,13 +806,14 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n         PatKind::Vec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n                 ty::TyArray(_, _) => vec![Single],\n-                _                      => if slice.is_some() {\n+                ty::TySlice(_) if slice.is_some() => {\n                     (before.len() + after.len()..max_slice_length+1)\n                         .map(|length| Slice(length))\n                         .collect()\n-                } else {\n-                    vec![Slice(before.len() + after.len())]\n                 }\n+                ty::TySlice(_) => vec!(Slice(before.len() + after.len())),\n+                _ => span_bug!(pat.span, \"pat_constructors: unexpected \\\n+                                          slice pattern type {:?}\", left_ty)\n             },\n         PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n             vec![Single],\n@@ -839,18 +828,16 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+    debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n         ty::TyBox(_) => 1,\n-        ty::TyRef(_, ty::TypeAndMut { ty, .. }) => match ty.sty {\n-            ty::TySlice(_) => match *ctor {\n-                Slice(length) => length,\n-                ConstantValue(_) => 0,\n-                _ => bug!()\n-            },\n-            ty::TyStr => 0,\n-            _ => 1\n+        ty::TySlice(_) => match *ctor {\n+            Slice(length) => length,\n+            ConstantValue(_) => 0,\n+            _ => bug!()\n         },\n+        ty::TyRef(..) => 1,\n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _) => {\n             ctor.variant_for_adt(adt).fields.len()\n         }\n@@ -877,6 +864,19 @@ fn range_covered_by_constructor(ctor: &Constructor,\n     }\n }\n \n+fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n+                          pat: &'a Pat)\n+                          -> (&'a Pat, Option<Ty<'tcx>>)\n+{\n+    let pat_ty = cx.tcx.pat_ty(pat);\n+    (pat, Some(match pat.node {\n+        PatKind::Binding(hir::BindByRef(..), _, _) => {\n+            pat_ty.builtin_deref(false, NoPreference).unwrap().ty\n+        }\n+        _ => pat_ty\n+    }))\n+}\n+\n /// This is the main specialization step. It expands the first pattern in the given row\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n@@ -885,14 +885,22 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n-                      constructor: &Constructor, col: usize, arity: usize) -> Option<Vec<&'a Pat>> {\n+pub fn specialize<'a, 'b, 'tcx>(\n+    cx: &MatchCheckCtxt<'b, 'tcx>,\n+    r: &[(&'a Pat, Option<Ty<'tcx>>)],\n+    constructor: &Constructor, col: usize, arity: usize)\n+    -> Option<Vec<(&'a Pat, Option<Ty<'tcx>>)>>\n+{\n+    let pat = raw_pat(r[col].0);\n     let &Pat {\n         id: pat_id, ref node, span: pat_span\n-    } = raw_pat(r[col]);\n-    let head: Option<Vec<&Pat>> = match *node {\n+    } = pat;\n+    let wpat = |pat: &'a Pat| wrap_pat(cx, pat);\n+    let dummy_pat = (DUMMY_WILD_PAT, None);\n+\n+    let head: Option<Vec<(&Pat, Option<Ty>)>> = match *node {\n         PatKind::Binding(..) | PatKind::Wild =>\n-            Some(vec![DUMMY_WILD_PAT; arity]),\n+            Some(vec![dummy_pat; arity]),\n \n         PatKind::Path(..) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n@@ -917,12 +925,14 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Def::Variant(..) | Def::Struct(..) => {\n                     match ddpos {\n                         Some(ddpos) => {\n-                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| &**p).collect();\n-                            pats.extend(repeat(DUMMY_WILD_PAT).take(arity - args.len()));\n-                            pats.extend(args[ddpos..].iter().map(|p| &**p));\n+                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n+                                wpat(p)\n+                            }).collect();\n+                            pats.extend(repeat((DUMMY_WILD_PAT, None)).take(arity - args.len()));\n+                            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n                             Some(pats)\n                         }\n-                        None => Some(args.iter().map(|p| &**p).collect())\n+                        None => Some(args.iter().map(|p| wpat(p)).collect())\n                     }\n                 }\n                 _ => None\n@@ -941,8 +951,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             if variant.did == def_variant.did {\n                 Some(variant.fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.name == sf.name) {\n-                        Some(ref f) => &*f.node.pat,\n-                        _ => DUMMY_WILD_PAT\n+                        Some(ref f) => wpat(&f.node.pat),\n+                        _ => dummy_pat\n                     }\n                 }).collect())\n             } else {\n@@ -951,25 +961,32 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         PatKind::Tuple(ref args, Some(ddpos)) => {\n-            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| &**p).collect();\n-            pats.extend(repeat(DUMMY_WILD_PAT).take(arity - args.len()));\n-            pats.extend(args[ddpos..].iter().map(|p| &**p));\n+            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| wpat(p)).collect();\n+            pats.extend(repeat(dummy_pat).take(arity - args.len()));\n+            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n             Some(pats)\n         }\n         PatKind::Tuple(ref args, None) =>\n-            Some(args.iter().map(|p| &**p).collect()),\n+            Some(args.iter().map(|p| wpat(&**p)).collect()),\n \n         PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>\n-            Some(vec![&**inner]),\n+            Some(vec![wpat(&**inner)]),\n \n         PatKind::Lit(ref expr) => {\n-            let expr_value = eval_const_expr(cx.tcx, &expr);\n-            match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n-                Some(true) => Some(vec![]),\n-                Some(false) => None,\n-                None => {\n-                    span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n-                    None\n+            if let Some(&ty::TyS { sty: ty::TyRef(_, mt), .. }) = r[col].1 {\n+                // HACK: handle string literals. A string literal pattern\n+                // serves both as an unary reference pattern and as a\n+                // nullary value pattern, depending on the type.\n+                Some(vec![(pat, Some(mt.ty))])\n+            } else {\n+                let expr_value = eval_const_expr(cx.tcx, &expr);\n+                match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n+                    Some(true) => Some(vec![]),\n+                    Some(false) => None,\n+                    None => {\n+                        span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n+                        None\n+                    }\n                 }\n             }\n         }\n@@ -988,37 +1005,45 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         PatKind::Vec(ref before, ref slice, ref after) => {\n+            let pat_len = before.len() + after.len();\n             match *constructor {\n-                // Fixed-length vectors.\n                 Single => {\n-                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n-                    pats.extend(after.iter().map(|p| &**p));\n-                    Some(pats)\n-                },\n-                Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n-                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n-                    pats.extend(after.iter().map(|p| &**p));\n-                    Some(pats)\n-                },\n-                Slice(length) if before.len() + after.len() == length => {\n-                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.extend(after.iter().map(|p| &**p));\n-                    Some(pats)\n+                    // Fixed-length vectors.\n+                    Some(\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        repeat(dummy_pat).take(arity - pat_len).chain(\n+                        after.iter().map(|p| wpat(p))\n+                    )).collect())\n                 },\n+                Slice(length) if pat_len <= length && slice.is_some() => {\n+                    Some(\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        repeat(dummy_pat).take(arity - pat_len).chain(\n+                        after.iter().map(|p| wpat(p))\n+                    )).collect())\n+                }\n+                Slice(length) if pat_len == length => {\n+                    Some(\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        after.iter().map(|p| wpat(p))\n+                    ).collect())\n+                }\n                 SliceWithSubslice(prefix, suffix)\n                     if before.len() == prefix\n                         && after.len() == suffix\n                         && slice.is_some() => {\n-                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.extend(after.iter().map(|p| &**p));\n+                    // this is used by trans::_match only\n+                    let mut pats: Vec<_> = before.iter()\n+                        .map(|p| (&**p, None)).collect();\n+                    pats.extend(after.iter().map(|p| (&**p, None)));\n                     Some(pats)\n                 }\n                 _ => None\n             }\n         }\n     };\n+    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n+\n     head.map(|mut head| {\n         head.extend_from_slice(&r[..col]);\n         head.extend_from_slice(&r[col + 1..]);\n@@ -1076,8 +1101,8 @@ fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A> where\n     F: FnOnce(&Pat) -> A,\n {\n-    let pats = Matrix(vec!(vec!(pat)));\n-    match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n+    let pats = Matrix(vec!(vec!(wrap_pat(cx, pat))));\n+    match is_useful(cx, &pats, &[(DUMMY_WILD_PAT, None)], ConstructWitness) {\n         UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n         NotUseful => None,\n         Useful => bug!()"}, {"sha": "b7f14fffafb779dbaf990a8d876f80668e80bba5", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n+use util::common::slice_pat;\n use util::nodemap::{FnvHashSet};\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -459,8 +460,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 // Check for a repr() attribute to specify the size of the\n                 // discriminant.\n                 let repr_hints = cx.lookup_repr_hints(def.did);\n-                match &**repr_hints {\n-                    [] => {\n+                match slice_pat(&&**repr_hints) {\n+                    &[] => {\n                         // Special-case types like `Option<extern fn()>`.\n                         if !is_repr_nullable_ptr(cx, def, substs) {\n                             return FfiUnsafe(\n@@ -470,7 +471,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                  the type\")\n                         }\n                     }\n-                    [ref hint] => {\n+                    &[ref hint] => {\n                         if !hint.is_ffi_safe() {\n                             // FIXME: This shouldn't be reachable: we should check\n                             // this earlier."}, {"sha": "14b4dbdd9cff4e8a94c040a5c7e79ffa90cdf2fb", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 69, "deletions": 24, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -429,42 +429,87 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// simpler (and, in fact, irrefutable).\n     ///\n     /// But there may also be candidates that the test just doesn't\n-    /// apply to. For example, consider the case of #29740:\n+    /// apply to. The classical example involves wildcards:\n     ///\n     /// ```rust,ignore\n+    /// match (x, y, z) {\n+    ///     (true, _, true) => true,    // (0)\n+    ///     (_, true, _) => true,       // (1)\n+    ///     (false, false, _) => false, // (2)\n+    ///     (true, _, false) => false,  // (3)\n+    /// }\n+    /// ```\n+    ///\n+    /// In that case, after we test on `x`, there are 2 overlapping candidate\n+    /// sets:\n+    ///\n+    /// - If the outcome is that `x` is true, candidates 0, 1, and 3\n+    /// - If the outcome is that `x` is false, candidates 1 and 2\n+    ///\n+    /// Here, the traditional \"decision tree\" method would generate 2\n+    /// separate code-paths for the 2 separate cases.\n+    ///\n+    /// In some cases, this duplication can create an exponential amount of\n+    /// code. This is most easily seen by noticing that this method terminates\n+    /// with precisely the reachable arms being reachable - but that problem\n+    /// is trivially NP-complete:\n+    ///\n+    /// ```rust\n+    ///     match (var0, var1, var2, var3, ..) {\n+    ///         (true, _, _, false, true, ...) => false,\n+    ///         (_, true, true, false, _, ...) => false,\n+    ///         (false, _, false, false, _, ...) => false,\n+    ///         ...\n+    ///         _ => true\n+    ///     }\n+    /// ```\n+    ///\n+    /// Here the last arm is reachable only if there is an assignment to\n+    /// the variables that does not match any of the literals. Therefore,\n+    /// compilation would take an exponential amount of time in some cases.\n+    ///\n+    /// That kind of exponential worst-case might not occur in practice, but\n+    /// our simplistic treatment of constants and guards would make it occur\n+    /// in very common situations - for example #29740:\n+    ///\n+    /// ```rust\n     /// match x {\n-    ///     \"foo\" => ...,\n-    ///     \"bar\" => ...,\n-    ///     \"baz\" => ...,\n-    ///     _ => ...,\n+    ///     \"foo\" if foo_guard => ...,\n+    ///     \"bar\" if bar_guard => ...,\n+    ///     \"baz\" if baz_guard => ...,\n+    ///     ...\n     /// }\n     /// ```\n     ///\n-    /// Here the match-pair we are testing will be `x @ \"foo\"`, and we\n-    /// will generate an `Eq` test. Because `\"bar\"` and `\"baz\"` are different\n-    /// constants, we will decide that these later candidates are just not\n-    /// informed by the eq test. So we'll wind up with three candidate sets:\n+    /// Here we first test the match-pair `x @ \"foo\"`, which is an `Eq` test.\n+    ///\n+    /// It might seem that we would end up with 2 disjoint candidate\n+    /// sets, consisting of the first candidate or the other 3, but our\n+    /// algorithm doesn't reason about \"foo\" being distinct from the other\n+    /// constants; it considers the latter arms to potentially match after\n+    /// both outcomes, which obviously leads to an exponential amount\n+    /// of tests.\n     ///\n-    /// - If outcome is that `x == \"foo\"` (one candidate, derived from `x @ \"foo\"`)\n-    /// - If outcome is that `x != \"foo\"` (empty list of candidates)\n-    /// - Otherwise (three candidates, `x @ \"bar\"`, `x @ \"baz\"`, `x @\n-    ///   _`). Here we have the invariant that everything in the\n-    ///   otherwise list is of **lower priority** than the stuff in the\n-    ///   other lists.\n+    /// To avoid these kinds of problems, our algorithm tries to ensure\n+    /// the amount of generated tests is linear. When we do a k-way test,\n+    /// we return an additional \"unmatched\" set alongside the obvious `k`\n+    /// sets. When we encounter a candidate that would be present in more\n+    /// than one of the sets, we put it and all candidates below it into the\n+    /// \"unmatched\" set. This ensures these `k+1` sets are disjoint.\n     ///\n-    /// So we'll compile the test. For each outcome of the test, we\n-    /// recursively call `match_candidates` with the corresponding set\n-    /// of candidates. But note that this set is now inexhaustive: for\n-    /// example, in the case where the test returns false, there are\n-    /// NO candidates, even though there is stll a value to be\n-    /// matched. So we'll collect the return values from\n-    /// `match_candidates`, which are the blocks where control-flow\n-    /// goes if none of the candidates matched. At this point, we can\n-    /// continue with the \"otherwise\" list.\n+    /// After we perform our test, we branch into the appropriate candidate\n+    /// set and recurse with `match_candidates`. These sub-matches are\n+    /// obviously inexhaustive - as we discarded our otherwise set - so\n+    /// we set their continuation to do `match_candidates` on the\n+    /// \"unmatched\" set (which is again inexhaustive).\n     ///\n     /// If you apply this to the above test, you basically wind up\n     /// with an if-else-if chain, testing each candidate in turn,\n     /// which is precisely what we want.\n+    ///\n+    /// In addition to avoiding exponential-time blowups, this algorithm\n+    /// also has nice property that each guard and arm is only generated\n+    /// once.\n     fn test_candidates<'pat>(&mut self,\n                              span: Span,\n                              arm_blocks: &mut ArmBlocks,"}, {"sha": "8392248e3f22e2088ffe6e99e4e38cb4f47bbcbd", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -31,18 +31,16 @@ use std::mem;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn simplify_candidate<'pat>(&mut self,\n-                                    mut block: BasicBlock,\n+                                    block: BasicBlock,\n                                     candidate: &mut Candidate<'pat, 'tcx>)\n                                     -> BlockAnd<()> {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n             let mut progress = match_pairs.len(); // count how many were simplified\n             for match_pair in match_pairs {\n-                match self.simplify_match_pair(block, match_pair, candidate) {\n-                    Ok(b) => {\n-                        block = b;\n-                    }\n+                match self.simplify_match_pair(match_pair, candidate) {\n+                    Ok(()) => {}\n                     Err(match_pair) => {\n                         candidate.match_pairs.push(match_pair);\n                         progress -= 1; // this one was not simplified\n@@ -61,14 +59,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// possible, Err is returned and no changes are made to\n     /// candidate.\n     fn simplify_match_pair<'pat>(&mut self,\n-                                 mut block: BasicBlock,\n                                  match_pair: MatchPair<'pat, 'tcx>,\n                                  candidate: &mut Candidate<'pat, 'tcx>)\n-                                 -> Result<BasicBlock, MatchPair<'pat, 'tcx>> {\n+                                 -> Result<(), MatchPair<'pat, 'tcx>> {\n         match *match_pair.pattern.kind {\n             PatternKind::Wild => {\n                 // nothing left to do\n-                Ok(block)\n+                Ok(())\n             }\n \n             PatternKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n@@ -87,7 +84,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     candidate.match_pairs.push(MatchPair::new(match_pair.lvalue, subpattern));\n                 }\n \n-                Ok(block)\n+                Ok(())\n             }\n \n             PatternKind::Constant { .. } => {\n@@ -96,37 +93,31 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Range { .. } |\n-            PatternKind::Variant { .. } => {\n-                // cannot simplify, test is required\n-                Err(match_pair)\n-            }\n-\n-            PatternKind::Slice { .. } if !match_pair.slice_len_checked => {\n+            PatternKind::Variant { .. } |\n+            PatternKind::Slice { .. } => {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n-                unpack!(block = self.prefix_suffix_slice(&mut candidate.match_pairs,\n-                                                         block,\n-                                                         match_pair.lvalue.clone(),\n-                                                         prefix,\n-                                                         slice.as_ref(),\n-                                                         suffix));\n-                Ok(block)\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+                self.prefix_slice_suffix(&mut candidate.match_pairs,\n+                                         &match_pair.lvalue,\n+                                         prefix,\n+                                         slice.as_ref(),\n+                                         suffix);\n+                Ok(())\n             }\n \n             PatternKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs\n                          .extend(self.field_match_pairs(match_pair.lvalue, subpatterns));\n-                Ok(block)\n+                Ok(())\n             }\n \n             PatternKind::Deref { ref subpattern } => {\n                 let lvalue = match_pair.lvalue.deref();\n                 candidate.match_pairs.push(MatchPair::new(lvalue, subpattern));\n-                Ok(block)\n+                Ok(())\n             }\n         }\n     }"}, {"sha": "668bdcf735802499d84f5978476a43777b69e7b1", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 112, "deletions": 43, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n+use std::cmp::Ordering;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n@@ -446,69 +447,118 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        match test.kind {\n+        match (&test.kind, &*match_pair.pattern.kind) {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n-            TestKind::Switch { adt_def: tested_adt_def , .. } => {\n-                match *match_pair.pattern.kind {\n-                    PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n-                        assert_eq!(adt_def, tested_adt_def);\n-                        let new_candidate =\n-                            self.candidate_after_variant_switch(match_pair_index,\n-                                                                adt_def,\n-                                                                variant_index,\n-                                                                subpatterns,\n-                                                                candidate);\n-                        resulting_candidates[variant_index].push(new_candidate);\n-                        true\n-                    }\n-                    _ => {\n-                        false\n-                    }\n-                }\n+            (&TestKind::Switch { adt_def: tested_adt_def, .. },\n+             &PatternKind::Variant { adt_def, variant_index, ref subpatterns }) => {\n+                assert_eq!(adt_def, tested_adt_def);\n+                let new_candidate =\n+                    self.candidate_after_variant_switch(match_pair_index,\n+                                                        adt_def,\n+                                                        variant_index,\n+                                                        subpatterns,\n+                                                        candidate);\n+                resulting_candidates[variant_index].push(new_candidate);\n+                true\n             }\n+            (&TestKind::Switch { .. }, _) => false,\n \n             // If we are performing a switch over integers, then this informs integer\n             // equality, but nothing else.\n             //\n-            // FIXME(#29623) we could use TestKind::Range to rule\n+            // FIXME(#29623) we could use PatternKind::Range to rule\n             // things out here, in some cases.\n-            TestKind::SwitchInt { switch_ty: _, options: _, ref indices } => {\n-                match *match_pair.pattern.kind {\n-                    PatternKind::Constant { ref value }\n-                    if is_switch_ty(match_pair.pattern.ty) => {\n-                        let index = indices[value];\n-                        let new_candidate = self.candidate_without_match_pair(match_pair_index,\n-                                                                              candidate);\n-                        resulting_candidates[index].push(new_candidate);\n+            (&TestKind::SwitchInt { switch_ty: _, options: _, ref indices },\n+             &PatternKind::Constant { ref value })\n+            if is_switch_ty(match_pair.pattern.ty) => {\n+                let index = indices[value];\n+                let new_candidate = self.candidate_without_match_pair(match_pair_index,\n+                                                                      candidate);\n+                resulting_candidates[index].push(new_candidate);\n+                true\n+            }\n+            (&TestKind::SwitchInt { .. }, _) => false,\n+\n+\n+            (&TestKind::Len { len: test_len, op: BinOp::Eq },\n+             &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n+                let pat_len = (prefix.len() + suffix.len()) as u64;\n+                match (test_len.cmp(&pat_len), slice) {\n+                    (Ordering::Equal, &None) => {\n+                        // on true, min_len = len = $actual_length,\n+                        // on false, len != $actual_length\n+                        resulting_candidates[0].push(\n+                            self.candidate_after_slice_test(match_pair_index,\n+                                                            candidate,\n+                                                            prefix,\n+                                                            slice.as_ref(),\n+                                                            suffix)\n+                        );\n                         true\n                     }\n-                    _ => {\n+                    (Ordering::Less, _) => {\n+                        // test_len < pat_len. If $actual_len = test_len,\n+                        // then $actual_len < pat_len and we don't have\n+                        // enough elements.\n+                        resulting_candidates[1].push(candidate.clone());\n+                        true\n+                    }\n+                    (Ordering::Equal, &Some(_)) | (Ordering::Greater, &Some(_)) => {\n+                        // This can match both if $actual_len = test_len >= pat_len,\n+                        // and if $actual_len > test_len. We can't advance.\n                         false\n                     }\n+                    (Ordering::Greater, &None) => {\n+                        // test_len != pat_len, so if $actual_len = test_len, then\n+                        // $actual_len != pat_len.\n+                        resulting_candidates[1].push(candidate.clone());\n+                        true\n+                    }\n                 }\n             }\n \n-            // If we are performing a length check, then this\n-            // informs slice patterns, but nothing else.\n-            TestKind::Len { .. } => {\n-                let pattern_test = self.test(&match_pair);\n-                match *match_pair.pattern.kind {\n-                    PatternKind::Slice { .. } if pattern_test.kind == test.kind => {\n-                        let mut new_candidate = candidate.clone();\n-\n-                        // Set up the MatchKind to simplify this like an array.\n-                        new_candidate.match_pairs[match_pair_index]\n-                                     .slice_len_checked = true;\n-                        resulting_candidates[0].push(new_candidate);\n+            (&TestKind::Len { len: test_len, op: BinOp::Ge },\n+             &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n+                // the test is `$actual_len >= test_len`\n+                let pat_len = (prefix.len() + suffix.len()) as u64;\n+                match (test_len.cmp(&pat_len), slice) {\n+                    (Ordering::Equal, &Some(_))  => {\n+                        // $actual_len >= test_len = pat_len,\n+                        // so we can match.\n+                        resulting_candidates[0].push(\n+                            self.candidate_after_slice_test(match_pair_index,\n+                                                            candidate,\n+                                                            prefix,\n+                                                            slice.as_ref(),\n+                                                            suffix)\n+                        );\n                         true\n                     }\n-                    _ => false\n+                    (Ordering::Less, _) | (Ordering::Equal, &None) => {\n+                        // test_len <= pat_len. If $actual_len < test_len,\n+                        // then it is also < pat_len, so the test passing is\n+                        // necessary (but insufficient).\n+                        resulting_candidates[0].push(candidate.clone());\n+                        true\n+                    }\n+                    (Ordering::Greater, &None) => {\n+                        // test_len > pat_len. If $actual_len >= test_len > pat_len,\n+                        // then we know we won't have a match.\n+                        resulting_candidates[1].push(candidate.clone());\n+                        true\n+                    }\n+                    (Ordering::Greater, &Some(_)) => {\n+                        // test_len < pat_len, and is therefore less\n+                        // strict. This can still go both ways.\n+                        false\n+                    }\n                 }\n             }\n \n-            TestKind::Eq { .. } |\n-            TestKind::Range { .. } => {\n+            (&TestKind::Eq { .. }, _) |\n+            (&TestKind::Range { .. }, _) |\n+            (&TestKind::Len { .. }, _) => {\n                 // These are all binary tests.\n                 //\n                 // FIXME(#29623) we can be more clever here\n@@ -544,6 +594,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn candidate_after_slice_test<'pat>(&mut self,\n+                                        match_pair_index: usize,\n+                                        candidate: &Candidate<'pat, 'tcx>,\n+                                        prefix: &'pat [Pattern<'tcx>],\n+                                        opt_slice: Option<&'pat Pattern<'tcx>>,\n+                                        suffix: &'pat [Pattern<'tcx>])\n+                                        -> Candidate<'pat, 'tcx> {\n+        let mut new_candidate =\n+            self.candidate_without_match_pair(match_pair_index, candidate);\n+        self.prefix_slice_suffix(\n+            &mut new_candidate.match_pairs,\n+            &candidate.match_pairs[match_pair_index].lvalue,\n+            prefix,\n+            opt_slice,\n+            suffix);\n+\n+        new_candidate\n+    }\n+\n     fn candidate_after_variant_switch<'pat>(&mut self,\n                                             match_pair_index: usize,\n                                             adt_def: ty::AdtDef<'tcx>,"}, {"sha": "53ebf6fceb5c807e2f8ea006dad651db8f42dd46", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::Builder;\n use build::matches::MatchPair;\n use hair::*;\n use rustc::mir::repr::*;\n@@ -28,64 +28,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                    .collect()\n     }\n \n-    /// When processing an array/slice pattern like `lv @ [x, y, ..s, z]`,\n-    /// this function converts the prefix (`x`, `y`) and suffix (`z`) into\n-    /// distinct match pairs:\n-    ///\n-    /// ```rust,ignore\n-    ///     lv[0 of 3] @ x  // see ProjectionElem::ConstantIndex (and its Debug impl)\n-    ///     lv[1 of 3] @ y  // to explain the `[x of y]` notation\n-    ///     lv[-1 of 3] @ z\n-    /// ```\n-    ///\n-    /// If a slice like `s` is present, then the function also creates\n-    /// a temporary like:\n-    ///\n-    /// ```rust,ignore\n-    ///     tmp0 = lv[2..-1] // using the special Rvalue::Slice\n-    /// ```\n-    ///\n-    /// and creates a match pair `tmp0 @ s`\n-    pub fn prefix_suffix_slice<'pat>(&mut self,\n+    pub fn prefix_slice_suffix<'pat>(&mut self,\n                                      match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n-                                     block: BasicBlock,\n-                                     lvalue: Lvalue<'tcx>,\n+                                     lvalue: &Lvalue<'tcx>,\n                                      prefix: &'pat [Pattern<'tcx>],\n                                      opt_slice: Option<&'pat Pattern<'tcx>>,\n-                                     suffix: &'pat [Pattern<'tcx>])\n-                                     -> BlockAnd<()> {\n-        // If there is a `..P` pattern, create a temporary `t0` for\n-        // the slice and then a match pair `t0 @ P`:\n-        if let Some(slice) = opt_slice {\n-            let prefix_len = prefix.len();\n-            let suffix_len = suffix.len();\n-            let rvalue = Rvalue::Slice {\n-                input: lvalue.clone(),\n-                from_start: prefix_len,\n-                from_end: suffix_len,\n-            };\n-            let temp = self.temp(slice.ty.clone()); // no need to schedule drop, temp is always copy\n-            let source_info = self.source_info(slice.span);\n-            self.cfg.push_assign(block, source_info, &temp, rvalue);\n-            match_pairs.push(MatchPair::new(temp, slice));\n-        }\n-\n-        self.prefix_suffix(match_pairs, lvalue, prefix, suffix);\n-\n-        block.unit()\n-    }\n-\n-    /// Helper for `prefix_suffix_slice` which just processes the prefix and suffix.\n-    fn prefix_suffix<'pat>(&mut self,\n-                           match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n-                           lvalue: Lvalue<'tcx>,\n-                           prefix: &'pat [Pattern<'tcx>],\n-                           suffix: &'pat [Pattern<'tcx>]) {\n+                                     suffix: &'pat [Pattern<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         assert!(min_length < u32::MAX as usize);\n         let min_length = min_length as u32;\n \n-        let prefix_pairs: Vec<_> =\n+        match_pairs.extend(\n             prefix.iter()\n                   .enumerate()\n                   .map(|(idx, subpattern)| {\n@@ -97,9 +50,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       let lvalue = lvalue.clone().elem(elem);\n                       MatchPair::new(lvalue, subpattern)\n                   })\n-                  .collect();\n+        );\n+\n+        if let Some(subslice_pat) = opt_slice {\n+            let subslice = lvalue.clone().elem(ProjectionElem::Subslice {\n+                from: prefix.len() as u32,\n+                to: suffix.len() as u32\n+            });\n+            match_pairs.push(MatchPair::new(subslice, subslice_pat));\n+        }\n \n-        let suffix_pairs: Vec<_> =\n+        match_pairs.extend(\n             suffix.iter()\n                   .rev()\n                   .enumerate()\n@@ -112,9 +73,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       let lvalue = lvalue.clone().elem(elem);\n                       MatchPair::new(lvalue, subpattern)\n                   })\n-                  .collect();\n-\n-        match_pairs.extend(prefix_pairs.into_iter().chain(suffix_pairs));\n+        );\n     }\n }\n "}, {"sha": "3d1ef31bd5c2af89f87ff4834f61101130e0d2e8", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -49,4 +49,3 @@ mod hair;\n pub mod mir_map;\n pub mod pretty;\n pub mod transform;\n-pub mod traversal;"}, {"sha": "987f12ab71b4a039d4d34f6bd7ecf1c06c1e53b4", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -11,11 +11,9 @@\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n-\n+use rustc::mir::traversal;\n use pretty;\n \n-use traversal;\n-\n pub struct AddCallGuards;\n \n /**"}, {"sha": "985bc9ac2d8d730328fca521b63e0c863f5e18cc", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -24,11 +24,11 @@\n \n use rustc::mir::repr::*;\n use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n+use rustc::mir::traversal::ReversePostorder;\n use rustc::ty::{self, TyCtxt};\n use syntax::codemap::Span;\n \n use build::Location;\n-use traversal::ReversePostorder;\n \n use std::mem;\n "}, {"sha": "3fdf492611d467a2ade1e13dbcb8b27cb1d448b6", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -25,6 +25,7 @@ use rustc::ty::cast::CastTy;\n use rustc::mir::repr::*;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::transform::{Pass, MirMapPass, MirSource};\n+use rustc::mir::traversal::{self, ReversePostorder};\n use rustc::mir::visit::{LvalueContext, Visitor};\n use rustc::util::nodemap::DefIdMap;\n use syntax::abi::Abi;\n@@ -35,7 +36,6 @@ use std::collections::hash_map::Entry;\n use std::fmt;\n \n use build::Location;\n-use traversal::{self, ReversePostorder};\n \n use super::promote_consts::{self, Candidate, TempState};\n \n@@ -509,6 +509,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         }\n \n                         ProjectionElem::ConstantIndex {..} |\n+                        ProjectionElem::Subslice {..} |\n                         ProjectionElem::Downcast(..) => {\n                             this.not_const()\n                         }\n@@ -708,7 +709,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n \n-            Rvalue::Slice {..} |\n             Rvalue::InlineAsm {..} => {\n                 self.not_const();\n             }"}, {"sha": "3a0055c564febccfcae401db5ddb38a591f9a742", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -13,13 +13,12 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::traversal;\n use pretty;\n use std::mem;\n \n use super::remove_dead_blocks::RemoveDeadBlocks;\n \n-use traversal;\n-\n pub struct SimplifyCfg;\n \n impl SimplifyCfg {"}, {"sha": "c38f1f1e6c0fad98648c8fe70bb1b86d5f8da189", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -203,6 +203,26 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n+            ProjectionElem::Subslice { from, to } => {\n+                LvalueTy::Ty {\n+                    ty: match base_ty.sty {\n+                        ty::TyArray(inner, size) => {\n+                            let min_size = (from as usize) + (to as usize);\n+                            if let Some(rest_size) = size.checked_sub(min_size) {\n+                                tcx.mk_array(inner, rest_size)\n+                            } else {\n+                                span_mirbug_and_err!(\n+                                    self, lvalue, \"taking too-small slice of {:?}\", base_ty)\n+                            }\n+                        }\n+                        ty::TySlice(..) => base_ty,\n+                        _ => {\n+                            span_mirbug_and_err!(\n+                                self, lvalue, \"slice of non-array {:?}\", base_ty)\n+                        }\n+                    }\n+                }\n+            }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match base_ty.sty {\n                     ty::TyEnum(adt_def, substs) if adt_def == adt_def1 => {"}, {"sha": "6acd1e76ff2c27da3274ebff7130d253c47b7b14", "filename": "src/librustc_plugin/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -14,5 +14,4 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n-rustc_mir = { path = \"../librustc_mir\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "7ef628e8f9b1688f869df965f761cbf774720535", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -70,7 +70,6 @@\n extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_metadata;\n-extern crate rustc_mir;\n \n pub use self::registry::Registry;\n "}, {"sha": "749ceda3db094c8adcd4310411da13f632d87f5a", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -21,7 +21,6 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n-rustc_mir = { path = \"../librustc_mir\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "913b0528b2e193f1a93a4e99af4940bf118b824b", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -505,14 +505,16 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           val: MatchInput,\n                                           mut e: F)\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n-    F: FnMut(&[&'p hir::Pat]) -> Option<Vec<&'p hir::Pat>>,\n+    F: FnMut(&[(&'p hir::Pat, Option<Ty<'tcx>>)])\n+             -> Option<Vec<(&'p hir::Pat, Option<Ty<'tcx>>)>>,\n {\n     debug!(\"enter_match(bcx={}, m={:?}, col={}, val={:?})\",\n            bcx.to_str(), m, col, val);\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(&br.pats).map(|pats| {\n+        let pats : Vec<_> = br.pats.iter().map(|p| (*p, None)).collect();\n+        e(&pats).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -530,7 +532,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 _ => {}\n             }\n             Match {\n-                pats: pats,\n+                pats: pats.into_iter().map(|p| p.0).collect(),\n                 data: br.data,\n                 bound_ptrs: bound_ptrs,\n                 pat_renaming_map: br.pat_renaming_map,\n@@ -550,7 +552,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, m, col, val, |pats| {\n-        match pats[col].node {\n+        match pats[col].0.node {\n             PatKind::Binding(..) | PatKind::Wild => {\n                 let mut r = pats[..col].to_vec();\n                 r.extend_from_slice(&pats[col + 1..]);\n@@ -729,7 +731,14 @@ fn bind_subslice_pat(bcx: Block,\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n \n     let slice_begin = InBoundsGEP(bcx, base, &[C_uint(bcx.ccx(), offset_left)]);\n-    let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n+    let diff = offset_left + offset_right;\n+    if let ty::TyArray(ty, n) = vec_ty_contents.sty {\n+        let array_ty = bcx.tcx().mk_array(ty, n-diff);\n+        let llty_array = type_of::type_of(bcx.ccx(), array_ty);\n+        return PointerCast(bcx, slice_begin, llty_array.ptr_to());\n+    }\n+\n+    let slice_len_offset = C_uint(bcx.ccx(), diff);\n     let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n     let slice_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReErased),\n                                          bcx.tcx().mk_slice(unit_ty));\n@@ -1205,7 +1214,12 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         Some(field_vals)\n     } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n-        Some(vec!(Load(bcx, val.val)))\n+        let ptr = if type_is_fat_ptr(bcx.tcx(), left_ty) {\n+            val.val\n+        } else {\n+            Load(bcx, val.val)\n+        };\n+        Some(vec!(ptr))\n     } else {\n         match left_ty.sty {\n             ty::TyArray(_, n) => {"}, {"sha": "8724945ed901bd1baf7c4710c9c7d93f5130199a", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -48,7 +48,6 @@ extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_incremental;\n pub extern crate rustc_llvm as llvm;\n-extern crate rustc_mir;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;\n extern crate rustc_const_math;"}, {"sha": "4476163a7f1083de9ae6fb19439f7842ece51114", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::bitvec::BitVector;\n use rustc::mir::repr as mir;\n use rustc::mir::repr::TerminatorKind;\n use rustc::mir::visit::{Visitor, LvalueContext};\n-use rustc_mir::traversal;\n+use rustc::mir::traversal;\n use common::{self, Block, BlockAndBuilder};\n use super::rvalue;\n "}, {"sha": "88c3fede1e1ed6727861a73233de3eaf63392f8f", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -775,9 +775,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n         let dest = match *dest {\n             mir::Lvalue::Temp(idx) => {\n-                let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), dest);\n-                let lvalue_ty = bcx.monomorphize(&lvalue_ty);\n-                let ret_ty = lvalue_ty.to_ty(bcx.tcx());\n+                let ret_ty = self.lvalue_ty(dest);\n                 match self.temps[idx as usize] {\n                     TempRef::Lvalue(dest) => dest,\n                     TempRef::Operand(None) => {"}, {"sha": "523dfef5a24095f8693b86c3f4cc540da2831404", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -20,13 +20,14 @@ use common::{self, BlockAndBuilder, CrateContext, C_uint, C_undef};\n use consts;\n use machine;\n use type_of::type_of;\n+use type_of;\n use Disr;\n \n use std::ptr;\n \n use super::{MirContext, TempRef};\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct LvalueRef<'tcx> {\n     /// Pointer to the contents of the lvalue\n     pub llval: ValueRef,\n@@ -88,7 +89,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let fcx = bcx.fcx();\n         let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n-        match *lvalue {\n+        let result = match *lvalue {\n             mir::Lvalue::Var(index) => self.vars[index as usize],\n             mir::Lvalue::Temp(index) => match self.temps[index as usize] {\n                 TempRef::Lvalue(lvalue) =>\n@@ -98,8 +99,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             },\n             mir::Lvalue::Arg(index) => self.args[index as usize],\n             mir::Lvalue::Static(def_id) => {\n-                let const_ty = self.mir.lvalue_ty(tcx, lvalue);\n-                LvalueRef::new_sized(consts::get_static(ccx, def_id).val, const_ty)\n+                let const_ty = self.lvalue_ty(lvalue);\n+                LvalueRef::new_sized(consts::get_static(ccx, def_id).val,\n+                                     LvalueTy::from_ty(const_ty))\n             },\n             mir::Lvalue::ReturnPointer => {\n                 let llval = if !fcx.fn_ty.ret.is_ignore() {\n@@ -131,7 +133,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let zero = common::C_uint(bcx.ccx(), 0u64);\n                         bcx.inbounds_gep(tr_base.llval, &[zero, llindex])\n                     };\n-                    (element, ptr::null_mut())\n+                    element\n                 };\n \n                 let (llprojected, llextra) = match projection.elem {\n@@ -169,21 +171,44 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);\n-                        project_index(self.prepare_index(bcx, index.immediate()))\n+                        (project_index(self.prepare_index(bcx, index.immediate())), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx(), offset);\n-                        project_index(self.prepare_index(bcx, lloffset))\n+                        (project_index(lloffset), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx(), offset);\n                         let lllen = tr_base.len(bcx.ccx());\n                         let llindex = bcx.sub(lllen, lloffset);\n-                        project_index(self.prepare_index(bcx, llindex))\n+                        (project_index(llindex), ptr::null_mut())\n+                    }\n+                    mir::ProjectionElem::Subslice { from, to } => {\n+                        let llindex = C_uint(bcx.ccx(), from);\n+                        let llbase = project_index(llindex);\n+\n+                        let base_ty = tr_base.ty.to_ty(bcx.tcx());\n+                        match base_ty.sty {\n+                            ty::TyArray(..) => {\n+                                // must cast the lvalue pointer type to the new\n+                                // array type (*[%_; new_len]).\n+                                let base_ty = self.lvalue_ty(lvalue);\n+                                let llbasety = type_of::type_of(bcx.ccx(), base_ty).ptr_to();\n+                                let llbase = bcx.pointercast(llbase, llbasety);\n+                                (llbase, ptr::null_mut())\n+                            }\n+                            ty::TySlice(..) => {\n+                                assert!(tr_base.llextra != ptr::null_mut());\n+                                let lllen = bcx.sub(tr_base.llextra,\n+                                                    C_uint(bcx.ccx(), from+to));\n+                                (llbase, lllen)\n+                            }\n+                            _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n+                        }\n                     }\n                     mir::ProjectionElem::Downcast(..) => {\n                         (tr_base.llval, tr_base.llextra)\n@@ -195,7 +220,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     ty: projected_ty,\n                 }\n             }\n-        }\n+        };\n+        debug!(\"trans_lvalue(lvalue={:?}) => {:?}\", lvalue, result);\n+        result\n     }\n \n     // Perform an action using the given Lvalue.\n@@ -210,27 +237,23 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 match self.temps[idx as usize] {\n                     TempRef::Lvalue(lvalue) => f(self, lvalue),\n                     TempRef::Operand(None) => {\n-                        let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n-                        let lvalue_ty = bcx.monomorphize(&lvalue_ty);\n+                        let lvalue_ty = self.lvalue_ty(lvalue);\n                         let lvalue = LvalueRef::alloca(bcx,\n-                                                       lvalue_ty.to_ty(bcx.tcx()),\n+                                                       lvalue_ty,\n                                                        \"lvalue_temp\");\n                         let ret = f(self, lvalue);\n-                        let op = self.trans_load(bcx, lvalue.llval, lvalue_ty.to_ty(bcx.tcx()));\n+                        let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n                         self.temps[idx as usize] = TempRef::Operand(Some(op));\n                         ret\n                     }\n                     TempRef::Operand(Some(_)) => {\n-                        let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n-                        let lvalue_ty = bcx.monomorphize(&lvalue_ty);\n-\n                         // See comments in TempRef::new_operand as to why\n                         // we always have Some in a ZST TempRef::Operand.\n-                        let ty = lvalue_ty.to_ty(bcx.tcx());\n+                        let ty = self.lvalue_ty(lvalue);\n                         if common::type_is_zero_size(bcx.ccx(), ty) {\n                             // Pass an undef pointer as no stores can actually occur.\n                             let llptr = C_undef(type_of(bcx.ccx(), ty).ptr_to());\n-                            f(self, LvalueRef::new_sized(llptr, lvalue_ty))\n+                            f(self, LvalueRef::new_sized(llptr, LvalueTy::from_ty(ty)))\n                         } else {\n                             bug!(\"Lvalue temp already set\");\n                         }\n@@ -264,4 +287,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             llindex\n         }\n     }\n+\n+    pub fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n+        let tcx = self.fcx.ccx.tcx();\n+        let lvalue_ty = self.mir.lvalue_ty(tcx, lvalue);\n+        self.fcx.monomorphize(&lvalue_ty.to_ty(tcx))\n+    }\n }"}, {"sha": "e1fa08fd8b3071cb52b2991e317830ed71cabaa9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -34,7 +34,7 @@ use rustc_data_structures::bitvec::BitVector;\n pub use self::constant::trans_static_initializer;\n \n use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n-use rustc_mir::traversal;\n+use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n "}, {"sha": "09b07c1440ec579b1ca3099d7d4790d8beaf1233", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -29,7 +29,7 @@ use Disr;\n use super::MirContext;\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::{LvalueRef, get_dataptr, get_meta};\n+use super::lvalue::{LvalueRef, get_dataptr};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -170,26 +170,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::Slice { ref input, from_start, from_end } => {\n-                let ccx = bcx.ccx();\n-                let input = self.trans_lvalue(&bcx, input);\n-                let ty = input.ty.to_ty(bcx.tcx());\n-                let (llbase1, lllen) = match ty.sty {\n-                    ty::TyArray(_, n) => {\n-                        (bcx.gepi(input.llval, &[0, from_start]), C_uint(ccx, n))\n-                    }\n-                    ty::TySlice(_) | ty::TyStr => {\n-                        (bcx.gepi(input.llval, &[from_start]), input.llextra)\n-                    }\n-                    _ => bug!(\"cannot slice {}\", ty)\n-                };\n-                let adj = C_uint(ccx, from_start + from_end);\n-                let lllen1 = bcx.sub(lllen, adj);\n-                bcx.store(llbase1, get_dataptr(&bcx, dest.llval));\n-                bcx.store(lllen1, get_meta(&bcx, dest.llval));\n-                bcx\n-            }\n-\n             mir::Rvalue::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n                     let lvalue = self.trans_lvalue(&bcx, output);\n@@ -498,7 +478,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) |\n-            mir::Rvalue::Slice { .. } |\n             mir::Rvalue::InlineAsm { .. } => {\n                 bug!(\"cannot generate operand from rvalue {:?}\", rvalue);\n \n@@ -652,7 +631,6 @@ pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n             true,\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) |\n-        mir::Rvalue::Slice { .. } |\n         mir::Rvalue::InlineAsm { .. } =>\n             false,\n     }"}, {"sha": "63472d582330fdec3371e986d3f69ba456b40e41", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -40,8 +40,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 bcx\n                             }\n                             TempRef::Operand(Some(_)) => {\n-                                let ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n-                                let ty = bcx.monomorphize(&ty.to_ty(bcx.tcx()));\n+                                let ty = self.lvalue_ty(lvalue);\n \n                                 if !common::type_is_zero_size(bcx.ccx(), ty) {\n                                     span_bug!(statement.source_info.span,"}, {"sha": "0430585fe6d0be46eefc8375f48b77d1fc68fb10", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -19,8 +19,8 @@ use lint;\n use util::nodemap::FnvHashMap;\n use session::Session;\n \n-use std::cmp;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::cmp;\n use std::ops::Deref;\n use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n@@ -323,44 +323,53 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             }\n             PatKind::Vec(ref before, ref slice, ref after) => {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                let inner_ty = self.next_ty_var();\n-                let pat_ty = match expected_ty.sty {\n-                    ty::TyArray(_, size) => tcx.mk_array(inner_ty, {\n+                let (inner_ty, slice_ty) = match expected_ty.sty {\n+                    ty::TyArray(inner_ty, size) => {\n                         let min_len = before.len() + after.len();\n-                        match *slice {\n-                            Some(_) => cmp::max(min_len, size),\n-                            None => min_len\n+                        if slice.is_none() {\n+                            if min_len != size {\n+                                span_err!(tcx.sess, pat.span, E0527,\n+                                          \"pattern requires {} elements but array has {}\",\n+                                          min_len, size);\n+                            }\n+                            (inner_ty, tcx.types.err)\n+                        } else if let Some(rest) = size.checked_sub(min_len) {\n+                            (inner_ty, tcx.mk_array(inner_ty, rest))\n+                        } else {\n+                            span_err!(tcx.sess, pat.span, E0528,\n+                                      \"pattern requires at least {} elements but array has {}\",\n+                                      min_len, size);\n+                            (inner_ty, tcx.types.err)\n                         }\n-                    }),\n+                    }\n+                    ty::TySlice(inner_ty) => (inner_ty, expected_ty),\n                     _ => {\n-                        let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                        tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n-                            ty: tcx.mk_slice(inner_ty),\n-                            mutbl: expected_ty.builtin_deref(true, ty::NoPreference)\n-                                              .map_or(hir::MutImmutable, |mt| mt.mutbl)\n-                        })\n+                        if !expected_ty.references_error() {\n+                            let mut err = struct_span_err!(\n+                                tcx.sess, pat.span, E0529,\n+                                \"expected an array or slice, found `{}`\",\n+                                expected_ty);\n+                            if let ty::TyRef(_, ty::TypeAndMut { mutbl: _, ty }) = expected_ty.sty {\n+                                match ty.sty {\n+                                    ty::TyArray(..) | ty::TySlice(..) => {\n+                                        err.help(\"the semantics of slice patterns changed \\\n+                                                  recently; see issue #23121\");\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            err.emit();\n+                        }\n+                        (tcx.types.err, tcx.types.err)\n                     }\n                 };\n \n-                self.write_ty(pat.id, pat_ty);\n-\n-                // `demand::subtype` would be good enough, but using\n-                // `eqtype` turns out to be equally general. See (*)\n-                // below for details.\n-                self.demand_eqtype(pat.span, expected, pat_ty);\n+                self.write_ty(pat.id, expected_ty);\n \n                 for elt in before {\n                     self.check_pat(&elt, inner_ty);\n                 }\n                 if let Some(ref slice) = *slice {\n-                    let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                    let mutbl = expected_ty.builtin_deref(true, ty::NoPreference)\n-                        .map_or(hir::MutImmutable, |mt| mt.mutbl);\n-\n-                    let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n-                        ty: tcx.mk_slice(inner_ty),\n-                        mutbl: mutbl\n-                    });\n                     self.check_pat(&slice, slice_ty);\n                 }\n                 for elt in after {\n@@ -369,7 +378,6 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-\n         // (*) In most of the cases above (literals and constants being\n         // the exception), we relate types using strict equality, evewn\n         // though subtyping would be sufficient. There are a few reasons"}, {"sha": "a8cb21126c079c0ec6d45bfce2b7b36d9ec39639", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -1157,25 +1157,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n                discr_cmt,\n                root_pat);\n-        let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n+    let _ = mc.cat_pattern(discr_cmt, root_pat, |_, sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(hir::BindByRef(mutbl), _, _) => {\n                         self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n                                                         mutbl, sub_cmt);\n                     }\n-\n-                    // `[_, ..slice, _]` pattern\n-                    PatKind::Vec(_, Some(ref slice_pat), _) => {\n-                        match mc.cat_slice_pattern(sub_cmt, &slice_pat) {\n-                            Ok((slice_cmt, slice_mutbl, slice_r)) => {\n-                                self.link_region(sub_pat.span, &slice_r,\n-                                                 ty::BorrowKind::from_mutbl(slice_mutbl),\n-                                                 slice_cmt);\n-                            }\n-                            Err(()) => {}\n-                        }\n-                    }\n                     _ => {}\n                 }\n             });"}, {"sha": "86717da24c54f03493a34cb4bf4417e15ab67222", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -4139,5 +4139,8 @@ register_diagnostics! {\n            // type `{}` was overridden\n     E0436, // functional record update requires a struct\n     E0513, // no type for local variable ..\n-    E0521  // redundant default implementations of trait\n+    E0521, // redundant default implementations of trait\n+    E0527, // expected {} elements, found {}\n+    E0528, // expected at least {} elements, found {}\n+    E0529, // slice pattern expects array or slice, not `{}`\n }"}, {"sha": "f5ca125aca91b66206d9e05588b3e50f5b7320a1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -22,6 +22,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst;\n+use rustc::util::common::slice_pat;\n \n use rustc_const_eval::lookup_const_by_id;\n \n@@ -197,10 +198,10 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n-        struct_type: match &*variant.fields {\n-            [] => doctree::Unit,\n-            [_] if variant.kind == ty::VariantKind::Tuple => doctree::Newtype,\n-            [..] if variant.kind == ty::VariantKind::Tuple => doctree::Tuple,\n+        struct_type: match slice_pat(&&*variant.fields) {\n+            &[] => doctree::Unit,\n+            &[_] if variant.kind == ty::VariantKind::Tuple => doctree::Newtype,\n+            &[..] if variant.kind == ty::VariantKind::Tuple => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n         generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),"}, {"sha": "760e84622cfe5d880f3a0375c397b26ab0b3eb20", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -20,6 +20,7 @@ use std::iter::repeat;\n \n use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::util::common::slice_pat;\n use syntax::abi::Abi;\n use rustc::hir;\n \n@@ -474,9 +475,9 @@ impl fmt::Display for clean::Type {\n                        decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                match &**typs {\n-                    [] => primitive_link(f, clean::PrimitiveTuple, \"()\"),\n-                    [ref one] => {\n+                match slice_pat(&&**typs) {\n+                    &[] => primitive_link(f, clean::PrimitiveTuple, \"()\"),\n+                    &[ref one] => {\n                         primitive_link(f, clean::PrimitiveTuple, \"(\")?;\n                         write!(f, \"{},\", one)?;\n                         primitive_link(f, clean::PrimitiveTuple, \")\")"}, {"sha": "135ea8a5e7cb40412c310d8a922df41ba085cd33", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -467,3 +467,15 @@ pub mod __rand {\n // the rustdoc documentation for primitive types. Using `include!`\n // because rustdoc only looks for these modules at the crate level.\n include!(\"primitive_docs.rs\");\n+\n+// FIXME(stage0): remove this after a snapshot\n+// HACK: this is needed because the interpretation of slice\n+// patterns changed between stage0 and now.\n+#[cfg(stage0)]\n+fn slice_pat<'a, 'b, T>(t: &'a &'b [T]) -> &'a &'b [T] {\n+    t\n+}\n+#[cfg(not(stage0))]\n+fn slice_pat<'a, 'b, T>(t: &'a &'b [T]) -> &'b [T] {\n+    *t\n+}"}, {"sha": "02506e7c2f3d91f7bf173e8e5da5949dec27d4ad", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -265,15 +265,18 @@ mod tests {\n \n             // Ensure the borrowchecker works\n             match queue.peek() {\n-                Some(vec) => match &**vec {\n-                    // Note that `pop` is not allowed here due to borrow\n-                    [1] => {}\n-                    _ => return\n+                Some(vec) => {\n+                    assert_eq!(&*vec, &[1]);\n                 },\n                 None => unreachable!()\n             }\n \n-            queue.pop();\n+            match queue.pop() {\n+                Some(vec) => {\n+                    assert_eq!(&*vec, &[1]);\n+                },\n+                None => unreachable!()\n+            }\n         }\n     }\n "}, {"sha": "d705b8986d0b1108d23985c1820004aa36ed9296", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -566,8 +566,8 @@ impl Wtf8 {\n         if len < 3 {\n             return None\n         }\n-        match &self.bytes[(len - 3)..] {\n-            [0xED, b2 @ 0xA0...0xAF, b3] => Some(decode_surrogate(b2, b3)),\n+        match ::slice_pat(&&self.bytes[(len - 3)..]) {\n+            &[0xED, b2 @ 0xA0...0xAF, b3] => Some(decode_surrogate(b2, b3)),\n             _ => None\n         }\n     }\n@@ -578,8 +578,8 @@ impl Wtf8 {\n         if len < 3 {\n             return None\n         }\n-        match &self.bytes[..3] {\n-            [0xED, b2 @ 0xB0...0xBF, b3] => Some(decode_surrogate(b2, b3)),\n+        match ::slice_pat(&&self.bytes[..3]) {\n+            &[0xED, b2 @ 0xB0...0xBF, b3] => Some(decode_surrogate(b2, b3)),\n             _ => None\n         }\n     }"}, {"sha": "c243e890526f78526d1777c7de94862f0b8f87c6", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -117,10 +117,10 @@ impl Drop for FindNextFileHandle {\n \n impl DirEntry {\n     fn new(root: &Arc<PathBuf>, wfd: &c::WIN32_FIND_DATAW) -> Option<DirEntry> {\n-        match &wfd.cFileName[0..3] {\n+        match ::slice_pat(&&wfd.cFileName[0..3]) {\n             // check for '.' and '..'\n-            [46, 0, ..] |\n-            [46, 46, 0, ..] => return None,\n+            &[46, 0, ..] |\n+            &[46, 46, 0, ..] => return None,\n             _ => {}\n         }\n "}, {"sha": "50d9f61e2c16098554304f76bf6e37f0e7cd235b", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -238,7 +238,6 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n- \"rustc_mir 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n \n@@ -285,7 +284,6 @@ dependencies = [\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n- \"rustc_mir 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\","}, {"sha": "f595d9d81cc6ef6bcb64eb67ce9055834880443d", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -24,14 +24,14 @@ pub fn main() {\n         Foo { string: \"baz\".to_string() }\n     );\n     let x: &[Foo] = &x;\n-    match x {\n-        [_, tail..] => {\n+    match *x {\n+        [_, ref tail..] => {\n             match tail {\n-                [Foo { string: a },\n+                &[Foo { string: a },\n                 //~^ ERROR cannot move out of borrowed content\n                 //~| cannot move out\n                 //~| to prevent move\n-                 Foo { string: b }] => {\n+                  Foo { string: b }] => {\n                     //~^ NOTE and here\n                 }\n                 _ => {"}, {"sha": "63e80b90ac81e6f211d885b77285f64ed6c142d6", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -15,7 +15,7 @@ fn a<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let tail = match vec {\n-        [_, tail..] => tail,\n+        &[_, ref tail..] => tail,\n         _ => panic!(\"a\")\n     };\n     tail\n@@ -25,7 +25,7 @@ fn b<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let init = match vec {\n-        [init.., _] => init,\n+        &[ref init.., _] => init,\n         _ => panic!(\"b\")\n     };\n     init\n@@ -35,7 +35,7 @@ fn c<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let slice = match vec {\n-        [_, slice.., _] => slice,\n+        &[_, ref slice.., _] => slice,\n         _ => panic!(\"c\")\n     };\n     slice"}, {"sha": "9dfd4d779284329ff53909c372604d51869c7a10", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -14,7 +14,7 @@ fn a() {\n     let mut v = vec!(1, 2, 3);\n     let vb: &mut [isize] = &mut v;\n     match vb {\n-        [_a, tail..] => {\n+        &mut [_a, ref tail..] => {\n             v.push(tail[0] + tail[1]); //~ ERROR cannot borrow\n         }\n         _ => {}"}, {"sha": "fddb9838c44b5e945561561ea298d22fc339a6e4", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     let mut a = [1, 2, 3, 4];\n     let t = match a {\n-        [1, 2, tail..] => tail,\n+        [1, 2, ref tail..] => tail,\n         _ => unreachable!()\n     };\n     println!(\"t[0]: {}\", t[0]);"}, {"sha": "d89b4100789f95d7132e969bef3e7e627fdbc8c0", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -28,7 +28,7 @@ fn b() {\n     let mut vec = vec!(box 1, box 2, box 3);\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        [_b..] => {\n+        &mut [ref _b..] => {\n         //~^ borrow of `vec[..]` occurs here\n             vec[0] = box 4; //~ ERROR cannot assign\n             //~^ assignment to borrowed `vec[..]` occurs here\n@@ -40,10 +40,11 @@ fn c() {\n     let mut vec = vec!(box 1, box 2, box 3);\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        [_a,         //~ ERROR cannot move out\n-        //~| cannot move out\n-        //~| to prevent move\n-         _b..] => {\n+        &mut [_a, //~ ERROR cannot move out of borrowed content\n+            //~| cannot move out\n+            //~| to prevent move\n+            ..\n+        ] => {\n             // Note: `_a` is *moved* here, but `b` is borrowing,\n             // hence illegal.\n             //\n@@ -61,7 +62,7 @@ fn d() {\n     let mut vec = vec!(box 1, box 2, box 3);\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        [_a..,     //~ ERROR cannot move out\n+        &mut [ //~ ERROR cannot move out\n         //~^ cannot move out\n          _b] => {} //~ NOTE to prevent move\n         _ => {}\n@@ -75,7 +76,7 @@ fn e() {\n     let mut vec = vec!(box 1, box 2, box 3);\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        [_a, _b, _c] => {}  //~ ERROR cannot move out\n+        &mut [_a, _b, _c] => {}  //~ ERROR cannot move out\n         //~| cannot move out\n         //~| NOTE to prevent move\n         //~| NOTE and here"}, {"sha": "a849e4e2faf3b51ff5d6cc97d90121ca1fadae82", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -14,7 +14,7 @@ fn a<'a>() -> &'a isize {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[isize] = &vec; //~ ERROR `vec` does not live long enough\n     let tail = match vec {\n-        [_a, tail..] => &tail[0],\n+        &[_a, ref tail..] => &tail[0],\n         _ => panic!(\"foo\")\n     };\n     tail"}, {"sha": "978d6f59b2df455b41b91ecc45d7244c2f7f6e88", "filename": "src/test/compile-fail/issue-12369.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -13,9 +13,9 @@\n fn main() {\n     let sl = vec![1,2,3];\n     let v: isize = match &*sl {\n-        [] => 0,\n-        [a,b,c] => 3,\n-        [a, rest..] => a,\n-        [10,a, rest..] => 10 //~ ERROR: unreachable pattern\n+        &[] => 0,\n+        &[a,b,c] => 3,\n+        &[a, ref rest..] => a,\n+        &[10,a, ref rest..] => 10 //~ ERROR: unreachable pattern\n     };\n }"}, {"sha": "32a6ea4f062cbc9819392615e13cd579a288d13e", "filename": "src/test/compile-fail/issue-12567.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -12,13 +12,15 @@\n \n fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) {\n     match (l1, l2) {\n-        ([], []) => println!(\"both empty\"),\n-        ([], [hd, tl..]) | ([hd, tl..], []) => println!(\"one empty\"),\n-        //~^ ERROR: cannot move out of borrowed content\n+        (&[], &[]) => println!(\"both empty\"),\n+        (&[], &[hd, ..]) | (&[hd, ..], &[])\n+            => println!(\"one empty\"),\n         //~^^ ERROR: cannot move out of borrowed content\n-        ([hd1, tl1..], [hd2, tl2..]) => println!(\"both nonempty\"),\n-        //~^ ERROR: cannot move out of borrowed content\n+        //~^^^ ERROR: cannot move out of borrowed content\n+        (&[hd1, ..], &[hd2, ..])\n+            => println!(\"both nonempty\"),\n         //~^^ ERROR: cannot move out of borrowed content\n+        //~^^^ ERROR: cannot move out of borrowed content\n     }\n }\n "}, {"sha": "6885c8d94c6b4fd16535103a91fa52bca135d372", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -15,11 +15,7 @@\n fn main() {\n     let x = [1,2];\n     let y = match x {\n-        [] => None,\n-//~^ ERROR mismatched types\n-//~| expected type `[_#1i; 2]`\n-//~| found type `[_#7t; 0]`\n-//~| expected an array with a fixed size of 2 elements, found one with 0 elements\n+        [] => None, //~ ERROR pattern requires 0 elements but array has 2\n         [a,_] => Some(a)\n     };\n }"}, {"sha": "82e82df31861ff35ab4a4fe913be379ebab96bda", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -13,11 +13,7 @@\n fn main() {\n   let x = [1,2];\n   let y = match x {\n-    [] => None,\n-    //~^ ERROR mismatched types\n-    //~| expected type `[_; 2]`\n-    //~| found type `[_; 0]`\n-    //~| expected an array with a fixed size of 2 elements\n+    [] => None, //~ ERROR pattern requires 0 elements but array has 2\n     [a,_] => Some(a)\n   };\n }"}, {"sha": "d0964d2aabea755357b9af916f00c127a642808d", "filename": "src/test/compile-fail/issue-15381.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -13,8 +13,8 @@\n fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n-    for [x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-        //~^ ERROR refutable pattern in `for` loop binding: `[]` not covered\n+    for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n+        //~^ ERROR refutable pattern in `for` loop binding: `&[]` not covered\n         println!(\"y={}\", y);\n     }\n }"}, {"sha": "9b105e7ec159d193ff8997e4850398234c8563a0", "filename": "src/test/compile-fail/issue-30240.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30240.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n+        \"hello\" => {}\n+    }\n+\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n+        ref _x if false => {}\n+        \"hello\" => {}\n+        \"hello\" => {} //~ ERROR unreachable pattern\n+    }\n+}"}, {"sha": "375d855d1fd31e6edae51647b965f13dec2e370f", "filename": "src/test/compile-fail/match-vec-mismatch-2.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -13,9 +13,6 @@\n fn main() {\n     match () {\n         [()] => { }\n-        //~^ ERROR mismatched types\n-        //~| expected type `()`\n-        //~| found type `&[_]`\n-        //~| expected (), found &-ptr\n+        //~^ ERROR expected an array or slice, found `()`\n     }\n }"}, {"sha": "3ac4958e7db0f6425b5a5d170574d967e1849bdf", "filename": "src/test/compile-fail/match-vec-mismatch.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -12,7 +12,36 @@\n \n fn main() {\n     match \"foo\".to_string() {\n-        ['f', 'o', ..] => {} //~ ERROR mismatched types\n+        ['f', 'o', ..] => {}\n+        //~^ ERROR expected an array or slice, found `std::string::String`\n         _ => { }\n-    }\n+    };\n+\n+    match &[0, 1, 2] {\n+        [..] => {} //~ ERROR expected an array or slice, found `&[_; 3]`\n+    };\n+\n+    match &[0, 1, 2] {\n+        &[..] => {} // ok\n+    };\n+\n+    match [0, 1, 2] {\n+        [0] => {}, //~ ERROR pattern requires\n+\n+        [0, 1, x..] => {\n+            let a: [_; 1] = x;\n+        }\n+        [0, 1, 2, 3, x..] => {} //~ ERROR pattern requires\n+    };\n+\n+    match does_not_exist { //~ ERROR unresolved name\n+        [] => {}\n+    };\n+}\n+\n+fn another_fn_to_avoid_suppression() {\n+    match Default::default()\n+    {\n+        [] => {}  //~ ERROR the type of this value\n+    };\n }"}, {"sha": "57e3a58b5660e27267d66d9af9f9643d6dd2542b", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     let x: Vec<(isize, isize)> = Vec::new();\n     let x: &[(isize, isize)] = &x;\n-    match x {\n+    match *x {\n         [a, (2, 3), _] => (),\n         [(1, 2), (2, 3), b] => (), //~ ERROR unreachable pattern\n         _ => ()\n@@ -23,16 +23,16 @@ fn main() {\n                               \"bar\".to_string(),\n                               \"baz\".to_string()];\n     let x: &[String] = &x;\n-    match x {\n+    match *x {\n         [a, _, _, ..] => { println!(\"{}\", a); }\n         [_, _, _, _, _] => { } //~ ERROR unreachable pattern\n         _ => { }\n     }\n \n     let x: Vec<char> = vec!('a', 'b', 'c');\n     let x: &[char] = &x;\n-    match x {\n-        ['a', 'b', 'c', _tail..] => {}\n+    match *x {\n+        ['a', 'b', 'c', ref _tail..] => {}\n         ['a', 'b', 'c'] => {} //~ ERROR unreachable pattern\n         _ => {}\n     }"}, {"sha": "1d524217a12a29519653256f9a8785e64d334dbf", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -14,11 +14,11 @@ enum t { a(u), b }\n enum u { c, d }\n \n fn match_nested_vecs<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n-    match (l1, l2) { //~ ERROR non-exhaustive patterns: `(Some([]), Err(_))` not covered\n-        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n-        (Some([_, ..]), Ok(_)) | (Some([_, ..]), Err(())) => \"Some(non-empty), any\",\n-        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n-        (None, Ok([_, _, ..])) => \"None, Ok(at least two elements)\"\n+    match (l1, l2) { //~ ERROR non-exhaustive patterns: `(Some(&[]), Err(_))` not covered\n+        (Some(&[]), Ok(&[])) => \"Some(empty), Ok(empty)\",\n+        (Some(&[_, ..]), Ok(_)) | (Some(&[_, ..]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok(&[])) | (None, Err(())) | (None, Ok(&[_])) => \"None, Ok(less than one element)\",\n+        (None, Ok(&[_, _, ..])) => \"None, Ok(at least two elements)\"\n     }\n }\n "}, {"sha": "017baacc9d329b771f7e40f295acbbfafeb03a24", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -39,32 +39,32 @@ fn main() {\n     }\n     let vec = vec!(Some(42), None, Some(21));\n     let vec: &[Option<isize>] = &vec;\n-    match vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n-        [Some(..), None, tail..] => {}\n-        [Some(..), Some(..), tail..] => {}\n+    match *vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n+        [Some(..), None, ref tail..] => {}\n+        [Some(..), Some(..), ref tail..] => {}\n         [None] => {}\n     }\n     let vec = vec!(1);\n     let vec: &[isize] = &vec;\n-    match vec {\n-        [_, tail..] => (),\n+    match *vec {\n+        [_, ref tail..] => (),\n         [] => ()\n     }\n     let vec = vec!(0.5f32);\n     let vec: &[f32] = &vec;\n-    match vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n+    match *vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),\n         [] => ()\n     }\n     let vec = vec!(Some(42), None, Some(21));\n     let vec: &[Option<isize>] = &vec;\n-    match vec {\n-        [Some(..), None, tail..] => {}\n-        [Some(..), Some(..), tail..] => {}\n-        [None, None, tail..] => {}\n-        [None, Some(..), tail..] => {}\n+    match *vec {\n+        [Some(..), None, ref tail..] => {}\n+        [Some(..), Some(..), ref tail..] => {}\n+        [None, None, ref tail..] => {}\n+        [None, Some(..), ref tail..] => {}\n         [Some(_)] => {}\n         [None] => {}\n         [] => {}"}, {"sha": "0b12a9acbcb9e9d56de662b81d4234bda7fc35a7", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -80,15 +80,15 @@ enum Enum {\n \n fn vectors_with_nested_enums() {\n     let x: &'static [Enum] = &[Enum::First, Enum::Second(false)];\n-    match x {\n+    match *x {\n     //~^ ERROR non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n         [] => (),\n         [_] => (),\n         [Enum::First, _] => (),\n         [Enum::Second(true), Enum::First] => (),\n         [Enum::Second(true), Enum::Second(true)] => (),\n         [Enum::Second(false), _] => (),\n-        [_, _, tail.., _] => ()\n+        [_, _, ref tail.., _] => ()\n     }\n }\n "}, {"sha": "ccb25d859acbae775ebe6ea85f454e4dce419ed8", "filename": "src/test/compile-fail/pat-slice-old-style.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fpat-slice-old-style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Fcompile-fail%2Fpat-slice-old-style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-slice-old-style.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slice_patterns)]\n+\n+fn slice_pat(x: &[u8]) {\n+    // OLD!\n+    match x {\n+        [a, b..] => {}\n+        //~^ ERROR expected an array or slice, found `&[u8]`\n+        //~| HELP the semantics of slice patterns changed recently; see issue #23121\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "cee0caeb465f56d3206266d85cc4f6f769730fb3", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -16,12 +16,12 @@ fn main() {\n \n     let mut result = vec!();\n     loop {\n-        x = match x {\n-            [1, n, 3, rest..] => {\n+        x = match *x {\n+            [1, n, 3, ref rest..] => {\n                 result.push(n);\n                 rest\n             }\n-            [n, rest..] => {\n+            [n, ref rest..] => {\n                 result.push(n);\n                 rest\n             }"}, {"sha": "508360cb70110a96ac10973133548c07053a1afc", "filename": "src/test/run-pass/issue-15104.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15104.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -16,9 +16,9 @@ fn main() {\n }\n \n fn count_members(v: &[usize]) -> usize {\n-    match v {\n+    match *v {\n         []         => 0,\n         [_]        => 1,\n-        [_x, xs..] => 1 + count_members(xs)\n+        [_, ref xs..] => 1 + count_members(xs)\n     }\n }"}, {"sha": "e596bee8bfe9fc7afc4936c33c7537873306aabb", "filename": "src/test/run-pass/issue-16648.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-16648.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-16648.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16648.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n \n-#![feature(slice_patterns)]\n+#![feature(slice_patterns, rustc_attrs)]\n \n+#[rustc_mir]\n fn main() {\n     let x: (isize, &[isize]) = (2, &[1, 2]);\n     assert_eq!(match x {\n-        (0, [_, _]) => 0,\n+        (0, &[_, _]) => 0,\n         (1, _) => 1,\n-        (2, [_, _]) => 2,\n+        (2, &[_, _]) => 2,\n         (2, _) => 3,\n         _ => 4\n     }, 2);"}, {"sha": "3be661ce35e3866e5503cbc4a211a55e68bd6c43", "filename": "src/test/run-pass/issue-30240.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-30240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-30240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30240.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let &ref a = &[0i32] as &[_];\n+    assert_eq!(a, &[0i32] as &[_]);\n+\n+    let &ref a = \"hello\";\n+    assert_eq!(a, \"hello\");\n+\n+    match \"foo\" {\n+        \"fool\" => unreachable!(),\n+        \"foo\" => {},\n+        ref _x => unreachable!()\n+    }\n+}"}, {"sha": "0008825226ba0161fdcd88b4c92e457c42331ec6", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -11,6 +11,7 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n use std::ops::Add;\n \n@@ -21,6 +22,7 @@ fn bar(a: &'static str, b: &'static str) -> [&'static str; 4] {\n     [a, b, b, a]\n }\n \n+#[rustc_mir]\n fn main() {\n     assert_eq!(foo([1, 2, 3]), (1, 3, 6));\n "}, {"sha": "7253672a7ff47425541e0a06911aaf3bcc601759", "filename": "src/test/run-pass/match-unsized.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fmatch-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fmatch-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-unsized.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let data: &'static str = \"Hello, World!\";\n+    match data {\n+        &ref xs => {\n+            assert_eq!(data, xs);\n+        }\n+    }\n+}"}, {"sha": "010c1455210084b521a898b125e183d8d1f2f1cb", "filename": "src/test/run-pass/match-vec-alternatives.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -11,47 +11,53 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n+#[rustc_mir]\n fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n-        ([], []) => \"both empty\",\n-        ([], [..]) | ([..], []) => \"one empty\",\n-        ([..], [..]) => \"both non-empty\"\n+        (&[], &[]) => \"both empty\",\n+        (&[], &[..]) | (&[..], &[]) => \"one empty\",\n+        (&[..], &[..]) => \"both non-empty\"\n     }\n }\n \n+#[rustc_mir]\n fn match_vecs_cons<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n-        ([], []) => \"both empty\",\n-        ([], [_, ..]) | ([_, ..], []) => \"one empty\",\n-        ([_, ..], [_, ..]) => \"both non-empty\"\n+        (&[], &[]) => \"both empty\",\n+        (&[], &[_, ..]) | (&[_, ..], &[]) => \"one empty\",\n+        (&[_, ..], &[_, ..]) => \"both non-empty\"\n     }\n }\n \n+#[rustc_mir]\n fn match_vecs_snoc<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n-        ([], []) => \"both empty\",\n-        ([], [.., _]) | ([.., _], []) => \"one empty\",\n-        ([.., _], [.., _]) => \"both non-empty\"\n+        (&[], &[]) => \"both empty\",\n+        (&[], &[.., _]) | (&[.., _], &[]) => \"one empty\",\n+        (&[.., _], &[.., _]) => \"both non-empty\"\n     }\n }\n \n+#[rustc_mir]\n fn match_nested_vecs_cons<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n     match (l1, l2) {\n-        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n-        (Some([_, ..]), Ok(_)) | (Some([_, ..]), Err(())) => \"Some(non-empty), any\",\n-        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n-        (None, Ok([_, _, ..])) => \"None, Ok(at least two elements)\",\n+        (Some(&[]), Ok(&[])) => \"Some(empty), Ok(empty)\",\n+        (Some(&[_, ..]), Ok(_)) | (Some(&[_, ..]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok(&[])) | (None, Err(())) | (None, Ok(&[_])) => \"None, Ok(less than one element)\",\n+        (None, Ok(&[_, _, ..])) => \"None, Ok(at least two elements)\",\n         _ => \"other\"\n     }\n }\n \n+#[rustc_mir]\n fn match_nested_vecs_snoc<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n     match (l1, l2) {\n-        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n-        (Some([.., _]), Ok(_)) | (Some([.., _]), Err(())) => \"Some(non-empty), any\",\n-        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n-        (None, Ok([.., _, _])) => \"None, Ok(at least two elements)\",\n+        (Some(&[]), Ok(&[])) => \"Some(empty), Ok(empty)\",\n+        (Some(&[.., _]), Ok(_)) | (Some(&[.., _]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok(&[])) | (None, Err(())) | (None, Ok(&[_])) => \"None, Ok(less than one element)\",\n+        (None, Ok(&[.., _, _])) => \"None, Ok(at least two elements)\",\n         _ => \"other\"\n     }\n }"}, {"sha": "7a6129d311ee386e83a51ca4fb706ac2fa0809b5", "filename": "src/test/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -11,21 +11,28 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n+use std::fmt::Debug;\n+\n+#[rustc_mir(graphviz=\"mir.gv\")]\n fn foldl<T, U, F>(values: &[T],\n                   initial: U,\n                   mut function: F)\n                   -> U where\n-    U: Clone,\n+    U: Clone+Debug, T:Debug,\n     F: FnMut(U, &T) -> U,\n-{\n-    match values {\n-        [ref head, tail..] =>\n+{    match values {\n+        &[ref head, ref tail..] =>\n             foldl(tail, function(initial, head), function),\n-        [] => initial.clone()\n+        &[] => {\n+            // FIXME: call guards\n+            let res = initial.clone(); res\n+        }\n     }\n }\n \n+#[rustc_mir]\n fn foldr<T, U, F>(values: &[T],\n                   initial: U,\n                   mut function: F)\n@@ -34,9 +41,12 @@ fn foldr<T, U, F>(values: &[T],\n     F: FnMut(&T, U) -> U,\n {\n     match values {\n-        [head.., ref tail] =>\n+        &[ref head.., ref tail] =>\n             foldr(head, function(tail, initial), function),\n-        [] => initial.clone()\n+        &[] => {\n+            // FIXME: call guards\n+            let res = initial.clone(); res\n+        }\n     }\n }\n "}, {"sha": "1093bc7c18b867e6f6e817e32527df9e09d6b52d", "filename": "src/test/run-pass/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slice_patterns)]\n+#![feature(slice_patterns, rustc_attrs)]\n \n+#[rustc_mir]\n pub fn main() {\n     let x = &[1, 2, 3, 4, 5];\n     let x: &[isize] = &[1, 2, 3, 4, 5];\n     if !x.is_empty() {\n         let el = match x {\n-            [1, ref tail..] => &tail[0],\n+            &[1, ref tail..] => &tail[0],\n             _ => unreachable!()\n         };\n         println!(\"{}\", *el);"}, {"sha": "075709a63b5f5d2978947ea1062e189fc7440a6a", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -11,7 +11,9 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n+#[rustc_mir]\n fn a() {\n     let x = [1];\n     match x {\n@@ -21,6 +23,7 @@ fn a() {\n     }\n }\n \n+#[rustc_mir]\n fn b() {\n     let x = [1, 2, 3];\n     match x {\n@@ -56,6 +59,48 @@ fn b() {\n     }\n }\n \n+\n+#[rustc_mir]\n+fn b_slice() {\n+    let x : &[_] = &[1, 2, 3];\n+    match x {\n+        &[a, b, ref c..] => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            let expected: &[_] = &[3];\n+            assert_eq!(c, expected);\n+        }\n+        _ => unreachable!()\n+    }\n+    match x {\n+        &[ref a.., b, c] => {\n+            let expected: &[_] = &[1];\n+            assert_eq!(a, expected);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+        _ => unreachable!()\n+    }\n+    match x {\n+        &[a, ref b.., c] => {\n+            assert_eq!(a, 1);\n+            let expected: &[_] = &[2];\n+            assert_eq!(b, expected);\n+            assert_eq!(c, 3);\n+        }\n+        _ => unreachable!()\n+    }\n+    match x {\n+        &[a, b, c] => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+        _ => unreachable!()\n+    }\n+}\n+\n+#[rustc_mir]\n fn c() {\n     let x = [1];\n     match x {\n@@ -64,6 +109,7 @@ fn c() {\n     }\n }\n \n+#[rustc_mir]\n fn d() {\n     let x = [1, 2, 3];\n     let branch = match x {\n@@ -75,17 +121,40 @@ fn d() {\n     assert_eq!(branch, 1);\n }\n \n+#[rustc_mir]\n fn e() {\n     let x: &[isize] = &[1, 2, 3];\n-    match x {\n-        [1, 2] => (),\n-        [..] => ()\n-    }\n+    let a = match *x {\n+        [1, 2] => 0,\n+        [..] => 1,\n+    };\n+\n+    assert_eq!(a, 1);\n+\n+    let b = match *x {\n+        [2, ..] => 0,\n+        [1, 2, ..] => 1,\n+        [_] => 2,\n+        [..] => 3\n+    };\n+\n+    assert_eq!(b, 1);\n+\n+\n+    let c = match *x {\n+        [_, _, _, _, ..] => 0,\n+        [1, 2, ..] => 1,\n+        [_] => 2,\n+        [..] => 3\n+    };\n+\n+    assert_eq!(c, 1);\n }\n \n pub fn main() {\n     a();\n     b();\n+    b_slice();\n     c();\n     d();\n     e();"}, {"sha": "6084a0d07a114911f2e180062d159f3e42f11f6c", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -11,26 +11,28 @@\n \n \n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n struct Foo {\n-    string: String\n+    string: &'static str\n }\n \n+#[rustc_mir]\n pub fn main() {\n     let x = [\n-        Foo { string: \"foo\".to_string() },\n-        Foo { string: \"bar\".to_string() },\n-        Foo { string: \"baz\".to_string() }\n+        Foo { string: \"foo\" },\n+        Foo { string: \"bar\" },\n+        Foo { string: \"baz\" }\n     ];\n     match x {\n-        [ref first, tail..] => {\n-            assert_eq!(first.string, \"foo\".to_string());\n+        [ref first, ref tail..] => {\n+            assert_eq!(first.string, \"foo\");\n             assert_eq!(tail.len(), 2);\n-            assert_eq!(tail[0].string, \"bar\".to_string());\n-            assert_eq!(tail[1].string, \"baz\".to_string());\n+            assert_eq!(tail[0].string, \"bar\");\n+            assert_eq!(tail[1].string, \"baz\");\n \n-            match tail {\n-                [Foo { .. }, _, Foo { .. }, _tail..] => {\n+            match *(tail as &[_]) {\n+                [Foo { .. }, _, Foo { .. }, ref _tail..] => {\n                     unreachable!();\n                 }\n                 [Foo { string: ref a }, Foo { string: ref b }] => {"}, {"sha": "00f4aa98a3e062bf2694beca39bb2882f682f2d6", "filename": "src/test/run-pass/zero_sized_subslice_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+#![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n \n+#[rustc_mir]\n fn main() {\n     let x = [(), ()];\n \n     // The subslice used to go out of bounds for zero-sized array items, check that this doesn't\n     // happen anymore\n     match x {\n-        [_, y..] => assert_eq!(&x[1] as *const (), &y[0] as *const ())\n+        [_, ref y..] => assert_eq!(&x[1] as *const (), &y[0] as *const ())\n     }\n }"}]}