{"sha": "a0e0e4575b79f89825d3ac6130a659982228eda4", "node_id": "C_kwDOAAsO6NoAKGEwZTBlNDU3NWI3OWY4OTgyNWQzYWM2MTMwYTY1OTk4MjIyOGVkYTQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-02T01:39:14Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-02T01:39:14Z"}, "message": "Simplify", "tree": {"sha": "034b9308bb9bc1d72eb9998e70ec4421db7c3ed2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/034b9308bb9bc1d72eb9998e70ec4421db7c3ed2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0e0e4575b79f89825d3ac6130a659982228eda4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0e0e4575b79f89825d3ac6130a659982228eda4", "html_url": "https://github.com/rust-lang/rust/commit/a0e0e4575b79f89825d3ac6130a659982228eda4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0e0e4575b79f89825d3ac6130a659982228eda4/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "809461cc420648eb7d4d53effbff0216bd9196b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/809461cc420648eb7d4d53effbff0216bd9196b4", "html_url": "https://github.com/rust-lang/rust/commit/809461cc420648eb7d4d53effbff0216bd9196b4"}], "stats": {"total": 106, "additions": 47, "deletions": 59}, "files": [{"sha": "8d223c375a33284d5fabe1b269a2423026c5b1f2", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a0e0e4575b79f89825d3ac6130a659982228eda4/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e0e4575b79f89825d3ac6130a659982228eda4/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=a0e0e4575b79f89825d3ac6130a659982228eda4", "patch": "@@ -27,6 +27,14 @@ use crate::{\n pub use ::parser::TopEntryPoint;\n pub use tt::{Delimiter, DelimiterKind, Punct};\n \n+pub use crate::{\n+    syntax_bridge::{\n+        parse_exprs_with_sep, parse_to_token_tree, syntax_node_to_token_tree,\n+        syntax_node_to_token_tree_censored, token_tree_to_syntax_node,\n+    },\n+    token_map::TokenMap,\n+};\n+\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum ParseError {\n     UnexpectedToken(String),\n@@ -70,14 +78,6 @@ impl fmt::Display for ExpandError {\n     }\n }\n \n-pub use crate::{\n-    syntax_bridge::{\n-        parse_exprs_with_sep, parse_to_token_tree, syntax_node_to_token_tree,\n-        syntax_node_to_token_tree_censored, token_tree_to_syntax_node,\n-    },\n-    token_map::TokenMap,\n-};\n-\n /// This struct contains AST for a single `macro_rules` definition. What might\n /// be very confusing is that AST has almost exactly the same shape as\n /// `tt::TokenTree`, but there's a crucial difference: in macro rules, `$ident`\n@@ -121,11 +121,9 @@ impl Shift {\n                         }\n                     }\n                     tt::TokenTree::Leaf(leaf) => {\n-                        let id = match leaf {\n-                            tt::Leaf::Literal(it) => it.id,\n-                            tt::Leaf::Punct(it) => it.id,\n-                            tt::Leaf::Ident(it) => it.id,\n-                        };\n+                        let &(tt::Leaf::Ident(tt::Ident { id, .. })\n+                        | tt::Leaf::Punct(tt::Punct { id, .. })\n+                        | tt::Leaf::Literal(tt::Literal { id, .. })) = leaf;\n \n                         (id != tt::TokenId::unspecified()).then(|| id.0)\n                     }\n@@ -138,15 +136,15 @@ impl Shift {\n     pub fn shift_all(self, tt: &mut tt::Subtree) {\n         for t in &mut tt.token_trees {\n             match t {\n-                tt::TokenTree::Leaf(leaf) => match leaf {\n-                    tt::Leaf::Ident(ident) => ident.id = self.shift(ident.id),\n-                    tt::Leaf::Punct(punct) => punct.id = self.shift(punct.id),\n-                    tt::Leaf::Literal(lit) => lit.id = self.shift(lit.id),\n-                },\n+                tt::TokenTree::Leaf(\n+                    tt::Leaf::Ident(tt::Ident { id, .. })\n+                    | tt::Leaf::Punct(tt::Punct { id, .. })\n+                    | tt::Leaf::Literal(tt::Literal { id, .. }),\n+                ) => *id = self.shift(*id),\n                 tt::TokenTree::Subtree(tt) => {\n                     if let Some(it) = tt.delimiter.as_mut() {\n                         it.id = self.shift(it.id);\n-                    };\n+                    }\n                     self.shift_all(tt)\n                 }\n             }\n@@ -155,9 +153,10 @@ impl Shift {\n \n     pub fn shift(self, id: tt::TokenId) -> tt::TokenId {\n         if id == tt::TokenId::unspecified() {\n-            return id;\n+            id\n+        } else {\n+            tt::TokenId(id.0 + self.0)\n         }\n-        tt::TokenId(id.0 + self.0)\n     }\n \n     pub fn unshift(self, id: tt::TokenId) -> Option<tt::TokenId> {\n@@ -190,8 +189,8 @@ impl DeclarativeMacro {\n             }\n         }\n \n-        for rule in &rules {\n-            validate(&rule.lhs)?;\n+        for Rule { lhs, .. } in &rules {\n+            validate(lhs)?;\n         }\n \n         Ok(DeclarativeMacro { rules, shift: Shift::new(tt) })\n@@ -220,12 +219,13 @@ impl DeclarativeMacro {\n             cov_mark::hit!(parse_macro_def_simple);\n             let rule = Rule::parse(&mut src, false)?;\n             if src.len() != 0 {\n-                return Err(ParseError::Expected(\"remain tokens in macro def\".to_string()));\n+                return Err(ParseError::Expected(\"remaining tokens in macro def\".to_string()));\n             }\n             rules.push(rule);\n         }\n-        for rule in &rules {\n-            validate(&rule.lhs)?;\n+\n+        for Rule { lhs, .. } in &rules {\n+            validate(lhs)?;\n         }\n \n         Ok(DeclarativeMacro { rules, shift: Shift::new(tt) })\n@@ -281,28 +281,18 @@ fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n             Op::Repeat { tokens: subtree, separator, .. } => {\n                 // Checks that no repetition which could match an empty token\n                 // https://github.com/rust-lang/rust/blob/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f/src/librustc_expand/mbe/macro_rules.rs#L558\n-\n-                if separator.is_none()\n-                    && subtree.iter().all(|child_op| {\n-                        match child_op {\n-                            Op::Var { kind, .. } => {\n-                                // vis is optional\n-                                if kind.as_ref().map_or(false, |it| it == \"vis\") {\n-                                    return true;\n-                                }\n-                            }\n-                            Op::Repeat { kind, .. } => {\n-                                return matches!(\n-                                    kind,\n-                                    parser::RepeatKind::ZeroOrMore | parser::RepeatKind::ZeroOrOne\n-                                )\n-                            }\n-                            Op::Leaf(_) => {}\n-                            Op::Subtree { .. } => {}\n-                        }\n-                        false\n-                    })\n-                {\n+                let lsh_is_empty_seq = separator.is_none() && subtree.iter().all(|child_op| {\n+                    match child_op {\n+                        // vis is optional\n+                        Op::Var { kind: Some(kind), .. } => kind == \"vis\",\n+                        Op::Repeat {\n+                            kind: parser::RepeatKind::ZeroOrMore | parser::RepeatKind::ZeroOrOne,\n+                            ..\n+                        } => true,\n+                        _ => false,\n+                    }\n+                });\n+                if lsh_is_empty_seq {\n                     return Err(ParseError::RepetitionEmptyTokenTree);\n                 }\n                 validate(subtree)?"}, {"sha": "7543054494a229f5d3f707dd35789eeadd19236b", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0e0e4575b79f89825d3ac6130a659982228eda4/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e0e4575b79f89825d3ac6130a659982228eda4/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=a0e0e4575b79f89825d3ac6130a659982228eda4", "patch": "@@ -76,9 +76,9 @@ impl PartialEq for Separator {\n         use Separator::*;\n \n         match (self, other) {\n-            (Ident(ref a), Ident(ref b)) => a.text == b.text,\n-            (Literal(ref a), Literal(ref b)) => a.text == b.text,\n-            (Puncts(ref a), Puncts(ref b)) if a.len() == b.len() => {\n+            (Ident(a), Ident(b)) => a.text == b.text,\n+            (Literal(a), Literal(b)) => a.text == b.text,\n+            (Puncts(a), Puncts(b)) if a.len() == b.len() => {\n                 let a_iter = a.iter().map(|a| a.char);\n                 let b_iter = b.iter().map(|b| b.char);\n                 a_iter.eq(b_iter)\n@@ -131,9 +131,7 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                     Op::Repeat { tokens, separator, kind }\n                 }\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n-                    tt::Leaf::Punct(_) => {\n-                        return Err(ParseError::Expected(\"ident\".to_string()));\n-                    }\n+                    tt::Leaf::Punct(_) => return Err(ParseError::Expected(\"ident\".to_string())),\n                     tt::Leaf::Ident(ident) if ident.text == \"crate\" => {\n                         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n                         Op::Leaf(tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: ident.id }))"}, {"sha": "3b97bc8ba606c34da37ab1ded843a57b09ac0120", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0e0e4575b79f89825d3ac6130a659982228eda4/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e0e4575b79f89825d3ac6130a659982228eda4/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=a0e0e4575b79f89825d3ac6130a659982228eda4", "patch": "@@ -81,7 +81,7 @@ pub fn parse_to_token_tree(text: &str) -> Option<(tt::Subtree, TokenMap)> {\n     }\n \n     let mut conv = RawConvertor {\n-        lexed: lexed,\n+        lexed,\n         pos: 0,\n         id_alloc: TokenIdAlloc {\n             map: Default::default(),\n@@ -147,8 +147,8 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n         let entry = stack.last_mut().unwrap();\n         let result = &mut entry.subtree.token_trees;\n         let (token, range) = match conv.bump() {\n-            None => break,\n             Some(it) => it,\n+            None => break,\n         };\n \n         let k: SyntaxKind = token.kind(&conv);"}, {"sha": "172916c5a14381a03eb7aa54688a365b2112fc97", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0e0e4575b79f89825d3ac6130a659982228eda4/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0e0e4575b79f89825d3ac6130a659982228eda4/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=a0e0e4575b79f89825d3ac6130a659982228eda4", "patch": "@@ -1,11 +1,11 @@\n //! A \"Parser\" structure for token trees. We use this when parsing a declarative\n //! macro definition into a list of patterns and templates.\n \n-use crate::{to_parser_input::to_parser_input, ExpandError, ExpandResult};\n-\n use syntax::SyntaxKind;\n use tt::buffer::TokenBuffer;\n \n+use crate::{to_parser_input::to_parser_input, ExpandError, ExpandResult};\n+\n macro_rules! err {\n     () => {\n         ExpandError::BindingError(format!(\"\"))\n@@ -27,7 +27,7 @@ impl<'a> TtIter<'a> {\n \n     pub(crate) fn expect_char(&mut self, char: char) -> Result<(), ()> {\n         match self.next() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: c, .. }))) if *c == char => {\n+            Some(&tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: c, .. }))) if c == char => {\n                 Ok(())\n             }\n             _ => Err(()),"}]}