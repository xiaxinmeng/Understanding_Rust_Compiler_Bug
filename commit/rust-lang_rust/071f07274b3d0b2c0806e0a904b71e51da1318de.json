{"sha": "071f07274b3d0b2c0806e0a904b71e51da1318de", "node_id": "C_kwDOAAsO6NoAKDA3MWYwNzI3NGIzZDBiMmMwODA2ZTBhOTA0YjcxZTUxZGExMzE4ZGU", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-04-27T01:57:44Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-04-29T01:12:08Z"}, "message": "macros: split diagnostic derives into modules\n\nSplit `SessionDiagnostic` and `SessionSubdiagnostic` derives and the\nvarious helper functions into multiple modules.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "ace5cb570fd238e2117cf911e178ec9fc2d32c89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ace5cb570fd238e2117cf911e178ec9fc2d32c89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/071f07274b3d0b2c0806e0a904b71e51da1318de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/071f07274b3d0b2c0806e0a904b71e51da1318de", "html_url": "https://github.com/rust-lang/rust/commit/071f07274b3d0b2c0806e0a904b71e51da1318de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/071f07274b3d0b2c0806e0a904b71e51da1318de/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49ec909ca7d649d73115f7e0e894b0ffb0740b66", "url": "https://api.github.com/repos/rust-lang/rust/commits/49ec909ca7d649d73115f7e0e894b0ffb0740b66", "html_url": "https://github.com/rust-lang/rust/commit/49ec909ca7d649d73115f7e0e894b0ffb0740b66"}], "stats": {"total": 3224, "additions": 1631, "deletions": 1593}, "files": [{"sha": "cdaee3ed2d7955f00ddd912d98cfae82bfa58c61", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "added", "additions": 703, "deletions": 0, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=071f07274b3d0b2c0806e0a904b71e51da1318de", "patch": "@@ -0,0 +1,703 @@\n+#![deny(unused_must_use)]\n+\n+use crate::diagnostics::error::{span_err, throw_span_err, SessionDiagnosticDeriveError};\n+use crate::diagnostics::utils::{\n+    option_inner_ty, report_error_if_not_applied_to_span, type_matches_path, FieldInfo, HasFieldMap,\n+};\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use std::collections::HashMap;\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, Type};\n+use synstructure::Structure;\n+\n+/// The central struct for constructing the `as_error` method from an annotated struct.\n+pub(crate) struct SessionDiagnosticDerive<'a> {\n+    structure: Structure<'a>,\n+    builder: SessionDiagnosticDeriveBuilder,\n+}\n+\n+impl<'a> SessionDiagnosticDerive<'a> {\n+    pub(crate) fn new(diag: syn::Ident, sess: syn::Ident, structure: Structure<'a>) -> Self {\n+        // Build the mapping of field names to fields. This allows attributes to peek values from\n+        // other fields.\n+        let mut fields_map = HashMap::new();\n+\n+        // Convenience bindings.\n+        let ast = structure.ast();\n+\n+        if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n+            for field in fields.iter() {\n+                if let Some(ident) = &field.ident {\n+                    fields_map.insert(ident.to_string(), quote! { &self.#ident });\n+                }\n+            }\n+        }\n+\n+        Self {\n+            builder: SessionDiagnosticDeriveBuilder {\n+                diag,\n+                sess,\n+                fields: fields_map,\n+                kind: None,\n+                code: None,\n+                slug: None,\n+            },\n+            structure,\n+        }\n+    }\n+\n+    pub(crate) fn into_tokens(self) -> TokenStream {\n+        let SessionDiagnosticDerive { mut structure, mut builder } = self;\n+\n+        let ast = structure.ast();\n+        let attrs = &ast.attrs;\n+\n+        let (implementation, param_ty) = {\n+            if let syn::Data::Struct(..) = ast.data {\n+                let preamble = {\n+                    let preamble = attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_structure_code(attr)\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+\n+                    quote! {\n+                        #(#preamble)*;\n+                    }\n+                };\n+\n+                // Generates calls to `span_label` and similar functions based on the attributes\n+                // on fields. Code for suggestions uses formatting machinery and the value of\n+                // other fields - because any given field can be referenced multiple times, it\n+                // should be accessed through a borrow. When passing fields to `set_arg` (which\n+                // happens below) for Fluent, we want to move the data, so that has to happen\n+                // in a separate pass over the fields.\n+                let attrs = structure.each(|field_binding| {\n+                    let field = field_binding.ast();\n+                    let result = field.attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_field_attr_code(\n+                                attr,\n+                                FieldInfo {\n+                                    vis: &field.vis,\n+                                    binding: field_binding,\n+                                    ty: &field.ty,\n+                                    span: &field.span(),\n+                                },\n+                            )\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+\n+                    quote! { #(#result);* }\n+                });\n+\n+                // When generating `set_arg` calls, move data rather than borrow it to avoid\n+                // requiring clones - this must therefore be the last use of each field (for\n+                // example, any formatting machinery that might refer to a field should be\n+                // generated already).\n+                structure.bind_with(|_| synstructure::BindStyle::Move);\n+                let args = structure.each(|field_binding| {\n+                    let field = field_binding.ast();\n+                    // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n+                    // need to be passed as an argument to the diagnostic. But when a field has no\n+                    // attributes then it must be passed as an argument to the diagnostic so that\n+                    // it can be referred to by Fluent messages.\n+                    if field.attrs.is_empty() {\n+                        let diag = &builder.diag;\n+                        let ident = field_binding.ast().ident.as_ref().unwrap();\n+                        quote! {\n+                            #diag.set_arg(\n+                                stringify!(#ident),\n+                                #field_binding.into_diagnostic_arg()\n+                            );\n+                        }\n+                    } else {\n+                        quote! {}\n+                    }\n+                });\n+\n+                let span = ast.span().unwrap();\n+                let (diag, sess) = (&builder.diag, &builder.sess);\n+                let init = match (builder.kind, builder.slug) {\n+                    (None, _) => {\n+                        span_err(span, \"diagnostic kind not specified\")\n+                            .help(\"use the `#[error(...)]` attribute to create an error\")\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some((kind, _)), None) => {\n+                        span_err(span, \"`slug` not specified\")\n+                            .help(&format!(\"use the `#[{}(slug = \\\"...\\\")]` attribute to set this diagnostic's slug\", kind.descr()))\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some((SessionDiagnosticKind::Error, _)), Some((slug, _))) => {\n+                        quote! {\n+                            let mut #diag = #sess.struct_err(\n+                                rustc_errors::DiagnosticMessage::fluent(#slug),\n+                            );\n+                        }\n+                    }\n+                    (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _))) => {\n+                        quote! {\n+                            let mut #diag = #sess.struct_warn(\n+                                rustc_errors::DiagnosticMessage::fluent(#slug),\n+                            );\n+                        }\n+                    }\n+                };\n+\n+                let implementation = quote! {\n+                    #init\n+                    #preamble\n+                    match self {\n+                        #attrs\n+                    }\n+                    match self {\n+                        #args\n+                    }\n+                    #diag\n+                };\n+                let param_ty = match builder.kind {\n+                    Some((SessionDiagnosticKind::Error, _)) => {\n+                        quote! { rustc_errors::ErrorGuaranteed }\n+                    }\n+                    Some((SessionDiagnosticKind::Warn, _)) => quote! { () },\n+                    _ => unreachable!(),\n+                };\n+\n+                (implementation, param_ty)\n+            } else {\n+                span_err(\n+                    ast.span().unwrap(),\n+                    \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n+                )\n+                .emit();\n+\n+                let implementation = SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                let param_ty = quote! { rustc_errors::ErrorGuaranteed };\n+                (implementation, param_ty)\n+            }\n+        };\n+\n+        let sess = &builder.sess;\n+        structure.gen_impl(quote! {\n+            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess, #param_ty>\n+                    for @Self\n+            {\n+                fn into_diagnostic(\n+                    self,\n+                    #sess: &'__session_diagnostic_sess rustc_session::parse::ParseSess\n+                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, #param_ty> {\n+                    use rustc_errors::IntoDiagnosticArg;\n+                    #implementation\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// What kind of session diagnostic is being derived - an error or a warning?\n+#[derive(Copy, Clone)]\n+enum SessionDiagnosticKind {\n+    /// `#[error(..)]`\n+    Error,\n+    /// `#[warn(..)]`\n+    Warn,\n+}\n+\n+impl SessionDiagnosticKind {\n+    /// Returns human-readable string corresponding to the kind.\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            SessionDiagnosticKind::Error => \"error\",\n+            SessionDiagnosticKind::Warn => \"warning\",\n+        }\n+    }\n+}\n+\n+/// Tracks persistent information required for building up the individual calls to diagnostic\n+/// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n+/// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n+/// double mut borrow later on.\n+struct SessionDiagnosticDeriveBuilder {\n+    /// Name of the session parameter that's passed in to the `as_error` method.\n+    sess: syn::Ident,\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n+    diag: syn::Ident,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    fields: HashMap<String, TokenStream>,\n+\n+    /// Kind of diagnostic requested via the struct attribute.\n+    kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n+    /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n+    /// has the actual diagnostic message.\n+    slug: Option<(String, proc_macro::Span)>,\n+    /// Error codes are a optional part of the struct attribute - this is only set to detect\n+    /// multiple specifications.\n+    code: Option<proc_macro::Span>,\n+}\n+\n+impl HasFieldMap for SessionDiagnosticDeriveBuilder {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n+        self.fields.get(field)\n+    }\n+}\n+\n+impl SessionDiagnosticDeriveBuilder {\n+    /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n+    /// attributes like `#[error(..)#`, such as the diagnostic kind and slug. Generates\n+    /// diagnostic builder calls for setting error code and creating note/help messages.\n+    fn generate_structure_code(\n+        &mut self,\n+        attr: &Attribute,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let span = attr.span().unwrap();\n+\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        let meta = attr.parse_meta()?;\n+\n+        if matches!(name, \"help\" | \"note\") && matches!(meta, Meta::Path(_) | Meta::NameValue(_)) {\n+            let diag = &self.diag;\n+            let slug = match &self.slug {\n+                Some((slug, _)) => slug.as_str(),\n+                None => throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`#[{}{}]` must come after `#[error(..)]` or `#[warn(..)]`\",\n+                        name,\n+                        match meta {\n+                            Meta::Path(_) => \"\",\n+                            Meta::NameValue(_) => \" = ...\",\n+                            _ => unreachable!(),\n+                        }\n+                    )\n+                ),\n+            };\n+            let id = match meta {\n+                Meta::Path(..) => quote! { #name },\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    quote! { #s }\n+                }\n+                _ => unreachable!(),\n+            };\n+            let fn_name = proc_macro2::Ident::new(name, attr.span());\n+\n+            return Ok(quote! {\n+                #diag.#fn_name(rustc_errors::DiagnosticMessage::fluent_attr(#slug, #id));\n+            });\n+        }\n+\n+        let nested = match meta {\n+            Meta::List(MetaList { nested, .. }) => nested,\n+            Meta::Path(..) => throw_span_err!(\n+                span,\n+                &format!(\"`#[{}]` is not a valid `SessionDiagnostic` struct attribute\", name)\n+            ),\n+            Meta::NameValue(..) => throw_span_err!(\n+                span,\n+                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` struct attribute\", name)\n+            ),\n+        };\n+\n+        let kind = match name {\n+            \"error\" => SessionDiagnosticKind::Error,\n+            \"warning\" => SessionDiagnosticKind::Warn,\n+            other => throw_span_err!(\n+                span,\n+                &format!(\"`#[{}(...)]` is not a valid `SessionDiagnostic` struct attribute\", other)\n+            ),\n+        };\n+        self.set_kind_once(kind, span)?;\n+\n+        let mut tokens = Vec::new();\n+        for attr in nested {\n+            let span = attr.span().unwrap();\n+            let meta = match attr {\n+                syn::NestedMeta::Meta(meta) => meta,\n+                syn::NestedMeta::Lit(_) => throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` struct attribute\",\n+                        name\n+                    )\n+                ),\n+            };\n+\n+            let path = meta.path();\n+            let nested_name = path.segments.last().unwrap().ident.to_string();\n+            match &meta {\n+                // Struct attributes are only allowed to be applied once, and the diagnostic\n+                // changes will be set in the initialisation code.\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    match nested_name.as_str() {\n+                        \"slug\" => {\n+                            self.set_slug_once(s.value(), s.span().unwrap());\n+                        }\n+                        \"code\" => {\n+                            tokens.push(self.set_code_once(s.value(), s.span().unwrap()));\n+                        }\n+                        other => {\n+                            let diag = span_err(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                    name, other\n+                                ),\n+                            );\n+                            diag.emit();\n+                        }\n+                    }\n+                }\n+                Meta::NameValue(..) => {\n+                    span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .help(\"value must be a string\")\n+                    .emit();\n+                }\n+                Meta::Path(..) => {\n+                    span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .emit();\n+                }\n+                Meta::List(..) => {\n+                    span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .emit();\n+                }\n+            }\n+        }\n+\n+        Ok(tokens.drain(..).collect())\n+    }\n+\n+    #[must_use]\n+    fn set_kind_once(\n+        &mut self,\n+        kind: SessionDiagnosticKind,\n+        span: proc_macro::Span,\n+    ) -> Result<(), SessionDiagnosticDeriveError> {\n+        match self.kind {\n+            None => {\n+                self.kind = Some((kind, span));\n+                Ok(())\n+            }\n+            Some((prev_kind, prev_span)) => {\n+                let existing = prev_kind.descr();\n+                let current = kind.descr();\n+\n+                let msg = if current == existing {\n+                    format!(\"`{}` specified multiple times\", existing)\n+                } else {\n+                    format!(\"`{}` specified when `{}` was already specified\", current, existing)\n+                };\n+                throw_span_err!(span, &msg, |diag| diag\n+                    .span_note(prev_span, \"previously specified here\"));\n+            }\n+        }\n+    }\n+\n+    fn set_code_once(&mut self, code: String, span: proc_macro::Span) -> TokenStream {\n+        match self.code {\n+            None => {\n+                self.code = Some(span);\n+            }\n+            Some(prev_span) => {\n+                span_err(span, \"`code` specified multiple times\")\n+                    .span_note(prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n+        }\n+\n+        let diag = &self.diag;\n+        quote! { #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string())); }\n+    }\n+\n+    fn set_slug_once(&mut self, slug: String, span: proc_macro::Span) {\n+        match self.slug {\n+            None => {\n+                self.slug = Some((slug, span));\n+            }\n+            Some((_, prev_span)) => {\n+                span_err(span, \"`slug` specified multiple times\")\n+                    .span_note(prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n+        }\n+    }\n+\n+    fn generate_field_attr_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let field_binding = &info.binding.binding;\n+        let option_ty = option_inner_ty(&info.ty);\n+        let generated_code = self.generate_non_option_field_code(\n+            attr,\n+            FieldInfo {\n+                vis: info.vis,\n+                binding: info.binding,\n+                ty: option_ty.unwrap_or(&info.ty),\n+                span: info.span,\n+            },\n+        )?;\n+\n+        if option_ty.is_none() {\n+            Ok(quote! { #generated_code })\n+        } else {\n+            Ok(quote! {\n+                if let Some(#field_binding) = #field_binding {\n+                    #generated_code\n+                }\n+            })\n+        }\n+    }\n+\n+    fn generate_non_option_field_code(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n+        let span = attr.span().unwrap();\n+        let field_binding = &info.binding.binding;\n+\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+\n+        let meta = attr.parse_meta()?;\n+        match meta {\n+            Meta::Path(_) => match name {\n+                \"skip_arg\" => {\n+                    // Don't need to do anything - by virtue of the attribute existing, the\n+                    // `set_arg` call will not be generated.\n+                    Ok(quote! {})\n+                }\n+                \"primary_span\" => {\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n+                    Ok(quote! {\n+                        #diag.set_span(*#field_binding);\n+                    })\n+                }\n+                \"label\" | \"note\" | \"help\" => {\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n+                    Ok(self.add_subdiagnostic(field_binding, name, name))\n+                }\n+                other => throw_span_err!(\n+                    span,\n+                    &format!(\"`#[{}]` is not a valid `SessionDiagnostic` field attribute\", other)\n+                ),\n+            },\n+            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => match name {\n+                \"label\" | \"note\" | \"help\" => {\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n+                    Ok(self.add_subdiagnostic(field_binding, name, &s.value()))\n+                }\n+                other => throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\",\n+                        other\n+                    )\n+                ),\n+            },\n+            Meta::NameValue(_) => throw_span_err!(\n+                span,\n+                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\", name),\n+                |diag| diag.help(\"value must be a string\")\n+            ),\n+            Meta::List(MetaList { path, nested, .. }) => {\n+                let name = path.segments.last().unwrap().ident.to_string();\n+                let name = name.as_ref();\n+\n+                match name {\n+                    \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\"\n+                    | \"suggestion_verbose\" => (),\n+                    other => throw_span_err!(\n+                        span,\n+                        &format!(\n+                            \"`#[{}(...)]` is not a valid `SessionDiagnostic` field attribute\",\n+                            other\n+                        )\n+                    ),\n+                };\n+\n+                let (span_, applicability) = self.span_and_applicability_of_ty(info)?;\n+\n+                let mut msg = None;\n+                let mut code = None;\n+\n+                for attr in nested {\n+                    let meta = match attr {\n+                        syn::NestedMeta::Meta(meta) => meta,\n+                        syn::NestedMeta::Lit(_) => throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` field attribute\",\n+                                name\n+                            )\n+                        ),\n+                    };\n+\n+                    let span = meta.span().unwrap();\n+                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                    let nested_name = nested_name.as_str();\n+\n+                    match meta {\n+                        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                            match nested_name {\n+                                \"message\" => {\n+                                    msg = Some(s.value());\n+                                }\n+                                \"code\" => {\n+                                    let formatted_str = self.build_format(&s.value(), s.span());\n+                                    code = Some(formatted_str);\n+                                }\n+                                other => throw_span_err!(\n+                                    span,\n+                                    &format!(\n+                                        \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` field attribute\",\n+                                        name, other\n+                                    )\n+                                ),\n+                            }\n+                        }\n+                        Meta::NameValue(..) => throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                name, nested_name\n+                            ),\n+                            |diag| diag.help(\"value must be a string\")\n+                        ),\n+                        Meta::Path(..) => throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                name, nested_name\n+                            )\n+                        ),\n+                        Meta::List(..) => throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                name, nested_name\n+                            )\n+                        ),\n+                    }\n+                }\n+\n+                let method = format_ident!(\"span_{}\", name);\n+\n+                let slug = self\n+                    .slug\n+                    .as_ref()\n+                    .map(|(slug, _)| slug.as_str())\n+                    .unwrap_or_else(|| \"missing-slug\");\n+                let msg = msg.as_deref().unwrap_or(\"suggestion\");\n+                let msg = quote! { rustc_errors::DiagnosticMessage::fluent_attr(#slug, #msg) };\n+                let code = code.unwrap_or_else(|| quote! { String::new() });\n+\n+                Ok(quote! { #diag.#method(#span_, #msg, #code, #applicability); })\n+            }\n+        }\n+    }\n+\n+    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug and\n+    /// `fluent_attr_identifier`.\n+    fn add_subdiagnostic(\n+        &self,\n+        field_binding: &proc_macro2::Ident,\n+        kind: &str,\n+        fluent_attr_identifier: &str,\n+    ) -> TokenStream {\n+        let diag = &self.diag;\n+\n+        let slug =\n+            self.slug.as_ref().map(|(slug, _)| slug.as_str()).unwrap_or_else(|| \"missing-slug\");\n+        let fn_name = format_ident!(\"span_{}\", kind);\n+        quote! {\n+            #diag.#fn_name(\n+                *#field_binding,\n+                rustc_errors::DiagnosticMessage::fluent_attr(#slug, #fluent_attr_identifier)\n+            );\n+        }\n+    }\n+\n+    fn span_and_applicability_of_ty(\n+        &self,\n+        info: FieldInfo<'_>,\n+    ) -> Result<(TokenStream, TokenStream), SessionDiagnosticDeriveError> {\n+        match &info.ty {\n+            // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n+            ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n+                let binding = &info.binding.binding;\n+                Ok((quote!(*#binding), quote!(rustc_errors::Applicability::Unspecified)))\n+            }\n+            // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n+            Type::Tuple(tup) => {\n+                let mut span_idx = None;\n+                let mut applicability_idx = None;\n+\n+                for (idx, elem) in tup.elems.iter().enumerate() {\n+                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n+                        if span_idx.is_none() {\n+                            span_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more than one `Span`\"\n+                            );\n+                        }\n+                    } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n+                        if applicability_idx.is_none() {\n+                            applicability_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n+                            );\n+                        }\n+                    }\n+                }\n+\n+                if let Some(span_idx) = span_idx {\n+                    let binding = &info.binding.binding;\n+                    let span = quote!(#binding.#span_idx);\n+                    let applicability = applicability_idx\n+                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n+                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+\n+                    return Ok((span, applicability));\n+                }\n+\n+                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n+                    diag.help(\"`#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\")\n+                });\n+            }\n+            // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n+            _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n+                diag.help(\"`#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\")\n+            }),\n+        }\n+    }\n+}"}, {"sha": "2a56b6cad02586ba81f20a1a655b4f2843bc144a", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=071f07274b3d0b2c0806e0a904b71e51da1318de", "patch": "@@ -0,0 +1,60 @@\n+use proc_macro::{Diagnostic, Level, MultiSpan};\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+use syn;\n+\n+#[derive(Debug)]\n+pub(crate) enum SessionDiagnosticDeriveError {\n+    SynError(syn::Error),\n+    ErrorHandled,\n+}\n+\n+impl SessionDiagnosticDeriveError {\n+    pub(crate) fn to_compile_error(self) -> TokenStream {\n+        match self {\n+            SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n+            SessionDiagnosticDeriveError::ErrorHandled => {\n+                // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n+                // error has already been emitted to the compiler.\n+                quote! {\n+                    { unreachable!(); }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n+    Diagnostic::spanned(span, Level::Error, msg)\n+}\n+\n+/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+///\n+/// Emit a diagnostic on span `$span` with msg `$msg` (optionally performing additional decoration\n+/// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n+macro_rules! throw_span_err {\n+    ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n+    ($span:expr, $msg:expr, $f:expr) => {{\n+        return Err(crate::diagnostics::error::_throw_span_err($span, $msg, $f));\n+    }};\n+}\n+\n+pub(crate) use throw_span_err;\n+\n+/// When possible, prefer using `throw_span_err!` over using this function directly. This only\n+/// exists as a function to constrain `f` to an `impl FnOnce`.\n+pub(crate) fn _throw_span_err(\n+    span: impl MultiSpan,\n+    msg: &str,\n+    f: impl FnOnce(Diagnostic) -> Diagnostic,\n+) -> SessionDiagnosticDeriveError {\n+    let diag = span_err(span, msg);\n+    f(diag).emit();\n+    SessionDiagnosticDeriveError::ErrorHandled\n+}\n+\n+impl From<syn::Error> for SessionDiagnosticDeriveError {\n+    fn from(e: syn::Error) -> Self {\n+        SessionDiagnosticDeriveError::SynError(e)\n+    }\n+}"}, {"sha": "73ad415d6c355b6442cd62158e44f00b92526ee3", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=071f07274b3d0b2c0806e0a904b71e51da1318de", "patch": "@@ -0,0 +1,114 @@\n+mod diagnostic;\n+mod error;\n+mod subdiagnostic;\n+mod utils;\n+\n+use diagnostic::SessionDiagnosticDerive;\n+use proc_macro2::TokenStream;\n+use quote::format_ident;\n+use subdiagnostic::SessionSubdiagnosticDerive;\n+use synstructure::Structure;\n+\n+/// Implements `#[derive(SessionDiagnostic)]`, which allows for errors to be specified as a struct,\n+/// independent from the actual diagnostics emitting code.\n+///\n+/// ```ignore (pseudo-rust)\n+/// # extern crate rustc_errors;\n+/// # use rustc_errors::Applicability;\n+/// # extern crate rustc_span;\n+/// # use rustc_span::{symbol::Ident, Span};\n+/// # extern crate rust_middle;\n+/// # use rustc_middle::ty::Ty;\n+/// #[derive(SessionDiagnostic)]\n+/// #[error(code = \"E0505\", slug = \"borrowck-move-out-of-borrow\")]\n+/// pub struct MoveOutOfBorrowError<'tcx> {\n+///     pub name: Ident,\n+///     pub ty: Ty<'tcx>,\n+///     #[primary_span]\n+///     #[label]\n+///     pub span: Span,\n+///     #[label = \"first-borrow-label\"]\n+///     pub first_borrow_span: Span,\n+///     #[suggestion(code = \"{name}.clone()\")]\n+///     pub clone_sugg: Option<(Span, Applicability)>\n+/// }\n+/// ```\n+///\n+/// ```fluent\n+/// move-out-of-borrow = cannot move out of {$name} because it is borrowed\n+///     .label = cannot move out of borrow\n+///     .first-borrow-label = `{$ty}` first borrowed here\n+///     .suggestion = consider cloning here\n+/// ```\n+///\n+/// Then, later, to emit the error:\n+///\n+/// ```ignore (pseudo-rust)\n+/// sess.emit_err(MoveOutOfBorrowError {\n+///     expected,\n+///     actual,\n+///     span,\n+///     first_borrow_span,\n+///     clone_sugg: Some(suggestion, Applicability::MachineApplicable),\n+/// });\n+/// ```\n+///\n+/// See rustc dev guide for more examples on using the `#[derive(SessionDiagnostic)]`:\n+/// <https://rustc-dev-guide.rust-lang.org/diagnostics/sessiondiagnostic.html>\n+pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n+    // Names for the diagnostic we build and the session we build it from.\n+    let diag = format_ident!(\"diag\");\n+    let sess = format_ident!(\"sess\");\n+\n+    SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n+}\n+\n+/// Implements `#[derive(SessionSubdiagnostic)]`, which allows for labels, notes, helps and\n+/// suggestions to be specified as a structs or enums, independent from the actual diagnostics\n+/// emitting code or diagnostic derives.\n+///\n+/// ```ignore (pseudo-rust)\n+/// #[derive(SessionSubdiagnostic)]\n+/// pub enum ExpectedIdentifierLabel<'tcx> {\n+///     #[label(slug = \"parser-expected-identifier\")]\n+///     WithoutFound {\n+///         #[primary_span]\n+///         span: Span,\n+///     }\n+///     #[label(slug = \"parser-expected-identifier-found\")]\n+///     WithFound {\n+///         #[primary_span]\n+///         span: Span,\n+///         found: String,\n+///     }\n+/// }\n+///\n+/// #[derive(SessionSubdiagnostic)]\n+/// #[suggestion_verbose(slug = \"parser-raw-identifier\")]\n+/// pub struct RawIdentifierSuggestion<'tcx> {\n+///     #[primary_span]\n+///     span: Span,\n+///     #[applicability]\n+///     applicability: Applicability,\n+///     ident: Ident,\n+/// }\n+/// ```\n+///\n+/// ```fluent\n+/// parser-expected-identifier = expected identifier\n+///\n+/// parser-expected-identifier-found = expected identifier, found {$found}\n+///\n+/// parser-raw-identifier = escape `{$ident}` to use it as an identifier\n+/// ```\n+///\n+/// Then, later, to add the subdiagnostic:\n+///\n+/// ```ignore (pseudo-rust)\n+/// diag.subdiagnostic(ExpectedIdentifierLabel::WithoutFound { span });\n+///\n+/// diag.subdiagnostic(RawIdentifierSuggestion { span, applicability, ident });\n+/// ```\n+pub fn session_subdiagnostic_derive(s: Structure<'_>) -> TokenStream {\n+    SessionSubdiagnosticDerive::new(s).into_tokens()\n+}"}, {"sha": "4d1ec826e9b7bf7423b2076814452a3d9789233d", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "added", "additions": 530, "deletions": 0, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=071f07274b3d0b2c0806e0a904b71e51da1318de", "patch": "@@ -0,0 +1,530 @@\n+#![deny(unused_must_use)]\n+\n+use crate::diagnostics::error::{span_err, throw_span_err, SessionDiagnosticDeriveError};\n+use crate::diagnostics::utils::{\n+    option_inner_ty, report_error_if_not_applied_to_applicability,\n+    report_error_if_not_applied_to_span, FieldInfo, HasFieldMap, SetOnce,\n+};\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use std::collections::HashMap;\n+use std::fmt;\n+use std::str::FromStr;\n+use syn::{spanned::Spanned, Meta, MetaList, MetaNameValue};\n+use synstructure::{BindingInfo, Structure, VariantInfo};\n+\n+enum Applicability {\n+    MachineApplicable,\n+    MaybeIncorrect,\n+    HasPlaceholders,\n+    Unspecified,\n+}\n+\n+impl FromStr for Applicability {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"machine-applicable\" => Ok(Applicability::MachineApplicable),\n+            \"maybe-incorrect\" => Ok(Applicability::MaybeIncorrect),\n+            \"has-placeholders\" => Ok(Applicability::HasPlaceholders),\n+            \"unspecified\" => Ok(Applicability::Unspecified),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl quote::ToTokens for Applicability {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        tokens.extend(match self {\n+            Applicability::MachineApplicable => {\n+                quote! { rustc_errors::Applicability::MachineApplicable }\n+            }\n+            Applicability::MaybeIncorrect => {\n+                quote! { rustc_errors::Applicability::MaybeIncorrect }\n+            }\n+            Applicability::HasPlaceholders => {\n+                quote! { rustc_errors::Applicability::HasPlaceholders }\n+            }\n+            Applicability::Unspecified => {\n+                quote! { rustc_errors::Applicability::Unspecified }\n+            }\n+        });\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum SubdiagnosticSuggestionKind {\n+    /// `#[suggestion]`\n+    Normal,\n+    /// `#[suggestion_short]`\n+    Short,\n+    /// `#[suggestion_hidden]`\n+    Hidden,\n+    /// `#[suggestion_verbose]`\n+    Verbose,\n+}\n+\n+#[derive(Clone, Copy)]\n+enum SubdiagnosticKind {\n+    /// `#[label(...)]`\n+    Label,\n+    /// `#[note(...)]`\n+    Note,\n+    /// `#[help(...)]`\n+    Help,\n+    /// `#[suggestion{,_short,_hidden,_verbose}]`\n+    Suggestion(SubdiagnosticSuggestionKind),\n+}\n+\n+impl FromStr for SubdiagnosticKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"label\" => Ok(SubdiagnosticKind::Label),\n+            \"note\" => Ok(SubdiagnosticKind::Note),\n+            \"help\" => Ok(SubdiagnosticKind::Help),\n+            \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n+            \"suggestion_short\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n+            }\n+            \"suggestion_hidden\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden))\n+            }\n+            \"suggestion_verbose\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose))\n+            }\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl quote::IdentFragment for SubdiagnosticKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            SubdiagnosticKind::Label => write!(f, \"label\"),\n+            SubdiagnosticKind::Note => write!(f, \"note\"),\n+            SubdiagnosticKind::Help => write!(f, \"help\"),\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n+                write!(f, \"suggestion\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short) => {\n+                write!(f, \"suggestion_short\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden) => {\n+                write!(f, \"suggestion_hidden\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose) => {\n+                write!(f, \"suggestion_verbose\")\n+            }\n+        }\n+    }\n+\n+    fn span(&self) -> Option<proc_macro2::Span> {\n+        None\n+    }\n+}\n+\n+pub(crate) struct SessionSubdiagnosticDerive<'a> {\n+    structure: Structure<'a>,\n+    diag: syn::Ident,\n+}\n+\n+impl<'a> SessionSubdiagnosticDerive<'a> {\n+    pub(crate) fn new(structure: Structure<'a>) -> Self {\n+        let diag = format_ident!(\"diag\");\n+        Self { structure, diag }\n+    }\n+\n+    pub(crate) fn into_tokens(self) -> TokenStream {\n+        let SessionSubdiagnosticDerive { mut structure, diag } = self;\n+        let implementation = {\n+            let ast = structure.ast();\n+            let span = ast.span().unwrap();\n+            match ast.data {\n+                syn::Data::Struct(..) | syn::Data::Enum(..) => (),\n+                syn::Data::Union(..) => {\n+                    span_err(\n+                        span,\n+                        \"`#[derive(SessionSubdiagnostic)]` can only be used on structs and enums\",\n+                    );\n+                }\n+            }\n+\n+            if matches!(ast.data, syn::Data::Enum(..)) {\n+                for attr in &ast.attrs {\n+                    span_err(\n+                        attr.span().unwrap(),\n+                        \"unsupported type attribute for subdiagnostic enum\",\n+                    )\n+                    .emit();\n+                }\n+            }\n+\n+            structure.bind_with(|_| synstructure::BindStyle::Move);\n+            let variants_ = structure.each_variant(|variant| {\n+                // Build the mapping of field names to fields. This allows attributes to peek\n+                // values from other fields.\n+                let mut fields_map = HashMap::new();\n+                for binding in variant.bindings() {\n+                    let field = binding.ast();\n+                    if let Some(ident) = &field.ident {\n+                        fields_map.insert(ident.to_string(), quote! { #binding });\n+                    }\n+                }\n+\n+                let mut builder = SessionSubdiagnosticDeriveBuilder {\n+                    diag: &diag,\n+                    variant,\n+                    span,\n+                    fields: fields_map,\n+                    kind: None,\n+                    slug: None,\n+                    code: None,\n+                    span_field: None,\n+                    applicability: None,\n+                };\n+                builder.into_tokens().unwrap_or_else(|v| v.to_compile_error())\n+            });\n+\n+            quote! {\n+                match self {\n+                    #variants_\n+                }\n+            }\n+        };\n+\n+        let ret = structure.gen_impl(quote! {\n+            gen impl rustc_errors::AddSubdiagnostic for @Self {\n+                fn add_to_diagnostic(self, #diag: &mut rustc_errors::Diagnostic) {\n+                    use rustc_errors::{Applicability, IntoDiagnosticArg};\n+                    #implementation\n+                }\n+            }\n+        });\n+        ret\n+    }\n+}\n+\n+struct SessionSubdiagnosticDeriveBuilder<'a> {\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n+    diag: &'a syn::Ident,\n+\n+    /// Info for the current variant (or the type if not an enum).\n+    variant: &'a VariantInfo<'a>,\n+    /// Span for the entire type.\n+    span: proc_macro::Span,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    fields: HashMap<String, TokenStream>,\n+\n+    /// Subdiagnostic kind of the type/variant.\n+    kind: Option<(SubdiagnosticKind, proc_macro::Span)>,\n+\n+    /// Slug of the subdiagnostic - corresponds to the Fluent identifier for the message - from the\n+    /// `#[kind(slug = \"...\")]` attribute on the type or variant.\n+    slug: Option<(String, proc_macro::Span)>,\n+    /// If a suggestion, the code to suggest as a replacement - from the `#[kind(code = \"...\")]`\n+    /// attribute on the type or variant.\n+    code: Option<(TokenStream, proc_macro::Span)>,\n+\n+    /// Identifier for the binding to the `#[primary_span]` field.\n+    span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n+    /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n+    /// `rustc_errors::Applicability::*` variant directly.\n+    applicability: Option<(TokenStream, proc_macro::Span)>,\n+}\n+\n+impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n+        self.fields.get(field)\n+    }\n+}\n+\n+impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n+    fn identify_kind(&mut self) -> Result<(), SessionDiagnosticDeriveError> {\n+        for attr in self.variant.ast().attrs {\n+            let span = attr.span().unwrap();\n+\n+            let name = attr.path.segments.last().unwrap().ident.to_string();\n+            let name = name.as_str();\n+\n+            let meta = attr.parse_meta()?;\n+            let kind = match meta {\n+                Meta::Path(_) => throw_span_err!(\n+                    span,\n+                    &format!(\"`#[{}]` is not a valid `SessionSubdiagnostic` attribute\", name)\n+                ),\n+                Meta::NameValue(_) => throw_span_err!(\n+                    span,\n+                    &format!(\"`#[{} = ...]` is not a valid `SessionSubdiagnostic` attribute\", name)\n+                ),\n+                Meta::List(MetaList { nested, .. }) => {\n+                    for attr in nested {\n+                        let meta = match attr {\n+                            syn::NestedMeta::Meta(meta) => meta,\n+                            syn::NestedMeta::Lit(_) => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}(\\\"...\\\")]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                    name\n+                                )\n+                            ),\n+                        };\n+\n+                        let span = meta.span().unwrap();\n+                        let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                        let nested_name = nested_name.as_str();\n+\n+                        match meta {\n+                            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                                match nested_name {\n+                                    \"code\" => {\n+                                        let formatted_str = self.build_format(&s.value(), s.span());\n+                                        self.code.set_once((formatted_str, span));\n+                                    }\n+                                    \"slug\" => self.slug.set_once((s.value(), span)),\n+                                    \"applicability\" => {\n+                                        let value = match Applicability::from_str(&s.value()) {\n+                                            Ok(v) => v,\n+                                            Err(()) => {\n+                                                span_err(span, \"invalid applicability\").emit();\n+                                                Applicability::Unspecified\n+                                            }\n+                                        };\n+                                        self.applicability.set_once((quote! { #value }, span));\n+                                    }\n+                                    other => throw_span_err!(\n+                                        span,\n+                                        &format!(\n+                                            \"`#[{}({} = ...)]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                            name, other\n+                                        )\n+                                    ),\n+                                }\n+                            }\n+                            Meta::NameValue(..) => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({} = ...)]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                    name, nested_name\n+                                ),\n+                                |diag| diag.help(\"value must be a string\")\n+                            ),\n+                            Meta::Path(..) => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({})]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                    name, nested_name\n+                                )\n+                            ),\n+                            Meta::List(..) => throw_span_err!(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({}(...))]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                    name, nested_name\n+                                )\n+                            ),\n+                        }\n+                    }\n+\n+                    let Ok(kind) = SubdiagnosticKind::from_str(name) else {\n+                        throw_span_err!(\n+                            span,\n+                            &format!(\n+                                \"`#[{}(...)]` is not a valid `SessionSubdiagnostic` attribute\",\n+                                name\n+                            )\n+                        );\n+                    };\n+                    kind\n+                }\n+            };\n+\n+            if matches!(\n+                kind,\n+                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n+            ) && self.code.is_some()\n+            {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\"`code` is not a valid nested attribute of a `{}` attribute\", name)\n+                );\n+            }\n+\n+            if self.slug.is_none() {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\"`slug` must be set in a `#[{}(...)]` attribute\", name)\n+                );\n+            }\n+\n+            self.kind.set_once((kind, span));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn generate_field_code(\n+        &mut self,\n+        binding: &BindingInfo<'_>,\n+        is_suggestion: bool,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let ast = binding.ast();\n+\n+        let option_ty = option_inner_ty(&ast.ty);\n+        let info = FieldInfo {\n+            vis: &ast.vis,\n+            binding: binding,\n+            ty: option_ty.unwrap_or(&ast.ty),\n+            span: &ast.span(),\n+        };\n+\n+        for attr in &ast.attrs {\n+            let name = attr.path.segments.last().unwrap().ident.to_string();\n+            let name = name.as_str();\n+            let span = attr.span().unwrap();\n+\n+            let meta = attr.parse_meta()?;\n+            match meta {\n+                Meta::Path(_) => match name {\n+                    \"primary_span\" => {\n+                        report_error_if_not_applied_to_span(attr, &info)?;\n+                        self.span_field.set_once((binding.binding.clone(), span));\n+                        return Ok(quote! {});\n+                    }\n+                    \"applicability\" if is_suggestion => {\n+                        report_error_if_not_applied_to_applicability(attr, &info)?;\n+                        let binding = binding.binding.clone();\n+                        self.applicability.set_once((quote! { #binding }, span));\n+                        return Ok(quote! {});\n+                    }\n+                    \"applicability\" => {\n+                        span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n+                        return Ok(quote! {});\n+                    }\n+                    \"skip_arg\" => {\n+                        return Ok(quote! {});\n+                    }\n+                    other => span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}]` is not a valid `SessionSubdiagnostic` field attribute\",\n+                            other\n+                        ),\n+                    )\n+                    .emit(),\n+                },\n+                Meta::NameValue(_) => span_err(\n+                    span,\n+                    &format!(\n+                        \"`#[{} = ...]` is not a valid `SessionSubdiagnostic` field attribute\",\n+                        name\n+                    ),\n+                )\n+                .emit(),\n+                Meta::List(_) => span_err(\n+                    span,\n+                    &format!(\n+                        \"`#[{}(...)]` is not a valid `SessionSubdiagnostic` field attribute\",\n+                        name\n+                    ),\n+                )\n+                .emit(),\n+            }\n+        }\n+\n+        let ident = ast.ident.as_ref().unwrap();\n+\n+        let diag = &self.diag;\n+        let generated = quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #binding.into_diagnostic_arg()\n+            );\n+        };\n+\n+        if option_ty.is_none() {\n+            Ok(quote! { #generated })\n+        } else {\n+            Ok(quote! {\n+                if let Some(#binding) = #binding {\n+                    #generated\n+                }\n+            })\n+        }\n+    }\n+\n+    fn into_tokens(&mut self) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        self.identify_kind()?;\n+        let Some(kind) = self.kind.map(|(kind, _)| kind) else {\n+            throw_span_err!(\n+                self.variant.ast().ident.span().unwrap(),\n+                \"subdiagnostic kind not specified\"\n+            );\n+        };\n+\n+        let is_suggestion = matches!(kind, SubdiagnosticKind::Suggestion(_));\n+\n+        let mut args = TokenStream::new();\n+        for binding in self.variant.bindings() {\n+            let arg = self\n+                .generate_field_code(binding, is_suggestion)\n+                .unwrap_or_else(|v| v.to_compile_error());\n+            args.extend(arg);\n+        }\n+\n+        // Missing slug errors will already have been reported.\n+        let slug = self.slug.as_ref().map(|(slug, _)| &**slug).unwrap_or(\"missing-slug\");\n+        let code = match self.code.as_ref() {\n+            Some((code, _)) => Some(quote! { #code }),\n+            None if is_suggestion => {\n+                span_err(self.span, \"suggestion without `code = \\\"...\\\"`\").emit();\n+                Some(quote! { /* macro error */ \"...\" })\n+            }\n+            None => None,\n+        };\n+\n+        let span_field = self.span_field.as_ref().map(|(span, _)| span);\n+        let applicability = match self.applicability.clone() {\n+            Some((applicability, _)) => Some(applicability),\n+            None if is_suggestion => {\n+                span_err(self.span, \"suggestion without `applicability`\").emit();\n+                Some(quote! { rustc_errors::Applicability::Unspecified })\n+            }\n+            None => None,\n+        };\n+\n+        let diag = &self.diag;\n+        let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n+        let message = quote! { rustc_errors::DiagnosticMessage::fluent(#slug) };\n+        let call = if matches!(kind, SubdiagnosticKind::Suggestion(..)) {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message, #code, #applicability); }\n+            } else {\n+                span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n+                quote! { unreachable!(); }\n+            }\n+        } else if matches!(kind, SubdiagnosticKind::Label) {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message); }\n+            } else {\n+                span_err(self.span, \"label without `#[primary_span]` field\").emit();\n+                quote! { unreachable!(); }\n+            }\n+        } else {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message); }\n+            } else {\n+                quote! { #diag.#name(#message); }\n+            }\n+        };\n+\n+        Ok(quote! {\n+            #call\n+            #args\n+        })\n+    }\n+}"}, {"sha": "c44ca7cc626125a0e1513ddef79b207ad9e53793", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=071f07274b3d0b2c0806e0a904b71e51da1318de", "patch": "@@ -0,0 +1,221 @@\n+use crate::diagnostics::error::{span_err, throw_span_err, SessionDiagnosticDeriveError};\n+use proc_macro::Span;\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use std::collections::BTreeSet;\n+use syn::{spanned::Spanned, Attribute, Meta, Type, Visibility};\n+use synstructure::BindingInfo;\n+\n+/// Checks whether the type name of `ty` matches `name`.\n+///\n+/// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n+/// `a::b::c::Foo`. This reasonably allows qualified names to be used in the macro.\n+pub(crate) fn type_matches_path(ty: &Type, name: &[&str]) -> bool {\n+    if let Type::Path(ty) = ty {\n+        ty.path\n+            .segments\n+            .iter()\n+            .map(|s| s.ident.to_string())\n+            .rev()\n+            .zip(name.iter().rev())\n+            .all(|(x, y)| &x.as_str() == y)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Reports an error if the field's type is not `Applicability`.\n+fn report_error_if_not_applied_to_ty(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+    path: &[&str],\n+    ty_name: &str,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    if !type_matches_path(&info.ty, path) {\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        let meta = attr.parse_meta()?;\n+\n+        throw_span_err!(\n+            attr.span().unwrap(),\n+            &format!(\n+                \"the `#[{}{}]` attribute can only be applied to fields of type `{}`\",\n+                name,\n+                match meta {\n+                    Meta::Path(_) => \"\",\n+                    Meta::NameValue(_) => \" = ...\",\n+                    Meta::List(_) => \"(...)\",\n+                },\n+                ty_name\n+            )\n+        );\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Reports an error if the field's type is not `Applicability`.\n+pub(crate) fn report_error_if_not_applied_to_applicability(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    report_error_if_not_applied_to_ty(\n+        attr,\n+        info,\n+        &[\"rustc_errors\", \"Applicability\"],\n+        \"Applicability\",\n+    )\n+}\n+\n+/// Reports an error if the field's type is not `Span`.\n+pub(crate) fn report_error_if_not_applied_to_span(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"Span\")\n+}\n+\n+/// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n+pub(crate) fn option_inner_ty(ty: &Type) -> Option<&Type> {\n+    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+        if let Type::Path(ty_path) = ty {\n+            let path = &ty_path.path;\n+            let ty = path.segments.iter().last().unwrap();\n+            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n+                if bracketed.args.len() == 1 {\n+                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n+                        return Some(ty);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+/// Field information passed to the builder. Deliberately omits attrs to discourage the\n+/// `generate_*` methods from walking the attributes themselves.\n+pub(crate) struct FieldInfo<'a> {\n+    pub(crate) vis: &'a Visibility,\n+    pub(crate) binding: &'a BindingInfo<'a>,\n+    pub(crate) ty: &'a Type,\n+    pub(crate) span: &'a proc_macro2::Span,\n+}\n+\n+pub(crate) trait SetOnce<T> {\n+    fn set_once(&mut self, value: T);\n+}\n+\n+impl<T> SetOnce<(T, Span)> for Option<(T, Span)> {\n+    fn set_once(&mut self, (value, span): (T, Span)) {\n+        match self {\n+            None => {\n+                *self = Some((value, span));\n+            }\n+            Some((_, prev_span)) => {\n+                span_err(span, \"specified multiple times\")\n+                    .span_note(*prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) trait HasFieldMap {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream>;\n+\n+    /// In the strings in the attributes supplied to this macro, we want callers to be able to\n+    /// reference fields in the format string. For example:\n+    ///\n+    /// ```ignore (not-usage-example)\n+    /// /// Suggest `==` when users wrote `===`.\n+    /// #[suggestion(slug = \"parser-not-javascript-eq\", code = \"{lhs} == {rhs}\")]\n+    /// struct NotJavaScriptEq {\n+    ///     #[primary_span]\n+    ///     span: Span,\n+    ///     lhs: Ident,\n+    ///     rhs: Ident,\n+    /// }\n+    /// ```\n+    ///\n+    /// We want to automatically pick up that `{lhs}` refers `self.lhs` and `{rhs}` refers to\n+    /// `self.rhs`, then generate this call to `format!`:\n+    ///\n+    /// ```ignore (not-usage-example)\n+    /// format!(\"{lhs} == {rhs}\", lhs = self.lhs, rhs = self.rhs)\n+    /// ```\n+    ///\n+    /// This function builds the entire call to `format!`.\n+    fn build_format(&self, input: &str, span: proc_macro2::Span) -> TokenStream {\n+        // This set is used later to generate the final format string. To keep builds reproducible,\n+        // the iteration order needs to be deterministic, hence why we use a `BTreeSet` here\n+        // instead of a `HashSet`.\n+        let mut referenced_fields: BTreeSet<String> = BTreeSet::new();\n+\n+        // At this point, we can start parsing the format string.\n+        let mut it = input.chars().peekable();\n+\n+        // Once the start of a format string has been found, process the format string and spit out\n+        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so\n+        // the next call to `it.next()` retrieves the next character.\n+        while let Some(c) = it.next() {\n+            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n+                let mut eat_argument = || -> Option<String> {\n+                    let mut result = String::new();\n+                    // Format specifiers look like:\n+                    //\n+                    //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                    //\n+                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n+                    while let Some(c) = it.next() {\n+                        result.push(c);\n+                        let next = *it.peek().unwrap_or(&'\\0');\n+                        if next == '}' {\n+                            break;\n+                        } else if next == ':' {\n+                            // Eat the ':' character.\n+                            assert_eq!(it.next().unwrap(), ':');\n+                            break;\n+                        }\n+                    }\n+                    // Eat until (and including) the matching '}'\n+                    while it.next()? != '}' {\n+                        continue;\n+                    }\n+                    Some(result)\n+                };\n+\n+                if let Some(referenced_field) = eat_argument() {\n+                    referenced_fields.insert(referenced_field);\n+                }\n+            }\n+        }\n+\n+        // At this point, `referenced_fields` contains a set of the unique fields that were\n+        // referenced in the format string. Generate the corresponding \"x = self.x\" format\n+        // string parameters:\n+        let args = referenced_fields.into_iter().map(|field: String| {\n+            let field_ident = format_ident!(\"{}\", field);\n+            let value = match self.get_field_binding(&field) {\n+                Some(value) => value.clone(),\n+                // This field doesn't exist. Emit a diagnostic.\n+                None => {\n+                    span_err(\n+                        span.unwrap(),\n+                        &format!(\"`{}` doesn't refer to a field on this type\", field),\n+                    )\n+                    .emit();\n+                    quote! {\n+                        \"{#field}\"\n+                    }\n+                }\n+            };\n+            quote! {\n+                #field_ident = #value\n+            }\n+        });\n+        quote! {\n+            format!(#input #(,#args)*)\n+        }\n+    }\n+}"}, {"sha": "ed2021e7d748866e6ddf5a696d2c0107b75a96d3", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/071f07274b3d0b2c0806e0a904b71e51da1318de/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=071f07274b3d0b2c0806e0a904b71e51da1318de", "patch": "@@ -8,12 +8,12 @@ use synstructure::decl_derive;\n \n use proc_macro::TokenStream;\n \n+mod diagnostics;\n mod hash_stable;\n mod lift;\n mod newtype;\n mod query;\n mod serialize;\n-mod session_diagnostic;\n mod symbols;\n mod type_foldable;\n \n@@ -76,7 +76,7 @@ decl_derive!(\n         suggestion,\n         suggestion_short,\n         suggestion_hidden,\n-        suggestion_verbose)] => session_diagnostic::session_diagnostic_derive\n+        suggestion_verbose)] => diagnostics::session_diagnostic_derive\n );\n decl_derive!(\n     [SessionSubdiagnostic, attributes(\n@@ -91,5 +91,5 @@ decl_derive!(\n         // field attributes\n         skip_arg,\n         primary_span,\n-        applicability)] => session_diagnostic::session_subdiagnostic_derive\n+        applicability)] => diagnostics::session_subdiagnostic_derive\n );"}, {"sha": "27c94f3e306b8ad364dc3f663b4ca14e657cae5a", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "removed", "additions": 0, "deletions": 1590, "changes": 1590, "blob_url": "https://github.com/rust-lang/rust/blob/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ec909ca7d649d73115f7e0e894b0ffb0740b66/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=49ec909ca7d649d73115f7e0e894b0ffb0740b66", "patch": "@@ -1,1590 +0,0 @@\n-#![deny(unused_must_use)]\n-use proc_macro::{Diagnostic, Level, MultiSpan};\n-use proc_macro2::TokenStream;\n-use quote::{format_ident, quote};\n-use std::collections::{BTreeSet, HashMap};\n-use std::fmt;\n-use std::str::FromStr;\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, Type, Visibility};\n-use synstructure::{BindingInfo, Structure, VariantInfo};\n-\n-/// Implements `#[derive(SessionDiagnostic)]`, which allows for errors to be specified as a struct,\n-/// independent from the actual diagnostics emitting code.\n-///\n-/// ```ignore (pseudo-rust)\n-/// # extern crate rustc_errors;\n-/// # use rustc_errors::Applicability;\n-/// # extern crate rustc_span;\n-/// # use rustc_span::{symbol::Ident, Span};\n-/// # extern crate rust_middle;\n-/// # use rustc_middle::ty::Ty;\n-/// #[derive(SessionDiagnostic)]\n-/// #[error(code = \"E0505\", slug = \"borrowck-move-out-of-borrow\")]\n-/// pub struct MoveOutOfBorrowError<'tcx> {\n-///     pub name: Ident,\n-///     pub ty: Ty<'tcx>,\n-///     #[primary_span]\n-///     #[label]\n-///     pub span: Span,\n-///     #[label = \"first-borrow-label\"]\n-///     pub first_borrow_span: Span,\n-///     #[suggestion(code = \"{name}.clone()\")]\n-///     pub clone_sugg: Option<(Span, Applicability)>\n-/// }\n-/// ```\n-///\n-/// ```fluent\n-/// move-out-of-borrow = cannot move out of {$name} because it is borrowed\n-///     .label = cannot move out of borrow\n-///     .first-borrow-label = `{$ty}` first borrowed here\n-///     .suggestion = consider cloning here\n-/// ```\n-///\n-/// Then, later, to emit the error:\n-///\n-/// ```ignore (pseudo-rust)\n-/// sess.emit_err(MoveOutOfBorrowError {\n-///     expected,\n-///     actual,\n-///     span,\n-///     first_borrow_span,\n-///     clone_sugg: Some(suggestion, Applicability::MachineApplicable),\n-/// });\n-/// ```\n-///\n-/// See rustc dev guide for more examples on using the `#[derive(SessionDiagnostic)]`:\n-/// <https://rustc-dev-guide.rust-lang.org/diagnostics/sessiondiagnostic.html>\n-pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n-    // Names for the diagnostic we build and the session we build it from.\n-    let diag = format_ident!(\"diag\");\n-    let sess = format_ident!(\"sess\");\n-\n-    SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n-}\n-\n-/// Implements `#[derive(SessionSubdiagnostic)]`, which allows for labels, notes, helps and\n-/// suggestions to be specified as a structs or enums, independent from the actual diagnostics\n-/// emitting code or diagnostic derives.\n-///\n-/// ```ignore (pseudo-rust)\n-/// #[derive(SessionSubdiagnostic)]\n-/// pub enum ExpectedIdentifierLabel<'tcx> {\n-///     #[label(slug = \"parser-expected-identifier\")]\n-///     WithoutFound {\n-///         #[primary_span]\n-///         span: Span,\n-///     }\n-///     #[label(slug = \"parser-expected-identifier-found\")]\n-///     WithFound {\n-///         #[primary_span]\n-///         span: Span,\n-///         found: String,\n-///     }\n-/// }\n-///\n-/// #[derive(SessionSubdiagnostic)]\n-/// #[suggestion_verbose(slug = \"parser-raw-identifier\")]\n-/// pub struct RawIdentifierSuggestion<'tcx> {\n-///     #[primary_span]\n-///     span: Span,\n-///     #[applicability]\n-///     applicability: Applicability,\n-///     ident: Ident,\n-/// }\n-/// ```\n-///\n-/// ```fluent\n-/// parser-expected-identifier = expected identifier\n-///\n-/// parser-expected-identifier-found = expected identifier, found {$found}\n-///\n-/// parser-raw-identifier = escape `{$ident}` to use it as an identifier\n-/// ```\n-///\n-/// Then, later, to add the subdiagnostic:\n-///\n-/// ```ignore (pseudo-rust)\n-/// diag.subdiagnostic(ExpectedIdentifierLabel::WithoutFound { span });\n-///\n-/// diag.subdiagnostic(RawIdentifierSuggestion { span, applicability, ident });\n-/// ```\n-pub fn session_subdiagnostic_derive(s: Structure<'_>) -> TokenStream {\n-    SessionSubdiagnosticDerive::new(s).into_tokens()\n-}\n-\n-/// Checks whether the type name of `ty` matches `name`.\n-///\n-/// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n-/// `a::b::c::Foo`. This reasonably allows qualified names to be used in the macro.\n-fn type_matches_path(ty: &Type, name: &[&str]) -> bool {\n-    if let Type::Path(ty) = ty {\n-        ty.path\n-            .segments\n-            .iter()\n-            .map(|s| s.ident.to_string())\n-            .rev()\n-            .zip(name.iter().rev())\n-            .all(|(x, y)| &x.as_str() == y)\n-    } else {\n-        false\n-    }\n-}\n-\n-/// The central struct for constructing the `as_error` method from an annotated struct.\n-struct SessionDiagnosticDerive<'a> {\n-    structure: Structure<'a>,\n-    builder: SessionDiagnosticDeriveBuilder,\n-}\n-\n-impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n-    fn from(e: syn::Error) -> Self {\n-        SessionDiagnosticDeriveError::SynError(e)\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum SessionDiagnosticDeriveError {\n-    SynError(syn::Error),\n-    ErrorHandled,\n-}\n-\n-impl SessionDiagnosticDeriveError {\n-    fn to_compile_error(self) -> TokenStream {\n-        match self {\n-            SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n-            SessionDiagnosticDeriveError::ErrorHandled => {\n-                // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n-                // error has already been emitted to the compiler.\n-                quote! {\n-                    { unreachable!(); }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n-    Diagnostic::spanned(span, Level::Error, msg)\n-}\n-\n-/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n-///\n-/// Emit a diagnostic on span `$span` with msg `$msg` (optionally performing additional decoration\n-/// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n-macro_rules! throw_span_err {\n-    ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n-    ($span:expr, $msg:expr, $f:expr) => {{\n-        return Err(_throw_span_err($span, $msg, $f));\n-    }};\n-}\n-\n-/// When possible, prefer using `throw_span_err!` over using this function directly. This only\n-/// exists as a function to constrain `f` to an `impl FnOnce`.\n-fn _throw_span_err(\n-    span: impl MultiSpan,\n-    msg: &str,\n-    f: impl FnOnce(Diagnostic) -> Diagnostic,\n-) -> SessionDiagnosticDeriveError {\n-    let diag = span_err(span, msg);\n-    f(diag).emit();\n-    SessionDiagnosticDeriveError::ErrorHandled\n-}\n-\n-impl<'a> SessionDiagnosticDerive<'a> {\n-    fn new(diag: syn::Ident, sess: syn::Ident, structure: Structure<'a>) -> Self {\n-        // Build the mapping of field names to fields. This allows attributes to peek values from\n-        // other fields.\n-        let mut fields_map = HashMap::new();\n-\n-        // Convenience bindings.\n-        let ast = structure.ast();\n-\n-        if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n-            for field in fields.iter() {\n-                if let Some(ident) = &field.ident {\n-                    fields_map.insert(ident.to_string(), quote! { &self.#ident });\n-                }\n-            }\n-        }\n-\n-        Self {\n-            builder: SessionDiagnosticDeriveBuilder {\n-                diag,\n-                sess,\n-                fields: fields_map,\n-                kind: None,\n-                code: None,\n-                slug: None,\n-            },\n-            structure,\n-        }\n-    }\n-\n-    fn into_tokens(self) -> TokenStream {\n-        let SessionDiagnosticDerive { mut structure, mut builder } = self;\n-\n-        let ast = structure.ast();\n-        let attrs = &ast.attrs;\n-\n-        let (implementation, param_ty) = {\n-            if let syn::Data::Struct(..) = ast.data {\n-                let preamble = {\n-                    let preamble = attrs.iter().map(|attr| {\n-                        builder\n-                            .generate_structure_code(attr)\n-                            .unwrap_or_else(|v| v.to_compile_error())\n-                    });\n-\n-                    quote! {\n-                        #(#preamble)*;\n-                    }\n-                };\n-\n-                // Generates calls to `span_label` and similar functions based on the attributes\n-                // on fields. Code for suggestions uses formatting machinery and the value of\n-                // other fields - because any given field can be referenced multiple times, it\n-                // should be accessed through a borrow. When passing fields to `set_arg` (which\n-                // happens below) for Fluent, we want to move the data, so that has to happen\n-                // in a separate pass over the fields.\n-                let attrs = structure.each(|field_binding| {\n-                    let field = field_binding.ast();\n-                    let result = field.attrs.iter().map(|attr| {\n-                        builder\n-                            .generate_field_attr_code(\n-                                attr,\n-                                FieldInfo {\n-                                    vis: &field.vis,\n-                                    binding: field_binding,\n-                                    ty: &field.ty,\n-                                    span: &field.span(),\n-                                },\n-                            )\n-                            .unwrap_or_else(|v| v.to_compile_error())\n-                    });\n-\n-                    quote! { #(#result);* }\n-                });\n-\n-                // When generating `set_arg` calls, move data rather than borrow it to avoid\n-                // requiring clones - this must therefore be the last use of each field (for\n-                // example, any formatting machinery that might refer to a field should be\n-                // generated already).\n-                structure.bind_with(|_| synstructure::BindStyle::Move);\n-                let args = structure.each(|field_binding| {\n-                    let field = field_binding.ast();\n-                    // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n-                    // need to be passed as an argument to the diagnostic. But when a field has no\n-                    // attributes then it must be passed as an argument to the diagnostic so that\n-                    // it can be referred to by Fluent messages.\n-                    if field.attrs.is_empty() {\n-                        let diag = &builder.diag;\n-                        let ident = field_binding.ast().ident.as_ref().unwrap();\n-                        quote! {\n-                            #diag.set_arg(\n-                                stringify!(#ident),\n-                                #field_binding.into_diagnostic_arg()\n-                            );\n-                        }\n-                    } else {\n-                        quote! {}\n-                    }\n-                });\n-\n-                let span = ast.span().unwrap();\n-                let (diag, sess) = (&builder.diag, &builder.sess);\n-                let init = match (builder.kind, builder.slug) {\n-                    (None, _) => {\n-                        span_err(span, \"diagnostic kind not specified\")\n-                            .help(\"use the `#[error(...)]` attribute to create an error\")\n-                            .emit();\n-                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n-                    }\n-                    (Some((kind, _)), None) => {\n-                        span_err(span, \"`slug` not specified\")\n-                            .help(&format!(\"use the `#[{}(slug = \\\"...\\\")]` attribute to set this diagnostic's slug\", kind.descr()))\n-                            .emit();\n-                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n-                    }\n-                    (Some((SessionDiagnosticKind::Error, _)), Some((slug, _))) => {\n-                        quote! {\n-                            let mut #diag = #sess.struct_err(\n-                                rustc_errors::DiagnosticMessage::fluent(#slug),\n-                            );\n-                        }\n-                    }\n-                    (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _))) => {\n-                        quote! {\n-                            let mut #diag = #sess.struct_warn(\n-                                rustc_errors::DiagnosticMessage::fluent(#slug),\n-                            );\n-                        }\n-                    }\n-                };\n-\n-                let implementation = quote! {\n-                    #init\n-                    #preamble\n-                    match self {\n-                        #attrs\n-                    }\n-                    match self {\n-                        #args\n-                    }\n-                    #diag\n-                };\n-                let param_ty = match builder.kind {\n-                    Some((SessionDiagnosticKind::Error, _)) => {\n-                        quote! { rustc_errors::ErrorGuaranteed }\n-                    }\n-                    Some((SessionDiagnosticKind::Warn, _)) => quote! { () },\n-                    _ => unreachable!(),\n-                };\n-\n-                (implementation, param_ty)\n-            } else {\n-                span_err(\n-                    ast.span().unwrap(),\n-                    \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n-                )\n-                .emit();\n-\n-                let implementation = SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n-                let param_ty = quote! { rustc_errors::ErrorGuaranteed };\n-                (implementation, param_ty)\n-            }\n-        };\n-\n-        let sess = &builder.sess;\n-        structure.gen_impl(quote! {\n-            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess, #param_ty>\n-                    for @Self\n-            {\n-                fn into_diagnostic(\n-                    self,\n-                    #sess: &'__session_diagnostic_sess rustc_session::parse::ParseSess\n-                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, #param_ty> {\n-                    use rustc_errors::IntoDiagnosticArg;\n-                    #implementation\n-                }\n-            }\n-        })\n-    }\n-}\n-\n-/// Field information passed to the builder. Deliberately omits attrs to discourage the\n-/// `generate_*` methods from walking the attributes themselves.\n-struct FieldInfo<'a> {\n-    vis: &'a Visibility,\n-    binding: &'a BindingInfo<'a>,\n-    ty: &'a Type,\n-    span: &'a proc_macro2::Span,\n-}\n-\n-/// What kind of session diagnostic is being derived - an error or a warning?\n-#[derive(Copy, Clone)]\n-enum SessionDiagnosticKind {\n-    /// `#[error(..)]`\n-    Error,\n-    /// `#[warn(..)]`\n-    Warn,\n-}\n-\n-impl SessionDiagnosticKind {\n-    /// Returns human-readable string corresponding to the kind.\n-    fn descr(&self) -> &'static str {\n-        match self {\n-            SessionDiagnosticKind::Error => \"error\",\n-            SessionDiagnosticKind::Warn => \"warning\",\n-        }\n-    }\n-}\n-\n-/// Tracks persistent information required for building up the individual calls to diagnostic\n-/// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n-/// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n-/// double mut borrow later on.\n-struct SessionDiagnosticDeriveBuilder {\n-    /// Name of the session parameter that's passed in to the `as_error` method.\n-    sess: syn::Ident,\n-    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n-    diag: syn::Ident,\n-\n-    /// Store a map of field name to its corresponding field. This is built on construction of the\n-    /// derive builder.\n-    fields: HashMap<String, TokenStream>,\n-\n-    /// Kind of diagnostic requested via the struct attribute.\n-    kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n-    /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n-    /// has the actual diagnostic message.\n-    slug: Option<(String, proc_macro::Span)>,\n-    /// Error codes are a optional part of the struct attribute - this is only set to detect\n-    /// multiple specifications.\n-    code: Option<proc_macro::Span>,\n-}\n-\n-impl SessionDiagnosticDeriveBuilder {\n-    /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n-    /// attributes like `#[error(..)#`, such as the diagnostic kind and slug. Generates\n-    /// diagnostic builder calls for setting error code and creating note/help messages.\n-    fn generate_structure_code(\n-        &mut self,\n-        attr: &Attribute,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        let span = attr.span().unwrap();\n-\n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_str();\n-        let meta = attr.parse_meta()?;\n-\n-        if matches!(name, \"help\" | \"note\") && matches!(meta, Meta::Path(_) | Meta::NameValue(_)) {\n-            let diag = &self.diag;\n-            let slug = match &self.slug {\n-                Some((slug, _)) => slug.as_str(),\n-                None => throw_span_err!(\n-                    span,\n-                    &format!(\n-                        \"`#[{}{}]` must come after `#[error(..)]` or `#[warn(..)]`\",\n-                        name,\n-                        match meta {\n-                            Meta::Path(_) => \"\",\n-                            Meta::NameValue(_) => \" = ...\",\n-                            _ => unreachable!(),\n-                        }\n-                    )\n-                ),\n-            };\n-            let id = match meta {\n-                Meta::Path(..) => quote! { #name },\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    quote! { #s }\n-                }\n-                _ => unreachable!(),\n-            };\n-            let fn_name = proc_macro2::Ident::new(name, attr.span());\n-\n-            return Ok(quote! {\n-                #diag.#fn_name(rustc_errors::DiagnosticMessage::fluent_attr(#slug, #id));\n-            });\n-        }\n-\n-        let nested = match meta {\n-            Meta::List(MetaList { nested, .. }) => nested,\n-            Meta::Path(..) => throw_span_err!(\n-                span,\n-                &format!(\"`#[{}]` is not a valid `SessionDiagnostic` struct attribute\", name)\n-            ),\n-            Meta::NameValue(..) => throw_span_err!(\n-                span,\n-                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` struct attribute\", name)\n-            ),\n-        };\n-\n-        let kind = match name {\n-            \"error\" => SessionDiagnosticKind::Error,\n-            \"warning\" => SessionDiagnosticKind::Warn,\n-            other => throw_span_err!(\n-                span,\n-                &format!(\"`#[{}(...)]` is not a valid `SessionDiagnostic` struct attribute\", other)\n-            ),\n-        };\n-        self.set_kind_once(kind, span)?;\n-\n-        let mut tokens = Vec::new();\n-        for attr in nested {\n-            let span = attr.span().unwrap();\n-            let meta = match attr {\n-                syn::NestedMeta::Meta(meta) => meta,\n-                syn::NestedMeta::Lit(_) => throw_span_err!(\n-                    span,\n-                    &format!(\n-                        \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` struct attribute\",\n-                        name\n-                    )\n-                ),\n-            };\n-\n-            let path = meta.path();\n-            let nested_name = path.segments.last().unwrap().ident.to_string();\n-            match &meta {\n-                // Struct attributes are only allowed to be applied once, and the diagnostic\n-                // changes will be set in the initialisation code.\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    match nested_name.as_str() {\n-                        \"slug\" => {\n-                            self.set_slug_once(s.value(), s.span().unwrap());\n-                        }\n-                        \"code\" => {\n-                            tokens.push(self.set_code_once(s.value(), s.span().unwrap()));\n-                        }\n-                        other => {\n-                            let diag = span_err(\n-                                span,\n-                                &format!(\n-                                    \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n-                                    name, other\n-                                ),\n-                            );\n-                            diag.emit();\n-                        }\n-                    }\n-                }\n-                Meta::NameValue(..) => {\n-                    span_err(\n-                        span,\n-                        &format!(\n-                            \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n-                            name, nested_name\n-                        ),\n-                    )\n-                    .help(\"value must be a string\")\n-                    .emit();\n-                }\n-                Meta::Path(..) => {\n-                    span_err(\n-                        span,\n-                        &format!(\n-                            \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n-                            name, nested_name\n-                        ),\n-                    )\n-                    .emit();\n-                }\n-                Meta::List(..) => {\n-                    span_err(\n-                        span,\n-                        &format!(\n-                            \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n-                            name, nested_name\n-                        ),\n-                    )\n-                    .emit();\n-                }\n-            }\n-        }\n-\n-        Ok(tokens.drain(..).collect())\n-    }\n-\n-    #[must_use]\n-    fn set_kind_once(\n-        &mut self,\n-        kind: SessionDiagnosticKind,\n-        span: proc_macro::Span,\n-    ) -> Result<(), SessionDiagnosticDeriveError> {\n-        match self.kind {\n-            None => {\n-                self.kind = Some((kind, span));\n-                Ok(())\n-            }\n-            Some((prev_kind, prev_span)) => {\n-                let existing = prev_kind.descr();\n-                let current = kind.descr();\n-\n-                let msg = if current == existing {\n-                    format!(\"`{}` specified multiple times\", existing)\n-                } else {\n-                    format!(\"`{}` specified when `{}` was already specified\", current, existing)\n-                };\n-                throw_span_err!(span, &msg, |diag| diag\n-                    .span_note(prev_span, \"previously specified here\"));\n-            }\n-        }\n-    }\n-\n-    fn set_code_once(&mut self, code: String, span: proc_macro::Span) -> TokenStream {\n-        match self.code {\n-            None => {\n-                self.code = Some(span);\n-            }\n-            Some(prev_span) => {\n-                span_err(span, \"`code` specified multiple times\")\n-                    .span_note(prev_span, \"previously specified here\")\n-                    .emit();\n-            }\n-        }\n-\n-        let diag = &self.diag;\n-        quote! { #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string())); }\n-    }\n-\n-    fn set_slug_once(&mut self, slug: String, span: proc_macro::Span) {\n-        match self.slug {\n-            None => {\n-                self.slug = Some((slug, span));\n-            }\n-            Some((_, prev_span)) => {\n-                span_err(span, \"`slug` specified multiple times\")\n-                    .span_note(prev_span, \"previously specified here\")\n-                    .emit();\n-            }\n-        }\n-    }\n-\n-    fn generate_field_attr_code(\n-        &mut self,\n-        attr: &syn::Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        let field_binding = &info.binding.binding;\n-        let option_ty = option_inner_ty(&info.ty);\n-        let generated_code = self.generate_non_option_field_code(\n-            attr,\n-            FieldInfo {\n-                vis: info.vis,\n-                binding: info.binding,\n-                ty: option_ty.unwrap_or(&info.ty),\n-                span: info.span,\n-            },\n-        )?;\n-\n-        if option_ty.is_none() {\n-            Ok(quote! { #generated_code })\n-        } else {\n-            Ok(quote! {\n-                if let Some(#field_binding) = #field_binding {\n-                    #generated_code\n-                }\n-            })\n-        }\n-    }\n-\n-    fn generate_non_option_field_code(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        let diag = &self.diag;\n-        let span = attr.span().unwrap();\n-        let field_binding = &info.binding.binding;\n-\n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_str();\n-\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(_) => match name {\n-                \"skip_arg\" => {\n-                    // Don't need to do anything - by virtue of the attribute existing, the\n-                    // `set_arg` call will not be generated.\n-                    Ok(quote! {})\n-                }\n-                \"primary_span\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(quote! {\n-                        #diag.set_span(*#field_binding);\n-                    })\n-                }\n-                \"label\" | \"note\" | \"help\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_subdiagnostic(field_binding, name, name))\n-                }\n-                other => throw_span_err!(\n-                    span,\n-                    &format!(\"`#[{}]` is not a valid `SessionDiagnostic` field attribute\", other)\n-                ),\n-            },\n-            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => match name {\n-                \"label\" | \"note\" | \"help\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_subdiagnostic(field_binding, name, &s.value()))\n-                }\n-                other => throw_span_err!(\n-                    span,\n-                    &format!(\n-                        \"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\",\n-                        other\n-                    )\n-                ),\n-            },\n-            Meta::NameValue(_) => throw_span_err!(\n-                span,\n-                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\", name),\n-                |diag| diag.help(\"value must be a string\")\n-            ),\n-            Meta::List(MetaList { path, nested, .. }) => {\n-                let name = path.segments.last().unwrap().ident.to_string();\n-                let name = name.as_ref();\n-\n-                match name {\n-                    \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\"\n-                    | \"suggestion_verbose\" => (),\n-                    other => throw_span_err!(\n-                        span,\n-                        &format!(\n-                            \"`#[{}(...)]` is not a valid `SessionDiagnostic` field attribute\",\n-                            other\n-                        )\n-                    ),\n-                };\n-\n-                let (span_, applicability) = self.span_and_applicability_of_ty(info)?;\n-\n-                let mut msg = None;\n-                let mut code = None;\n-\n-                for attr in nested {\n-                    let meta = match attr {\n-                        syn::NestedMeta::Meta(meta) => meta,\n-                        syn::NestedMeta::Lit(_) => throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` field attribute\",\n-                                name\n-                            )\n-                        ),\n-                    };\n-\n-                    let span = meta.span().unwrap();\n-                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                    let nested_name = nested_name.as_str();\n-\n-                    match meta {\n-                        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                            match nested_name {\n-                                \"message\" => {\n-                                    msg = Some(s.value());\n-                                }\n-                                \"code\" => {\n-                                    let formatted_str = self.build_format(&s.value(), s.span());\n-                                    code = Some(formatted_str);\n-                                }\n-                                other => throw_span_err!(\n-                                    span,\n-                                    &format!(\n-                                        \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` field attribute\",\n-                                        name, other\n-                                    )\n-                                ),\n-                            }\n-                        }\n-                        Meta::NameValue(..) => throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n-                                name, nested_name\n-                            ),\n-                            |diag| diag.help(\"value must be a string\")\n-                        ),\n-                        Meta::Path(..) => throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n-                                name, nested_name\n-                            )\n-                        ),\n-                        Meta::List(..) => throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n-                                name, nested_name\n-                            )\n-                        ),\n-                    }\n-                }\n-\n-                let method = format_ident!(\"span_{}\", name);\n-\n-                let slug = self\n-                    .slug\n-                    .as_ref()\n-                    .map(|(slug, _)| slug.as_str())\n-                    .unwrap_or_else(|| \"missing-slug\");\n-                let msg = msg.as_deref().unwrap_or(\"suggestion\");\n-                let msg = quote! { rustc_errors::DiagnosticMessage::fluent_attr(#slug, #msg) };\n-                let code = code.unwrap_or_else(|| quote! { String::new() });\n-\n-                Ok(quote! { #diag.#method(#span_, #msg, #code, #applicability); })\n-            }\n-        }\n-    }\n-\n-    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug and\n-    /// `fluent_attr_identifier`.\n-    fn add_subdiagnostic(\n-        &self,\n-        field_binding: &proc_macro2::Ident,\n-        kind: &str,\n-        fluent_attr_identifier: &str,\n-    ) -> TokenStream {\n-        let diag = &self.diag;\n-\n-        let slug =\n-            self.slug.as_ref().map(|(slug, _)| slug.as_str()).unwrap_or_else(|| \"missing-slug\");\n-        let fn_name = format_ident!(\"span_{}\", kind);\n-        quote! {\n-            #diag.#fn_name(\n-                *#field_binding,\n-                rustc_errors::DiagnosticMessage::fluent_attr(#slug, #fluent_attr_identifier)\n-            );\n-        }\n-    }\n-\n-    fn span_and_applicability_of_ty(\n-        &self,\n-        info: FieldInfo<'_>,\n-    ) -> Result<(TokenStream, TokenStream), SessionDiagnosticDeriveError> {\n-        match &info.ty {\n-            // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n-            ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n-                let binding = &info.binding.binding;\n-                Ok((quote!(*#binding), quote!(rustc_errors::Applicability::Unspecified)))\n-            }\n-            // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n-            Type::Tuple(tup) => {\n-                let mut span_idx = None;\n-                let mut applicability_idx = None;\n-\n-                for (idx, elem) in tup.elems.iter().enumerate() {\n-                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n-                        if span_idx.is_none() {\n-                            span_idx = Some(syn::Index::from(idx));\n-                        } else {\n-                            throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more than one `Span`\"\n-                            );\n-                        }\n-                    } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n-                        if applicability_idx.is_none() {\n-                            applicability_idx = Some(syn::Index::from(idx));\n-                        } else {\n-                            throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n-                            );\n-                        }\n-                    }\n-                }\n-\n-                if let Some(span_idx) = span_idx {\n-                    let binding = &info.binding.binding;\n-                    let span = quote!(#binding.#span_idx);\n-                    let applicability = applicability_idx\n-                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n-                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n-\n-                    return Ok((span, applicability));\n-                }\n-\n-                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n-                    diag.help(\"`#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\")\n-                });\n-            }\n-            // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n-            _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n-                diag.help(\"`#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\")\n-            }),\n-        }\n-    }\n-}\n-\n-trait HasFieldMap {\n-    fn get_field_binding(&self, field: &String) -> Option<&TokenStream>;\n-\n-    /// In the strings in the attributes supplied to this macro, we want callers to be able to\n-    /// reference fields in the format string. For example:\n-    ///\n-    /// ```ignore (not-usage-example)\n-    /// /// Suggest `==` when users wrote `===`.\n-    /// #[suggestion(slug = \"parser-not-javascript-eq\", code = \"{lhs} == {rhs}\")]\n-    /// struct NotJavaScriptEq {\n-    ///     #[primary_span]\n-    ///     span: Span,\n-    ///     lhs: Ident,\n-    ///     rhs: Ident,\n-    /// }\n-    /// ```\n-    ///\n-    /// We want to automatically pick up that `{lhs}` refers `self.lhs` and `{rhs}` refers to\n-    /// `self.rhs`, then generate this call to `format!`:\n-    ///\n-    /// ```ignore (not-usage-example)\n-    /// format!(\"{lhs} == {rhs}\", lhs = self.lhs, rhs = self.rhs)\n-    /// ```\n-    ///\n-    /// This function builds the entire call to `format!`.\n-    fn build_format(&self, input: &str, span: proc_macro2::Span) -> TokenStream {\n-        // This set is used later to generate the final format string. To keep builds reproducible,\n-        // the iteration order needs to be deterministic, hence why we use a `BTreeSet` here\n-        // instead of a `HashSet`.\n-        let mut referenced_fields: BTreeSet<String> = BTreeSet::new();\n-\n-        // At this point, we can start parsing the format string.\n-        let mut it = input.chars().peekable();\n-\n-        // Once the start of a format string has been found, process the format string and spit out\n-        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so\n-        // the next call to `it.next()` retrieves the next character.\n-        while let Some(c) = it.next() {\n-            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n-                let mut eat_argument = || -> Option<String> {\n-                    let mut result = String::new();\n-                    // Format specifiers look like:\n-                    //\n-                    //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n-                    //\n-                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n-                    while let Some(c) = it.next() {\n-                        result.push(c);\n-                        let next = *it.peek().unwrap_or(&'\\0');\n-                        if next == '}' {\n-                            break;\n-                        } else if next == ':' {\n-                            // Eat the ':' character.\n-                            assert_eq!(it.next().unwrap(), ':');\n-                            break;\n-                        }\n-                    }\n-                    // Eat until (and including) the matching '}'\n-                    while it.next()? != '}' {\n-                        continue;\n-                    }\n-                    Some(result)\n-                };\n-\n-                if let Some(referenced_field) = eat_argument() {\n-                    referenced_fields.insert(referenced_field);\n-                }\n-            }\n-        }\n-\n-        // At this point, `referenced_fields` contains a set of the unique fields that were\n-        // referenced in the format string. Generate the corresponding \"x = self.x\" format\n-        // string parameters:\n-        let args = referenced_fields.into_iter().map(|field: String| {\n-            let field_ident = format_ident!(\"{}\", field);\n-            let value = match self.get_field_binding(&field) {\n-                Some(value) => value.clone(),\n-                // This field doesn't exist. Emit a diagnostic.\n-                None => {\n-                    Diagnostic::spanned(\n-                        span.unwrap(),\n-                        Level::Error,\n-                        format!(\"`{}` doesn't refer to a field on this type\", field),\n-                    )\n-                    .emit();\n-                    quote! {\n-                        \"{#field}\"\n-                    }\n-                }\n-            };\n-            quote! {\n-                #field_ident = #value\n-            }\n-        });\n-        quote! {\n-            format!(#input #(,#args)*)\n-        }\n-    }\n-}\n-\n-impl HasFieldMap for SessionDiagnosticDeriveBuilder {\n-    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n-        self.fields.get(field)\n-    }\n-}\n-\n-/// Reports an error if the field's type is not `Applicability`.\n-fn report_error_if_not_applied_to_ty(\n-    attr: &Attribute,\n-    info: &FieldInfo<'_>,\n-    path: &[&str],\n-    ty_name: &str,\n-) -> Result<(), SessionDiagnosticDeriveError> {\n-    if !type_matches_path(&info.ty, path) {\n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_str();\n-        let meta = attr.parse_meta()?;\n-\n-        throw_span_err!(\n-            attr.span().unwrap(),\n-            &format!(\n-                \"the `#[{}{}]` attribute can only be applied to fields of type `{}`\",\n-                name,\n-                match meta {\n-                    Meta::Path(_) => \"\",\n-                    Meta::NameValue(_) => \" = ...\",\n-                    Meta::List(_) => \"(...)\",\n-                },\n-                ty_name\n-            )\n-        );\n-    }\n-\n-    Ok(())\n-}\n-\n-/// Reports an error if the field's type is not `Applicability`.\n-fn report_error_if_not_applied_to_applicability(\n-    attr: &Attribute,\n-    info: &FieldInfo<'_>,\n-) -> Result<(), SessionDiagnosticDeriveError> {\n-    report_error_if_not_applied_to_ty(\n-        attr,\n-        info,\n-        &[\"rustc_errors\", \"Applicability\"],\n-        \"Applicability\",\n-    )\n-}\n-\n-/// Reports an error if the field's type is not `Span`.\n-fn report_error_if_not_applied_to_span(\n-    attr: &Attribute,\n-    info: &FieldInfo<'_>,\n-) -> Result<(), SessionDiagnosticDeriveError> {\n-    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"Span\")\n-}\n-\n-/// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n-fn option_inner_ty(ty: &Type) -> Option<&Type> {\n-    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n-        if let Type::Path(ty_path) = ty {\n-            let path = &ty_path.path;\n-            let ty = path.segments.iter().last().unwrap();\n-            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n-                if bracketed.args.len() == 1 {\n-                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n-                        return Some(ty);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    None\n-}\n-\n-trait SetOnce<T> {\n-    fn set_once(&mut self, value: T);\n-}\n-\n-impl<T> SetOnce<(T, proc_macro::Span)> for Option<(T, proc_macro::Span)> {\n-    fn set_once(&mut self, (value, span): (T, proc_macro::Span)) {\n-        match self {\n-            None => {\n-                *self = Some((value, span));\n-            }\n-            Some((_, prev_span)) => {\n-                span_err(span, \"specified multiple times\")\n-                    .span_note(*prev_span, \"previously specified here\")\n-                    .emit();\n-            }\n-        }\n-    }\n-}\n-\n-enum Applicability {\n-    MachineApplicable,\n-    MaybeIncorrect,\n-    HasPlaceholders,\n-    Unspecified,\n-}\n-\n-impl FromStr for Applicability {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"machine-applicable\" => Ok(Applicability::MachineApplicable),\n-            \"maybe-incorrect\" => Ok(Applicability::MaybeIncorrect),\n-            \"has-placeholders\" => Ok(Applicability::HasPlaceholders),\n-            \"unspecified\" => Ok(Applicability::Unspecified),\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n-impl quote::ToTokens for Applicability {\n-    fn to_tokens(&self, tokens: &mut TokenStream) {\n-        tokens.extend(match self {\n-            Applicability::MachineApplicable => {\n-                quote! { rustc_errors::Applicability::MachineApplicable }\n-            }\n-            Applicability::MaybeIncorrect => {\n-                quote! { rustc_errors::Applicability::MaybeIncorrect }\n-            }\n-            Applicability::HasPlaceholders => {\n-                quote! { rustc_errors::Applicability::HasPlaceholders }\n-            }\n-            Applicability::Unspecified => {\n-                quote! { rustc_errors::Applicability::Unspecified }\n-            }\n-        });\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-enum SubdiagnosticSuggestionKind {\n-    /// `#[suggestion]`\n-    Normal,\n-    /// `#[suggestion_short]`\n-    Short,\n-    /// `#[suggestion_hidden]`\n-    Hidden,\n-    /// `#[suggestion_verbose]`\n-    Verbose,\n-}\n-\n-#[derive(Clone, Copy)]\n-enum SubdiagnosticKind {\n-    /// `#[label]` or `#[label(...)]`\n-    Label,\n-    /// `#[note]` or  `#[note(...)]`\n-    Note,\n-    /// `#[help]` or `#[help(...)]`\n-    Help,\n-    /// `#[suggestion{,_short,_hidden,_verbose}]`\n-    Suggestion(SubdiagnosticSuggestionKind),\n-}\n-\n-impl FromStr for SubdiagnosticKind {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"label\" => Ok(SubdiagnosticKind::Label),\n-            \"note\" => Ok(SubdiagnosticKind::Note),\n-            \"help\" => Ok(SubdiagnosticKind::Help),\n-            \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n-            \"suggestion_short\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n-            }\n-            \"suggestion_hidden\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden))\n-            }\n-            \"suggestion_verbose\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose))\n-            }\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n-impl quote::IdentFragment for SubdiagnosticKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            SubdiagnosticKind::Label => write!(f, \"label\"),\n-            SubdiagnosticKind::Note => write!(f, \"note\"),\n-            SubdiagnosticKind::Help => write!(f, \"help\"),\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n-                write!(f, \"suggestion\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short) => {\n-                write!(f, \"suggestion_short\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden) => {\n-                write!(f, \"suggestion_hidden\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose) => {\n-                write!(f, \"suggestion_verbose\")\n-            }\n-        }\n-    }\n-\n-    fn span(&self) -> Option<proc_macro2::Span> {\n-        None\n-    }\n-}\n-\n-struct SessionSubdiagnosticDerive<'a> {\n-    structure: Structure<'a>,\n-    diag: syn::Ident,\n-}\n-\n-struct SessionSubdiagnosticDeriveBuilder<'a> {\n-    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n-    diag: &'a syn::Ident,\n-\n-    /// Info for the current variant (or the type if not an enum).\n-    variant: &'a VariantInfo<'a>,\n-    /// Span for the entire type.\n-    span: proc_macro::Span,\n-\n-    /// Store a map of field name to its corresponding field. This is built on construction of the\n-    /// derive builder.\n-    fields: HashMap<String, TokenStream>,\n-\n-    /// Subdiagnostic kind of the type/variant.\n-    kind: Option<(SubdiagnosticKind, proc_macro::Span)>,\n-\n-    /// Slug of the subdiagnostic - corresponds to the Fluent identifier for the message - from the\n-    /// `#[kind(slug = \"...\")]` attribute on the type or variant.\n-    slug: Option<(String, proc_macro::Span)>,\n-    /// If a suggestion, the code to suggest as a replacement - from the `#[kind(code = \"...\")]`\n-    /// attribute on the type or variant.\n-    code: Option<(proc_macro2::TokenStream, proc_macro::Span)>,\n-\n-    /// Identifier for the binding to the `#[primary_span]` field.\n-    span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n-    /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n-    /// `rustc_errors::Applicability::*` variant directly.\n-    applicability: Option<(proc_macro2::TokenStream, proc_macro::Span)>,\n-}\n-\n-impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n-    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n-        self.fields.get(field)\n-    }\n-}\n-\n-impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n-    fn identify_kind(&mut self) -> Result<(), SessionDiagnosticDeriveError> {\n-        for attr in self.variant.ast().attrs {\n-            let span = attr.span().unwrap();\n-\n-            let name = attr.path.segments.last().unwrap().ident.to_string();\n-            let name = name.as_str();\n-\n-            let meta = attr.parse_meta()?;\n-            let kind = match meta {\n-                Meta::Path(_) => throw_span_err!(\n-                    span,\n-                    &format!(\"`#[{}]` is not a valid `SessionSubdiagnostic` attribute\", name)\n-                ),\n-                Meta::NameValue(_) => throw_span_err!(\n-                    span,\n-                    &format!(\"`#[{} = ...]` is not a valid `SessionSubdiagnostic` attribute\", name)\n-                ),\n-                Meta::List(MetaList { nested, .. }) => {\n-                    for attr in nested {\n-                        let meta = match attr {\n-                            syn::NestedMeta::Meta(meta) => meta,\n-                            syn::NestedMeta::Lit(_) => throw_span_err!(\n-                                span,\n-                                &format!(\n-                                    \"`#[{}(\\\"...\\\")]` is not a valid `SessionSubdiagnostic` attribute\",\n-                                    name\n-                                )\n-                            ),\n-                        };\n-\n-                        let span = meta.span().unwrap();\n-                        let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                        let nested_name = nested_name.as_str();\n-\n-                        match meta {\n-                            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                                match nested_name {\n-                                    \"code\" => {\n-                                        let formatted_str = self.build_format(&s.value(), s.span());\n-                                        self.code.set_once((formatted_str, span));\n-                                    }\n-                                    \"slug\" => self.slug.set_once((s.value(), span)),\n-                                    \"applicability\" => {\n-                                        let value = match Applicability::from_str(&s.value()) {\n-                                            Ok(v) => v,\n-                                            Err(()) => {\n-                                                span_err(span, \"invalid applicability\").emit();\n-                                                Applicability::Unspecified\n-                                            }\n-                                        };\n-                                        self.applicability.set_once((quote! { #value }, span));\n-                                    }\n-                                    other => throw_span_err!(\n-                                        span,\n-                                        &format!(\n-                                            \"`#[{}({} = ...)]` is not a valid `SessionSubdiagnostic` attribute\",\n-                                            name, other\n-                                        )\n-                                    ),\n-                                }\n-                            }\n-                            Meta::NameValue(..) => throw_span_err!(\n-                                span,\n-                                &format!(\n-                                    \"`#[{}({} = ...)]` is not a valid `SessionSubdiagnostic` attribute\",\n-                                    name, nested_name\n-                                ),\n-                                |diag| diag.help(\"value must be a string\")\n-                            ),\n-                            Meta::Path(..) => throw_span_err!(\n-                                span,\n-                                &format!(\n-                                    \"`#[{}({})]` is not a valid `SessionSubdiagnostic` attribute\",\n-                                    name, nested_name\n-                                )\n-                            ),\n-                            Meta::List(..) => throw_span_err!(\n-                                span,\n-                                &format!(\n-                                    \"`#[{}({}(...))]` is not a valid `SessionSubdiagnostic` attribute\",\n-                                    name, nested_name\n-                                )\n-                            ),\n-                        }\n-                    }\n-\n-                    let Ok(kind) = SubdiagnosticKind::from_str(name) else {\n-                        throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}(...)]` is not a valid `SessionSubdiagnostic` attribute\",\n-                                name\n-                            )\n-                        );\n-                    };\n-                    kind\n-                }\n-            };\n-\n-            if matches!(\n-                kind,\n-                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n-            ) && self.code.is_some()\n-            {\n-                throw_span_err!(\n-                    span,\n-                    &format!(\"`code` is not a valid nested attribute of a `{}` attribute\", name)\n-                );\n-            }\n-\n-            if self.slug.is_none() {\n-                throw_span_err!(\n-                    span,\n-                    &format!(\"`slug` must be set in a `#[{}(...)]` attribute\", name)\n-                );\n-            }\n-\n-            self.kind.set_once((kind, span));\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn generate_field_code(\n-        &mut self,\n-        binding: &BindingInfo<'_>,\n-        is_suggestion: bool,\n-    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        let ast = binding.ast();\n-\n-        let option_ty = option_inner_ty(&ast.ty);\n-        let info = FieldInfo {\n-            vis: &ast.vis,\n-            binding: binding,\n-            ty: option_ty.unwrap_or(&ast.ty),\n-            span: &ast.span(),\n-        };\n-\n-        for attr in &ast.attrs {\n-            let name = attr.path.segments.last().unwrap().ident.to_string();\n-            let name = name.as_str();\n-            let span = attr.span().unwrap();\n-\n-            let meta = attr.parse_meta()?;\n-            match meta {\n-                Meta::Path(_) => match name {\n-                    \"primary_span\" => {\n-                        report_error_if_not_applied_to_span(attr, &info)?;\n-                        self.span_field.set_once((binding.binding.clone(), span));\n-                        return Ok(quote! {});\n-                    }\n-                    \"applicability\" if is_suggestion => {\n-                        report_error_if_not_applied_to_applicability(attr, &info)?;\n-                        let binding = binding.binding.clone();\n-                        self.applicability.set_once((quote! { #binding }, span));\n-                        return Ok(quote! {});\n-                    }\n-                    \"applicability\" => {\n-                        span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n-                        return Ok(quote! {});\n-                    }\n-                    \"skip_arg\" => {\n-                        return Ok(quote! {});\n-                    }\n-                    other => span_err(\n-                        span,\n-                        &format!(\n-                            \"`#[{}]` is not a valid `SessionSubdiagnostic` field attribute\",\n-                            other\n-                        ),\n-                    )\n-                    .emit(),\n-                },\n-                Meta::NameValue(_) => span_err(\n-                    span,\n-                    &format!(\n-                        \"`#[{} = ...]` is not a valid `SessionSubdiagnostic` field attribute\",\n-                        name\n-                    ),\n-                )\n-                .emit(),\n-                Meta::List(_) => span_err(\n-                    span,\n-                    &format!(\n-                        \"`#[{}(...)]` is not a valid `SessionSubdiagnostic` field attribute\",\n-                        name\n-                    ),\n-                )\n-                .emit(),\n-            }\n-        }\n-\n-        let ident = ast.ident.as_ref().unwrap();\n-\n-        let diag = &self.diag;\n-        let generated = quote! {\n-            #diag.set_arg(\n-                stringify!(#ident),\n-                #binding.into_diagnostic_arg()\n-            );\n-        };\n-\n-        if option_ty.is_none() {\n-            Ok(quote! { #generated })\n-        } else {\n-            Ok(quote! {\n-                if let Some(#binding) = #binding {\n-                    #generated\n-                }\n-            })\n-        }\n-    }\n-\n-    fn into_tokens(&mut self) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n-        self.identify_kind()?;\n-        let Some(kind) = self.kind.map(|(kind, _)| kind) else {\n-            throw_span_err!(\n-                self.variant.ast().ident.span().unwrap(),\n-                \"subdiagnostic kind not specified\"\n-            );\n-        };\n-\n-        let is_suggestion = matches!(kind, SubdiagnosticKind::Suggestion(_));\n-\n-        let mut args = TokenStream::new();\n-        for binding in self.variant.bindings() {\n-            let arg = self\n-                .generate_field_code(binding, is_suggestion)\n-                .unwrap_or_else(|v| v.to_compile_error());\n-            args.extend(arg);\n-        }\n-\n-        // Missing slug errors will already have been reported.\n-        let slug = self.slug.as_ref().map(|(slug, _)| &**slug).unwrap_or(\"missing-slug\");\n-        let code = match self.code.as_ref() {\n-            Some((code, _)) => Some(quote! { #code }),\n-            None if is_suggestion => {\n-                span_err(self.span, \"suggestion without `code = \\\"...\\\"`\").emit();\n-                Some(quote! { /* macro error */ \"...\" })\n-            }\n-            None => None,\n-        };\n-\n-        let span_field = self.span_field.as_ref().map(|(span, _)| span);\n-        let applicability = match self.applicability.clone() {\n-            Some((applicability, _)) => Some(applicability),\n-            None if is_suggestion => {\n-                span_err(self.span, \"suggestion without `applicability`\").emit();\n-                Some(quote! { rustc_errors::Applicability::Unspecified })\n-            }\n-            None => None,\n-        };\n-\n-        let diag = &self.diag;\n-        let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n-        let message = quote! { rustc_errors::DiagnosticMessage::fluent(#slug) };\n-        let call = if matches!(kind, SubdiagnosticKind::Suggestion(..)) {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message, #code, #applicability); }\n-            } else {\n-                span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n-                quote! { unreachable!(); }\n-            }\n-        } else if matches!(kind, SubdiagnosticKind::Label) {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message); }\n-            } else {\n-                span_err(self.span, \"label without `#[primary_span]` field\").emit();\n-                quote! { unreachable!(); }\n-            }\n-        } else {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message); }\n-            } else {\n-                quote! { #diag.#name(#message); }\n-            }\n-        };\n-\n-        Ok(quote! {\n-            #call\n-            #args\n-        })\n-    }\n-}\n-\n-impl<'a> SessionSubdiagnosticDerive<'a> {\n-    fn new(structure: Structure<'a>) -> Self {\n-        let diag = format_ident!(\"diag\");\n-        Self { structure, diag }\n-    }\n-\n-    fn into_tokens(self) -> TokenStream {\n-        let SessionSubdiagnosticDerive { mut structure, diag } = self;\n-        let implementation = {\n-            let ast = structure.ast();\n-            let span = ast.span().unwrap();\n-            match ast.data {\n-                syn::Data::Struct(..) | syn::Data::Enum(..) => (),\n-                syn::Data::Union(..) => {\n-                    span_err(\n-                        span,\n-                        \"`#[derive(SessionSubdiagnostic)]` can only be used on structs and enums\",\n-                    );\n-                }\n-            }\n-\n-            if matches!(ast.data, syn::Data::Enum(..)) {\n-                for attr in &ast.attrs {\n-                    span_err(\n-                        attr.span().unwrap(),\n-                        \"unsupported type attribute for subdiagnostic enum\",\n-                    )\n-                    .emit();\n-                }\n-            }\n-\n-            structure.bind_with(|_| synstructure::BindStyle::Move);\n-            let variants_ = structure.each_variant(|variant| {\n-                // Build the mapping of field names to fields. This allows attributes to peek\n-                // values from other fields.\n-                let mut fields_map = HashMap::new();\n-                for binding in variant.bindings() {\n-                    let field = binding.ast();\n-                    if let Some(ident) = &field.ident {\n-                        fields_map.insert(ident.to_string(), quote! { #binding });\n-                    }\n-                }\n-\n-                let mut builder = SessionSubdiagnosticDeriveBuilder {\n-                    diag: &diag,\n-                    variant,\n-                    span,\n-                    fields: fields_map,\n-                    kind: None,\n-                    slug: None,\n-                    code: None,\n-                    span_field: None,\n-                    applicability: None,\n-                };\n-                builder.into_tokens().unwrap_or_else(|v| v.to_compile_error())\n-            });\n-\n-            quote! {\n-                match self {\n-                    #variants_\n-                }\n-            }\n-        };\n-\n-        let ret = structure.gen_impl(quote! {\n-            gen impl rustc_errors::AddSubdiagnostic for @Self {\n-                fn add_to_diagnostic(self, #diag: &mut rustc_errors::Diagnostic) {\n-                    use rustc_errors::{Applicability, IntoDiagnosticArg};\n-                    #implementation\n-                }\n-            }\n-        });\n-        ret\n-    }\n-}"}]}