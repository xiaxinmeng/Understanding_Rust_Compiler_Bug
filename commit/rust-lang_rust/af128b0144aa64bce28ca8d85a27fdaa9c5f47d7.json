{"sha": "af128b0144aa64bce28ca8d85a27fdaa9c5f47d7", "node_id": "C_kwDOAAsO6NoAKGFmMTI4YjAxNDRhYTY0YmNlMjhjYThkODVhMjdmZGFhOWM1ZjQ3ZDc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-22T20:29:25Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-13T17:18:24Z"}, "message": "Also compute implicit params in THIR.", "tree": {"sha": "fb29bda2cccfa339c260a7a77f03125d157f8254", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb29bda2cccfa339c260a7a77f03125d157f8254"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7", "html_url": "https://github.com/rust-lang/rust/commit/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "445841cda32cf9fb95528cfe8d126d0a0e0cb608", "url": "https://api.github.com/repos/rust-lang/rust/commits/445841cda32cf9fb95528cfe8d126d0a0e0cb608", "html_url": "https://github.com/rust-lang/rust/commit/445841cda32cf9fb95528cfe8d126d0a0e0cb608"}], "stats": {"total": 182, "additions": 98, "deletions": 84}, "files": [{"sha": "165b9103968d04cc9d6d1375ff28ed0062cc3ec4", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=af128b0144aa64bce28ca8d85a27fdaa9c5f47d7", "patch": "@@ -73,6 +73,8 @@ macro_rules! thir_with_elements {\n     }\n }\n \n+pub const UPVAR_ENV_PARAM: ParamId = ParamId::from_u32(0);\n+\n thir_with_elements! {\n     arms: ArmId => Arm<'tcx> => \"a{}\",\n     blocks: BlockId => Block => \"b{}\",\n@@ -84,16 +86,16 @@ thir_with_elements! {\n /// Description of a type-checked function parameter.\n #[derive(Clone, Debug, HashStable)]\n pub struct Param<'tcx> {\n-    /// The pattern that appears in the parameter list.\n-    pub pat: Box<Pat<'tcx>>,\n+    /// The pattern that appears in the parameter list, or None for implicit parameters.\n+    pub pat: Option<Box<Pat<'tcx>>>,\n     /// The possibly inferred type.\n     pub ty: Ty<'tcx>,\n     /// Span of the explicitly provided type, or None if inferred for closures.\n     pub ty_span: Option<Span>,\n     /// Whether this param is `self`, and how it is bound.\n     pub self_kind: Option<hir::ImplicitSelfKind>,\n     /// HirId for lints.\n-    pub hir_id: hir::HirId,\n+    pub hir_id: Option<hir::HirId>,\n }\n \n #[derive(Copy, Clone, Debug, HashStable)]"}, {"sha": "25c4e51cb9255c6d256058140b93000e2b912f79", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 35, "deletions": 79, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=af128b0144aa64bce28ca8d85a27fdaa9c5f47d7", "patch": "@@ -7,16 +7,19 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::{GeneratorKind, ImplicitSelfKind, Node};\n+use rustc_hir::{GeneratorKind, Node};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::*;\n-use rustc_middle::thir::{BindingMode, Expr, ExprId, LintLevel, LocalVarId, Param, PatKind, Thir};\n+use rustc_middle::thir::{\n+    self, BindingMode, Expr, ExprId, LintLevel, LocalVarId, Param, ParamId, PatKind, Thir,\n+};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable, TypeckResults};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -97,26 +100,6 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-fn liberated_closure_env_ty(\n-    tcx: TyCtxt<'_>,\n-    closure_expr_id: hir::HirId,\n-    body_id: hir::BodyId,\n-) -> Ty<'_> {\n-    let closure_ty = tcx.typeck_body(body_id).node_type(closure_expr_id);\n-\n-    let ty::Closure(closure_def_id, closure_substs) = *closure_ty.kind() else {\n-        bug!(\"closure expr does not have closure type: {:?}\", closure_ty);\n-    };\n-\n-    let bound_vars =\n-        tcx.mk_bound_variable_kinds(std::iter::once(ty::BoundVariableKind::Region(ty::BrEnv)));\n-    let br =\n-        ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind: ty::BrEnv };\n-    let env_region = ty::ReLateBound(ty::INNERMOST, br);\n-    let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs, env_region).unwrap();\n-    tcx.erase_late_bound_regions(ty::Binder::bind_with_vars(closure_env_ty, bound_vars))\n-}\n-\n #[derive(Debug, PartialEq, Eq)]\n enum BlockFrame {\n     /// Evaluation is currently within a statement.\n@@ -446,13 +429,6 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'thir, 'tcx>(\n-    Ty<'tcx>,\n-    Option<Span>,\n-    Option<&'thir Param<'tcx>>,\n-    Option<ImplicitSelfKind>,\n-);\n-\n fn construct_fn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fn_def: ty::WithOptConstParam<LocalDefId>,\n@@ -483,50 +459,28 @@ fn construct_fn<'tcx>(\n         hir::Unsafety::Unsafe => Safety::FnUnsafe,\n     };\n \n-    let body = tcx.hir().body(body_id);\n-    let ty = tcx.type_of(fn_def.did);\n     let mut abi = fn_sig.abi;\n-    let implicit_argument = match ty.kind() {\n-        ty::Closure(..) => {\n-            // HACK(eddyb) Avoid having RustCall on closures,\n-            // as it adds unnecessary (and wrong) auto-tupling.\n-            abi = Abi::Rust;\n-            vec![ArgInfo(liberated_closure_env_ty(tcx, fn_id, body_id), None, None, None)]\n-        }\n-        ty::Generator(..) => {\n-            let gen_ty = typeck_results.node_type(fn_id);\n-\n-            // The resume argument may be missing, in that case we need to provide it here.\n-            // It will always be `()` in this case.\n-            if body.params.is_empty() {\n-                vec![ArgInfo(gen_ty, None, None, None), ArgInfo(tcx.mk_unit(), None, None, None)]\n-            } else {\n-                vec![ArgInfo(gen_ty, None, None, None)]\n-            }\n-        }\n-        _ => vec![],\n-    };\n-\n-    let explicit_arguments =\n-        thir.params.iter().map(|arg| ArgInfo(arg.ty, arg.ty_span, Some(&arg), arg.self_kind));\n+    if let DefKind::Closure = tcx.def_kind(fn_def.did) {\n+        // HACK(eddyb) Avoid having RustCall on closures,\n+        // as it adds unnecessary (and wrong) auto-tupling.\n+        abi = Abi::Rust;\n+    }\n \n-    let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+    let arguments = &thir.params;\n \n     let (yield_ty, return_ty) = if generator_kind.is_some() {\n-        let gen_ty = typeck_results.node_type(fn_id);\n+        let gen_ty = arguments[thir::UPVAR_ENV_PARAM].ty;\n         let gen_sig = match gen_ty.kind() {\n             ty::Generator(_, gen_substs, ..) => gen_substs.as_generator().sig(),\n             _ => {\n-                span_bug!(span, \"generator w/o generator type: {:?}\", ty)\n+                span_bug!(span, \"generator w/o generator type: {:?}\", gen_ty)\n             }\n         };\n         (Some(gen_sig.yield_ty), gen_sig.return_ty)\n     } else {\n         (None, fn_sig.output())\n     };\n \n-    let arguments: Vec<_> = arguments.collect();\n-\n     let mut body = tcx.infer_ctxt().enter(|infcx| {\n         let mut builder = Builder::new(\n             thir,\n@@ -542,9 +496,9 @@ fn construct_fn<'tcx>(\n         );\n \n         let call_site_scope =\n-            region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::CallSite };\n+            region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::CallSite };\n         let arg_scope =\n-            region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::Arguments };\n+            region::Scope { id: body_id.hir_id.local_id, data: region::ScopeData::Arguments };\n         let source_info = builder.source_info(span);\n         let call_site_s = (call_site_scope, source_info);\n         unpack!(builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n@@ -560,7 +514,7 @@ fn construct_fn<'tcx>(\n                         builder.args_and_body(\n                             START_BLOCK,\n                             fn_def.did,\n-                            &arguments,\n+                            arguments,\n                             arg_scope,\n                             &thir[expr],\n                         )\n@@ -819,18 +773,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         mut block: BasicBlock,\n         fn_def_id: LocalDefId,\n-        arguments: &[ArgInfo<'_, 'tcx>],\n+        arguments: &IndexVec<ParamId, Param<'tcx>>,\n         argument_scope: region::Scope,\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n         // Allocate locals for the function arguments\n-        for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n+        for param in arguments.iter() {\n             let source_info =\n-                SourceInfo::outermost(arg_opt.map_or(self.fn_span, |arg| arg.pat.span));\n-            let arg_local = self.local_decls.push(LocalDecl::with_source_info(ty, source_info));\n+                SourceInfo::outermost(param.pat.as_ref().map_or(self.fn_span, |pat| pat.span));\n+            let arg_local =\n+                self.local_decls.push(LocalDecl::with_source_info(param.ty, source_info));\n \n             // If this is a simple binding pattern, give debuginfo a nice name.\n-            if let Some(arg) = arg_opt && let Some(name) = arg.pat.simple_ident() {\n+            if let Some(ref pat) = param.pat && let Some(name) = pat.simple_ident() {\n                 self.var_debug_info.push(VarDebugInfo {\n                     name,\n                     source_info,\n@@ -905,27 +860,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let mut scope = None;\n         // Bind the argument patterns\n-        for (index, arg_info) in arguments.iter().enumerate() {\n+        for (index, param) in arguments.iter().enumerate() {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n             let place = Place::from(local);\n-            let &ArgInfo(_, opt_ty_info, arg_opt, ref self_binding) = arg_info;\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n-                arg_opt.as_ref().map_or(expr.span, |arg| arg.pat.span),\n+                param.pat.as_ref().map_or(expr.span, |pat| pat.span),\n                 argument_scope,\n                 local,\n                 DropKind::Value,\n             );\n \n-            let Some(arg) = arg_opt else {\n+            let Some(ref pat) = param.pat else {\n                 continue;\n             };\n             let original_source_scope = self.source_scope;\n-            let span = arg.pat.span;\n-            self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n-            match arg.pat.kind {\n+            let span = pat.span;\n+            if let Some(arg_hir_id) = param.hir_id {\n+                self.set_correct_source_scope_for_arg(arg_hir_id, original_source_scope, span);\n+            }\n+            match pat.kind {\n                 // Don't introduce extra copies for simple bindings\n                 PatKind::Binding {\n                     mutability,\n@@ -936,16 +892,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 } => {\n                     self.local_decls[local].mutability = mutability;\n                     self.local_decls[local].source_info.scope = self.source_scope;\n-                    self.local_decls[local].local_info = if let Some(kind) = self_binding {\n+                    self.local_decls[local].local_info = if let Some(kind) = param.self_kind {\n                         Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(\n-                            BindingForm::ImplicitSelf(*kind),\n+                            BindingForm::ImplicitSelf(kind),\n                         ))))\n                     } else {\n                         let binding_mode = ty::BindingMode::BindByValue(mutability);\n                         Some(Box::new(LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                             VarBindingForm {\n                                 binding_mode,\n-                                opt_ty_info,\n+                                opt_ty_info: param.ty_span,\n                                 opt_match_place: Some((None, span)),\n                                 pat_span: span,\n                             },\n@@ -957,12 +913,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     scope = self.declare_bindings(\n                         scope,\n                         expr.span,\n-                        &arg.pat,\n+                        &pat,\n                         matches::ArmHasGuard(false),\n                         Some((Some(&place), span)),\n                     );\n                     let place_builder = PlaceBuilder::from(local);\n-                    unpack!(block = self.place_into_pattern(block, &arg.pat, place_builder, false));\n+                    unpack!(block = self.place_into_pattern(block, &pat, place_builder, false));\n                 }\n             }\n             self.source_scope = original_source_scope;"}, {"sha": "7bab560b369771ad3bf4df434893e3e5be729e71", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af128b0144aa64bce28ca8d85a27fdaa9c5f47d7/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=af128b0144aa64bce28ca8d85a27fdaa9c5f47d7", "patch": "@@ -8,6 +8,7 @@ use crate::thir::util::UserAnnotatedTyHelpers;\n use rustc_data_structures::steal::Steal;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::HirId;\n@@ -31,8 +32,21 @@ pub(crate) fn thir_body<'tcx>(\n \n     let owner_id = hir.local_def_id_to_hir_id(owner_def.did);\n     if let Some(ref fn_decl) = hir.fn_decl_by_hir_id(owner_id) {\n+        let closure_env_param = cx.closure_env_param(owner_def.did, owner_id);\n         let explicit_params = cx.explicit_params(owner_id, fn_decl, body);\n-        cx.thir.params = explicit_params.collect();\n+        cx.thir.params = closure_env_param.into_iter().chain(explicit_params).collect();\n+\n+        // The resume argument may be missing, in that case we need to provide it here.\n+        // It will always be `()` in this case.\n+        if tcx.def_kind(owner_def.did) == DefKind::Generator && body.params.is_empty() {\n+            cx.thir.params.push(Param {\n+                ty: tcx.mk_unit(),\n+                pat: None,\n+                ty_span: None,\n+                self_kind: None,\n+                hir_id: None,\n+            });\n+        }\n     }\n \n     Ok((tcx.alloc_steal_thir(cx.thir), expr))\n@@ -94,6 +108,48 @@ impl<'tcx> Cx<'tcx> {\n         pat_from_hir(self.tcx, self.param_env, self.typeck_results(), p)\n     }\n \n+    fn closure_env_param(&self, owner_def: LocalDefId, owner_id: HirId) -> Option<Param<'tcx>> {\n+        match self.tcx.def_kind(owner_def) {\n+            DefKind::Closure => {\n+                let closure_ty = self.typeck_results.node_type(owner_id);\n+\n+                let ty::Closure(closure_def_id, closure_substs) = *closure_ty.kind() else {\n+                    bug!(\"closure expr does not have closure type: {:?}\", closure_ty);\n+                };\n+\n+                let bound_vars = self.tcx.mk_bound_variable_kinds(std::iter::once(\n+                    ty::BoundVariableKind::Region(ty::BrEnv),\n+                ));\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BrEnv,\n+                };\n+                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let closure_env_ty =\n+                    self.tcx.closure_env_ty(closure_def_id, closure_substs, env_region).unwrap();\n+                let liberated_closure_env_ty = self.tcx.erase_late_bound_regions(\n+                    ty::Binder::bind_with_vars(closure_env_ty, bound_vars),\n+                );\n+                let env_param = Param {\n+                    ty: liberated_closure_env_ty,\n+                    pat: None,\n+                    ty_span: None,\n+                    self_kind: None,\n+                    hir_id: None,\n+                };\n+\n+                Some(env_param)\n+            }\n+            DefKind::Generator => {\n+                let gen_ty = self.typeck_results.node_type(owner_id);\n+                let gen_param =\n+                    Param { ty: gen_ty, pat: None, ty_span: None, self_kind: None, hir_id: None };\n+                Some(gen_param)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     fn explicit_params<'a>(\n         &'a mut self,\n         owner_id: HirId,\n@@ -128,7 +184,7 @@ impl<'tcx> Cx<'tcx> {\n             };\n \n             let pat = self.pattern_from_hir(param.pat);\n-            Param { pat, ty, ty_span, self_kind, hir_id: param.hir_id }\n+            Param { pat: Some(pat), ty, ty_span, self_kind, hir_id: Some(param.hir_id) }\n         })\n     }\n }"}]}