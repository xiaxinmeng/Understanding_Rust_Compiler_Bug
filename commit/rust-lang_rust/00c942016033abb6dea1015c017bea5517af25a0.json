{"sha": "00c942016033abb6dea1015c017bea5517af25a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYzk0MjAxNjAzM2FiYjZkZWExMDE1YzAxN2JlYTU1MTdhZjI1YTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-17T08:23:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-18T20:38:29Z"}, "message": "rename unify to unify_and_identity", "tree": {"sha": "ba2948a7a6d62af077fa396496a7e7e4b87eae1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba2948a7a6d62af077fa396496a7e7e4b87eae1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00c942016033abb6dea1015c017bea5517af25a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00c942016033abb6dea1015c017bea5517af25a0", "html_url": "https://github.com/rust-lang/rust/commit/00c942016033abb6dea1015c017bea5517af25a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00c942016033abb6dea1015c017bea5517af25a0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1922041e7f69407e7fa40bf90e8ec47d49a97fd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1922041e7f69407e7fa40bf90e8ec47d49a97fd2", "html_url": "https://github.com/rust-lang/rust/commit/1922041e7f69407e7fa40bf90e8ec47d49a97fd2"}], "stats": {"total": 20, "additions": 10, "deletions": 10}, "files": [{"sha": "bd5ed0c32d61affb4dd5d55d4e015825fb5363a9", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/00c942016033abb6dea1015c017bea5517af25a0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00c942016033abb6dea1015c017bea5517af25a0/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=00c942016033abb6dea1015c017bea5517af25a0", "patch": "@@ -113,7 +113,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     /// Unify two types (using sub or lub) and produce a noop coercion.\n-    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+    fn unify_and_identity(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         let infcx = self.fcx.infcx();\n         infcx.commit_if_ok(|_| {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n@@ -187,7 +187,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.unify(a, b)\n+                self.unify_and_identity(a, b)\n             }\n         }\n     }\n@@ -219,7 +219,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n                 (r_a, mt_a.mutbl)\n             }\n-            _ => return self.unify(a, b)\n+            _ => return self.unify_and_identity(a, b)\n         };\n \n         let span = self.origin.span();\n@@ -251,7 +251,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             let ty = self.tcx().mk_ref(r_borrow,\n                                         TypeAndMut {ty: inner_ty, mutbl: mutbl_b});\n-            match self.unify(ty, b) {\n+            match self.unify_and_identity(ty, b) {\n                 Err(err) => {\n                     if first_error.is_none() {\n                         first_error = Some(err);\n@@ -404,14 +404,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify(unsafe_a, b).map(|(ty, _)| {\n+                    return self.unify_and_identity(unsafe_a, b).map(|(ty, _)| {\n                         (ty, AdjustUnsafeFnPointer)\n                     });\n                 }\n                 _ => {}\n             }\n         }\n-        self.unify(a, b)\n+        self.unify_and_identity(a, b)\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -430,11 +430,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         match b.sty {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx().mk_ty(ty::TyFnPtr(fn_ty_a));\n-                self.unify(a_fn_pointer, b).map(|(ty, _)| {\n+                self.unify_and_identity(a_fn_pointer, b).map(|(ty, _)| {\n                     (ty, AdjustReifyFnPointer)\n                 })\n             }\n-            _ => self.unify(a, b)\n+            _ => self.unify_and_identity(a, b)\n         }\n     }\n \n@@ -451,13 +451,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.unify(a, b);\n+                return self.unify_and_identity(a, b);\n             }\n         };\n \n         // Check that the types which they point at are compatible.\n         let a_unsafe = self.tcx().mk_ptr(ty::TypeAndMut{ mutbl: mutbl_b, ty: mt_a.ty });\n-        let (ty, noop) = try!(self.unify(a_unsafe, b));\n+        let (ty, noop) = try!(self.unify_and_identity(a_unsafe, b));\n         try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n \n         // Although references and unsafe ptrs have the same"}]}