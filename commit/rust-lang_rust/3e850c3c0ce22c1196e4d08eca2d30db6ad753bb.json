{"sha": "3e850c3c0ce22c1196e4d08eca2d30db6ad753bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlODUwYzNjMGNlMjJjMTE5NmU0ZDA4ZWNhMmQzMGRiNmFkNzUzYmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-13T23:43:54Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-13T23:46:39Z"}, "message": "librustc: Stop reexporting all of core in every crate. rs=really-bad-bug", "tree": {"sha": "1e648147f0bbd3efa4ab2a9b0c7da7aa873b66ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e648147f0bbd3efa4ab2a9b0c7da7aa873b66ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e850c3c0ce22c1196e4d08eca2d30db6ad753bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e850c3c0ce22c1196e4d08eca2d30db6ad753bb", "html_url": "https://github.com/rust-lang/rust/commit/3e850c3c0ce22c1196e4d08eca2d30db6ad753bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e850c3c0ce22c1196e4d08eca2d30db6ad753bb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4e107e6c76701047bd16840dae9023e92a42fdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4e107e6c76701047bd16840dae9023e92a42fdc", "html_url": "https://github.com/rust-lang/rust/commit/f4e107e6c76701047bd16840dae9023e92a42fdc"}], "stats": {"total": 39, "additions": 24, "deletions": 15}, "files": [{"sha": "7668d317d813d6eb5b674993645b5503a912c267", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e850c3c0ce22c1196e4d08eca2d30db6ad753bb/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e850c3c0ce22c1196e4d08eca2d30db6ad753bb/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=3e850c3c0ce22c1196e4d08eca2d30db6ad753bb", "patch": "@@ -32,14 +32,14 @@ fn inject_libcore_ref(sess: Session,\n \n     let vi1 = @{node: ast::view_item_use(sess.ident_of(~\"core\"), ~[], n1),\n                 attrs: ~[],\n-                vis: ast::public,\n+                vis: ast::private,\n                 span: dummy_sp()};\n     let vp = spanned(ast::view_path_glob(\n         ident_to_path(dummy_sp(), sess.ident_of(~\"core\")),\n         n2));\n     let vi2 = @{node: ast::view_item_import(~[vp]),\n                 attrs: ~[],\n-                vis: ast::public,\n+                vis: ast::private,\n                 span: dummy_sp()};\n \n     let vis = vec::append(~[vi1, vi2], crate.node.module.view_items);"}, {"sha": "82a26d23902d0e40bf1c5ce59be637267d879af7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3e850c3c0ce22c1196e4d08eca2d30db6ad753bb/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e850c3c0ce22c1196e4d08eca2d30db6ad753bb/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3e850c3c0ce22c1196e4d08eca2d30db6ad753bb", "patch": "@@ -1691,7 +1691,7 @@ impl Resolver {\n                     // avoid creating cycles in the\n                     // module graph.\n \n-                    let resolution = @ImportResolution(Public, dummy_sp());\n+                    let resolution = @ImportResolution(Private, dummy_sp());\n                     resolution.outstanding_references = 0;\n \n                     match existing_module.parent_link {\n@@ -2159,7 +2159,8 @@ impl Resolver {\n                             let span = import_directive.span;\n                             let p = import_directive.privacy;\n                             resolution_result =\n-                                self.resolve_glob_import(p, module_,\n+                                self.resolve_glob_import(p,\n+                                                         module_,\n                                                          containing_module,\n                                                          span);\n                         }\n@@ -2284,7 +2285,6 @@ impl Resolver {\n                         fn get_binding(import_resolution: @ImportResolution,\n                                        namespace: Namespace)\n                                     -> NamespaceResult {\n-\n                             // Import resolutions must be declared with \"pub\"\n                             // in order to be exported.\n                             if import_resolution.privacy == Private {\n@@ -2506,14 +2506,13 @@ impl Resolver {\n                            containing_module: @Module,\n                            span: span)\n                         -> ResolveResult<()> {\n-\n         // This function works in a highly imperative manner; it eagerly adds\n         // everything it can to the list of import resolutions of the module\n         // node.\n+        debug!(\"(resolving glob import) resolving %? glob import\", privacy);\n \n         // We must bail out if the node has unresolved imports of any kind\n         // (including globs).\n-\n         if !(*containing_module).all_imports_resolved() {\n             debug!(\"(resolving glob import) target module has unresolved \\\n                     imports; bailing out\");\n@@ -2590,8 +2589,7 @@ impl Resolver {\n             match module_.import_resolutions.find(ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n-                    dest_import_resolution = @ImportResolution(privacy,\n-                                                               span);\n+                    dest_import_resolution = @ImportResolution(privacy, span);\n                     module_.import_resolutions.insert\n                         (ident, dest_import_resolution);\n                 }\n@@ -2602,10 +2600,11 @@ impl Resolver {\n \n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n-                    to `%s`\",\n+                    to `%s`, privacy=%?\",\n                    self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n-                   self.module_to_str(module_));\n+                   self.module_to_str(module_),\n+                   dest_import_resolution.privacy);\n \n             // Merge the child item into the import resolution.\n             if (*name_bindings).defined_in_namespace(ValueNS) {\n@@ -3142,14 +3141,18 @@ impl Resolver {\n \n     fn record_exports_for_module_subtree(module_: @Module) {\n         // If this isn't a local crate, then bail out. We don't need to record\n-        // exports for local crates.\n+        // exports for nonlocal crates.\n \n         match module_.def_id {\n             Some(def_id) if def_id.crate == local_crate => {\n                 // OK. Continue.\n+                debug!(\"(recording exports for module subtree) recording \\\n+                        exports for local module\");\n             }\n             None => {\n                 // Record exports for the root module.\n+                debug!(\"(recording exports for module subtree) recording \\\n+                        exports for root module\");\n             }\n             Some(_) => {\n                 // Bail out.\n@@ -3222,15 +3225,21 @@ impl Resolver {\n     }\n \n     fn add_exports_for_module(exports2: &mut ~[Export2], module_: @Module) {\n-\n         for module_.children.each_ref |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    self.session.str_of(*ident));\n-            self.add_exports_of_namebindings(exports2, *ident,\n-                                             *namebindings, false)\n+            self.add_exports_of_namebindings(exports2,\n+                                             *ident,\n+                                             *namebindings,\n+                                             false)\n         }\n \n         for module_.import_resolutions.each_ref |ident, importresolution| {\n+            if importresolution.privacy != Public {\n+                debug!(\"(computing exports) not reexporting private `%s`\",\n+                       self.session.str_of(*ident));\n+                loop;\n+            }\n             for [ TypeNS, ValueNS ].each |ns| {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {"}]}