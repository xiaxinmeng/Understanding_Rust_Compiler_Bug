{"sha": "56714acc5eb0687ed9a7566fdebe5528657fc5b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NzE0YWNjNWViMDY4N2VkOWE3NTY2ZmRlYmU1NTI4NjU3ZmM1YjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-05T13:07:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-05T13:07:45Z"}, "message": "Auto merge of #49684 - kennytm:rollup, r=kennytm\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #48658 (Add a generic CAS loop to std::sync::Atomic*)\n - #49253 (Take the original extra-filename passed to a crate into account when resolving it as a dependency)\n - #49345 (RFC 2008: Finishing Touches)\n - #49432 (Flush executables to disk after linkage)\n - #49496 (Add more vec![... ; n] optimizations)\n - #49563 (add a dist builder to build rust-std components for the THUMB targets)\n - #49654 (Host compiler documentation: Include private items)\n - #49667 (Add more features to rust_2018_preview)\n - #49674 (ci: Remove x86_64-gnu-incremental builder)\n\nFailed merges:", "tree": {"sha": "d24cca4596ad0cbbdd35e2d36f7a94483386a011", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d24cca4596ad0cbbdd35e2d36f7a94483386a011"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56714acc5eb0687ed9a7566fdebe5528657fc5b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56714acc5eb0687ed9a7566fdebe5528657fc5b3", "html_url": "https://github.com/rust-lang/rust/commit/56714acc5eb0687ed9a7566fdebe5528657fc5b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56714acc5eb0687ed9a7566fdebe5528657fc5b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01d0be99257f5942ddc1168db1a7b5a472cf2c31", "url": "https://api.github.com/repos/rust-lang/rust/commits/01d0be99257f5942ddc1168db1a7b5a472cf2c31", "html_url": "https://github.com/rust-lang/rust/commit/01d0be99257f5942ddc1168db1a7b5a472cf2c31"}, {"sha": "f4511e24373a453f6993ff15cf557a9047ee782c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4511e24373a453f6993ff15cf557a9047ee782c", "html_url": "https://github.com/rust-lang/rust/commit/f4511e24373a453f6993ff15cf557a9047ee782c"}], "stats": {"total": 688, "additions": 567, "deletions": 121}, "files": [{"sha": "36329ab91143c46e116609163e843124e5998e79", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -171,8 +171,6 @@ matrix:\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-distcheck\n       if: branch = auto\n-    - env: IMAGE=x86_64-gnu-incremental\n-      if: branch = auto\n \n     - stage: publish toolstate\n       if: branch = master AND type = push"}, {"sha": "9cc18464fea094668f1c716c74cffe340e233827", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -140,48 +140,58 @@ pub fn std_cargo(build: &Builder,\n                  compiler: &Compiler,\n                  target: Interned<String>,\n                  cargo: &mut Command) {\n-    let mut features = build.std_features();\n-\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n-    // When doing a local rebuild we tell cargo that we're stage1 rather than\n-    // stage0. This works fine if the local rust and being-built rust have the\n-    // same view of what the default allocator is, but fails otherwise. Since\n-    // we don't have a way to express an allocator preference yet, work\n-    // around the issue in the case of a local rebuild with jemalloc disabled.\n-    if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n-        features.push_str(\" force_alloc_system\");\n-    }\n+    if build.no_std(target) == Some(true) {\n+        // for no-std targets we only compile a few no_std crates\n+        cargo.arg(\"--features\").arg(\"c mem\")\n+            .args(&[\"-p\", \"alloc\"])\n+            .args(&[\"-p\", \"compiler_builtins\"])\n+            .args(&[\"-p\", \"std_unicode\"])\n+            .arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n+    } else {\n+        let mut features = build.std_features();\n+\n+        // When doing a local rebuild we tell cargo that we're stage1 rather than\n+        // stage0. This works fine if the local rust and being-built rust have the\n+        // same view of what the default allocator is, but fails otherwise. Since\n+        // we don't have a way to express an allocator preference yet, work\n+        // around the issue in the case of a local rebuild with jemalloc disabled.\n+        if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n+            features.push_str(\" force_alloc_system\");\n+        }\n \n-    if compiler.stage != 0 && build.config.sanitizers {\n-        // This variable is used by the sanitizer runtime crates, e.g.\n-        // rustc_lsan, to build the sanitizer runtime from C code\n-        // When this variable is missing, those crates won't compile the C code,\n-        // so we don't set this variable during stage0 where llvm-config is\n-        // missing\n-        // We also only build the runtimes when --enable-sanitizers (or its\n-        // config.toml equivalent) is used\n-        let llvm_config = build.ensure(native::Llvm {\n-            target: build.config.build,\n-            emscripten: false,\n-        });\n-        cargo.env(\"LLVM_CONFIG\", llvm_config);\n-    }\n+        if compiler.stage != 0 && build.config.sanitizers {\n+            // This variable is used by the sanitizer runtime crates, e.g.\n+            // rustc_lsan, to build the sanitizer runtime from C code\n+            // When this variable is missing, those crates won't compile the C code,\n+            // so we don't set this variable during stage0 where llvm-config is\n+            // missing\n+            // We also only build the runtimes when --enable-sanitizers (or its\n+            // config.toml equivalent) is used\n+            let llvm_config = build.ensure(native::Llvm {\n+                target: build.config.build,\n+                emscripten: false,\n+            });\n+            cargo.env(\"LLVM_CONFIG\", llvm_config);\n+        }\n \n-    cargo.arg(\"--features\").arg(features)\n-        .arg(\"--manifest-path\")\n-        .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n+        cargo.arg(\"--features\").arg(features)\n+            .arg(\"--manifest-path\")\n+            .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n \n-    if let Some(target) = build.config.target_config.get(&target) {\n-        if let Some(ref jemalloc) = target.jemalloc {\n-            cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+        if let Some(target) = build.config.target_config.get(&target) {\n+            if let Some(ref jemalloc) = target.jemalloc {\n+                cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+            }\n         }\n-    }\n-    if target.contains(\"musl\") {\n-        if let Some(p) = build.musl_root(target) {\n-            cargo.env(\"MUSL_ROOT\", p);\n+        if target.contains(\"musl\") {\n+            if let Some(p) = build.musl_root(target) {\n+                cargo.env(\"MUSL_ROOT\", p);\n+            }\n         }\n     }\n }"}, {"sha": "863abd14935a8f3493b0994ac4314e8bce5cb804", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -161,6 +161,7 @@ pub struct Target {\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n     pub qemu_rootfs: Option<PathBuf>,\n+    pub no_std: bool,\n }\n \n /// Structure of the `config.toml` file that configuration is read from."}, {"sha": "e1f5d34bf67235c5e2a58225e4e4903f5b6b55a4", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -642,7 +642,12 @@ impl Step for Std {\n         if build.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            builder.ensure(compile::Test { compiler, target });\n+            if build.no_std(target) == Some(true) {\n+                // the `test` doesn't compile for no-std targets\n+                builder.ensure(compile::Std { compiler, target });\n+            } else {\n+                builder.ensure(compile::Test { compiler, target });\n+            }\n         }\n \n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));"}, {"sha": "4237ded2215c218e4fd8ed16e4d7d4a795fecc4b", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -698,6 +698,7 @@ impl Step for Rustc {\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n         compile::rustc_cargo(build, &mut cargo);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`."}, {"sha": "ea4368c0323fbd761b127afd0e32a3a65222a869", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -750,6 +750,12 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n+    /// Returns true if this is a no-std `target`, if defined\n+    fn no_std(&self, target: Interned<String>) -> Option<bool> {\n+        self.config.target_config.get(&target)\n+            .map(|t| t.no_std)\n+    }\n+\n     /// Returns whether the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n     fn remote_tested(&self, target: Interned<String>) -> bool {"}, {"sha": "1b1cec5f18c07d530795f35ee5df4d4faa8145e8", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -169,6 +169,19 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n+        if target.contains(\"-none-\") {\n+            if build.no_std(*target).is_none() {\n+                let target = build.config.target_config.entry(target.clone())\n+                    .or_insert(Default::default());\n+\n+                target.no_std = true;\n+            }\n+\n+            if build.no_std(*target) == Some(false) {\n+                panic!(\"All the *-none-* targets are no-std targets\")\n+            }\n+        }\n+\n         // Make sure musl-root is valid\n         if target.contains(\"musl\") {\n             // If this is a native target (host is also musl) and no musl-root is given,"}, {"sha": "00366301aa17aba600cb8c4f112a220124daab0c", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -20,7 +20,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   bzip2 \\\n   patch \\\n   libssl-dev \\\n-  pkg-config\n+  pkg-config \\\n+  gcc-arm-none-eabi \\\n+  libnewlib-arm-none-eabi\n \n WORKDIR /build\n \n@@ -86,6 +88,10 @@ ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n \n # FIXME: remove armv5te vars after https://github.com/alexcrichton/cc-rs/issues/271\n #        get fixed and cc update"}, {"sha": "7304ed6015cc9042f5e552df3244d45f105d932e", "filename": "src/ci/docker/x86_64-gnu-incremental/Dockerfile", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01d0be99257f5942ddc1168db1a7b5a472cf2c31/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/01d0be99257f5942ddc1168db1a7b5a472cf2c31/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile?ref=01d0be99257f5942ddc1168db1a7b5a472cf2c31", "patch": "@@ -1,22 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n-ENV RUSTFLAGS -Zincremental=/tmp/rust-incr-cache\n-ENV RUST_CHECK_TARGET check\n-ENV CARGO_INCREMENTAL 0"}, {"sha": "4b883b5bce79bd48f714b5442340696024eea662", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -1594,40 +1594,69 @@ impl SpecFromElem for u8 {\n     }\n }\n \n-macro_rules! impl_spec_from_elem {\n+impl<T: Clone + IsZero> SpecFromElem for T {\n+    #[inline]\n+    fn from_elem(elem: T, n: usize) -> Vec<T> {\n+        if elem.is_zero() {\n+            return Vec {\n+                buf: RawVec::with_capacity_zeroed(n),\n+                len: n,\n+            }\n+        }\n+        let mut v = Vec::with_capacity(n);\n+        v.extend_with(n, ExtendElement(elem));\n+        v\n+    }\n+}\n+\n+unsafe trait IsZero {\n+    /// Whether this value is zero\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_zero {\n     ($t: ty, $is_zero: expr) => {\n-        impl SpecFromElem for $t {\n+        unsafe impl IsZero for $t {\n             #[inline]\n-            fn from_elem(elem: $t, n: usize) -> Vec<$t> {\n-                if $is_zero(elem) {\n-                    return Vec {\n-                        buf: RawVec::with_capacity_zeroed(n),\n-                        len: n,\n-                    }\n-                }\n-                let mut v = Vec::with_capacity(n);\n-                v.extend_with(n, ExtendElement(elem));\n-                v\n+            fn is_zero(&self) -> bool {\n+                $is_zero(*self)\n             }\n         }\n-    };\n+    }\n }\n \n-impl_spec_from_elem!(i8, |x| x == 0);\n-impl_spec_from_elem!(i16, |x| x == 0);\n-impl_spec_from_elem!(i32, |x| x == 0);\n-impl_spec_from_elem!(i64, |x| x == 0);\n-impl_spec_from_elem!(i128, |x| x == 0);\n-impl_spec_from_elem!(isize, |x| x == 0);\n+impl_is_zero!(i8, |x| x == 0);\n+impl_is_zero!(i16, |x| x == 0);\n+impl_is_zero!(i32, |x| x == 0);\n+impl_is_zero!(i64, |x| x == 0);\n+impl_is_zero!(i128, |x| x == 0);\n+impl_is_zero!(isize, |x| x == 0);\n+\n+impl_is_zero!(u16, |x| x == 0);\n+impl_is_zero!(u32, |x| x == 0);\n+impl_is_zero!(u64, |x| x == 0);\n+impl_is_zero!(u128, |x| x == 0);\n+impl_is_zero!(usize, |x| x == 0);\n+\n+impl_is_zero!(char, |x| x == '\\0');\n+\n+impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n+impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n \n-impl_spec_from_elem!(u16, |x| x == 0);\n-impl_spec_from_elem!(u32, |x| x == 0);\n-impl_spec_from_elem!(u64, |x| x == 0);\n-impl_spec_from_elem!(u128, |x| x == 0);\n-impl_spec_from_elem!(usize, |x| x == 0);\n+unsafe impl<T: ?Sized> IsZero for *const T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n+\n+unsafe impl<T: ?Sized> IsZero for *mut T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n \n-impl_spec_from_elem!(f32, |x: f32| x.to_bits() == 0);\n-impl_spec_from_elem!(f64, |x: f64| x.to_bits() == 0);\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec"}, {"sha": "d336934ec7214ad56668dae5428abfef74ee7514", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -952,6 +952,7 @@ macro_rules! atomic_int {\n      $stable_nand:meta,\n      $s_int_type:expr, $int_ref:expr,\n      $extra_feature:expr,\n+     $min_fn:ident, $max_fn:ident,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n@@ -1421,6 +1422,128 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n             }\n+\n+            doc_comment! {\n+                concat!(\"Fetches the value, and applies a function to it that returns an optional\n+new value. Returns a `Result` (`Ok(_)` if the function returned `Some(_)`, else `Err(_)`) of the\n+previous value.\n+\n+Note: This may call the function multiple times if the value has been changed from other threads in\n+the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n+but once to the stored value.\n+\n+# Examples\n+\n+```rust\n+#![feature(no_more_cas)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let x = \", stringify!($atomic_type), \"::new(7);\n+assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n+assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n+assert_eq!(x.load(Ordering::SeqCst), 9);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"no_more_cas\",\n+                       reason = \"no more CAS loops in user code\",\n+                       issue = \"48655\")]\n+                pub fn fetch_update<F>(&self,\n+                                       mut f: F,\n+                                       fetch_order: Ordering,\n+                                       set_order: Ordering) -> Result<$int_type, $int_type>\n+                where F: FnMut($int_type) -> Option<$int_type> {\n+                    let mut prev = self.load(fetch_order);\n+                    while let Some(next) = f(prev) {\n+                        match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                            x @ Ok(_) => return x,\n+                            Err(next_prev) => prev = next_prev\n+                        }\n+                    }\n+                    Err(prev)\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Maximum with the current value.\n+\n+Finds the maximum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\n+assert_eq!(foo.load(Ordering::SeqCst), 42);\n+```\n+\n+If you want to obtain the maximum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 42;\n+let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n+assert!(max_foo == 42);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $max_fn(self.v.get(), val, order) }\n+                }\n+            }\n+\n+            doc_comment! {\n+                concat!(\"Minimum with the current value.\n+\n+Finds the minimum of the current value and the argument `val`, and\n+sets the new value to the result.\n+\n+Returns the previous value.\n+\n+# Examples\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+assert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 23);\n+assert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\n+assert_eq!(foo.load(Ordering::Relaxed), 22);\n+```\n+\n+If you want to obtain the minimum value in one step, you can use the following:\n+\n+```\n+#![feature(atomic_min_max)]\n+\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n+\n+let foo = \", stringify!($atomic_type), \"::new(23);\n+let bar = 12;\n+let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n+assert_eq!(min_foo, 12);\n+```\"),\n+                #[inline]\n+                #[unstable(feature = \"atomic_min_max\",\n+                       reason = \"easier and faster min/max than writing manual CAS loop\",\n+                       issue = \"48655\")]\n+                pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    unsafe { $min_fn(self.v.get(), val, order) }\n+                }\n+            }\n+\n         }\n     }\n }\n@@ -1435,6 +1558,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n@@ -1447,6 +1571,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1459,6 +1584,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1471,6 +1597,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1483,6 +1610,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1495,6 +1623,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1507,6 +1636,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_min, atomic_max,\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1519,6 +1649,7 @@ atomic_int! {\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n     \"#![feature(integer_atomics)]\\n\\n\",\n+    atomic_umin, atomic_umax,\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1531,6 +1662,7 @@ atomic_int!{\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"isize\", \"../../../std/primitive.isize.html\",\n     \"\",\n+    atomic_min, atomic_max,\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1543,6 +1675,7 @@ atomic_int!{\n     unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"usize\", \"../../../std/primitive.usize.html\",\n     \"\",\n+    atomic_umin, atomic_umax,\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n \n@@ -1720,6 +1853,58 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_max_acq(dst, val),\n+        Release => intrinsics::atomic_max_rel(dst, val),\n+        AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_max(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_min_acq(dst, val),\n+        Release => intrinsics::atomic_min_rel(dst, val),\n+        AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_min(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the max value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umax_acq(dst, val),\n+        Release => intrinsics::atomic_umax_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umax(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n+/// returns the min value (signed comparison)\n+#[inline]\n+unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_umin_acq(dst, val),\n+        Release => intrinsics::atomic_umin_rel(dst, val),\n+        AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_umin(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n /// An atomic fence.\n ///\n /// Depending on the specified order, a fence prevents the compiler and CPU from"}, {"sha": "d1f3736556c5dc28eaff476814ae693bc0dc412e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -589,6 +589,7 @@ define_dep_nodes!( <'tcx>\n     [input] CrateDisambiguator(CrateNum),\n     [input] CrateHash(CrateNum),\n     [input] OriginalCrateName(CrateNum),\n+    [input] ExtraFileName(CrateNum),\n \n     [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n     [] AllTraitImplementations(CrateNum),"}, {"sha": "2662e70999196f458de10c16608a9f55b52e1558", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -2058,6 +2058,33 @@ where 'x: 'y\n ```\n \"##,\n \n+E0910: r##\"\n+This error indicates that a `#[non_exhaustive]` attribute was incorrectly placed\n+on something other than a struct or enum.\n+\n+Examples of erroneous code:\n+\n+```compile_fail,E0910\n+# #![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+trait Foo { }\n+```\n+\"##,\n+\n+E0911: r##\"\n+This error indicates that a `#[non_exhaustive]` attribute had a value. The\n+`#[non_exhaustive]` should be empty.\n+\n+Examples of erroneous code:\n+\n+```compile_fail,E0911\n+# #![feature(non_exhaustive)]\n+\n+#[non_exhaustive(anything)]\n+struct Foo;\n+```\n+\"##,\n \n }\n "}, {"sha": "956cd17f38f214cd91f47550641f74cdb667742a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -66,6 +66,8 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         for attr in &item.attrs {\n             if attr.check_name(\"inline\") {\n                 self.check_inline(attr, &item.span, target)\n+            } else if attr.check_name(\"non_exhaustive\") {\n+                self.check_non_exhaustive(attr, item, target)\n             } else if attr.check_name(\"wasm_import_module\") {\n                 has_wasm_import_module = true;\n                 if attr.value_str().is_none() {\n@@ -113,6 +115,31 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n+    /// Check if the `#[non_exhaustive]` attribute on an `item` is valid.\n+    fn check_non_exhaustive(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n+        match target {\n+            Target::Struct | Target::Enum => { /* Valid */ },\n+            _ => {\n+                struct_span_err!(self.tcx.sess,\n+                                 attr.span,\n+                                 E0910,\n+                                 \"attribute can only be applied to a struct or enum\")\n+                    .span_label(item.span, \"not a struct or enum\")\n+                    .emit();\n+                return;\n+            }\n+        }\n+\n+        if attr.meta_item_list().is_some() || attr.value_str().is_some() {\n+            struct_span_err!(self.tcx.sess,\n+                             attr.span,\n+                             E0911,\n+                             \"attribute should be empty\")\n+                .span_label(item.span, \"not empty\")\n+                .emit();\n+        }\n+    }\n+\n     /// Check if the `#[repr]` attributes on `item` are valid.\n     fn check_repr(&self, item: &hir::Item, target: Target) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:"}, {"sha": "7e1b7c08c3dad99fc22c4566c84cf15a3e78082e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -353,8 +353,8 @@ pub struct ScopeTree {\n     /// the result of `g()` occurs after the yield (and therefore\n     /// doesn't). If we want to infer that, we can look at the\n     /// postorder traversal:\n-    /// ```\n-    /// `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n+    /// ```plain,ignore\n+    ///     `foo` `f` Call#1 `y` Yield `bar` `g` Call#3 Call#2 Call#0\n     /// ```\n     ///\n     /// In which we can easily see that `Call#1` occurs before the yield,"}, {"sha": "b1649686323f8750e09e47f33be76fdf28a7f839", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -362,7 +362,9 @@ enum EvaluationResult {\n     /// When checking `foo`, we have to prove `T: Trait`. This basically\n     /// translates into this:\n     ///\n+    /// ```plain,ignore\n     ///     (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n+    /// ```\n     ///\n     /// When we try to prove it, we first go the first option, which\n     /// recurses. This shows us that the impl is \"useless\" - it won't"}, {"sha": "a08cd57b1f7e24639d4e1128419f4240f6f9428e", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -466,6 +466,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::original_crate_name<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::extra_filename<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the extra filename for a crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::implementations_of_trait<'tcx> {\n     fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n         format!(\"looking up implementations of a trait in a crate\")"}, {"sha": "8651619705b4203680a513756eea95bab481330f", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -328,6 +328,7 @@ define_maps! { <'tcx>\n     [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n     [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n     [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n+    [] fn extra_filename: ExtraFileName(CrateNum) -> String,\n \n     [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n         -> Lrc<Vec<DefId>>,"}, {"sha": "fa69eb8e5bc661f8b057538b6c88d1cd1b271cbd", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -881,6 +881,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::CrateDisambiguator => { force!(crate_disambiguator, krate!()); }\n         DepKind::CrateHash => { force!(crate_hash, krate!()); }\n         DepKind::OriginalCrateName => { force!(original_crate_name, krate!()); }\n+        DepKind::ExtraFileName => { force!(extra_filename, krate!()); }\n \n         DepKind::AllTraitImplementations => {\n             force!(all_trait_implementations, krate!());"}, {"sha": "86f495c5fac3a2782e245ed06bc2364d0184f2ad", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -262,6 +262,7 @@ impl<'a> CrateLoader<'a> {\n                      ident: Symbol,\n                      name: Symbol,\n                      hash: Option<&Svh>,\n+                     extra_filename: Option<&str>,\n                      span: Span,\n                      path_kind: PathKind,\n                      mut dep_kind: DepKind)\n@@ -277,6 +278,7 @@ impl<'a> CrateLoader<'a> {\n                 ident,\n                 crate_name: name,\n                 hash: hash.map(|a| &*a),\n+                extra_filename: extra_filename,\n                 filesearch: self.sess.target_filesearch(path_kind),\n                 target: &self.sess.target.target,\n                 triple: &self.sess.opts.target_triple,\n@@ -409,7 +411,8 @@ impl<'a> CrateLoader<'a> {\n         ::std::iter::once(krate).chain(crate_root.crate_deps\n                                                  .decode(metadata)\n                                                  .map(|dep| {\n-            debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n+            info!(\"resolving dep crate {} hash: `{}` extra filename: `{}`\", dep.name, dep.hash,\n+                  dep.extra_filename);\n             if dep.kind == DepKind::UnexportedMacrosOnly {\n                 return krate;\n             }\n@@ -418,7 +421,8 @@ impl<'a> CrateLoader<'a> {\n                 _ => dep.kind,\n             };\n             let (local_cnum, ..) = self.resolve_crate(\n-                root, dep.name, dep.name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n+                root, dep.name, dep.name, Some(&dep.hash), Some(&dep.extra_filename), span,\n+                PathKind::Dependency, dep_kind,\n             );\n             local_cnum\n         })).collect()\n@@ -437,6 +441,7 @@ impl<'a> CrateLoader<'a> {\n             ident: orig_name,\n             crate_name: rename,\n             hash: None,\n+            extra_filename: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n             triple: &host_triple,\n@@ -664,7 +669,7 @@ impl<'a> CrateLoader<'a> {\n \n         let dep_kind = DepKind::Implicit;\n         let (cnum, data) =\n-            self.resolve_crate(&None, name, name, None, DUMMY_SP, PathKind::Crate, dep_kind);\n+            self.resolve_crate(&None, name, name, None, None, DUMMY_SP, PathKind::Crate, dep_kind);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -771,7 +776,7 @@ impl<'a> CrateLoader<'a> {\n                 let symbol = Symbol::intern(name);\n                 let dep_kind = DepKind::Explicit;\n                 let (_, data) =\n-                    self.resolve_crate(&None, symbol, symbol, None, DUMMY_SP,\n+                    self.resolve_crate(&None, symbol, symbol, None, None, DUMMY_SP,\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n@@ -794,7 +799,7 @@ impl<'a> CrateLoader<'a> {\n             let symbol = Symbol::intern(\"profiler_builtins\");\n             let dep_kind = DepKind::Implicit;\n             let (_, data) =\n-                self.resolve_crate(&None, symbol, symbol, None, DUMMY_SP,\n+                self.resolve_crate(&None, symbol, symbol, None, None, DUMMY_SP,\n                                    PathKind::Crate, dep_kind);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n@@ -909,6 +914,7 @@ impl<'a> CrateLoader<'a> {\n                                                               name,\n                                                               name,\n                                                               None,\n+                                                              None,\n                                                               DUMMY_SP,\n                                                               PathKind::Crate,\n                                                               DepKind::Implicit);\n@@ -1059,7 +1065,8 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n                 };\n \n                 let (cnum, ..) = self.resolve_crate(\n-                    &None, item.ident.name, orig_name, None, item.span, PathKind::Crate, dep_kind,\n+                    &None, item.ident.name, orig_name, None, None,\n+                    item.span, PathKind::Crate, dep_kind,\n                 );\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n@@ -1074,6 +1081,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n     }\n \n     fn resolve_crate_from_path(&mut self, name: Symbol, span: Span) -> CrateNum {\n-        self.resolve_crate(&None, name, name, None, span, PathKind::Crate, DepKind::Explicit).0\n+        self.resolve_crate(&None, name, name, None, None, span, PathKind::Crate,\n+                           DepKind::Explicit).0\n     }\n }"}, {"sha": "f63edf07fa8ba5b6615079f4c1739e7e18864378", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -213,6 +213,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     crate_hash => { cdata.hash() }\n     original_crate_name => { cdata.name() }\n \n+    extra_filename => { cdata.root.extra_filename.clone() }\n+\n+\n     implementations_of_trait => {\n         let mut result = vec![];\n         let filter = Some(other);"}, {"sha": "0da6fc5b9eda19267d012e54052a123a9f0b7f57", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -462,6 +462,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let has_global_allocator = tcx.sess.has_global_allocator.get();\n         let root = self.lazy(&CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n+            extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator(),\n@@ -1357,6 +1358,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     name: self.tcx.original_crate_name(cnum),\n                     hash: self.tcx.crate_hash(cnum),\n                     kind: self.tcx.dep_kind(cnum),\n+                    extra_filename: self.tcx.extra_filename(cnum),\n                 };\n                 (cnum, dep)\n             })"}, {"sha": "f553c55ae56fad5cf5ef9f407c6111c56ee47e77", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -83,7 +83,10 @@\n //! 1. Does the filename match an rlib/dylib pattern? That is to say, does the\n //!    filename have the right prefix/suffix?\n //! 2. Does the filename have the right prefix for the crate name being queried?\n-//!    This is filtering for files like `libfoo*.rlib` and such.\n+//!    This is filtering for files like `libfoo*.rlib` and such. If the crate\n+//!    we're looking for was originally compiled with -C extra-filename, the\n+//!    extra filename will be included in this prefix to reduce reading\n+//!    metadata from crates that would otherwise share our prefix.\n //! 3. Is the file an actual rust library? This is done by loading the metadata\n //!    from the library and making sure it's actually there.\n //! 4. Does the name in the metadata agree with the name of the library?\n@@ -236,6 +239,7 @@ use syntax_pos::Span;\n use rustc_back::target::{Target, TargetTriple};\n \n use std::cmp;\n+use std::collections::HashSet;\n use std::fmt;\n use std::fs;\n use std::io::{self, Read};\n@@ -256,6 +260,7 @@ pub struct Context<'a> {\n     pub ident: Symbol,\n     pub crate_name: Symbol,\n     pub hash: Option<&'a Svh>,\n+    pub extra_filename: Option<&'a str>,\n     // points to either self.sess.target.target or self.sess.host, must match triple\n     pub target: &'a Target,\n     pub triple: &'a TargetTriple,\n@@ -303,7 +308,12 @@ impl CratePaths {\n \n impl<'a> Context<'a> {\n     pub fn maybe_load_library_crate(&mut self) -> Option<Library> {\n-        self.find_library_crate()\n+        let mut seen_paths = HashSet::new();\n+        match self.extra_filename {\n+            Some(s) => self.find_library_crate(s, &mut seen_paths)\n+                .or_else(|| self.find_library_crate(\"\", &mut seen_paths)),\n+            None => self.find_library_crate(\"\", &mut seen_paths)\n+        }\n     }\n \n     pub fn report_errs(&mut self) -> ! {\n@@ -419,7 +429,10 @@ impl<'a> Context<'a> {\n         unreachable!();\n     }\n \n-    fn find_library_crate(&mut self) -> Option<Library> {\n+    fn find_library_crate(&mut self,\n+                          extra_prefix: &str,\n+                          seen_paths: &mut HashSet<PathBuf>)\n+                          -> Option<Library> {\n         // If an SVH is specified, then this is a transitive dependency that\n         // must be loaded via -L plus some filtering.\n         if self.hash.is_none() {\n@@ -434,9 +447,9 @@ impl<'a> Context<'a> {\n         let staticpair = self.staticlibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}\", dypair.0, self.crate_name);\n-        let rlib_prefix = format!(\"lib{}\", self.crate_name);\n-        let staticlib_prefix = format!(\"{}{}\", staticpair.0, self.crate_name);\n+        let dylib_prefix = format!(\"{}{}{}\", dypair.0, self.crate_name, extra_prefix);\n+        let rlib_prefix = format!(\"lib{}{}\", self.crate_name, extra_prefix);\n+        let staticlib_prefix = format!(\"{}{}{}\", staticpair.0, self.crate_name, extra_prefix);\n \n         let mut candidates = FxHashMap();\n         let mut staticlibs = vec![];\n@@ -476,6 +489,7 @@ impl<'a> Context<'a> {\n                     }\n                     return FileDoesntMatch;\n                 };\n+\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n@@ -484,6 +498,10 @@ impl<'a> Context<'a> {\n             let (ref mut rlibs, ref mut rmetas, ref mut dylibs) = *slot;\n             fs::canonicalize(path)\n                 .map(|p| {\n+                    if seen_paths.contains(&p) {\n+                        return FileDoesntMatch\n+                    };\n+                    seen_paths.insert(p.clone());\n                     match found_kind {\n                         CrateFlavor::Rlib => { rlibs.insert(p, kind); }\n                         CrateFlavor::Rmeta => { rmetas.insert(p, kind); }"}, {"sha": "a7ee0e7e9a961c7eb5b2eb461532d88dcbbf5588", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -188,6 +188,7 @@ pub enum LazyState {\n pub struct CrateRoot {\n     pub name: Symbol,\n     pub triple: TargetTriple,\n+    pub extra_filename: String,\n     pub hash: hir::svh::Svh,\n     pub disambiguator: CrateDisambiguator,\n     pub panic_strategy: PanicStrategy,\n@@ -216,12 +217,14 @@ pub struct CrateDep {\n     pub name: ast::Name,\n     pub hash: hir::svh::Svh,\n     pub kind: DepKind,\n+    pub extra_filename: String,\n }\n \n impl_stable_hash_for!(struct CrateDep {\n     name,\n     hash,\n-    kind\n+    kind,\n+    extra_filename\n });\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "3a97d2767444bc065f75555a8c9c4e468bcf1ed5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -427,14 +427,14 @@ fn generate_fn_name_span(cm: &CodeMap, span: Span) -> Option<Span> {\n /// a new local type parameter.\n ///\n /// For instance:\n-/// ```\n+/// ```rust,ignore (pseudo-Rust)\n /// // Given span\n /// fn my_function(param: T)\n-///                       ^ Original span\n+/// //                    ^ Original span\n ///\n /// // Result\n /// fn my_function(param: T)\n-///    ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n+/// // ^^^^^^^^^^^ Generated span with snippet `my_function<T>`\n /// ```\n ///\n /// Attention: The method used is very fragile since it essentially duplicates the work of the"}, {"sha": "4ffc71ba4703eb268d34619852877f5e47206d0e", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -694,7 +694,7 @@ fn link_natively(sess: &Session,\n     loop {\n         i += 1;\n         prog = time(sess, \"running linker\", || {\n-            exec_linker(sess, &mut cmd, tmpdir)\n+            exec_linker(sess, &mut cmd, out_filename, tmpdir)\n         });\n         let output = match prog {\n             Ok(ref output) => output,\n@@ -822,7 +822,7 @@ fn link_natively(sess: &Session,\n     }\n }\n \n-fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n+fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &Path)\n     -> io::Result<Output>\n {\n     // When attempting to spawn the linker we run a risk of blowing out the\n@@ -836,7 +836,11 @@ fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n     // there instead of looking at the command line.\n     if !cmd.very_likely_to_exceed_some_spawn_limit() {\n         match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n-            Ok(child) => return child.wait_with_output(),\n+            Ok(child) => {\n+                let output = child.wait_with_output();\n+                flush_linked_file(&output, out_filename)?;\n+                return output;\n+            }\n             Err(ref e) if command_line_too_big(e) => {\n                 info!(\"command line to linker was too big: {}\", e);\n             }\n@@ -870,7 +874,37 @@ fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n     fs::write(&file, &bytes)?;\n     cmd2.arg(format!(\"@{}\", file.display()));\n     info!(\"invoking linker {:?}\", cmd2);\n-    return cmd2.output();\n+    let output = cmd2.output();\n+    flush_linked_file(&output, out_filename)?;\n+    return output;\n+\n+    #[cfg(unix)]\n+    fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    #[cfg(windows)]\n+    fn flush_linked_file(command_output: &io::Result<Output>, out_filename: &Path)\n+        -> io::Result<()>\n+    {\n+        // On Windows, under high I/O load, output buffers are sometimes not flushed,\n+        // even long after process exit, causing nasty, non-reproducible output bugs.\n+        //\n+        // File::sync_all() calls FlushFileBuffers() down the line, which solves the problem.\n+        //\n+        // \u0410 full writeup of the original Chrome bug can be found at\n+        // randomascii.wordpress.com/2018/02/25/compiler-bug-linker-bug-windows-kernel-bug/amp\n+\n+        if let &Ok(ref out) = command_output {\n+            if out.status.success() {\n+                if let Ok(of) = fs::OpenOptions::new().write(true).open(out_filename) {\n+                    of.sync_all()?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n \n     #[cfg(unix)]\n     fn command_line_too_big(err: &io::Error) -> bool {"}, {"sha": "b5e862fac958a027089e068924fffdf6440e3a31", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -1164,10 +1164,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// constraint that `'z <= 'a`. Given this setup, let's clarify the\n     /// parameters in (roughly) terms of the example:\n     ///\n+    /// ```plain,ignore (pseudo-Rust)\n     ///     A borrow of: `& 'z bk * r` where `r` has type `& 'a bk T`\n     ///     borrow_region   ^~                 ref_region    ^~\n     ///     borrow_kind        ^~               ref_kind        ^~\n     ///     ref_cmt                 ^\n+    /// ```\n     ///\n     /// Here `bk` stands for some borrow-kind (e.g., `mut`, `uniq`, etc).\n     ///"}, {"sha": "faf3ccb1133adcb89c9a18a168d0120f8aa5a228", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -42,21 +42,21 @@ use syntax_pos::Span;\n ///\n /// Example:\n ///\n-/// ```\n+/// ```rust,ignore (pseudo-Rust)\n /// impl<T> Trait<Foo> for Bar { ... }\n-///      ^ T does not appear in `Foo` or `Bar`, error!\n+/// //   ^ T does not appear in `Foo` or `Bar`, error!\n ///\n /// impl<T> Trait<Foo<T>> for Bar { ... }\n-///      ^ T appears in `Foo<T>`, ok.\n+/// //   ^ T appears in `Foo<T>`, ok.\n ///\n /// impl<T> Trait<Foo> for Bar where Bar: Iterator<Item=T> { ... }\n-///      ^ T is bound to `<Bar as Iterator>::Item`, ok.\n+/// //   ^ T is bound to `<Bar as Iterator>::Item`, ok.\n ///\n /// impl<'a> Trait<Foo> for Bar { }\n-///      ^ 'a is unused, but for back-compat we allow it\n+/// //   ^ 'a is unused, but for back-compat we allow it\n ///\n /// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n-///      ^ 'a is unused and appears in assoc type, error\n+/// //   ^ 'a is unused and appears in assoc type, error\n /// ```\n pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // We will tag this as part of the WF check -- logically, it is,"}, {"sha": "0f039895dee77e8e5e1d1de55e903e0383063313", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -193,7 +193,7 @@ declare_features! (\n     (active, rustc_attrs, \"1.0.0\", Some(29642), None),\n \n     // Allows the use of non lexical lifetimes; RFC 2094\n-    (active, nll, \"1.0.0\", Some(43234), None),\n+    (active, nll, \"1.0.0\", Some(43234), Some(Edition::Edition2018)),\n \n     // Allows the use of #[allow_internal_unstable]. This is an\n     // attribute on macro_rules! and can't use the attribute handling\n@@ -388,7 +388,7 @@ declare_features! (\n     (active, dyn_trait, \"1.22.0\", Some(44662), Some(Edition::Edition2018)),\n \n     // `crate` as visibility modifier, synonymous to `pub(crate)`\n-    (active, crate_visibility_modifier, \"1.23.0\", Some(45388), None),\n+    (active, crate_visibility_modifier, \"1.23.0\", Some(45388), Some(Edition::Edition2018)),\n \n     // extern types\n     (active, extern_types, \"1.23.0\", Some(43467), None),\n@@ -397,10 +397,10 @@ declare_features! (\n     (active, arbitrary_self_types, \"1.23.0\", Some(44874), None),\n \n     // `crate` in paths\n-    (active, crate_in_paths, \"1.23.0\", Some(45477), None),\n+    (active, crate_in_paths, \"1.23.0\", Some(45477), Some(Edition::Edition2018)),\n \n     // In-band lifetime bindings (e.g. `fn foo(x: &'a u8) -> &'a u8`)\n-    (active, in_band_lifetimes, \"1.23.0\", Some(44524), None),\n+    (active, in_band_lifetimes, \"1.23.0\", Some(44524), Some(Edition::Edition2018)),\n \n     // generic associated types (RFC 1598)\n     (active, generic_associated_types, \"1.23.0\", Some(44265), None),\n@@ -409,10 +409,10 @@ declare_features! (\n     (active, extern_absolute_paths, \"1.24.0\", Some(44660), None),\n \n     // `foo.rs` as an alternative to `foo/mod.rs`\n-    (active, non_modrs_mods, \"1.24.0\", Some(44660), None),\n+    (active, non_modrs_mods, \"1.24.0\", Some(44660), Some(Edition::Edition2018)),\n \n     // Termination trait in tests (RFC 1937)\n-    (active, termination_trait_test, \"1.24.0\", Some(48854), None),\n+    (active, termination_trait_test, \"1.24.0\", Some(48854), Some(Edition::Edition2018)),\n \n     // Allows use of the :lifetime macro fragment specifier\n     (active, macro_lifetime_matcher, \"1.24.0\", Some(46895), None),"}, {"sha": "7d8423ca84eb41622f382652c0adb2641ea0fcbd", "filename": "src/rustc/compiler_builtins_shim/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -35,5 +35,6 @@ cc = \"1.0.1\"\n [features]\n c = []\n default = [\"c\", \"rustbuild\", \"compiler-builtins\"]\n+mem = []\n rustbuild = []\n compiler-builtins = []"}, {"sha": "e48d989c01d61030db2da36fbb68e181253ec00e", "filename": "src/test/compile-fail/rfc-2008-non-exhaustive/invalid-attribute.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Fcompile-fail%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Fcompile-fail%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(non_exhaustive)]\n+\n+#[non_exhaustive(anything)]\n+//~^ ERROR attribute should be empty [E0911]\n+struct Foo;\n+\n+#[non_exhaustive]\n+//~^ ERROR attribute can only be applied to a struct or enum [E0910]\n+trait Bar { }\n+\n+#[non_exhaustive]\n+//~^ ERROR attribute can only be applied to a struct or enum [E0910]\n+union Baz {\n+    f1: u16,\n+    f2: u16\n+}\n+\n+fn main() { }"}, {"sha": "4b0c36d01b7a86feaecf8c95283c5b121d040798", "filename": "src/test/run-make-fulldeps/resolve-rename/Makefile", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2FMakefile?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -0,0 +1,7 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) -C extra-filename=-hash foo.rs\n+\t$(RUSTC) bar.rs\n+\tmv $(TMPDIR)/libfoo-hash.rlib $(TMPDIR)/libfoo-another-hash.rlib\n+\t$(RUSTC) baz.rs"}, {"sha": "1552b45f2fc16075d27f459ae8c052c27078be6d", "filename": "src/test/run-make-fulldeps/resolve-rename/bar.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Fbar.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+extern crate foo;\n+\n+pub fn bar() { foo::foo() }"}, {"sha": "27d801490e4256dd64e82aac7580e17673a3fe7a", "filename": "src/test/run-make-fulldeps/resolve-rename/baz.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Fbaz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Fbaz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Fbaz.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+extern crate bar;\n+\n+pub fn baz() { bar::bar() }"}, {"sha": "830c289b65f1169a063d63885aeff1fe0141fd46", "filename": "src/test/run-make-fulldeps/resolve-rename/foo.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56714acc5eb0687ed9a7566fdebe5528657fc5b3/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fresolve-rename%2Ffoo.rs?ref=56714acc5eb0687ed9a7566fdebe5528657fc5b3", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+pub fn foo() {}"}]}