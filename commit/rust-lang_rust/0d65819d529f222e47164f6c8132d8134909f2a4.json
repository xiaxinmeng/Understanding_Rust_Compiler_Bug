{"sha": "0d65819d529f222e47164f6c8132d8134909f2a4", "node_id": "C_kwDOAAsO6NoAKDBkNjU4MTlkNTI5ZjIyMmU0NzE2NGY2YzgxMzJkODEzNDkwOWYyYTQ", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-08-26T20:39:59Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-08-31T16:56:42Z"}, "message": "respond to review feedback: mainly eliminate as many conversions as possible...\n\n- ... when creating diagnostics in rustc_metadata\n-  use the error_code! macro\n- pass macro output to diag.code()\n- use fluent from within manual implementation of SessionDiagnostic\n- emit the untested errors in case they occur in the wild\n- stop panicking in the probably-not-dead code, add fixme to write test", "tree": {"sha": "273a58e5e2ff576a688e8186142ed1faad81d12b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/273a58e5e2ff576a688e8186142ed1faad81d12b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d65819d529f222e47164f6c8132d8134909f2a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d65819d529f222e47164f6c8132d8134909f2a4", "html_url": "https://github.com/rust-lang/rust/commit/0d65819d529f222e47164f6c8132d8134909f2a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d65819d529f222e47164f6c8132d8134909f2a4/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "html_url": "https://github.com/rust-lang/rust/commit/d0ba1fbaa4f73b6edf27346817b1f74fb352945e"}], "stats": {"total": 460, "additions": 234, "deletions": 226}, "files": [{"sha": "0ce329ff07086084e9fbadae5adfc8e027d0c607", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -3514,6 +3514,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n+ \"rustc_target\",\n  \"serde\",\n  \"serde_json\",\n  \"termcolor\","}, {"sha": "dee01bcad4bbca7ea53b8022137de3ad17d95919", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -225,3 +225,33 @@ metadata_cannot_find_crate =\n \n metadata_no_dylib_plugin =\n     plugin `{$crate_name}` only found in rlib format, but must be available in dylib format\n+\n+metadata_target_not_installed =\n+    the `{$locator_triple}` target may not be installed\n+\n+metadata_target_no_std_support =\n+    the `{$locator_triple}` target may not support the standard library\n+\n+metadata_consider_downloading_target =\n+    consider downloading the target with `rustup target add {$locator_triple}`\n+\n+metadata_std_required =\n+    `std` is required by `{$current_crate}` because it does not declare `#![no_std]`\n+\n+metadata_consider_building_std =\n+    consider building the standard library from source with `cargo build -Zbuild-std`\n+\n+metadata_compiler_missing_profiler =\n+    the compiler may have been built without the profiler runtime\n+\n+metadata_install_missing_components =\n+    maybe you need to install the missing components with: `rustup component add rust-src rustc-dev llvm-tools-preview`\n+\n+metadata_cant_find_crate =\n+    can't find crate\n+\n+metadata_crate_location_unknown_type =\n+    extern location for {$crate_name} is of an unknown type: {$path}\n+\n+metadata_lib_filename_form =\n+    file name should be lib*.rlib or {dll_prefix}*.{dll_suffix}"}, {"sha": "4d207fd17fb2dfb9b2f16d3e9a9fa9f8a2a023f4", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -15,13 +15,14 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n+rustc_target = { path = \"../rustc_target\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.9\"\n termize = \"0.1.1\"\n-serde = { version = \"1.0.125\", features = [\"derive\"] }\n+serde = { version = \"1.0.125\", features = [ \"derive\" ] }\n serde_json = \"1.0.59\"\n \n [target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"handleapi\", \"synchapi\", \"winbase\"] }\n+winapi = { version = \"0.3\", features = [ \"handleapi\", \"synchapi\", \"winbase\" ] }"}, {"sha": "b569ef4fc2c915086f894f0905e03483834594b8", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -10,6 +10,7 @@ use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n use rustc_span::{edition::Edition, Span, DUMMY_SP};\n+use rustc_target::spec::PanicStrategy;\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n@@ -144,6 +145,12 @@ impl IntoDiagnosticArg for usize {\n     }\n }\n \n+impl IntoDiagnosticArg for PanicStrategy {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.desc().to_string()))\n+    }\n+}\n+\n impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     fn into(self) -> FluentValue<'source> {\n         match self {"}, {"sha": "edffec8ab55c4ca98dc6025884c13a7d87082cdd", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -750,13 +750,10 @@ impl<'a> CrateLoader<'a> {\n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n         if !data.is_panic_runtime() {\n-            self.sess.emit_err(CrateNotPanicRuntime { crate_name: name.to_string() });\n+            self.sess.emit_err(CrateNotPanicRuntime { crate_name: name });\n         }\n         if data.required_panic_strategy() != Some(desired_strategy) {\n-            self.sess.emit_err(NoPanicStrategy {\n-                crate_name: name.to_string(),\n-                strategy: desired_strategy.desc().to_string(),\n-            });\n+            self.sess.emit_err(NoPanicStrategy { crate_name: name, strategy: desired_strategy });\n         }\n \n         self.cstore.injected_panic_runtime = Some(cnum);\n@@ -784,7 +781,7 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n         if !data.is_profiler_runtime() {\n-            self.sess.emit_err(NotProfilerRuntime { crate_name: name.to_string() });\n+            self.sess.emit_err(NotProfilerRuntime { crate_name: name });\n         }\n     }\n \n@@ -828,8 +825,8 @@ impl<'a> CrateLoader<'a> {\n                 match global_allocator {\n                     Some(other_crate) => {\n                         self.sess.emit_err(ConflictingGlobalAlloc {\n-                            crate_name: data.name().to_string(),\n-                            other_crate_name: other_crate.to_string(),\n+                            crate_name: data.name(),\n+                            other_crate_name: other_crate,\n                         });\n                     }\n                     None => global_allocator = Some(data.name()),\n@@ -874,9 +871,9 @@ impl<'a> CrateLoader<'a> {\n             let data = self.cstore.get_crate_data(dep);\n             if needs_dep(&data) {\n                 self.sess.emit_err(NoTransitiveNeedsDep {\n-                    crate_name: self.cstore.get_crate_data(krate).name().to_string(),\n-                    needs_crate_name: what.to_string(),\n-                    deps_crate_name: data.name().to_string(),\n+                    crate_name: self.cstore.get_crate_data(krate).name(),\n+                    needs_crate_name: what,\n+                    deps_crate_name: data.name(),\n                 });\n             }\n         }"}, {"sha": "9ad0099ad251b17f2c2b6270105f19ec2d57a811", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -140,7 +140,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n                 if src.rlib.is_some() {\n                     continue;\n                 }\n-                sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum).to_string() });\n+                sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum) });\n             }\n             return Vec::new();\n         }\n@@ -224,10 +224,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                sess.emit_err(LibRequired {\n-                    crate_name: tcx.crate_name(cnum).to_string(),\n-                    kind: kind.to_string(),\n-                });\n+                sess.emit_err(LibRequired { crate_name: tcx.crate_name(cnum), kind: kind });\n             }\n         }\n     }\n@@ -251,8 +248,7 @@ fn add_library(\n             // This error is probably a little obscure, but I imagine that it\n             // can be refined over time.\n             if link2 != link || link == RequireStatic {\n-                tcx.sess\n-                    .emit_err(CrateDepMultiple { crate_name: tcx.crate_name(cnum).to_string() });\n+                tcx.sess.emit_err(CrateDepMultiple { crate_name: tcx.crate_name(cnum) });\n             }\n         }\n         None => {\n@@ -347,8 +343,8 @@ fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n \n         if tcx.is_panic_runtime(cnum) {\n             if let Some((prev, _)) = panic_runtime {\n-                let prev_name = tcx.crate_name(prev).to_string();\n-                let cur_name = tcx.crate_name(cnum).to_string();\n+                let prev_name = tcx.crate_name(prev);\n+                let cur_name = tcx.crate_name(cnum);\n                 sess.emit_err(TwoPanicRuntimes { prev_name, cur_name });\n             }\n             panic_runtime = Some((\n@@ -370,8 +366,8 @@ fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n         // our same strategy.\n         if found_strategy != desired_strategy {\n             sess.emit_err(BadPanicStrategy {\n-                runtime: tcx.crate_name(runtime_cnum).to_string(),\n-                strategy: desired_strategy.desc().to_string(),\n+                runtime: tcx.crate_name(runtime_cnum),\n+                strategy: desired_strategy,\n             });\n         }\n \n@@ -390,17 +386,17 @@ fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n \n             if let Some(found_strategy) = tcx.required_panic_strategy(cnum) && desired_strategy != found_strategy {\n                 sess.emit_err(RequiredPanicStrategy {\n-                    crate_name: tcx.crate_name(cnum).to_string(),\n-                    found_strategy: found_strategy.desc().to_string(),\n-                    desired_strategy: desired_strategy.desc().to_string() });\n+                    crate_name: tcx.crate_name(cnum),\n+                    found_strategy,\n+                    desired_strategy});\n             }\n \n             let found_drop_strategy = tcx.panic_in_drop_strategy(cnum);\n             if tcx.sess.opts.unstable_opts.panic_in_drop != found_drop_strategy {\n                 sess.emit_err(IncompatiblePanicInDropStrategy {\n-                    crate_name: tcx.crate_name(cnum).to_string(),\n-                    found_strategy: found_drop_strategy.desc().to_string(),\n-                    desired_strategy: tcx.sess.opts.unstable_opts.panic_in_drop.desc().to_string(),\n+                    crate_name: tcx.crate_name(cnum),\n+                    found_strategy: found_drop_strategy,\n+                    desired_strategy: tcx.sess.opts.unstable_opts.panic_in_drop,\n                 });\n             }\n         }"}, {"sha": "565c96917e2fc1e7538b748e84463692538cae1c", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 112, "deletions": 103, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -1,59 +1,64 @@\n-use std::path::PathBuf;\n+use std::{\n+    io::Error,\n+    path::{Path, PathBuf},\n+};\n \n-use rustc_errors::{DiagnosticId, ErrorGuaranteed};\n+use rustc_errors::{error_code, ErrorGuaranteed};\n use rustc_macros::SessionDiagnostic;\n use rustc_session::{config, SessionDiagnostic};\n use rustc_span::{sym, Span, Symbol};\n-use rustc_target::spec::TargetTriple;\n+use rustc_target::spec::{PanicStrategy, TargetTriple};\n+\n+use crate::locator::CrateFlavor;\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::rlib_required)]\n pub struct RlibRequired {\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::lib_required)]\n-pub struct LibRequired {\n-    pub crate_name: String,\n-    pub kind: String,\n+pub struct LibRequired<'a> {\n+    pub crate_name: Symbol,\n+    pub kind: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::crate_dep_multiple)]\n #[help]\n pub struct CrateDepMultiple {\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::two_panic_runtimes)]\n pub struct TwoPanicRuntimes {\n-    pub prev_name: String,\n-    pub cur_name: String,\n+    pub prev_name: Symbol,\n+    pub cur_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::bad_panic_strategy)]\n pub struct BadPanicStrategy {\n-    pub runtime: String,\n-    pub strategy: String,\n+    pub runtime: Symbol,\n+    pub strategy: PanicStrategy,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::required_panic_strategy)]\n pub struct RequiredPanicStrategy {\n-    pub crate_name: String,\n-    pub found_strategy: String,\n-    pub desired_strategy: String,\n+    pub crate_name: Symbol,\n+    pub found_strategy: PanicStrategy,\n+    pub desired_strategy: PanicStrategy,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::incompatible_panic_in_drop_strategy)]\n pub struct IncompatiblePanicInDropStrategy {\n-    pub crate_name: String,\n-    pub found_strategy: String,\n-    pub desired_strategy: String,\n+    pub crate_name: Symbol,\n+    pub found_strategy: PanicStrategy,\n+    pub desired_strategy: PanicStrategy,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -129,11 +134,11 @@ pub struct FrameworkOnlyWindows {\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::unknown_link_kind, code = \"E0458\")]\n-pub struct UnknownLinkKind {\n+pub struct UnknownLinkKind<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    pub kind: String,\n+    pub kind: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -180,10 +185,10 @@ pub struct InvalidLinkModifier {\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::multiple_modifiers)]\n-pub struct MultipleModifiers {\n+pub struct MultipleModifiers<'a> {\n     #[primary_span]\n     pub span: Span,\n-    pub modifier: String,\n+    pub modifier: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -209,10 +214,10 @@ pub struct AsNeededCompatibility {\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::unknown_link_modifier)]\n-pub struct UnknownLinkModifier {\n+pub struct UnknownLinkModifier<'a> {\n     #[primary_span]\n     pub span: Span,\n-    pub modifier: String,\n+    pub modifier: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -250,20 +255,20 @@ pub struct LibFrameworkApple;\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::empty_renaming_target)]\n-pub struct EmptyRenamingTarget {\n-    pub lib_name: String,\n+pub struct EmptyRenamingTarget<'a> {\n+    pub lib_name: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::renaming_no_link)]\n-pub struct RenamingNoLink {\n-    pub lib_name: String,\n+pub struct RenamingNoLink<'a> {\n+    pub lib_name: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::multiple_renamings)]\n-pub struct MultipleRenamings {\n-    pub lib_name: String,\n+pub struct MultipleRenamings<'a> {\n+    pub lib_name: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -290,32 +295,32 @@ pub struct UnsupportedAbi {\n #[derive(SessionDiagnostic)]\n #[diag(metadata::fail_create_file_encoder)]\n pub struct FailCreateFileEncoder {\n-    pub err: String,\n+    pub err: Error,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::fail_seek_file)]\n pub struct FailSeekFile {\n-    pub err: String,\n+    pub err: Error,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::fail_write_file)]\n pub struct FailWriteFile {\n-    pub err: String,\n+    pub err: Error,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::crate_not_panic_runtime)]\n pub struct CrateNotPanicRuntime {\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::no_panic_strategy)]\n pub struct NoPanicStrategy {\n-    pub crate_name: String,\n-    pub strategy: String,\n+    pub crate_name: Symbol,\n+    pub strategy: PanicStrategy,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -325,7 +330,7 @@ pub struct ProfilerBuiltinsNeedsCore;\n #[derive(SessionDiagnostic)]\n #[diag(metadata::not_profiler_runtime)]\n pub struct NotProfilerRuntime {\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -341,8 +346,8 @@ pub struct NoMultipleGlobalAlloc {\n #[derive(SessionDiagnostic)]\n #[diag(metadata::conflicting_global_alloc)]\n pub struct ConflictingGlobalAlloc {\n-    pub crate_name: String,\n-    pub other_crate_name: String,\n+    pub crate_name: Symbol,\n+    pub other_crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -351,68 +356,68 @@ pub struct GlobalAllocRequired;\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::no_transitive_needs_dep)]\n-pub struct NoTransitiveNeedsDep {\n-    pub crate_name: String,\n-    pub needs_crate_name: String,\n-    pub deps_crate_name: String,\n+pub struct NoTransitiveNeedsDep<'a> {\n+    pub crate_name: Symbol,\n+    pub needs_crate_name: &'a str,\n+    pub deps_crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::failed_write_error)]\n pub struct FailedWriteError {\n-    pub filename: String,\n-    pub err: String,\n+    pub filename: PathBuf,\n+    pub err: Error,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::failed_create_tempdir)]\n pub struct FailedCreateTempdir {\n-    pub err: String,\n+    pub err: Error,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::failed_create_file)]\n-pub struct FailedCreateFile {\n-    pub filename: String,\n-    pub err: String,\n+pub struct FailedCreateFile<'a> {\n+    pub filename: &'a Path,\n+    pub err: Error,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::failed_create_encoded_metadata)]\n pub struct FailedCreateEncodedMetadata {\n-    pub err: String,\n+    pub err: Error,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::non_ascii_name)]\n pub struct NonAsciiName {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::extern_location_not_exist)]\n-pub struct ExternLocationNotExist {\n+pub struct ExternLocationNotExist<'a> {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n-    pub location: String,\n+    pub crate_name: Symbol,\n+    pub location: &'a Path,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::extern_location_not_file)]\n-pub struct ExternLocationNotFile {\n+pub struct ExternLocationNotFile<'a> {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n-    pub location: String,\n+    pub crate_name: Symbol,\n+    pub location: &'a Path,\n }\n \n-pub struct MultipleCandidates {\n+pub(crate) struct MultipleCandidates {\n     pub span: Span,\n-    pub flavor: String,\n-    pub crate_name: String,\n+    pub flavor: CrateFlavor,\n+    pub crate_name: Symbol,\n     pub candidates: Vec<PathBuf>,\n }\n \n@@ -424,7 +429,7 @@ impl SessionDiagnostic<'_> for MultipleCandidates {\n         let mut diag = sess.struct_err(rustc_errors::fluent::metadata::multiple_candidates);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"flavor\", self.flavor);\n-        diag.code(DiagnosticId::Error(\"E0465\".into()));\n+        diag.code(error_code!(E0465));\n         diag.set_span(self.span);\n         for (i, candidate) in self.candidates.iter().enumerate() {\n             diag.span_note(self.span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n@@ -439,7 +444,7 @@ impl SessionDiagnostic<'_> for MultipleCandidates {\n pub struct MultipleMatchingCrates {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n     pub candidates: String,\n }\n \n@@ -448,24 +453,24 @@ pub struct MultipleMatchingCrates {\n pub struct SymbolConflictsCurrent {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::symbol_conflicts_others, code = \"E0523\")]\n pub struct SymbolConflictsOthers {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::stable_crate_id_collision)]\n pub struct StableCrateIdCollision {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name0: String,\n-    pub crate_name1: String,\n+    pub crate_name0: Symbol,\n+    pub crate_name1: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n@@ -483,19 +488,19 @@ pub struct DlError {\n pub struct NewerCrateVersion {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n     pub add_info: String,\n     pub found_crates: String,\n }\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::no_crate_with_triple, code = \"E0461\")]\n #[note(metadata::found_crate_versions)]\n-pub struct NoCrateWithTriple {\n+pub struct NoCrateWithTriple<'a> {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n-    pub locator_triple: String,\n+    pub crate_name: Symbol,\n+    pub locator_triple: &'a str,\n     pub add_info: String,\n     pub found_crates: String,\n }\n@@ -507,7 +512,7 @@ pub struct NoCrateWithTriple {\n pub struct FoundStaticlib {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n     pub add_info: String,\n     pub found_crates: String,\n }\n@@ -519,15 +524,15 @@ pub struct FoundStaticlib {\n pub struct IncompatibleRustc {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n     pub add_info: String,\n     pub found_crates: String,\n     pub rustc_version: String,\n }\n \n pub struct InvalidMetadataFiles {\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n     pub add_info: String,\n     pub crate_rejections: Vec<String>,\n }\n@@ -540,7 +545,7 @@ impl SessionDiagnostic<'_> for InvalidMetadataFiles {\n         let mut diag = sess.struct_err(rustc_errors::fluent::metadata::invalid_meta_files);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"add_info\", self.add_info);\n-        diag.code(DiagnosticId::Error(\"E0786\".into()));\n+        diag.code(error_code!(E0786));\n         diag.set_span(self.span);\n         for crate_rejection in self.crate_rejections {\n             diag.note(crate_rejection);\n@@ -551,8 +556,7 @@ impl SessionDiagnostic<'_> for InvalidMetadataFiles {\n \n pub struct CannotFindCrate {\n     pub span: Span,\n-    pub crate_name: String,\n-    pub crate_name_symbol: Symbol,\n+    pub crate_name: Symbol,\n     pub add_info: String,\n     pub missing_core: bool,\n     pub current_crate: String,\n@@ -567,53 +571,41 @@ impl SessionDiagnostic<'_> for CannotFindCrate {\n         sess: &'_ rustc_session::parse::ParseSess,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut diag = sess.struct_err(rustc_errors::fluent::metadata::cannot_find_crate);\n-        diag.set_arg(\"crate_name\", self.crate_name.clone());\n+        diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"add_info\", self.add_info);\n-        diag.code(DiagnosticId::Error(\"E0463\".into()));\n+        diag.set_arg(\"locator_triple\", self.locator_triple.triple());\n+        diag.code(error_code!(E0463));\n         diag.set_span(self.span);\n-        // FIXME: Find a way to distill this logic down into the derived SessionDiagnostic form\n-        if (self.crate_name_symbol == sym::std || self.crate_name_symbol == sym::core)\n+        if (self.crate_name == sym::std || self.crate_name == sym::core)\n             && self.locator_triple != TargetTriple::from_triple(config::host_triple())\n         {\n             if self.missing_core {\n-                diag.note(&format!(\"the `{}` target may not be installed\", self.locator_triple));\n+                diag.note(rustc_errors::fluent::metadata::target_not_installed);\n             } else {\n-                diag.note(&format!(\n-                    \"the `{}` target may not support the standard library\",\n-                    self.locator_triple\n-                ));\n+                diag.note(rustc_errors::fluent::metadata::target_no_std_support);\n             }\n             // NOTE: this suggests using rustup, even though the user may not have it installed.\n             // That's because they could choose to install it; or this may give them a hint which\n             // target they need to install from their distro.\n             if self.missing_core {\n-                diag.help(&format!(\n-                    \"consider downloading the target with `rustup target add {}`\",\n-                    self.locator_triple\n-                ));\n+                diag.help(rustc_errors::fluent::metadata::consider_downloading_target);\n             }\n             // Suggest using #![no_std]. #[no_core] is unstable and not really supported anyway.\n             // NOTE: this is a dummy span if `extern crate std` was injected by the compiler.\n             // If it's not a dummy, that means someone added `extern crate std` explicitly and\n             // `#![no_std]` won't help.\n             if !self.missing_core && self.span.is_dummy() {\n-                diag.note(&format!(\n-                    \"`std` is required by `{}` because it does not declare `#![no_std]`\",\n-                    self.current_crate\n-                ));\n+                diag.note(rustc_errors::fluent::metadata::std_required);\n             }\n             if self.is_nightly_build {\n-                diag.help(\"consider building the standard library from source with `cargo build -Zbuild-std`\");\n+                diag.help(rustc_errors::fluent::metadata::consider_building_std);\n             }\n-        } else if self.crate_name_symbol == self.profiler_runtime {\n-            diag.note(\"the compiler may have been built without the profiler runtime\");\n-        } else if self.crate_name.starts_with(\"rustc_\") {\n-            diag.help(\n-                \"maybe you need to install the missing components with: \\\n-                             `rustup component add rust-src rustc-dev llvm-tools-preview`\",\n-            );\n+        } else if self.crate_name == self.profiler_runtime {\n+            diag.note(rustc_errors::fluent::metadata::compiler_missing_profiler);\n+        } else if self.crate_name.as_str().starts_with(\"rustc_\") {\n+            diag.help(rustc_errors::fluent::metadata::install_missing_components);\n         }\n-        diag.span_label(self.span, \"can't find crate\");\n+        diag.span_label(self.span, rustc_errors::fluent::metadata::cant_find_crate);\n         diag\n     }\n }\n@@ -623,5 +615,22 @@ impl SessionDiagnostic<'_> for CannotFindCrate {\n pub struct NoDylibPlugin {\n     #[primary_span]\n     pub span: Span,\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::crate_location_unknown_type)]\n+pub struct CrateLocationUnknownType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub path: &'a Path,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::lib_filename_form)]\n+pub struct LibFilenameForm<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub dll_prefix: &'a str,\n+    pub dll_suffix: &'a str,\n }"}, {"sha": "f360a586476e70bf4a2e9da3bd4426351d834880", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -26,11 +26,8 @@ pub fn emit_metadata(sess: &Session, metadata: &[u8], tmpdir: &MaybeTempDir) ->\n     let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n     let result = fs::write(&out_filename, metadata);\n \n-    if let Err(e) = result {\n-        sess.emit_fatal(FailedWriteError {\n-            filename: out_filename.display().to_string(),\n-            err: e.to_string(),\n-        });\n+    if let Err(err) = result {\n+        sess.emit_fatal(FailedWriteError { filename: out_filename, err });\n     }\n \n     out_filename\n@@ -71,19 +68,16 @@ pub fn encode_and_write_metadata(\n     let metadata_tmpdir = TempFileBuilder::new()\n         .prefix(\"rmeta\")\n         .tempdir_in(out_filename.parent().unwrap_or_else(|| Path::new(\"\")))\n-        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailedCreateTempdir { err: err.to_string() }));\n+        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailedCreateTempdir { err }));\n     let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n     let metadata_filename = metadata_tmpdir.as_ref().join(METADATA_FILENAME);\n \n     // Always create a file at `metadata_filename`, even if we have nothing to write to it.\n     // This simplifies the creation of the output `out_filename` when requested.\n     match metadata_kind {\n         MetadataKind::None => {\n-            std::fs::File::create(&metadata_filename).unwrap_or_else(|e| {\n-                tcx.sess.emit_fatal(FailedCreateFile {\n-                    filename: metadata_filename.display().to_string(),\n-                    err: e.to_string(),\n-                });\n+            std::fs::File::create(&metadata_filename).unwrap_or_else(|err| {\n+                tcx.sess.emit_fatal(FailedCreateFile { filename: &metadata_filename, err });\n             });\n         }\n         MetadataKind::Uncompressed | MetadataKind::Compressed => {\n@@ -98,11 +92,8 @@ pub fn encode_and_write_metadata(\n     // this file always exists.\n     let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n     let (metadata_filename, metadata_tmpdir) = if need_metadata_file {\n-        if let Err(e) = non_durable_rename(&metadata_filename, &out_filename) {\n-            tcx.sess.emit_fatal(FailedWriteError {\n-                filename: out_filename.display().to_string(),\n-                err: e.to_string(),\n-            });\n+        if let Err(err) = non_durable_rename(&metadata_filename, &out_filename) {\n+            tcx.sess.emit_fatal(FailedWriteError { filename: out_filename, err });\n         }\n         if tcx.sess.opts.json_artifact_notifications {\n             tcx.sess\n@@ -117,8 +108,8 @@ pub fn encode_and_write_metadata(\n \n     // Load metadata back to memory: codegen may need to include it in object files.\n     let metadata =\n-        EncodedMetadata::from_path(metadata_filename, metadata_tmpdir).unwrap_or_else(|e| {\n-            tcx.sess.emit_fatal(FailedCreateEncodedMetadata { err: e.to_string() });\n+        EncodedMetadata::from_path(metadata_filename, metadata_tmpdir).unwrap_or_else(|err| {\n+            tcx.sess.emit_fatal(FailedCreateEncodedMetadata { err });\n         });\n \n     let need_metadata_module = metadata_kind == MetadataKind::Compressed;"}, {"sha": "5edad819e7e3c2ca95f94bb4df90a17518c2650f", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 42, "deletions": 60, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -214,10 +214,11 @@\n \n use crate::creader::Library;\n use crate::errors::{\n-    CannotFindCrate, DlError, ExternLocationNotExist, ExternLocationNotFile, FoundStaticlib,\n-    IncompatibleRustc, InvalidMetadataFiles, MultipleCandidates, MultipleMatchingCrates,\n-    NewerCrateVersion, NoCrateWithTriple, NoDylibPlugin, NonAsciiName, StableCrateIdCollision,\n-    SymbolConflictsCurrent, SymbolConflictsOthers,\n+    CannotFindCrate, CrateLocationUnknownType, DlError, ExternLocationNotExist,\n+    ExternLocationNotFile, FoundStaticlib, IncompatibleRustc, InvalidMetadataFiles,\n+    LibFilenameForm, MultipleCandidates, MultipleMatchingCrates, NewerCrateVersion,\n+    NoCrateWithTriple, NoDylibPlugin, NonAsciiName, StableCrateIdCollision, SymbolConflictsCurrent,\n+    SymbolConflictsOthers,\n };\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n@@ -226,7 +227,7 @@ use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc_errors::FatalError;\n+use rustc_errors::{DiagnosticArgValue, FatalError, IntoDiagnosticArg};\n use rustc_session::config::{self, CrateType};\n use rustc_session::cstore::{CrateSource, MetadataLoader};\n use rustc_session::filesearch::FileSearch;\n@@ -238,6 +239,7 @@ use rustc_span::Span;\n use rustc_target::spec::{Target, TargetTriple};\n \n use snap::read::FrameDecoder;\n+use std::borrow::Cow;\n use std::fmt::Write as _;\n use std::io::{Read, Result as IoResult, Write};\n use std::path::{Path, PathBuf};\n@@ -294,6 +296,16 @@ impl fmt::Display for CrateFlavor {\n     }\n }\n \n+impl IntoDiagnosticArg for CrateFlavor {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        match self {\n+            CrateFlavor::Rlib => DiagnosticArgValue::Str(Cow::Borrowed(\"rlib\")),\n+            CrateFlavor::Rmeta => DiagnosticArgValue::Str(Cow::Borrowed(\"rmeta\")),\n+            CrateFlavor::Dylib => DiagnosticArgValue::Str(Cow::Borrowed(\"dylib\")),\n+        }\n+    }\n+}\n+\n impl<'a> CrateLocator<'a> {\n     pub(crate) fn new(\n         sess: &'a Session,\n@@ -946,29 +958,16 @@ impl CrateError {\n     pub(crate) fn report(self, sess: &Session, span: Span, missing_core: bool) {\n         match self {\n             CrateError::NonAsciiName(crate_name) => {\n-                sess.emit_err(NonAsciiName { span, crate_name: crate_name.to_string() });\n+                sess.emit_err(NonAsciiName { span, crate_name });\n             }\n             CrateError::ExternLocationNotExist(crate_name, loc) => {\n-                sess.emit_err(ExternLocationNotExist {\n-                    span,\n-                    crate_name: crate_name.to_string(),\n-                    location: loc.display().to_string(),\n-                });\n+                sess.emit_err(ExternLocationNotExist { span, crate_name, location: &loc });\n             }\n             CrateError::ExternLocationNotFile(crate_name, loc) => {\n-                sess.emit_err(ExternLocationNotFile {\n-                    span,\n-                    crate_name: crate_name.to_string(),\n-                    location: loc.display().to_string(),\n-                });\n+                sess.emit_err(ExternLocationNotFile { span, crate_name, location: &loc });\n             }\n             CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n-                sess.emit_err(MultipleCandidates {\n-                    span,\n-                    flavor: flavor.to_string(),\n-                    crate_name: crate_name.to_string(),\n-                    candidates,\n-                });\n+                sess.emit_err(MultipleCandidates { span, flavor: flavor, crate_name, candidates });\n             }\n             CrateError::MultipleMatchingCrates(crate_name, libraries) => {\n                 let mut libraries: Vec<_> = libraries.into_values().collect();\n@@ -998,52 +997,41 @@ impl CrateError {\n                         s\n                     })\n                     .collect::<String>();\n-                sess.emit_err(MultipleMatchingCrates {\n-                    span,\n-                    crate_name: crate_name.to_string(),\n-                    candidates,\n-                });\n+                sess.emit_err(MultipleMatchingCrates { span, crate_name, candidates });\n             }\n             CrateError::SymbolConflictsCurrent(root_name) => {\n-                sess.emit_err(SymbolConflictsCurrent { span, crate_name: root_name.to_string() });\n+                sess.emit_err(SymbolConflictsCurrent { span, crate_name: root_name });\n             }\n             CrateError::SymbolConflictsOthers(root_name) => {\n-                sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name.to_string() });\n+                sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name });\n             }\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n                 sess.emit_err(StableCrateIdCollision {\n                     span,\n-                    crate_name0: crate_name0.to_string(),\n-                    crate_name1: crate_name1.to_string(),\n+                    crate_name0: crate_name0,\n+                    crate_name1: crate_name1,\n                 });\n             }\n             CrateError::DlOpen(s) | CrateError::DlSym(s) => {\n-                sess.emit_err(DlError { span, err: s.to_string() });\n+                sess.emit_err(DlError { span, err: s });\n             }\n             CrateError::LocatorCombined(locator) => {\n                 let crate_name = locator.crate_name;\n                 let add_info = match &locator.root {\n                     None => String::new(),\n                     Some(r) => format!(\" which `{}` depends on\", r.name),\n                 };\n-                // FIXME: Is there any way to get these notes and helps onto every diagnostic in this\n-                // huge branch arm without changing them all to manual implementations?\n-                let mut global_loc_notes = Vec::new();\n-                let mut global_loc_helps = Vec::new();\n+                // FIXME: There are no tests for CrateLocationUnknownType or LibFilenameForm\n                 if !locator.crate_rejections.via_filename.is_empty() {\n                     let mismatches = locator.crate_rejections.via_filename.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        global_loc_notes.push(format!(\n-                            \"extern location for {} is of an unknown type: {}\",\n-                            crate_name,\n-                            path.display(),\n-                        ));\n-                        global_loc_helps.push(format!(\n-                            \"file name should be lib*.rlib or {}*.{}\",\n-                            locator.dll_prefix, locator.dll_suffix\n-                        ));\n+                        sess.emit_err(CrateLocationUnknownType { span, path: &path });\n+                        sess.emit_err(LibFilenameForm {\n+                            span,\n+                            dll_prefix: &locator.dll_prefix,\n+                            dll_suffix: &locator.dll_suffix,\n+                        });\n                     }\n-                    panic!(\"!!!!! REVERT THIS COMMIT !!!!!\");\n                 }\n                 let mut found_crates = String::new();\n                 if !locator.crate_rejections.via_hash.is_empty() {\n@@ -1066,7 +1054,7 @@ impl CrateError {\n                     }\n                     sess.emit_err(NewerCrateVersion {\n                         span,\n-                        crate_name: crate_name.to_string(),\n+                        crate_name: crate_name,\n                         add_info,\n                         found_crates,\n                     });\n@@ -1082,8 +1070,8 @@ impl CrateError {\n                     }\n                     sess.emit_err(NoCrateWithTriple {\n                         span,\n-                        crate_name: crate_name.to_string(),\n-                        locator_triple: locator.triple.to_string(),\n+                        crate_name: crate_name,\n+                        locator_triple: locator.triple.triple(),\n                         add_info,\n                         found_crates,\n                     });\n@@ -1096,12 +1084,7 @@ impl CrateError {\n                             path.display()\n                         ));\n                     }\n-                    sess.emit_err(FoundStaticlib {\n-                        span,\n-                        crate_name: crate_name.to_string(),\n-                        add_info,\n-                        found_crates,\n-                    });\n+                    sess.emit_err(FoundStaticlib { span, crate_name, add_info, found_crates });\n                 } else if !locator.crate_rejections.via_version.is_empty() {\n                     let mismatches = locator.crate_rejections.via_version.iter();\n                     for CrateMismatch { path, got } in mismatches {\n@@ -1114,7 +1097,7 @@ impl CrateError {\n                     }\n                     sess.emit_err(IncompatibleRustc {\n                         span,\n-                        crate_name: crate_name.to_string(),\n+                        crate_name,\n                         add_info,\n                         found_crates,\n                         rustc_version: rustc_version(),\n@@ -1126,15 +1109,14 @@ impl CrateError {\n                     }\n                     sess.emit_err(InvalidMetadataFiles {\n                         span,\n-                        crate_name: crate_name.to_string(),\n+                        crate_name,\n                         add_info,\n                         crate_rejections,\n                     });\n                 } else {\n                     sess.emit_err(CannotFindCrate {\n                         span,\n-                        crate_name: crate_name.to_string(),\n-                        crate_name_symbol: crate_name,\n+                        crate_name,\n                         add_info,\n                         missing_core,\n                         current_crate: sess\n@@ -1149,7 +1131,7 @@ impl CrateError {\n                 }\n             }\n             CrateError::NonDylibPlugin(crate_name) => {\n-                sess.emit_err(NoDylibPlugin { span, crate_name: crate_name.to_string() });\n+                sess.emit_err(NoDylibPlugin { span, crate_name });\n             }\n         }\n     }"}, {"sha": "19f64ef70c9c64773a4d60b777877d07e3e917b5", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> Collector<'tcx> {\n                                 NativeLibKind::RawDylib\n                             }\n                             kind => {\n-                                sess.emit_err(UnknownLinkKind { span, kind: kind.to_string() });\n+                                sess.emit_err(UnknownLinkKind { span, kind });\n                                 continue;\n                             }\n                         };\n@@ -249,10 +249,7 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     let assign_modifier = |dst: &mut Option<bool>| {\n                         if dst.is_some() {\n-                            sess.emit_err(MultipleModifiers {\n-                                span,\n-                                modifier: modifier.to_string(),\n-                            });\n+                            sess.emit_err(MultipleModifiers { span, modifier });\n                         } else {\n                             *dst = Some(value);\n                         }\n@@ -287,10 +284,7 @@ impl<'tcx> Collector<'tcx> {\n                         }\n \n                         _ => {\n-                            sess.emit_err(UnknownLinkModifier {\n-                                span,\n-                                modifier: modifier.to_string(),\n-                            });\n+                            sess.emit_err(UnknownLinkModifier { span, modifier });\n                         }\n                     }\n                 }\n@@ -379,11 +373,11 @@ impl<'tcx> Collector<'tcx> {\n                     .filter_map(|lib| lib.name.as_ref())\n                     .any(|n| n.as_str() == lib.name);\n                 if new_name.is_empty() {\n-                    self.tcx.sess.emit_err(EmptyRenamingTarget { lib_name: lib.name.clone() });\n+                    self.tcx.sess.emit_err(EmptyRenamingTarget { lib_name: &lib.name });\n                 } else if !any_duplicate {\n-                    self.tcx.sess.emit_err(RenamingNoLink { lib_name: lib.name.clone() });\n+                    self.tcx.sess.emit_err(RenamingNoLink { lib_name: &lib.name });\n                 } else if !renames.insert(&lib.name) {\n-                    self.tcx.sess.emit_err(MultipleRenamings { lib_name: lib.name.clone() });\n+                    self.tcx.sess.emit_err(MultipleRenamings { lib_name: &lib.name });\n                 }\n             }\n         }"}, {"sha": "8f55fb59f0bf84b21d07e723244d4cb27d6c8ccd", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d65819d529f222e47164f6c8132d8134909f2a4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0d65819d529f222e47164f6c8132d8134909f2a4", "patch": "@@ -2270,7 +2270,7 @@ pub fn encode_metadata(tcx: TyCtxt<'_>, path: &Path) {\n \n fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n     let mut encoder = opaque::FileEncoder::new(path)\n-        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailCreateFileEncoder { err: err.to_string() }));\n+        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailCreateFileEncoder { err }));\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n     // Will be filled with the root position after encoding everything.\n@@ -2315,10 +2315,10 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>, path: &Path) {\n     // Encode the root position.\n     let header = METADATA_HEADER.len();\n     file.seek(std::io::SeekFrom::Start(header as u64))\n-        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailSeekFile { err: err.to_string() }));\n+        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailSeekFile { err }));\n     let pos = root.position.get();\n     file.write_all(&[(pos >> 24) as u8, (pos >> 16) as u8, (pos >> 8) as u8, (pos >> 0) as u8])\n-        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailWriteFile { err: err.to_string() }));\n+        .unwrap_or_else(|err| tcx.sess.emit_fatal(FailWriteFile { err }));\n \n     // Return to the position where we are before writing the root position.\n     file.seek(std::io::SeekFrom::Start(pos_before_seek)).unwrap();"}]}