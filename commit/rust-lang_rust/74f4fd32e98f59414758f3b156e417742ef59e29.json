{"sha": "74f4fd32e98f59414758f3b156e417742ef59e29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZjRmZDMyZTk4ZjU5NDE0NzU4ZjNiMTU2ZTQxNzc0MmVmNTllMjk=", "commit": {"author": {"name": "Laura Peskin", "email": "laura.peskin@gmail.com", "date": "2017-08-30T14:38:13Z"}, "committer": {"name": "Laura Peskin", "email": "laura.peskin@gmail.com", "date": "2017-09-24T19:40:16Z"}, "message": "attempt to add check for mutation of range bound within loop; compiles but doesn't work as intended. pushed for feedback", "tree": {"sha": "aad7016b94252e10d4767d5c8c076921e599597b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aad7016b94252e10d4767d5c8c076921e599597b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74f4fd32e98f59414758f3b156e417742ef59e29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74f4fd32e98f59414758f3b156e417742ef59e29", "html_url": "https://github.com/rust-lang/rust/commit/74f4fd32e98f59414758f3b156e417742ef59e29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74f4fd32e98f59414758f3b156e417742ef59e29/comments", "author": {"login": "lpesk", "id": 7589231, "node_id": "MDQ6VXNlcjc1ODkyMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/7589231?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lpesk", "html_url": "https://github.com/lpesk", "followers_url": "https://api.github.com/users/lpesk/followers", "following_url": "https://api.github.com/users/lpesk/following{/other_user}", "gists_url": "https://api.github.com/users/lpesk/gists{/gist_id}", "starred_url": "https://api.github.com/users/lpesk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lpesk/subscriptions", "organizations_url": "https://api.github.com/users/lpesk/orgs", "repos_url": "https://api.github.com/users/lpesk/repos", "events_url": "https://api.github.com/users/lpesk/events{/privacy}", "received_events_url": "https://api.github.com/users/lpesk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lpesk", "id": 7589231, "node_id": "MDQ6VXNlcjc1ODkyMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/7589231?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lpesk", "html_url": "https://github.com/lpesk", "followers_url": "https://api.github.com/users/lpesk/followers", "following_url": "https://api.github.com/users/lpesk/following{/other_user}", "gists_url": "https://api.github.com/users/lpesk/gists{/gist_id}", "starred_url": "https://api.github.com/users/lpesk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lpesk/subscriptions", "organizations_url": "https://api.github.com/users/lpesk/orgs", "repos_url": "https://api.github.com/users/lpesk/repos", "events_url": "https://api.github.com/users/lpesk/events{/privacy}", "received_events_url": "https://api.github.com/users/lpesk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "319f12a4c4d290b12a6d7396e8592391d4fcb1a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/319f12a4c4d290b12a6d7396e8592391d4fcb1a9", "html_url": "https://github.com/rust-lang/rust/commit/319f12a4c4d290b12a6d7396e8592391d4fcb1a9"}], "stats": {"total": 62, "additions": 54, "deletions": 8}, "files": [{"sha": "a40278982ab4a0c826519da7dafb9e09495c8a9b", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/74f4fd32e98f59414758f3b156e417742ef59e29/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f4fd32e98f59414758f3b156e417742ef59e29/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=74f4fd32e98f59414758f3b156e417742ef59e29", "patch": "@@ -7,11 +7,15 @@ use rustc::hir::map::Node::{NodeBlock, NodeExpr, NodeStmt};\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n+use rustc::middle::region::CodeExtent;\n+use rustc::middle::expr_use_visitor::*;\n+use rustc::middle::mem_categorization::cmt;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Subst, Substs};\n use rustc_const_eval::ConstContext;\n use std::collections::{HashMap, HashSet};\n use syntax::ast;\n+use syntax::codemap::Span;\n use utils::sugg;\n use utils::const_to_u64;\n \n@@ -614,7 +618,7 @@ fn check_for_loop<'a, 'tcx>(\n     check_for_loop_arg(cx, pat, arg, expr);\n     check_for_loop_explicit_counter(cx, arg, body, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n-    check_for_mut_range_bound(cx, arg, expr);\n+    check_for_mut_range_bound(cx, arg, body, expr);\n     detect_manual_memcpy(cx, pat, arg, body, expr);\n }\n \n@@ -1304,37 +1308,79 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     }\n }\n \n-fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, expr: &Expr) {\n+// TODO: clippy builds, but the `mutate` method of `Delegate` is never called when compiling `tests/run-pass/mut_range_bound_tmp.rs`. what's wrong? \n+\n+struct MutateDelegate<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    node_id: NodeId,\n+    was_mutated: bool\n+}\n+\n+impl<'a, 'tcx> Delegate<'tcx> for MutateDelegate<'a, 'tcx> {\n+    fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n+    }\n+  \n+    fn matched_pat(&mut self, matched_pat: &Pat, cmt: cmt<'tcx>, mode: MatchMode) {\n+    }\n+\n+    fn consume_pat(&mut self, consume_pat: &Pat, cmt: cmt<'tcx>, mode: ConsumeMode) {\n+    }\n+\n+    fn borrow(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ty::Region, _: ty::BorrowKind, _: LoanCause) {        \n+    }\n+\n+    fn mutate(&mut self, assignment_id: NodeId, _: Span, _: cmt<'tcx>, _: MutateMode) {\n+        println!(\"something was mutated\"); // tmp: see if this function is ever called at all (no)\n+        if assignment_id == self.node_id {\n+            self.was_mutated = true;\n+        }\n+    }\n+\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {\n+    }\n+}\n+\n+impl<'a, 'tcx> MutateDelegate<'a, 'tcx> {\n+    fn bound_was_mutated(&self) -> bool {\n+        self.was_mutated\n+    }\n+}\n+\n+fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr,  expr: &Expr) {\n     if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(arg) {\n         let bounds = vec![start, end];\n         for bound in &bounds {\n-            if check_for_mutability(cx, bound) {\n+            if check_for_mutation(cx, body, bound) {\n                 span_lint(cx, MUT_RANGE_BOUND, expr.span, \"you are looping over a range where at least one bound was defined as a mutable variable. keep in mind that mutating this variable inside the loop will not affect the range\");   \n                 return;\n             }\n         }\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext, bound: &Expr) -> bool {\n+fn check_for_mutation(cx: &LateContext, body: &Expr, bound: &Expr) -> bool {\n     if_let_chain! {[\n         let ExprPath(ref qpath) = bound.node,\n         let QPath::Resolved(None, ref path) = *qpath,\n-        path.segments.len() == 1,\n     ], {\n         let def = cx.tables.qpath_def(qpath, bound.id);\n         match def {\n             Def::Local(..) | Def::Upvar(..) => {\n                 let def_id = def.def_id();\n                 let node_id = cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n                 let node_str = cx.tcx.hir.get(node_id);\n-                if_let_chain! {[\n+                if_let_chain! {[ // prob redundant now, remove\n                     let map::Node::NodeLocal(pat) = node_str,\n                     let PatKind::Binding(bind_ann, _, _, _) = pat.node,\n                     let BindingAnnotation::Mutable = bind_ann,\n+                    \n                 ], {\n-                    return true;\n-                }} \n+                    println!(\"bound was mutable\"); // tmp: make sure the full if-let chain executes when it should (yes)\n+                    let mut delegate = MutateDelegate { cx: cx, node_id: node_id, was_mutated: false };\n+                    let region_maps = &cx.tcx.region_maps(def_id); // is this the correct argument?\n+                    ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_maps, cx.tables).walk_expr(body);\n+                    return delegate.bound_was_mutated();\n+                }}\n             },\n             _ => (),\n         }}"}]}