{"sha": "c196b8abaafaf360647513c64fac0c8568f9b747", "node_id": "C_kwDOAAsO6NoAKGMxOTZiOGFiYWFmYWYzNjA2NDc1MTNjNjRmYWMwYzg1NjhmOWI3NDc", "commit": {"author": {"name": "Jacob Lifshay", "email": "programmerjake@gmail.com", "date": "2022-03-11T22:49:06Z"}, "committer": {"name": "Jacob Lifshay", "email": "programmerjake@gmail.com", "date": "2022-03-11T22:49:06Z"}, "message": "replace horizontal_* with reduce_*", "tree": {"sha": "cc2e53e98244b27a7fbb98dce9d00f7f43acf196", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc2e53e98244b27a7fbb98dce9d00f7f43acf196"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c196b8abaafaf360647513c64fac0c8568f9b747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c196b8abaafaf360647513c64fac0c8568f9b747", "html_url": "https://github.com/rust-lang/rust/commit/c196b8abaafaf360647513c64fac0c8568f9b747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c196b8abaafaf360647513c64fac0c8568f9b747/comments", "author": {"login": "programmerjake", "id": 4584340, "node_id": "MDQ6VXNlcjQ1ODQzNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4584340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/programmerjake", "html_url": "https://github.com/programmerjake", "followers_url": "https://api.github.com/users/programmerjake/followers", "following_url": "https://api.github.com/users/programmerjake/following{/other_user}", "gists_url": "https://api.github.com/users/programmerjake/gists{/gist_id}", "starred_url": "https://api.github.com/users/programmerjake/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/programmerjake/subscriptions", "organizations_url": "https://api.github.com/users/programmerjake/orgs", "repos_url": "https://api.github.com/users/programmerjake/repos", "events_url": "https://api.github.com/users/programmerjake/events{/privacy}", "received_events_url": "https://api.github.com/users/programmerjake/received_events", "type": "User", "site_admin": false}, "committer": {"login": "programmerjake", "id": 4584340, "node_id": "MDQ6VXNlcjQ1ODQzNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4584340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/programmerjake", "html_url": "https://github.com/programmerjake", "followers_url": "https://api.github.com/users/programmerjake/followers", "following_url": "https://api.github.com/users/programmerjake/following{/other_user}", "gists_url": "https://api.github.com/users/programmerjake/gists{/gist_id}", "starred_url": "https://api.github.com/users/programmerjake/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/programmerjake/subscriptions", "organizations_url": "https://api.github.com/users/programmerjake/orgs", "repos_url": "https://api.github.com/users/programmerjake/repos", "events_url": "https://api.github.com/users/programmerjake/events{/privacy}", "received_events_url": "https://api.github.com/users/programmerjake/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b9f69622badf863df71993e8b1e3468cf92eeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b9f69622badf863df71993e8b1e3468cf92eeb", "html_url": "https://github.com/rust-lang/rust/commit/86b9f69622badf863df71993e8b1e3468cf92eeb"}], "stats": {"total": 102, "additions": 51, "deletions": 51}, "files": [{"sha": "39f530f68f57a3bb241eb95e1771bf0a5aabe88a", "filename": "crates/core_simd/examples/matrix_inversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs?ref=c196b8abaafaf360647513c64fac0c8568f9b747", "patch": "@@ -233,7 +233,7 @@ pub fn simd_inv4x4(m: Matrix4x4) -> Option<Matrix4x4> {\n     let det = det.rotate_lanes_right::<2>() + det;\n     let det = det.reverse().rotate_lanes_right::<2>() + det;\n \n-    if det.horizontal_sum() == 0. {\n+    if det.reduce_sum() == 0. {\n         return None;\n     }\n     // calculate the reciprocal"}, {"sha": "664a0454bbd09522948db8abbdc4cefbe5cec876", "filename": "crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=c196b8abaafaf360647513c64fac0c8568f9b747", "patch": "@@ -107,10 +107,10 @@ mod nbody {\n         let mut e = 0.;\n         for i in 0..N_BODIES {\n             let bi = &bodies[i];\n-            e += bi.mass * (bi.v * bi.v).horizontal_sum() * 0.5;\n+            e += bi.mass * (bi.v * bi.v).reduce_sum() * 0.5;\n             for bj in bodies.iter().take(N_BODIES).skip(i + 1) {\n                 let dx = bi.x - bj.x;\n-                e -= bi.mass * bj.mass / (dx * dx).horizontal_sum().sqrt()\n+                e -= bi.mass * bj.mass / (dx * dx).reduce_sum().sqrt()\n             }\n         }\n         e\n@@ -134,8 +134,8 @@ mod nbody {\n         let mut mag = [0.0; N];\n         for i in (0..N).step_by(2) {\n             let d2s = f64x2::from_array([\n-                (r[i] * r[i]).horizontal_sum(),\n-                (r[i + 1] * r[i + 1]).horizontal_sum(),\n+                (r[i] * r[i]).reduce_sum(),\n+                (r[i + 1] * r[i + 1]).reduce_sum(),\n             ]);\n             let dmags = f64x2::splat(dt) / (d2s * d2s.sqrt());\n             mag[i] = dmags[0];"}, {"sha": "012182e090b9f1b2ab3bef92a654a6bfd7ec0837", "filename": "crates/core_simd/examples/spectral_norm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs?ref=c196b8abaafaf360647513c64fac0c8568f9b747", "patch": "@@ -20,7 +20,7 @@ fn mult_av(v: &[f64], out: &mut [f64]) {\n             sum += b / a;\n             j += 2\n         }\n-        *out = sum.horizontal_sum();\n+        *out = sum.reduce_sum();\n     }\n }\n \n@@ -38,7 +38,7 @@ fn mult_atv(v: &[f64], out: &mut [f64]) {\n             sum += b / a;\n             j += 2\n         }\n-        *out = sum.horizontal_sum();\n+        *out = sum.reduce_sum();\n     }\n }\n "}, {"sha": "3177fd167fc44bcf2ad168503d1b6d7fd96190ef", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=c196b8abaafaf360647513c64fac0c8568f9b747", "patch": "@@ -11,30 +11,30 @@ macro_rules! impl_integer_reductions {\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n+            /// Reducing wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n-            pub fn horizontal_sum(self) -> $scalar {\n+            pub fn reduce_sum(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_add_ordered(self, 0) }\n             }\n \n-            /// Horizontal wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n+            /// Reducing wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n             #[inline]\n-            pub fn horizontal_product(self) -> $scalar {\n+            pub fn reduce_product(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_mul_ordered(self, 1) }\n             }\n \n-            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            /// Reducing maximum.  Returns the maximum lane in the vector.\n             #[inline]\n-            pub fn horizontal_max(self) -> $scalar {\n+            pub fn reduce_max(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n-            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            /// Reducing minimum.  Returns the minimum lane in the vector.\n             #[inline]\n-            pub fn horizontal_min(self) -> $scalar {\n+            pub fn reduce_min(self) -> $scalar {\n                 // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_min(self) }\n             }\n@@ -60,9 +60,9 @@ macro_rules! impl_float_reductions {\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n \n-            /// Horizontal add.  Returns the sum of the lanes of the vector.\n+            /// Reducing add.  Returns the sum of the lanes of the vector.\n             #[inline]\n-            pub fn horizontal_sum(self) -> $scalar {\n+            pub fn reduce_sum(self) -> $scalar {\n                 // LLVM sum is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().sum()\n@@ -72,9 +72,9 @@ macro_rules! impl_float_reductions {\n                 }\n             }\n \n-            /// Horizontal multiply.  Returns the product of the lanes of the vector.\n+            /// Reducing multiply.  Returns the product of the lanes of the vector.\n             #[inline]\n-            pub fn horizontal_product(self) -> $scalar {\n+            pub fn reduce_product(self) -> $scalar {\n                 // LLVM product is inaccurate on i586\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().product()\n@@ -84,22 +84,22 @@ macro_rules! impl_float_reductions {\n                 }\n             }\n \n-            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            /// Reducing maximum.  Returns the maximum lane in the vector.\n             ///\n             /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n-            pub fn horizontal_max(self) -> $scalar {\n+            pub fn reduce_max(self) -> $scalar {\n                 // Safety: `self` is a float vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n-            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            /// Reducing minimum.  Returns the minimum lane in the vector.\n             ///\n             /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n-            pub fn horizontal_min(self) -> $scalar {\n+            pub fn reduce_min(self) -> $scalar {\n                 // Safety: `self` is a float vector\n                 unsafe { simd_reduce_min(self) }\n             }\n@@ -116,10 +116,10 @@ where\n     T: SimdElement + BitAnd<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n+    /// Reducing bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_and(self) -> T {\n+    pub fn reduce_and(self) -> T {\n         unsafe { simd_reduce_and(self) }\n     }\n }\n@@ -130,10 +130,10 @@ where\n     T: SimdElement + BitOr<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n+    /// Reducing bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_or(self) -> T {\n+    pub fn reduce_or(self) -> T {\n         unsafe { simd_reduce_or(self) }\n     }\n }\n@@ -144,10 +144,10 @@ where\n     T: SimdElement + BitXor<T, Output = T>,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    /// Horizontal bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n+    /// Reducing bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n     /// the vector.\n     #[inline]\n-    pub fn horizontal_xor(self) -> T {\n+    pub fn reduce_xor(self) -> T {\n         unsafe { simd_reduce_xor(self) }\n     }\n }"}, {"sha": "0b3f8979a37a07df72a464644e35c1ccb09cf7aa", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c196b8abaafaf360647513c64fac0c8568f9b747/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=c196b8abaafaf360647513c64fac0c8568f9b747", "patch": "@@ -94,70 +94,70 @@ macro_rules! impl_binary_checked_op_test {\n macro_rules! impl_common_integer_tests {\n     { $vector:ident, $scalar:ident } => {\n         test_helpers::test_lanes! {\n-            fn horizontal_sum<const LANES: usize>() {\n+            fn reduce_sum<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_sum(),\n+                        $vector::<LANES>::from_array(x).reduce_sum(),\n                         x.iter().copied().fold(0 as $scalar, $scalar::wrapping_add),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_product<const LANES: usize>() {\n+            fn reduce_product<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_product(),\n+                        $vector::<LANES>::from_array(x).reduce_product(),\n                         x.iter().copied().fold(1 as $scalar, $scalar::wrapping_mul),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_and<const LANES: usize>() {\n+            fn reduce_and<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_and(),\n+                        $vector::<LANES>::from_array(x).reduce_and(),\n                         x.iter().copied().fold(-1i8 as $scalar, <$scalar as core::ops::BitAnd>::bitand),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_or<const LANES: usize>() {\n+            fn reduce_or<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_or(),\n+                        $vector::<LANES>::from_array(x).reduce_or(),\n                         x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitOr>::bitor),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_xor<const LANES: usize>() {\n+            fn reduce_xor<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_xor(),\n+                        $vector::<LANES>::from_array(x).reduce_xor(),\n                         x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitXor>::bitxor),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_max<const LANES: usize>() {\n+            fn reduce_max<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_max(),\n+                        $vector::<LANES>::from_array(x).reduce_max(),\n                         x.iter().copied().max().unwrap(),\n                     );\n                     Ok(())\n                 });\n             }\n \n-            fn horizontal_min<const LANES: usize>() {\n+            fn reduce_min<const LANES: usize>() {\n                 test_helpers::test_1(&|x| {\n                     test_helpers::prop_assert_biteq! (\n-                        $vector::<LANES>::from_array(x).horizontal_min(),\n+                        $vector::<LANES>::from_array(x).reduce_min(),\n                         x.iter().copied().min().unwrap(),\n                     );\n                     Ok(())\n@@ -516,29 +516,29 @@ macro_rules! impl_float_tests {\n                     })\n                 }\n \n-                fn horizontal_sum<const LANES: usize>() {\n+                fn reduce_sum<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! (\n-                            Vector::<LANES>::from_array(x).horizontal_sum(),\n+                            Vector::<LANES>::from_array(x).reduce_sum(),\n                             x.iter().sum(),\n                         );\n                         Ok(())\n                     });\n                 }\n \n-                fn horizontal_product<const LANES: usize>() {\n+                fn reduce_product<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! (\n-                            Vector::<LANES>::from_array(x).horizontal_product(),\n+                            Vector::<LANES>::from_array(x).reduce_product(),\n                             x.iter().product(),\n                         );\n                         Ok(())\n                     });\n                 }\n \n-                fn horizontal_max<const LANES: usize>() {\n+                fn reduce_max<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n-                        let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n+                        let vmax = Vector::<LANES>::from_array(x).reduce_max();\n                         let smax = x.iter().copied().fold(Scalar::NAN, Scalar::max);\n                         // 0 and -0 are treated the same\n                         if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {\n@@ -548,9 +548,9 @@ macro_rules! impl_float_tests {\n                     });\n                 }\n \n-                fn horizontal_min<const LANES: usize>() {\n+                fn reduce_min<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n-                        let vmax = Vector::<LANES>::from_array(x).horizontal_min();\n+                        let vmax = Vector::<LANES>::from_array(x).reduce_min();\n                         let smax = x.iter().copied().fold(Scalar::NAN, Scalar::min);\n                         // 0 and -0 are treated the same\n                         if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {"}]}