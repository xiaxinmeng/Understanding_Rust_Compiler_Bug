{"sha": "6940cfed1e24a67e816e69e1093e04c0eb73e070", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NDBjZmVkMWUyNGE2N2U4MTZlNjllMTA5M2UwNGMwZWI3M2UwNzA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-12T16:28:19Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-12T18:00:22Z"}, "message": "Move some hir_ty diagnostics to hir", "tree": {"sha": "68825f63dc6bdb571498ba659a2cf57bd31accb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68825f63dc6bdb571498ba659a2cf57bd31accb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6940cfed1e24a67e816e69e1093e04c0eb73e070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6940cfed1e24a67e816e69e1093e04c0eb73e070", "html_url": "https://github.com/rust-lang/rust/commit/6940cfed1e24a67e816e69e1093e04c0eb73e070", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6940cfed1e24a67e816e69e1093e04c0eb73e070/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f0141a14026827edfe4ef046013001acd22d94d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f0141a14026827edfe4ef046013001acd22d94d", "html_url": "https://github.com/rust-lang/rust/commit/6f0141a14026827edfe4ef046013001acd22d94d"}], "stats": {"total": 3602, "additions": 1821, "deletions": 1781}, "files": [{"sha": "26dbcd86a4688de95e46532a000b1576a32d3bcf", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 258, "deletions": 5, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=6940cfed1e24a67e816e69e1093e04c0eb73e070", "patch": "@@ -7,15 +7,12 @@ use std::any::Any;\n \n use cfg::{CfgExpr, CfgOptions, DnfExpr};\n use hir_def::path::ModPath;\n-use hir_expand::{HirFileId, InFile};\n+use hir_expand::{name::Name, HirFileId, InFile};\n use stdx::format_to;\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n pub use hir_ty::{\n-    diagnostics::{\n-        IncorrectCase, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingOkOrSomeInTailExpr, RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap,\n-    },\n+    diagnostics::IncorrectCase,\n     diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder},\n };\n \n@@ -325,3 +322,259 @@ impl Diagnostic for MissingUnsafe {\n         self\n     }\n }\n+\n+// Diagnostic: missing-structure-fields\n+//\n+// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.\n+//\n+// Example:\n+//\n+// ```rust\n+// struct A { a: u8, b: u8 }\n+//\n+// let a = A { a: 10 };\n+// ```\n+#[derive(Debug)]\n+pub struct MissingFields {\n+    pub file: HirFileId,\n+    pub field_list_parent: AstPtr<ast::RecordExpr>,\n+    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n+    pub missed_fields: Vec<Name>,\n+}\n+\n+impl Diagnostic for MissingFields {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-structure-fields\")\n+    }\n+    fn message(&self) -> String {\n+        let mut buf = String::from(\"Missing structure fields:\\n\");\n+        for field in &self.missed_fields {\n+            format_to!(buf, \"- {}\\n\", field);\n+        }\n+        buf\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile {\n+            file_id: self.file,\n+            value: self\n+                .field_list_parent_path\n+                .clone()\n+                .map(SyntaxNodePtr::from)\n+                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n+        }\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: missing-pat-fields\n+//\n+// This diagnostic is triggered if pattern lacks some fields that exist in the corresponding structure.\n+//\n+// Example:\n+//\n+// ```rust\n+// struct A { a: u8, b: u8 }\n+//\n+// let a = A { a: 10, b: 20 };\n+//\n+// if let A { a } = a {\n+//     // ...\n+// }\n+// ```\n+#[derive(Debug)]\n+pub struct MissingPatFields {\n+    pub file: HirFileId,\n+    pub field_list_parent: AstPtr<ast::RecordPat>,\n+    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n+    pub missed_fields: Vec<Name>,\n+}\n+\n+impl Diagnostic for MissingPatFields {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-pat-fields\")\n+    }\n+    fn message(&self) -> String {\n+        let mut buf = String::from(\"Missing structure fields:\\n\");\n+        for field in &self.missed_fields {\n+            format_to!(buf, \"- {}\\n\", field);\n+        }\n+        buf\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile {\n+            file_id: self.file,\n+            value: self\n+                .field_list_parent_path\n+                .clone()\n+                .map(SyntaxNodePtr::from)\n+                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n+        }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: replace-filter-map-next-with-find-map\n+//\n+// This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n+#[derive(Debug)]\n+pub struct ReplaceFilterMapNextWithFindMap {\n+    pub file: HirFileId,\n+    /// This expression is the whole method chain up to and including `.filter_map(..).next()`.\n+    pub next_expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"replace-filter-map-next-with-find-map\")\n+    }\n+    fn message(&self) -> String {\n+        \"replace filter_map(..).next() with find_map(..)\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.next_expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: mismatched-arg-count\n+//\n+// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n+#[derive(Debug)]\n+pub struct MismatchedArgCount {\n+    pub file: HirFileId,\n+    pub call_expr: AstPtr<ast::Expr>,\n+    pub expected: usize,\n+    pub found: usize,\n+}\n+\n+impl Diagnostic for MismatchedArgCount {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"mismatched-arg-count\")\n+    }\n+    fn message(&self) -> String {\n+        let s = if self.expected == 1 { \"\" } else { \"s\" };\n+        format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.call_expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+    fn is_experimental(&self) -> bool {\n+        true\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct RemoveThisSemicolon {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+}\n+\n+impl Diagnostic for RemoveThisSemicolon {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"remove-this-semicolon\")\n+    }\n+\n+    fn message(&self) -> String {\n+        \"Remove this semicolon\".to_string()\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.expr.clone().into() }\n+    }\n+\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: missing-ok-or-some-in-tail-expr\n+//\n+// This diagnostic is triggered if a block that should return `Result` returns a value not wrapped in `Ok`,\n+// or if a block that should return `Option` returns a value not wrapped in `Some`.\n+//\n+// Example:\n+//\n+// ```rust\n+// fn foo() -> Result<u8, ()> {\n+//     10\n+// }\n+// ```\n+#[derive(Debug)]\n+pub struct MissingOkOrSomeInTailExpr {\n+    pub file: HirFileId,\n+    pub expr: AstPtr<ast::Expr>,\n+    // `Some` or `Ok` depending on whether the return type is Result or Option\n+    pub required: String,\n+}\n+\n+impl Diagnostic for MissingOkOrSomeInTailExpr {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-ok-or-some-in-tail-expr\")\n+    }\n+    fn message(&self) -> String {\n+        format!(\"wrap return expression in {}\", self.required)\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+// Diagnostic: missing-match-arm\n+//\n+// This diagnostic is triggered if `match` block is missing one or more match arms.\n+#[derive(Debug)]\n+pub struct MissingMatchArms {\n+    pub file: HirFileId,\n+    pub match_expr: AstPtr<ast::Expr>,\n+    pub arms: AstPtr<ast::MatchArmList>,\n+}\n+\n+impl Diagnostic for MissingMatchArms {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-match-arm\")\n+    }\n+    fn message(&self) -> String {\n+        String::from(\"Missing match arm\")\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.match_expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct InternalBailedOut {\n+    pub file: HirFileId,\n+    pub pat_syntax_ptr: SyntaxNodePtr,\n+}\n+\n+impl Diagnostic for InternalBailedOut {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"internal:match-check-bailed-out\")\n+    }\n+    fn message(&self) -> String {\n+        format!(\"Internal: match check bailed out\")\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.pat_syntax_ptr.clone() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "dd5515c2bd071f736248effc1a14b65916407805", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 163, "deletions": 12, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6940cfed1e24a67e816e69e1093e04c0eb73e070", "patch": "@@ -36,9 +36,11 @@ use std::{iter, sync::Arc};\n use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, Edition, FileId};\n use diagnostics::{\n-    BreakOutsideOfLoop, InactiveCode, MacroError, MissingUnsafe, NoSuchField,\n-    UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n-    UnresolvedModule, UnresolvedProcMacro,\n+    BreakOutsideOfLoop, InactiveCode, InternalBailedOut, MacroError, MismatchedArgCount,\n+    MissingFields, MissingOkOrSomeInTailExpr, MissingPatFields, MissingUnsafe, NoSuchField,\n+    RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap, UnimplementedBuiltinMacro,\n+    UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n+    UnresolvedProcMacro,\n };\n use either::Either;\n use hir_def::{\n@@ -61,6 +63,7 @@ use hir_ty::{\n     autoderef,\n     consteval::ConstExt,\n     could_unify,\n+    diagnostics::BodyValidationDiagnostic,\n     diagnostics_sink::DiagnosticSink,\n     method_resolution::{self, def_crates, TyFingerprint},\n     primitive::UintTy,\n@@ -82,7 +85,10 @@ use syntax::{\n };\n use tt::{Ident, Leaf, Literal, TokenTree};\n \n-use crate::db::{DefDatabase, HirDatabase};\n+use crate::{\n+    db::{DefDatabase, HirDatabase},\n+    diagnostics::MissingMatchArms,\n+};\n \n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n@@ -447,7 +453,12 @@ impl Module {\n         self.id.def_map(db.upcast())[self.id.local_id].scope.visibility_of(def.clone().into())\n     }\n \n-    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+    pub fn diagnostics(\n+        self,\n+        db: &dyn HirDatabase,\n+        sink: &mut DiagnosticSink,\n+        internal_diagnostics: bool,\n+    ) {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n         });\n@@ -593,11 +604,11 @@ impl Module {\n         }\n         for decl in self.declarations(db) {\n             match decl {\n-                crate::ModuleDef::Function(f) => f.diagnostics(db, sink),\n+                crate::ModuleDef::Function(f) => f.diagnostics(db, sink, internal_diagnostics),\n                 crate::ModuleDef::Module(m) => {\n                     // Only add diagnostics from inline modules\n                     if def_map[m.id.local_id].origin.is_inline() {\n-                        m.diagnostics(db, sink)\n+                        m.diagnostics(db, sink, internal_diagnostics)\n                     }\n                 }\n                 _ => {\n@@ -609,7 +620,7 @@ impl Module {\n         for impl_def in self.impl_defs(db) {\n             for item in impl_def.items(db) {\n                 if let AssocItem::Function(f) = item {\n-                    f.diagnostics(db, sink);\n+                    f.diagnostics(db, sink, internal_diagnostics);\n                 }\n             }\n         }\n@@ -1011,7 +1022,12 @@ impl Function {\n         db.function_data(self.id).is_async()\n     }\n \n-    pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n+    pub fn diagnostics(\n+        self,\n+        db: &dyn HirDatabase,\n+        sink: &mut DiagnosticSink,\n+        internal_diagnostics: bool,\n+    ) {\n         let krate = self.module(db).id.krate();\n \n         let source_map = db.body_with_source_map(self.id.into()).1;\n@@ -1067,14 +1083,149 @@ impl Function {\n                     sink.push(MissingUnsafe { file: in_file.file_id, expr: in_file.value })\n                 }\n                 Err(SyntheticSyntax) => {\n-                    // FIXME: The `expr` was desugared, report or assert that\n-                    // this doesn't happen.\n+                    // FIXME: Here and eslwhere in this file, the `expr` was\n+                    // desugared, report or assert that this doesn't happen.\n+                }\n+            }\n+        }\n+\n+        for diagnostic in\n+            BodyValidationDiagnostic::collect(db, self.id.into(), internal_diagnostics)\n+        {\n+            match diagnostic {\n+                BodyValidationDiagnostic::RecordLiteralMissingFields {\n+                    record_expr,\n+                    variant,\n+                    missed_fields,\n+                } => match source_map.expr_syntax(record_expr) {\n+                    Ok(source_ptr) => {\n+                        let root = source_ptr.file_syntax(db.upcast());\n+                        if let ast::Expr::RecordExpr(record_expr) = &source_ptr.value.to_node(&root)\n+                        {\n+                            if let Some(_) = record_expr.record_expr_field_list() {\n+                                let variant_data = variant.variant_data(db.upcast());\n+                                let missed_fields = missed_fields\n+                                    .into_iter()\n+                                    .map(|idx| variant_data.fields()[idx].name.clone())\n+                                    .collect();\n+                                sink.push(MissingFields {\n+                                    file: source_ptr.file_id,\n+                                    field_list_parent: AstPtr::new(&record_expr),\n+                                    field_list_parent_path: record_expr\n+                                        .path()\n+                                        .map(|path| AstPtr::new(&path)),\n+                                    missed_fields,\n+                                })\n+                            }\n+                        }\n+                    }\n+                    Err(SyntheticSyntax) => (),\n+                },\n+                BodyValidationDiagnostic::RecordPatMissingFields {\n+                    record_pat,\n+                    variant,\n+                    missed_fields,\n+                } => match source_map.pat_syntax(record_pat) {\n+                    Ok(source_ptr) => {\n+                        if let Some(expr) = source_ptr.value.as_ref().left() {\n+                            let root = source_ptr.file_syntax(db.upcast());\n+                            if let ast::Pat::RecordPat(record_pat) = expr.to_node(&root) {\n+                                if let Some(_) = record_pat.record_pat_field_list() {\n+                                    let variant_data = variant.variant_data(db.upcast());\n+                                    let missed_fields = missed_fields\n+                                        .into_iter()\n+                                        .map(|idx| variant_data.fields()[idx].name.clone())\n+                                        .collect();\n+                                    sink.push(MissingPatFields {\n+                                        file: source_ptr.file_id,\n+                                        field_list_parent: AstPtr::new(&record_pat),\n+                                        field_list_parent_path: record_pat\n+                                            .path()\n+                                            .map(|path| AstPtr::new(&path)),\n+                                        missed_fields,\n+                                    })\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Err(SyntheticSyntax) => (),\n+                },\n+\n+                BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap { method_call_expr } => {\n+                    if let Ok(next_source_ptr) = source_map.expr_syntax(method_call_expr) {\n+                        sink.push(ReplaceFilterMapNextWithFindMap {\n+                            file: next_source_ptr.file_id,\n+                            next_expr: next_source_ptr.value,\n+                        });\n+                    }\n+                }\n+                BodyValidationDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n+                    match source_map.expr_syntax(call_expr) {\n+                        Ok(source_ptr) => sink.push(MismatchedArgCount {\n+                            file: source_ptr.file_id,\n+                            call_expr: source_ptr.value,\n+                            expected,\n+                            found,\n+                        }),\n+                        Err(SyntheticSyntax) => (),\n+                    }\n+                }\n+                BodyValidationDiagnostic::RemoveThisSemicolon { expr } => {\n+                    match source_map.expr_syntax(expr) {\n+                        Ok(source_ptr) => sink.push(RemoveThisSemicolon {\n+                            file: source_ptr.file_id,\n+                            expr: source_ptr.value,\n+                        }),\n+                        Err(SyntheticSyntax) => (),\n+                    }\n+                }\n+                BodyValidationDiagnostic::MissingOkOrSomeInTailExpr { expr, required } => {\n+                    match source_map.expr_syntax(expr) {\n+                        Ok(source_ptr) => sink.push(MissingOkOrSomeInTailExpr {\n+                            file: source_ptr.file_id,\n+                            expr: source_ptr.value,\n+                            required,\n+                        }),\n+                        Err(SyntheticSyntax) => (),\n+                    }\n+                }\n+                BodyValidationDiagnostic::MissingMatchArms { match_expr } => {\n+                    match source_map.expr_syntax(match_expr) {\n+                        Ok(source_ptr) => {\n+                            let root = source_ptr.file_syntax(db.upcast());\n+                            if let ast::Expr::MatchExpr(match_expr) =\n+                                &source_ptr.value.to_node(&root)\n+                            {\n+                                if let (Some(match_expr), Some(arms)) =\n+                                    (match_expr.expr(), match_expr.match_arm_list())\n+                                {\n+                                    sink.push(MissingMatchArms {\n+                                        file: source_ptr.file_id,\n+                                        match_expr: AstPtr::new(&match_expr),\n+                                        arms: AstPtr::new(&arms),\n+                                    })\n+                                }\n+                            }\n+                        }\n+                        Err(SyntheticSyntax) => (),\n+                    }\n+                }\n+                BodyValidationDiagnostic::InternalBailedOut { pat } => {\n+                    match source_map.pat_syntax(pat) {\n+                        Ok(source_ptr) => {\n+                            let pat_syntax_ptr = source_ptr.value.either(Into::into, Into::into);\n+                            sink.push(InternalBailedOut {\n+                                file: source_ptr.file_id,\n+                                pat_syntax_ptr,\n+                            });\n+                        }\n+                        Err(SyntheticSyntax) => (),\n+                    }\n                 }\n             }\n         }\n \n         hir_ty::diagnostics::validate_module_item(db, krate, self.id.into(), sink);\n-        hir_ty::diagnostics::validate_body(db, self.id.into(), sink);\n     }\n \n     /// Whether this function declaration has a definition."}, {"sha": "f3236bc060a35b2573f6e9bd7a2d47e06aa47d2b", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 397, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=6940cfed1e24a67e816e69e1093e04c0eb73e070", "patch": "@@ -7,9 +7,8 @@ mod decl_check;\n use std::{any::Any, fmt};\n \n use base_db::CrateId;\n-use hir_def::{DefWithBodyId, ModuleDefId};\n-use hir_expand::{name::Name, HirFileId, InFile};\n-use stdx::format_to;\n+use hir_def::ModuleDefId;\n+use hir_expand::{HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n use crate::{\n@@ -18,7 +17,9 @@ use crate::{\n };\n \n pub use crate::diagnostics::{\n-    expr::{record_literal_missing_fields, record_pattern_missing_fields},\n+    expr::{\n+        record_literal_missing_fields, record_pattern_missing_fields, BodyValidationDiagnostic,\n+    },\n     unsafe_check::missing_unsafe,\n };\n \n@@ -33,223 +34,6 @@ pub fn validate_module_item(\n     validator.validate_item(owner);\n }\n \n-pub fn validate_body(db: &dyn HirDatabase, owner: DefWithBodyId, sink: &mut DiagnosticSink<'_>) {\n-    let _p = profile::span(\"validate_body\");\n-    let infer = db.infer(owner);\n-    let mut validator = expr::ExprValidator::new(owner, infer.clone(), sink);\n-    validator.validate_body(db);\n-}\n-\n-// Diagnostic: missing-structure-fields\n-//\n-// This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.\n-//\n-// Example:\n-//\n-// ```rust\n-// struct A { a: u8, b: u8 }\n-//\n-// let a = A { a: 10 };\n-// ```\n-#[derive(Debug)]\n-pub struct MissingFields {\n-    pub file: HirFileId,\n-    pub field_list_parent: AstPtr<ast::RecordExpr>,\n-    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n-    pub missed_fields: Vec<Name>,\n-}\n-\n-impl Diagnostic for MissingFields {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-structure-fields\")\n-    }\n-    fn message(&self) -> String {\n-        let mut buf = String::from(\"Missing structure fields:\\n\");\n-        for field in &self.missed_fields {\n-            format_to!(buf, \"- {}\\n\", field);\n-        }\n-        buf\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile {\n-            file_id: self.file,\n-            value: self\n-                .field_list_parent_path\n-                .clone()\n-                .map(SyntaxNodePtr::from)\n-                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n-        }\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: missing-pat-fields\n-//\n-// This diagnostic is triggered if pattern lacks some fields that exist in the corresponding structure.\n-//\n-// Example:\n-//\n-// ```rust\n-// struct A { a: u8, b: u8 }\n-//\n-// let a = A { a: 10, b: 20 };\n-//\n-// if let A { a } = a {\n-//     // ...\n-// }\n-// ```\n-#[derive(Debug)]\n-pub struct MissingPatFields {\n-    pub file: HirFileId,\n-    pub field_list_parent: AstPtr<ast::RecordPat>,\n-    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n-    pub missed_fields: Vec<Name>,\n-}\n-\n-impl Diagnostic for MissingPatFields {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-pat-fields\")\n-    }\n-    fn message(&self) -> String {\n-        let mut buf = String::from(\"Missing structure fields:\\n\");\n-        for field in &self.missed_fields {\n-            format_to!(buf, \"- {}\\n\", field);\n-        }\n-        buf\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile {\n-            file_id: self.file,\n-            value: self\n-                .field_list_parent_path\n-                .clone()\n-                .map(SyntaxNodePtr::from)\n-                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n-        }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: missing-match-arm\n-//\n-// This diagnostic is triggered if `match` block is missing one or more match arms.\n-#[derive(Debug)]\n-pub struct MissingMatchArms {\n-    pub file: HirFileId,\n-    pub match_expr: AstPtr<ast::Expr>,\n-    pub arms: AstPtr<ast::MatchArmList>,\n-}\n-\n-impl Diagnostic for MissingMatchArms {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-match-arm\")\n-    }\n-    fn message(&self) -> String {\n-        String::from(\"Missing match arm\")\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.match_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: missing-ok-or-some-in-tail-expr\n-//\n-// This diagnostic is triggered if a block that should return `Result` returns a value not wrapped in `Ok`,\n-// or if a block that should return `Option` returns a value not wrapped in `Some`.\n-//\n-// Example:\n-//\n-// ```rust\n-// fn foo() -> Result<u8, ()> {\n-//     10\n-// }\n-// ```\n-#[derive(Debug)]\n-pub struct MissingOkOrSomeInTailExpr {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n-    // `Some` or `Ok` depending on whether the return type is Result or Option\n-    pub required: String,\n-}\n-\n-impl Diagnostic for MissingOkOrSomeInTailExpr {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-ok-or-some-in-tail-expr\")\n-    }\n-    fn message(&self) -> String {\n-        format!(\"wrap return expression in {}\", self.required)\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct RemoveThisSemicolon {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n-}\n-\n-impl Diagnostic for RemoveThisSemicolon {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"remove-this-semicolon\")\n-    }\n-\n-    fn message(&self) -> String {\n-        \"Remove this semicolon\".to_string()\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.expr.clone().into() }\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n-// Diagnostic: mismatched-arg-count\n-//\n-// This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n-#[derive(Debug)]\n-pub struct MismatchedArgCount {\n-    pub file: HirFileId,\n-    pub call_expr: AstPtr<ast::Expr>,\n-    pub expected: usize,\n-    pub found: usize,\n-}\n-\n-impl Diagnostic for MismatchedArgCount {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"mismatched-arg-count\")\n-    }\n-    fn message(&self) -> String {\n-        let s = if self.expected == 1 { \"\" } else { \"s\" };\n-        format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.call_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-    fn is_experimental(&self) -> bool {\n-        true\n-    }\n-}\n-\n #[derive(Debug)]\n pub enum CaseType {\n     // `some_var`\n@@ -344,31 +128,6 @@ impl Diagnostic for IncorrectCase {\n     }\n }\n \n-// Diagnostic: replace-filter-map-next-with-find-map\n-//\n-// This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n-#[derive(Debug)]\n-pub struct ReplaceFilterMapNextWithFindMap {\n-    pub file: HirFileId,\n-    /// This expression is the whole method chain up to and including `.filter_map(..).next()`.\n-    pub next_expr: AstPtr<ast::Expr>,\n-}\n-\n-impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"replace-filter-map-next-with-find-map\")\n-    }\n-    fn message(&self) -> String {\n-        \"replace filter_map(..).next() with find_map(..)\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.next_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use base_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n@@ -378,7 +137,7 @@ mod tests {\n     use syntax::{TextRange, TextSize};\n \n     use crate::{\n-        diagnostics::{validate_body, validate_module_item},\n+        diagnostics::validate_module_item,\n         diagnostics_sink::{Diagnostic, DiagnosticSinkBuilder},\n         test_db::TestDB,\n     };\n@@ -416,11 +175,6 @@ mod tests {\n                         }\n                     }\n                 }\n-\n-                for f in fns {\n-                    let mut sink = DiagnosticSinkBuilder::new().build(&mut cb);\n-                    validate_body(self, f.into(), &mut sink);\n-                }\n             }\n         }\n     }\n@@ -455,58 +209,6 @@ mod tests {\n         assert_eq!(annotations, actual);\n     }\n \n-    #[test]\n-    fn missing_record_pat_field_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-struct S { foo: i32, bar: () }\n-fn baz(s: S) {\n-    let S { foo: _ } = s;\n-      //^ Missing structure fields:\n-      //| - bar\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n-        check_diagnostics(\n-            r\"\n-struct S { foo: i32, bar: () }\n-fn baz(s: S) -> i32 {\n-    match s {\n-        S { foo, .. } => foo,\n-    }\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn missing_record_pat_field_box() {\n-        check_diagnostics(\n-            r\"\n-struct S { s: Box<u32> }\n-fn x(a: S) {\n-    let S { box s } = a;\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn missing_record_pat_field_ref() {\n-        check_diagnostics(\n-            r\"\n-struct S { s: u32 }\n-fn x(a: S) {\n-    let S { ref s } = a;\n-}\n-\",\n-        )\n-    }\n-\n     #[test]\n     fn import_extern_crate_clash_with_inner_item() {\n         // This is more of a resolver test, but doesn't really work with the hir_def testsuite.\n@@ -535,97 +237,4 @@ pub struct Claims {\n         \"#,\n         );\n     }\n-\n-    #[test]\n-    fn missing_semicolon() {\n-        check_diagnostics(\n-            r#\"\n-                fn test() -> i32 { 123; }\n-                                 //^^^ Remove this semicolon\n-            \"#,\n-        );\n-    }\n-\n-    // Register the required standard library types to make the tests work\n-    fn add_filter_map_with_find_next_boilerplate(body: &str) -> String {\n-        let prefix = r#\"\n-        //- /main.rs crate:main deps:core\n-        use core::iter::Iterator;\n-        use core::option::Option::{self, Some, None};\n-        \"#;\n-        let suffix = r#\"\n-        //- /core/lib.rs crate:core\n-        pub mod option {\n-            pub enum Option<T> { Some(T), None }\n-        }\n-        pub mod iter {\n-            pub trait Iterator {\n-                type Item;\n-                fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n-                fn next(&mut self) -> Option<Self::Item>;\n-            }\n-            pub struct FilterMap {}\n-            impl Iterator for FilterMap {\n-                type Item = i32;\n-                fn next(&mut self) -> i32 { 7 }\n-            }\n-        }\n-        \"#;\n-        format!(\"{}{}{}\", prefix, body, suffix)\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map2() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3].iter().filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n-                      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ replace filter_map(..).next() with find_map(..)\n-            }\n-        \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_without_next() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n-                    .len();\n-            }\n-            \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_with_intervening_methods() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n-                    .map(|x| x + 2)\n-                    .len();\n-            }\n-            \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_if_not_in_chain() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None });\n-                let n = m.next();\n-            }\n-            \"#,\n-        ));\n-    }\n }"}, {"sha": "c480ed352a1e3432088aaf447d9184c2122c3b3c", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 91, "deletions": 408, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=6940cfed1e24a67e816e69e1093e04c0eb73e070", "patch": "@@ -9,19 +9,13 @@ use hir_def::{\n };\n use hir_expand::name;\n use rustc_hash::FxHashSet;\n-use syntax::{ast, AstPtr};\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{\n-        match_check::{\n-            self,\n-            usefulness::{compute_match_usefulness, expand_pattern, MatchCheckCtx, PatternArena},\n-        },\n-        MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n-        MissingPatFields, RemoveThisSemicolon,\n+    diagnostics::match_check::{\n+        self,\n+        usefulness::{compute_match_usefulness, expand_pattern, MatchCheckCtx, PatternArena},\n     },\n-    diagnostics_sink::DiagnosticSink,\n     AdtId, InferenceResult, Interner, TyExt, TyKind,\n };\n \n@@ -31,38 +25,81 @@ pub(crate) use hir_def::{\n     LocalFieldId, VariantId,\n };\n \n-use super::ReplaceFilterMapNextWithFindMap;\n+pub enum BodyValidationDiagnostic {\n+    RecordLiteralMissingFields {\n+        record_expr: ExprId,\n+        variant: VariantId,\n+        missed_fields: Vec<LocalFieldId>,\n+    },\n+    RecordPatMissingFields {\n+        record_pat: PatId,\n+        variant: VariantId,\n+        missed_fields: Vec<LocalFieldId>,\n+    },\n+    ReplaceFilterMapNextWithFindMap {\n+        method_call_expr: ExprId,\n+    },\n+    MismatchedArgCount {\n+        call_expr: ExprId,\n+        expected: usize,\n+        found: usize,\n+    },\n+    RemoveThisSemicolon {\n+        expr: ExprId,\n+    },\n+    MissingOkOrSomeInTailExpr {\n+        expr: ExprId,\n+        required: String,\n+    },\n+    MissingMatchArms {\n+        match_expr: ExprId,\n+    },\n+    InternalBailedOut {\n+        pat: PatId,\n+    },\n+}\n \n-pub(super) struct ExprValidator<'a, 'b: 'a> {\n+impl BodyValidationDiagnostic {\n+    pub fn collect(\n+        db: &dyn HirDatabase,\n+        owner: DefWithBodyId,\n+        internal_diagnostics: bool,\n+    ) -> Vec<BodyValidationDiagnostic> {\n+        let _p = profile::span(\"BodyValidationDiagnostic::collect\");\n+        let infer = db.infer(owner);\n+        let mut validator = ExprValidator::new(owner, infer.clone());\n+        validator.internal_diagnostics = internal_diagnostics;\n+        validator.validate_body(db);\n+        validator.diagnostics\n+    }\n+}\n+\n+struct ExprValidator {\n     owner: DefWithBodyId,\n     infer: Arc<InferenceResult>,\n-    sink: &'a mut DiagnosticSink<'b>,\n+    pub(super) diagnostics: Vec<BodyValidationDiagnostic>,\n+    internal_diagnostics: bool,\n }\n \n-impl<'a, 'b> ExprValidator<'a, 'b> {\n-    pub(super) fn new(\n-        owner: DefWithBodyId,\n-        infer: Arc<InferenceResult>,\n-        sink: &'a mut DiagnosticSink<'b>,\n-    ) -> ExprValidator<'a, 'b> {\n-        ExprValidator { owner, infer, sink }\n+impl ExprValidator {\n+    fn new(owner: DefWithBodyId, infer: Arc<InferenceResult>) -> ExprValidator {\n+        ExprValidator { owner, infer, diagnostics: Vec::new(), internal_diagnostics: false }\n     }\n \n-    pub(super) fn validate_body(&mut self, db: &dyn HirDatabase) {\n+    fn validate_body(&mut self, db: &dyn HirDatabase) {\n         self.check_for_filter_map_next(db);\n \n         let body = db.body(self.owner);\n \n         for (id, expr) in body.exprs.iter() {\n-            if let Some((variant_def, missed_fields, true)) =\n+            if let Some((variant, missed_fields, true)) =\n                 record_literal_missing_fields(db, &self.infer, id, expr)\n             {\n-                self.create_record_literal_missing_fields_diagnostic(\n-                    id,\n-                    db,\n-                    variant_def,\n+                self.diagnostics.push(BodyValidationDiagnostic::RecordLiteralMissingFields {\n+                    record_expr: id,\n+                    variant,\n                     missed_fields,\n-                );\n+                });\n             }\n \n             match expr {\n@@ -76,87 +113,22 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             }\n         }\n         for (id, pat) in body.pats.iter() {\n-            if let Some((variant_def, missed_fields, true)) =\n+            if let Some((variant, missed_fields, true)) =\n                 record_pattern_missing_fields(db, &self.infer, id, pat)\n             {\n-                self.create_record_pattern_missing_fields_diagnostic(\n-                    id,\n-                    db,\n-                    variant_def,\n+                self.diagnostics.push(BodyValidationDiagnostic::RecordPatMissingFields {\n+                    record_pat: id,\n+                    variant,\n                     missed_fields,\n-                );\n+                });\n             }\n         }\n         let body_expr = &body[body.body_expr];\n         if let Expr::Block { statements, tail, .. } = body_expr {\n             if let Some(t) = tail {\n                 self.validate_results_in_tail_expr(body.body_expr, *t, db);\n             } else if let Some(Statement::Expr { expr: id, .. }) = statements.last() {\n-                self.validate_missing_tail_expr(body.body_expr, *id, db);\n-            }\n-        }\n-    }\n-\n-    fn create_record_literal_missing_fields_diagnostic(\n-        &mut self,\n-        id: ExprId,\n-        db: &dyn HirDatabase,\n-        variant_def: VariantId,\n-        missed_fields: Vec<LocalFieldId>,\n-    ) {\n-        // XXX: only look at source_map if we do have missing fields\n-        let (_, source_map) = db.body_with_source_map(self.owner);\n-\n-        if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-            let root = source_ptr.file_syntax(db.upcast());\n-            if let ast::Expr::RecordExpr(record_expr) = &source_ptr.value.to_node(&root) {\n-                if let Some(_) = record_expr.record_expr_field_list() {\n-                    let variant_data = variant_def.variant_data(db.upcast());\n-                    let missed_fields = missed_fields\n-                        .into_iter()\n-                        .map(|idx| variant_data.fields()[idx].name.clone())\n-                        .collect();\n-                    self.sink.push(MissingFields {\n-                        file: source_ptr.file_id,\n-                        field_list_parent: AstPtr::new(&record_expr),\n-                        field_list_parent_path: record_expr.path().map(|path| AstPtr::new(&path)),\n-                        missed_fields,\n-                    })\n-                }\n-            }\n-        }\n-    }\n-\n-    fn create_record_pattern_missing_fields_diagnostic(\n-        &mut self,\n-        id: PatId,\n-        db: &dyn HirDatabase,\n-        variant_def: VariantId,\n-        missed_fields: Vec<LocalFieldId>,\n-    ) {\n-        // XXX: only look at source_map if we do have missing fields\n-        let (_, source_map) = db.body_with_source_map(self.owner);\n-\n-        if let Ok(source_ptr) = source_map.pat_syntax(id) {\n-            if let Some(expr) = source_ptr.value.as_ref().left() {\n-                let root = source_ptr.file_syntax(db.upcast());\n-                if let ast::Pat::RecordPat(record_pat) = expr.to_node(&root) {\n-                    if let Some(_) = record_pat.record_pat_field_list() {\n-                        let variant_data = variant_def.variant_data(db.upcast());\n-                        let missed_fields = missed_fields\n-                            .into_iter()\n-                            .map(|idx| variant_data.fields()[idx].name.clone())\n-                            .collect();\n-                        self.sink.push(MissingPatFields {\n-                            file: source_ptr.file_id,\n-                            field_list_parent: AstPtr::new(&record_pat),\n-                            field_list_parent_path: record_pat\n-                                .path()\n-                                .map(|path| AstPtr::new(&path)),\n-                            missed_fields,\n-                        })\n-                    }\n-                }\n+                self.validate_missing_tail_expr(body.body_expr, *id);\n             }\n         }\n     }\n@@ -199,13 +171,11 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                 if function_id == *next_function_id {\n                     if let Some(filter_map_id) = prev {\n                         if *receiver == filter_map_id {\n-                            let (_, source_map) = db.body_with_source_map(self.owner);\n-                            if let Ok(next_source_ptr) = source_map.expr_syntax(id) {\n-                                self.sink.push(ReplaceFilterMapNextWithFindMap {\n-                                    file: next_source_ptr.file_id,\n-                                    next_expr: next_source_ptr.value,\n-                                });\n-                            }\n+                            self.diagnostics.push(\n+                                BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap {\n+                                    method_call_expr: id,\n+                                },\n+                            );\n                         }\n                     }\n                 }\n@@ -266,19 +236,15 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         let mut arg_count = args.len();\n \n         if arg_count != param_count {\n-            let (_, source_map) = db.body_with_source_map(self.owner);\n-            if let Ok(source_ptr) = source_map.expr_syntax(call_id) {\n-                if is_method_call {\n-                    param_count -= 1;\n-                    arg_count -= 1;\n-                }\n-                self.sink.push(MismatchedArgCount {\n-                    file: source_ptr.file_id,\n-                    call_expr: source_ptr.value,\n-                    expected: param_count,\n-                    found: arg_count,\n-                });\n+            if is_method_call {\n+                param_count -= 1;\n+                arg_count -= 1;\n             }\n+            self.diagnostics.push(BodyValidationDiagnostic::MismatchedArgCount {\n+                call_expr: call_id,\n+                expected: param_count,\n+                found: arg_count,\n+            });\n         }\n     }\n \n@@ -346,8 +312,9 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             // fit the match expression, we skip this diagnostic. Skipping the entire\n             // diagnostic rather than just not including this match arm is preferred\n             // to avoid the chance of false positives.\n-            #[cfg(test)]\n-            match_check::tests::report_bail_out(db, self.owner, arm.pat, self.sink);\n+            if self.internal_diagnostics {\n+                self.diagnostics.push(BodyValidationDiagnostic::InternalBailedOut { pat: arm.pat })\n+            }\n             return;\n         }\n \n@@ -382,20 +349,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         // FIXME Report witnesses\n         // eprintln!(\"compute_match_usefulness(..) -> {:?}\", &witnesses);\n         if !witnesses.is_empty() {\n-            if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-                let root = source_ptr.file_syntax(db.upcast());\n-                if let ast::Expr::MatchExpr(match_expr) = &source_ptr.value.to_node(&root) {\n-                    if let (Some(match_expr), Some(arms)) =\n-                        (match_expr.expr(), match_expr.match_arm_list())\n-                    {\n-                        self.sink.push(MissingMatchArms {\n-                            file: source_ptr.file_id,\n-                            match_expr: AstPtr::new(&match_expr),\n-                            arms: AstPtr::new(&arms),\n-                        })\n-                    }\n-                }\n-            }\n+            self.diagnostics.push(BodyValidationDiagnostic::MissingMatchArms { match_expr: id });\n         }\n     }\n \n@@ -453,24 +407,12 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         if params.len(&Interner) > 0\n             && params.at(&Interner, 0).ty(&Interner) == Some(&mismatch.actual)\n         {\n-            let (_, source_map) = db.body_with_source_map(self.owner);\n-\n-            if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-                self.sink.push(MissingOkOrSomeInTailExpr {\n-                    file: source_ptr.file_id,\n-                    expr: source_ptr.value,\n-                    required,\n-                });\n-            }\n+            self.diagnostics\n+                .push(BodyValidationDiagnostic::MissingOkOrSomeInTailExpr { expr: id, required });\n         }\n     }\n \n-    fn validate_missing_tail_expr(\n-        &mut self,\n-        body_id: ExprId,\n-        possible_tail_id: ExprId,\n-        db: &dyn HirDatabase,\n-    ) {\n+    fn validate_missing_tail_expr(&mut self, body_id: ExprId, possible_tail_id: ExprId) {\n         let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n             Some(m) => m,\n             None => return,\n@@ -485,12 +427,8 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             return;\n         }\n \n-        let (_, source_map) = db.body_with_source_map(self.owner);\n-\n-        if let Ok(source_ptr) = source_map.expr_syntax(possible_tail_id) {\n-            self.sink\n-                .push(RemoveThisSemicolon { file: source_ptr.file_id, expr: source_ptr.value });\n-        }\n+        self.diagnostics\n+            .push(BodyValidationDiagnostic::RemoveThisSemicolon { expr: possible_tail_id });\n     }\n }\n \n@@ -568,258 +506,3 @@ fn types_of_subpatterns_do_match(pat: PatId, body: &Body, infer: &InferenceResul\n     walk(pat, body, infer, &mut has_type_mismatches);\n     !has_type_mismatches\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    #[test]\n-    fn simple_free_fn_zero() {\n-        check_diagnostics(\n-            r#\"\n-fn zero() {}\n-fn f() { zero(1); }\n-       //^^^^^^^ Expected 0 arguments, found 1\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-fn zero() {}\n-fn f() { zero(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn simple_free_fn_one() {\n-        check_diagnostics(\n-            r#\"\n-fn one(arg: u8) {}\n-fn f() { one(); }\n-       //^^^^^ Expected 1 argument, found 0\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-fn one(arg: u8) {}\n-fn f() { one(1); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_as_fn() {\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self) {} }\n-\n-fn f() {\n-    S::method();\n-} //^^^^^^^^^^^ Expected 1 argument, found 0\n-\"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self) {} }\n-\n-fn f() {\n-    S::method(&S);\n-    S.method();\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_with_arg() {\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self, arg: u8) {} }\n-\n-            fn f() {\n-                S.method();\n-            } //^^^^^^^^^^ Expected 1 argument, found 0\n-            \"#,\n-        );\n-\n-        check_diagnostics(\n-            r#\"\n-struct S;\n-impl S { fn method(&self, arg: u8) {} }\n-\n-fn f() {\n-    S::method(&S, 0);\n-    S.method(1);\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_unknown_receiver() {\n-        // note: this is incorrect code, so there might be errors on this in the\n-        // future, but we shouldn't emit an argument count diagnostic here\n-        check_diagnostics(\n-            r#\"\n-trait Foo { fn method(&self, arg: usize) {} }\n-\n-fn f() {\n-    let x;\n-    x.method();\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_struct() {\n-        check_diagnostics(\n-            r#\"\n-struct Tup(u8, u16);\n-fn f() {\n-    Tup(0);\n-} //^^^^^^ Expected 2 arguments, found 1\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn enum_variant() {\n-        check_diagnostics(\n-            r#\"\n-enum En { Variant(u8, u16), }\n-fn f() {\n-    En::Variant(0);\n-} //^^^^^^^^^^^^^^ Expected 2 arguments, found 1\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn enum_variant_type_macro() {\n-        check_diagnostics(\n-            r#\"\n-macro_rules! Type {\n-    () => { u32 };\n-}\n-enum Foo {\n-    Bar(Type![])\n-}\n-impl Foo {\n-    fn new() {\n-        Foo::Bar(0);\n-        Foo::Bar(0, 1);\n-      //^^^^^^^^^^^^^^ Expected 1 argument, found 2\n-        Foo::Bar();\n-      //^^^^^^^^^^ Expected 1 argument, found 0\n-    }\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn varargs() {\n-        check_diagnostics(\n-            r#\"\n-extern \"C\" {\n-    fn fixed(fixed: u8);\n-    fn varargs(fixed: u8, ...);\n-    fn varargs2(...);\n-}\n-\n-fn f() {\n-    unsafe {\n-        fixed(0);\n-        fixed(0, 1);\n-      //^^^^^^^^^^^ Expected 1 argument, found 2\n-        varargs(0);\n-        varargs(0, 1);\n-        varargs2();\n-        varargs2(0);\n-        varargs2(0, 1);\n-    }\n-}\n-        \"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn arg_count_lambda() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    let f = |()| ();\n-    f();\n-  //^^^ Expected 1 argument, found 0\n-    f(());\n-    f((), ());\n-  //^^^^^^^^^ Expected 1 argument, found 2\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn cfgd_out_call_arguments() {\n-        check_diagnostics(\n-            r#\"\n-struct C(#[cfg(FALSE)] ());\n-impl C {\n-    fn new() -> Self {\n-        Self(\n-            #[cfg(FALSE)]\n-            (),\n-        )\n-    }\n-\n-    fn method(&self) {}\n-}\n-\n-fn main() {\n-    C::new().method(#[cfg(FALSE)] 0);\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn cfgd_out_fn_params() {\n-        check_diagnostics(\n-            r#\"\n-fn foo(#[cfg(NEVER)] x: ()) {}\n-\n-struct S;\n-\n-impl S {\n-    fn method(#[cfg(NEVER)] self) {}\n-    fn method2(#[cfg(NEVER)] self, arg: u8) {}\n-    fn method3(self, #[cfg(NEVER)] arg: u8) {}\n-}\n-\n-extern \"C\" {\n-    fn fixed(fixed: u8, #[cfg(NEVER)] ...);\n-    fn varargs(#[cfg(not(NEVER))] ...);\n-}\n-\n-fn main() {\n-    foo();\n-    S::method();\n-    S::method2(0);\n-    S::method3(S);\n-    S.method3();\n-    unsafe {\n-        fixed(0);\n-        varargs(1, 2, 3);\n-    }\n-}\n-            \"#,\n-        )\n-    }\n-}"}, {"sha": "a30e426993c99bb481a789fc757706897c21a91f", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 0, "deletions": 957, "changes": 957, "blob_url": "https://github.com/rust-lang/rust/blob/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=6940cfed1e24a67e816e69e1093e04c0eb73e070", "patch": "@@ -364,960 +364,3 @@ impl PatternFoldable for PatKind {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-pub(super) mod tests {\n-    mod report {\n-        use std::any::Any;\n-\n-        use hir_def::{expr::PatId, DefWithBodyId};\n-        use hir_expand::{HirFileId, InFile};\n-        use syntax::SyntaxNodePtr;\n-\n-        use crate::{\n-            db::HirDatabase,\n-            diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink},\n-        };\n-\n-        /// In tests, match check bails out loudly.\n-        /// This helps to catch incorrect tests that pass due to false negatives.\n-        pub(crate) fn report_bail_out(\n-            db: &dyn HirDatabase,\n-            def: DefWithBodyId,\n-            pat: PatId,\n-            sink: &mut DiagnosticSink,\n-        ) {\n-            let (_, source_map) = db.body_with_source_map(def);\n-            if let Ok(source_ptr) = source_map.pat_syntax(pat) {\n-                let pat_syntax_ptr = source_ptr.value.either(Into::into, Into::into);\n-                sink.push(BailedOut { file: source_ptr.file_id, pat_syntax_ptr });\n-            }\n-        }\n-\n-        #[derive(Debug)]\n-        struct BailedOut {\n-            file: HirFileId,\n-            pat_syntax_ptr: SyntaxNodePtr,\n-        }\n-\n-        impl Diagnostic for BailedOut {\n-            fn code(&self) -> DiagnosticCode {\n-                DiagnosticCode(\"internal:match-check-bailed-out\")\n-            }\n-            fn message(&self) -> String {\n-                format!(\"Internal: match check bailed out\")\n-            }\n-            fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-                InFile { file_id: self.file, value: self.pat_syntax_ptr.clone() }\n-            }\n-            fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-                self\n-            }\n-        }\n-    }\n-\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    pub(crate) use self::report::report_bail_out;\n-\n-    #[test]\n-    fn empty_tuple() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match () { }\n-        //^^ Missing match arm\n-    match (()) { }\n-        //^^^^ Missing match arm\n-\n-    match () { _ => (), }\n-    match () { () => (), }\n-    match (()) { (()) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_two_empty_tuple() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match ((), ()) { }\n-        //^^^^^^^^ Missing match arm\n-\n-    match ((), ()) { ((), ()) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn boolean() {\n-        check_diagnostics(\n-            r#\"\n-fn test_main() {\n-    match false { }\n-        //^^^^^ Missing match arm\n-    match false { true => (), }\n-        //^^^^^ Missing match arm\n-    match (false, true) {}\n-        //^^^^^^^^^^^^^ Missing match arm\n-    match (false, true) { (true, true) => (), }\n-        //^^^^^^^^^^^^^ Missing match arm\n-    match (false, true) {\n-        //^^^^^^^^^^^^^ Missing match arm\n-        (false, true) => (),\n-        (false, false) => (),\n-        (true, false) => (),\n-    }\n-    match (false, true) { (true, _x) => (), }\n-        //^^^^^^^^^^^^^ Missing match arm\n-\n-    match false { true => (), false => (), }\n-    match (false, true) {\n-        (false, _) => (),\n-        (true, false) => (),\n-        (_, true) => (),\n-    }\n-    match (false, true) {\n-        (true, true) => (),\n-        (true, false) => (),\n-        (false, true) => (),\n-        (false, false) => (),\n-    }\n-    match (false, true) {\n-        (true, _x) => (),\n-        (false, true) => (),\n-        (false, false) => (),\n-    }\n-    match (false, true, false) {\n-        (false, ..) => (),\n-        (true, ..) => (),\n-    }\n-    match (false, true, false) {\n-        (.., false) => (),\n-        (.., true) => (),\n-    }\n-    match (false, true, false) { (..) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_tuple_and_bools() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, ((), false)) {}\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-    match (false, ((), false)) { (true, ((), true)) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-    match (false, ((), false)) { (true, _) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-\n-    match (false, ((), false)) {\n-        (true, ((), true)) => (),\n-        (true, ((), false)) => (),\n-        (false, ((), true)) => (),\n-        (false, ((), false)) => (),\n-    }\n-    match (false, ((), false)) {\n-        (true, ((), true)) => (),\n-        (true, ((), false)) => (),\n-        (false, _) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enums() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B, }\n-\n-fn main() {\n-    match Either::A { }\n-        //^^^^^^^^^ Missing match arm\n-    match Either::B { Either::A => (), }\n-        //^^^^^^^^^ Missing match arm\n-\n-    match &Either::B {\n-        //^^^^^^^^^^ Missing match arm\n-        Either::A => (),\n-    }\n-\n-    match Either::B {\n-        Either::A => (), Either::B => (),\n-    }\n-    match &Either::B {\n-        Either::A => (), Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_containing_bool() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B }\n-\n-fn main() {\n-    match Either::B { }\n-        //^^^^^^^^^ Missing match arm\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true) => (), Either::B => ()\n-    }\n-\n-    match Either::B {\n-        Either::A(true) => (),\n-        Either::A(false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        Either::B => (),\n-        _ => (),\n-    }\n-    match Either::B {\n-        Either::A(_) => (),\n-        Either::B => (),\n-    }\n-\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_different_sizes() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B(bool, bool) }\n-\n-fn main() {\n-    match Either::A(false) {\n-        //^^^^^^^^^^^^^^^^ Missing match arm\n-        Either::A(_) => (),\n-        Either::B(false, _) => (),\n-    }\n-\n-    match Either::A(false) {\n-        Either::A(_) => (),\n-        Either::B(true, _) => (),\n-        Either::B(false, _) => (),\n-    }\n-    match Either::A(false) {\n-        Either::A(true) | Either::A(false) => (),\n-        Either::B(true, _) => (),\n-        Either::B(false, _) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_enum_no_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B(bool, bool) }\n-enum Either2 { C, D }\n-\n-fn main() {\n-    match (Either::A(false), Either2::C) {\n-        (Either::A(true), _) | (Either::A(false), _) => (),\n-        (Either::B(true, _), Either2::C) => (),\n-        (Either::B(false, _), Either2::C) => (),\n-        (Either::B(_, _), Either2::D) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn or_pattern_no_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {A, B}\n-\n-fn main() {\n-    match (Either::A, Either::B) {\n-        (Either::A | Either::B, _) => (),\n-    }\n-}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn mismatched_types() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B }\n-enum Either2 { C, D }\n-\n-fn main() {\n-    match Either::A {\n-        Either2::C => (),\n-    //  ^^^^^^^^^^ Internal: match check bailed out\n-        Either2::D => (),\n-    }\n-    match (true, false) {\n-        (true, false, true) => (),\n-    //  ^^^^^^^^^^^^^^^^^^^ Internal: match check bailed out\n-        (true) => (),\n-    }\n-    match (true, false) { (true,) => {} }\n-    //                    ^^^^^^^ Internal: match check bailed out\n-    match (0) { () => () }\n-            //  ^^ Internal: match check bailed out\n-    match Unresolved::Bar { Unresolved::Baz => () }\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn mismatched_types_in_or_patterns() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match false { true | () => {} }\n-    //            ^^^^^^^^^ Internal: match check bailed out\n-    match (false,) { (true | (),) => {} }\n-    //               ^^^^^^^^^^^^ Internal: match check bailed out\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn malformed_match_arm_tuple_enum_missing_pattern() {\n-        // We are testing to be sure we don't panic here when the match\n-        // arm `Either::B` is missing its pattern.\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B(u32) }\n-\n-fn main() {\n-    match Either::A {\n-        Either::A => (),\n-        Either::B() => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn malformed_match_arm_extra_fields() {\n-        check_diagnostics(\n-            r#\"\n-enum A { B(isize, isize), C }\n-fn main() {\n-    match A::B(1, 2) {\n-        A::B(_, _, _) => (),\n-    //  ^^^^^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match A::B(1, 2) {\n-        A::C(_) => (),\n-    //  ^^^^^^^ Internal: match check bailed out\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_diverges() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B }\n-\n-fn main() {\n-    match loop {} {\n-        Either::A => (),\n-    //  ^^^^^^^^^ Internal: match check bailed out\n-        Either::B => (),\n-    }\n-    match loop {} {\n-        Either::A => (),\n-    //  ^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match loop { break Foo::A } {\n-        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        Either::A => (),\n-    }\n-    match loop { break Foo::A } {\n-        Either::A => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_partially_diverges() {\n-        check_diagnostics(\n-            r#\"\n-enum Either<T> { A(T), B }\n-\n-fn foo() -> Either<!> { Either::B }\n-fn main() -> u32 {\n-    match foo() {\n-        Either::A(val) => val,\n-        Either::B => 0,\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A { foo: bool }, B }\n-\n-fn main() {\n-    let a = Either::A { foo: true };\n-    match a { }\n-        //^ Missing match arm\n-    match a { Either::A { foo: true } => () }\n-        //^ Missing match arm\n-    match a {\n-        Either::A { } => (),\n-      //^^^^^^^^^ Missing structure fields:\n-      //        | - foo\n-        Either::B => (),\n-    }\n-    match a {\n-        //^ Missing match arm\n-        Either::A { } => (),\n-    } //^^^^^^^^^ Missing structure fields:\n-      //        | - foo\n-\n-    match a {\n-        Either::A { foo: true } => (),\n-        Either::A { foo: false } => (),\n-        Either::B => (),\n-    }\n-    match a {\n-        Either::A { foo: _ } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record_fields_out_of_order() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A { foo: bool, bar: () },\n-    B,\n-}\n-\n-fn main() {\n-    let a = Either::A { foo: true, bar: () };\n-    match a {\n-        //^ Missing match arm\n-        Either::A { bar: (), foo: false } => (),\n-        Either::A { foo: true, bar: () } => (),\n-    }\n-\n-    match a {\n-        Either::A { bar: (), foo: false } => (),\n-        Either::A { foo: true, bar: () } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record_ellipsis() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A { foo: bool, bar: bool },\n-    B,\n-}\n-\n-fn main() {\n-    let a = Either::B;\n-    match a {\n-        //^ Missing match arm\n-        Either::A { foo: true, .. } => (),\n-        Either::B => (),\n-    }\n-    match a {\n-        //^ Missing match arm\n-        Either::A { .. } => (),\n-    }\n-\n-    match a {\n-        Either::A { foo: true, .. } => (),\n-        Either::A { foo: false, .. } => (),\n-        Either::B => (),\n-    }\n-\n-    match a {\n-        Either::A { .. } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A(bool, bool, bool, bool),\n-    B,\n-}\n-\n-fn main() {\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(false, .., false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(.., true) => (),\n-        Either::B => (),\n-    }\n-\n-    match Either::B {\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(false, .., true) => (),\n-        Either::A(false, .., false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(.., true) => (),\n-        Either::A(.., false) => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn never() {\n-        check_diagnostics(\n-            r#\"\n-enum Never {}\n-\n-fn enum_(never: Never) {\n-    match never {}\n-}\n-fn enum_ref(never: &Never) {\n-    match never {}\n-        //^^^^^ Missing match arm\n-}\n-fn bang(never: !) {\n-    match never {}\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unknown_type() {\n-        check_diagnostics(\n-            r#\"\n-enum Option<T> { Some(T), None }\n-\n-fn main() {\n-    // `Never` is deliberately not defined so that it's an uninferred type.\n-    match Option::<Never>::None {\n-        None => (),\n-        Some(never) => match never {},\n-    //  ^^^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match Option::<Never>::None {\n-        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        Option::Some(_never) => {},\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (false, ..) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (.., false) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (true, .., false) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo { a: bool }\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo { a: true } => () }\n-        //^ Missing match arm\n-    match &f { Foo { a: true } => () }\n-        //^^ Missing match arm\n-    match f { Foo { a: _ } => () }\n-    match f {\n-        Foo { a: true } => (),\n-        Foo { a: false } => (),\n-    }\n-    match &f {\n-        Foo { a: true } => (),\n-        Foo { a: false } => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo(bool);\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo(true) => () }\n-        //^ Missing match arm\n-    match f {\n-        Foo(true) => (),\n-        Foo(false) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unit_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo;\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo => () }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct_ellipsis() {\n-        check_diagnostics(\n-            r#\"struct Foo { foo: bool, bar: bool }\n-fn main(f: Foo) {\n-    match f { Foo { foo: true, .. } => () }\n-        //^ Missing match arm\n-    match f {\n-        //^ Missing match arm\n-        Foo { foo: true, .. } => (),\n-        Foo { bar: false, .. } => ()\n-    }\n-    match f { Foo { .. } => () }\n-    match f {\n-        Foo { foo: true, .. } => (),\n-        Foo { foo: false, .. } => ()\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn internal_or() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    enum Either { A(bool), B }\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true | false) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_panic_at_unimplemented_subpattern_type() {\n-        check_diagnostics(\n-            r#\"\n-struct S { a: char}\n-fn main(v: S) {\n-    match v { S{ a }      => {} }\n-    match v { S{ a: _x }  => {} }\n-    match v { S{ a: 'a' } => {} }\n-            //^^^^^^^^^^^ Internal: match check bailed out\n-    match v { S{..}       => {} }\n-    match v { _           => {} }\n-    match v { }\n-        //^ Missing match arm\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn binding() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match true {\n-        _x @ true => {}\n-        false     => {}\n-    }\n-    match true { _x @ true => {} }\n-        //^^^^ Missing match arm\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn binding_ref_has_correct_type() {\n-        // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n-        // If that's not true match checking will panic with \"incompatible constructors\"\n-        // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n-        check_diagnostics(\n-            r#\"\n-enum Foo { A }\n-fn main() {\n-    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n-    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n-    match Foo::A {\n-        ref _x => {}\n-    //  ^^^^^^ Internal: match check bailed out\n-        Foo::A => {}\n-    }\n-    match (true,) {\n-        (ref _x,) => {}\n-        (true,) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_non_exhaustive() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:lib\n-#[non_exhaustive]\n-pub enum E { A, B }\n-fn _local() {\n-    match E::A { _ => {} }\n-    match E::A {\n-        E::A => {}\n-        E::B => {}\n-    }\n-    match E::A {\n-        E::A | E::B => {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:lib\n-use lib::E;\n-fn main() {\n-    match E::A { _ => {} }\n-    match E::A {\n-        //^^^^ Missing match arm\n-        E::A => {}\n-        E::B => {}\n-    }\n-    match E::A {\n-        //^^^^ Missing match arm\n-        E::A | E::B => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn match_guard() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match true {\n-        true if false => {}\n-        true          => {}\n-        false         => {}\n-    }\n-    match true {\n-        //^^^^ Missing match arm\n-        true if false => {}\n-        false         => {}\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn pattern_type_is_of_substitution() {\n-        cov_mark::check!(match_check_wildcard_expanded_to_substitutions);\n-        check_diagnostics(\n-            r#\"\n-struct Foo<T>(T);\n-struct Bar;\n-fn main() {\n-    match Foo(Bar) {\n-        _ | Foo(Bar) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct_no_such_field() {\n-        check_diagnostics(\n-            r#\"\n-struct Foo { }\n-fn main(f: Foo) {\n-    match f { Foo { bar } => () }\n-    //        ^^^^^^^^^^^ Internal: match check bailed out\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn match_ergonomics_issue_9095() {\n-        check_diagnostics(\n-            r#\"\n-enum Foo<T> { A(T) }\n-fn main() {\n-    match &Foo::A(true) {\n-        _ => {}\n-        Foo::A(_) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    mod false_negatives {\n-        //! The implementation of match checking here is a work in progress. As we roll this out, we\n-        //! prefer false negatives to false positives (ideally there would be no false positives). This\n-        //! test module should document known false negatives. Eventually we will have a complete\n-        //! implementation of match checking and this module will be empty.\n-        //!\n-        //! The reasons for documenting known false negatives:\n-        //!\n-        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n-        //!   2. It ensures the code doesn't panic when handling these cases.\n-        use super::*;\n-\n-        #[test]\n-        fn integers() {\n-            // We don't currently check integer exhaustiveness.\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match 5 {\n-        10 => (),\n-    //  ^^ Internal: match check bailed out\n-        11..20 => (),\n-    }\n-}\n-\"#,\n-            );\n-        }\n-\n-        #[test]\n-        fn reference_patterns_at_top_level() {\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match &false {\n-        &true => {}\n-    //  ^^^^^ Internal: match check bailed out\n-    }\n-}\n-            \"#,\n-            );\n-        }\n-\n-        #[test]\n-        fn reference_patterns_in_fields() {\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match (&false,) {\n-        (true,) => {}\n-    //  ^^^^^^^ Internal: match check bailed out\n-    }\n-    match (&false,) {\n-        (&true,) => {}\n-    //  ^^^^^^^^ Internal: match check bailed out\n-    }\n-}\n-            \"#,\n-            );\n-        }\n-    }\n-}"}, {"sha": "222141bd6a5536300a4be8ac5de01127a0adac63", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=6940cfed1e24a67e816e69e1093e04c0eb73e070", "patch": "@@ -664,7 +664,6 @@ impl Fields {\n                         let is_non_exhaustive =\n                             is_field_list_non_exhaustive(variant_id, cx) && !adt_is_local;\n \n-                        cov_mark::hit!(match_check_wildcard_expanded_to_substitutions);\n                         let field_ty_data = cx.db.field_types(variant_id);\n                         let field_tys = || {\n                             field_ty_data"}, {"sha": "dffb6fdc8509dfeb8725d888aae74e346546b1f9", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 1303, "deletions": 1, "changes": 1304, "blob_url": "https://github.com/rust-lang/rust/blob/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cfed1e24a67e816e69e1093e04c0eb73e070/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=6940cfed1e24a67e816e69e1093e04c0eb73e070", "patch": "@@ -204,8 +204,9 @@ pub(crate) fn diagnostics(\n             );\n         });\n \n+    let internal_diagnostics = cfg!(test);\n     match sema.to_module_def(file_id) {\n-        Some(m) => m.diagnostics(db, &mut sink),\n+        Some(m) => m.diagnostics(db, &mut sink, internal_diagnostics),\n         None => {\n             sink.push(UnlinkedFile { file_id, node: SyntaxNodePtr::new(&parse.tree().syntax()) });\n         }\n@@ -942,4 +943,1305 @@ fn main() {\n \"#,\n         );\n     }\n+\n+    // Register the required standard library types to make the tests work\n+    fn add_filter_map_with_find_next_boilerplate(body: &str) -> String {\n+        let prefix = r#\"\n+        //- /main.rs crate:main deps:core\n+        use core::iter::Iterator;\n+        use core::option::Option::{self, Some, None};\n+        \"#;\n+        let suffix = r#\"\n+        //- /core/lib.rs crate:core\n+        pub mod option {\n+            pub enum Option<T> { Some(T), None }\n+        }\n+        pub mod iter {\n+            pub trait Iterator {\n+                type Item;\n+                fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n+                fn next(&mut self) -> Option<Self::Item>;\n+            }\n+            pub struct FilterMap {}\n+            impl Iterator for FilterMap {\n+                type Item = i32;\n+                fn next(&mut self) -> i32 { 7 }\n+            }\n+        }\n+        \"#;\n+        format!(\"{}{}{}\", prefix, body, suffix)\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map2() {\n+        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n+            r#\"\n+            fn foo() {\n+                let m = [1, 2, 3].iter().filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n+                      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ replace filter_map(..).next() with find_map(..)\n+            }\n+        \"#,\n+        ));\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_without_next() {\n+        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n+            r#\"\n+            fn foo() {\n+                let m = [1, 2, 3]\n+                    .iter()\n+                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+                    .len();\n+            }\n+            \"#,\n+        ));\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_with_intervening_methods() {\n+        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n+            r#\"\n+            fn foo() {\n+                let m = [1, 2, 3]\n+                    .iter()\n+                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+                    .map(|x| x + 2)\n+                    .len();\n+            }\n+            \"#,\n+        ));\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_if_not_in_chain() {\n+        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n+            r#\"\n+            fn foo() {\n+                let m = [1, 2, 3]\n+                    .iter()\n+                    .filter_map(|x| if *x == 2 { Some (4) } else { None });\n+                let n = m.next();\n+            }\n+            \"#,\n+        ));\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) {\n+    let S { foo: _ } = s;\n+      //^ Missing structure fields:\n+      //| - bar\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n+        check_diagnostics(\n+            r\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) -> i32 {\n+    match s {\n+        S { foo, .. } => foo,\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_box() {\n+        check_diagnostics(\n+            r\"\n+struct S { s: Box<u32> }\n+fn x(a: S) {\n+    let S { box s } = a;\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_ref() {\n+        check_diagnostics(\n+            r\"\n+struct S { s: u32 }\n+fn x(a: S) {\n+    let S { ref s } = a;\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn simple_free_fn_zero() {\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(1); }\n+       //^^^^^^^ Expected 0 arguments, found 1\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_free_fn_one() {\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(); }\n+       //^^^^^ Expected 1 argument, found 0\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(1); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_as_fn() {\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method();\n+} //^^^^^^^^^^^ Expected 1 argument, found 0\n+\"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method(&S);\n+    S.method();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_arg() {\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n+\n+            fn f() {\n+                S.method();\n+            } //^^^^^^^^^^ Expected 1 argument, found 0\n+            \"#,\n+        );\n+\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n+\n+fn f() {\n+    S::method(&S, 0);\n+    S.method(1);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_unknown_receiver() {\n+        // note: this is incorrect code, so there might be errors on this in the\n+        // future, but we shouldn't emit an argument count diagnostic here\n+        check_diagnostics(\n+            r#\"\n+trait Foo { fn method(&self, arg: usize) {} }\n+\n+fn f() {\n+    let x;\n+    x.method();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct() {\n+        check_diagnostics(\n+            r#\"\n+struct Tup(u8, u16);\n+fn f() {\n+    Tup(0);\n+} //^^^^^^ Expected 2 arguments, found 1\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn enum_variant() {\n+        check_diagnostics(\n+            r#\"\n+enum En { Variant(u8, u16), }\n+fn f() {\n+    En::Variant(0);\n+} //^^^^^^^^^^^^^^ Expected 2 arguments, found 1\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn enum_variant_type_macro() {\n+        check_diagnostics(\n+            r#\"\n+macro_rules! Type {\n+    () => { u32 };\n+}\n+enum Foo {\n+    Bar(Type![])\n+}\n+impl Foo {\n+    fn new() {\n+        Foo::Bar(0);\n+        Foo::Bar(0, 1);\n+      //^^^^^^^^^^^^^^ Expected 1 argument, found 2\n+        Foo::Bar();\n+      //^^^^^^^^^^ Expected 1 argument, found 0\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn varargs() {\n+        check_diagnostics(\n+            r#\"\n+extern \"C\" {\n+    fn fixed(fixed: u8);\n+    fn varargs(fixed: u8, ...);\n+    fn varargs2(...);\n+}\n+\n+fn f() {\n+    unsafe {\n+        fixed(0);\n+        fixed(0, 1);\n+      //^^^^^^^^^^^ Expected 1 argument, found 2\n+        varargs(0);\n+        varargs(0, 1);\n+        varargs2();\n+        varargs2(0);\n+        varargs2(0, 1);\n+    }\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn arg_count_lambda() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let f = |()| ();\n+    f();\n+  //^^^ Expected 1 argument, found 0\n+    f(());\n+    f((), ());\n+  //^^^^^^^^^ Expected 1 argument, found 2\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn cfgd_out_call_arguments() {\n+        check_diagnostics(\n+            r#\"\n+struct C(#[cfg(FALSE)] ());\n+impl C {\n+    fn new() -> Self {\n+        Self(\n+            #[cfg(FALSE)]\n+            (),\n+        )\n+    }\n+\n+    fn method(&self) {}\n+}\n+\n+fn main() {\n+    C::new().method(#[cfg(FALSE)] 0);\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn cfgd_out_fn_params() {\n+        check_diagnostics(\n+            r#\"\n+fn foo(#[cfg(NEVER)] x: ()) {}\n+\n+struct S;\n+\n+impl S {\n+    fn method(#[cfg(NEVER)] self) {}\n+    fn method2(#[cfg(NEVER)] self, arg: u8) {}\n+    fn method3(self, #[cfg(NEVER)] arg: u8) {}\n+}\n+\n+extern \"C\" {\n+    fn fixed(fixed: u8, #[cfg(NEVER)] ...);\n+    fn varargs(#[cfg(not(NEVER))] ...);\n+}\n+\n+fn main() {\n+    foo();\n+    S::method();\n+    S::method2(0);\n+    S::method3(S);\n+    S.method3();\n+    unsafe {\n+        fixed(0);\n+        varargs(1, 2, 3);\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_semicolon() {\n+        check_diagnostics(\n+            r#\"\n+                fn test() -> i32 { 123; }\n+                                 //^^^ Remove this semicolon\n+            \"#,\n+        );\n+    }\n+}\n+\n+#[cfg(test)]\n+pub(super) mod match_check_tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match () { }\n+        //^^ Missing match arm\n+    match (()) { }\n+        //^^^^ Missing match arm\n+\n+    match () { _ => (), }\n+    match () { () => (), }\n+    match (()) { (()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_two_empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match ((), ()) { }\n+        //^^^^^^^^ Missing match arm\n+\n+    match ((), ()) { ((), ()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn boolean() {\n+        check_diagnostics(\n+            r#\"\n+fn test_main() {\n+    match false { }\n+        //^^^^^ Missing match arm\n+    match false { true => (), }\n+        //^^^^^ Missing match arm\n+    match (false, true) {}\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) { (true, true) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) {\n+        //^^^^^^^^^^^^^ Missing match arm\n+        (false, true) => (),\n+        (false, false) => (),\n+        (true, false) => (),\n+    }\n+    match (false, true) { (true, _x) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+\n+    match false { true => (), false => (), }\n+    match (false, true) {\n+        (false, _) => (),\n+        (true, false) => (),\n+        (_, true) => (),\n+    }\n+    match (false, true) {\n+        (true, true) => (),\n+        (true, false) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true) {\n+        (true, _x) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true, false) {\n+        (false, ..) => (),\n+        (true, ..) => (),\n+    }\n+    match (false, true, false) {\n+        (.., false) => (),\n+        (.., true) => (),\n+    }\n+    match (false, true, false) { (..) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, ((), false)) {}\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, ((), true)) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, _) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, ((), true)) => (),\n+        (false, ((), false)) => (),\n+    }\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, _) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enums() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B, }\n+\n+fn main() {\n+    match Either::A { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B { Either::A => (), }\n+        //^^^^^^^^^ Missing match arm\n+\n+    match &Either::B {\n+        //^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n+    }\n+\n+    match Either::B {\n+        Either::A => (), Either::B => (),\n+    }\n+    match &Either::B {\n+        Either::A => (), Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B }\n+\n+fn main() {\n+    match Either::B { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true) => (), Either::B => ()\n+    }\n+\n+    match Either::B {\n+        Either::A(true) => (),\n+        Either::A(false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::B => (),\n+        _ => (),\n+    }\n+    match Either::B {\n+        Either::A(_) => (),\n+        Either::B => (),\n+    }\n+\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_different_sizes() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+\n+fn main() {\n+    match Either::A(false) {\n+        //^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A(_) => (),\n+        Either::B(false, _) => (),\n+    }\n+\n+    match Either::A(false) {\n+        Either::A(_) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n+    }\n+    match Either::A(false) {\n+        Either::A(true) | Either::A(false) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_enum_no_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match (Either::A(false), Either2::C) {\n+        (Either::A(true), _) | (Either::A(false), _) => (),\n+        (Either::B(true, _), Either2::C) => (),\n+        (Either::B(false, _), Either2::C) => (),\n+        (Either::B(_, _), Either2::D) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern_no_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {A, B}\n+\n+fn main() {\n+    match (Either::A, Either::B) {\n+        (Either::A | Either::B, _) => (),\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn mismatched_types() {\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match Either::A {\n+        Either2::C => (),\n+    //  ^^^^^^^^^^ Internal: match check bailed out\n+        Either2::D => (),\n+    }\n+    match (true, false) {\n+        (true, false, true) => (),\n+    //  ^^^^^^^^^^^^^^^^^^^ Internal: match check bailed out\n+        (true) => (),\n+    }\n+    match (true, false) { (true,) => {} }\n+    //                    ^^^^^^^ Internal: match check bailed out\n+    match (0) { () => () }\n+            //  ^^ Internal: match check bailed out\n+    match Unresolved::Bar { Unresolved::Baz => () }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mismatched_types_in_or_patterns() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match false { true | () => {} }\n+    //            ^^^^^^^^^ Internal: match check bailed out\n+    match (false,) { (true | (),) => {} }\n+    //               ^^^^^^^^^^^^ Internal: match check bailed out\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_tuple_enum_missing_pattern() {\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B(u32) }\n+\n+fn main() {\n+    match Either::A {\n+        Either::A => (),\n+        Either::B() => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_extra_fields() {\n+        check_diagnostics(\n+            r#\"\n+enum A { B(isize, isize), C }\n+fn main() {\n+    match A::B(1, 2) {\n+        A::B(_, _, _) => (),\n+    //  ^^^^^^^^^^^^^ Internal: match check bailed out\n+    }\n+    match A::B(1, 2) {\n+        A::C(_) => (),\n+    //  ^^^^^^^ Internal: match check bailed out\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn expr_diverges() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+\n+fn main() {\n+    match loop {} {\n+        Either::A => (),\n+    //  ^^^^^^^^^ Internal: match check bailed out\n+        Either::B => (),\n+    }\n+    match loop {} {\n+        Either::A => (),\n+    //  ^^^^^^^^^ Internal: match check bailed out\n+    }\n+    match loop { break Foo::A } {\n+        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn expr_partially_diverges() {\n+        check_diagnostics(\n+            r#\"\n+enum Either<T> { A(T), B }\n+\n+fn foo() -> Either<!> { Either::B }\n+fn main() -> u32 {\n+    match foo() {\n+        Either::A(val) => val,\n+        Either::B => 0,\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A { foo: bool }, B }\n+\n+fn main() {\n+    let a = Either::A { foo: true };\n+    match a { }\n+        //^ Missing match arm\n+    match a { Either::A { foo: true } => () }\n+        //^ Missing match arm\n+    match a {\n+        Either::A { } => (),\n+      //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n+        Either::B => (),\n+    }\n+    match a {\n+        //^ Missing match arm\n+        Either::A { } => (),\n+    } //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n+\n+    match a {\n+        Either::A { foo: true } => (),\n+        Either::A { foo: false } => (),\n+        Either::B => (),\n+    }\n+    match a {\n+        Either::A { foo: _ } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record_fields_out_of_order() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: () },\n+    B,\n+}\n+\n+fn main() {\n+    let a = Either::A { foo: true, bar: () };\n+    match a {\n+        //^ Missing match arm\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+    }\n+\n+    match a {\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: bool },\n+    B,\n+}\n+\n+fn main() {\n+    let a = Either::B;\n+    match a {\n+        //^ Missing match arm\n+        Either::A { foo: true, .. } => (),\n+        Either::B => (),\n+    }\n+    match a {\n+        //^ Missing match arm\n+        Either::A { .. } => (),\n+    }\n+\n+    match a {\n+        Either::A { foo: true, .. } => (),\n+        Either::A { foo: false, .. } => (),\n+        Either::B => (),\n+    }\n+\n+    match a {\n+        Either::A { .. } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A(bool, bool, bool, bool),\n+    B,\n+}\n+\n+fn main() {\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::B => (),\n+    }\n+\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., true) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::A(.., false) => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn never() {\n+        check_diagnostics(\n+            r#\"\n+enum Never {}\n+\n+fn enum_(never: Never) {\n+    match never {}\n+}\n+fn enum_ref(never: &Never) {\n+    match never {}\n+        //^^^^^ Missing match arm\n+}\n+fn bang(never: !) {\n+    match never {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unknown_type() {\n+        check_diagnostics(\n+            r#\"\n+enum Option<T> { Some(T), None }\n+\n+fn main() {\n+    // `Never` is deliberately not defined so that it's an uninferred type.\n+    match Option::<Never>::None {\n+        None => (),\n+        Some(never) => match never {},\n+    //  ^^^^^^^^^^^ Internal: match check bailed out\n+    }\n+    match Option::<Never>::None {\n+        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        Option::Some(_never) => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        (false, ..) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        (.., false) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        (true, .., false) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo { a: bool }\n+fn main(f: Foo) {\n+    match f {}\n+        //^ Missing match arm\n+    match f { Foo { a: true } => () }\n+        //^ Missing match arm\n+    match &f { Foo { a: true } => () }\n+        //^^ Missing match arm\n+    match f { Foo { a: _ } => () }\n+    match f {\n+        Foo { a: true } => (),\n+        Foo { a: false } => (),\n+    }\n+    match &f {\n+        Foo { a: true } => (),\n+        Foo { a: false } => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo(bool);\n+fn main(f: Foo) {\n+    match f {}\n+        //^ Missing match arm\n+    match f { Foo(true) => () }\n+        //^ Missing match arm\n+    match f {\n+        Foo(true) => (),\n+        Foo(false) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unit_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo;\n+fn main(f: Foo) {\n+    match f {}\n+        //^ Missing match arm\n+    match f { Foo => () }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct_ellipsis() {\n+        check_diagnostics(\n+            r#\"struct Foo { foo: bool, bar: bool }\n+fn main(f: Foo) {\n+    match f { Foo { foo: true, .. } => () }\n+        //^ Missing match arm\n+    match f {\n+        //^ Missing match arm\n+        Foo { foo: true, .. } => (),\n+        Foo { bar: false, .. } => ()\n+    }\n+    match f { Foo { .. } => () }\n+    match f {\n+        Foo { foo: true, .. } => (),\n+        Foo { foo: false, .. } => ()\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn internal_or() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    enum Either { A(bool), B }\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true | false) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_panic_at_unimplemented_subpattern_type() {\n+        check_diagnostics(\n+            r#\"\n+struct S { a: char}\n+fn main(v: S) {\n+    match v { S{ a }      => {} }\n+    match v { S{ a: _x }  => {} }\n+    match v { S{ a: 'a' } => {} }\n+            //^^^^^^^^^^^ Internal: match check bailed out\n+    match v { S{..}       => {} }\n+    match v { _           => {} }\n+    match v { }\n+        //^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match true {\n+        _x @ true => {}\n+        false     => {}\n+    }\n+    match true { _x @ true => {} }\n+        //^^^^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding_ref_has_correct_type() {\n+        // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n+        // If that's not true match checking will panic with \"incompatible constructors\"\n+        // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n+        check_diagnostics(\n+            r#\"\n+enum Foo { A }\n+fn main() {\n+    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n+    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n+    match Foo::A {\n+        ref _x => {}\n+    //  ^^^^^^ Internal: match check bailed out\n+        Foo::A => {}\n+    }\n+    match (true,) {\n+        (ref _x,) => {}\n+        (true,) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_non_exhaustive() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:lib\n+#[non_exhaustive]\n+pub enum E { A, B }\n+fn _local() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        E::A | E::B => {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:lib\n+use lib::E;\n+fn main() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        //^^^^ Missing match arm\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        //^^^^ Missing match arm\n+        E::A | E::B => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_guard() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match true {\n+        true if false => {}\n+        true          => {}\n+        false         => {}\n+    }\n+    match true {\n+        //^^^^ Missing match arm\n+        true if false => {}\n+        false         => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn pattern_type_is_of_substitution() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo<T>(T);\n+struct Bar;\n+fn main() {\n+    match Foo(Bar) {\n+        _ | Foo(Bar) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct_no_such_field() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo { }\n+fn main(f: Foo) {\n+    match f { Foo { bar } => () }\n+    //        ^^^^^^^^^^^ Internal: match check bailed out\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_ergonomics_issue_9095() {\n+        check_diagnostics(\n+            r#\"\n+enum Foo<T> { A(T) }\n+fn main() {\n+    match &Foo::A(true) {\n+        _ => {}\n+        Foo::A(_) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    mod false_negatives {\n+        //! The implementation of match checking here is a work in progress. As we roll this out, we\n+        //! prefer false negatives to false positives (ideally there would be no false positives). This\n+        //! test module should document known false negatives. Eventually we will have a complete\n+        //! implementation of match checking and this module will be empty.\n+        //!\n+        //! The reasons for documenting known false negatives:\n+        //!\n+        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+        //!   2. It ensures the code doesn't panic when handling these cases.\n+        use super::*;\n+\n+        #[test]\n+        fn integers() {\n+            // We don't currently check integer exhaustiveness.\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match 5 {\n+        10 => (),\n+    //  ^^ Internal: match check bailed out\n+        11..20 => (),\n+    }\n+}\n+\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn reference_patterns_at_top_level() {\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match &false {\n+        &true => {}\n+    //  ^^^^^ Internal: match check bailed out\n+    }\n+}\n+            \"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn reference_patterns_in_fields() {\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (&false,) {\n+        (true,) => {}\n+    //  ^^^^^^^ Internal: match check bailed out\n+    }\n+    match (&false,) {\n+        (&true,) => {}\n+    //  ^^^^^^^^ Internal: match check bailed out\n+    }\n+}\n+            \"#,\n+            );\n+        }\n+    }\n }"}]}