{"sha": "cb417881a9341e3258a3b1fa4a14c0717e226d61", "node_id": "C_kwDOAAsO6NoAKGNiNDE3ODgxYTkzNDFlMzI1OGEzYjFmYTRhMTRjMDcxN2UyMjZkNjE", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-05-14T04:53:03Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-06-16T01:38:26Z"}, "message": "remove box derefs from codgen", "tree": {"sha": "11a4d98ee39821864826411ccf9a90b3c92d4753", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11a4d98ee39821864826411ccf9a90b3c92d4753"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb417881a9341e3258a3b1fa4a14c0717e226d61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb417881a9341e3258a3b1fa4a14c0717e226d61", "html_url": "https://github.com/rust-lang/rust/commit/cb417881a9341e3258a3b1fa4a14c0717e226d61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb417881a9341e3258a3b1fa4a14c0717e226d61/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e9d3d917a988973d9c657a257029a9bd850f6dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e9d3d917a988973d9c657a257029a9bd850f6dc", "html_url": "https://github.com/rust-lang/rust/commit/3e9d3d917a988973d9c657a257029a9bd850f6dc"}], "stats": {"total": 531, "additions": 385, "deletions": 146}, "files": [{"sha": "e8fab80452416f0af037133f65753d0c6449ec8f", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -118,22 +118,20 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n     }\n \n     pub fn deref<Cx: LayoutTypeMethods<'tcx>>(self, cx: &Cx) -> PlaceRef<'tcx, V> {\n+        if self.layout.ty.is_box() && !self.layout.abi.is_scalar() {\n+            bug!(\"dereferencing non-scalar box ({:?}) in codegen\", self.layout.ty);\n+        }\n+\n         let projected_ty = self\n             .layout\n             .ty\n             .builtin_deref(true)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self))\n             .ty;\n+\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, None),\n-            OperandValue::Pair(llptr, llextra) => {\n-                // if the box's allocator isn't a ZST, then \"llextra\" is actually the allocator\n-                if self.layout.ty.is_box() && !self.layout.field(cx, 1).is_zst() {\n-                    (llptr, None)\n-                } else {\n-                    (llptr, Some(llextra))\n-                }\n-            }\n+            OperandValue::Pair(llptr, llextra) => (llptr, Some(llextra)),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self),\n         };\n         let layout = cx.layout_of(projected_ty);"}, {"sha": "5b88635982f543e33eb4bd5977f1732380ce0117", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -446,35 +446,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         mir::PlaceRef { projection: &place_ref.projection[..elem.0], ..place_ref },\n                     );\n \n-                    // a box with a non-zst allocator should not be directly dereferenced\n-                    if cg_base.layout.ty.is_box() && !cg_base.layout.field(cx, 1).is_zst() {\n-                        // Extract `Box<T>` -> `Unique<T>` -> `NonNull<T>` -> `*const T`\n-                        let ptr =\n-                            cg_base.extract_field(bx, 0).extract_field(bx, 0).extract_field(bx, 0);\n-\n-                        ptr.deref(bx.cx())\n-                    } else {\n-                        cg_base.deref(bx.cx())\n-                    }\n+                    cg_base.deref(bx.cx())\n                 } else {\n                     bug!(\"using operand local {:?} as place\", place_ref);\n                 }\n             }\n         };\n         for elem in place_ref.projection[base..].iter() {\n             cg_base = match *elem {\n-                mir::ProjectionElem::Deref => {\n-                    // a box with a non-zst allocator should not be directly dereferenced\n-                    if cg_base.layout.ty.is_box() && !cg_base.layout.field(cx, 1).is_zst() {\n-                        // Project `Box<T>` -> `Unique<T>` -> `NonNull<T>` -> `*const T`\n-                        let ptr =\n-                            cg_base.project_field(bx, 0).project_field(bx, 0).project_field(bx, 0);\n-\n-                        bx.load_operand(ptr).deref(bx.cx())\n-                    } else {\n-                        bx.load_operand(cg_base).deref(bx.cx())\n-                    }\n-                }\n+                mir::ProjectionElem::Deref => bx.load_operand(cg_base).deref(bx.cx()),\n                 mir::ProjectionElem::Field(ref field, _) => {\n                     cg_base.project_field(bx, field.index())\n                 }"}, {"sha": "66d66ea951033ceb10ea9a280fd53b446ca41051", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -240,65 +240,79 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         context: PlaceContext,\n         location: Location,\n     ) {\n-        if let ProjectionElem::Index(index) = elem {\n-            let index_ty = self.body.local_decls[index].ty;\n-            if index_ty != self.tcx.types.usize {\n-                self.fail(location, format!(\"bad index ({:?} != usize)\", index_ty))\n+        match elem {\n+            ProjectionElem::Index(index) => {\n+                let index_ty = self.body.local_decls[index].ty;\n+                if index_ty != self.tcx.types.usize {\n+                    self.fail(location, format!(\"bad index ({:?} != usize)\", index_ty))\n+                }\n             }\n-        }\n-        if let ProjectionElem::Field(f, ty) = elem {\n-            let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n-            let parent_ty = parent.ty(&self.body.local_decls, self.tcx);\n-            let fail_out_of_bounds = |this: &Self, location| {\n-                this.fail(location, format!(\"Out of bounds field {:?} for {:?}\", f, parent_ty));\n-            };\n-            let check_equal = |this: &Self, location, f_ty| {\n-                if !this.mir_assign_valid_types(ty, f_ty) {\n-                    this.fail(\n+            ProjectionElem::Deref if self.mir_phase >= MirPhase::GeneratorsLowered => {\n+                let base_ty = Place::ty_from(local, proj_base, &self.body.local_decls, self.tcx).ty;\n+\n+                if base_ty.is_box() {\n+                    self.fail(\n+                        location,\n+                        format!(\"{:?} dereferenced after ElaborateBoxDerefs\", base_ty),\n+                    )\n+                }\n+            }\n+            ProjectionElem::Field(f, ty) => {\n+                let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n+                let parent_ty = parent.ty(&self.body.local_decls, self.tcx);\n+                let fail_out_of_bounds = |this: &Self, location| {\n+                    this.fail(location, format!(\"Out of bounds field {:?} for {:?}\", f, parent_ty));\n+                };\n+                let check_equal = |this: &Self, location, f_ty| {\n+                    if !this.mir_assign_valid_types(ty, f_ty) {\n+                        this.fail(\n                         location,\n                         format!(\n                             \"Field projection `{:?}.{:?}` specified type `{:?}`, but actual type is {:?}\",\n                             parent, f, ty, f_ty\n                         )\n                     )\n-                }\n-            };\n-            match parent_ty.ty.kind() {\n-                ty::Tuple(fields) => {\n-                    let Some(f_ty) = fields.get(f.as_usize()) else {\n-                        fail_out_of_bounds(self, location);\n-                        return;\n-                    };\n-                    check_equal(self, location, *f_ty);\n-                }\n-                ty::Adt(adt_def, substs) => {\n-                    let var = parent_ty.variant_index.unwrap_or(VariantIdx::from_u32(0));\n-                    let Some(field) = adt_def.variant(var).fields.get(f.as_usize()) else {\n-                        fail_out_of_bounds(self, location);\n-                        return;\n-                    };\n-                    check_equal(self, location, field.ty(self.tcx, substs));\n-                }\n-                ty::Closure(_, substs) => {\n-                    let substs = substs.as_closure();\n-                    let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n-                        fail_out_of_bounds(self, location);\n-                        return;\n-                    };\n-                    check_equal(self, location, f_ty);\n-                }\n-                ty::Generator(_, substs, _) => {\n-                    let substs = substs.as_generator();\n-                    let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n-                        fail_out_of_bounds(self, location);\n-                        return;\n-                    };\n-                    check_equal(self, location, f_ty);\n-                }\n-                _ => {\n-                    self.fail(location, format!(\"{:?} does not have fields\", parent_ty.ty));\n+                    }\n+                };\n+\n+                match parent_ty.ty.kind() {\n+                    ty::Tuple(fields) => {\n+                        let Some(f_ty) = fields.get(f.as_usize()) else {\n+                            fail_out_of_bounds(self, location);\n+                            return;\n+                        };\n+                        check_equal(self, location, *f_ty);\n+                    }\n+                    ty::Adt(adt_def, substs) => {\n+                        let var = parent_ty.variant_index.unwrap_or(VariantIdx::from_u32(0));\n+                        let Some(field) = adt_def.variant(var).fields.get(f.as_usize()) else {\n+                            fail_out_of_bounds(self, location);\n+                            return;\n+                        };\n+                        check_equal(self, location, field.ty(self.tcx, substs));\n+                    }\n+                    ty::Closure(_, substs) => {\n+                        let substs = substs.as_closure();\n+                        let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n+                            fail_out_of_bounds(self, location);\n+                            return;\n+                        };\n+                        check_equal(self, location, f_ty);\n+                    }\n+                    ty::Generator(_, substs, _) => {\n+                        let substs = substs.as_generator();\n+                        let Some(f_ty) = substs.upvar_tys().nth(f.as_usize()) else {\n+                            fail_out_of_bounds(self, location);\n+                            return;\n+                        };\n+                        check_equal(self, location, f_ty);\n+                    }\n+                    _ => {\n+                        self.fail(location, format!(\"{:?} does not have fields\", parent_ty.ty));\n+                    }\n                 }\n             }\n+            _ => {}\n         }\n         self.super_projection_elem(local, proj_base, elem, context, location);\n     }"}, {"sha": "b9e039d098b4fe542e30b60ab5be03f6ceac0b00", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -176,8 +176,9 @@ pub enum MirPhase {\n     DropsLowered = 3,\n     /// After this projections may only contain deref projections as the first element.\n     Derefered = 4,\n-    /// Beginning with this phase, the following variant is disallowed:\n+    /// Beginning with this phase, the following variants are disallowed:\n     /// * [`Rvalue::Aggregate`] for any `AggregateKind` except `Array`\n+    /// * [`ProjectionElem::Deref`] of `Box`\n     ///\n     /// And the following variant is allowed:\n     /// * [`StatementKind::SetDiscriminant`]"}, {"sha": "c0b0cc3c591b01ef68a558bc24ce2f1c88378f72", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -410,7 +410,18 @@ where\n     fn open_drop_for_box(&mut self, adt: ty::AdtDef<'tcx>, substs: SubstsRef<'tcx>) -> BasicBlock {\n         debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n \n-        let interior = self.tcx().mk_place_deref(self.place);\n+        // drop glue is sent straight to codegen\n+        // box cannot be directly dereferenced\n+        let unique_ty = adt.non_enum_variant().fields[0].ty(self.tcx(), substs);\n+        let nonnull_ty =\n+            unique_ty.ty_adt_def().unwrap().non_enum_variant().fields[0].ty(self.tcx(), substs);\n+        let ptr_ty = self.tcx().mk_imm_ptr(substs[0].expect_ty());\n+\n+        let unique_place = self.tcx().mk_place_field(self.place, Field::new(0), unique_ty);\n+        let nonnull_place = self.tcx().mk_place_field(unique_place, Field::new(0), nonnull_ty);\n+        let ptr_place = self.tcx().mk_place_field(nonnull_place, Field::new(0), ptr_ty);\n+        let interior = self.tcx().mk_place_deref(ptr_place);\n+\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.box_free_block(adt, substs, self.succ, self.unwind);"}, {"sha": "107d3ad3f15191a17899af4dce532b444c2dd7b4", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -0,0 +1,130 @@\n+//! This pass transforms derefs of Box into a deref of the pointer inside Box\n+//! Codegen does not allow box to be directly dereferenced\n+\n+use crate::MirPass;\n+use rustc_hir::def_id::DefId;\n+use rustc_index::vec::Idx;\n+use rustc_middle::mir::patch::MirPatch;\n+use rustc_middle::mir::visit::MutVisitor;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::Subst;\n+use rustc_middle::ty::TyCtxt;\n+\n+struct ElaborateBoxDerefVistor<'tcx, 'a> {\n+    tcx: TyCtxt<'tcx>,\n+    unique_did: DefId,\n+    nonnull_did: DefId,\n+    local_decls: &'a mut LocalDecls<'tcx>,\n+    patch: MirPatch<'tcx>,\n+}\n+\n+impl<'tcx, 'a> MutVisitor<'tcx> for ElaborateBoxDerefVistor<'tcx, 'a> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_place(\n+        &mut self,\n+        place: &mut Place<'tcx>,\n+        context: visit::PlaceContext,\n+        location: Location,\n+    ) {\n+        let tcx = self.tcx;\n+\n+        let base_ty = self.local_decls[place.local].ty;\n+\n+        // Derefer ensures that derefs are always the first projection\n+        if place.projection.first() == Some(&PlaceElem::Deref) && base_ty.is_box() {\n+            let source_info = self.local_decls[place.local].source_info;\n+\n+            let substs = tcx.intern_substs(&[base_ty.boxed_ty().into()]);\n+            let unique_ty = tcx.bound_type_of(self.unique_did).subst(tcx, substs);\n+            let nonnull_ty = tcx.bound_type_of(self.nonnull_did).subst(tcx, substs);\n+            let ptr_ty = tcx.mk_imm_ptr(base_ty.boxed_ty());\n+\n+            let ptr_local = self.patch.new_temp(ptr_ty, source_info.span);\n+            self.local_decls.push(LocalDecl::new(ptr_ty, source_info.span));\n+\n+            self.patch.add_statement(location, StatementKind::StorageLive(ptr_local));\n+\n+            self.patch.add_assign(\n+                location,\n+                Place::from(ptr_local),\n+                Rvalue::Use(Operand::Copy(Place::from(place.local).project_deeper(\n+                    &[\n+                        PlaceElem::Field(Field::new(0), unique_ty),\n+                        PlaceElem::Field(Field::new(0), nonnull_ty),\n+                        PlaceElem::Field(Field::new(0), ptr_ty),\n+                    ],\n+                    tcx,\n+                ))),\n+            );\n+\n+            place.local = ptr_local;\n+\n+            self.patch.add_statement(\n+                Location { block: location.block, statement_index: location.statement_index + 1 },\n+                StatementKind::StorageDead(ptr_local),\n+            );\n+        }\n+\n+        self.super_place(place, context, location);\n+    }\n+}\n+\n+pub struct ElaborateBoxDerefs;\n+\n+impl<'tcx> MirPass<'tcx> for ElaborateBoxDerefs {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        if let Some(def_id) = tcx.lang_items().owned_box() {\n+            let unique_did = tcx.adt_def(def_id).non_enum_variant().fields[0].did;\n+\n+            let Some(nonnull_def) = tcx.type_of(unique_did).ty_adt_def() else {\n+                span_bug!(tcx.def_span(unique_did), \"expected Box to contain Unique\")\n+            };\n+\n+            let nonnull_did = nonnull_def.non_enum_variant().fields[0].did;\n+\n+            let patch = MirPatch::new(body);\n+\n+            let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n+\n+            let mut visitor =\n+                ElaborateBoxDerefVistor { tcx, unique_did, nonnull_did, local_decls, patch };\n+\n+            for (block, BasicBlockData { statements, terminator, .. }) in\n+                basic_blocks.iter_enumerated_mut()\n+            {\n+                let mut index = 0;\n+                for statement in statements {\n+                    let location = Location { block, statement_index: index };\n+                    visitor.visit_statement(statement, location);\n+                    index += 1;\n+                }\n+\n+                if let Some(terminator) = terminator\n+                && !matches!(terminator.kind, TerminatorKind::Yield{..})\n+                {\n+                    let location = Location { block, statement_index: index };\n+                    visitor.visit_terminator(terminator, location);\n+                }\n+\n+                let location = Location { block, statement_index: index };\n+                match terminator {\n+                    // yielding into a box is handed when lowering generators\n+                    Some(Terminator { kind: TerminatorKind::Yield { value, .. }, .. }) => {\n+                        visitor.visit_operand(value, location);\n+                    }\n+                    Some(terminator) => {\n+                        visitor.visit_terminator(terminator, location);\n+                    }\n+                    None => {}\n+                }\n+            }\n+\n+            visitor.patch.apply(body);\n+        } else {\n+            // box is not present, this pass doesn't need to do anything\n+        }\n+    }\n+}"}, {"sha": "a5faf26916418d4c56a20482570158d66d0d0d6a", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 83, "deletions": 10, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -56,7 +56,7 @@ use crate::MirPass;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::bit_set::{BitMatrix, BitSet};\n+use rustc_index::bit_set::{BitMatrix, BitSet, GrowableBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::dump_mir;\n use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n@@ -206,7 +206,7 @@ struct SuspensionPoint<'tcx> {\n     /// Which block to jump to if the generator is dropped in this state.\n     drop: Option<BasicBlock>,\n     /// Set of locals that have live storage while at this suspension point.\n-    storage_liveness: BitSet<Local>,\n+    storage_liveness: GrowableBitSet<Local>,\n }\n \n struct TransformVisitor<'tcx> {\n@@ -362,7 +362,7 @@ impl<'tcx> MutVisitor<'tcx> for TransformVisitor<'tcx> {\n                     resume,\n                     resume_arg,\n                     drop,\n-                    storage_liveness: self.storage_liveness[block].clone().unwrap(),\n+                    storage_liveness: self.storage_liveness[block].clone().unwrap().into(),\n                 });\n \n                 VariantIdx::new(state)\n@@ -1177,6 +1177,8 @@ fn create_cases<'tcx>(\n     transform: &TransformVisitor<'tcx>,\n     operation: Operation,\n ) -> Vec<(usize, BasicBlock)> {\n+    let tcx = transform.tcx;\n+\n     let source_info = SourceInfo::outermost(body.span);\n \n     transform\n@@ -1209,13 +1211,84 @@ fn create_cases<'tcx>(\n                 if operation == Operation::Resume {\n                     // Move the resume argument to the destination place of the `Yield` terminator\n                     let resume_arg = Local::new(2); // 0 = return, 1 = self\n-                    statements.push(Statement {\n-                        source_info,\n-                        kind: StatementKind::Assign(Box::new((\n-                            point.resume_arg,\n-                            Rvalue::Use(Operand::Move(resume_arg.into())),\n-                        ))),\n-                    });\n+\n+                    // handle `box yield` properly\n+                    let box_place = if let [projection @ .., ProjectionElem::Deref] =\n+                        &**point.resume_arg.projection\n+                    {\n+                        let box_place =\n+                            Place::from(point.resume_arg.local).project_deeper(projection, tcx);\n+\n+                        let box_ty = box_place.ty(&body.local_decls, tcx).ty;\n+\n+                        if box_ty.is_box() { Some((box_place, box_ty)) } else { None }\n+                    } else {\n+                        None\n+                    };\n+\n+                    if let Some((box_place, box_ty)) = box_place {\n+                        let unique_did = box_ty\n+                            .ty_adt_def()\n+                            .expect(\"expected Box to be an Adt\")\n+                            .non_enum_variant()\n+                            .fields[0]\n+                            .did;\n+\n+                        let Some(nonnull_def) = tcx.type_of(unique_did).ty_adt_def() else {\n+                            span_bug!(tcx.def_span(unique_did), \"expected Box to contain Unique\")\n+                        };\n+\n+                        let nonnull_did = nonnull_def.non_enum_variant().fields[0].did;\n+\n+                        let substs = tcx.intern_substs(&[box_ty.boxed_ty().into()]);\n+                        let unique_ty = tcx.bound_type_of(unique_did).subst(tcx, substs);\n+                        let nonnull_ty = tcx.bound_type_of(nonnull_did).subst(tcx, substs);\n+                        let ptr_ty = tcx.mk_imm_ptr(box_ty.boxed_ty());\n+\n+                        let ptr_local = body.local_decls.push(LocalDecl::new(ptr_ty, body.span));\n+\n+                        statements.push(Statement {\n+                            source_info,\n+                            kind: StatementKind::StorageLive(ptr_local),\n+                        });\n+\n+                        statements.push(Statement {\n+                            source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                Place::from(ptr_local),\n+                                Rvalue::Use(Operand::Copy(box_place.project_deeper(\n+                                    &[\n+                                        PlaceElem::Field(Field::new(0), unique_ty),\n+                                        PlaceElem::Field(Field::new(0), nonnull_ty),\n+                                        PlaceElem::Field(Field::new(0), ptr_ty),\n+                                    ],\n+                                    tcx,\n+                                ))),\n+                            ))),\n+                        });\n+\n+                        statements.push(Statement {\n+                            source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                Place::from(ptr_local)\n+                                    .project_deeper(&[ProjectionElem::Deref], tcx),\n+                                Rvalue::Use(Operand::Move(resume_arg.into())),\n+                            ))),\n+                        });\n+\n+                        statements.push(Statement {\n+                            source_info,\n+                            kind: StatementKind::StorageDead(ptr_local),\n+                        });\n+                    } else {\n+                        statements.push(Statement {\n+                            source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                point.resume_arg,\n+                                Rvalue::Use(Operand::Move(resume_arg.into())),\n+                            ))),\n+                        });\n+                    }\n                 }\n \n                 // Then jump to the real target"}, {"sha": "b7caa61ef07a797db41e17f9924db2248198581d", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -57,6 +57,7 @@ mod deref_separator;\n mod dest_prop;\n pub mod dump_mir;\n mod early_otherwise_branch;\n+mod elaborate_box_derefs;\n mod elaborate_drops;\n mod function_item_references;\n mod generator;\n@@ -427,6 +428,7 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n         // `AddRetag` needs to run after `ElaborateDrops`. Otherwise it should run fairly late,\n         // but before optimizations begin.\n         &deref_separator::Derefer,\n+        &elaborate_box_derefs::ElaborateBoxDerefs,\n         &add_retag::AddRetag,\n         &lower_intrinsics::LowerIntrinsics,\n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),"}, {"sha": "39238dffa103111fa60c3a30725deacc8df007ca", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -23,8 +23,10 @@ use core::panic::PanicInfo;\n \n extern crate libc;\n \n+struct Unique<T>(*mut T);\n+\n #[lang = \"owned_box\"]\n-pub struct Box<T>(*mut T);\n+pub struct Box<T>(Unique<T>);\n \n #[lang = \"exchange_malloc\"]\n unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {"}, {"sha": "f448306ba1b086fd7157cff68a5e667c0694d400", "filename": "src/test/codegen/loads.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fcodegen%2Floads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fcodegen%2Floads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Floads.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -28,101 +28,101 @@ pub fn ptr_alignment_helper(x: &&()) {}\n // CHECK-LABEL: @load_ref\n #[no_mangle]\n pub fn load_ref<'a>(x: &&'a i32) -> &'a i32 {\n-// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META:[0-9]+]], !noundef !{{[0-9]+}}\n+    // CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META:[0-9]+]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_ref_higher_alignment\n #[no_mangle]\n pub fn load_ref_higher_alignment<'a>(x: &&'a Align16) -> &'a Align16 {\n-// CHECK: load {{%Align16\\*|i128\\*|ptr}}, {{%Align16\\*\\*|i128\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_16_META:[0-9]+]], !noundef !{{[0-9]+}}\n+    // CHECK: load {{%Align16\\*|i128\\*|ptr}}, {{%Align16\\*\\*|i128\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_16_META:[0-9]+]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_scalar_pair\n #[no_mangle]\n pub fn load_scalar_pair<'a>(x: &(&'a i32, &'a Align16)) -> (&'a i32, &'a Align16) {\n-// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %{{.+}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META]], !noundef !{{[0-9]+}}\n-// CHECK: load {{i64\\*|ptr}}, {{i64\\*\\*|ptr}} %{{.+}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_16_META]], !noundef !{{[0-9]+}}\n+    // CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %{{.+}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META]], !noundef !{{[0-9]+}}\n+    // CHECK: load {{i64\\*|ptr}}, {{i64\\*\\*|ptr}} %{{.+}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_16_META]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_raw_pointer\n #[no_mangle]\n pub fn load_raw_pointer<'a>(x: &*const i32) -> *const i32 {\n-// loaded raw pointer should not have !nonnull, !align, or !noundef metadata\n-// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]]{{$}}\n+    // loaded raw pointer should not have !nonnull, !align, or !noundef metadata\n+    // CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]]{{$}}\n     *x\n }\n \n // CHECK-LABEL: @load_box\n #[no_mangle]\n pub fn load_box<'a>(x: Box<Box<i32>>) -> Box<i32> {\n-// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META]], !noundef !{{[0-9]+}}\n+    // CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %{{.*}}, align [[PTR_ALIGNMENT]], !nonnull !{{[0-9]+}}, !align ![[ALIGN_4_META]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_bool\n #[no_mangle]\n pub fn load_bool(x: &bool) -> bool {\n-// CHECK: load i8, {{i8\\*|ptr}} %x, align 1, !range ![[BOOL_RANGE:[0-9]+]], !noundef !{{[0-9]+}}\n+    // CHECK: load i8, {{i8\\*|ptr}} %x, align 1, !range ![[BOOL_RANGE:[0-9]+]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_maybeuninit_bool\n #[no_mangle]\n pub fn load_maybeuninit_bool(x: &MaybeUninit<bool>) -> MaybeUninit<bool> {\n-// CHECK: load i8, {{i8\\*|ptr}} %x, align 1{{$}}\n+    // CHECK: load i8, {{i8\\*|ptr}} %x, align 1{{$}}\n     *x\n }\n \n // CHECK-LABEL: @load_enum_bool\n #[no_mangle]\n pub fn load_enum_bool(x: &MyBool) -> MyBool {\n-// CHECK: load i8, {{i8\\*|ptr}} %x, align 1, !range ![[BOOL_RANGE]], !noundef !{{[0-9]+}}\n+    // CHECK: load i8, {{i8\\*|ptr}} %x, align 1, !range ![[BOOL_RANGE]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_maybeuninit_enum_bool\n #[no_mangle]\n pub fn load_maybeuninit_enum_bool(x: &MaybeUninit<MyBool>) -> MaybeUninit<MyBool> {\n-// CHECK: load i8, {{i8\\*|ptr}} %x, align 1{{$}}\n+    // CHECK: load i8, {{i8\\*|ptr}} %x, align 1{{$}}\n     *x\n }\n \n // CHECK-LABEL: @load_int\n #[no_mangle]\n pub fn load_int(x: &u16) -> u16 {\n-// CHECK: load i16, {{i16\\*|ptr}} %x, align 2{{$}}\n+    // CHECK: load i16, {{i16\\*|ptr}} %x, align 2{{$}}\n     *x\n }\n \n // CHECK-LABEL: @load_nonzero_int\n #[no_mangle]\n pub fn load_nonzero_int(x: &NonZeroU16) -> NonZeroU16 {\n-// CHECK: load i16, {{i16\\*|ptr}} %x, align 2, !range ![[NONZEROU16_RANGE:[0-9]+]], !noundef !{{[0-9]+}}\n+    // CHECK: load i16, {{i16\\*|ptr}} %x, align 2, !range ![[NONZEROU16_RANGE:[0-9]+]], !noundef !{{[0-9]+}}\n     *x\n }\n \n // CHECK-LABEL: @load_option_nonzero_int\n #[no_mangle]\n pub fn load_option_nonzero_int(x: &Option<NonZeroU16>) -> Option<NonZeroU16> {\n-// CHECK: load i16, {{i16\\*|ptr}} %x, align 2{{$}}\n+    // CHECK: load i16, {{i16\\*|ptr}} %x, align 2{{$}}\n     *x\n }\n \n // CHECK-LABEL: @borrow\n #[no_mangle]\n pub fn borrow(x: &i32) -> &i32 {\n-// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x{{.*}}, !nonnull\n+    // CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x{{.*}}, !nonnull\n     &x; // keep variable in an alloca\n     x\n }\n \n // CHECK-LABEL: @_box\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> i32 {\n-// CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x{{.*}}, !nonnull\n+    // CHECK: load {{i32\\*|ptr}}, {{i32\\*\\*|ptr}} %x{{.*}}, align [[PTR_ALIGNMENT]]\n     *x\n }\n \n@@ -131,8 +131,8 @@ pub fn _box(x: Box<i32>) -> i32 {\n // dependent alignment\n #[no_mangle]\n pub fn small_array_alignment(x: [i8; 4]) -> [i8; 4] {\n-// CHECK: [[VAR:%[0-9]+]] = load i32, {{i32\\*|ptr}} %{{.*}}, align 1\n-// CHECK: ret i32 [[VAR]]\n+    // CHECK: [[VAR:%[0-9]+]] = load i32, {{i32\\*|ptr}} %{{.*}}, align 1\n+    // CHECK: ret i32 [[VAR]]\n     x\n }\n \n@@ -141,8 +141,8 @@ pub fn small_array_alignment(x: [i8; 4]) -> [i8; 4] {\n // dependent alignment\n #[no_mangle]\n pub fn small_struct_alignment(x: Bytes) -> Bytes {\n-// CHECK: [[VAR:%[0-9]+]] = load i32, {{i32\\*|ptr}} %{{.*}}, align 1\n-// CHECK: ret i32 [[VAR]]\n+    // CHECK: [[VAR:%[0-9]+]] = load i32, {{i32\\*|ptr}} %{{.*}}, align 1\n+    // CHECK: ret i32 [[VAR]]\n     x\n }\n "}, {"sha": "87302424914d9f354ae9e192e95dfe07b96ce8d1", "filename": "src/test/mir-opt/const_prop/boxes.main.ConstProp.diff", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboxes.main.ConstProp.diff?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -10,6 +10,10 @@\n       let mut _5: usize;                   // in scope 0 at $DIR/boxes.rs:12:14: 12:22\n       let mut _6: *mut u8;                 // in scope 0 at $DIR/boxes.rs:12:14: 12:22\n       let mut _7: std::boxed::Box<i32>;    // in scope 0 at $DIR/boxes.rs:12:14: 12:22\n+      let mut _8: *const i32;              // in scope 0 at $DIR/boxes.rs:12:14: 12:22\n+      let mut _9: *const i32;              // in scope 0 at $DIR/boxes.rs:12:14: 12:22\n+      let mut _10: *const i32;             // in scope 0 at $DIR/boxes.rs:12:14: 12:22\n+      let mut _11: *const i32;             // in scope 0 at $DIR/boxes.rs:12:14: 12:22\n       scope 1 {\n           debug x => _1;                   // in scope 1 at $DIR/boxes.rs:12:9: 12:10\n       }\n@@ -34,10 +38,16 @@\n       bb1: {\n           StorageLive(_7);                 // scope 0 at $DIR/boxes.rs:12:14: 12:22\n           _7 = ShallowInitBox(move _6, i32); // scope 0 at $DIR/boxes.rs:12:14: 12:22\n-          (*_7) = const 42_i32;            // scope 0 at $DIR/boxes.rs:12:19: 12:21\n+          StorageLive(_8);                 // scope 0 at $DIR/boxes.rs:12:19: 12:21\n+          _8 = (((_7.0: std::ptr::Unique<i32>).0: std::ptr::NonNull<i32>).0: *const i32); // scope 0 at $DIR/boxes.rs:12:19: 12:21\n+          (*_8) = const 42_i32;            // scope 0 at $DIR/boxes.rs:12:19: 12:21\n+          StorageDead(_8);                 // scope 0 at $DIR/boxes.rs:12:14: 12:22\n           _3 = move _7;                    // scope 0 at $DIR/boxes.rs:12:14: 12:22\n           StorageDead(_7);                 // scope 0 at $DIR/boxes.rs:12:21: 12:22\n-          _2 = (*_3);                      // scope 0 at $DIR/boxes.rs:12:13: 12:22\n+          StorageLive(_9);                 // scope 0 at $DIR/boxes.rs:12:13: 12:22\n+          _9 = (((_3.0: std::ptr::Unique<i32>).0: std::ptr::NonNull<i32>).0: *const i32); // scope 0 at $DIR/boxes.rs:12:13: 12:22\n+          _2 = (*_9);                      // scope 0 at $DIR/boxes.rs:12:13: 12:22\n+          StorageDead(_9);                 // scope 0 at $DIR/boxes.rs:12:13: 12:26\n           _1 = Add(move _2, const 0_i32);  // scope 0 at $DIR/boxes.rs:12:13: 12:26\n           StorageDead(_2);                 // scope 0 at $DIR/boxes.rs:12:25: 12:26\n           drop(_3) -> [return: bb2, unwind: bb3]; // scope 0 at $DIR/boxes.rs:12:26: 12:27"}, {"sha": "92bf6471179901f57a174cd2e452d3f124c71eca", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.32bit.diff", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -9,7 +9,8 @@\n       let mut _4: *mut u8;                 // in scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n       let mut _5: std::boxed::Box<std::vec::Vec<u32>>; // in scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n       let mut _6: ();                      // in scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n-+     let mut _7: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n+      let mut _7: *const std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n++     let mut _8: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/inline-into-box-place.rs:8:9: 8:11\n       }\n@@ -32,7 +33,7 @@\n       bb1: {\n           StorageLive(_5);                 // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           _5 = ShallowInitBox(move _4, std::vec::Vec<u32>); // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n--         (*_5) = Vec::<u32>::new() -> [return: bb2, unwind: bb5]; // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n+-         (*((_5.0: std::ptr::Unique<std::vec::Vec<u32>>).0: *const std::vec::Vec<u32>)) = Vec::<u32>::new() -> [return: bb2, unwind: bb5]; // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         StorageLive(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         _7 = &mut (*_5);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n +         StorageLive(_8);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n@@ -71,6 +72,7 @@\n -     }\n - \n -     bb5 (cleanup): {\n+-         StorageDead(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n -         _6 = alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>(move (_5.0: std::ptr::Unique<std::vec::Vec<u32>>), move (_5.1: std::alloc::Global)) -> bb4; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n -                                          // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:42: 8:43"}, {"sha": "89414574898a69420aeaddc54f563846df028326", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.64bit.diff", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -9,14 +9,16 @@\n       let mut _4: *mut u8;                 // in scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n       let mut _5: std::boxed::Box<std::vec::Vec<u32>>; // in scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n       let mut _6: ();                      // in scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n-+     let mut _7: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n+      let mut _7: *const std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n+      let mut _8: *const std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n++     let mut _9: &mut std::vec::Vec<u32>; // in scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/inline-into-box-place.rs:8:9: 8:11\n       }\n       scope 2 {\n       }\n +     scope 3 (inlined Vec::<u32>::new) {  // at $DIR/inline-into-box-place.rs:8:33: 8:43\n-+         let mut _8: alloc::raw_vec::RawVec<u32>; // in scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         let mut _10: alloc::raw_vec::RawVec<u32>; // in scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +     }\n   \n       bb0: {\n@@ -32,11 +34,13 @@\n       bb1: {\n           StorageLive(_5);                 // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           _5 = ShallowInitBox(move _4, std::vec::Vec<u32>); // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n--         (*_5) = Vec::<u32>::new() -> [return: bb2, unwind: bb5]; // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n-+         StorageLive(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n-+         _7 = &mut (*_5);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n-+         StorageLive(_8);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         _8 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n+          StorageLive(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n+          _7 = (((_5.0: std::ptr::Unique<std::vec::Vec<u32>>).0: std::ptr::NonNull<std::vec::Vec<u32>>).0: *const std::vec::Vec<u32>); // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n+-         (*_7) = Vec::<u32>::new() -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageLive(_9);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         _9 = &mut (*_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         StorageLive(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         _10 = const alloc::raw_vec::RawVec::<u32>::NEW; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:33: 8:41\n -                                          // + user_ty: UserType(1)\n@@ -47,15 +51,16 @@\n +                                          // + span: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Unevaluated(alloc::raw_vec::RawVec::<T>::NEW, [u32], None) }\n-+         Deinit((*_7));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         ((*_7).0: alloc::raw_vec::RawVec<u32>) = move _8; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         ((*_7).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         StorageDead(_8);                 // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         StorageDead(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n++         Deinit((*_9));                   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         ((*_9).0: alloc::raw_vec::RawVec<u32>) = move _10; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         ((*_9).1: usize) = const 0_usize; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageDead(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         StorageDead(_9);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n+          StorageDead(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n           _1 = move _5;                    // scope 0 at $DIR/inline-into-box-place.rs:8:29: 8:43\n           StorageDead(_5);                 // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n           _0 = const ();                   // scope 0 at $DIR/inline-into-box-place.rs:7:11: 9:2\n--         drop(_1) -> [return: bb3, unwind: bb4]; // scope 0 at $DIR/inline-into-box-place.rs:9:1: 9:2\n+-         drop(_1) -> [return: bb3, unwind: bb5]; // scope 0 at $DIR/inline-into-box-place.rs:9:1: 9:2\n +         drop(_1) -> [return: bb2, unwind: bb3]; // scope 0 at $DIR/inline-into-box-place.rs:9:1: 9:2\n       }\n   \n@@ -66,15 +71,16 @@\n       }\n   \n -     bb4 (cleanup): {\n-+     bb3 (cleanup): {\n-          resume;                          // scope 0 at $DIR/inline-into-box-place.rs:7:1: 9:2\n--     }\n-- \n--     bb5 (cleanup): {\n--         _6 = alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>(move (_5.0: std::ptr::Unique<std::vec::Vec<u32>>), move (_5.1: std::alloc::Global)) -> bb4; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n+-         StorageDead(_7);                 // scope 0 at $DIR/inline-into-box-place.rs:8:33: 8:43\n+-         _6 = alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>(move (_5.0: std::ptr::Unique<std::vec::Vec<u32>>), move (_5.1: std::alloc::Global)) -> bb5; // scope 0 at $DIR/inline-into-box-place.rs:8:42: 8:43\n -                                          // mir::Constant\n -                                          // + span: $DIR/inline-into-box-place.rs:8:42: 8:43\n -                                          // + literal: Const { ty: unsafe fn(Unique<Vec<u32>>, std::alloc::Global) {alloc::alloc::box_free::<Vec<u32>, std::alloc::Global>}, val: Value(Scalar(<ZST>)) }\n+-     }\n+- \n+-     bb5 (cleanup): {\n++     bb3 (cleanup): {\n+          resume;                          // scope 0 at $DIR/inline-into-box-place.rs:7:1: 9:2\n       }\n   }\n   "}, {"sha": "11a205eb41580f086f006a617cba09a72e88b0fe", "filename": "src/test/mir-opt/inline/issue_58867_inline_as_ref_as_mut.b.Inline.after.mir", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.b.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.b.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.b.Inline.after.mir?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -11,6 +11,7 @@ fn b(_1: &mut Box<T>) -> &mut T {\n         let mut _5: &mut T;              // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         let mut _6: &mut T;              // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         let mut _7: std::boxed::Box<T>;  // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        let mut _8: *const T;            // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n     }\n \n     bb0: {\n@@ -22,7 +23,10 @@ fn b(_1: &mut Box<T>) -> &mut T {\n         StorageLive(_6);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         StorageLive(_7);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         _7 = move (*_4);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-        _6 = &mut (*_7);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        StorageLive(_8);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        _8 = (((_7.0: std::ptr::Unique<T>).0: std::ptr::NonNull<T>).0: *const T); // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        _6 = &mut (*_8);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        StorageDead(_8);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         StorageDead(_7);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         _5 = &mut (*_6);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         _3 = &mut (*_5);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL"}, {"sha": "b04a91d7c9590a7b936945d3445065374575552f", "filename": "src/test/mir-opt/inline/issue_58867_inline_as_ref_as_mut.d.Inline.after.mir", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.d.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.d.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.d.Inline.after.mir?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -8,6 +8,7 @@ fn d(_1: &Box<T>) -> &T {\n     scope 1 (inlined <Box<T> as AsRef<T>>::as_ref) { // at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n         debug self => _3;                // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         let mut _4: std::boxed::Box<T>;  // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        let mut _5: *const T;            // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n     }\n \n     bb0: {\n@@ -16,7 +17,10 @@ fn d(_1: &Box<T>) -> &T {\n         _3 = &(*_1);                     // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n         StorageLive(_4);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         _4 = move (*_3);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-        _2 = &(*_4);                     // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        StorageLive(_5);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        _5 = (((_4.0: std::ptr::Unique<T>).0: std::ptr::NonNull<T>).0: *const T); // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        _2 = &(*_5);                     // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        StorageDead(_5);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         StorageDead(_4);                 // scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n         _0 = &(*_2);                     // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n         StorageDead(_3);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:14: 18:15"}, {"sha": "8e9c14a03c386623fed51bea2843c68ff16ca8d1", "filename": "src/test/ui/mir/ssa-analysis-regression-50041.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb417881a9341e3258a3b1fa4a14c0717e226d61/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs?ref=cb417881a9341e3258a3b1fa4a14c0717e226d61", "patch": "@@ -1,27 +1,29 @@\n // build-pass\n // compile-flags: -Z mir-opt-level=4\n \n-#![crate_type=\"lib\"]\n+#![crate_type = \"lib\"]\n #![feature(lang_items)]\n #![no_std]\n \n+struct NonNull<T: ?Sized>(*mut T);\n+\n+struct Unique<T: ?Sized>(NonNull<T>);\n+\n #[lang = \"owned_box\"]\n-pub struct Box<T: ?Sized>(*mut T, ());\n+pub struct Box<T: ?Sized>(Unique<T>);\n \n impl<T: ?Sized> Drop for Box<T> {\n-    fn drop(&mut self) {\n-    }\n+    fn drop(&mut self) {}\n }\n \n #[lang = \"box_free\"]\n #[inline(always)]\n-unsafe fn box_free<T: ?Sized>(ptr: *mut T, _: ()) {\n-    dealloc(ptr)\n+unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n+    dealloc(ptr.0.0)\n }\n \n #[inline(never)]\n-fn dealloc<T: ?Sized>(_: *mut T) {\n-}\n+fn dealloc<T: ?Sized>(_: *mut T) {}\n \n pub struct Foo<T>(T);\n "}]}