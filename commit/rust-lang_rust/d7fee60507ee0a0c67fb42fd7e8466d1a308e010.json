{"sha": "d7fee60507ee0a0c67fb42fd7e8466d1a308e010", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZmVlNjA1MDdlZTBhMGM2N2ZiNDJmZDdlODQ2NmQxYTMwOGUwMTA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-14T09:10:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-14T09:10:46Z"}, "message": "Merge #5363\n\n5363: Reduce visibility r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "73803d742edeb6a0f31d09817ffb6e89852bb2f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73803d742edeb6a0f31d09817ffb6e89852bb2f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7fee60507ee0a0c67fb42fd7e8466d1a308e010", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfDXaWCRBK7hj4Ov3rIwAAdHIIAIG7BS/IZQtKmDMOI0yYU3LK\nDnJlYT5m0i9j/pw3yAoVZufR3xAx2VqQipiZCh00oi2fHN+DHMouIklsjCCNPLkG\nXxRNp676z1LbIS6LMMCgtD1E06muv4LJTMlA2w55zIJxWUR0yACxSHjvCy//CUMD\n17USv6mhZ5rRc1TV+eRw4RuKdp8cg32rtaAnjdbqtlAgXbSFV4T+4r7nCIHSS1v2\nTkbTyyufysAiWXIFhq4OLMNCrmnf19V4I3V5YZKJIg2DBFuDyy4nSqDyvyUc+A4B\n4JgCW3nd22o/gCb9jIccuvjdLEOWQsKwyKF4CUSTIKOXQ3whTAdexNxHcuZHdiA=\n=VC2c\n-----END PGP SIGNATURE-----\n", "payload": "tree 73803d742edeb6a0f31d09817ffb6e89852bb2f5\nparent 45ec95caf616e721ca9f876740e65b9591aa5faf\nparent 7b2ce1a54f75ba5d933521ba8780aaf1ffeef407\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594717846 +0000\ncommitter GitHub <noreply@github.com> 1594717846 +0000\n\nMerge #5363\n\n5363: Reduce visibility r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7fee60507ee0a0c67fb42fd7e8466d1a308e010", "html_url": "https://github.com/rust-lang/rust/commit/d7fee60507ee0a0c67fb42fd7e8466d1a308e010", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7fee60507ee0a0c67fb42fd7e8466d1a308e010/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45ec95caf616e721ca9f876740e65b9591aa5faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/45ec95caf616e721ca9f876740e65b9591aa5faf", "html_url": "https://github.com/rust-lang/rust/commit/45ec95caf616e721ca9f876740e65b9591aa5faf"}, {"sha": "7b2ce1a54f75ba5d933521ba8780aaf1ffeef407", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b2ce1a54f75ba5d933521ba8780aaf1ffeef407", "html_url": "https://github.com/rust-lang/rust/commit/7b2ce1a54f75ba5d933521ba8780aaf1ffeef407"}], "stats": {"total": 168, "additions": 83, "deletions": 85}, "files": [{"sha": "899025a87978eef65f37f117ccaf4ad82d76ac95", "filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 83, "deletions": 85, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d7fee60507ee0a0c67fb42fd7e8466d1a308e010/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fee60507ee0a0c67fb42fd7e8466d1a308e010/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=d7fee60507ee0a0c67fb42fd7e8466d1a308e010", "patch": "@@ -272,7 +272,7 @@ impl From<&PatId> for PatIdOrWild {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n-pub enum MatchCheckErr {\n+pub(super) enum MatchCheckErr {\n     NotImplemented,\n     MalformedMatchArm,\n     /// Used when type inference cannot resolve the type of\n@@ -287,21 +287,21 @@ pub enum MatchCheckErr {\n ///\n /// The `std::result::Result` type is used here rather than a custom enum\n /// to allow the use of `?`.\n-pub type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n+pub(super) type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n \n #[derive(Debug)]\n /// A row in a Matrix.\n ///\n /// This type is modeled from the struct of the same name in `rustc`.\n-pub(crate) struct PatStack(PatStackInner);\n+pub(super) struct PatStack(PatStackInner);\n type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n \n impl PatStack {\n-    pub(crate) fn from_pattern(pat_id: PatId) -> PatStack {\n+    pub(super) fn from_pattern(pat_id: PatId) -> PatStack {\n         Self(smallvec!(pat_id.into()))\n     }\n \n-    pub(crate) fn from_wild() -> PatStack {\n+    pub(super) fn from_wild() -> PatStack {\n         Self(smallvec!(PatIdOrWild::Wild))\n     }\n \n@@ -510,14 +510,14 @@ impl PatStack {\n /// A collection of PatStack.\n ///\n /// This type is modeled from the struct of the same name in `rustc`.\n-pub(crate) struct Matrix(Vec<PatStack>);\n+pub(super) struct Matrix(Vec<PatStack>);\n \n impl Matrix {\n-    pub(crate) fn empty() -> Self {\n+    pub(super) fn empty() -> Self {\n         Self(vec![])\n     }\n \n-    pub(crate) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n+    pub(super) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n         if let Some(Pat::Or(pat_ids)) = row.get_head().map(|pat_id| pat_id.as_pat(cx)) {\n             // Or patterns are expanded here\n             for pat_id in pat_ids {\n@@ -579,16 +579,16 @@ impl Matrix {\n /// not matched by an prior match arms.\n ///\n /// We may eventually need an `Unknown` variant here.\n-pub enum Usefulness {\n+pub(super) enum Usefulness {\n     Useful,\n     NotUseful,\n }\n \n-pub struct MatchCheckCtx<'a> {\n-    pub match_expr: Idx<Expr>,\n-    pub body: Arc<Body>,\n-    pub infer: Arc<InferenceResult>,\n-    pub db: &'a dyn HirDatabase,\n+pub(super) struct MatchCheckCtx<'a> {\n+    pub(super) match_expr: Idx<Expr>,\n+    pub(super) body: Arc<Body>,\n+    pub(super) infer: Arc<InferenceResult>,\n+    pub(super) db: &'a dyn HirDatabase,\n }\n \n /// Given a set of patterns `matrix`, and pattern to consider `v`, determines\n@@ -599,7 +599,7 @@ pub struct MatchCheckCtx<'a> {\n /// expected that you have already type checked the match arms. All patterns in\n /// matrix should be the same type as v, as well as they should all be the same\n /// type as the match expression.\n-pub(crate) fn is_useful(\n+pub(super) fn is_useful(\n     cx: &MatchCheckCtx,\n     matrix: &Matrix,\n     v: &PatStack,\n@@ -837,23 +837,23 @@ fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: Enum\n \n #[cfg(test)]\n mod tests {\n-    pub(super) use insta::assert_snapshot;\n-    pub(super) use ra_db::fixture::WithFixture;\n+    use insta::assert_snapshot;\n+    use ra_db::fixture::WithFixture;\n \n-    pub(super) use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n+    use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n \n-    pub(super) fn check_diagnostic_message(ra_fixture: &str) -> String {\n+    fn check_diagnostic_message(ra_fixture: &str) -> String {\n         TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().0\n     }\n \n-    pub(super) fn check_diagnostic(ra_fixture: &str) {\n+    fn check_diagnostic(ra_fixture: &str) {\n         let diagnostic_count =\n             TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n \n         assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n     }\n \n-    pub(super) fn check_no_diagnostic(ra_fixture: &str) {\n+    fn check_no_diagnostic(ra_fixture: &str) {\n         let (s, diagnostic_count) =\n             TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>();\n \n@@ -2036,44 +2036,41 @@ mod tests {\n         \",\n         );\n     }\n-}\n \n-#[cfg(test)]\n-mod false_negatives {\n-    //! The implementation of match checking here is a work in progress. As we roll this out, we\n-    //! prefer false negatives to false positives (ideally there would be no false positives). This\n-    //! test module should document known false negatives. Eventually we will have a complete\n-    //! implementation of match checking and this module will be empty.\n-    //!\n-    //! The reasons for documenting known false negatives:\n-    //!\n-    //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n-    //!   2. It ensures the code doesn't panic when handling these cases.\n-\n-    use super::tests::*;\n-\n-    #[test]\n-    fn integers() {\n-        // This is a false negative.\n-        // We don't currently check integer exhaustiveness.\n-        check_no_diagnostic(\n-            r\"\n+    mod false_negatives {\n+        //! The implementation of match checking here is a work in progress. As we roll this out, we\n+        //! prefer false negatives to false positives (ideally there would be no false positives). This\n+        //! test module should document known false negatives. Eventually we will have a complete\n+        //! implementation of match checking and this module will be empty.\n+        //!\n+        //! The reasons for documenting known false negatives:\n+        //!\n+        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+        //!   2. It ensures the code doesn't panic when handling these cases.\n+        use super::*;\n+\n+        #[test]\n+        fn integers() {\n+            // This is a false negative.\n+            // We don't currently check integer exhaustiveness.\n+            check_no_diagnostic(\n+                r\"\n             fn test_fn() {\n                 match 5 {\n                     10 => (),\n                     11..20 => (),\n                 }\n             }\n         \",\n-        );\n-    }\n+            );\n+        }\n \n-    #[test]\n-    fn internal_or() {\n-        // This is a false negative.\n-        // We do not currently handle patterns with internal `or`s.\n-        check_no_diagnostic(\n-            r\"\n+        #[test]\n+        fn internal_or() {\n+            // This is a false negative.\n+            // We do not currently handle patterns with internal `or`s.\n+            check_no_diagnostic(\n+                r\"\n             fn test_fn() {\n                 enum Either {\n                     A(bool),\n@@ -2084,17 +2081,17 @@ mod false_negatives {\n                 }\n             }\n         \",\n-        );\n-    }\n+            );\n+        }\n \n-    #[test]\n-    fn expr_loop_missing_arm() {\n-        // This is a false negative.\n-        // We currently infer the type of `loop { break Foo::A }` to `!`, which\n-        // causes us to skip the diagnostic since `Either::A` doesn't type check\n-        // with `!`.\n-        check_diagnostic(\n-            r\"\n+        #[test]\n+        fn expr_loop_missing_arm() {\n+            // This is a false negative.\n+            // We currently infer the type of `loop { break Foo::A }` to `!`, which\n+            // causes us to skip the diagnostic since `Either::A` doesn't type check\n+            // with `!`.\n+            check_diagnostic(\n+                r\"\n             enum Either {\n                 A,\n                 B,\n@@ -2105,45 +2102,45 @@ mod false_negatives {\n                 }\n             }\n         \",\n-        );\n-    }\n+            );\n+        }\n \n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        // This is a false negative.\n-        // We don't currently handle tuple patterns with ellipsis.\n-        check_no_diagnostic(\n-            r\"\n+        #[test]\n+        fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n+            // This is a false negative.\n+            // We don't currently handle tuple patterns with ellipsis.\n+            check_no_diagnostic(\n+                r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (false, ..) => {},\n                 }\n             }\n         \",\n-        );\n-    }\n+            );\n+        }\n \n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        // This is a false negative.\n-        // We don't currently handle tuple patterns with ellipsis.\n-        check_no_diagnostic(\n-            r\"\n+        #[test]\n+        fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n+            // This is a false negative.\n+            // We don't currently handle tuple patterns with ellipsis.\n+            check_no_diagnostic(\n+                r\"\n             fn test_fn() {\n                 match (false, true, false) {\n                     (.., false) => {},\n                 }\n             }\n         \",\n-        );\n-    }\n+            );\n+        }\n \n-    #[test]\n-    fn struct_missing_arm() {\n-        // This is a false negative.\n-        // We don't currently handle structs.\n-        check_no_diagnostic(\n-            r\"\n+        #[test]\n+        fn struct_missing_arm() {\n+            // This is a false negative.\n+            // We don't currently handle structs.\n+            check_no_diagnostic(\n+                r\"\n             struct Foo {\n                 a: bool,\n             }\n@@ -2153,6 +2150,7 @@ mod false_negatives {\n                 }\n             }\n         \",\n-        );\n+            );\n+        }\n     }\n }"}]}