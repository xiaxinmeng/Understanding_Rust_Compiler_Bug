{"sha": "b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MWMwMmU1MTJmY2ZlMThlYTdhNWE4YTk5YWM3NThiNGZhNTY0YTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-01T18:11:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-01T18:11:51Z"}, "message": "auto merge of #13115 : huonw/rust/rand-errors, r=alexcrichton\n\nmove errno -> IoError converter into std, bubble up OSRng errors\r\n\r\nAlso adds a general errno -> `~str` converter to `std::os`, and makes the failure messages for the things using `OSRng` (e.g. (transitively) the task-local RNG, meaning hashmap initialisation failures aren't such a black box).", "tree": {"sha": "7842aad2f7ad07256764e22d6ab2fad0b6f624ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7842aad2f7ad07256764e22d6ab2fad0b6f624ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "html_url": "https://github.com/rust-lang/rust/commit/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64", "html_url": "https://github.com/rust-lang/rust/commit/b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64"}, {"sha": "bc7a2d72a3fea324fa432de9b6ce6073302d3d8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7a2d72a3fea324fa432de9b6ce6073302d3d8c", "html_url": "https://github.com/rust-lang/rust/commit/bc7a2d72a3fea324fa432de9b6ce6073302d3d8c"}], "stats": {"total": 374, "additions": 216, "deletions": 158}, "files": [{"sha": "6c1391e7ca816b6c1eb9c78596f967695473b08b", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -52,7 +52,7 @@ pub mod bench {\n                                                   map: &mut M,\n                                                   bh: &mut BenchHarness) {\n         // setup\n-        let mut rng = rand::XorShiftRng::new();\n+        let mut rng = rand::weak_rng();\n \n         map.clear();\n         for _ in range(0, n) {\n@@ -89,7 +89,7 @@ pub mod bench {\n                                                 map: &mut M,\n                                                 bh: &mut BenchHarness) {\n         // setup\n-        let mut rng = rand::XorShiftRng::new();\n+        let mut rng = rand::weak_rng();\n         let mut keys = slice::from_fn(n, |_| rng.gen::<uint>() % n);\n \n         for k in keys.iter() {"}, {"sha": "683df846d62c2b9ccee2098bbbf8472d567d3c86", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -967,7 +967,12 @@ impl ClosureConverter for UnsafeTaskReceiver {\n // worry there.\n #[cfg(windows)]\n fn new_sched_rng() -> XorShiftRng {\n-    XorShiftRng::new()\n+    match XorShiftRng::new() {\n+        Ok(r) => r,\n+        Err(e) => {\n+            rtabort!(\"sched: failed to create seeded RNG: {}\", e)\n+        }\n+    }\n }\n #[cfg(unix)]\n fn new_sched_rng() -> XorShiftRng {"}, {"sha": "bca564870e2f63fd784b41a0733b4bc13acfa839", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -96,10 +96,8 @@ extern \"system\" {\n \n #[cfg(windows)]\n fn get_error(_: c_int) -> IoError {\n-    use super::translate_error;\n-\n     unsafe {\n-        translate_error(WSAGetLastError() as i32, true)\n+        IoError::from_errno(WSAGetLastError() as uint, true)\n     }\n }\n "}, {"sha": "34843102456bfccfb47121701b3cae7e2e27aae1", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 2, "deletions": 65, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -86,73 +86,10 @@ fn unimpl() -> IoError {\n     }\n }\n \n-fn translate_error(errno: i32, detail: bool) -> IoError {\n-    #[cfg(windows)]\n-    fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n-        match errno {\n-            libc::EOF => (io::EndOfFile, \"end of file\"),\n-            libc::ERROR_NO_DATA => (io::BrokenPipe, \"the pipe is being closed\"),\n-            libc::ERROR_FILE_NOT_FOUND => (io::FileNotFound, \"file not found\"),\n-            libc::ERROR_INVALID_NAME => (io::InvalidInput, \"invalid file name\"),\n-            libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n-            libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n-            libc::WSAEACCES => (io::PermissionDenied, \"permission denied\"),\n-            libc::WSAEWOULDBLOCK => {\n-                (io::ResourceUnavailable, \"resource temporarily unavailable\")\n-            }\n-            libc::WSAENOTCONN => (io::NotConnected, \"not connected\"),\n-            libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n-            libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n-            libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-            libc::ERROR_BROKEN_PIPE => (io::EndOfFile, \"the pipe has ended\"),\n-\n-            // libuv maps this error code to EISDIR. we do too. if it is found\n-            // to be incorrect, we can add in some more machinery to only\n-            // return this message when ERROR_INVALID_FUNCTION after certain\n-            // win32 calls.\n-            libc::ERROR_INVALID_FUNCTION => (io::InvalidInput,\n-                                             \"illegal operation on a directory\"),\n-\n-            _ => (io::OtherIoError, \"unknown error\")\n-        }\n-    }\n-\n-    #[cfg(not(windows))]\n-    fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n-        // FIXME: this should probably be a bit more descriptive...\n-        match errno {\n-            libc::EOF => (io::EndOfFile, \"end of file\"),\n-            libc::ECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n-            libc::ECONNRESET => (io::ConnectionReset, \"connection reset\"),\n-            libc::EPERM | libc::EACCES =>\n-                (io::PermissionDenied, \"permission denied\"),\n-            libc::EPIPE => (io::BrokenPipe, \"broken pipe\"),\n-            libc::ENOTCONN => (io::NotConnected, \"not connected\"),\n-            libc::ECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n-            libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n-            libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-            libc::ENOENT => (io::FileNotFound, \"no such file or directory\"),\n-            libc::EISDIR => (io::InvalidInput, \"illegal operation on a directory\"),\n-\n-            // These two constants can have the same value on some systems, but\n-            // different values on others, so we can't use a match clause\n-            x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-                (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n-\n-            _ => (io::OtherIoError, \"unknown error\")\n-        }\n-    }\n-\n-    let (kind, desc) = get_err(errno);\n-    IoError {\n-        kind: kind,\n-        desc: desc,\n-        detail: if detail {Some(os::last_os_error())} else {None},\n-    }\n+fn last_error() -> IoError {\n+    IoError::last_error()\n }\n \n-fn last_error() -> IoError { translate_error(os::errno() as i32, true) }\n-\n // unix has nonzero values as errors\n fn mkerr_libc(ret: libc::c_int) -> IoResult<()> {\n     if ret != 0 {"}, {"sha": "6ddd69eb019995bfbbef94628a4122214803ace5", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -120,7 +120,7 @@ fn last_error() -> io::IoError {\n     extern \"system\" {\n         fn WSAGetLastError() -> libc::c_int;\n     }\n-    super::translate_error(unsafe { WSAGetLastError() }, true)\n+    io::IoError::from_errno(unsafe { WSAGetLastError() } as uint, true)\n }\n \n #[cfg(not(windows))]"}, {"sha": "d2e2db63c1bff7c1276040861091701290295697", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -481,7 +481,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n                                     (bytes[1] << 16) as i32 |\n                                     (bytes[2] <<  8) as i32 |\n                                     (bytes[3] <<  0) as i32;\n-                        Err(super::translate_error(errno, false))\n+                        Err(io::IoError::from_errno(errno as uint, false))\n                     }\n                     Err(e) => {\n                         assert!(e.kind == io::BrokenPipe ||"}, {"sha": "5cd53ca88a9d9ddefc59f4ed2bf906fb69e5c7cc", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -126,7 +126,7 @@ mod bench {\n \n     #[bench]\n     fn rand_exp(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n+        let mut rng = XorShiftRng::new().unwrap();\n         let mut exp = Exp::new(2.71828 * 3.14159);\n \n         bh.iter(|| {"}, {"sha": "a1557b842129ac63e4708dc98ad17a2b75e761ce", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -370,14 +370,14 @@ mod bench {\n     use self::test::BenchHarness;\n     use std::mem::size_of;\n     use distributions::IndependentSample;\n-    use {StdRng, RAND_BENCH_N};\n+    use {XorShiftRng, RAND_BENCH_N};\n     use super::Gamma;\n \n \n     #[bench]\n     fn bench_gamma_large_shape(bh: &mut BenchHarness) {\n         let gamma = Gamma::new(10., 1.0);\n-        let mut rng = StdRng::new();\n+        let mut rng = XorShiftRng::new().unwrap();\n \n         bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n@@ -390,7 +390,7 @@ mod bench {\n     #[bench]\n     fn bench_gamma_small_shape(bh: &mut BenchHarness) {\n         let gamma = Gamma::new(0.1, 1.0);\n-        let mut rng = StdRng::new();\n+        let mut rng = XorShiftRng::new().unwrap();\n \n         bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {"}, {"sha": "7340d00929e3e7e722cd2fa52e6ca70cd40c4e37", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -193,7 +193,7 @@ mod bench {\n \n     #[bench]\n     fn rand_normal(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n+        let mut rng = XorShiftRng::new().unwrap();\n         let mut normal = Normal::new(-2.71828, 3.14159);\n \n         bh.iter(|| {"}, {"sha": "de3d471c7bd0d412f44973fa4e6975ab951f5ddb", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -11,6 +11,7 @@\n //! The ISAAC random number generator.\n \n use {Rng, SeedableRng, OSRng};\n+use std::io::IoResult;\n use std::iter::{range_step, Repeat};\n use std::slice::raw;\n use std::mem;\n@@ -44,19 +45,23 @@ static EMPTY: IsaacRng = IsaacRng {\n \n impl IsaacRng {\n     /// Create an ISAAC random number generator with a random seed.\n-    pub fn new() -> IsaacRng {\n+    ///\n+    /// This reads randomness from the operating system (via `OSRng`)\n+    /// which may fail, any error is propagated via the `IoResult`\n+    /// return value.\n+    pub fn new() -> IoResult<IsaacRng> {\n         let mut rng = EMPTY;\n-\n+        let mut os_rng = try!(OSRng::new());\n         unsafe {\n             let ptr = rng.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n-                OSRng::new().fill_bytes(slice);\n+                os_rng.fill_bytes(slice);\n             })\n         }\n \n         rng.init(true);\n-        rng\n+        Ok(rng)\n     }\n \n     /// Create an ISAAC random number generator using the default\n@@ -249,19 +254,24 @@ static EMPTY_64: Isaac64Rng = Isaac64Rng {\n impl Isaac64Rng {\n     /// Create a 64-bit ISAAC random number generator with a random\n     /// seed.\n-    pub fn new() -> Isaac64Rng {\n+    ///\n+    /// This reads randomness from the operating system (via `OSRng`)\n+    /// which may fail, any error is propagated via the `IoResult`\n+    /// return value.\n+    pub fn new() -> IoResult<Isaac64Rng> {\n         let mut rng = EMPTY_64;\n+        let mut os_rng = try!(OSRng::new());\n \n         unsafe {\n             let ptr = rng.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n-                OSRng::new().fill_bytes(slice);\n+                os_rng.fill_bytes(slice);\n             })\n         }\n \n         rng.init(true);\n-        rng\n+        Ok(rng)\n     }\n \n     /// Create a 64-bit ISAAC random number generator using the\n@@ -430,19 +440,19 @@ impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n #[cfg(test)]\n mod test {\n     use super::{IsaacRng, Isaac64Rng};\n-    use {Rng, SeedableRng, OSRng};\n+    use {Rng, SeedableRng, task_rng};\n     use std::slice;\n \n     #[test]\n     fn test_rng_32_rand_seeded() {\n-        let s = OSRng::new().gen_vec::<u32>(256);\n+        let s = task_rng().gen_vec::<u32>(256);\n         let mut ra: IsaacRng = SeedableRng::from_seed(s.as_slice());\n         let mut rb: IsaacRng = SeedableRng::from_seed(s.as_slice());\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n     #[test]\n     fn test_rng_64_rand_seeded() {\n-        let s = OSRng::new().gen_vec::<u64>(256);\n+        let s = task_rng().gen_vec::<u64>(256);\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n@@ -465,7 +475,7 @@ mod test {\n \n     #[test]\n     fn test_rng_32_reseed() {\n-        let s = OSRng::new().gen_vec::<u32>(256);\n+        let s = task_rng().gen_vec::<u32>(256);\n         let mut r: IsaacRng = SeedableRng::from_seed(s.as_slice());\n         let string1 = r.gen_ascii_str(100);\n \n@@ -476,7 +486,7 @@ mod test {\n     }\n     #[test]\n     fn test_rng_64_reseed() {\n-        let s = OSRng::new().gen_vec::<u64>(256);\n+        let s = task_rng().gen_vec::<u64>(256);\n         let mut r: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n         let string1 = r.gen_ascii_str(100);\n "}, {"sha": "56d52e784661926134313eeac8564957fb106d62", "filename": "src/librand/lib.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -78,6 +78,7 @@ println!(\"{:?}\", tuple_ptr)\n #[phase(syntax, link)] extern crate log;\n \n use std::cast;\n+use std::io::IoResult;\n use std::kinds::marker;\n use std::local_data;\n use std::str;\n@@ -403,7 +404,7 @@ pub trait SeedableRng<Seed>: Rng {\n /// appropriate.\n #[deprecated=\"use `task_rng` or `StdRng::new`\"]\n pub fn rng() -> StdRng {\n-    StdRng::new()\n+    StdRng::new().unwrap()\n }\n \n /// The standard RNG. This is designed to be efficient on the current\n@@ -425,9 +426,12 @@ impl StdRng {\n     /// number of random numbers, or doesn't need the utmost speed for\n     /// generating each number, `task_rng` and/or `random` may be more\n     /// appropriate.\n+    ///\n+    /// Reading the randomness from the OS may fail, and any error is\n+    /// propagated via the `IoResult` return value.\n     #[cfg(not(target_word_size=\"64\"))]\n-    pub fn new() -> StdRng {\n-        StdRng { rng: IsaacRng::new() }\n+    pub fn new() -> IoResult<StdRng> {\n+        IsaacRng::new().map(|r| StdRng { rng: r })\n     }\n     /// Create a randomly seeded instance of `StdRng`.\n     ///\n@@ -437,9 +441,12 @@ impl StdRng {\n     /// number of random numbers, or doesn't need the utmost speed for\n     /// generating each number, `task_rng` and/or `random` may be more\n     /// appropriate.\n+    ///\n+    /// Reading the randomness from the OS may fail, and any error is\n+    /// propagated via the `IoResult` return value.\n     #[cfg(target_word_size=\"64\")]\n-    pub fn new() -> StdRng {\n-        StdRng { rng: Isaac64Rng::new() }\n+    pub fn new() -> IoResult<StdRng> {\n+        Isaac64Rng::new().map(|r| StdRng { rng: r })\n     }\n }\n \n@@ -477,7 +484,10 @@ impl<'a> SeedableRng<&'a [uint]> for StdRng {\n /// This will read randomness from the operating system to seed the\n /// generator.\n pub fn weak_rng() -> XorShiftRng {\n-    XorShiftRng::new()\n+    match XorShiftRng::new() {\n+        Ok(r) => r,\n+        Err(e) => fail!(\"weak_rng: failed to create seeded RNG: {}\", e)\n+    }\n }\n \n /// An Xorshift[1] random number\n@@ -539,18 +549,18 @@ impl SeedableRng<[u32, .. 4]> for XorShiftRng {\n \n impl XorShiftRng {\n     /// Create an xor shift random number generator with a random seed.\n-    pub fn new() -> XorShiftRng {\n+    pub fn new() -> IoResult<XorShiftRng> {\n         let mut s = [0u8, ..16];\n+        let mut r = try!(OSRng::new());\n         loop {\n-            let mut r = OSRng::new();\n             r.fill_bytes(s);\n \n             if !s.iter().all(|x| *x == 0) {\n                 break;\n             }\n         }\n         let s: [u32, ..4] = unsafe { cast::transmute(s) };\n-        SeedableRng::from_seed(s)\n+        Ok(SeedableRng::from_seed(s))\n     }\n }\n \n@@ -559,7 +569,10 @@ struct TaskRngReseeder;\n \n impl reseeding::Reseeder<StdRng> for TaskRngReseeder {\n     fn reseed(&mut self, rng: &mut StdRng) {\n-        *rng = StdRng::new();\n+        *rng = match StdRng::new() {\n+            Ok(r) => r,\n+            Err(e) => fail!(\"could not reseed task_rng: {}\", e)\n+        }\n     }\n }\n static TASK_RNG_RESEED_THRESHOLD: uint = 32_768;\n@@ -596,7 +609,11 @@ local_data_key!(TASK_RNG_KEY: ~TaskRngInner)\n pub fn task_rng() -> TaskRng {\n     local_data::get_mut(TASK_RNG_KEY, |rng| match rng {\n         None => {\n-            let mut rng = ~reseeding::ReseedingRng::new(StdRng::new(),\n+            let r = match StdRng::new() {\n+                Ok(r) => r,\n+                Err(e) => fail!(\"could not initialize task_rng: {}\", e)\n+            };\n+            let mut rng = ~reseeding::ReseedingRng::new(r,\n                                                         TASK_RNG_RESEED_THRESHOLD,\n                                                         TaskRngReseeder);\n             let ptr = &mut *rng as *mut TaskRngInner;\n@@ -679,7 +696,7 @@ pub struct Closed01<F>(F);\n #[cfg(test)]\n mod test {\n     use std::slice;\n-    use super::{Rng, task_rng, random, OSRng, SeedableRng, StdRng};\n+    use super::{Rng, task_rng, random, SeedableRng, StdRng};\n \n     struct ConstRng { i: u64 }\n     impl Rng for ConstRng {\n@@ -841,15 +858,15 @@ mod test {\n \n     #[test]\n     fn test_std_rng_seeded() {\n-        let s = OSRng::new().gen_vec::<uint>(256);\n+        let s = task_rng().gen_vec::<uint>(256);\n         let mut ra: StdRng = SeedableRng::from_seed(s.as_slice());\n         let mut rb: StdRng = SeedableRng::from_seed(s.as_slice());\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n \n     #[test]\n     fn test_std_rng_reseed() {\n-        let s = OSRng::new().gen_vec::<uint>(256);\n+        let s = task_rng().gen_vec::<uint>(256);\n         let mut r: StdRng = SeedableRng::from_seed(s.as_slice());\n         let string1 = r.gen_ascii_str(100);\n \n@@ -872,7 +889,7 @@ mod bench {\n \n     #[bench]\n     fn rand_xorshift(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n+        let mut rng = XorShiftRng::new().unwrap();\n         bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n@@ -883,7 +900,7 @@ mod bench {\n \n     #[bench]\n     fn rand_isaac(bh: &mut BenchHarness) {\n-        let mut rng = IsaacRng::new();\n+        let mut rng = IsaacRng::new().unwrap();\n         bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n@@ -894,7 +911,7 @@ mod bench {\n \n     #[bench]\n     fn rand_isaac64(bh: &mut BenchHarness) {\n-        let mut rng = Isaac64Rng::new();\n+        let mut rng = Isaac64Rng::new().unwrap();\n         bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n@@ -905,7 +922,7 @@ mod bench {\n \n     #[bench]\n     fn rand_std(bh: &mut BenchHarness) {\n-        let mut rng = StdRng::new();\n+        let mut rng = StdRng::new().unwrap();\n         bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n@@ -916,7 +933,7 @@ mod bench {\n \n     #[bench]\n     fn rand_shuffle_100(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n+        let mut rng = XorShiftRng::new().unwrap();\n         let x : &mut[uint] = [1,..100];\n         bh.iter(|| {\n             rng.shuffle_mut(x);"}, {"sha": "86960af7a4d84e143f3e55c1afbdfd542545ce1c", "filename": "src/librand/os.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fos.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -17,7 +17,7 @@ pub use self::imp::OSRng;\n mod imp {\n     use Rng;\n     use reader::ReaderRng;\n-    use std::io::File;\n+    use std::io::{IoResult, File};\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -35,12 +35,11 @@ mod imp {\n \n     impl OSRng {\n         /// Create a new `OSRng`.\n-        pub fn new() -> OSRng {\n-            let reader = File::open(&Path::new(\"/dev/urandom\"));\n-            let reader = reader.ok().expect(\"Error opening /dev/urandom\");\n+        pub fn new() -> IoResult<OSRng> {\n+            let reader = try!(File::open(&Path::new(\"/dev/urandom\")));\n             let reader_rng = ReaderRng::new(reader);\n \n-            OSRng { inner: reader_rng }\n+            Ok(OSRng { inner: reader_rng })\n         }\n     }\n \n@@ -61,6 +60,7 @@ mod imp {\n mod imp {\n     use Rng;\n     use std::cast;\n+    use std::io::{IoResult, IoError};\n     use std::libc::{c_ulong, DWORD, BYTE, LPCSTR, BOOL};\n     use std::os;\n     use std::rt::stack;\n@@ -99,7 +99,7 @@ mod imp {\n \n     impl OSRng {\n         /// Create a new `OSRng`.\n-        pub fn new() -> OSRng {\n+        pub fn new() -> IoResult<OSRng> {\n             let mut hcp = 0;\n             let mut ret = unsafe {\n                 CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n@@ -143,9 +143,10 @@ mod imp {\n             }\n \n             if ret == 0 {\n-                fail!(\"couldn't create context: {}\", os::last_os_error());\n+                Err(IoError::last_error())\n+            } else {\n+                Ok(OSRng { hcryptprov: hcp })\n             }\n-            OSRng { hcryptprov: hcp }\n         }\n     }\n \n@@ -191,7 +192,7 @@ mod test {\n \n     #[test]\n     fn test_os_rng() {\n-        let mut r = OSRng::new();\n+        let mut r = OSRng::new().unwrap();\n \n         r.next_u32();\n         r.next_u64();\n@@ -213,7 +214,7 @@ mod test {\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n-                let mut r = OSRng::new();\n+                let mut r = OSRng::new().unwrap();\n                 task::deschedule();\n                 let mut v = [0u8, .. 1000];\n "}, {"sha": "c069c7389c2112ba2e5cbbee47e2a807443f30a8", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -100,20 +100,22 @@ impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R>>\n /// # Example\n ///\n /// ```rust\n-/// use rand::{Rng, SeedableRng};\n+/// use rand::{Rng, SeedableRng, StdRng};\n /// use rand::reseeding::{Reseeder, ReseedingRng};\n ///\n /// struct TickTockReseeder { tick: bool }\n-/// impl Reseeder<rand::StdRng> for TickTockReseeder {\n-///     fn reseed(&mut self, rng: &mut rand::StdRng) {\n+/// impl Reseeder<StdRng> for TickTockReseeder {\n+///     fn reseed(&mut self, rng: &mut StdRng) {\n ///         let val = if self.tick {0} else {1};\n ///         rng.reseed(&[val]);\n ///         self.tick = !self.tick;\n ///     }\n /// }\n /// fn main() {\n ///     let rsdr = TickTockReseeder { tick: true };\n-///     let mut rng = ReseedingRng::new(rand::StdRng::new(), 10, rsdr);\n+///\n+///     let inner = StdRng::new().unwrap();\n+///     let mut rng = ReseedingRng::new(inner, 10, rsdr);\n ///\n ///     // this will repeat, because it gets reseeded very regularly.\n ///     println!(\"{}\", rng.gen_ascii_str(100));"}, {"sha": "4d1d08551a68037019cece7ac3387cbb92ebd595", "filename": "src/libstd/fmt/num.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fnum.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -400,31 +400,31 @@ mod bench {\n \n         #[bench]\n         fn format_bin(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n         }\n \n         #[bench]\n         fn format_oct(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n         }\n \n         #[bench]\n         fn format_dec(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n         }\n \n         #[bench]\n         fn format_hex(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n         }\n \n         #[bench]\n         fn format_base_36(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n         }\n     }\n@@ -436,31 +436,31 @@ mod bench {\n \n         #[bench]\n         fn format_bin(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n         }\n \n         #[bench]\n         fn format_oct(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n         }\n \n         #[bench]\n         fn format_dec(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n         }\n \n         #[bench]\n         fn format_hex(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n         }\n \n         #[bench]\n         fn format_base_36(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n         }\n     }"}, {"sha": "410b841545e4ffc8b388134399d8eeded81591b9", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -1286,7 +1286,7 @@ mod test {\n         use rand::{StdRng, Rng};\n \n         let mut bytes = [0, ..1024];\n-        StdRng::new().fill_bytes(bytes);\n+        StdRng::new().unwrap().fill_bytes(bytes);\n \n         let tmpdir = tmpdir();\n "}, {"sha": "403e0e48fd51bbbce6e1706e2b58650d6d6c36ff", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -216,6 +216,8 @@ use container::Container;\n use fmt;\n use int;\n use iter::Iterator;\n+use libc;\n+use os;\n use option::{Option, Some, None};\n use path::Path;\n use result::{Ok, Err, Result};\n@@ -290,6 +292,88 @@ pub struct IoError {\n     pub detail: Option<~str>\n }\n \n+impl IoError {\n+    /// Convert an `errno` value into an `IoError`.\n+    ///\n+    /// If `detail` is `true`, the `detail` field of the `IoError`\n+    /// struct is filled with an allocated string describing the error\n+    /// in more detail, retrieved from the operating system.\n+    pub fn from_errno(errno: uint, detail: bool) -> IoError {\n+        #[cfg(windows)]\n+        fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n+            match errno {\n+                libc::EOF => (EndOfFile, \"end of file\"),\n+                libc::ERROR_NO_DATA => (BrokenPipe, \"the pipe is being closed\"),\n+                libc::ERROR_FILE_NOT_FOUND => (FileNotFound, \"file not found\"),\n+                libc::ERROR_INVALID_NAME => (InvalidInput, \"invalid file name\"),\n+                libc::WSAECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n+                libc::WSAECONNRESET => (ConnectionReset, \"connection reset\"),\n+                libc::WSAEACCES => (PermissionDenied, \"permission denied\"),\n+                libc::WSAEWOULDBLOCK => {\n+                    (ResourceUnavailable, \"resource temporarily unavailable\")\n+                }\n+                libc::WSAENOTCONN => (NotConnected, \"not connected\"),\n+                libc::WSAECONNABORTED => (ConnectionAborted, \"connection aborted\"),\n+                libc::WSAEADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n+                libc::WSAEADDRINUSE => (ConnectionRefused, \"address in use\"),\n+                libc::ERROR_BROKEN_PIPE => (EndOfFile, \"the pipe has ended\"),\n+\n+                // libuv maps this error code to EISDIR. we do too. if it is found\n+                // to be incorrect, we can add in some more machinery to only\n+                // return this message when ERROR_INVALID_FUNCTION after certain\n+                // win32 calls.\n+                libc::ERROR_INVALID_FUNCTION => (InvalidInput,\n+                                                 \"illegal operation on a directory\"),\n+\n+                _ => (OtherIoError, \"unknown error\")\n+            }\n+        }\n+\n+        #[cfg(not(windows))]\n+        fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n+            // FIXME: this should probably be a bit more descriptive...\n+            match errno {\n+                libc::EOF => (EndOfFile, \"end of file\"),\n+                libc::ECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n+                libc::ECONNRESET => (ConnectionReset, \"connection reset\"),\n+                libc::EPERM | libc::EACCES =>\n+                    (PermissionDenied, \"permission denied\"),\n+                libc::EPIPE => (BrokenPipe, \"broken pipe\"),\n+                libc::ENOTCONN => (NotConnected, \"not connected\"),\n+                libc::ECONNABORTED => (ConnectionAborted, \"connection aborted\"),\n+                libc::EADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n+                libc::EADDRINUSE => (ConnectionRefused, \"address in use\"),\n+                libc::ENOENT => (FileNotFound, \"no such file or directory\"),\n+                libc::EISDIR => (InvalidInput, \"illegal operation on a directory\"),\n+\n+                // These two constants can have the same value on some systems, but\n+                // different values on others, so we can't use a match clause\n+                x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+                    (ResourceUnavailable, \"resource temporarily unavailable\"),\n+\n+                _ => (OtherIoError, \"unknown error\")\n+            }\n+        }\n+\n+        let (kind, desc) = get_err(errno as i32);\n+        IoError {\n+            kind: kind,\n+            desc: desc,\n+            detail: if detail {Some(os::error_string(errno))} else {None},\n+        }\n+    }\n+\n+    /// Retrieve the last error to occur as a (detailed) IoError.\n+    ///\n+    /// This uses the OS `errno`, and so there should not be any task\n+    /// descheduling or migration (other than that performed by the\n+    /// operating system) between the call(s) for which errors are\n+    /// being checked and the call of this function.\n+    pub fn last_error() -> IoError {\n+        IoError::from_errno(os::errno() as uint, true)\n+    }\n+}\n+\n impl fmt::Show for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(fmt.buf.write_str(self.desc));"}, {"sha": "15c7b251fa7417f88f1b06609bca0cd2264f633e", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -821,31 +821,31 @@ mod bench {\n \n         #[bench]\n         fn to_str_bin(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<uint>().to_str_radix(2); })\n         }\n \n         #[bench]\n         fn to_str_oct(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<uint>().to_str_radix(8); })\n         }\n \n         #[bench]\n         fn to_str_dec(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<uint>().to_str_radix(10); })\n         }\n \n         #[bench]\n         fn to_str_hex(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<uint>().to_str_radix(16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<uint>().to_str_radix(36); })\n         }\n     }\n@@ -857,31 +857,31 @@ mod bench {\n \n         #[bench]\n         fn to_str_bin(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<int>().to_str_radix(2); })\n         }\n \n         #[bench]\n         fn to_str_oct(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<int>().to_str_radix(8); })\n         }\n \n         #[bench]\n         fn to_str_dec(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<int>().to_str_radix(10); })\n         }\n \n         #[bench]\n         fn to_str_hex(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<int>().to_str_radix(16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { rng.gen::<int>().to_str_radix(36); })\n         }\n     }\n@@ -893,7 +893,7 @@ mod bench {\n \n         #[bench]\n         fn float_to_str(bh: &mut BenchHarness) {\n-            let mut rng = XorShiftRng::new();\n+            let mut rng = XorShiftRng::new().unwrap();\n             bh.iter(|| { f64::to_str(rng.gen()); })\n         }\n     }"}, {"sha": "a5583afb31dde25edb1e0585ae6332df8ef18fcb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -663,10 +663,12 @@ pub fn errno() -> uint {\n     }\n }\n \n-/// Get a string representing the platform-dependent last error\n-pub fn last_os_error() -> ~str {\n+/// Return the string corresponding to an `errno()` value of `errnum`.\n+pub fn error_string(errnum: uint) -> ~str {\n+    return strerror(errnum);\n+\n     #[cfg(unix)]\n-    fn strerror() -> ~str {\n+    fn strerror(errnum: uint) -> ~str {\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n@@ -702,7 +704,7 @@ pub fn last_os_error() -> ~str {\n \n         let p = buf.as_mut_ptr();\n         unsafe {\n-            if strerror_r(errno() as c_int, p, buf.len() as libc::size_t) < 0 {\n+            if strerror_r(errnum as c_int, p, buf.len() as libc::size_t) < 0 {\n                 fail!(\"strerror_r failure\");\n             }\n \n@@ -711,7 +713,7 @@ pub fn last_os_error() -> ~str {\n     }\n \n     #[cfg(windows)]\n-    fn strerror() -> ~str {\n+    fn strerror(errnum: uint) -> ~str {\n         use libc::types::os::arch::extra::DWORD;\n         use libc::types::os::arch::extra::LPWSTR;\n         use libc::types::os::arch::extra::LPVOID;\n@@ -735,34 +737,36 @@ pub fn last_os_error() -> ~str {\n         // This value is calculated from the macro\n         // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n         let langId = 0x0800 as DWORD;\n-        let err = errno() as DWORD;\n \n         let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n \n         unsafe {\n             let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n                                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                                      ptr::mut_null(),\n-                                     err,\n+                                     errnum as DWORD,\n                                      langId,\n                                      buf.as_mut_ptr(),\n                                      buf.len() as DWORD,\n                                      ptr::null());\n             if res == 0 {\n                 // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n                 let fm_err = errno();\n-                return format!(\"OS Error {} (FormatMessageW() returned error {})\", err, fm_err);\n+                return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n             }\n \n             let msg = str::from_utf16(str::truncate_utf16_at_nul(buf));\n             match msg {\n-                Some(msg) => format!(\"OS Error {}: {}\", err, msg),\n-                None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", err),\n+                Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n+                None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n             }\n         }\n     }\n+}\n \n-    strerror()\n+/// Get a string representing the platform-dependent last error\n+pub fn last_os_error() -> ~str {\n+    error_string(errno() as uint)\n }\n \n static mut EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;"}, {"sha": "0f90135512c3c667d21d9080882ef569945af0c5", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -435,7 +435,7 @@ mod test {\n     #[test]\n     fn rng() {\n         use rand::{StdRng, Rng};\n-        let mut r = StdRng::new();\n+        let mut r = StdRng::new().unwrap();\n         let _ = r.next_u32();\n     }\n "}, {"sha": "babf3f737fbeda6c6559fdd3f08d1cfcd8db0447", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -41,7 +41,7 @@ struct Noise2DContext {\n \n impl Noise2DContext {\n     fn new() -> Noise2DContext {\n-        let mut rng = StdRng::new();\n+        let mut rng = StdRng::new().unwrap();\n \n         let mut rgradients = [Vec2 { x: 0.0, y: 0.0 }, ..256];\n         for x in rgradients.mut_iter() {"}]}