{"sha": "3ae2468261dca097ecfa81a74654fed32b60f8ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZTI0NjgyNjFkY2EwOTdlY2ZhODFhNzQ2NTRmZWQzMmI2MGY4Y2U=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-14T18:57:59Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-15T13:22:11Z"}, "message": "Clean up shared subst code", "tree": {"sha": "888f15ca0211f0175ac1cc5f744b3a4f8c1c4757", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/888f15ca0211f0175ac1cc5f744b3a4f8c1c4757"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ae2468261dca097ecfa81a74654fed32b60f8ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae2468261dca097ecfa81a74654fed32b60f8ce", "html_url": "https://github.com/rust-lang/rust/commit/3ae2468261dca097ecfa81a74654fed32b60f8ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ae2468261dca097ecfa81a74654fed32b60f8ce/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9190da9825b729ce63becf727b2cfdad3e8561a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9190da9825b729ce63becf727b2cfdad3e8561a", "html_url": "https://github.com/rust-lang/rust/commit/d9190da9825b729ce63becf727b2cfdad3e8561a"}], "stats": {"total": 245, "additions": 101, "deletions": 144}, "files": [{"sha": "7a1e255dc5d0cbca3f73c2d3c16f5351efc8bd26", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3ae2468261dca097ecfa81a74654fed32b60f8ce", "patch": "@@ -905,34 +905,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.next_region_var(RegionVariableOrigin::NLL(origin))\n     }\n \n-    /// Create a region inference variable for the given\n-    /// region parameter definition.\n-    pub fn region_var_for_def(&self,\n-                              span: Span,\n-                              def: &ty::GenericParamDef)\n-                              -> ty::Region<'tcx> {\n-        self.next_region_var(EarlyBoundRegion(span, def.name))\n-    }\n-\n-    /// Create a type inference variable for the given\n-    /// type parameter definition. The substitutions are\n-    /// for actual parameters that may be referred to by\n-    /// the default of this type parameter, if it exists.\n-    /// E.g. `struct Foo<A, B, C = (A, B)>(...);` when\n-    /// used in a path such as `Foo::<T, U>::new()` will\n-    /// use an inference variable for `C` with `[T, U]`\n-    /// as the substitutions for the default, `(T, U)`.\n-    pub fn type_var_for_def(&self,\n-                            span: Span,\n-                            def: &ty::GenericParamDef)\n-                            -> Ty<'tcx> {\n-        let ty_var_id = self.type_variables\n-                            .borrow_mut()\n-                            .new_var(self.universe(),\n-                                     false,\n-                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n-\n-        self.tcx.mk_var(ty_var_id)\n+    pub fn var_for_def(&self,\n+                       span: Span,\n+                       param: &ty::GenericParamDef)\n+                       -> UnpackedKind<'tcx> {\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => {\n+                // Create a region inference variable for the given\n+                // region parameter definition.\n+                UnpackedKind::Lifetime(self.next_region_var(EarlyBoundRegion(span, param.name)))\n+            }\n+            GenericParamDefKind::Type(_) => {\n+                // Create a type inference variable for the given\n+                // type parameter definition. The substitutions are\n+                // for actual parameters that may be referred to by\n+                // the default of this type parameter, if it exists.\n+                // E.g. `struct Foo<A, B, C = (A, B)>(...);` when\n+                // used in a path such as `Foo::<T, U>::new()` will\n+                // use an inference variable for `C` with `[T, U]`\n+                // as the substitutions for the default, `(T, U)`.\n+                let ty_var_id = self.type_variables\n+                                    .borrow_mut()\n+                                    .new_var(self.universe(),\n+                                             false,\n+                                             TypeVariableOrigin::TypeParameterDefinition(span, param.name));\n+\n+                UnpackedKind::Type(self.tcx.mk_var(ty_var_id))\n+            }\n+        }\n     }\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n@@ -942,14 +942,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n         Substs::for_item(self.tcx, def_id, |param, _| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {\n-                    UnpackedKind::Lifetime(self.region_var_for_def(span, param))\n-                }\n-                GenericParamDefKind::Type(_) => {\n-                    UnpackedKind::Type(self.type_var_for_def(span, param))\n-                }\n-            }\n+            self.var_for_def(span, param)\n         })\n     }\n "}, {"sha": "66c451e8193109b5b1c33f9a3894e94b6e34050f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3ae2468261dca097ecfa81a74654fed32b60f8ce", "patch": "@@ -2329,18 +2329,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let substs = Substs::for_item(self, def_id, |param, substs| {\n             match param.kind {\n                 GenericParamDefKind::Lifetime => bug!(),\n-                GenericParamDefKind::Type(_) => {\n+                GenericParamDefKind::Type(ty_param) => {\n                     if param.index == 0 {\n                         UnpackedKind::Type(ty)\n                     } else {\n-                        match param.kind {\n-                            ty::GenericParamDefKind::Type(ty_param) => {\n-                                assert!(ty_param.has_default);\n-                                UnpackedKind::Type(\n-                                    self.type_of(param.def_id).subst(self, substs))\n-                            }\n-                            _ => unreachable!()\n-                        }\n+                        assert!(ty_param.has_default);\n+                        UnpackedKind::Type(self.type_of(param.def_id).subst(self, substs))\n                     }\n                 }\n             }"}, {"sha": "32ea9938ff554e9de4e7f697077006be60b7bb32", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3ae2468261dca097ecfa81a74654fed32b60f8ce", "patch": "@@ -276,32 +276,26 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     };\n                     UnpackedKind::Lifetime(lt)\n                 }\n-                GenericParamDefKind::Type(_) => {\n+                GenericParamDefKind::Type(ty) => {\n                     let i = param.index as usize;\n \n                     // Handle Self first, so we can adjust the index to match the AST.\n                     if let (0, Some(ty)) = (i, self_ty) {\n                         return UnpackedKind::Type(ty);\n                     }\n \n-                    let has_default = match param.kind {\n-                        GenericParamDefKind::Type(ty) => ty.has_default,\n-                        _ => unreachable!()\n-                    };\n-\n                     let i = i - (lt_accepted + own_self);\n                     let ty = if i < ty_provided {\n                         // A provided type parameter.\n                         self.ast_ty_to_ty(&parameters.types[i])\n                     } else if infer_types {\n                         // No type parameters were provided, we can infer all.\n-                        let ty_var = if !default_needs_object_self(param) {\n+                        if !default_needs_object_self(param) {\n                             self.ty_infer_for_def(param, span)\n                         } else {\n                             self.ty_infer(span)\n-                        };\n-                        ty_var\n-                    } else if has_default {\n+                        }\n+                    } else if ty.has_default {\n                         // No type parameter provided, but a default exists.\n \n                         // If we are converting an object type, then the"}, {"sha": "e2b4380fda2a5c34dee3db7d0c178785fce89809", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3ae2468261dca097ecfa81a74654fed32b60f8ce", "patch": "@@ -318,36 +318,28 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let provided = &segment.parameters;\n         let own_counts = method_generics.own_counts();\n         Substs::for_item(self.tcx, pick.item.def_id, |param, _| {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {\n-                    let i = param.index as usize;\n-                    let lt = if i < parent_substs.len() {\n-                        parent_substs.region_at(i)\n-                    } else if let Some(lifetime)\n-                            = provided.as_ref().and_then(|p| p.lifetimes.get(i - parent_substs.len())) {\n-                        AstConv::ast_region_to_region(self.fcx, lifetime, Some(param))\n-                    } else {\n-                        self.region_var_for_def(self.span, param)\n-                    };\n-                    UnpackedKind::Lifetime(lt)\n-                }\n-                GenericParamDefKind::Type(_) => {\n-                    let i = param.index as usize;\n-                    let ty = if i < parent_substs.len() {\n-                        parent_substs.type_at(i)\n-                    } else if let Some(ast_ty)\n-                        = provided.as_ref().and_then(|p| {\n-                            let idx =\n-                                i - parent_substs.len() - own_counts.lifetimes;\n-                            p.types.get(idx)\n-                        })\n-                    {\n-                        self.to_ty(ast_ty)\n-                    } else {\n-                        self.type_var_for_def(self.span, param)\n-                    };\n-                    UnpackedKind::Type(ty)\n+            let i = param.index as usize;\n+            if i < parent_substs.len() {\n+                parent_substs[i].unpack()\n+            } else {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        if let Some(lifetime) = provided.as_ref().and_then(|p| {\n+                            p.lifetimes.get(i - parent_substs.len())\n+                        }) {\n+                            return UnpackedKind::Lifetime(\n+                                AstConv::ast_region_to_region(self.fcx, lifetime, Some(param)));\n+                        }\n+                    }\n+                    GenericParamDefKind::Type(_) => {\n+                        if let Some(ast_ty) = provided.as_ref().and_then(|p| {\n+                            p.types.get(i - parent_substs.len() - own_counts.lifetimes)\n+                        }) {\n+                            return UnpackedKind::Type(self.to_ty(ast_ty));\n+                        }\n+                    }\n                 }\n+                self.var_for_def(self.span, param)\n             }\n         })\n     }"}, {"sha": "f02f70caef9b87597b6899fb2a5d5f62e799624d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3ae2468261dca097ecfa81a74654fed32b60f8ce", "patch": "@@ -256,20 +256,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n         let substs = Substs::for_item(self.tcx, trait_def_id, |param, _| {\n             match param.kind {\n-                GenericParamDefKind::Lifetime => {\n-                    UnpackedKind::Lifetime(self.region_var_for_def(span, param))\n-                }\n+                GenericParamDefKind::Lifetime => {}\n                 GenericParamDefKind::Type(_) => {\n-                    let ty = if param.index == 0 {\n-                        self_ty\n+                    if param.index == 0 {\n+                        return UnpackedKind::Type(self_ty);\n                     } else if let Some(ref input_types) = opt_input_types {\n-                        input_types[param.index as usize - 1]\n-                    } else {\n-                        self.type_var_for_def(span, param)\n-                    };\n-                    UnpackedKind::Type(ty)\n+                        return UnpackedKind::Type(input_types[param.index as usize - 1]);\n+                    }\n                 }\n             }\n+            self.var_for_def(span, param)\n         });\n \n         let trait_ref = ty::TraitRef::new(trait_def_id, substs);"}, {"sha": "54fea4ab00a683d73f4eb5639275830885334987", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3ae2468261dca097ecfa81a74654fed32b60f8ce", "patch": "@@ -1389,26 +1389,17 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             xform_fn_sig.subst(self.tcx, substs)\n         } else {\n             let substs = Substs::for_item(self.tcx, method, |param, _| {\n-                match param.kind {\n-                    GenericParamDefKind::Lifetime => {\n-                        let i = param.index as usize;\n-                        let lt = if i < substs.len() {\n-                            substs.region_at(i)\n-                        } else {\n+                let i = param.index as usize;\n+                if i < substs.len() {\n+                    substs[i].unpack()\n+                } else {\n+                    match param.kind {\n+                        GenericParamDefKind::Lifetime => {\n                             // In general, during probe we erase regions. See\n                             // `impl_self_ty()` for an explanation.\n-                            self.tcx.types.re_erased\n-                        };\n-                        UnpackedKind::Lifetime(lt)\n-                    }\n-                    GenericParamDefKind::Type(_) => {\n-                        let i = param.index as usize;\n-                        let ty = if i < substs.len() {\n-                            substs.type_at(i)\n-                        } else {\n-                            self.type_var_for_def(self.span, param)\n-                        };\n-                        UnpackedKind::Type(ty)\n+                            UnpackedKind::Lifetime(self.tcx.types.re_erased)\n+                        }\n+                        GenericParamDefKind::Type(_) => self.var_for_def(self.span, param),\n                     }\n                 }\n             });"}, {"sha": "0b0659729ef8be27aaff9254d216b1ac313045c1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae2468261dca097ecfa81a74654fed32b60f8ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3ae2468261dca097ecfa81a74654fed32b60f8ce", "patch": "@@ -1746,7 +1746,11 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn ty_infer_for_def(&self,\n                         ty_param_def: &ty::GenericParamDef,\n                         span: Span) -> Ty<'tcx> {\n-        self.type_var_for_def(span, ty_param_def)\n+        if let UnpackedKind::Type(ty) = self.var_for_def(span, ty_param_def) {\n+            ty\n+        } else {\n+            unreachable!()\n+        }\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -4759,17 +4763,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (None, None) => (0, false)\n         };\n         let substs = Substs::for_item(self.tcx, def.def_id(), |param, substs| {\n+            let mut i = param.index as usize;\n+\n+            let segment = if i < fn_start {\n+                if let GenericParamDefKind::Type(_) = param.kind {\n+                    // Handle Self first, so we can adjust the index to match the AST.\n+                    if has_self && i == 0 {\n+                        return opt_self_ty.map(|ty| UnpackedKind::Type(ty)).unwrap_or_else(|| {\n+                            self.var_for_def(span, param)\n+                        });\n+                    }\n+                }\n+                i -= has_self as usize;\n+                type_segment\n+            } else {\n+                i -= fn_start;\n+                fn_segment\n+            };\n+\n             match param.kind {\n                 GenericParamDefKind::Lifetime => {\n-                    let mut i = param.index as usize;\n-\n-                    let segment = if i < fn_start {\n-                        i -= has_self as usize;\n-                        type_segment\n-                    } else {\n-                        i -= fn_start;\n-                        fn_segment\n-                    };\n                     let lifetimes = segment.map_or(&[][..], |(s, _)| {\n                         s.parameters.as_ref().map_or(&[][..], |p| &p.lifetimes[..])\n                     });\n@@ -4782,21 +4795,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     UnpackedKind::Lifetime(lt)\n                 }\n                 GenericParamDefKind::Type(_) => {\n-                    let mut i = param.index as usize;\n-\n-                    let segment = if i < fn_start {\n-                        // Handle Self first, so we can adjust the index to match the AST.\n-                        if has_self && i == 0 {\n-                            return UnpackedKind::Type(opt_self_ty.unwrap_or_else(|| {\n-                                self.type_var_for_def(span, param)\n-                            }));\n-                        }\n-                        i -= has_self as usize;\n-                        type_segment\n-                    } else {\n-                        i -= fn_start;\n-                        fn_segment\n-                    };\n                     let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n                         (s.parameters.as_ref().map_or(&[][..], |p| &p.types[..]), s.infer_types)\n                     });\n@@ -4811,24 +4809,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => unreachable!()\n                     };\n \n-                    let ty = if let Some(ast_ty) = types.get(i) {\n+                    if let Some(ast_ty) = types.get(i) {\n                         // A provided type parameter.\n-                        self.to_ty(ast_ty)\n+                        UnpackedKind::Type(self.to_ty(ast_ty))\n                     } else if !infer_types && has_default {\n                         // No type parameter provided, but a default exists.\n                         let default = self.tcx.type_of(param.def_id);\n-                        self.normalize_ty(\n+                        UnpackedKind::Type(self.normalize_ty(\n                             span,\n                             default.subst_spanned(self.tcx, substs, Some(span))\n-                        )\n+                        ))\n                     } else {\n                         // No type parameters were provided, we can infer all.\n                         // This can also be reached in some error cases:\n                         // We prefer to use inference variables instead of\n                         // TyError to let type inference recover somewhat.\n-                        self.type_var_for_def(span, param)\n-                    };\n-                    UnpackedKind::Type(ty)\n+                        self.var_for_def(span, param)\n+                    }\n                 }\n             }\n         });"}]}