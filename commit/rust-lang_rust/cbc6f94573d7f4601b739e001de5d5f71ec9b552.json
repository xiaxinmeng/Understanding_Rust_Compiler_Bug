{"sha": "cbc6f94573d7f4601b739e001de5d5f71ec9b552", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYzZmOTQ1NzNkN2Y0NjAxYjczOWUwMDFkZTVkNWY3MWVjOWI1NTI=", "commit": {"author": {"name": "Wesley Norris", "email": "repnop@outlook.com", "date": "2019-11-09T15:56:36Z"}, "committer": {"name": "Wesley Norris", "email": "repnop@outlook.com", "date": "2019-11-09T15:56:36Z"}, "message": "Add add_new assist\n\nAdds a new assist to autogenerate a new fn based on the selected struct,\nexcluding tuple structs and unions. The fn will inherit the same\nvisibility as the struct and the assist will attempt to reuse any\nexisting impl blocks that exist at the same level of struct.", "tree": {"sha": "ee481bcf679e739dfea13ec36b16fb593607e43a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee481bcf679e739dfea13ec36b16fb593607e43a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbc6f94573d7f4601b739e001de5d5f71ec9b552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc6f94573d7f4601b739e001de5d5f71ec9b552", "html_url": "https://github.com/rust-lang/rust/commit/cbc6f94573d7f4601b739e001de5d5f71ec9b552", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbc6f94573d7f4601b739e001de5d5f71ec9b552/comments", "author": {"login": "repnop", "id": 24203105, "node_id": "MDQ6VXNlcjI0MjAzMTA1", "avatar_url": "https://avatars.githubusercontent.com/u/24203105?v=4", "gravatar_id": "", "url": "https://api.github.com/users/repnop", "html_url": "https://github.com/repnop", "followers_url": "https://api.github.com/users/repnop/followers", "following_url": "https://api.github.com/users/repnop/following{/other_user}", "gists_url": "https://api.github.com/users/repnop/gists{/gist_id}", "starred_url": "https://api.github.com/users/repnop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/repnop/subscriptions", "organizations_url": "https://api.github.com/users/repnop/orgs", "repos_url": "https://api.github.com/users/repnop/repos", "events_url": "https://api.github.com/users/repnop/events{/privacy}", "received_events_url": "https://api.github.com/users/repnop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "repnop", "id": 24203105, "node_id": "MDQ6VXNlcjI0MjAzMTA1", "avatar_url": "https://avatars.githubusercontent.com/u/24203105?v=4", "gravatar_id": "", "url": "https://api.github.com/users/repnop", "html_url": "https://github.com/repnop", "followers_url": "https://api.github.com/users/repnop/followers", "following_url": "https://api.github.com/users/repnop/following{/other_user}", "gists_url": "https://api.github.com/users/repnop/gists{/gist_id}", "starred_url": "https://api.github.com/users/repnop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/repnop/subscriptions", "organizations_url": "https://api.github.com/users/repnop/orgs", "repos_url": "https://api.github.com/users/repnop/repos", "events_url": "https://api.github.com/users/repnop/events{/privacy}", "received_events_url": "https://api.github.com/users/repnop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d786ea221b27fbdf7c7f7beea0290db448e0611", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d786ea221b27fbdf7c7f7beea0290db448e0611", "html_url": "https://github.com/rust-lang/rust/commit/9d786ea221b27fbdf7c7f7beea0290db448e0611"}], "stats": {"total": 424, "additions": 424, "deletions": 0}, "files": [{"sha": "a8839cfba3d2aa80a33b54c87259f5edabf2650f", "filename": "crates/ra_assists/src/assists/add_new.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6f94573d7f4601b739e001de5d5f71ec9b552/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6f94573d7f4601b739e001de5d5f71ec9b552/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs?ref=cbc6f94573d7f4601b739e001de5d5f71ec9b552", "patch": "@@ -0,0 +1,379 @@\n+use format_buf::format;\n+use hir::{db::HirDatabase, FromSource};\n+use join_to_string::join;\n+use ra_syntax::{\n+    ast::{\n+        self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n+    },\n+    TextUnit, T,\n+};\n+use std::fmt::Write;\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+\n+// Assist: add_new\n+//\n+// Adds a new inherent impl for a type.\n+//\n+// ```\n+// struct Ctx<T: Clone> {\n+//      data: T,<|>\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Ctx<T: Clone> {\n+//      data: T,\n+// }\n+//\n+// impl<T: Clone> Ctx<T> {\n+//     fn new(data: T) -> Self { Self { data } }\n+// }\n+//\n+// ```\n+pub(crate) fn add_new(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n+\n+    // We want to only apply this to non-union structs with named fields\n+    let field_list = match (strukt.kind(), strukt.is_union()) {\n+        (StructKind::Named(named), false) => named,\n+        _ => return None,\n+    };\n+\n+    // Return early if we've found an existing new fn\n+    let impl_block = find_struct_impl(&ctx, &strukt)?;\n+\n+    ctx.add_assist(AssistId(\"add_new\"), \"add new fn\", |edit| {\n+        edit.target(strukt.syntax().text_range());\n+\n+        let mut buf = String::with_capacity(512);\n+\n+        if impl_block.is_some() {\n+            buf.push('\\n');\n+        }\n+\n+        let vis = strukt.visibility().map(|v| format!(\"{} \", v.syntax()));\n+        let vis = vis.as_ref().map(String::as_str).unwrap_or(\"\");\n+        write!(&mut buf, \"    {}fn new(\", vis).unwrap();\n+\n+        join(field_list.fields().map(|f| {\n+            format!(\n+                \"{}: {}\",\n+                f.name().unwrap().syntax().text(),\n+                f.ascribed_type().unwrap().syntax().text()\n+            )\n+        }))\n+        .separator(\", \")\n+        .to_buf(&mut buf);\n+\n+        buf.push_str(\") -> Self { Self {\");\n+\n+        join(field_list.fields().map(|f| f.name().unwrap().syntax().text()))\n+            .separator(\", \")\n+            .surround_with(\" \", \" \")\n+            .to_buf(&mut buf);\n+\n+        buf.push_str(\"} }\");\n+\n+        let (start_offset, end_offset) = if let Some(impl_block) = impl_block {\n+            buf.push('\\n');\n+            let start = impl_block\n+                .syntax()\n+                .descendants_with_tokens()\n+                .find(|t| t.kind() == T!['{'])\n+                .unwrap()\n+                .text_range()\n+                .end();\n+\n+            (start, TextUnit::from_usize(1))\n+        } else {\n+            buf = generate_impl_text(&strukt, &buf);\n+            let start = strukt.syntax().text_range().end();\n+\n+            (start, TextUnit::from_usize(3))\n+        };\n+\n+        edit.set_cursor(start_offset + TextUnit::of_str(&buf) - end_offset);\n+        edit.insert(start_offset, buf);\n+    })\n+}\n+\n+// Generates the surrounding `impl Type { <code> }` including type and lifetime\n+// parameters\n+fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n+    let type_params = strukt.type_param_list();\n+    let mut buf = String::with_capacity(code.len());\n+    buf.push_str(\"\\n\\nimpl\");\n+    if let Some(type_params) = &type_params {\n+        format!(buf, \"{}\", type_params.syntax());\n+    }\n+    buf.push_str(\" \");\n+    buf.push_str(strukt.name().unwrap().text().as_str());\n+    if let Some(type_params) = type_params {\n+        let lifetime_params = type_params\n+            .lifetime_params()\n+            .filter_map(|it| it.lifetime_token())\n+            .map(|it| it.text().clone());\n+        let type_params =\n+            type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());\n+        join(lifetime_params.chain(type_params)).surround_with(\"<\", \">\").to_buf(&mut buf);\n+    }\n+\n+    format!(&mut buf, \" {{\\n{}\\n}}\\n\", code);\n+\n+    buf\n+}\n+\n+// Uses a syntax-driven approach to find any impl blocks for the struct that\n+// exist within the module/file\n+//\n+// Returns `None` if we've found an existing `new` fn\n+//\n+// FIXME: change the new fn checking to a more semantic approach when that's more\n+// viable (e.g. we process proc macros, etc)\n+fn find_struct_impl(\n+    ctx: &AssistCtx<impl HirDatabase>,\n+    strukt: &ast::StructDef,\n+) -> Option<Option<ast::ImplBlock>> {\n+    let db = ctx.db;\n+    let module = strukt.syntax().ancestors().find(|node| {\n+        ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n+    })?;\n+\n+    let struct_ty = {\n+        let src = hir::Source { file_id: ctx.frange.file_id.into(), ast: strukt.clone() };\n+        hir::Struct::from_source(db, src).unwrap().ty(db)\n+    };\n+\n+    let mut found_new_fn = false;\n+\n+    let block = module.descendants().filter_map(ast::ImplBlock::cast).find(|impl_blk| {\n+        if found_new_fn {\n+            return false;\n+        }\n+\n+        let src = hir::Source { file_id: ctx.frange.file_id.into(), ast: impl_blk.clone() };\n+        let blk = hir::ImplBlock::from_source(db, src).unwrap();\n+\n+        let same_ty = blk.target_ty(db) == struct_ty;\n+        let not_trait_impl = blk.target_trait(db).is_none();\n+\n+        found_new_fn = has_new_fn(impl_blk);\n+\n+        same_ty && not_trait_impl\n+    });\n+\n+    if found_new_fn {\n+        None\n+    } else {\n+        Some(block)\n+    }\n+}\n+\n+fn has_new_fn(imp: &ast::ImplBlock) -> bool {\n+    if let Some(il) = imp.item_list() {\n+        for item in il.impl_items() {\n+            if let ast::ImplItem::FnDef(f) = item {\n+                if f.name().unwrap().text().eq_ignore_ascii_case(\"new\") {\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn test_add_new() {\n+        // Check output of generation\n+        check_assist(\n+            add_new,\n+\"struct Foo {<|>}\",\n+\"struct Foo {}\n+\n+impl Foo {\n+    fn new() -> Self { Self {  } }<|>\n+}\n+\",\n+        );\n+        check_assist(\n+            add_new,\n+\"struct Foo<T: Clone> {<|>}\",\n+\"struct Foo<T: Clone> {}\n+\n+impl<T: Clone> Foo<T> {\n+    fn new() -> Self { Self {  } }<|>\n+}\n+\",\n+        );\n+        check_assist(\n+            add_new,\n+\"struct Foo<'a, T: Foo<'a>> {<|>}\",\n+\"struct Foo<'a, T: Foo<'a>> {}\n+\n+impl<'a, T: Foo<'a>> Foo<'a, T> {\n+    fn new() -> Self { Self {  } }<|>\n+}\n+\",\n+        );\n+        check_assist(\n+            add_new,\n+\"struct Foo { baz: String <|>}\",\n+\"struct Foo { baz: String }\n+\n+impl Foo {\n+    fn new(baz: String) -> Self { Self { baz } }<|>\n+}\n+\",\n+        );\n+        check_assist(\n+            add_new,\n+\"struct Foo { baz: String, qux: Vec<i32> <|>}\",\n+\"struct Foo { baz: String, qux: Vec<i32> }\n+\n+impl Foo {\n+    fn new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }<|>\n+}\n+\",\n+        );\n+\n+        // Check that visibility modifiers don't get brought in for fields\n+        check_assist(\n+            add_new,\n+\"struct Foo { pub baz: String, pub qux: Vec<i32> <|>}\",\n+\"struct Foo { pub baz: String, pub qux: Vec<i32> }\n+\n+impl Foo {\n+    fn new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }<|>\n+}\n+\",\n+        );\n+\n+        // Check that it reuses existing impls\n+        check_assist(\n+            add_new,\n+\"struct Foo {<|>}\n+\n+impl Foo {}\n+\",\n+\"struct Foo {}\n+\n+impl Foo {\n+    fn new() -> Self { Self {  } }<|>\n+}\n+\",\n+        );\n+        check_assist(\n+            add_new,\n+\"struct Foo {<|>}\n+\n+impl Foo {\n+    fn qux(&self) {}\n+}\n+\",\n+\"struct Foo {}\n+\n+impl Foo {\n+    fn new() -> Self { Self {  } }<|>\n+\n+    fn qux(&self) {}\n+}\n+\",\n+        );\n+\n+        check_assist(\n+            add_new,\n+\"struct Foo {<|>}\n+\n+impl Foo {\n+    fn qux(&self) {}\n+    fn baz() -> i32 {\n+        5\n+    }\n+}\n+\",\n+\"struct Foo {}\n+\n+impl Foo {\n+    fn new() -> Self { Self {  } }<|>\n+\n+    fn qux(&self) {}\n+    fn baz() -> i32 {\n+        5\n+    }\n+}\n+\",\n+        );\n+\n+        // Check visibility of new fn based on struct\n+        check_assist(\n+            add_new,\n+\"pub struct Foo {<|>}\",\n+\"pub struct Foo {}\n+\n+impl Foo {\n+    pub fn new() -> Self { Self {  } }<|>\n+}\n+\",\n+        );\n+        check_assist(\n+            add_new,\n+\"pub(crate) struct Foo {<|>}\",\n+\"pub(crate) struct Foo {}\n+\n+impl Foo {\n+    pub(crate) fn new() -> Self { Self {  } }<|>\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn add_new_not_applicable_if_fn_exists() {\n+        check_assist_not_applicable(\n+            add_new,\n+            \"\n+struct Foo {<|>}\n+\n+impl Foo {\n+    fn new() -> Self {\n+        Self\n+    }    \n+}\",\n+        );\n+\n+        check_assist_not_applicable(\n+            add_new,\n+            \"\n+struct Foo {<|>}\n+\n+impl Foo {\n+    fn New() -> Self {\n+        Self\n+    }    \n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn add_new_target() {\n+        check_assist_target(\n+            add_new,\n+            \"\n+struct SomeThingIrrelevant;\n+/// Has a lifetime parameter\n+struct Foo<'a, T: Foo<'a>> {<|>}\n+struct EvenMoreIrrelevant;\n+\",\n+            \"/// Has a lifetime parameter\n+struct Foo<'a, T: Foo<'a>> {}\",\n+        );\n+    }\n+}"}, {"sha": "176761efb954401484207ef1754e08f89e71ae81", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6f94573d7f4601b739e001de5d5f71ec9b552/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6f94573d7f4601b739e001de5d5f71ec9b552/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=cbc6f94573d7f4601b739e001de5d5f71ec9b552", "patch": "@@ -156,6 +156,28 @@ fn process(map: HashMap<String, String>) {}\n     )\n }\n \n+#[test]\n+fn doctest_add_new() {\n+    check(\n+        \"add_new\",\n+        r#####\"\n+struct Ctx<T: Clone> {\n+     data: T,<|>\n+}\n+\"#####,\n+        r#####\"\n+struct Ctx<T: Clone> {\n+     data: T,\n+}\n+\n+impl<T: Clone> Ctx<T> {\n+    fn new(data: T) -> Self { Self { data } }\n+}\n+\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_apply_demorgan() {\n     check("}, {"sha": "f2f0dacbf7d997d27003b113eb75eada55931af9", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6f94573d7f4601b739e001de5d5f71ec9b552/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6f94573d7f4601b739e001de5d5f71ec9b552/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=cbc6f94573d7f4601b739e001de5d5f71ec9b552", "patch": "@@ -95,6 +95,7 @@ mod assists {\n     mod add_derive;\n     mod add_explicit_type;\n     mod add_impl;\n+    mod add_new;\n     mod apply_demorgan;\n     mod flip_comma;\n     mod flip_binexpr;\n@@ -119,6 +120,7 @@ mod assists {\n             add_derive::add_derive,\n             add_explicit_type::add_explicit_type,\n             add_impl::add_impl,\n+            add_new::add_new,\n             apply_demorgan::apply_demorgan,\n             change_visibility::change_visibility,\n             fill_match_arms::fill_match_arms,"}, {"sha": "8da7578e2f2b9712a1f6e5b683d48900f7469750", "filename": "docs/user/assists.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6f94573d7f4601b739e001de5d5f71ec9b552/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6f94573d7f4601b739e001de5d5f71ec9b552/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=cbc6f94573d7f4601b739e001de5d5f71ec9b552", "patch": "@@ -150,6 +150,27 @@ use std::collections::HashMap;\n fn process(map: HashMap<String, String>) {}\n ```\n \n+## `add_new`\n+\n+Adds a new inherent impl for a type.\n+\n+```rust\n+// BEFORE\n+struct Ctx<T: Clone> {\n+     data: T,\u2503\n+}\n+\n+// AFTER\n+struct Ctx<T: Clone> {\n+     data: T,\n+}\n+\n+impl<T: Clone> Ctx<T> {\n+    fn new(data: T) -> Self { Self { data } }\n+}\n+\n+```\n+\n ## `apply_demorgan`\n \n Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)."}]}