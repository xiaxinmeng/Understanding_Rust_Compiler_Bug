{"sha": "d0f993070929428f7a484cfce66d5690e709006d", "node_id": "C_kwDOAAsO6NoAKGQwZjk5MzA3MDkyOTQyOGY3YTQ4NGNmY2U2NmQ1NjkwZTcwOTAwNmQ", "commit": {"author": {"name": "Conrad Ludgate", "email": "conradludgate@gmail.com", "date": "2022-05-14T17:44:31Z"}, "committer": {"name": "Conrad Ludgate", "email": "conradludgate@gmail.com", "date": "2022-05-26T12:18:57Z"}, "message": "improve case conversion happy path", "tree": {"sha": "2b615a7c1c2998dedcfdf378130f1744fc561a91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b615a7c1c2998dedcfdf378130f1744fc561a91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0f993070929428f7a484cfce66d5690e709006d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f993070929428f7a484cfce66d5690e709006d", "html_url": "https://github.com/rust-lang/rust/commit/d0f993070929428f7a484cfce66d5690e709006d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0f993070929428f7a484cfce66d5690e709006d/comments", "author": {"login": "conradludgate", "id": 6625462, "node_id": "MDQ6VXNlcjY2MjU0NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6625462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/conradludgate", "html_url": "https://github.com/conradludgate", "followers_url": "https://api.github.com/users/conradludgate/followers", "following_url": "https://api.github.com/users/conradludgate/following{/other_user}", "gists_url": "https://api.github.com/users/conradludgate/gists{/gist_id}", "starred_url": "https://api.github.com/users/conradludgate/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/conradludgate/subscriptions", "organizations_url": "https://api.github.com/users/conradludgate/orgs", "repos_url": "https://api.github.com/users/conradludgate/repos", "events_url": "https://api.github.com/users/conradludgate/events{/privacy}", "received_events_url": "https://api.github.com/users/conradludgate/received_events", "type": "User", "site_admin": false}, "committer": {"login": "conradludgate", "id": 6625462, "node_id": "MDQ6VXNlcjY2MjU0NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/6625462?v=4", "gravatar_id": "", "url": "https://api.github.com/users/conradludgate", "html_url": "https://github.com/conradludgate", "followers_url": "https://api.github.com/users/conradludgate/followers", "following_url": "https://api.github.com/users/conradludgate/following{/other_user}", "gists_url": "https://api.github.com/users/conradludgate/gists{/gist_id}", "starred_url": "https://api.github.com/users/conradludgate/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/conradludgate/subscriptions", "organizations_url": "https://api.github.com/users/conradludgate/orgs", "repos_url": "https://api.github.com/users/conradludgate/repos", "events_url": "https://api.github.com/users/conradludgate/events{/privacy}", "received_events_url": "https://api.github.com/users/conradludgate/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "653463731a7f01f519cf85f444869def27f00395", "url": "https://api.github.com/repos/rust-lang/rust/commits/653463731a7f01f519cf85f444869def27f00395", "html_url": "https://github.com/rust-lang/rust/commit/653463731a7f01f519cf85f444869def27f00395"}], "stats": {"total": 88, "additions": 83, "deletions": 5}, "files": [{"sha": "39dfd98ddccfb8aef35fd13a1379d3dfaeaad797", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d0f993070929428f7a484cfce66d5690e709006d/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f993070929428f7a484cfce66d5690e709006d/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=d0f993070929428f7a484cfce66d5690e709006d", "patch": "@@ -383,15 +383,23 @@ impl str {\n                   without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_lowercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        for (i, c) in self[..].char_indices() {\n+        let out = convert_while_ascii(self.as_bytes(), u8::to_ascii_lowercase);\n+\n+        // Safety: we know this is a valid char boundary since\n+        // out.len() is only progressed if ascii bytes are found\n+        let rest = unsafe { self.get_unchecked(out.len()..) };\n+\n+        // Safety: We have written only valid ASCII to our vec\n+        let mut s = unsafe { String::from_utf8_unchecked(out) };\n+\n+        for (i, c) in rest[..].char_indices() {\n             if c == '\u03a3' {\n                 // \u03a3 maps to \u03c3, except at the end of a word where it maps to \u03c2.\n                 // This is the only conditional (contextual) but language-independent mapping\n                 // in `SpecialCasing.txt`,\n                 // so hard-code it rather than have a generic \"condition\" mechanism.\n                 // See https://github.com/rust-lang/rust/issues/26035\n-                map_uppercase_sigma(self, i, &mut s)\n+                map_uppercase_sigma(rest, i, &mut s)\n             } else {\n                 match conversions::to_lower(c) {\n                     [a, '\\0', _] => s.push(a),\n@@ -466,8 +474,16 @@ impl str {\n                   without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        for c in self[..].chars() {\n+        let out = convert_while_ascii(self.as_bytes(), u8::to_ascii_uppercase);\n+\n+        // Safety: we know this is a valid char boundary since\n+        // out.len() is only progressed if ascii bytes are found\n+        let rest = unsafe { self.get_unchecked(out.len()..) };\n+\n+        // Safety: We have written only valid ASCII to our vec\n+        let mut s = unsafe { String::from_utf8_unchecked(out) };\n+\n+        for c in rest.chars() {\n             match conversions::to_upper(c) {\n                 [a, '\\0', _] => s.push(a),\n                 [a, b, '\\0'] => {\n@@ -619,3 +635,51 @@ impl str {\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n     unsafe { Box::from_raw(Box::into_raw(v) as *mut str) }\n }\n+\n+/// Converts the bytes while the bytes are still ascii.\n+/// For better average performance, this is happens in chunks of `2*size_of::<usize>()`.\n+/// Returns a vec with the converted bytes.\n+#[inline]\n+#[cfg(not(test))]\n+#[cfg(not(no_global_oom_handling))]\n+fn convert_while_ascii(b: &[u8], convert: fn(&u8) -> u8) -> Vec<u8> {\n+    let mut out = Vec::with_capacity(b.len());\n+\n+    const USIZE_SIZE: usize = mem::size_of::<usize>();\n+    const MAGIC_UNROLL: usize = 2;\n+    const N: usize = USIZE_SIZE * MAGIC_UNROLL;\n+    const NONASCII_MASK: usize = usize::from_ne_bytes([0x80; USIZE_SIZE]);\n+\n+    let mut i = 0;\n+    unsafe {\n+        while i + N <= b.len() {\n+            // Safety: we have checks the sizes `b` and `out` to know that our\n+            let in_chunk = b.get_unchecked(i..i + N);\n+            let out_chunk = out.spare_capacity_mut().get_unchecked_mut(i..i + N);\n+\n+            let mut bits = 0;\n+            for j in 0..MAGIC_UNROLL {\n+                // read the bytes 1 usize at a time (unaligned since we haven't checked the alignment)\n+                // safety: in_chunk is valid bytes in the range\n+                bits |= in_chunk.as_ptr().cast::<usize>().add(j).read_unaligned();\n+            }\n+            // if our chunks aren't ascii, then return only the prior bytes as init\n+            if bits & NONASCII_MASK != 0 {\n+                break;\n+            }\n+\n+            // perform the case conversions on N bytes (gets heavily autovec'd)\n+            for j in 0..N {\n+                // safety: in_chunk and out_chunk is valid bytes in the range\n+                let out = out_chunk.get_unchecked_mut(j);\n+                out.write(convert(in_chunk.get_unchecked(j)));\n+            }\n+\n+            // mark these bytes as initialised\n+            i += N;\n+        }\n+        out.set_len(i);\n+    }\n+\n+    out\n+}"}, {"sha": "7379569dd68fe4a189f4218c860fab7d482f9164", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0f993070929428f7a484cfce66d5690e709006d/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0f993070929428f7a484cfce66d5690e709006d/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=d0f993070929428f7a484cfce66d5690e709006d", "patch": "@@ -1772,6 +1772,20 @@ fn to_lowercase() {\n     assert_eq!(\"\u0391\u03a3\u0391\".to_lowercase(), \"\u03b1\u03c3\u03b1\");\n     assert_eq!(\"\u0391\u03a3'\u0391\".to_lowercase(), \"\u03b1\u03c3'\u03b1\");\n     assert_eq!(\"\u0391\u03a3''\u0391\".to_lowercase(), \"\u03b1\u03c3''\u03b1\");\n+\n+    // a really long string that has it's lowercase form\n+    // even longer. this tests that implementations don't assume\n+    // an incorrect upper bound on allocations\n+    let upper = str::repeat(\"\u0130\", 512);\n+    let lower = str::repeat(\"i\u0307\", 512);\n+    assert_eq!(upper.to_lowercase(), lower);\n+\n+    // a really long ascii-only string.\n+    // This test that the ascii hot-path\n+    // functions correctly\n+    let upper = str::repeat(\"A\", 511);\n+    let lower = str::repeat(\"a\", 511);\n+    assert_eq!(upper.to_lowercase(), lower);\n }\n \n #[test]"}]}