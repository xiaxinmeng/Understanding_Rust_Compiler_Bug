{"sha": "10f4ce324baf7cfb7ce2b2096662b82b79204944", "node_id": "C_kwDOAAsO6NoAKDEwZjRjZTMyNGJhZjdjZmI3Y2UyYjIwOTY2NjJiODJiNzkyMDQ5NDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-22T10:48:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-22T10:48:58Z"}, "message": "Auto merge of #98279 - cjgillot:all-fresh-nofn, r=petrochenkov\n\nCreate elided lifetime parameters for function-like types\n\nSplit from https://github.com/rust-lang/rust/pull/97720\n\nThis PR refactor lifetime generic parameters in bare function types and parenthesized traits to introduce the additional required lifetimes as fresh parameters in a `for<>` bound.\n\nThis PR does the same to lifetimes appearing in closure signatures, and as-if introducing `for<>` bounds on closures (without the associated change in semantics).\n\nr? `@petrochenkov`", "tree": {"sha": "c1c264be332d6fabab112d732142d0593e54fd25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1c264be332d6fabab112d732142d0593e54fd25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10f4ce324baf7cfb7ce2b2096662b82b79204944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10f4ce324baf7cfb7ce2b2096662b82b79204944", "html_url": "https://github.com/rust-lang/rust/commit/10f4ce324baf7cfb7ce2b2096662b82b79204944", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10f4ce324baf7cfb7ce2b2096662b82b79204944/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89a0783f1c8fef46b1c8de57dc611a1d753bf0d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/89a0783f1c8fef46b1c8de57dc611a1d753bf0d5", "html_url": "https://github.com/rust-lang/rust/commit/89a0783f1c8fef46b1c8de57dc611a1d753bf0d5"}, {"sha": "576661cb5f4cdcf2ae56f5b210db4b2ef19e0184", "url": "https://api.github.com/repos/rust-lang/rust/commits/576661cb5f4cdcf2ae56f5b210db4b2ef19e0184", "html_url": "https://github.com/rust-lang/rust/commit/576661cb5f4cdcf2ae56f5b210db4b2ef19e0184"}], "stats": {"total": 1407, "additions": 808, "deletions": 599}, "files": [{"sha": "3babe73030a45efac44d1eab8f4c50e9e4fb7385", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -165,6 +165,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     if let Async::Yes { closure_id, .. } = asyncness {\n                         self.lower_expr_async_closure(\n                             capture_clause,\n+                            e.id,\n                             closure_id,\n                             decl,\n                             body,\n@@ -173,6 +174,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     } else {\n                         self.lower_expr_closure(\n                             capture_clause,\n+                            e.id,\n                             movability,\n                             decl,\n                             body,\n@@ -604,6 +606,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `static |_task_context| -> <ret_ty> { body }`:\n         let generator_kind = hir::ExprKind::Closure {\n             capture_clause,\n+            bound_generic_params: &[],\n             fn_decl,\n             body,\n             fn_decl_span: self.lower_span(span),\n@@ -828,6 +831,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_expr_closure(\n         &mut self,\n         capture_clause: CaptureBy,\n+        closure_id: NodeId,\n         movability: Movability,\n         decl: &FnDecl,\n         body: &Expr,\n@@ -848,16 +852,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (body_id, generator_option)\n         });\n \n-        // Lower outside new scope to preserve `is_in_loop_condition`.\n-        let fn_decl = self.lower_fn_decl(decl, None, FnDeclKind::Closure, None);\n-\n-        hir::ExprKind::Closure {\n-            capture_clause,\n-            fn_decl,\n-            body,\n-            fn_decl_span: self.lower_span(fn_decl_span),\n-            movability: generator_option,\n-        }\n+        self.with_lifetime_binder(closure_id, &[], |this, bound_generic_params| {\n+            // Lower outside new scope to preserve `is_in_loop_condition`.\n+            let fn_decl = this.lower_fn_decl(decl, None, FnDeclKind::Closure, None);\n+\n+            hir::ExprKind::Closure {\n+                capture_clause,\n+                bound_generic_params,\n+                fn_decl,\n+                body,\n+                fn_decl_span: this.lower_span(fn_decl_span),\n+                movability: generator_option,\n+            }\n+        })\n     }\n \n     fn generator_movability_for_fn(\n@@ -897,6 +904,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         capture_clause: CaptureBy,\n         closure_id: NodeId,\n+        inner_closure_id: NodeId,\n         decl: &FnDecl,\n         body: &Expr,\n         fn_decl_span: Span,\n@@ -927,7 +935,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     if let FnRetTy::Ty(ty) = &decl.output { Some(ty.clone()) } else { None };\n                 let async_body = this.make_async_expr(\n                     capture_clause,\n-                    closure_id,\n+                    inner_closure_id,\n                     async_ret_ty,\n                     body.span,\n                     hir::AsyncGeneratorKind::Closure,\n@@ -938,18 +946,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             body_id\n         });\n \n-        // We need to lower the declaration outside the new scope, because we\n-        // have to conserve the state of being inside a loop condition for the\n-        // closure argument types.\n-        let fn_decl = self.lower_fn_decl(&outer_decl, None, FnDeclKind::Closure, None);\n-\n-        hir::ExprKind::Closure {\n-            capture_clause,\n-            fn_decl,\n-            body,\n-            fn_decl_span: self.lower_span(fn_decl_span),\n-            movability: None,\n-        }\n+        self.with_lifetime_binder(closure_id, &[], |this, bound_generic_params| {\n+            // We need to lower the declaration outside the new scope, because we\n+            // have to conserve the state of being inside a loop condition for the\n+            // closure argument types.\n+            let fn_decl = this.lower_fn_decl(&outer_decl, None, FnDeclKind::Closure, None);\n+\n+            hir::ExprKind::Closure {\n+                capture_clause,\n+                bound_generic_params,\n+                fn_decl,\n+                body,\n+                fn_decl_span: this.lower_span(fn_decl_span),\n+                movability: None,\n+            }\n+        })\n     }\n \n     /// Destructure the LHS of complex assignments."}, {"sha": "0ef213716945c88fee80e0c041b83b574a3368f0", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -1386,16 +1386,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> =\n             self.lower_generic_params_mut(&generics.params).collect();\n+\n+        // Introduce extra lifetimes if late resolution tells us to.\n+        let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n+        params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n+            self.lifetime_res_to_generic_param(ident, node_id, res)\n+        }));\n+\n         let has_where_clause_predicates = !generics.where_clause.predicates.is_empty();\n         let where_clause_span = self.lower_span(generics.where_clause.span);\n         let span = self.lower_span(generics.span);\n         let res = f(self);\n \n-        let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n         let impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n-        params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n-            self.lifetime_res_to_generic_param(ident, node_id, res)\n-        }));\n         params.extend(impl_trait_defs.into_iter());\n \n         let impl_trait_bounds = std::mem::take(&mut self.impl_trait_bounds);"}, {"sha": "e8b92eaad5c8dbfba258398f6f3fbcab75453d0f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -223,6 +223,12 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n     }\n \n     /// Obtain the list of lifetimes parameters to add to an item.\n+    ///\n+    /// Extra lifetime parameters should only be added in places that can appear\n+    /// as a `binder` in `LifetimeRes`.\n+    ///\n+    /// The extra lifetimes that appear from the parenthesized `Fn`-trait desugaring\n+    /// should appear at the enclosing `PolyTraitRef`.\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)> {\n         self.extra_lifetime_params_map.remove(&id).unwrap_or_default()\n     }\n@@ -721,6 +727,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Converts a lifetime into a new generic parameter.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn lifetime_res_to_generic_param(\n         &mut self,\n         ident: Ident,\n@@ -731,7 +738,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Param { .. } => {\n                 (hir::ParamName::Plain(ident), hir::LifetimeParamKind::Explicit)\n             }\n-            LifetimeRes::Fresh { .. } => (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided),\n+            LifetimeRes::Fresh { param, .. } => {\n+                // Late resolution delegates to us the creation of the `LocalDefId`.\n+                let _def_id = self.create_def(\n+                    self.current_hir_id_owner,\n+                    param,\n+                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                );\n+                debug!(?_def_id);\n+\n+                (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided)\n+            }\n             LifetimeRes::Static | LifetimeRes::Error => return None,\n             res => panic!(\n                 \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n@@ -777,11 +794,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Register a binder to be ignored for lifetime capture.\n     #[tracing::instrument(level = \"debug\", skip(self, f))]\n     #[inline]\n-    fn with_lifetime_binder<T>(&mut self, binder: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n+    fn with_lifetime_binder<T>(\n+        &mut self,\n+        binder: NodeId,\n+        generic_params: &[GenericParam],\n+        f: impl FnOnce(&mut Self, &'hir [hir::GenericParam<'hir>]) -> T,\n+    ) -> T {\n+        let mut generic_params: Vec<_> = self.lower_generic_params_mut(generic_params).collect();\n+        let extra_lifetimes = self.resolver.take_extra_lifetime_params(binder);\n+        debug!(?extra_lifetimes);\n+        generic_params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n+            self.lifetime_res_to_generic_param(ident, node_id, res)\n+        }));\n+        let generic_params = self.arena.alloc_from_iter(generic_params);\n+        debug!(?generic_params);\n+\n         if let Some(ctxt) = &mut self.captured_lifetimes {\n             ctxt.binders_to_ignore.insert(binder);\n         }\n-        let ret = f(self);\n+        let ret = f(self, generic_params);\n         if let Some(ctxt) = &mut self.captured_lifetimes {\n             ctxt.binders_to_ignore.remove(&binder);\n         }\n@@ -1178,15 +1209,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let lifetime = self.lower_lifetime(&region);\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n-            TyKind::BareFn(ref f) => self.with_lifetime_binder(t.id, |this| {\n-                hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n-                    generic_params: this.lower_generic_params(&f.generic_params),\n-                    unsafety: this.lower_unsafety(f.unsafety),\n-                    abi: this.lower_extern(f.ext),\n-                    decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n-                    param_names: this.lower_fn_params_to_names(&f.decl),\n-                }))\n-            }),\n+            TyKind::BareFn(ref f) => {\n+                self.with_lifetime_binder(t.id, &f.generic_params, |this, generic_params| {\n+                    hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n+                        generic_params,\n+                        unsafety: this.lower_unsafety(f.unsafety),\n+                        abi: this.lower_extern(f.ext),\n+                        decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n+                        param_names: this.lower_fn_params_to_names(&f.decl),\n+                    }))\n+                })\n+            }\n             TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => hir::TyKind::Tup(\n                 self.arena.alloc_from_iter(tys.iter().map(|ty| self.lower_ty_direct(ty, itctx))),\n@@ -1814,8 +1847,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 hir::LifetimeName::Param(param, p_name)\n             }\n-            LifetimeRes::Fresh { mut param, binder } => {\n+            LifetimeRes::Fresh { param, binder } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n+                let mut param = self.local_def_id(param);\n                 if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n                     if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n                         match captured_lifetimes.captures.entry(param) {\n@@ -1952,13 +1986,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         itctx: ImplTraitContext,\n     ) -> hir::PolyTraitRef<'hir> {\n-        let bound_generic_params = self.lower_generic_params(&p.bound_generic_params);\n-\n-        let trait_ref = self.with_lifetime_binder(p.trait_ref.ref_id, |this| {\n-            this.lower_trait_ref(&p.trait_ref, itctx)\n-        });\n-\n-        hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }\n+        self.with_lifetime_binder(\n+            p.trait_ref.ref_id,\n+            &p.bound_generic_params,\n+            |this, bound_generic_params| {\n+                let trait_ref = this.lower_trait_ref(&p.trait_ref, itctx);\n+                hir::PolyTraitRef { bound_generic_params, trait_ref, span: this.lower_span(p.span) }\n+            },\n+        )\n     }\n \n     fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext) -> hir::MutTy<'hir> {"}, {"sha": "52ba5daf01410046555852aa3eb8ce2f5327c1d7", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -191,9 +191,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => {\n-                        self.lower_parenthesized_parameter_data(segment.id, data)\n-                    }\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Err => {\n                         let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n                         err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n@@ -351,39 +349,34 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_parenthesized_parameter_data(\n         &mut self,\n-        id: NodeId,\n         data: &ParenthesizedArgs,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n         // compatibility, even in contexts like an impl header where\n         // we generally don't permit such things (see #51008).\n-        self.with_lifetime_binder(id, |this| {\n-            let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n-            let inputs = this.arena.alloc_from_iter(inputs.iter().map(|ty| {\n-                this.lower_ty_direct(\n-                    ty,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam),\n-                )\n-            }));\n-            let output_ty = match output {\n-                FnRetTy::Ty(ty) => this\n-                    .lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn)),\n-                FnRetTy::Default(_) => this.arena.alloc(this.ty_tup(*span, &[])),\n-            };\n-            let args = smallvec![GenericArg::Type(this.ty_tup(*inputs_span, inputs))];\n-            let binding = this.output_ty_binding(output_ty.span, output_ty);\n-            (\n-                GenericArgsCtor {\n-                    args,\n-                    bindings: arena_vec![this; binding],\n-                    parenthesized: true,\n-                    span: data.inputs_span,\n-                },\n-                false,\n-            )\n-        })\n+        let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n+        let inputs = self.arena.alloc_from_iter(inputs.iter().map(|ty| {\n+            self.lower_ty_direct(ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n+        }));\n+        let output_ty = match output {\n+            FnRetTy::Ty(ty) => {\n+                self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n+            }\n+            FnRetTy::Default(_) => self.arena.alloc(self.ty_tup(*span, &[])),\n+        };\n+        let args = smallvec![GenericArg::Type(self.ty_tup(*inputs_span, inputs))];\n+        let binding = self.output_ty_binding(output_ty.span, output_ty);\n+        (\n+            GenericArgsCtor {\n+                args,\n+                bindings: arena_vec![self; binding],\n+                parenthesized: true,\n+                span: data.inputs_span,\n+            },\n+            false,\n+        )\n     }\n \n     /// An associated type binding `Output = $ty`."}, {"sha": "1db4b902f7150b9a4cfcdfd48002d52b16c9a12c", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -254,6 +254,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// *user* has a name for. In that case, we'll be able to map\n     /// `fr` to a `Region<'tcx>`, and that region will be one of\n     /// named variants.\n+    #[tracing::instrument(level = \"trace\", skip(self))]\n     fn give_name_from_error_region(&self, fr: RegionVid) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n@@ -290,7 +291,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     if free_region.bound_region.is_named() {\n                         // A named region that is actually named.\n                         Some(RegionName { name, source: RegionNameSource::NamedFreeRegion(span) })\n-                    } else {\n+                    } else if let hir::IsAsync::Async = tcx.asyncness(self.mir_hir_id().owner) {\n                         // If we spuriously thought that the region is named, we should let the\n                         // system generate a true name for error messages. Currently this can\n                         // happen if we have an elided name in an async fn for example: the\n@@ -301,6 +302,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                             name,\n                             source: RegionNameSource::AnonRegionFromAsyncFn(span),\n                         })\n+                    } else {\n+                        None\n                     }\n                 }\n \n@@ -362,6 +365,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  | fn foo(x: &u32) { .. }\n     ///           ------- fully elaborated type of `x` is `&'1 u32`\n     /// ```\n+    #[tracing::instrument(level = \"trace\", skip(self))]\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n         fr: RegionVid,\n@@ -651,6 +655,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  | let x = Some(&22);\n     ///        - fully elaborated type of `x` is `Option<&'1 u32>`\n     /// ```\n+    #[tracing::instrument(level = \"trace\", skip(self))]\n     fn give_name_if_anonymous_region_appears_in_upvars(&self, fr: RegionVid) -> Option<RegionName> {\n         let upvar_index = self.regioncx.get_upvar_index_for_region(self.infcx.tcx, fr)?;\n         let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n@@ -670,6 +675,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// must be a closure since, in a free fn, such an argument would\n     /// have to either also appear in an argument (if using elision)\n     /// or be early bound (named, not in argument).\n+    #[tracing::instrument(level = \"trace\", skip(self))]\n     fn give_name_if_anonymous_region_appears_in_output(&self, fr: RegionVid) -> Option<RegionName> {\n         let tcx = self.infcx.tcx;\n         let hir = tcx.hir();\n@@ -801,6 +807,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         }\n     }\n \n+    #[tracing::instrument(level = \"trace\", skip(self))]\n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n         fr: RegionVid,"}, {"sha": "d0893cd09d8db845df30bdfd3537dc3f84104e09", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -722,8 +722,7 @@ pub enum LifetimeRes {\n         /// Id of the introducing place. That can be:\n         /// - an item's id, for the item's generic parameters;\n         /// - a TraitRef's ref_id, identifying the `for<...>` binder;\n-        /// - a BareFn type's id;\n-        /// - a Path's id when this path has parenthesized generic args.\n+        /// - a BareFn type's id.\n         ///\n         /// This information is used for impl-trait lifetime captures, to know when to or not to\n         /// capture any given lifetime.\n@@ -732,7 +731,9 @@ pub enum LifetimeRes {\n     /// Created a generic parameter for an anonymous lifetime.\n     Fresh {\n         /// Id of the generic parameter that introduced it.\n-        param: LocalDefId,\n+        ///\n+        /// Creating the associated `LocalDefId` is the responsibility of lowering.\n+        param: NodeId,\n         /// Id of the introducing place. See `Param`.\n         binder: NodeId,\n     },"}, {"sha": "a7fc59255d79a3dd73d40a7052a37d4172b48ec3", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -1932,6 +1932,7 @@ pub enum ExprKind<'hir> {\n     /// `Option<Movability>`.\n     Closure {\n         capture_clause: CaptureBy,\n+        bound_generic_params: &'hir [GenericParam<'hir>],\n         fn_decl: &'hir FnDecl<'hir>,\n         body: BodyId,\n         fn_decl_span: Span,\n@@ -3480,7 +3481,7 @@ impl<'hir> Node<'hir> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::Block<'static>, 48);\n-    rustc_data_structures::static_assert_size!(super::Expr<'static>, 56);\n+    rustc_data_structures::static_assert_size!(super::Expr<'static>, 64);\n     rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n     rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);"}, {"sha": "e68274e2ad9788d0f46906c9848ac2f1a98b6b89", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -1169,12 +1169,16 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprKind::Closure {\n+            bound_generic_params,\n             ref fn_decl,\n             body,\n             capture_clause: _,\n             fn_decl_span: _,\n             movability: _,\n-        } => visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id),\n+        } => {\n+            walk_list!(visitor, visit_generic_param, bound_generic_params);\n+            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n+        }\n         ExprKind::Block(ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);"}, {"sha": "7bf91df9f760b6fbac5e409564847039712128c2", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -1459,11 +1459,13 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::Closure {\n                 capture_clause,\n+                bound_generic_params,\n                 ref fn_decl,\n                 body,\n                 fn_decl_span: _,\n                 movability: _,\n             } => {\n+                self.print_formal_generic_params(bound_generic_params);\n                 self.print_capture_clause(capture_clause);\n \n                 self.print_closure_params(&fn_decl, body);"}, {"sha": "e36f55b2e0237d5d53d2cb768cfa2b891a0c10b7", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 504, "deletions": 373, "changes": 877, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -20,9 +20,7 @@ use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::definitions::DefPathData;\n use rustc_hir::{PrimTy, TraitCandidate};\n-use rustc_index::vec::Idx;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n@@ -238,14 +236,21 @@ enum LifetimeRibKind {\n     /// `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n     AnonConst,\n \n-    /// For **Modern** cases, create a new anonymous region parameter\n-    /// and reference that.\n+    /// Create a new anonymous lifetime parameter and reference it.\n     ///\n-    /// For **Dyn Bound** cases, pass responsibility to\n-    /// `resolve_lifetime` code.\n+    /// If `report_in_path`, report an error when encountering lifetime elision in a path:\n+    /// ```compile_fail\n+    /// struct Foo<'a> { x: &'a () }\n+    /// async fn foo(x: Foo) {}\n+    /// ```\n     ///\n-    /// For **Deprecated** cases, report an error.\n-    AnonymousCreateParameter(NodeId),\n+    /// Note: the error should not trigger when the elided lifetime is in a pattern or\n+    /// expression-position path:\n+    /// ```\n+    /// struct Foo<'a> { x: &'a () }\n+    /// async fn foo(Foo { x: _ }: Foo<'_>) {}\n+    /// ```\n+    AnonymousCreateParameter { binder: NodeId, report_in_path: bool },\n \n     /// Give a hard error when either `&` or `'_` is written. Used to\n     /// rule out things like `where T: Foo<'_>`. Does not imply an\n@@ -635,7 +640,10 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     |this| {\n                         this.visit_generic_params(&bare_fn.generic_params, false);\n                         this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(ty.id, false),\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: ty.id,\n+                                report_in_path: false,\n+                            },\n                             |this| walk_list!(this, visit_param, &bare_fn.decl.inputs),\n                         );\n                         this.with_lifetime_rib(\n@@ -721,15 +729,13 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             // a body, or if there's no body for some other reason.\n             FnKind::Fn(FnCtxt::Foreign, _, sig, _, generics, _)\n             | FnKind::Fn(_, _, sig, _, generics, None) => {\n+                self.visit_fn_header(&sig.header);\n+                self.visit_generics(generics);\n                 // We don't need to deal with patterns in parameters, because\n                 // they are not possible for foreign or bodiless functions.\n                 self.with_lifetime_rib(\n                     LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n-                    |this| {\n-                        this.visit_fn_header(&sig.header);\n-                        this.visit_generics(generics);\n-                        walk_list!(this, visit_param, &sig.decl.inputs);\n-                    },\n+                    |this| walk_list!(this, visit_param, &sig.decl.inputs),\n                 );\n                 self.with_lifetime_rib(\n                     LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n@@ -746,86 +752,127 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             self.diagnostic_metadata.current_function = Some((fn_kind, sp));\n         }\n         debug!(\"(resolving function) entering function\");\n-        let declaration = fn_kind.decl();\n \n         // Create a value rib for the function.\n         self.with_rib(ValueNS, rib_kind, |this| {\n             // Create a label rib for the function.\n             this.with_label_rib(FnItemRibKind, |this| {\n-                let async_node_id = fn_kind.header().and_then(|h| h.asyncness.opt_return_id());\n-\n-                if let FnKind::Fn(_, _, _, _, generics, _) = fn_kind {\n-                    this.visit_generics(generics);\n-                }\n+                match fn_kind {\n+                    FnKind::Fn(_, _, sig, _, generics, body) => {\n+                        this.visit_generics(generics);\n \n-                if let Some(async_node_id) = async_node_id {\n-                    // In `async fn`, argument-position elided lifetimes\n-                    // must be transformed into fresh generic parameters so that\n-                    // they can be applied to the opaque `impl Trait` return type.\n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousCreateParameter(fn_id),\n-                        |this| {\n+                        let declaration = &sig.decl;\n+                        let async_node_id = sig.header.asyncness.opt_return_id();\n+\n+                        // Argument-position elided lifetimes must be transformed into fresh\n+                        // generic parameters.  This is especially useful for `async fn`, where\n+                        // these fresh generic parameters can be applied to the opaque `impl Trait`\n+                        // return type.\n+                        let rib = if async_node_id.is_some() {\n+                            // Only emit a hard error for `async fn`, since this kind of\n+                            // elision has always been allowed in regular `fn`s.\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: fn_id,\n+                                report_in_path: true,\n+                            }\n+                        } else {\n+                            LifetimeRibKind::AnonymousPassThrough(fn_id, false)\n+                        };\n+                        this.with_lifetime_rib(\n+                            rib,\n                             // Add each argument to the rib.\n-                            this.resolve_params(&declaration.inputs)\n-                        },\n-                    );\n-\n-                    // Construct the list of in-scope lifetime parameters for async lowering.\n-                    // We include all lifetime parameters, either named or \"Fresh\".\n-                    // The order of those parameters does not matter, as long as it is\n-                    // deterministic.\n-                    let mut extra_lifetime_params =\n-                        this.r.extra_lifetime_params_map.get(&fn_id).cloned().unwrap_or_default();\n-                    for rib in this.lifetime_ribs.iter().rev() {\n-                        extra_lifetime_params.extend(\n-                            rib.bindings\n-                                .iter()\n-                                .map(|(&ident, &(node_id, res))| (ident, node_id, res)),\n+                            |this| this.resolve_params(&declaration.inputs),\n                         );\n-                        match rib.kind {\n-                            LifetimeRibKind::Item => break,\n-                            LifetimeRibKind::AnonymousCreateParameter(id) => {\n-                                if let Some(earlier_fresh) =\n-                                    this.r.extra_lifetime_params_map.get(&id)\n-                                {\n-                                    extra_lifetime_params.extend(earlier_fresh);\n+\n+                        // Construct the list of in-scope lifetime parameters for async lowering.\n+                        // We include all lifetime parameters, either named or \"Fresh\".\n+                        // The order of those parameters does not matter, as long as it is\n+                        // deterministic.\n+                        if let Some(async_node_id) = async_node_id {\n+                            let mut extra_lifetime_params = this\n+                                .r\n+                                .extra_lifetime_params_map\n+                                .get(&fn_id)\n+                                .cloned()\n+                                .unwrap_or_default();\n+                            for rib in this.lifetime_ribs.iter().rev() {\n+                                extra_lifetime_params.extend(\n+                                    rib.bindings\n+                                        .iter()\n+                                        .map(|(&ident, &(node_id, res))| (ident, node_id, res)),\n+                                );\n+                                match rib.kind {\n+                                    LifetimeRibKind::Item => break,\n+                                    LifetimeRibKind::AnonymousCreateParameter {\n+                                        binder, ..\n+                                    } => {\n+                                        if let Some(earlier_fresh) =\n+                                            this.r.extra_lifetime_params_map.get(&binder)\n+                                        {\n+                                            extra_lifetime_params.extend(earlier_fresh);\n+                                        }\n+                                    }\n+                                    _ => {}\n                                 }\n                             }\n-                            _ => {}\n+                            this.r\n+                                .extra_lifetime_params_map\n+                                .insert(async_node_id, extra_lifetime_params);\n                         }\n-                    }\n-                    this.r.extra_lifetime_params_map.insert(async_node_id, extra_lifetime_params);\n \n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(async_node_id, true),\n-                        |this| visit::walk_fn_ret_ty(this, &declaration.output),\n-                    );\n-                } else {\n-                    // Add each argument to the rib.\n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n-                        |this| this.resolve_params(&declaration.inputs),\n-                    );\n-                    this.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n-                        |this| visit::walk_fn_ret_ty(this, &declaration.output),\n-                    );\n-                };\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(\n+                                // For async fn, the return type appears inside a custom\n+                                // `impl Future` RPIT, so we override the binder's id.\n+                                async_node_id.unwrap_or(fn_id),\n+                                true,\n+                            ),\n+                            |this| visit::walk_fn_ret_ty(this, &declaration.output),\n+                        );\n \n-                // Ignore errors in function bodies if this is rustdoc\n-                // Be sure not to set this until the function signature has been resolved.\n-                let previous_state = replace(&mut this.in_func_body, true);\n-                // Resolve the function body, potentially inside the body of an async closure\n-                this.with_lifetime_rib(\n-                    LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n-                    |this| match fn_kind {\n-                        FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n-                        FnKind::Closure(_, body) => this.visit_expr(body),\n-                    },\n-                );\n+                        if let Some(body) = body {\n+                            // Ignore errors in function bodies if this is rustdoc\n+                            // Be sure not to set this until the function signature has been resolved.\n+                            let previous_state = replace(&mut this.in_func_body, true);\n+                            // Resolve the function body, potentially inside the body of an async closure\n+                            this.with_lifetime_rib(\n+                                LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                                |this| this.visit_block(body),\n+                            );\n+\n+                            debug!(\"(resolving function) leaving function\");\n+                            this.in_func_body = previous_state;\n+                        }\n+                    }\n+                    FnKind::Closure(declaration, body) => {\n+                        // We do not have any explicit generic lifetime parameter.\n+                        // FIXME(rfc3216): Change when implementing `for<>` bounds on closures.\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: fn_id,\n+                                report_in_path: false,\n+                            },\n+                            // Add each argument to the rib.\n+                            |this| this.resolve_params(&declaration.inputs),\n+                        );\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n+                            |this| visit::walk_fn_ret_ty(this, &declaration.output),\n+                        );\n+\n+                        // Ignore errors in function bodies if this is rustdoc\n+                        // Be sure not to set this until the function signature has been resolved.\n+                        let previous_state = replace(&mut this.in_func_body, true);\n+                        // Resolve the function body, potentially inside the body of an async closure\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n+                            |this| this.visit_expr(body),\n+                        );\n \n-                debug!(\"(resolving function) leaving function\");\n-                this.in_func_body = previous_state;\n+                        debug!(\"(resolving function) leaving function\");\n+                        this.in_func_body = previous_state;\n+                    }\n+                }\n             })\n         });\n         self.diagnostic_metadata.current_function = previous_value;\n@@ -902,19 +949,66 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n \n+    fn visit_assoc_constraint(&mut self, constraint: &'ast AssocConstraint) {\n+        self.visit_ident(constraint.ident);\n+        if let Some(ref gen_args) = constraint.gen_args {\n+            // Forbid anonymous lifetimes in GAT parameters until proper semantics are decided.\n+            self.with_lifetime_rib(LifetimeRibKind::AnonymousReportError, |this| {\n+                this.visit_generic_args(gen_args.span(), gen_args)\n+            });\n+        }\n+        match constraint.kind {\n+            AssocConstraintKind::Equality { ref term } => match term {\n+                Term::Ty(ty) => self.visit_ty(ty),\n+                Term::Const(c) => self.visit_anon_const(c),\n+            },\n+            AssocConstraintKind::Bound { ref bounds } => {\n+                walk_list!(self, visit_param_bound, bounds, BoundKind::Bound);\n+            }\n+        }\n+    }\n+\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n         if let Some(ref args) = path_segment.args {\n             match &**args {\n                 GenericArgs::AngleBracketed(..) => visit::walk_generic_args(self, path_span, args),\n-                GenericArgs::Parenthesized(ref data) => {\n-                    self.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(path_segment.id, false),\n-                        |this| walk_list!(this, visit_ty, &data.inputs),\n-                    );\n-                    self.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(path_segment.id, true),\n-                        |this| visit::walk_fn_ret_ty(this, &data.output),\n-                    )\n+                GenericArgs::Parenthesized(p_args) => {\n+                    // Probe the lifetime ribs to know how to behave.\n+                    for rib in self.lifetime_ribs.iter().rev() {\n+                        match rib.kind {\n+                            // We are inside a `PolyTraitRef`.  The lifetimes are\n+                            // to be intoduced in that (maybe implicit) `for<>` binder.\n+                            LifetimeRibKind::Generics {\n+                                binder,\n+                                kind: LifetimeBinderKind::PolyTrait,\n+                                ..\n+                            } => {\n+                                self.with_lifetime_rib(\n+                                    LifetimeRibKind::AnonymousCreateParameter {\n+                                        binder,\n+                                        report_in_path: false,\n+                                    },\n+                                    |this| walk_list!(this, visit_ty, &p_args.inputs),\n+                                );\n+                                self.with_lifetime_rib(\n+                                    LifetimeRibKind::AnonymousPassThrough(binder, true),\n+                                    |this| visit::walk_fn_ret_ty(this, &p_args.output),\n+                                );\n+                                break;\n+                            }\n+                            // We have nowhere to introduce generics.  Code is malformed,\n+                            // so use regular lifetime resolution to avoid spurious errors.\n+                            LifetimeRibKind::Item | LifetimeRibKind::Generics { .. } => {\n+                                visit::walk_generic_args(self, path_span, args);\n+                                break;\n+                            }\n+                            LifetimeRibKind::AnonymousPassThrough(..)\n+                            | LifetimeRibKind::AnonymousCreateParameter { .. }\n+                            | LifetimeRibKind::AnonymousReportError\n+                            | LifetimeRibKind::AnonConst\n+                            | LifetimeRibKind::ConstGeneric => {}\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -1243,13 +1337,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         for i in &mut indices {\n             let rib = &self.lifetime_ribs[i];\n             let normalized_ident = ident.normalize_to_macros_2_0();\n-            if let Some(&(_, region)) = rib.bindings.get(&normalized_ident) {\n-                self.record_lifetime_res(lifetime.id, region);\n+            if let Some(&(_, res)) = rib.bindings.get(&normalized_ident) {\n+                self.record_lifetime_res(lifetime.id, res);\n \n-                if let LifetimeRes::Param { param, .. } = region {\n+                if let LifetimeRes::Param { param, .. } = res {\n                     match self.lifetime_uses.entry(param) {\n                         Entry::Vacant(v) => {\n-                            debug!(\"First use of {:?} at {:?}\", region, ident.span);\n+                            debug!(\"First use of {:?} at {:?}\", res, ident.span);\n                             let use_set = self\n                                 .lifetime_ribs\n                                 .iter()\n@@ -1264,17 +1358,19 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                     }\n                                     // An anonymous lifetime is legal here, go ahead.\n                                     LifetimeRibKind::AnonymousPassThrough(_, false)\n-                                    | LifetimeRibKind::AnonymousCreateParameter(_) => {\n+                                    | LifetimeRibKind::AnonymousCreateParameter { .. } => {\n                                         Some(LifetimeUseSet::One { use_span: ident.span, use_ctxt })\n                                     }\n-                                    _ => None,\n+                                    LifetimeRibKind::Generics { .. }\n+                                    | LifetimeRibKind::ConstGeneric\n+                                    | LifetimeRibKind::AnonConst => None,\n                                 })\n                                 .unwrap_or(LifetimeUseSet::Many);\n                             debug!(?use_ctxt, ?use_set);\n                             v.insert(use_set);\n                         }\n                         Entry::Occupied(mut o) => {\n-                            debug!(\"Many uses of {:?} at {:?}\", region, ident.span);\n+                            debug!(\"Many uses of {:?} at {:?}\", res, ident.span);\n                             *o.get_mut() = LifetimeUseSet::Many;\n                         }\n                     }\n@@ -1319,8 +1415,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         for i in (0..self.lifetime_ribs.len()).rev() {\n             let rib = &mut self.lifetime_ribs[i];\n             match rib.kind {\n-                LifetimeRibKind::AnonymousCreateParameter(item_node_id) => {\n-                    self.create_fresh_lifetime(lifetime.id, lifetime.ident, item_node_id);\n+                LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n+                    let res = self.create_fresh_lifetime(lifetime.id, lifetime.ident, binder);\n+                    self.record_lifetime_res(lifetime.id, res);\n                     return;\n                 }\n                 LifetimeRibKind::AnonymousReportError => {\n@@ -1353,7 +1450,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     return;\n                 }\n                 LifetimeRibKind::Item => break,\n-                _ => {}\n+                LifetimeRibKind::Generics { .. }\n+                | LifetimeRibKind::ConstGeneric\n+                | LifetimeRibKind::AnonConst => {}\n             }\n         }\n         // This resolution is wrong, it passes the work to HIR lifetime resolution.\n@@ -1377,27 +1476,21 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    fn create_fresh_lifetime(&mut self, id: NodeId, ident: Ident, item_node_id: NodeId) {\n+    fn create_fresh_lifetime(&mut self, id: NodeId, ident: Ident, binder: NodeId) -> LifetimeRes {\n         debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n         debug!(?ident.span);\n-        let item_def_id = self.r.local_def_id(item_node_id);\n-        let def_node_id = self.r.next_node_id();\n-        let def_id = self.r.create_def(\n-            item_def_id,\n-            def_node_id,\n-            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-            self.parent_scope.expansion.to_expn_id(),\n-            ident.span,\n-        );\n-        debug!(?def_id);\n \n-        let region = LifetimeRes::Fresh { param: def_id, binder: item_node_id };\n-        self.record_lifetime_res(id, region);\n-        self.r.extra_lifetime_params_map.entry(item_node_id).or_insert_with(Vec::new).push((\n-            ident,\n-            def_node_id,\n-            region,\n-        ));\n+        // Leave the responsibility to create the `LocalDefId` to lowering.\n+        let param = self.r.next_node_id();\n+        let res = LifetimeRes::Fresh { param, binder };\n+\n+        // Record the created lifetime parameter so lowering can pick it up and add it to HIR.\n+        self.r\n+            .extra_lifetime_params_map\n+            .entry(binder)\n+            .or_insert_with(Vec::new)\n+            .push((ident, param, res));\n+        res\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -1447,7 +1540,60 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 | PathSource::Struct\n                 | PathSource::TupleStruct(..) => false,\n             };\n-            let mut res = LifetimeRes::Error;\n+\n+            let elided_lifetime_span = if segment.has_generic_args {\n+                // If there are brackets, but not generic arguments, then use the opening bracket\n+                segment.args_span.with_hi(segment.args_span.lo() + BytePos(1))\n+            } else {\n+                // If there are no brackets, use the identifier span.\n+                // HACK: we use find_ancestor_inside to properly suggest elided spans in paths\n+                // originating from macros, since the segment's span might be from a macro arg.\n+                segment.ident.span.find_ancestor_inside(path_span).unwrap_or(path_span)\n+            };\n+            let ident = Ident::new(kw::UnderscoreLifetime, elided_lifetime_span);\n+\n+            let node_ids = self.r.next_node_ids(expected_lifetimes);\n+            self.record_lifetime_res(\n+                segment_id,\n+                LifetimeRes::ElidedAnchor { start: node_ids.start, end: node_ids.end },\n+            );\n+\n+            if !missing {\n+                // Do not create a parameter for patterns and expressions.\n+                for rib in self.lifetime_ribs.iter().rev() {\n+                    match rib.kind {\n+                        LifetimeRibKind::AnonymousPassThrough(binder, _) => {\n+                            let res = LifetimeRes::Anonymous { binder, elided: true };\n+                            for id in node_ids {\n+                                self.record_lifetime_res(id, res);\n+                            }\n+                            break;\n+                        }\n+                        // `LifetimeRes::Error`, which would usually be used in the case of\n+                        // `ReportError`, is unsuitable here, as we don't emit an error yet.  Instead,\n+                        // we simply resolve to an implicit lifetime, which will be checked later, at\n+                        // which point a suitable error will be emitted.\n+                        LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n+                            // FIXME(cjgillot) This resolution is wrong, but this does not matter\n+                            // since these cases are erroneous anyway.  Lifetime resolution should\n+                            // emit a \"missing lifetime specifier\" diagnostic.\n+                            let res =\n+                                LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n+                            for id in node_ids {\n+                                self.record_lifetime_res(id, res);\n+                            }\n+                            break;\n+                        }\n+                        LifetimeRibKind::AnonymousCreateParameter { .. }\n+                        | LifetimeRibKind::Generics { .. }\n+                        | LifetimeRibKind::ConstGeneric\n+                        | LifetimeRibKind::AnonConst => {}\n+                    }\n+                }\n+                continue;\n+            }\n+\n+            let mut should_lint = true;\n             for rib in self.lifetime_ribs.iter().rev() {\n                 match rib.kind {\n                     // In create-parameter mode we error here because we don't want to support\n@@ -1456,72 +1602,68 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     //\n                     //     impl Foo for std::cell::Ref<u32> // note lack of '_\n                     //     async fn foo(_: std::cell::Ref<u32>) { ... }\n-                    LifetimeRibKind::AnonymousCreateParameter(_) => {\n+                    LifetimeRibKind::AnonymousCreateParameter { report_in_path: true, .. } => {\n+                        let sess = self.r.session;\n+                        let mut err = rustc_errors::struct_span_err!(\n+                            sess,\n+                            path_span,\n+                            E0726,\n+                            \"implicit elided lifetime not allowed here\"\n+                        );\n+                        rustc_errors::add_elided_lifetime_in_path_suggestion(\n+                            sess.source_map(),\n+                            &mut err,\n+                            expected_lifetimes,\n+                            path_span,\n+                            !segment.has_generic_args,\n+                            elided_lifetime_span,\n+                        );\n+                        err.note(\"assuming a `'static` lifetime...\");\n+                        err.emit();\n+                        should_lint = false;\n+\n+                        for id in node_ids {\n+                            self.record_lifetime_res(id, LifetimeRes::Error);\n+                        }\n+                        break;\n+                    }\n+                    // Do not create a parameter for patterns and expressions.\n+                    LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n+                        for id in node_ids {\n+                            let res = self.create_fresh_lifetime(id, ident, binder);\n+                            self.record_lifetime_res(id, res);\n+                        }\n                         break;\n                     }\n                     // `PassThrough` is the normal case.\n-                    // `new_error_lifetime`, which would usually be used in the case of `ReportError`,\n-                    // is unsuitable here, as these can occur from missing lifetime parameters in a\n-                    // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n-                    // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n-                    // later, at which point a suitable error will be emitted.\n                     LifetimeRibKind::AnonymousPassThrough(binder, _) => {\n-                        res = LifetimeRes::Anonymous { binder, elided: true };\n+                        let res = LifetimeRes::Anonymous { binder, elided: true };\n+                        for id in node_ids {\n+                            self.record_lifetime_res(id, res);\n+                        }\n                         break;\n                     }\n+                    // `LifetimeRes::Error`, which would usually be used in the case of\n+                    // `ReportError`, is unsuitable here, as we don't emit an error yet.  Instead,\n+                    // we simply resolve to an implicit lifetime, which will be checked later, at\n+                    // which point a suitable error will be emitted.\n                     LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n                         // FIXME(cjgillot) This resolution is wrong, but this does not matter\n                         // since these cases are erroneous anyway.  Lifetime resolution should\n                         // emit a \"missing lifetime specifier\" diagnostic.\n-                        res = LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n+                        let res = LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n+                        for id in node_ids {\n+                            self.record_lifetime_res(id, res);\n+                        }\n                         break;\n                     }\n-                    _ => {}\n+                    LifetimeRibKind::Generics { .. }\n+                    | LifetimeRibKind::ConstGeneric\n+                    | LifetimeRibKind::AnonConst => {}\n                 }\n             }\n \n-            let node_ids = self.r.next_node_ids(expected_lifetimes);\n-            self.record_lifetime_res(\n-                segment_id,\n-                LifetimeRes::ElidedAnchor { start: node_ids.start, end: node_ids.end },\n-            );\n-            for i in 0..expected_lifetimes {\n-                let id = node_ids.start.plus(i);\n-                self.record_lifetime_res(id, res);\n-            }\n-\n-            if !missing {\n-                continue;\n-            }\n-\n-            let elided_lifetime_span = if segment.has_generic_args {\n-                // If there are brackets, but not generic arguments, then use the opening bracket\n-                segment.args_span.with_hi(segment.args_span.lo() + BytePos(1))\n-            } else {\n-                // If there are no brackets, use the identifier span.\n-                // HACK: we use find_ancestor_inside to properly suggest elided spans in paths\n-                // originating from macros, since the segment's span might be from a macro arg.\n-                segment.ident.span.find_ancestor_inside(path_span).unwrap_or(path_span)\n-            };\n-            if let LifetimeRes::Error = res {\n-                let sess = self.r.session;\n-                let mut err = rustc_errors::struct_span_err!(\n-                    sess,\n-                    path_span,\n-                    E0726,\n-                    \"implicit elided lifetime not allowed here\"\n-                );\n-                rustc_errors::add_elided_lifetime_in_path_suggestion(\n-                    sess.source_map(),\n-                    &mut err,\n-                    expected_lifetimes,\n-                    path_span,\n-                    !segment.has_generic_args,\n-                    elided_lifetime_span,\n-                );\n-                err.note(\"assuming a `'static` lifetime...\");\n-                err.emit();\n-            } else {\n+            if should_lint {\n                 self.r.lint_buffer.buffer_lint_with_diagnostic(\n                     lint::builtin::ELIDED_LIFETIMES_IN_PATHS,\n                     segment_id,\n@@ -1732,72 +1874,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             |this| {\n                                 this.visit_generics(generics);\n                                 walk_list!(this, visit_param_bound, bounds, BoundKind::SuperTraits);\n-\n-                                let walk_assoc_item =\n-                                    |this: &mut Self,\n-                                     generics: &Generics,\n-                                     kind,\n-                                     item: &'ast AssocItem| {\n-                                        this.with_generic_param_rib(\n-                                            &generics.params,\n-                                            AssocItemRibKind,\n-                                            LifetimeRibKind::Generics {\n-                                                binder: item.id,\n-                                                span: generics.span,\n-                                                kind,\n-                                            },\n-                                            |this| {\n-                                                visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n-                                            },\n-                                        );\n-                                    };\n-\n-                                this.with_trait_items(items, |this| {\n-                                    for item in items {\n-                                        match &item.kind {\n-                                            AssocItemKind::Const(_, ty, default) => {\n-                                                this.visit_ty(ty);\n-                                                // Only impose the restrictions of `ConstRibKind` for an\n-                                                // actual constant expression in a provided default.\n-                                                if let Some(expr) = default {\n-                                                    // We allow arbitrary const expressions inside of associated consts,\n-                                                    // even if they are potentially not const evaluatable.\n-                                                    //\n-                                                    // Type parameters can already be used and as associated consts are\n-                                                    // not used as part of the type system, this is far less surprising.\n-                                                    this.with_constant_rib(\n-                                                        IsRepeatExpr::No,\n-                                                        HasGenericParams::Yes,\n-                                                        None,\n-                                                        |this| this.visit_expr(expr),\n-                                                    );\n-                                                }\n-                                            }\n-                                            AssocItemKind::Fn(box Fn { generics, .. }) => {\n-                                                walk_assoc_item(\n-                                                    this,\n-                                                    generics,\n-                                                    LifetimeBinderKind::Function,\n-                                                    item,\n-                                                );\n-                                            }\n-                                            AssocItemKind::TyAlias(box TyAlias {\n-                                                generics,\n-                                                ..\n-                                            }) => {\n-                                                walk_assoc_item(\n-                                                    this,\n-                                                    generics,\n-                                                    LifetimeBinderKind::Item,\n-                                                    item,\n-                                                );\n-                                            }\n-                                            AssocItemKind::MacCall(_) => {\n-                                                panic!(\"unexpanded macro in resolve!\")\n-                                            }\n-                                        };\n-                                    }\n-                                });\n+                                this.resolve_trait_items(items);\n                             },\n                         );\n                     },\n@@ -2073,16 +2150,53 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     /// When evaluating a `trait` use its associated types' idents for suggestions in E0412.\n-    fn with_trait_items<T>(\n-        &mut self,\n-        trait_items: &'ast [P<AssocItem>],\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> T {\n+    fn resolve_trait_items(&mut self, trait_items: &'ast [P<AssocItem>]) {\n         let trait_assoc_items =\n             replace(&mut self.diagnostic_metadata.current_trait_assoc_items, Some(&trait_items));\n-        let result = f(self);\n+\n+        let walk_assoc_item =\n+            |this: &mut Self, generics: &Generics, kind, item: &'ast AssocItem| {\n+                this.with_generic_param_rib(\n+                    &generics.params,\n+                    AssocItemRibKind,\n+                    LifetimeRibKind::Generics { binder: item.id, span: generics.span, kind },\n+                    |this| visit::walk_assoc_item(this, item, AssocCtxt::Trait),\n+                );\n+            };\n+\n+        for item in trait_items {\n+            match &item.kind {\n+                AssocItemKind::Const(_, ty, default) => {\n+                    self.visit_ty(ty);\n+                    // Only impose the restrictions of `ConstRibKind` for an\n+                    // actual constant expression in a provided default.\n+                    if let Some(expr) = default {\n+                        // We allow arbitrary const expressions inside of associated consts,\n+                        // even if they are potentially not const evaluatable.\n+                        //\n+                        // Type parameters can already be used and as associated consts are\n+                        // not used as part of the type system, this is far less surprising.\n+                        self.with_constant_rib(\n+                            IsRepeatExpr::No,\n+                            HasGenericParams::Yes,\n+                            None,\n+                            |this| this.visit_expr(expr),\n+                        );\n+                    }\n+                }\n+                AssocItemKind::Fn(box Fn { generics, .. }) => {\n+                    walk_assoc_item(self, generics, LifetimeBinderKind::Function, item);\n+                }\n+                AssocItemKind::TyAlias(box TyAlias { generics, .. }) => {\n+                    walk_assoc_item(self, generics, LifetimeBinderKind::Item, item);\n+                }\n+                AssocItemKind::MacCall(_) => {\n+                    panic!(\"unexpanded macro in resolve!\")\n+                }\n+            };\n+        }\n+\n         self.diagnostic_metadata.current_trait_assoc_items = trait_assoc_items;\n-        result\n     }\n \n     /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n@@ -2140,142 +2254,159 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(&generics.params, ItemRibKind(HasGenericParams::Yes), LifetimeRibKind::Generics { span: generics.span, binder: item_id, kind: LifetimeBinderKind::ImplBlock }, |this| {\n-            // Dummy self type for better errors if `Self` is used in the trait path.\n-            this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n-                this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter(item_id), |this| {\n-                    // Resolve the trait reference, if necessary.\n-                    this.with_optional_trait_ref(opt_trait_reference.as_ref(), self_type, |this, trait_id| {\n-                        let item_def_id = this.r.local_def_id(item_id);\n-\n-                        // Register the trait definitions from here.\n-                        if let Some(trait_id) = trait_id {\n-                            this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n-                        }\n-\n-                        let item_def_id = item_def_id.to_def_id();\n-                        let res =\n-                            Res::SelfTy { trait_: trait_id, alias_to: Some((item_def_id, false)) };\n-                        this.with_self_rib(res, |this| {\n-                            if let Some(trait_ref) = opt_trait_reference.as_ref() {\n-                                // Resolve type arguments in the trait path.\n-                                visit::walk_trait_ref(this, trait_ref);\n-                            }\n-                            // Resolve the self type.\n-                            this.visit_ty(self_type);\n-                            // Resolve the generic parameters.\n-                            this.visit_generics(generics);\n+        self.with_generic_param_rib(\n+            &generics.params,\n+            ItemRibKind(HasGenericParams::Yes),\n+            LifetimeRibKind::Generics {\n+                span: generics.span,\n+                binder: item_id,\n+                kind: LifetimeBinderKind::ImplBlock\n+            },\n+            |this| {\n+                // Dummy self type for better errors if `Self` is used in the trait path.\n+                this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n+                    this.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousCreateParameter {\n+                            binder: item_id,\n+                            report_in_path: true\n+                        },\n+                        |this| {\n+                            // Resolve the trait reference, if necessary.\n+                            this.with_optional_trait_ref(\n+                                opt_trait_reference.as_ref(),\n+                                self_type,\n+                                |this, trait_id| {\n+                                    let item_def_id = this.r.local_def_id(item_id);\n+\n+                                    // Register the trait definitions from here.\n+                                    if let Some(trait_id) = trait_id {\n+                                        this.r.trait_impls.entry(trait_id).or_default().push(item_def_id);\n+                                    }\n \n-                            // Resolve the items within the impl.\n-                            this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(item_id,false),\n-                                |this| {\n-                                    this.with_current_self_type(self_type, |this| {\n-                                        this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n-                                            debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n-                                            for item in impl_items {\n-                                                use crate::ResolutionError::*;\n-                                                match &item.kind {\n-                                                    AssocItemKind::Const(_default, _ty, _expr) => {\n-                                                        debug!(\"resolve_implementation AssocItemKind::Const\");\n-                                                        // If this is a trait impl, ensure the const\n-                                                        // exists in trait\n-                                                        this.check_trait_item(\n-                                                            item.id,\n-                                                            item.ident,\n-                                                            &item.kind,\n-                                                            ValueNS,\n-                                                            item.span,\n-                                                            |i, s, c| ConstNotMemberOfTrait(i, s, c),\n-                                                        );\n-\n-                                                        // We allow arbitrary const expressions inside of associated consts,\n-                                                        // even if they are potentially not const evaluatable.\n-                                                        //\n-                                                        // Type parameters can already be used and as associated consts are\n-                                                        // not used as part of the type system, this is far less surprising.\n-                                                        this.with_constant_rib(\n-                                                            IsRepeatExpr::No,\n-                                                            HasGenericParams::Yes,\n-                                                            None,\n-                                                            |this| {\n-                                                                visit::walk_assoc_item(\n-                                                                    this,\n-                                                                    item,\n-                                                                    AssocCtxt::Impl,\n-                                                                )\n-                                                            },\n-                                                        );\n-                                                    }\n-                                                    AssocItemKind::Fn(box Fn { generics, .. }) => {\n-                                                        debug!(\"resolve_implementation AssocItemKind::Fn\");\n-                                                        // We also need a new scope for the impl item type parameters.\n-                                                        this.with_generic_param_rib(\n-                                                            &generics.params,\n-                                                            AssocItemRibKind,\n-                                                            LifetimeRibKind::Generics { binder: item.id, span: generics.span, kind: LifetimeBinderKind::Function },\n-                                                            |this| {\n-                                                                // If this is a trait impl, ensure the method\n-                                                                // exists in trait\n-                                                                this.check_trait_item(\n-                                                                    item.id,\n-                                                                    item.ident,\n-                                                                    &item.kind,\n-                                                                    ValueNS,\n-                                                                    item.span,\n-                                                                    |i, s, c| MethodNotMemberOfTrait(i, s, c),\n-                                                                );\n-\n-                                                                visit::walk_assoc_item(\n-                                                                    this,\n-                                                                    item,\n-                                                                    AssocCtxt::Impl,\n-                                                                )\n-                                                            },\n-                                                        );\n-                                                    }\n-                                                    AssocItemKind::TyAlias(box TyAlias {\n-                                                        generics, ..\n-                                                    }) => {\n-                                                        debug!(\"resolve_implementation AssocItemKind::TyAlias\");\n-                                                        // We also need a new scope for the impl item type parameters.\n-                                                        this.with_generic_param_rib(\n-                                                            &generics.params,\n-                                                            AssocItemRibKind,\n-                                                            LifetimeRibKind::Generics { binder: item.id, span: generics.span, kind: LifetimeBinderKind::Item },\n-                                                            |this| {\n-                                                                // If this is a trait impl, ensure the type\n-                                                                // exists in trait\n-                                                                this.check_trait_item(\n-                                                                    item.id,\n-                                                                    item.ident,\n-                                                                    &item.kind,\n-                                                                    TypeNS,\n-                                                                    item.span,\n-                                                                    |i, s, c| TypeNotMemberOfTrait(i, s, c),\n-                                                                );\n-\n-                                                                visit::walk_assoc_item(\n-                                                                    this,\n-                                                                    item,\n-                                                                    AssocCtxt::Impl,\n-                                                                )\n-                                                            },\n-                                                        );\n-                                                    }\n-                                                    AssocItemKind::MacCall(_) => {\n-                                                        panic!(\"unexpanded macro in resolve!\")\n-                                                    }\n-                                                }\n-                                            }\n-                                        });\n+                                    let item_def_id = item_def_id.to_def_id();\n+                                    let res = Res::SelfTy {\n+                                        trait_: trait_id,\n+                                        alias_to: Some((item_def_id, false)),\n+                                    };\n+                                    this.with_self_rib(res, |this| {\n+                                        if let Some(trait_ref) = opt_trait_reference.as_ref() {\n+                                            // Resolve type arguments in the trait path.\n+                                            visit::walk_trait_ref(this, trait_ref);\n+                                        }\n+                                        // Resolve the self type.\n+                                        this.visit_ty(self_type);\n+                                        // Resolve the generic parameters.\n+                                        this.visit_generics(generics);\n+\n+                                        // Resolve the items within the impl.\n+                                        this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(item_id,false),\n+                                            |this| {\n+                                                this.with_current_self_type(self_type, |this| {\n+                                                    this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n+                                                        debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n+                                                        for item in impl_items {\n+                                                            this.resolve_impl_item(&**item);\n+                                                        }\n+                                                    });\n+                                                });\n+                                            },\n+                                        );\n                                     });\n                                 },\n                             );\n-                        });\n-                    });\n+                        },\n+                    );\n                 });\n-            });\n-        });\n+            },\n+        );\n+    }\n+\n+    fn resolve_impl_item(&mut self, item: &'ast AssocItem) {\n+        use crate::ResolutionError::*;\n+        match &item.kind {\n+            AssocItemKind::Const(_, ty, default) => {\n+                debug!(\"resolve_implementation AssocItemKind::Const\");\n+                // If this is a trait impl, ensure the const\n+                // exists in trait\n+                self.check_trait_item(\n+                    item.id,\n+                    item.ident,\n+                    &item.kind,\n+                    ValueNS,\n+                    item.span,\n+                    |i, s, c| ConstNotMemberOfTrait(i, s, c),\n+                );\n+\n+                self.visit_ty(ty);\n+                if let Some(expr) = default {\n+                    // We allow arbitrary const expressions inside of associated consts,\n+                    // even if they are potentially not const evaluatable.\n+                    //\n+                    // Type parameters can already be used and as associated consts are\n+                    // not used as part of the type system, this is far less surprising.\n+                    self.with_constant_rib(IsRepeatExpr::No, HasGenericParams::Yes, None, |this| {\n+                        this.visit_expr(expr)\n+                    });\n+                }\n+            }\n+            AssocItemKind::Fn(box Fn { generics, .. }) => {\n+                debug!(\"resolve_implementation AssocItemKind::Fn\");\n+                // We also need a new scope for the impl item type parameters.\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    AssocItemRibKind,\n+                    LifetimeRibKind::Generics {\n+                        binder: item.id,\n+                        span: generics.span,\n+                        kind: LifetimeBinderKind::Function,\n+                    },\n+                    |this| {\n+                        // If this is a trait impl, ensure the method\n+                        // exists in trait\n+                        this.check_trait_item(\n+                            item.id,\n+                            item.ident,\n+                            &item.kind,\n+                            ValueNS,\n+                            item.span,\n+                            |i, s, c| MethodNotMemberOfTrait(i, s, c),\n+                        );\n+\n+                        visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                    },\n+                );\n+            }\n+            AssocItemKind::TyAlias(box TyAlias { generics, .. }) => {\n+                debug!(\"resolve_implementation AssocItemKind::TyAlias\");\n+                // We also need a new scope for the impl item type parameters.\n+                self.with_generic_param_rib(\n+                    &generics.params,\n+                    AssocItemRibKind,\n+                    LifetimeRibKind::Generics {\n+                        binder: item.id,\n+                        span: generics.span,\n+                        kind: LifetimeBinderKind::Item,\n+                    },\n+                    |this| {\n+                        // If this is a trait impl, ensure the type\n+                        // exists in trait\n+                        this.check_trait_item(\n+                            item.id,\n+                            item.ident,\n+                            &item.kind,\n+                            TypeNS,\n+                            item.span,\n+                            |i, s, c| TypeNotMemberOfTrait(i, s, c),\n+                        );\n+\n+                        visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                    },\n+                );\n+            }\n+            AssocItemKind::MacCall(_) => {\n+                panic!(\"unexpanded macro in resolve!\")\n+            }\n+        }\n     }\n \n     fn check_trait_item<F>("}, {"sha": "68bcba7147bba5ec3d018383424a9087716ea64a", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -2242,9 +2242,18 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             ]\n             .contains(&Some(did))\n             {\n-                let (span, span_type) = match &trait_ref.bound_generic_params {\n-                    [] => (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty),\n-                    [.., bound] => (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail),\n+                let (span, span_type) = if let Some(bound) =\n+                    trait_ref.bound_generic_params.iter().rfind(|param| {\n+                        matches!(\n+                            param.kind,\n+                            hir::GenericParamKind::Lifetime {\n+                                kind: hir::LifetimeParamKind::Explicit\n+                            }\n+                        )\n+                    }) {\n+                    (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail)\n+                } else {\n+                    (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty)\n                 };\n                 self.missing_named_lifetime_spots\n                     .push(MissingLifetimeSpot::HigherRanked { span, span_type });"}, {"sha": "ed5d1165c7d0d48c20593e8d6e1cb1bbee2c7c99", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -29,8 +29,6 @@ use std::cell::Cell;\n use std::fmt;\n use std::mem::take;\n \n-use tracing::{debug, span, Level};\n-\n trait RegionExt {\n     fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n@@ -572,41 +570,38 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_fn(\n-        &mut self,\n-        fk: intravisit::FnKind<'tcx>,\n-        fd: &'tcx hir::FnDecl<'tcx>,\n-        b: hir::BodyId,\n-        s: rustc_span::Span,\n-        hir_id: hir::HirId,\n-    ) {\n-        let name = match fk {\n-            intravisit::FnKind::ItemFn(id, _, _) => id.name,\n-            intravisit::FnKind::Method(id, _) => id.name,\n-            intravisit::FnKind::Closure => sym::closure,\n-        };\n-        let name = name.as_str();\n-        let span = span!(Level::DEBUG, \"visit_fn\", name);\n-        let _enter = span.enter();\n-        match fk {\n-            // Any `Binders` are handled elsewhere\n-            intravisit::FnKind::ItemFn(..) | intravisit::FnKind::Method(..) => {\n-                intravisit::walk_fn(self, fk, fd, b, s, hir_id)\n-            }\n-            intravisit::FnKind::Closure => {\n-                self.map.late_bound_vars.insert(hir_id, vec![]);\n-                let scope = Scope::Binder {\n-                    hir_id,\n-                    lifetimes: FxIndexMap::default(),\n-                    next_early_index: self.next_early_index(),\n-                    s: self.scope,\n-                    opaque_type_parent: false,\n-                    scope_type: BinderScopeType::Normal,\n-                    allow_late_bound: true,\n-                    where_bound_origin: None,\n-                };\n-                self.with(scope, move |this| intravisit::walk_fn(this, fk, fd, b, s, hir_id));\n-            }\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n+        if let hir::ExprKind::Closure { bound_generic_params, .. } = e.kind {\n+            let next_early_index = self.next_early_index();\n+            let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n+                bound_generic_params\n+                    .iter()\n+                    .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n+                    .enumerate()\n+                    .map(|(late_bound_idx, param)| {\n+                        let pair = Region::late(late_bound_idx as u32, self.tcx.hir(), param);\n+                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        (pair, r)\n+                    })\n+                    .unzip();\n+            self.map.late_bound_vars.insert(e.hir_id, binders);\n+            let scope = Scope::Binder {\n+                hir_id: e.hir_id,\n+                lifetimes,\n+                s: self.scope,\n+                next_early_index,\n+                opaque_type_parent: false,\n+                scope_type: BinderScopeType::Normal,\n+                allow_late_bound: true,\n+                where_bound_origin: None,\n+            };\n+            self.with(scope, |this| {\n+                // a closure has no bounds, so everything\n+                // contained within is scoped within its binder.\n+                intravisit::walk_expr(this, e)\n+            });\n+        } else {\n+            intravisit::walk_expr(self, e)\n         }\n     }\n \n@@ -755,7 +750,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let next_early_index = self.next_early_index();\n                 let lifetime_span: Option<Span> =\n                     c.generic_params.iter().rev().find_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(param.span),\n+                        GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit } => {\n+                            Some(param.span)\n+                        }\n                         _ => None,\n                     });\n                 let (span, span_type) = if let Some(span) = lifetime_span {"}, {"sha": "84e3180b491a188686b5931ad58d3170451ff0f5", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -2920,13 +2920,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) {\n         for br in referenced_regions.difference(&constrained_regions) {\n             let br_name = match *br {\n+                ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) | ty::BrEnv => {\n+                    \"an anonymous lifetime\".to_string()\n+                }\n                 ty::BrNamed(_, name) => format!(\"lifetime `{}`\", name),\n-                ty::BrAnon(_) | ty::BrEnv => \"an anonymous lifetime\".to_string(),\n             };\n \n             let mut err = generate_err(&br_name);\n \n-            if let ty::BrAnon(_) = *br {\n+            if let ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) = *br {\n                 // The only way for an anonymous lifetime to wind up\n                 // in the return type but **also** be unconstrained is\n                 // if it only appears in \"associated types\" in the"}, {"sha": "95c82a7d2c3d8e15a419b2cb1e4e6d491358cc17", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -628,24 +628,40 @@ fn compare_number_of_generics<'tcx>(\n     let mut err_occurred = None;\n     for (kind, trait_count, impl_count) in matchings {\n         if impl_count != trait_count {\n+            let arg_spans = |kind: ty::AssocKind, generics: &hir::Generics<'_>| {\n+                let mut spans = generics\n+                    .params\n+                    .iter()\n+                    .filter(|p| match p.kind {\n+                        hir::GenericParamKind::Lifetime {\n+                            kind: hir::LifetimeParamKind::Elided,\n+                        } => {\n+                            // A fn can have an arbitrary number of extra elided lifetimes for the\n+                            // same signature.\n+                            !matches!(kind, ty::AssocKind::Fn)\n+                        }\n+                        _ => true,\n+                    })\n+                    .map(|p| p.span)\n+                    .collect::<Vec<Span>>();\n+                if spans.is_empty() {\n+                    spans = vec![generics.span]\n+                }\n+                spans\n+            };\n             let (trait_spans, impl_trait_spans) = if let Some(def_id) = trait_.def_id.as_local() {\n                 let trait_item = tcx.hir().expect_trait_item(def_id);\n-                if trait_item.generics.params.is_empty() {\n-                    (Some(vec![trait_item.generics.span]), vec![])\n-                } else {\n-                    let arg_spans: Vec<Span> =\n-                        trait_item.generics.params.iter().map(|p| p.span).collect();\n-                    let impl_trait_spans: Vec<Span> = trait_item\n-                        .generics\n-                        .params\n-                        .iter()\n-                        .filter_map(|p| match p.kind {\n-                            GenericParamKind::Type { synthetic: true, .. } => Some(p.span),\n-                            _ => None,\n-                        })\n-                        .collect();\n-                    (Some(arg_spans), impl_trait_spans)\n-                }\n+                let arg_spans: Vec<Span> = arg_spans(trait_.kind, trait_item.generics);\n+                let impl_trait_spans: Vec<Span> = trait_item\n+                    .generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|p| match p.kind {\n+                        GenericParamKind::Type { synthetic: true, .. } => Some(p.span),\n+                        _ => None,\n+                    })\n+                    .collect();\n+                (Some(arg_spans), impl_trait_spans)\n             } else {\n                 (trait_span.map(|s| vec![s]), vec![])\n             };\n@@ -660,23 +676,7 @@ fn compare_number_of_generics<'tcx>(\n                     _ => None,\n                 })\n                 .collect();\n-            let spans = if impl_item.generics.params.is_empty() {\n-                vec![impl_item.generics.span]\n-            } else {\n-                impl_item\n-                    .generics\n-                    .params\n-                    .iter()\n-                    .filter(|p| {\n-                        matches!(\n-                            p.kind,\n-                            hir::GenericParamKind::Type { .. }\n-                                | hir::GenericParamKind::Const { .. }\n-                        )\n-                    })\n-                    .map(|p| p.span)\n-                    .collect::<Vec<Span>>()\n-            };\n+            let spans = arg_spans(impl_.kind, impl_item.generics);\n             let span = spans.first().copied();\n \n             let mut err = tcx.sess.struct_span_err_with_code("}, {"sha": "9e5c4afc717a7162bc2d33856a00421f46305e7b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -222,10 +222,15 @@ impl<'tcx> Clean<'tcx, Option<Lifetime>> for ty::Region<'tcx> {\n         match **self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) => {\n-                Some(Lifetime(name))\n+                if name != kw::UnderscoreLifetime { Some(Lifetime(name)) } else { None }\n+            }\n+            ty::ReEarlyBound(ref data) => {\n+                if data.name != kw::UnderscoreLifetime {\n+                    Some(Lifetime(data.name))\n+                } else {\n+                    None\n+                }\n             }\n-            ty::ReEarlyBound(ref data) => Some(Lifetime(data.name)),\n-\n             ty::ReLateBound(..)\n             | ty::ReFree(..)\n             | ty::ReVar(..)\n@@ -530,29 +535,25 @@ fn clean_generic_param<'tcx>(\n     GenericParamDef { name, kind }\n }\n \n+/// Synthetic type-parameters are inserted after normal ones.\n+/// In order for normal parameters to be able to refer to synthetic ones,\n+/// scans them first.\n+fn is_impl_trait(param: &hir::GenericParam<'_>) -> bool {\n+    match param.kind {\n+        hir::GenericParamKind::Type { synthetic, .. } => synthetic,\n+        _ => false,\n+    }\n+}\n+\n+/// This can happen for `async fn`, e.g. `async fn f<'_>(&'_ self)`.\n+///\n+/// See `lifetime_to_generic_param` in `rustc_ast_lowering` for more information.\n+fn is_elided_lifetime(param: &hir::GenericParam<'_>) -> bool {\n+    matches!(param.kind, hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided })\n+}\n+\n impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n-        // Synthetic type-parameters are inserted after normal ones.\n-        // In order for normal parameters to be able to refer to synthetic ones,\n-        // scans them first.\n-        fn is_impl_trait(param: &hir::GenericParam<'_>) -> bool {\n-            match param.kind {\n-                hir::GenericParamKind::Type { synthetic, .. } => synthetic,\n-                _ => false,\n-            }\n-        }\n-        /// This can happen for `async fn`, e.g. `async fn f<'_>(&'_ self)`.\n-        ///\n-        /// See [`lifetime_to_generic_param`] in [`rustc_ast_lowering`] for more information.\n-        ///\n-        /// [`lifetime_to_generic_param`]: rustc_ast_lowering::LoweringContext::lifetime_to_generic_param\n-        fn is_elided_lifetime(param: &hir::GenericParam<'_>) -> bool {\n-            matches!(\n-                param.kind,\n-                hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided }\n-            )\n-        }\n-\n         let impl_trait_params = self\n             .params\n             .iter()\n@@ -991,6 +992,7 @@ impl<'tcx> Clean<'tcx, PolyTrait> for hir::PolyTraitRef<'tcx> {\n             generic_params: self\n                 .bound_generic_params\n                 .iter()\n+                .filter(|p| !is_elided_lifetime(p))\n                 .map(|x| clean_generic_param(cx, None, x))\n                 .collect(),\n         }\n@@ -1865,8 +1867,12 @@ impl<'tcx> Clean<'tcx, BareFunctionDecl> for hir::BareFnTy<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             // NOTE: generics must be cleaned before args\n-            let generic_params =\n-                self.generic_params.iter().map(|x| clean_generic_param(cx, None, x)).collect();\n+            let generic_params = self\n+                .generic_params\n+                .iter()\n+                .filter(|p| !is_elided_lifetime(p))\n+                .map(|x| clean_generic_param(cx, None, x))\n+                .collect();\n             let args = clean_args_from_types_and_names(cx, self.decl.inputs, self.param_names);\n             let decl = clean_fn_decl_with_args(cx, self.decl, args);\n             (generic_params, decl)"}, {"sha": "16574f94c00e9e07ed48f68995d0679d943e3a06", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -84,12 +84,9 @@ pub(crate) fn substs_to_args<'tcx>(\n     let mut ret_val =\n         Vec::with_capacity(substs.len().saturating_sub(if skip_first { 1 } else { 0 }));\n     ret_val.extend(substs.iter().filter_map(|kind| match kind.unpack() {\n-        GenericArgKind::Lifetime(lt) => match *lt {\n-            ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrAnon(_), .. }) => {\n-                Some(GenericArg::Lifetime(Lifetime::elided()))\n-            }\n-            _ => lt.clean(cx).map(GenericArg::Lifetime),\n-        },\n+        GenericArgKind::Lifetime(lt) => {\n+            Some(GenericArg::Lifetime(lt.clean(cx).unwrap_or(Lifetime::elided())))\n+        }\n         GenericArgKind::Type(_) if skip_first => {\n             skip_first = false;\n             None"}, {"sha": "c9fd7248a80044038a2bb9694fde051d7ebb1982", "filename": "src/test/ui/generic-associated-types/issue-70304.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -45,7 +45,7 @@ where\n }\n \n fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'_>> {\n-    //~^ ERROR: missing lifetime specifier\n+    //~^ ERROR `'_` cannot be used here [E0637]\n     //~| ERROR: missing lifetime specifier\n     DocumentImpl {}\n }"}, {"sha": "b3881ccb099f07d6a2707b4bf1789e764bfedd03", "filename": "src/test/ui/generic-associated-types/issue-70304.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -1,14 +1,8 @@\n-error[E0106]: missing lifetime specifier\n+error[E0637]: `'_` cannot be used here\n   --> $DIR/issue-70304.rs:47:41\n    |\n LL | fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'_>> {\n-   |                                         ^^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL | fn create_doc() -> impl Document<Cursor<'static> = DocCursorImpl<'_>> {\n-   |                                         ~~~~~~~\n+   |                                         ^^ `'_` is a reserved lifetime name\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-70304.rs:47:61\n@@ -24,4 +18,5 @@ LL | fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'static>> {\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0106, E0637.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "2365daada11479fc8ffadf3b6008dcfc66e8208b", "filename": "src/test/ui/generic-associated-types/issue-95305.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -9,7 +9,7 @@ trait Foo {\n }\n \n fn foo(x: &impl Foo<Item<'_> = u32>) { }\n-                       //~^ ERROR missing lifetime specifier\n+                       //~^ ERROR `'_` cannot be used here [E0637]\n \n fn bar(x: &impl for<'a> Foo<Item<'a> = &'_ u32>) { }\n                                       //~^ ERROR missing lifetime specifier"}, {"sha": "8624d880d4ee27e91009a446376bde35b68e5823", "filename": "src/test/ui/generic-associated-types/issue-95305.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.stderr?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -1,13 +1,8 @@\n-error[E0106]: missing lifetime specifier\n+error[E0637]: `'_` cannot be used here\n   --> $DIR/issue-95305.rs:11:26\n    |\n LL | fn foo(x: &impl Foo<Item<'_> = u32>) { }\n-   |                          ^^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL | fn foo<'a>(x: &impl Foo<Item<'a> = u32>) { }\n-   |       ++++                   ~~\n+   |                          ^^ `'_` is a reserved lifetime name\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-95305.rs:14:41\n@@ -22,4 +17,5 @@ LL | fn bar(x: &impl for<'a> Foo<Item<'a> = &'a u32>) { }\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0106, E0637.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "1458bf0c4a49341147eb47f4bf57c7601c8e5199", "filename": "src/test/ui/generic-associated-types/parameter_number_and_kind_impl.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -8,15 +8,17 @@ LL |     type A = u32;\n    |           ^ lifetimes do not match type in trait\n \n error[E0049]: type `B` has 1 type parameter but its trait declaration has 0 type parameters\n-  --> $DIR/parameter_number_and_kind_impl.rs:17:16\n+  --> $DIR/parameter_number_and_kind_impl.rs:17:12\n    |\n LL |     type B<'a, 'b>;\n    |            --  --\n    |            |\n    |            expected 0 type parameters\n ...\n LL |     type B<'a, T> = Vec<T>;\n-   |                ^ found 1 type parameter\n+   |            ^^  ^\n+   |            |\n+   |            found 1 type parameter\n \n error[E0195]: lifetime parameters or bounds on type `C` do not match the trait declaration\n   --> $DIR/parameter_number_and_kind_impl.rs:19:11"}, {"sha": "0bfa7b3cc7c45e8acc440c359b5e2e72f52e344b", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-71955.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.stderr?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -23,7 +23,7 @@ error[E0308]: mismatched types\n LL |     foo(bar, \"string\", |s| s.len() == 5);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-   = note: expected trait `FnOnce<(&&str,)>`\n+   = note: expected trait `for<'r, 's> FnOnce<(&'r &'s str,)>`\n               found trait `for<'r> FnOnce<(&'r &str,)>`\n note: this closure does not fulfill the lifetime requirements\n   --> $DIR/issue-71955.rs:45:24\n@@ -61,7 +61,7 @@ error[E0308]: mismatched types\n LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-   = note: expected trait `FnOnce<(&Wrapper<'_>,)>`\n+   = note: expected trait `for<'r, 's> FnOnce<(&'r Wrapper<'s>,)>`\n               found trait `for<'r> FnOnce<(&'r Wrapper<'_>,)>`\n note: this closure does not fulfill the lifetime requirements\n   --> $DIR/issue-71955.rs:48:24"}, {"sha": "172bf218c0d4cd7244dcdbbeb4a3cd3f0a62ccd2", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-85455.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -6,8 +6,8 @@ trait SomeTrait<'a> {\n \n fn give_me_ice<T>() {\n     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n-    //~^ ERROR the trait bound `T: SomeTrait<'_>` is not satisfied [E0277]\n-    //~| ERROR the trait bound `T: SomeTrait<'_>` is not satisfied [E0277]\n+    //~^ ERROR the trait bound `for<'r> T: SomeTrait<'r>` is not satisfied [E0277]\n+    //~| ERROR the trait bound `for<'r> T: SomeTrait<'r>` is not satisfied [E0277]\n }\n \n fn callee<T: Fn<(&'static (),)>>() {"}, {"sha": "ecca4b999e7e8c1c04bb230261d1c50a8646e545", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-85455.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -1,24 +1,24 @@\n-error[E0277]: the trait bound `T: SomeTrait<'_>` is not satisfied\n+error[E0277]: the trait bound `for<'r> T: SomeTrait<'r>` is not satisfied\n   --> $DIR/issue-85455.rs:8:5\n    |\n LL |     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `SomeTrait<'_>` is not implemented for `T`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'r> SomeTrait<'r>` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |\n-LL | fn give_me_ice<T: SomeTrait<'_>>() {\n-   |                 +++++++++++++++\n+LL | fn give_me_ice<T: for<'r> SomeTrait<'r>>() {\n+   |                 +++++++++++++++++++++++\n \n-error[E0277]: the trait bound `T: SomeTrait<'_>` is not satisfied\n+error[E0277]: the trait bound `for<'r> T: SomeTrait<'r>` is not satisfied\n   --> $DIR/issue-85455.rs:8:14\n    |\n LL |     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `SomeTrait<'_>` is not implemented for `T`\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'r> SomeTrait<'r>` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |\n-LL | fn give_me_ice<T: SomeTrait<'_>>() {\n-   |                 +++++++++++++++\n+LL | fn give_me_ice<T: for<'r> SomeTrait<'r>>() {\n+   |                 +++++++++++++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "359c08c98d1ab8e0357326b1ec096083674c0a1a", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -13,6 +13,10 @@ impl StaticTrait for Box<dyn Debug> { }\n trait NotStaticTrait { }\n impl NotStaticTrait for Box<dyn Debug + '_> { }\n \n+// Check that we don't err when the trait has a lifetime parameter.\n+trait TraitWithLifetime<'a> { }\n+impl NotStaticTrait for &dyn TraitWithLifetime<'_> { }\n+\n fn static_val<T: StaticTrait>(_: T) {\n }\n "}, {"sha": "762698c4fc141b7753a41ff12635ba51b42b5409", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -1,5 +1,5 @@\n error[E0521]: borrowed data escapes outside of function\n-  --> $DIR/dyn-trait.rs:20:5\n+  --> $DIR/dyn-trait.rs:24:5\n    |\n LL | fn with_dyn_debug_static<'a>(x: Box<dyn Debug + 'a>) {\n    |                          --  - `x` is a reference that is only valid in the function body"}, {"sha": "ff84d2511496005f6e8de48e16a37f10bba999da", "filename": "src/test/ui/lifetimes/elided-lifetime-in-path-in-pat.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-path-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-path-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-path-in-pat.rs?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+struct Foo<'a> {\n+    x: &'a (),\n+}\n+\n+// The lifetime in pattern-position `Foo` is elided.\n+// Verify that lowering does not create an independent lifetime parameter for it.\n+fn foo<'a>(Foo { x }: Foo<'a>) {\n+    *x\n+}\n+\n+fn main() {}"}, {"sha": "d85ea6529f628e08ea4272e961a378d99a8315bb", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-using-trait-objects.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f4ce324baf7cfb7ce2b2096662b82b79204944/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.stderr?ref=10f4ce324baf7cfb7ce2b2096662b82b79204944", "patch": "@@ -10,8 +10,8 @@ LL |   y.push(z);\n    |\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn foo<'a>(x:Box<dyn Fn(&'a u8, &'a u8)> , y: Vec<&u8>, z: &u8) {\n-   |       ++++               ++      ++\n+LL | fn foo<'a>(x:Box<dyn Fn(&u8, &u8)> , y: Vec<&'a u8>, z: &'a u8) {\n+   |       ++++                                   ++          ++\n \n error[E0596]: cannot borrow `y` as mutable, as it is not declared as mutable\n   --> $DIR/ex3-both-anon-regions-using-trait-objects.rs:2:3"}]}