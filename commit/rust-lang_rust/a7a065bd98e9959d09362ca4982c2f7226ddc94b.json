{"sha": "a7a065bd98e9959d09362ca4982c2f7226ddc94b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YTA2NWJkOThlOTk1OWQwOTM2MmNhNDk4MmMyZjcyMjZkZGM5NGI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-05T21:59:13Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:46Z"}, "message": "libcollections: use unboxed closures in `[Clone]SliceAllocPrelude` methods", "tree": {"sha": "7d4e77988d42b5ed3b5f19f60809ce66b1738a9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d4e77988d42b5ed3b5f19f60809ce66b1738a9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7a065bd98e9959d09362ca4982c2f7226ddc94b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7a065bd98e9959d09362ca4982c2f7226ddc94b", "html_url": "https://github.com/rust-lang/rust/commit/a7a065bd98e9959d09362ca4982c2f7226ddc94b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7a065bd98e9959d09362ca4982c2f7226ddc94b/comments", "author": null, "committer": null, "parents": [{"sha": "6f19f8d43051f8c8dff81ed0c82ca2d9026d58a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f19f8d43051f8c8dff81ed0c82ca2d9026d58a8", "html_url": "https://github.com/rust-lang/rust/commit/6f19f8d43051f8c8dff81ed0c82ca2d9026d58a8"}], "stats": {"total": 13, "additions": 7, "deletions": 6}, "files": [{"sha": "463e28b420d157c6d7bbf6d72aeae439bd1a070b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a7a065bd98e9959d09362ca4982c2f7226ddc94b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7a065bd98e9959d09362ca4982c2f7226ddc94b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a7a065bd98e9959d09362ca4982c2f7226ddc94b", "patch": "@@ -94,6 +94,7 @@ use core::cmp;\n use core::kinds::{Copy, Sized};\n use core::mem::size_of;\n use core::mem;\n+use core::ops::FnMut;\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n use core::prelude::{Ord, Ordering, RawPtr, Some, range};\n use core::ptr;\n@@ -296,7 +297,7 @@ pub trait CloneSliceAllocPrelude<T> for Sized? {\n \n     /// Partitions the vector into two vectors `(a, b)`, where all\n     /// elements of `a` satisfy `f` and all elements of `b` do not.\n-    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n \n     /// Creates an iterator that yields every possible permutation of the\n     /// vector in succession.\n@@ -336,7 +337,7 @@ impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n \n \n     #[inline]\n-    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n+    fn partitioned<F>(&self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -361,7 +362,7 @@ impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n \n }\n \n-fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n     let len = v.len() as int;\n     let buf_v = v.as_mut_ptr();\n \n@@ -403,7 +404,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     }\n }\n \n-fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n     // warning: this wildly uses unsafe.\n     static BASE_INSERTION: uint = 32;\n     static LARGE_INSERTION: uint = 16;\n@@ -611,7 +612,7 @@ pub trait SliceAllocPrelude<T> for Sized? {\n     /// v.sort_by(|a, b| b.cmp(a));\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n-    fn sort_by(&mut self, compare: |&T, &T| -> Ordering);\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n     /// from the range [start,end).\n@@ -639,7 +640,7 @@ pub trait SliceAllocPrelude<T> for Sized? {\n \n impl<T> SliceAllocPrelude<T> for [T] {\n     #[inline]\n-    fn sort_by(&mut self, compare: |&T, &T| -> Ordering) {\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n     }\n "}]}