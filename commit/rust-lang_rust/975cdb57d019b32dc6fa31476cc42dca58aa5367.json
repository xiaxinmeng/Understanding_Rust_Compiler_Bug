{"sha": "975cdb57d019b32dc6fa31476cc42dca58aa5367", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NWNkYjU3ZDAxOWIzMmRjNmZhMzE0NzZjYzQyZGNhNThhYTUzNjc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-14T07:24:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-14T07:24:12Z"}, "message": "Rollup merge of #58347 - matthewjasper:closure-bounds-fixes, r=pnkfelix\n\nClosure bounds fixes\n\n* Ensures that \"nice region errors\" are buffered so that they are sorted and migrated correctly.\n* Propagates fewer constraints for closures (cc #58178)\n* Propagate constraints from closures more precisely (#58127)\n\nCloses #58127\n\nr? @nikomatsakis", "tree": {"sha": "1d1bae844e2ed3a8d7f4683a431855c91b7b71dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d1bae844e2ed3a8d7f4683a431855c91b7b71dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/975cdb57d019b32dc6fa31476cc42dca58aa5367", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcZRecCRBK7hj4Ov3rIwAAdHIIAF+pApXrx6xRJhnxbCgy1M8N\nvtVYOZAwKL2D767yzwW/8MIJv3IqaFO7R23zzwyX0CiPl86kyp3k38Yo4fE+cEAk\nKYk2jCHu8MMKQZGf3T//emzPGSbJhkzW+Jo82wN1QwnQxb/hhTcnAVJi4y2qIUG4\nCvZTnTXfNIhnsJriHnlbzpScipjEBTHnnQ+PL9kc5rKkybSpkfywv/Mrgz+1/LF+\nVJVT6ssK1X/CoIBHktmKLtLaUTnF7UzNV+jERZXDSq9y+m/l0TwKuPgnBI6R1fZf\nbC0ycQYnhvO+xCdfW/HpzMM1tEILPLrkpBn1BA+qXtFRXOsQbaOIo5c2Vit/tOA=\n=rmGe\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d1bae844e2ed3a8d7f4683a431855c91b7b71dd\nparent f9c9512628d3df8b24cb4a6982cfdefaef77ad51\nparent 79e8c311765df4c35558aa9683f1e2004719175a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550129052 +0100\ncommitter GitHub <noreply@github.com> 1550129052 +0100\n\nRollup merge of #58347 - matthewjasper:closure-bounds-fixes, r=pnkfelix\n\nClosure bounds fixes\n\n* Ensures that \"nice region errors\" are buffered so that they are sorted and migrated correctly.\n* Propagates fewer constraints for closures (cc #58178)\n* Propagate constraints from closures more precisely (#58127)\n\nCloses #58127\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/975cdb57d019b32dc6fa31476cc42dca58aa5367", "html_url": "https://github.com/rust-lang/rust/commit/975cdb57d019b32dc6fa31476cc42dca58aa5367", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/975cdb57d019b32dc6fa31476cc42dca58aa5367/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9c9512628d3df8b24cb4a6982cfdefaef77ad51", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c9512628d3df8b24cb4a6982cfdefaef77ad51", "html_url": "https://github.com/rust-lang/rust/commit/f9c9512628d3df8b24cb4a6982cfdefaef77ad51"}, {"sha": "79e8c311765df4c35558aa9683f1e2004719175a", "url": "https://api.github.com/repos/rust-lang/rust/commits/79e8c311765df4c35558aa9683f1e2004719175a", "html_url": "https://github.com/rust-lang/rust/commit/79e8c311765df4c35558aa9683f1e2004719175a"}], "stats": {"total": 346, "additions": 234, "deletions": 112}, "files": [{"sha": "d995fe92337c4f66d398b0bedaaf14f7f8db817d", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=975cdb57d019b32dc6fa31476cc42dca58aa5367", "patch": "@@ -1,9 +1,10 @@\n use crate::infer::InferCtxt;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n-use syntax::source_map::Span;\n use crate::ty::{self, TyCtxt};\n use crate::util::common::ErrorReported;\n+use errors::DiagnosticBuilder;\n+use syntax::source_map::Span;\n \n mod different_lifetimes;\n mod find_anon_type;\n@@ -59,7 +60,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn try_report_from_nll(&self) -> Option<ErrorReported> {\n+    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'cx>> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n         self.try_report_named_anon_conflict()\n@@ -68,6 +69,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n \n     pub fn try_report(&self) -> Option<ErrorReported> {\n         self.try_report_from_nll()\n+            .map(|mut diag| { diag.emit(); ErrorReported })\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_outlives_closure())\n             .or_else(|| self.try_report_static_impl_trait())"}, {"sha": "3821484d38e5f9bd291d33d2f79bd6eaca568988", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=975cdb57d019b32dc6fa31476cc42dca58aa5367", "patch": "@@ -2,13 +2,12 @@\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::ty;\n-use crate::util::common::ErrorReported;\n-use errors::Applicability;\n+use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n-    pub(super) fn try_report_named_anon_conflict(&self) -> Option<ErrorReported> {\n+    pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n         let (span, sub, sup) = self.get_regions();\n \n         debug!(\n@@ -96,21 +95,23 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             (\"parameter type\".to_owned(), \"type\".to_owned())\n         };\n \n-        struct_span_err!(\n+        let mut diag = struct_span_err!(\n             self.tcx().sess,\n             span,\n             E0621,\n             \"explicit lifetime required in {}\",\n             error_var\n-        ).span_suggestion(\n-            new_ty_span,\n-            &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n-            new_ty.to_string(),\n-            Applicability::Unspecified,\n-        )\n-        .span_label(span, format!(\"lifetime `{}` required\", named))\n-        .emit();\n-        return Some(ErrorReported);\n+        );\n+\n+        diag.span_suggestion(\n+                new_ty_span,\n+                &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n+                new_ty.to_string(),\n+                Applicability::Unspecified,\n+            )\n+            .span_label(span, format!(\"lifetime `{}` required\", named));\n+\n+        Some(diag)\n     }\n \n     // This method returns whether the given Region is Named"}, {"sha": "3b2fb7d41008e55ca2d3077876ffa6f87d13e5a6", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=975cdb57d019b32dc6fa31476cc42dca58aa5367", "patch": "@@ -8,13 +8,12 @@ use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty;\n use crate::ty::error::ExpectedFound;\n use crate::ty::subst::Substs;\n-use crate::util::common::ErrorReported;\n use crate::util::ppaux::RegionHighlightMode;\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit a descriptive diagnostic error.\n-    pub(super) fn try_report_placeholder_conflict(&self) -> Option<ErrorReported> {\n+    pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'me>> {\n         match &self.error {\n             ///////////////////////////////////////////////////////////////////////////\n             // NB. The ordering of cases in this match is very\n@@ -178,7 +177,7 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         trait_def_id: DefId,\n         expected_substs: &'tcx Substs<'tcx>,\n         actual_substs: &'tcx Substs<'tcx>,\n-    ) -> ErrorReported {\n+    ) -> DiagnosticBuilder<'me> {\n         debug!(\n             \"try_report_placeholders_trait(\\\n              vid={:?}, \\\n@@ -295,8 +294,7 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             any_self_ty_has_vid,\n         );\n \n-        err.emit();\n-        ErrorReported\n+        err\n     }\n \n     /// Add notes with details about the expected and actual trait refs, with attention to cases"}, {"sha": "081c458bfc17a37d821b7f544e8d7316fe85f9f1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=975cdb57d019b32dc6fa31476cc42dca58aa5367", "patch": "@@ -244,7 +244,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n             let nice = NiceRegionError::new_from_span(infcx, span, o, f, Some(tables));\n-            if let Some(_error_reported) = nice.try_report_from_nll() {\n+            if let Some(diag) = nice.try_report_from_nll() {\n+                diag.buffer(errors_buffer);\n                 return;\n             }\n         }"}, {"sha": "cbeb5dc206ee68d5754cbbe1f96e62c4f9f85fe9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 106, "deletions": 54, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=975cdb57d019b32dc6fa31476cc42dca58aa5367", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::{\n     ConstraintCategory, Local, Location, Mir,\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n-use rustc::util::common;\n+use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n@@ -763,20 +763,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             debug!(\"try_promote_type_test: ur={:?}\", ur);\n \n-            let non_local_ub = self.universal_region_relations.non_local_upper_bound(ur);\n+            let non_local_ub = self.universal_region_relations.non_local_upper_bounds(&ur);\n             debug!(\"try_promote_type_test: non_local_ub={:?}\", non_local_ub);\n \n-            assert!(self.universal_regions.is_universal_region(non_local_ub));\n-            assert!(!self.universal_regions.is_local_free_region(non_local_ub));\n-\n-            let requirement = ClosureOutlivesRequirement {\n-                subject,\n-                outlived_free_region: non_local_ub,\n-                blame_span: locations.span(mir),\n-                category: ConstraintCategory::Boring,\n-            };\n-            debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n-            propagated_outlives_requirements.push(requirement);\n+            // This is slightly too conservative. To show T: '1, given `'2: '1`\n+            // and `'3: '1` we only need to prove that T: '2 *or* T: '3, but to\n+            // avoid potential non-determinism we approximate this by requiring\n+            // T: '1 and T: '2.\n+            for &upper_bound in non_local_ub {\n+                debug_assert!(self.universal_regions.is_universal_region(upper_bound));\n+                debug_assert!(!self.universal_regions.is_local_free_region(upper_bound));\n+\n+                let requirement = ClosureOutlivesRequirement {\n+                    subject,\n+                    outlived_free_region: upper_bound,\n+                    blame_span: locations.span(mir),\n+                    category: ConstraintCategory::Boring,\n+                };\n+                debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n+                propagated_outlives_requirements.push(requirement);\n+            }\n         }\n         true\n     }\n@@ -1157,63 +1163,109 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .is_none()\n         );\n \n+        // Only check all of the relations for the main representative of each\n+        // SCC, otherwise just check that we outlive said representative. This\n+        // reduces the number of redundant relations propagated out of\n+        // closures.\n+        // Note that the representative will be a universal region if there is\n+        // one in this SCC, so we will always check the representative here.\n+        let representative = self.scc_representatives[longer_fr_scc];\n+        if representative != longer_fr {\n+            self.check_universal_region_relation(\n+                longer_fr,\n+                representative,\n+                infcx,\n+                mir,\n+                mir_def_id,\n+                propagated_outlives_requirements,\n+                errors_buffer,\n+            );\n+            return;\n+        }\n+\n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n-            // If it is known that `fr: o`, carry on.\n-            if self.universal_region_relations\n-                .outlives(longer_fr, shorter_fr)\n-            {\n-                continue;\n+            if let Some(ErrorReported) = self.check_universal_region_relation(\n+                longer_fr,\n+                shorter_fr,\n+                infcx,\n+                mir,\n+                mir_def_id,\n+                propagated_outlives_requirements,\n+                errors_buffer,\n+            ) {\n+                // continuing to iterate just reports more errors than necessary\n+                return;\n             }\n+        }\n+    }\n \n-            debug!(\n-                \"check_universal_region: fr={:?} does not outlive shorter_fr={:?}\",\n-                longer_fr, shorter_fr,\n-            );\n+    fn check_universal_region_relation(\n+        &self,\n+        longer_fr: RegionVid,\n+        shorter_fr: RegionVid,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+    ) -> Option<ErrorReported> {\n+        // If it is known that `fr: o`, carry on.\n+        if self.universal_region_relations\n+            .outlives(longer_fr, shorter_fr)\n+        {\n+            return None;\n+        }\n \n-            let blame_span_category = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n-\n-            if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n-                // Shrink `fr` until we find a non-local region (if we do).\n-                // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-                if let Some(fr_minus) = self.universal_region_relations\n-                    .non_local_lower_bound(longer_fr)\n-                {\n-                    debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n-\n-                    // Grow `shorter_fr` until we find a non-local\n-                    // region. (We always will.)  We'll call that\n-                    // `shorter_fr+` -- it's ever so slightly larger than\n-                    // `fr`.\n-                    let shorter_fr_plus = self.universal_region_relations\n-                        .non_local_upper_bound(shorter_fr);\n-                    debug!(\n-                        \"check_universal_region: shorter_fr_plus={:?}\",\n-                        shorter_fr_plus\n-                    );\n+        debug!(\n+            \"check_universal_region_relation: fr={:?} does not outlive shorter_fr={:?}\",\n+            longer_fr, shorter_fr,\n+        );\n \n+        if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n+            // Shrink `longer_fr` until we find a non-local region (if we do).\n+            // We'll call it `fr-` -- it's ever so slightly smaller than\n+            // `longer_fr`.\n+\n+            if let Some(fr_minus) = self\n+                .universal_region_relations\n+                .non_local_lower_bound(longer_fr)\n+            {\n+                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+\n+                let blame_span_category = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n+\n+                // Grow `shorter_fr` until we find some non-local regions. (We\n+                // always will.)  We'll call them `shorter_fr+` -- they're ever\n+                // so slightly larger than `shorter_fr`.\n+                let shorter_fr_plus = self.universal_region_relations\n+                    .non_local_upper_bounds(&shorter_fr);\n+                debug!(\n+                    \"check_universal_region: shorter_fr_plus={:?}\",\n+                    shorter_fr_plus\n+                );\n+                for &&fr in &shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n                         subject: ClosureOutlivesSubject::Region(fr_minus),\n-                        outlived_free_region: shorter_fr_plus,\n+                        outlived_free_region: fr,\n                         blame_span: blame_span_category.1,\n                         category: blame_span_category.0,\n                     });\n-                    continue;\n                 }\n+                return None;\n             }\n-\n-            // If we are not in a context where we can propagate\n-            // errors, or we could not shrink `fr` to something\n-            // smaller, then just report an error.\n-            //\n-            // Note: in this case, we use the unapproximated regions\n-            // to report the error. This gives better error messages\n-            // in some cases.\n-            self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n-            return; // continuing to iterate just reports more errors than necessary\n         }\n+\n+        // If we are not in a context where we can't propagate errors, or we\n+        // could not shrink `fr` to something smaller, then just report an\n+        // error.\n+        //\n+        // Note: in this case, we use the unapproximated regions to report the\n+        // error. This gives better error messages in some cases.\n+        self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        Some(ErrorReported)\n     }\n \n     fn check_bound_universal_region<'gcx>("}, {"sha": "3b663ef6dad61f44477edd99774b77e53bd99cce", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 65, "deletions": 37, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=975cdb57d019b32dc6fa31476cc42dca58aa5367", "patch": "@@ -105,44 +105,89 @@ impl UniversalRegionRelations<'tcx> {\n \n     /// Finds an \"upper bound\" for `fr` that is not local. In other\n     /// words, returns the smallest (*) known region `fr1` that (a)\n-    /// outlives `fr` and (b) is not local. This cannot fail, because\n-    /// we will always find `'static` at worst.\n+    /// outlives `fr` and (b) is not local.\n     ///\n-    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n-    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+    /// (*) If there are multiple competing choices, we return all of them.\n+    crate fn non_local_upper_bounds(&'a self, fr: &'a RegionVid) -> Vec<&'a RegionVid> {\n         debug!(\"non_local_upper_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.inverse_outlives, fr)\n+        let res = self.non_local_bounds(&self.inverse_outlives, fr);\n+        assert!(!res.is_empty(), \"can't find an upper bound!?\");\n+        res\n+    }\n+\n+    /// Returns the \"postdominating\" bound of the set of\n+    /// `non_local_upper_bounds` for the given region.\n+    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+        let upper_bounds = self.non_local_upper_bounds(&fr);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = self\n+            .inverse_outlives\n+            .mutual_immediate_postdominator(upper_bounds);\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom\n+            .and_then(|&post_dom| {\n+                // If the mutual immediate postdom is not local, then\n+                // there is no non-local result we can return.\n+                if !self.universal_regions.is_local_free_region(post_dom) {\n+                    Some(post_dom)\n+                } else {\n+                    None\n+                }\n+            })\n             .unwrap_or(self.universal_regions.fr_static)\n     }\n \n+\n     /// Finds a \"lower bound\" for `fr` that is not local. In other\n     /// words, returns the largest (*) known region `fr1` that (a) is\n-    /// outlived by `fr` and (b) is not local. This cannot fail,\n-    /// because we will always find `'static` at worst.\n+    /// outlived by `fr` and (b) is not local.\n     ///\n     /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n     /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n     crate fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n         debug!(\"non_local_lower_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.outlives, fr)\n+        let lower_bounds = self.non_local_bounds(&self.outlives, &fr);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = self\n+            .outlives\n+            .mutual_immediate_postdominator(lower_bounds);\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom\n+            .and_then(|&post_dom| {\n+                // If the mutual immediate postdom is not local, then\n+                // there is no non-local result we can return.\n+                if !self.universal_regions.is_local_free_region(post_dom) {\n+                    Some(post_dom)\n+                } else {\n+                    None\n+                }\n+            })\n     }\n \n-    /// Helper for `non_local_upper_bound` and\n-    /// `non_local_lower_bound`. Repeatedly invokes `postdom_parent`\n-    /// until we find something that is not local. Returns `None` if we\n-    /// never do so.\n-    fn non_local_bound(\n+    /// Helper for `non_local_upper_bounds` and `non_local_lower_bounds`.\n+    /// Repeatedly invokes `postdom_parent` until we find something that is not\n+    /// local. Returns `None` if we never do so.\n+    fn non_local_bounds<'a>(\n         &self,\n-        relation: &TransitiveRelation<RegionVid>,\n-        fr0: RegionVid,\n-    ) -> Option<RegionVid> {\n+        relation: &'a TransitiveRelation<RegionVid>,\n+        fr0: &'a RegionVid,\n+    ) -> Vec<&'a RegionVid> {\n         // This method assumes that `fr0` is one of the universally\n         // quantified region variables.\n-        assert!(self.universal_regions.is_universal_region(fr0));\n+        assert!(self.universal_regions.is_universal_region(*fr0));\n \n         let mut external_parents = vec![];\n-        let mut queue = vec![&fr0];\n+        let mut queue = vec![fr0];\n \n         // Keep expanding `fr` into its parents until we reach\n         // non-local regions.\n@@ -157,24 +202,7 @@ impl UniversalRegionRelations<'tcx> {\n \n         debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n \n-        // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = relation\n-            .mutual_immediate_postdominator(external_parents)\n-            .cloned();\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom.and_then(|post_dom| {\n-            // If the mutual immediate postdom is not local, then\n-            // there is no non-local result we can return.\n-            if !self.universal_regions.is_local_free_region(post_dom) {\n-                Some(post_dom)\n-            } else {\n-                None\n-            }\n-        })\n+        external_parents\n     }\n \n     /// Returns `true` if fr1 is known to outlive fr2."}, {"sha": "71d5d4053ee252cbb89de224860fef2a146cdfc6", "filename": "src/test/ui/nll/closure-requirements/issue-58127-mutliple-requirements.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975cdb57d019b32dc6fa31476cc42dca58aa5367/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fissue-58127-mutliple-requirements.rs?ref=975cdb57d019b32dc6fa31476cc42dca58aa5367", "patch": "@@ -0,0 +1,40 @@\n+// revisions: migrate nll\n+//[migrate]compile-flags: -Z borrowck=migrate\n+#![cfg_attr(nll, feature(nll))]\n+\n+// compile-pass\n+\n+// Test that we propagate region relations from closures precisely when there is\n+// more than one non-local lower bound.\n+\n+// In this case the closure has signature\n+// |x: &'4 mut (&'5 (&'1 str, &'2 str), &'3 str)| -> ..\n+// We end up with a `'3: '5` constraint that we can propagate as\n+// `'3: '1`, `'3: '2`, but previously we approximated it as `'3: 'static`.\n+\n+// As an optimization, we primarily propagate bounds for the \"representative\"\n+// of each SCC. As such we have these two similar cases where hopefully one\n+// of them will test the case we want (case2, when this test was added).\n+mod case1 {\n+    fn f(s: &str) {\n+        g(s, |x| h(x));\n+    }\n+\n+    fn g<T, F>(_: T, _: F)\n+    where F: Fn(&mut (&(T, T), T)) {}\n+\n+    fn h<T>(_: &mut (&(T, T), T)) {}\n+}\n+\n+mod case2 {\n+    fn f(s: &str) {\n+        g(s, |x| h(x));\n+    }\n+\n+    fn g<T, F>(_: T, _: F)\n+    where F: Fn(&mut (T, &(T, T))) {}\n+\n+    fn h<T>(_: &mut (T, &(T, T))) {}\n+}\n+\n+fn main() {}"}]}