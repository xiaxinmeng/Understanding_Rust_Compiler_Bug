{"sha": "8dc69ff9c48fcbdbe0b5be74eadee7f21e65ddcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYzY5ZmY5YzQ4ZmNiZGJlMGI1YmU3NGVhZGVlN2YyMWU2NWRkY2Q=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-07-13T14:45:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-13T14:45:17Z"}, "message": "Rollup merge of #43125 - aochagavia:stable_drop, r=arielb1\n\nAdd regression tests to ensure stable drop order\n\nWork towards #43034\n\nI think this is all we need to do on the testing front regarding RFC 1857", "tree": {"sha": "27bd2f34de47c1737af5e10743e994531ca1f89d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27bd2f34de47c1737af5e10743e994531ca1f89d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dc69ff9c48fcbdbe0b5be74eadee7f21e65ddcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc69ff9c48fcbdbe0b5be74eadee7f21e65ddcd", "html_url": "https://github.com/rust-lang/rust/commit/8dc69ff9c48fcbdbe0b5be74eadee7f21e65ddcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dc69ff9c48fcbdbe0b5be74eadee7f21e65ddcd/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f", "html_url": "https://github.com/rust-lang/rust/commit/3aaa809c7b9ce92f7cd96cc2d8fa4005934dd30f"}, {"sha": "f86e433b67292150faa9fd978cad487934d90c76", "url": "https://api.github.com/repos/rust-lang/rust/commits/f86e433b67292150faa9fd978cad487934d90c76", "html_url": "https://github.com/rust-lang/rust/commit/f86e433b67292150faa9fd978cad487934d90c76"}], "stats": {"total": 231, "additions": 231, "deletions": 0}, "files": [{"sha": "42f989538c89066a2ee37d4feeb6197a8e93fb12", "filename": "src/test/run-pass/rfc1857-drop-order.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/8dc69ff9c48fcbdbe0b5be74eadee7f21e65ddcd/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc69ff9c48fcbdbe0b5be74eadee7f21e65ddcd/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs?ref=8dc69ff9c48fcbdbe0b5be74eadee7f21e65ddcd", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code, unreachable_code)]\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+use std::panic::{self, AssertUnwindSafe, UnwindSafe};\n+\n+// This struct is used to record the order in which elements are dropped\n+struct PushOnDrop {\n+    vec: Rc<RefCell<Vec<u32>>>,\n+    val: u32\n+}\n+\n+impl PushOnDrop {\n+    fn new(val: u32, vec: Rc<RefCell<Vec<u32>>>) -> PushOnDrop {\n+        PushOnDrop { vec, val }\n+    }\n+}\n+\n+impl Drop for PushOnDrop {\n+    fn drop(&mut self) {\n+        self.vec.borrow_mut().push(self.val)\n+    }\n+}\n+\n+impl UnwindSafe for PushOnDrop { }\n+\n+// Structs\n+struct TestStruct {\n+    x: PushOnDrop,\n+    y: PushOnDrop,\n+    z: PushOnDrop\n+}\n+\n+// Tuple structs\n+struct TestTupleStruct(PushOnDrop, PushOnDrop, PushOnDrop);\n+\n+// Enum variants\n+enum TestEnum {\n+    Tuple(PushOnDrop, PushOnDrop, PushOnDrop),\n+    Struct { x: PushOnDrop, y: PushOnDrop, z: PushOnDrop }\n+}\n+\n+fn test_drop_tuple() {\n+    // Tuple fields are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple = (PushOnDrop::new(1, dropped_fields.clone()),\n+                      PushOnDrop::new(2, dropped_fields.clone()));\n+    drop(test_tuple);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Panic during construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        (PushOnDrop::new(2, cloned.clone()),\n+         PushOnDrop::new(1, cloned.clone()),\n+         panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_struct() {\n+    // Struct fields are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_struct = TestStruct {\n+        x: PushOnDrop::new(1, dropped_fields.clone()),\n+        y: PushOnDrop::new(2, dropped_fields.clone()),\n+        z: PushOnDrop::new(3, dropped_fields.clone()),\n+    };\n+    drop(test_struct);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for tuple structs\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple_struct = TestTupleStruct(PushOnDrop::new(1, dropped_fields.clone()),\n+                                            PushOnDrop::new(2, dropped_fields.clone()),\n+                                            PushOnDrop::new(3, dropped_fields.clone()));\n+    drop(test_tuple_struct);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during struct construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestStruct {\n+            x: PushOnDrop::new(2, cloned.clone()),\n+            y: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Test with different initialization order\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestStruct {\n+            y: PushOnDrop::new(2, cloned.clone()),\n+            x: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for tuple structs\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestTupleStruct(PushOnDrop::new(2, cloned.clone()),\n+                        PushOnDrop::new(1, cloned.clone()),\n+                        panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_enum() {\n+    // Enum variants are dropped in the same order they are declared\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_struct_enum = TestEnum::Struct {\n+        x: PushOnDrop::new(1, dropped_fields.clone()),\n+        y: PushOnDrop::new(2, dropped_fields.clone()),\n+        z: PushOnDrop::new(3, dropped_fields.clone())\n+    };\n+    drop(test_struct_enum);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for tuple enum variants\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let test_tuple_enum = TestEnum::Tuple(PushOnDrop::new(1, dropped_fields.clone()),\n+                                          PushOnDrop::new(2, dropped_fields.clone()),\n+                                          PushOnDrop::new(3, dropped_fields.clone()));\n+    drop(test_tuple_enum);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during enum construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Struct {\n+            x: PushOnDrop::new(2, cloned.clone()),\n+            y: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // Test with different initialization order\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Struct {\n+            y: PushOnDrop::new(2, cloned.clone()),\n+            x: PushOnDrop::new(1, cloned.clone()),\n+            z: panic!(\"this panic is catched :D\")\n+        };\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for tuple enum variants\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        TestEnum::Tuple(PushOnDrop::new(2, cloned.clone()),\n+                        PushOnDrop::new(1, cloned.clone()),\n+                        panic!(\"this panic is catched :D\"));\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn test_drop_list() {\n+    // Elements in a Vec are dropped in the same order they are pushed\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let xs = vec![PushOnDrop::new(1, dropped_fields.clone()),\n+                  PushOnDrop::new(2, dropped_fields.clone()),\n+                  PushOnDrop::new(3, dropped_fields.clone())];\n+    drop(xs);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // The same holds for arrays\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let xs = [PushOnDrop::new(1, dropped_fields.clone()),\n+              PushOnDrop::new(2, dropped_fields.clone()),\n+              PushOnDrop::new(3, dropped_fields.clone())];\n+    drop(xs);\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2, 3]);\n+\n+    // Panic during vec construction means that fields are treated as local variables\n+    // Therefore they are dropped in reverse order of initialization\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        vec![\n+            PushOnDrop::new(2, cloned.clone()),\n+            PushOnDrop::new(1, cloned.clone()),\n+            panic!(\"this panic is catched :D\")\n+        ];\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+\n+    // The same holds for arrays\n+    let dropped_fields = Rc::new(RefCell::new(Vec::new()));\n+    let cloned = AssertUnwindSafe(dropped_fields.clone());\n+    panic::catch_unwind(|| {\n+        [\n+            PushOnDrop::new(2, cloned.clone()),\n+            PushOnDrop::new(1, cloned.clone()),\n+            panic!(\"this panic is catched :D\")\n+        ];\n+    }).err().unwrap();\n+    assert_eq!(*dropped_fields.borrow(), &[1, 2]);\n+}\n+\n+fn main() {\n+    test_drop_tuple();\n+    test_drop_struct();\n+    test_drop_enum();\n+    test_drop_list();\n+}"}]}