{"sha": "0143774cb5c21b18bf599b1726e122785c0de452", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxNDM3NzRjYjVjMjFiMThiZjU5OWIxNzI2ZTEyMjc4NWMwZGU0NTI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-02-18T06:18:29Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-03T01:52:48Z"}, "message": "Remove lifetime parameter from `syntax::tokenstream::Cursor`.", "tree": {"sha": "46525c253827fb48a17df0c4a1e51d4e72d73ba6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46525c253827fb48a17df0c4a1e51d4e72d73ba6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0143774cb5c21b18bf599b1726e122785c0de452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0143774cb5c21b18bf599b1726e122785c0de452", "html_url": "https://github.com/rust-lang/rust/commit/0143774cb5c21b18bf599b1726e122785c0de452", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0143774cb5c21b18bf599b1726e122785c0de452/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0b7112ba246d96f253ba845d91f36c0b7398e42", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7112ba246d96f253ba845d91f36c0b7398e42", "html_url": "https://github.com/rust-lang/rust/commit/c0b7112ba246d96f253ba845d91f36c0b7398e42"}], "stats": {"total": 74, "additions": 40, "deletions": 34}, "files": [{"sha": "b9bf35cff07b4e44e5fdbe5c7d5c6be055b30c9c", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0143774cb5c21b18bf599b1726e122785c0de452/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0143774cb5c21b18bf599b1726e122785c0de452/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=0143774cb5c21b18bf599b1726e122785c0de452", "patch": "@@ -51,7 +51,7 @@ macro_rules! quote_tree {\n fn delimit(delim: token::DelimToken, stream: TokenStream) -> TokenStream {\n     TokenTree::Delimited(DUMMY_SP, Rc::new(Delimited {\n         delim: delim,\n-        tts: stream.trees().cloned().collect(),\n+        tts: stream.into_trees().collect(),\n     })).into()\n }\n \n@@ -75,21 +75,21 @@ impl Quote for TokenStream {\n             return quote!(::syntax::tokenstream::TokenStream::empty());\n         }\n \n-        struct Quote<'a>(tokenstream::Cursor<'a>);\n+        struct Quote(tokenstream::Cursor);\n \n-        impl<'a> Iterator for Quote<'a> {\n+        impl Iterator for Quote {\n             type Item = TokenStream;\n \n             fn next(&mut self) -> Option<TokenStream> {\n                 let is_unquote = match self.0.peek() {\n-                    Some(&TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"unquote\" => {\n+                    Some(TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"unquote\" => {\n                         self.0.next();\n                         true\n                     }\n                     _ => false,\n                 };\n \n-                self.0.next().cloned().map(|tree| {\n+                self.0.next().map(|tree| {\n                     let quoted_tree = if is_unquote { tree.into() } else { tree.quote() };\n                     quote!(::syntax::tokenstream::TokenStream::from((unquote quoted_tree)),)\n                 })\n@@ -104,7 +104,7 @@ impl Quote for TokenStream {\n impl Quote for Vec<TokenTree> {\n     fn quote(&self) -> TokenStream {\n         let stream = self.iter().cloned().collect::<TokenStream>();\n-        quote!((quote stream).trees().cloned().collect::<::std::vec::Vec<_> >())\n+        quote!((quote stream).into_trees().collect::<::std::vec::Vec<_> >())\n     }\n }\n "}, {"sha": "8107696b8b920212e4ed42bf4f821d78baf9f36c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0143774cb5c21b18bf599b1726e122785c0de452/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0143774cb5c21b18bf599b1726e122785c0de452/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0143774cb5c21b18bf599b1726e122785c0de452", "patch": "@@ -647,7 +647,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, name: Name, span: Span)\n                        -> Expansion {\n-        let mut parser = self.cx.new_parser_from_tts(&toks.trees().cloned().collect::<Vec<_>>());\n+        let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n         let expansion = match parser.parse_expansion(kind, false) {\n             Ok(expansion) => expansion,\n             Err(mut err) => {"}, {"sha": "f783e32d621040f02fb38682dc06ec38a5f47b26", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0143774cb5c21b18bf599b1726e122785c0de452/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0143774cb5c21b18bf599b1726e122785c0de452/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0143774cb5c21b18bf599b1726e122785c0de452", "patch": "@@ -192,7 +192,7 @@ pub fn new_parser_from_tts<'a>(sess: &'a ParseSess, tts: Vec<tokenstream::TokenT\n }\n \n pub fn new_parser_from_ts<'a>(sess: &'a ParseSess, ts: tokenstream::TokenStream) -> Parser<'a> {\n-    tts_to_parser(sess, ts.trees().cloned().collect())\n+    tts_to_parser(sess, ts.into_trees().collect())\n }\n \n "}, {"sha": "0f973540edb5a8f9529a6d1f516b34259f3504c5", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0143774cb5c21b18bf599b1726e122785c0de452/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0143774cb5c21b18bf599b1726e122785c0de452/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=0143774cb5c21b18bf599b1726e122785c0de452", "patch": "@@ -35,7 +35,7 @@ use serialize::{Decoder, Decodable, Encoder, Encodable};\n use symbol::Symbol;\n use util::RcSlice;\n \n-use std::{fmt, iter};\n+use std::{fmt, iter, mem};\n use std::rc::Rc;\n \n /// A delimited sequence of token trees\n@@ -338,87 +338,93 @@ impl TokenStream {\n         TokenStream { kind: TokenStreamKind::Stream(RcSlice::new(vec)) }\n     }\n \n-    pub fn trees<'a>(&'a self) -> Cursor {\n+    pub fn trees(&self) -> Cursor {\n+        self.clone().into_trees()\n+    }\n+\n+    pub fn into_trees(self) -> Cursor {\n         Cursor::new(self)\n     }\n \n     /// Compares two TokenStreams, checking equality without regarding span information.\n     pub fn eq_unspanned(&self, other: &TokenStream) -> bool {\n         for (t1, t2) in self.trees().zip(other.trees()) {\n-            if !t1.eq_unspanned(t2) {\n+            if !t1.eq_unspanned(&t2) {\n                 return false;\n             }\n         }\n         true\n     }\n }\n \n-pub struct Cursor<'a> {\n-    current_frame: CursorFrame<'a>,\n-    stack: Vec<CursorFrame<'a>>,\n+pub struct Cursor {\n+    current_frame: CursorFrame,\n+    stack: Vec<CursorFrame>,\n }\n \n-impl<'a> Iterator for Cursor<'a> {\n-    type Item = &'a TokenTree;\n+impl Iterator for Cursor {\n+    type Item = TokenTree;\n \n-    fn next(&mut self) -> Option<&'a TokenTree> {\n+    fn next(&mut self) -> Option<TokenTree> {\n         let tree = self.peek();\n         self.current_frame = self.stack.pop().unwrap_or(CursorFrame::Empty);\n         tree\n     }\n }\n \n-enum CursorFrame<'a> {\n+enum CursorFrame {\n     Empty,\n-    Tree(&'a TokenTree),\n-    Stream(&'a RcSlice<TokenStream>, usize),\n+    Tree(TokenTree),\n+    Stream(RcSlice<TokenStream>, usize),\n }\n \n-impl<'a> CursorFrame<'a> {\n-    fn new(stream: &'a TokenStream) -> Self {\n+impl CursorFrame {\n+    fn new(stream: TokenStream) -> Self {\n         match stream.kind {\n             TokenStreamKind::Empty => CursorFrame::Empty,\n-            TokenStreamKind::Tree(ref tree) => CursorFrame::Tree(tree),\n-            TokenStreamKind::Stream(ref stream) => CursorFrame::Stream(stream, 0),\n+            TokenStreamKind::Tree(tree) => CursorFrame::Tree(tree),\n+            TokenStreamKind::Stream(stream) => CursorFrame::Stream(stream, 0),\n         }\n     }\n }\n \n-impl<'a> Cursor<'a> {\n-    fn new(stream: &'a TokenStream) -> Self {\n+impl Cursor {\n+    fn new(stream: TokenStream) -> Self {\n         Cursor {\n             current_frame: CursorFrame::new(stream),\n             stack: Vec::new(),\n         }\n     }\n \n-    pub fn peek(&mut self) -> Option<&'a TokenTree> {\n-        while let CursorFrame::Stream(stream, index) = self.current_frame {\n+    pub fn peek(&mut self) -> Option<TokenTree> {\n+        while let CursorFrame::Stream(stream, index) =\n+                mem::replace(&mut self.current_frame, CursorFrame::Empty) {\n             self.current_frame = if index == stream.len() {\n                 self.stack.pop().unwrap_or(CursorFrame::Empty)\n             } else {\n+                let frame = CursorFrame::new(stream[index].clone());\n                 self.stack.push(CursorFrame::Stream(stream, index + 1));\n-                CursorFrame::new(&stream[index])\n+                frame\n             };\n         }\n \n         match self.current_frame {\n             CursorFrame::Empty => None,\n-            CursorFrame::Tree(tree) => Some(tree),\n+            CursorFrame::Tree(ref tree) => Some(tree.clone()),\n             CursorFrame::Stream(..) => unreachable!(),\n         }\n     }\n }\n \n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(&pprust::tts_to_string(&self.trees().cloned().collect::<Vec<_>>()))\n+        f.write_str(&pprust::tts_to_string(&self.trees().collect::<Vec<_>>()))\n     }\n }\n \n impl Encodable for TokenStream {\n     fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        self.trees().cloned().collect::<Vec<_>>().encode(encoder)\n+        self.trees().collect::<Vec<_>>().encode(encoder)\n     }\n }\n \n@@ -464,14 +470,14 @@ mod tests {\n     fn test_from_to_bijection() {\n         let test_start = string_to_tts(\"foo::bar(baz)\".to_string());\n         let ts = test_start.iter().cloned().collect::<TokenStream>();\n-        let test_end: Vec<TokenTree> = ts.trees().cloned().collect();\n+        let test_end: Vec<TokenTree> = ts.trees().collect();\n         assert_eq!(test_start, test_end)\n     }\n \n     #[test]\n     fn test_to_from_bijection() {\n         let test_start = string_to_ts(\"foo::bar(baz)\");\n-        let test_end = test_start.trees().cloned().collect();\n+        let test_end = test_start.trees().collect();\n         assert_eq!(test_start, test_end)\n     }\n "}]}