{"sha": "999d76812cc2403568a2c5740be3474d5f8fc36f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5OWQ3NjgxMmNjMjQwMzU2OGEyYzU3NDBiZTM0NzRkNWY4ZmMzNmY=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-09-28T15:32:22Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-09-29T12:57:41Z"}, "message": "rustc/infer: improve vector allocations", "tree": {"sha": "d6506c48e39ca337f4695082ac46a7925ea70ff1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6506c48e39ca337f4695082ac46a7925ea70ff1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/999d76812cc2403568a2c5740be3474d5f8fc36f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/999d76812cc2403568a2c5740be3474d5f8fc36f", "html_url": "https://github.com/rust-lang/rust/commit/999d76812cc2403568a2c5740be3474d5f8fc36f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/999d76812cc2403568a2c5740be3474d5f8fc36f/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e84647e18181ea9aa199d42b3da598eb59ab70c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e84647e18181ea9aa199d42b3da598eb59ab70c", "html_url": "https://github.com/rust-lang/rust/commit/0e84647e18181ea9aa199d42b3da598eb59ab70c"}], "stats": {"total": 72, "additions": 37, "deletions": 35}, "files": [{"sha": "f70064e07162968d71c423b7f5c3800e740f0300", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/999d76812cc2403568a2c5740be3474d5f8fc36f/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999d76812cc2403568a2c5740be3474d5f8fc36f/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=999d76812cc2403568a2c5740be3474d5f8fc36f", "patch": "@@ -310,16 +310,18 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // ...also include the other query region constraints from the query.\n-        output_query_region_constraints.reserve(query_result.value.region_constraints.len());\n-        for r_c in query_result.value.region_constraints.iter() {\n-            let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n-            let k1 = substitute_value(self.tcx, &result_subst, &k1);\n-            let r2 = substitute_value(self.tcx, &result_subst, &r2);\n-            if k1 != r2.into() {\n-                output_query_region_constraints\n-                    .push(ty::Binder::bind(ty::OutlivesPredicate(k1, r2)));\n-            }\n-        }\n+        output_query_region_constraints.extend(\n+            query_result.value.region_constraints.iter().filter_map(|r_c| {\n+                let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n+                let k1 = substitute_value(self.tcx, &result_subst, &k1);\n+                let r2 = substitute_value(self.tcx, &result_subst, &r2);\n+                if k1 != r2.into() {\n+                    Some(ty::Binder::bind(ty::OutlivesPredicate(k1, r2)))\n+                } else {\n+                    None\n+                }\n+            })\n+        );\n \n         let user_result: R =\n             query_result.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n@@ -576,31 +578,30 @@ pub fn make_query_outlives<'tcx>(\n     assert!(verifys.is_empty());\n     assert!(givens.is_empty());\n \n-    let mut outlives: Vec<_> = constraints\n-            .into_iter()\n-            .map(|(k, _)| match *k {\n-                // Swap regions because we are going from sub (<=) to outlives\n-                // (>=).\n-                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                    tcx.mk_region(ty::ReVar(v2)).into(),\n-                    tcx.mk_region(ty::ReVar(v1)),\n-                ),\n-                Constraint::VarSubReg(v1, r2) => {\n-                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-                }\n-                Constraint::RegSubVar(r1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-                }\n-                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n-            })\n-            .map(ty::Binder::dummy) // no bound regions in the code above\n-            .collect();\n-\n-    outlives.extend(\n-        outlives_obligations\n-            .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n-            .map(ty::Binder::dummy), // no bound regions in the code above\n-    );\n+    let outlives: Vec<_> = constraints\n+        .into_iter()\n+        .map(|(k, _)| match *k {\n+            // Swap regions because we are going from sub (<=) to outlives\n+            // (>=).\n+            Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                tcx.mk_region(ty::ReVar(v2)).into(),\n+                tcx.mk_region(ty::ReVar(v1)),\n+            ),\n+            Constraint::VarSubReg(v1, r2) => {\n+                ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+            }\n+            Constraint::RegSubVar(r1, v2) => {\n+                ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+            }\n+            Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+        })\n+        .map(ty::Binder::dummy) // no bound regions in the code above\n+        .chain(\n+            outlives_obligations\n+                .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n+                .map(ty::Binder::dummy), // no bound regions in the code above\n+        )\n+        .collect();\n \n     outlives\n }"}, {"sha": "d365992aef5006f15deb01212ae7ac7c80153e44", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/999d76812cc2403568a2c5740be3474d5f8fc36f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/999d76812cc2403568a2c5740be3474d5f8fc36f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=999d76812cc2403568a2c5740be3474d5f8fc36f", "patch": "@@ -803,6 +803,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         );\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n+        self.obligations.reserve(bounds.predicates.len());\n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,\n             // which will be the concrete type instead of the opaque type."}]}