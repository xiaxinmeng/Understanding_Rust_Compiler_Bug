{"sha": "d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzN2EwN2ZmYmVmZDY3NzJhNjhjMjVmMThkMzVhN2ZlNWI4Mjk0MmU=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-06-22T05:58:17Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-06-25T01:45:29Z"}, "message": "fixup! 2229: Capture box completely in move closures\n\nfixup! 2229: Capture box completely in move closures", "tree": {"sha": "172b9ef77deeae5b95899bb5326fb4c2b6279a57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/172b9ef77deeae5b95899bb5326fb4c2b6279a57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "html_url": "https://github.com/rust-lang/rust/commit/d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d37a07ffbefd6772a68c25f18d35a7fe5b82942e/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de2052af9cf7ac83da6a825701e32bd0e4aa9a85", "url": "https://api.github.com/repos/rust-lang/rust/commits/de2052af9cf7ac83da6a825701e32bd0e4aa9a85", "html_url": "https://github.com/rust-lang/rust/commit/de2052af9cf7ac83da6a825701e32bd0e4aa9a85"}], "stats": {"total": 66, "additions": 36, "deletions": 30}, "files": [{"sha": "581aa087be9e769f90e497330ef4c54d9d9ab8a9", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d37a07ffbefd6772a68c25f18d35a7fe5b82942e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37a07ffbefd6772a68c25f18d35a7fe5b82942e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         self.log_capture_analysis_first_pass(closure_def_id, &delegate.capture_information, span);\n \n-        self.compute_min_captures(closure_def_id, delegate.capture_information);\n+        self.compute_min_captures(closure_def_id, capture_clause, delegate.capture_information);\n \n         let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n \n@@ -200,7 +200,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // This will update the min captures based on this new fake information.\n-            self.compute_min_captures(closure_def_id, capture_information);\n+            self.compute_min_captures(closure_def_id, capture_clause, capture_information);\n         }\n \n         if let Some(closure_substs) = infer_kind {\n@@ -213,7 +213,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If we have an origin, store it.\n             if let Some(origin) = delegate.current_origin.clone() {\n                 let origin = if enable_precise_capture(self.tcx, span) {\n-                    (origin.0, restrict_capture_precision(origin.1))\n+                    (origin.0, restrict_capture_precision(capture_clause, origin.1))\n                 } else {\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n                 };\n@@ -368,6 +368,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn compute_min_captures(\n         &self,\n         closure_def_id: DefId,\n+        capture_clause: hir::CaptureBy,\n         capture_information: InferredCaptureInformation<'tcx>,\n     ) {\n         if capture_information.is_empty() {\n@@ -385,7 +386,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let place = restrict_capture_precision(place);\n+            let place = restrict_capture_precision(capture_clause, place);\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n@@ -1590,7 +1591,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(_) = place.base {\n             // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n             // such as deref of a raw pointer.\n-            let place = restrict_capture_precision(place);\n+            let place = restrict_capture_precision(self.capture_clause, place);\n             let place =\n                 restrict_repr_packed_field_ref_capture(self.fcx.tcx, self.fcx.param_env, &place);\n             self.fake_reads.push((place, cause, diag_expr_id));\n@@ -1625,19 +1626,16 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, bk\n         );\n \n+        // We only want repr packed restriction to be applied to reading references into a packed\n+        // struct, and not when the data is being moved. There for we call this method here instead\n+        // of in `restrict_capture_precision`.\n         let place = restrict_repr_packed_field_ref_capture(\n             self.fcx.tcx,\n             self.fcx.param_env,\n             &place_with_id.place,\n         );\n \n-        let place = restrict_preicision_for_box(&place, self.capture_clause);\n-\n         let place_with_id = PlaceWithHirId { place, ..*place_with_id };\n-        debug!(\n-            \"borrow after restrictions:(place_with_id={:?}, diag_expr_id={:?}, bk={:?})\",\n-            place_with_id, diag_expr_id, bk\n-        );\n \n         if !self.capture_information.contains_key(&place_with_id.place) {\n             self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n@@ -1661,39 +1659,46 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n-// In case of move closures we don't want to capture derefs on a box.\n-// This is motivated by:\n-//   1. We only want to capture data that is on the stack\n-//   2. One motivatiton for the user to use a box might be to reduce the amount of data that gets\n-//      moved (if size of pointer < size of data). We want to make sure that this optimization that\n-//      the user made is respected.\n-fn restrict_preicision_for_box(place: &Place<'tcx>, capture_by: hir::CaptureBy) -> Place<'tcx> {\n-    let mut rv = place.clone();\n-    match capture_by {\n-        hir::CaptureBy::Ref => rv,\n+/// Deref of a box isn't captured in move clousres. This is motivated by:\n+///   1. We only want to capture data that is on the stack\n+///   2. One motivation for the user to use a box might be to reduce the amount of data that gets\n+///      moved (if size of pointer < size of data). We want to make sure that this optimization that\n+///      the user made is respected.\n+fn restrict_precision_for_box<'tcx>(\n+    capture_clause: hir::CaptureBy,\n+    mut place: Place<'tcx>,\n+) -> Place<'tcx> {\n+    match capture_clause {\n+        hir::CaptureBy::Ref => {}\n         hir::CaptureBy::Value => {\n             if ty::TyS::is_box(place.base_ty) {\n-                Place { projections: Vec::new(), ..rv }\n+                place.projections.truncate(0);\n             } else {\n                 // Either the box is the last access or there is a deref applied on the box\n                 // In either case we want to stop at the box.\n                 let pos = place.projections.iter().position(|proj| ty::TyS::is_box(proj.ty));\n                 match pos {\n-                    None => rv,\n+                    None => {}\n                     Some(idx) => {\n-                        Place { projections: rv.projections.drain(0..=idx).collect(), ..rv }\n+                        place.projections.truncate(idx + 1);\n                     }\n                 }\n             }\n         }\n     }\n+\n+    place\n }\n \n /// Truncate projections so that following rules are obeyed by the captured `place`:\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No Index projections are captured, since arrays are captured completely.\n-fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n+/// - Deref of a box isn't captured in move clousres.\n+fn restrict_capture_precision<'tcx>(\n+    capture_clause: hir::CaptureBy,\n+    mut place: Place<'tcx>,\n+) -> Place<'tcx> {\n     if place.projections.is_empty() {\n         // Nothing to do here\n         return place;\n@@ -1728,7 +1733,8 @@ fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n \n     place.projections.truncate(length);\n \n-    place\n+    // Dont't capture projections on top of a box in move closures.\n+    restrict_precision_for_box(capture_clause, place)\n }\n \n /// Truncates a place so that the resultant capture doesn't move data out of a reference"}, {"sha": "f96370eb2031548cb29a3e2d9a129142f02bca80", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d37a07ffbefd6772a68c25f18d35a7fe5b82942e/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d37a07ffbefd6772a68c25f18d35a7fe5b82942e/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "patch": "@@ -141,7 +141,7 @@ fn truncate_box_derefs() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         println!(\"{}\", b.0);\n-        //~^ NOTE: Capturing b[] -> ByValue\n+        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ByValue\n         //~| NOTE: Min Capture b[] -> ByValue\n     };\n \n@@ -158,7 +158,7 @@ fn truncate_box_derefs() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         println!(\"{}\", t.1.0);\n-        //~^ NOTE: Capturing t[(1, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(1, 0),Deref,(0, 0)] -> ByValue\n         //~| NOTE: Min Capture t[(1, 0)] -> ByValue\n     };\n }"}, {"sha": "82aa7ab891260d0d9b2739a71c9ef1235d5b418e", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d37a07ffbefd6772a68c25f18d35a7fe5b82942e/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d37a07ffbefd6772a68c25f18d35a7fe5b82942e/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=d37a07ffbefd6772a68c25f18d35a7fe5b82942e", "patch": "@@ -317,7 +317,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing b[] -> ByValue\n+note: Capturing b[Deref,(0, 0)] -> ByValue\n   --> $DIR/move_closure.rs:143:24\n    |\n LL |         println!(\"{}\", b.0);\n@@ -353,7 +353,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(1, 0)] -> ByValue\n+note: Capturing t[(1, 0),Deref,(0, 0)] -> ByValue\n   --> $DIR/move_closure.rs:160:24\n    |\n LL |         println!(\"{}\", t.1.0);"}]}