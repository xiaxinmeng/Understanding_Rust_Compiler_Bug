{"sha": "3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "node_id": "C_kwDOAAsO6NoAKDMyODhkM2EzMDVhZDE1Y2ZjZGNkOWVmNzI0MDRiZTZkMmEyODg3YjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-26T00:17:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-26T00:17:59Z"}, "message": "Auto merge of #101785 - jyn514:query-struct-fn-ptrs, r=cjgillot\n\nUse function pointers instead of macro-unrolled loops in rustc_query_impl\n\nBy making these standalone functions, we\na) allow making them extensible in the future with a new `QueryStruct`\nb) greatly decrease the amount of code in each individual function, avoiding exponential blowup in llvm\n\nHelps with https://github.com/rust-lang/rust/issues/96524. Based on https://github.com/rust-lang/rust/pull/101173; only the last commit is relevant.\n\nr? `@cjgillot`", "tree": {"sha": "4d3cfca921d1a813178dafded888a8c20c3e67bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d3cfca921d1a813178dafded888a8c20c3e67bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "html_url": "https://github.com/rust-lang/rust/commit/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff40f2ec95923c4d45366e85bcff17d75df68d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff40f2ec95923c4d45366e85bcff17d75df68d68", "html_url": "https://github.com/rust-lang/rust/commit/ff40f2ec95923c4d45366e85bcff17d75df68d68"}, {"sha": "7a8369096c27312b1beda84c8f5c2ab207d8a3c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a8369096c27312b1beda84c8f5c2ab207d8a3c7", "html_url": "https://github.com/rust-lang/rust/commit/7a8369096c27312b1beda84c8f5c2ab207d8a3c7"}], "stats": {"total": 151, "additions": 95, "deletions": 56}, "files": [{"sha": "8e018d3e4a4bcdd1ae9bce4b9746220679718983", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "patch": "@@ -1,6 +1,8 @@\n //! Support for serializing the dep-graph and reloading it.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+// this shouldn't be necessary, but the check for `&mut _` is too naive and denies returning a function pointer that takes a mut ref\n+#![feature(const_mut_refs)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(once_cell)]"}, {"sha": "2b3850bc0dfb5a4177ad3934cd05daaedf70b39d", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 86, "deletions": 38, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "patch": "@@ -3,7 +3,8 @@\n //! manage the caches, and so forth.\n \n use crate::keys::Key;\n-use crate::on_disk_cache::CacheDecoder;\n+use crate::on_disk_cache::{CacheDecoder, CacheEncoder, EncodedDepNodeIndex};\n+use crate::profiling_support::QueryKeyStringCache;\n use crate::{on_disk_cache, Queries};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{AtomicU64, Lock};\n@@ -173,34 +174,14 @@ impl<'tcx> QueryCtxt<'tcx> {\n \n     pub(super) fn encode_query_results(\n         self,\n-        encoder: &mut on_disk_cache::CacheEncoder<'_, 'tcx>,\n-        query_result_index: &mut on_disk_cache::EncodedDepNodeIndex,\n+        encoder: &mut CacheEncoder<'_, 'tcx>,\n+        query_result_index: &mut EncodedDepNodeIndex,\n     ) {\n-        macro_rules! expand_if_cached {\n-            ([] $encode:expr) => {};\n-            ([(cache) $($rest:tt)*] $encode:expr) => {\n-                $encode\n-            };\n-            ([$other:tt $($modifiers:tt)*] $encode:expr) => {\n-                expand_if_cached!([$($modifiers)*] $encode)\n-            };\n-        }\n-\n-        macro_rules! encode_queries {\n-            (\n-            $($(#[$attr:meta])*\n-                [$($modifiers:tt)*] fn $query:ident($($K:tt)*) -> $V:ty,)*) => {\n-                $(\n-                    expand_if_cached!([$($modifiers)*] on_disk_cache::encode_query_results::<_, super::queries::$query<'_>>(\n-                        self,\n-                        encoder,\n-                        query_result_index\n-                    ));\n-                )*\n+        for query in &self.queries.query_structs {\n+            if let Some(encode) = query.encode_query_results {\n+                encode(self, encoder, query_result_index);\n             }\n         }\n-\n-        rustc_query_append!(encode_queries!);\n     }\n \n     pub fn try_print_query_stack(\n@@ -213,6 +194,14 @@ impl<'tcx> QueryCtxt<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy)]\n+pub(crate) struct QueryStruct<'tcx> {\n+    pub try_collect_active_jobs: fn(QueryCtxt<'tcx>, &mut QueryMap) -> Option<()>,\n+    pub alloc_self_profile_query_strings: fn(TyCtxt<'tcx>, &mut QueryKeyStringCache),\n+    pub encode_query_results:\n+        Option<fn(QueryCtxt<'tcx>, &mut CacheEncoder<'_, 'tcx>, &mut EncodedDepNodeIndex)>,\n+}\n+\n macro_rules! handle_cycle_error {\n     ([]) => {{\n         rustc_query_system::HandleCycleError::Error\n@@ -438,6 +427,18 @@ where\n     }\n }\n \n+macro_rules! expand_if_cached {\n+    ([], $tokens:expr) => {{\n+        None\n+    }};\n+    ([(cache) $($rest:tt)*], $tokens:expr) => {{\n+        Some($tokens)\n+    }};\n+    ([$other:tt $($modifiers:tt)*], $tokens:expr) => {\n+        expand_if_cached!([$($modifiers)*], $tokens)\n+    };\n+}\n+\n // NOTE: `$V` isn't used here, but we still need to match on it so it can be passed to other macros\n // invoked by `rustc_query_append`.\n macro_rules! define_queries {\n@@ -571,6 +572,59 @@ macro_rules! define_queries {\n             })*\n         }\n \n+        mod query_structs {\n+            use rustc_middle::ty::TyCtxt;\n+            use $crate::plumbing::{QueryStruct, QueryCtxt};\n+            use $crate::profiling_support::QueryKeyStringCache;\n+            use rustc_query_system::query::{QueryDescription, QueryMap};\n+\n+            pub(super) const fn dummy_query_struct<'tcx>() -> QueryStruct<'tcx> {\n+                fn noop_try_collect_active_jobs(_: QueryCtxt<'_>, _: &mut QueryMap) -> Option<()> {\n+                    None\n+                }\n+                fn noop_alloc_self_profile_query_strings(_: TyCtxt<'_>, _: &mut QueryKeyStringCache) {}\n+\n+                QueryStruct {\n+                    try_collect_active_jobs: noop_try_collect_active_jobs,\n+                    alloc_self_profile_query_strings: noop_alloc_self_profile_query_strings,\n+                    encode_query_results: None,\n+                }\n+            }\n+\n+            pub(super) use dummy_query_struct as Null;\n+            pub(super) use dummy_query_struct as Red;\n+            pub(super) use dummy_query_struct as TraitSelect;\n+            pub(super) use dummy_query_struct as CompileCodegenUnit;\n+            pub(super) use dummy_query_struct as CompileMonoItem;\n+\n+            $(\n+            pub(super) const fn $name<'tcx>() -> QueryStruct<'tcx> { QueryStruct {\n+                try_collect_active_jobs: |tcx, qmap| {\n+                    let make_query = |tcx, key| {\n+                        let kind = rustc_middle::dep_graph::DepKind::$name;\n+                        let name = stringify!($name);\n+                        $crate::plumbing::create_query_frame(tcx, super::queries::$name::describe, key, kind, name)\n+                    };\n+                    tcx.queries.$name.try_collect_active_jobs(\n+                        tcx,\n+                        make_query,\n+                        qmap,\n+                    )\n+                },\n+                alloc_self_profile_query_strings: |tcx, string_cache| {\n+                    $crate::profiling_support::alloc_self_profile_query_strings_for_query_cache(\n+                        tcx,\n+                        stringify!($name),\n+                        &tcx.query_caches.$name,\n+                        string_cache,\n+                    )\n+                },\n+                encode_query_results: expand_if_cached!([$($modifiers)*], |tcx, encoder, query_result_index|\n+                    $crate::on_disk_cache::encode_query_results::<_, super::queries::$name<'_>>(tcx, encoder, query_result_index)\n+                ),\n+            }})*\n+        }\n+\n         pub fn query_callbacks<'tcx>(arena: &'tcx Arena<'tcx>) -> &'tcx [DepKindStruct<'tcx>] {\n             arena.alloc_from_iter(make_dep_kind_array!(query_callbacks))\n         }\n@@ -585,9 +639,11 @@ impl<'tcx> Queries<'tcx> {\n         extern_providers: ExternProviders,\n         on_disk_cache: Option<OnDiskCache<'tcx>>,\n     ) -> Self {\n+        use crate::query_structs;\n         Queries {\n             local_providers: Box::new(local_providers),\n             extern_providers: Box::new(extern_providers),\n+            query_structs: make_dep_kind_array!(query_structs).to_vec(),\n             on_disk_cache,\n             jobs: AtomicU64::new(1),\n             ..Queries::default()\n@@ -602,6 +658,7 @@ macro_rules! define_queries_struct {\n         pub struct Queries<'tcx> {\n             local_providers: Box<Providers>,\n             extern_providers: Box<ExternProviders>,\n+            query_structs: Vec<$crate::plumbing::QueryStruct<'tcx>>,\n \n             pub on_disk_cache: Option<OnDiskCache<'tcx>>,\n \n@@ -618,18 +675,9 @@ macro_rules! define_queries_struct {\n                 let tcx = QueryCtxt { tcx, queries: self };\n                 let mut jobs = QueryMap::default();\n \n-                $(\n-                    let make_query = |tcx, key| {\n-                        let kind = dep_graph::DepKind::$name;\n-                        let name = stringify!($name);\n-                        $crate::plumbing::create_query_frame(tcx, queries::$name::describe, key, kind, name)\n-                    };\n-                    self.$name.try_collect_active_jobs(\n-                        tcx,\n-                        make_query,\n-                        &mut jobs,\n-                    )?;\n-                )*\n+                for query in &self.query_structs {\n+                    (query.try_collect_active_jobs)(tcx, &mut jobs);\n+                }\n \n                 Some(jobs)\n             }"}, {"sha": "2cc311d48c8f63e661d011ce100189f8d616238a", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3288d3a305ad15cfcdcd9ef72404be6d2a2887b5/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=3288d3a305ad15cfcdcd9ef72404be6d2a2887b5", "patch": "@@ -1,3 +1,4 @@\n+use crate::QueryCtxt;\n use measureme::{StringComponent, StringId};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n@@ -8,7 +9,7 @@ use rustc_query_system::query::QueryCache;\n use std::fmt::Debug;\n use std::io::Write;\n \n-struct QueryKeyStringCache {\n+pub(crate) struct QueryKeyStringCache {\n     def_id_cache: FxHashMap<DefId, StringId>,\n }\n \n@@ -226,7 +227,7 @@ where\n /// Allocate the self-profiling query strings for a single query cache. This\n /// method is called from `alloc_self_profile_query_strings` which knows all\n /// the queries via macro magic.\n-fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n+pub(crate) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n     query_cache: &C,\n@@ -298,27 +299,15 @@ fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n /// If we are recording only summary data, the ids will point to\n /// just the query names. If we are recording query keys too, we\n /// allocate the corresponding strings here.\n-pub fn alloc_self_profile_query_strings(tcx: TyCtxt<'_>) {\n+pub fn alloc_self_profile_query_strings<'tcx>(tcx: TyCtxt<'tcx>) {\n     if !tcx.prof.enabled() {\n         return;\n     }\n \n     let mut string_cache = QueryKeyStringCache::new();\n+    let queries = QueryCtxt::from_tcx(tcx);\n \n-    macro_rules! alloc_once {\n-        (\n-        $($(#[$attr:meta])*\n-            [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n-            $(\n-                alloc_self_profile_query_strings_for_query_cache(\n-                    tcx,\n-                    stringify!($name),\n-                    &tcx.query_caches.$name,\n-                    &mut string_cache,\n-                );\n-            )+\n-        }\n+    for query in &queries.queries.query_structs {\n+        (query.alloc_self_profile_query_strings)(tcx, &mut string_cache);\n     }\n-\n-    rustc_query_append! { alloc_once! }\n }"}]}