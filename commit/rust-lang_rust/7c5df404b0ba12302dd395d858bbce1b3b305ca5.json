{"sha": "7c5df404b0ba12302dd395d858bbce1b3b305ca5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNWRmNDA0YjBiYTEyMzAyZGQzOTVkODU4YmJjZTFiM2IzMDVjYTU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-18T02:45:21Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-18T11:36:36Z"}, "message": "rustc: move freevar finding to resolve.", "tree": {"sha": "3e817315a2a46fed007b0e32a27b1c1aac42ef87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e817315a2a46fed007b0e32a27b1c1aac42ef87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c5df404b0ba12302dd395d858bbce1b3b305ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c5df404b0ba12302dd395d858bbce1b3b305ca5", "html_url": "https://github.com/rust-lang/rust/commit/7c5df404b0ba12302dd395d858bbce1b3b305ca5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c5df404b0ba12302dd395d858bbce1b3b305ca5/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c192ae123bb4c6163df37334ad316f542dc39f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c192ae123bb4c6163df37334ad316f542dc39f3", "html_url": "https://github.com/rust-lang/rust/commit/5c192ae123bb4c6163df37334ad316f542dc39f3"}], "stats": {"total": 469, "additions": 173, "deletions": 296}, "files": [{"sha": "4ff9133c8a534e9748c2beabee67dec375118f63", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -17,7 +17,7 @@ use lint;\n use llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n use metadata::creader;\n-use middle::{trans, freevars, stability, kind, ty, typeck, reachable};\n+use middle::{trans, stability, kind, ty, typeck, reachable};\n use middle::dependency_format;\n use middle;\n use plugin::load::Plugins;\n@@ -378,11 +378,13 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                           middle::lang_items::collect_language_items(krate, &sess));\n \n     let middle::resolve::CrateMap {\n-        def_map: def_map,\n-        exp_map2: exp_map2,\n-        trait_map: trait_map,\n-        external_exports: external_exports,\n-        last_private_map: last_private_map\n+        def_map,\n+        freevars,\n+        capture_mode_map,\n+        exp_map2,\n+        trait_map,\n+        external_exports,\n+        last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n              middle::resolve::resolve_crate(&sess, &lang_items, krate));\n@@ -401,10 +403,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n             plugin::build::find_plugin_registrar(\n                 sess.diagnostic(), krate)));\n \n-    let (freevars, capture_modes) =\n-        time(time_passes, \"freevar finding\", (), |_|\n-             freevars::annotate_freevars(&def_map, krate));\n-\n     let region_map = time(time_passes, \"region resolution\", (), |_|\n                           middle::region::resolve_crate(&sess, krate));\n \n@@ -423,7 +421,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             named_region_map,\n                             ast_map,\n                             freevars,\n-                            capture_modes,\n+                            capture_mode_map,\n                             region_map,\n                             lang_items,\n                             stability_index);"}, {"sha": "d13adfd34b1ce0e088c1cba9f2cea58570ee9347", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -93,7 +93,6 @@ pub mod middle {\n     pub mod effect;\n     pub mod entry;\n     pub mod expr_use_visitor;\n-    pub mod freevars;\n     pub mod graph;\n     pub mod intrinsicck;\n     pub mod kind;"}, {"sha": "0a61911dfc9085e4bb230cf3af9bfc95c9138153", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -16,7 +16,6 @@\n \n use middle::mem_categorization as mc;\n use middle::def;\n-use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;"}, {"sha": "c014c8f8bb2bc8bd22a789e94440a3fe7a849b42", "filename": "src/librustc/middle/freevars.rs", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c192ae123bb4c6163df37334ad316f542dc39f3/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=5c192ae123bb4c6163df37334ad316f542dc39f3", "patch": "@@ -1,128 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// A pass that annotates for each loops and functions with the free\n-// variables that they contain.\n-\n-#![allow(non_camel_case_types)]\n-\n-use middle::def;\n-use middle::resolve;\n-use middle::ty;\n-use util::nodemap::{NodeMap, NodeSet};\n-\n-use syntax::ast;\n-use syntax::codemap::Span;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n-\n-struct CollectFreevarsVisitor<'a, 'b:'a> {\n-    node_id: ast::NodeId,\n-    seen: NodeSet,\n-    cx: &'a mut AnnotateFreevarsVisitor<'b>,\n-    depth: u32\n-}\n-\n-impl<'a, 'b, 'v> Visitor<'v> for CollectFreevarsVisitor<'a, 'b> {\n-    fn visit_item(&mut self, _: &ast::Item) {\n-        // ignore_item\n-    }\n-\n-    fn visit_expr(&mut self, expr: &ast::Expr) {\n-        match expr.node {\n-            ast::ExprProc(..) => {\n-                self.cx.capture_mode_map.insert(expr.id, ast::CaptureByValue);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprFnBlock(_, _, _) => {\n-                // NOTE(stage0): After snapshot, change to:\n-                //\n-                //self.cx.capture_mode_map.insert(expr.id, capture_clause);\n-                self.cx.capture_mode_map.insert(expr.id, ast::CaptureByRef);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprUnboxedFn(capture_clause, _, _, _) => {\n-                self.cx.capture_mode_map.insert(expr.id, capture_clause);\n-                self.depth += 1;\n-                visit::walk_expr(self, expr);\n-                self.depth -= 1;\n-            }\n-            ast::ExprPath(..) => {\n-                let def = *self.cx.def_map.borrow().find(&expr.id)\n-                                                   .expect(\"path not found\");\n-                let dnum = def.def_id().node;\n-                if self.seen.contains(&dnum) {\n-                    return;\n-                }\n-                let def = match def {\n-                    def::DefUpvar(_, _, depth, _, _) => {\n-                        if depth < self.depth {\n-                            return;\n-                        }\n-                        let mut def = def;\n-                        for _ in range(0, depth - self.depth) {\n-                            match def {\n-                                def::DefUpvar(_, inner, _, _, _) => { def = *inner; }\n-                                _ => unreachable!()\n-                            }\n-                        }\n-                        def\n-                    },\n-                    _ => return\n-                };\n-                self.cx.freevars.find_or_insert(self.node_id, vec![]).push(ty::Freevar {\n-                    def: def,\n-                    span: expr.span,\n-                });\n-                self.seen.insert(dnum);\n-            }\n-            _ => visit::walk_expr(self, expr)\n-        }\n-    }\n-}\n-\n-struct AnnotateFreevarsVisitor<'a> {\n-    def_map: &'a resolve::DefMap,\n-    freevars: ty::FreevarMap,\n-    capture_mode_map: ty::CaptureModeMap,\n-}\n-\n-impl<'a, 'v> Visitor<'v> for AnnotateFreevarsVisitor<'a> {\n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                blk: &'v ast::Block, s: Span, nid: ast::NodeId) {\n-        CollectFreevarsVisitor {\n-            node_id: nid,\n-            seen: NodeSet::new(),\n-            cx: self,\n-            depth: 0\n-        }.visit_block(blk);\n-        visit::walk_fn(self, fk, fd, blk, s);\n-    }\n-}\n-\n-// Build a map from every function and for-each body to a set of the\n-// freevars contained in it. The implementation is not particularly\n-// efficient as it fully recomputes the free variables at every\n-// node of interest rather than building up the free variables in\n-// one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate)\n-                         -> (ty::FreevarMap, ty::CaptureModeMap) {\n-    let mut visitor = AnnotateFreevarsVisitor {\n-        def_map: def_map,\n-        freevars: NodeMap::new(),\n-        capture_mode_map: NodeMap::new(),\n-    };\n-    visit::walk_crate(&mut visitor, krate);\n-    (visitor.freevars, visitor.capture_mode_map)\n-}"}, {"sha": "74c889c614acb1e67a8a46e4d67090c802ab46fb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -103,7 +103,6 @@\n  */\n \n use middle::def::*;\n-use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;"}, {"sha": "cfb4db52eab08d02da10c3d218b073b6569b234c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -63,7 +63,6 @@\n #![allow(non_camel_case_types)]\n \n use middle::def;\n-use middle::freevars;\n use middle::ty;\n use middle::typeck;\n use util::nodemap::{DefIdMap, NodeMap};"}, {"sha": "652b3fc34a7f3ba8947c34e855126871ad46414b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 155, "deletions": 137, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -19,7 +19,8 @@ use middle::lang_items::LanguageItems;\n use middle::pat_util::pat_bindings;\n use middle::subst::{ParamSpace, FnSpace, TypeSpace};\n use middle::ty::{ExplicitSelfCategory, StaticExplicitSelfCategory};\n-use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n+use middle::ty::{CaptureModeMap, Freevar, FreevarMap};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DeclItem, DefId, Expr, ExprAgain, ExprBreak, ExprField};\n@@ -279,11 +280,7 @@ enum RibKind {\n \n     // We passed through a closure scope at the given node ID.\n     // Translate upvars as appropriate.\n-    ClosureRibKind(NodeId /* func id */),\n-\n-    // We passed through a proc or unboxed closure scope at the given node ID.\n-    // Translate upvars as appropriate.\n-    ProcRibKind(NodeId /* func id */, NodeId /* body id */),\n+    ClosureRibKind(NodeId /* func id */, NodeId /* body id if proc or unboxed */),\n \n     // We passed through an impl or trait and are now in one of its\n     // methods. Allow references to ty params that impl or trait\n@@ -895,6 +892,9 @@ struct Resolver<'a> {\n     primitive_type_table: PrimitiveTypeTable,\n \n     def_map: DefMap,\n+    freevars: RefCell<FreevarMap>,\n+    freevars_seen: RefCell<NodeMap<NodeSet>>,\n+    capture_mode_map: RefCell<CaptureModeMap>,\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n@@ -1000,6 +1000,9 @@ impl<'a> Resolver<'a> {\n             primitive_type_table: PrimitiveTypeTable::new(),\n \n             def_map: RefCell::new(NodeMap::new()),\n+            freevars: RefCell::new(NodeMap::new()),\n+            freevars_seen: RefCell::new(NodeMap::new()),\n+            capture_mode_map: RefCell::new(NodeMap::new()),\n             export_map2: RefCell::new(NodeMap::new()),\n             trait_map: NodeMap::new(),\n             used_imports: HashSet::new(),\n@@ -3831,164 +3834,167 @@ impl<'a> Resolver<'a> {\n         self.current_module = orig_module;\n     }\n \n-    /// Wraps the given definition in the appropriate number of `def_upvar`\n+    /// Wraps the given definition in the appropriate number of `DefUpvar`\n     /// wrappers.\n     fn upvarify(&self,\n                 ribs: &[Rib],\n-                rib_index: uint,\n                 def_like: DefLike,\n                 span: Span)\n                 -> Option<DefLike> {\n-        let mut def;\n-        let is_ty_param;\n-\n         match def_like {\n-            DlDef(d @ DefLocal(..)) | DlDef(d @ DefUpvar(..)) => {\n-                def = d;\n-                is_ty_param = false;\n-            }\n-            DlDef(d @ DefTyParam(..)) |\n-            DlDef(d @ DefSelfTy(..)) => {\n-                def = d;\n-                is_ty_param = true;\n-            }\n-            _ => {\n-                return Some(def_like);\n-            }\n-        }\n-\n-        let mut rib_index = rib_index + 1;\n-        while rib_index < ribs.len() {\n-            match ribs[rib_index].kind {\n-                NormalRibKind => {\n-                    // Nothing to do. Continue.\n-                }\n-                ClosureRibKind(function_id) => {\n-                    if !is_ty_param {\n-                        let (depth, block_id) = match def {\n-                            DefUpvar(_, _, depth, _, block_id) => (depth + 1, block_id),\n-                            _ => (0, ast::DUMMY_NODE_ID)\n-                        };\n-                        def = DefUpvar(def.def_id().node, box(GC) def, depth, function_id, block_id);\n-                    }\n-                }\n-                ProcRibKind(function_id, block_id) => {\n-                    if !is_ty_param {\n-                        let depth = match def {\n-                            DefUpvar(_, _, depth, _, _) => depth + 1,\n-                            _ => 0\n-                        };\n-                        def = DefUpvar(def.def_id().node, box(GC) def, depth, function_id, block_id);\n-                    }\n-                }\n-                MethodRibKind(item_id, _) => {\n-                  // If the def is a ty param, and came from the parent\n-                  // item, it's ok\n-                  match def {\n-                    DefTyParam(_, did, _) if {\n-                        self.def_map.borrow().find(&did.node).map(|x| *x)\n-                            == Some(DefTyParamBinder(item_id))\n-                    } => {\n-                      // ok\n-                    }\n+            DlDef(d @ DefUpvar(..)) => {\n+                self.session.span_bug(span,\n+                    format!(\"unexpected {} in bindings\", d).as_slice())\n+            }\n+            DlDef(d @ DefLocal(_)) => {\n+                let node_id = d.def_id().node;\n+                let mut def = d;\n+                let mut depth = 0;\n+                let mut last_proc_body_id = ast::DUMMY_NODE_ID;\n+                for rib in ribs.iter() {\n+                    match rib.kind {\n+                        NormalRibKind => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        ClosureRibKind(function_id, maybe_proc_body) => {\n+                            let prev_def = def;\n+                            if maybe_proc_body != ast::DUMMY_NODE_ID {\n+                                last_proc_body_id = maybe_proc_body;\n+                            }\n+                            def = DefUpvar(node_id, box(GC) def,\n+                                           depth, function_id, last_proc_body_id);\n+                            depth += 1;\n+\n+                            let mut seen = self.freevars_seen.borrow_mut();\n+                            let seen = seen.find_or_insert(function_id, NodeSet::new());\n+                            if seen.contains(&node_id) {\n+                                continue;\n+                            }\n+                            self.freevars.borrow_mut().find_or_insert(function_id, vec![])\n+                                         .push(Freevar { def: prev_def, span: span });\n+                            seen.insert(node_id);\n+                        }\n+                        MethodRibKind(item_id, _) => {\n+                            // If the def is a ty param, and came from the parent\n+                            // item, it's ok\n+                            match def {\n+                                DefTyParam(_, did, _) if {\n+                                    self.def_map.borrow().find_copy(&did.node)\n+                                        == Some(DefTyParamBinder(item_id))\n+                                } => {} // ok\n+                                DefSelfTy(did) if did == item_id => {} // ok\n+                                _ => {\n+                                    // This was an attempt to access an upvar inside a\n+                                    // named function item. This is not allowed, so we\n+                                    // report an error.\n \n-                    DefSelfTy(did) if {\n-                        did == item_id\n-                    } => {\n-                      // ok\n-                    }\n+                                    self.resolve_error(\n+                                        span,\n+                                        \"can't capture dynamic environment in a fn item; \\\n+                                        use the || { ... } closure form instead\");\n \n-                    _ => {\n-                    if !is_ty_param {\n-                        // This was an attempt to access an upvar inside a\n-                        // named function item. This is not allowed, so we\n-                        // report an error.\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+                        ItemRibKind => {\n+                            // This was an attempt to access an upvar inside a\n+                            // named function item. This is not allowed, so we\n+                            // report an error.\n \n-                        self.resolve_error(\n-                            span,\n-                            \"can't capture dynamic environment in a fn item; \\\n-                            use the || { ... } closure form instead\");\n-                    } else {\n-                        // This was an attempt to use a type parameter outside\n-                        // its scope.\n+                            self.resolve_error(\n+                                span,\n+                                \"can't capture dynamic environment in a fn item; \\\n+                                use the || { ... } closure form instead\");\n \n-                        self.resolve_error(span,\n-                                              \"can't use type parameters from \\\n-                                              outer function; try using a local \\\n-                                              type parameter instead\");\n-                    }\n+                            return None;\n+                        }\n+                        ConstantItemRibKind => {\n+                            // Still doesn't deal with upvars\n+                            self.resolve_error(span,\n+                                               \"attempt to use a non-constant \\\n+                                                value in a constant\");\n \n-                    return None;\n+                        }\n                     }\n-                  }\n                 }\n-                ItemRibKind => {\n-                    if !is_ty_param {\n-                        // This was an attempt to access an upvar inside a\n-                        // named function item. This is not allowed, so we\n-                        // report an error.\n+                Some(DlDef(def))\n+            }\n+            DlDef(def @ DefTyParam(..)) |\n+            DlDef(def @ DefSelfTy(..)) => {\n+                for rib in ribs.iter() {\n+                    match rib.kind {\n+                        NormalRibKind | ClosureRibKind(..) => {\n+                            // Nothing to do. Continue.\n+                        }\n+                        MethodRibKind(item_id, _) => {\n+                            // If the def is a ty param, and came from the parent\n+                            // item, it's ok\n+                            match def {\n+                                DefTyParam(_, did, _) if {\n+                                    self.def_map.borrow().find_copy(&did.node)\n+                                        == Some(DefTyParamBinder(item_id))\n+                                } => {} // ok\n+                                DefSelfTy(did) if did == item_id => {} // ok\n \n-                        self.resolve_error(\n-                            span,\n-                            \"can't capture dynamic environment in a fn item; \\\n-                            use the || { ... } closure form instead\");\n-                    } else {\n-                        // This was an attempt to use a type parameter outside\n-                        // its scope.\n+                                _ => {\n+                                    // This was an attempt to use a type parameter outside\n+                                    // its scope.\n \n-                        self.resolve_error(span,\n-                                              \"can't use type parameters from \\\n-                                              outer function; try using a local \\\n-                                              type parameter instead\");\n-                    }\n+                                    self.resolve_error(span,\n+                                                        \"can't use type parameters from \\\n+                                                        outer function; try using a local \\\n+                                                        type parameter instead\");\n \n-                    return None;\n-                }\n-                ConstantItemRibKind => {\n-                    if is_ty_param {\n-                        // see #9186\n-                        self.resolve_error(span,\n-                                              \"cannot use an outer type \\\n-                                               parameter in this context\");\n-                    } else {\n-                        // Still doesn't deal with upvars\n-                        self.resolve_error(span,\n-                                              \"attempt to use a non-constant \\\n-                                               value in a constant\");\n-                    }\n+                                    return None;\n+                                }\n+                            }\n+                        }\n+                        ItemRibKind => {\n+                            // This was an attempt to use a type parameter outside\n+                            // its scope.\n \n+                            self.resolve_error(span,\n+                                               \"can't use type parameters from \\\n+                                                outer function; try using a local \\\n+                                                type parameter instead\");\n+\n+                            return None;\n+                        }\n+                        ConstantItemRibKind => {\n+                            // see #9186\n+                            self.resolve_error(span,\n+                                               \"cannot use an outer type \\\n+                                                parameter in this context\");\n+\n+                        }\n+                    }\n                 }\n+                Some(DlDef(def))\n             }\n-\n-            rib_index += 1;\n+            _ => Some(def_like)\n         }\n-\n-        return Some(DlDef(def));\n     }\n \n     fn search_ribs(&self,\n                    ribs: &[Rib],\n                    name: Name,\n                    span: Span)\n                    -> Option<DefLike> {\n-        // FIXME #4950: This should not use a while loop.\n         // FIXME #4950: Try caching?\n \n-        let mut i = ribs.len();\n-        while i != 0 {\n-            i -= 1;\n-            let binding_opt = ribs[i].bindings.borrow().find_copy(&name);\n-            match binding_opt {\n+        for (i, rib) in ribs.iter().enumerate().rev() {\n+            match rib.bindings.borrow().find_copy(&name) {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs, i, def_like, span);\n+                    return self.upvarify(ribs.slice_from(i + 1), def_like, span);\n                 }\n                 None => {\n                     // Continue.\n                 }\n             }\n         }\n \n-        return None;\n+        None\n     }\n \n     fn resolve_crate(&mut self, krate: &ast::Crate) {\n@@ -5773,13 +5779,23 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprFnBlock(_, ref fn_decl, ref block) => {\n-                self.resolve_function(ClosureRibKind(expr.id),\n+                // NOTE(stage0): After snapshot, change to:\n+                //\n+                //self.capture_mode_map.borrow_mut().insert(expr.id, capture_clause);\n+                self.capture_mode_map.borrow_mut().insert(expr.id, ast::CaptureByRef);\n+                self.resolve_function(ClosureRibKind(expr.id, ast::DUMMY_NODE_ID),\n+                                      Some(&**fn_decl), NoTypeParameters,\n+                                      &**block);\n+            }\n+            ExprProc(ref fn_decl, ref block) => {\n+                self.capture_mode_map.borrow_mut().insert(expr.id, ast::CaptureByValue);\n+                self.resolve_function(ClosureRibKind(expr.id, block.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }\n-            ExprProc(ref fn_decl, ref block) |\n-            ExprUnboxedFn(_, _, ref fn_decl, ref block) => {\n-                self.resolve_function(ProcRibKind(expr.id, block.id),\n+            ExprUnboxedFn(capture_clause, _, ref fn_decl, ref block) => {\n+                self.capture_mode_map.borrow_mut().insert(expr.id, capture_clause);\n+                self.resolve_function(ClosureRibKind(expr.id, block.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n             }\n@@ -6210,6 +6226,8 @@ impl<'a> Resolver<'a> {\n \n pub struct CrateMap {\n     pub def_map: DefMap,\n+    pub freevars: RefCell<FreevarMap>,\n+    pub capture_mode_map: RefCell<CaptureModeMap>,\n     pub exp_map2: ExportMap2,\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n@@ -6223,13 +6241,13 @@ pub fn resolve_crate(session: &Session,\n                   -> CrateMap {\n     let mut resolver = Resolver::new(session, krate.span);\n     resolver.resolve(krate);\n-    let Resolver { def_map, export_map2, trait_map, last_private,\n-                   external_exports, .. } = resolver;\n     CrateMap {\n-        def_map: def_map,\n-        exp_map2: export_map2,\n-        trait_map: trait_map,\n-        external_exports: external_exports,\n-        last_private_map: last_private,\n+        def_map: resolver.def_map,\n+        freevars: resolver.freevars,\n+        capture_mode_map: resolver.capture_mode_map,\n+        exp_map2: resolver.export_map2,\n+        trait_map: resolver.trait_map,\n+        external_exports: resolver.external_exports,\n+        last_private_map: resolver.last_private,\n     }\n }"}, {"sha": "fa8c6b8b4482f63ad514c2930dbc87ed79a04305", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -14,7 +14,6 @@ use back::link::mangle_internal_name_by_path_and_seq;\n use driver::config::FullDebugInfo;\n use llvm::ValueRef;\n use middle::def;\n-use middle::freevars;\n use middle::mem_categorization::Typer;\n use middle::trans::adt;\n use middle::trans::base::*;"}, {"sha": "a5a9d6851762a7bcc0e567294a1fd2bb5205a8db", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -17,7 +17,6 @@ use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef};\n use llvm::{True, False, Bool};\n use middle::def;\n-use middle::freevars;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n use middle::subst;"}, {"sha": "7e767b96b6d9ce5220ed92d64e27aafbc254d10f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -1461,8 +1461,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      dm: resolve::DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n-                     freevars: FreevarMap,\n-                     capture_modes: CaptureModeMap,\n+                     freevars: RefCell<FreevarMap>,\n+                     capture_modes: RefCell<CaptureModeMap>,\n                      region_maps: middle::region::RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx> {\n@@ -1483,7 +1483,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         object_cast_map: RefCell::new(NodeMap::new()),\n         map: map,\n         intrinsic_defs: RefCell::new(DefIdMap::new()),\n-        freevars: RefCell::new(freevars),\n+        freevars: freevars,\n         tcache: RefCell::new(DefIdMap::new()),\n         rcache: RefCell::new(HashMap::new()),\n         short_names_cache: RefCell::new(HashMap::new()),\n@@ -1520,7 +1520,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         node_lint_levels: RefCell::new(HashMap::new()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n-        capture_modes: RefCell::new(capture_modes),\n+        capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap::new()),\n         trait_associated_types: RefCell::new(DefIdMap::new()),\n     }\n@@ -4755,7 +4755,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId)\n                               -> Vec<UnboxedClosureUpvar> {\n     if closure_id.krate == ast::LOCAL_CRATE {\n         match tcx.freevars.borrow().find(&closure_id.node) {\n-            None => tcx.sess.bug(\"no freevars for unboxed closure?!\"),\n+            None => vec![],\n             Some(ref freevars) => {\n                 freevars.iter().map(|freevar| {\n                     let freevar_def_id = freevar.def.def_id();\n@@ -5701,7 +5701,7 @@ pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n \n pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T) -> T {\n     match tcx.freevars.borrow().find(&fid) {\n-        None => fail!(\"with_freevars: {} has no freevars\", fid),\n+        None => f(&[]),\n         Some(d) => f(d.as_slice())\n     }\n }"}, {"sha": "f62951a85daf32a58b26cf6e4c86b80175cf1365", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -79,7 +79,6 @@ type parameter).\n \n use middle::const_eval;\n use middle::def;\n-use middle::freevars;\n use middle::lang_items::IteratorItem;\n use middle::mem_categorization::McResult;\n use middle::mem_categorization;"}, {"sha": "02d45d51688874ff7616b747bef7e5fe01456f7b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -119,7 +119,6 @@ and report an error, and it just seems like more mess in the end.)\n */\n \n use middle::def;\n-use middle::freevars;\n use middle::mem_categorization as mc;\n use middle::ty::{ReScope};\n use middle::ty;"}, {"sha": "29cd2e77e8b1f05a2bb1d8e3f6aa963c0df8389e", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5df404b0ba12302dd395d858bbce1b3b305ca5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=7c5df404b0ba12302dd395d858bbce1b3b305ca5", "patch": "@@ -22,7 +22,6 @@ use driver::diagnostic;\n use driver::diagnostic::Emitter;\n use driver::driver;\n use driver::session;\n-use middle::freevars;\n use middle::lang_items;\n use middle::region;\n use middle::resolve;\n@@ -125,10 +124,8 @@ fn test_env(_test_name: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n-    let resolve::CrateMap { def_map: def_map, .. } =\n+    let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n         resolve::resolve_crate(&sess, &lang_items, krate);\n-    let (freevars_map, captures_map) = freevars::annotate_freevars(&def_map,\n-                                                                   krate);\n     let named_region_map = resolve_lifetime::krate(&sess, krate);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);\n@@ -138,8 +135,8 @@ fn test_env(_test_name: &str,\n                           def_map,\n                           named_region_map,\n                           ast_map,\n-                          freevars_map,\n-                          captures_map,\n+                          freevars,\n+                          capture_mode_map,\n                           region_map,\n                           lang_items,\n                           stability_index);"}]}