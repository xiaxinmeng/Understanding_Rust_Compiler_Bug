{"sha": "3a85e47f6ab586328ee17bb27e8dae3e3e247e23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhODVlNDdmNmFiNTg2MzI4ZWUxN2JiMjdlOGRhZTNlM2UyNDdlMjM=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-02T15:09:31Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:46Z"}, "message": "Support bool literal patterns", "tree": {"sha": "7767a3c7bc044573fe9f67fbc997254e48d32ec7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7767a3c7bc044573fe9f67fbc997254e48d32ec7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a85e47f6ab586328ee17bb27e8dae3e3e247e23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a85e47f6ab586328ee17bb27e8dae3e3e247e23", "html_url": "https://github.com/rust-lang/rust/commit/3a85e47f6ab586328ee17bb27e8dae3e3e247e23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a85e47f6ab586328ee17bb27e8dae3e3e247e23/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a8a0b62697c01ef881e7e2a0387e3649cab2034", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8a0b62697c01ef881e7e2a0387e3649cab2034", "html_url": "https://github.com/rust-lang/rust/commit/5a8a0b62697c01ef881e7e2a0387e3649cab2034"}], "stats": {"total": 191, "additions": 182, "deletions": 9}, "files": [{"sha": "044506d66989e68438c037fd889062323e4419fa", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3a85e47f6ab586328ee17bb27e8dae3e3e247e23/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a85e47f6ab586328ee17bb27e8dae3e3e247e23/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=3a85e47f6ab586328ee17bb27e8dae3e3e247e23", "patch": "@@ -118,6 +118,32 @@ fn main(v: E) {\n     match v { }\n         //^ Missing match arm\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn boolean() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match true {\n+        true  => {}\n+        false => {}\n+    }\n+    match true {\n+        true | false => {}\n+    }\n+    match true {\n+        true => {}\n+        _ => {}\n+    }\n+    match true {}\n+        //^^^^ Missing match arm\n+    match true { true => {} }\n+        //^^^^ Missing match arm\n+\n+}\n \"#,\n         );\n     }"}, {"sha": "393d9999716e186f08e123b1009cde71526ab8a5", "filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs", "status": "modified", "additions": 156, "deletions": 9, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/3a85e47f6ab586328ee17bb27e8dae3e3e247e23/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a85e47f6ab586328ee17bb27e8dae3e3e247e23/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs?ref=3a85e47f6ab586328ee17bb27e8dae3e3e247e23", "patch": "@@ -1,12 +1,17 @@\n+use std::{\n+    cmp::{max, min},\n+    iter::once,\n+    ops::RangeInclusive,\n+};\n+\n use hir_def::{\n-    expr::{Pat, PatId, RecordFieldPat},\n+    expr::{Expr, Literal, Pat, PatId, RecordFieldPat},\n     find_path::find_path,\n     item_scope::ItemInNs,\n     path::Path,\n     type_ref::Mutability,\n     AttrDefId, EnumVariantId, HasModule, VariantId,\n };\n-\n use smallvec::{smallvec, SmallVec};\n \n use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n@@ -20,7 +25,7 @@ pub(super) enum ToDo {}\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(super) struct IntRange {\n-    range: ToDo,\n+    range: RangeInclusive<u128>,\n }\n \n impl IntRange {\n@@ -36,12 +41,147 @@ impl IntRange {\n     }\n \n     fn is_singleton(&self) -> bool {\n-        todo!()\n+        self.range.start() == self.range.end()\n+    }\n+\n+    fn boundaries(&self) -> (u128, u128) {\n+        (*self.range.start(), *self.range.end())\n+    }\n+\n+    #[inline]\n+    fn from_bool(value: bool) -> IntRange {\n+        let val = value as u128;\n+        IntRange { range: val..=val }\n+    }\n+\n+    #[inline]\n+    fn from_range(cx: &MatchCheckCtx<'_>, lo: u128, hi: u128, scalar_ty: Scalar) -> IntRange {\n+        if let Scalar::Bool = scalar_ty {\n+            IntRange { range: lo..=hi }\n+        } else {\n+            todo!()\n+        }\n+    }\n+\n+    fn is_subrange(&self, other: &Self) -> bool {\n+        other.range.start() <= self.range.start() && self.range.end() <= other.range.end()\n+    }\n+\n+    fn intersection(&self, other: &Self) -> Option<Self> {\n+        let (lo, hi) = self.boundaries();\n+        let (other_lo, other_hi) = other.boundaries();\n+        if lo <= other_hi && other_lo <= hi {\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi) })\n+        } else {\n+            None\n+        }\n     }\n \n     /// See `Constructor::is_covered_by`\n     fn is_covered_by(&self, other: &Self) -> bool {\n-        todo!()\n+        if self.intersection(other).is_some() {\n+            // Constructor splitting should ensure that all intersections we encounter are actually\n+            // inclusions.\n+            assert!(self.is_subrange(other));\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Represents a border between 2 integers. Because the intervals spanning borders must be able to\n+/// cover every integer, we need to be able to represent 2^128 + 1 such borders.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+enum IntBorder {\n+    JustBefore(u128),\n+    AfterMax,\n+}\n+\n+/// A range of integers that is partitioned into disjoint subranges. This does constructor\n+/// splitting for integer ranges as explained at the top of the file.\n+///\n+/// This is fed multiple ranges, and returns an output that covers the input, but is split so that\n+/// the only intersections between an output range and a seen range are inclusions. No output range\n+/// straddles the boundary of one of the inputs.\n+///\n+/// The following input:\n+/// ```\n+///   |-------------------------| // `self`\n+/// |------|  |----------|   |----|\n+///    |-------| |-------|\n+/// ```\n+/// would be iterated over as follows:\n+/// ```\n+///   ||---|--||-|---|---|---|--|\n+/// ```\n+#[derive(Debug, Clone)]\n+struct SplitIntRange {\n+    /// The range we are splitting\n+    range: IntRange,\n+    /// The borders of ranges we have seen. They are all contained within `range`. This is kept\n+    /// sorted.\n+    borders: Vec<IntBorder>,\n+}\n+\n+impl SplitIntRange {\n+    fn new(range: IntRange) -> Self {\n+        SplitIntRange { range, borders: Vec::new() }\n+    }\n+\n+    /// Internal use\n+    fn to_borders(r: IntRange) -> [IntBorder; 2] {\n+        use IntBorder::*;\n+        let (lo, hi) = r.boundaries();\n+        let lo = JustBefore(lo);\n+        let hi = match hi.checked_add(1) {\n+            Some(m) => JustBefore(m),\n+            None => AfterMax,\n+        };\n+        [lo, hi]\n+    }\n+\n+    /// Add ranges relative to which we split.\n+    fn split(&mut self, ranges: impl Iterator<Item = IntRange>) {\n+        let this_range = &self.range;\n+        let included_ranges = ranges.filter_map(|r| this_range.intersection(&r));\n+        let included_borders = included_ranges.flat_map(|r| {\n+            let borders = Self::to_borders(r);\n+            once(borders[0]).chain(once(borders[1]))\n+        });\n+        self.borders.extend(included_borders);\n+        self.borders.sort_unstable();\n+    }\n+\n+    /// Iterate over the contained ranges.\n+    fn iter(&self) -> impl Iterator<Item = IntRange> + '_ {\n+        use IntBorder::*;\n+\n+        let self_range = Self::to_borders(self.range.clone());\n+        // Start with the start of the range.\n+        let mut prev_border = self_range[0];\n+        self.borders\n+            .iter()\n+            .copied()\n+            // End with the end of the range.\n+            .chain(once(self_range[1]))\n+            // List pairs of adjacent borders.\n+            .map(move |border| {\n+                let ret = (prev_border, border);\n+                prev_border = border;\n+                ret\n+            })\n+            // Skip duplicates.\n+            .filter(|(prev_border, border)| prev_border != border)\n+            // Finally, convert to ranges.\n+            .map(|(prev_border, border)| {\n+                let range = match (prev_border, border) {\n+                    (JustBefore(n), JustBefore(m)) if n < m => n..=(m - 1),\n+                    (JustBefore(n), AfterMax) => n..=u128::MAX,\n+                    _ => unreachable!(), // Ruled out by the sorting and filtering we did\n+                };\n+                IntRange { range }\n+            })\n     }\n }\n \n@@ -143,13 +283,16 @@ impl Constructor {\n                     VariantId::StructId(_) | VariantId::UnionId(_) => Single,\n                 }\n             }\n+            &Pat::Lit(expr_id) => match cx.body[expr_id] {\n+                Expr::Literal(Literal::Bool(val)) => IntRange(IntRange::from_bool(val)),\n+                _ => todo!(),\n+            },\n \n             Pat::Or(..) => panic!(\"bug: Or-pattern should have been expanded earlier on.\"),\n             Pat::Missing => todo!(\"Fail gracefully when there is an error in a pattern\"),\n             pat => todo!(\"Constructor::from_pat {:?}\", pat),\n             // Pat::Range { start, end } => {}\n             // Pat::Slice { prefix, slice, suffix } => {}\n-            // Pat::Lit(_) => {}\n             // Pat::ConstBlock(_) => {}\n         }\n     }\n@@ -181,7 +324,10 @@ impl Constructor {\n             // Fast-track if the range is trivial. In particular, we don't do the overlapping\n             // ranges check.\n             IntRange(ctor_range) if !ctor_range.is_singleton() => {\n-                todo!(\"Constructor::split IntRange\")\n+                let mut split_range = SplitIntRange::new(ctor_range.clone());\n+                let int_ranges = ctors.filter_map(|ctor| ctor.as_int_range());\n+                split_range.split(int_ranges.cloned());\n+                split_range.iter().map(IntRange).collect()\n             }\n             Slice(_) => todo!(\"Constructor::split Slice\"),\n             // Any other constructor can be used unchanged.\n@@ -282,7 +428,8 @@ pub(super) struct SplitWildcard {\n impl SplitWildcard {\n     pub(super) fn new(pcx: PatCtxt<'_>) -> Self {\n         let cx = pcx.cx;\n-        // let make_range = |start, end| IntRange(todo!());\n+        let make_range =\n+            |start, end, scalar| IntRange(IntRange::from_range(cx, start, end, scalar));\n \n         // This determines the set of all possible constructors for the type `pcx.ty`. For numbers,\n         // arrays and slices we use ranges and variable-length slices when appropriate.\n@@ -293,7 +440,7 @@ impl SplitWildcard {\n         // Invariant: this is empty if and only if the type is uninhabited (as determined by\n         // `cx.is_uninhabited()`).\n         let all_ctors = match pcx.ty.kind(&Interner) {\n-            TyKind::Scalar(Scalar::Bool) => todo!(),\n+            TyKind::Scalar(Scalar::Bool) => smallvec![make_range(0, 1, Scalar::Bool)],\n             // TyKind::Array(..) if ... => todo!(),\n             TyKind::Array(..) | TyKind::Slice(..) => todo!(),\n             &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref _substs) => {"}]}