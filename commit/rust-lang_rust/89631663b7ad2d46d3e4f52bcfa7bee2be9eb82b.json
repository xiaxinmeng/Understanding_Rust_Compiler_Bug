{"sha": "89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NjMxNjYzYjdhZDJkNDZkM2U0ZjUyYmNmYTdiZWUyYmU5ZWI4MmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-04T17:17:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-04T17:17:01Z"}, "message": "Auto merge of #78280 - bugadani:span, r=lcnr\n\nCodegen: Query span as late as possible", "tree": {"sha": "99b68ba8b6239710db5c34b0d84b52feed7a97a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99b68ba8b6239710db5c34b0d84b52feed7a97a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b", "html_url": "https://github.com/rust-lang/rust/commit/89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75f1db1102076e416e1154b241b4fc95c01c0d7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/75f1db1102076e416e1154b241b4fc95c01c0d7b", "html_url": "https://github.com/rust-lang/rust/commit/75f1db1102076e416e1154b241b4fc95c01c0d7b"}, {"sha": "caf9131e652cb8d92a1f9f3f5b02bc2ca51d3ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf9131e652cb8d92a1f9f3f5b02bc2ca51d3ed5", "html_url": "https://github.com/rust-lang/rust/commit/caf9131e652cb8d92a1f9f3f5b02bc2ca51d3ed5"}], "stats": {"total": 41, "additions": 18, "deletions": 23}, "files": [{"sha": "90a51f75e0ee3e9f74903f511dc2a42ef7bc682b", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b", "patch": "@@ -19,7 +19,6 @@ use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::symbol::sym;\n-use rustc_span::Span;\n use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n use tracing::debug;\n \n@@ -110,7 +109,7 @@ fn check_and_apply_linkage(\n     attrs: &CodegenFnAttrs,\n     ty: Ty<'tcx>,\n     sym: &str,\n-    span: Span,\n+    span_def_id: DefId,\n ) -> &'ll Value {\n     let llty = cx.layout_of(ty).llvm_type(cx);\n     if let Some(linkage) = attrs.linkage {\n@@ -125,7 +124,7 @@ fn check_and_apply_linkage(\n             cx.layout_of(mt.ty).llvm_type(cx)\n         } else {\n             cx.sess().span_fatal(\n-                span,\n+                cx.tcx.def_span(span_def_id),\n                 \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n             )\n         };\n@@ -143,7 +142,10 @@ fn check_and_apply_linkage(\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(&sym);\n             let g2 = cx.define_global(&real_name, llty).unwrap_or_else(|| {\n-                cx.sess().span_fatal(span, &format!(\"symbol `{}` is already defined\", &sym))\n+                cx.sess().span_fatal(\n+                    cx.tcx.def_span(span_def_id),\n+                    &format!(\"symbol `{}` is already defined\", &sym),\n+                )\n             });\n             llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n             llvm::LLVMSetInitializer(g2, g1);\n@@ -210,21 +212,21 @@ impl CodegenCx<'ll, 'tcx> {\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n-        let g = if let Some(def_id) = def_id.as_local() {\n-            let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+        let g = if let Some(local_def_id) = def_id.as_local() {\n+            let id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n             let llty = self.layout_of(ty).llvm_type(self);\n             // FIXME: refactor this to work without accessing the HIR\n             let (g, attrs) = match self.tcx.hir().get(id) {\n-                Node::Item(&hir::Item { attrs, span, kind: hir::ItemKind::Static(..), .. }) => {\n+                Node::Item(&hir::Item { attrs, kind: hir::ItemKind::Static(..), .. }) => {\n                     if let Some(g) = self.get_declared_value(sym) {\n                         if self.val_ty(g) != self.type_ptr_to(llty) {\n-                            span_bug!(span, \"Conflicting types for static\");\n+                            span_bug!(self.tcx.def_span(def_id), \"Conflicting types for static\");\n                         }\n                     }\n \n                     let g = self.declare_global(sym, llty);\n \n-                    if !self.tcx.is_reachable_non_generic(def_id) {\n+                    if !self.tcx.is_reachable_non_generic(local_def_id) {\n                         unsafe {\n                             llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                         }\n@@ -235,12 +237,11 @@ impl CodegenCx<'ll, 'tcx> {\n \n                 Node::ForeignItem(&hir::ForeignItem {\n                     ref attrs,\n-                    span,\n                     kind: hir::ForeignItemKind::Static(..),\n                     ..\n                 }) => {\n-                    let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, span), &**attrs)\n+                    let fn_attrs = self.tcx.codegen_fn_attrs(local_def_id);\n+                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, def_id), &**attrs)\n                 }\n \n                 item => bug!(\"get_static: expected static, found {:?}\", item),\n@@ -260,8 +261,7 @@ impl CodegenCx<'ll, 'tcx> {\n             debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n \n             let attrs = self.tcx.codegen_fn_attrs(def_id);\n-            let span = self.tcx.def_span(def_id);\n-            let g = check_and_apply_linkage(&self, &attrs, ty, sym, span);\n+            let g = check_and_apply_linkage(&self, &attrs, ty, sym, def_id);\n \n             // Thread-local statics in some other crate need to *always* be linked\n             // against in a thread-local fashion, so we need to be sure to apply the"}, {"sha": "afb407b35bede4cb60222ab1e58e7e4108c98b91", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=89631663b7ad2d46d3e4f52bcfa7bee2be9eb82b", "patch": "@@ -46,7 +46,6 @@ use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, EntryFnType};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Session;\n-use rustc_span::Span;\n use rustc_symbol_mangling::test as symbol_names_test;\n use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n@@ -364,11 +363,7 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n ) -> Option<Bx::Function> {\n-    let (main_def_id, span) = match cx.tcx().entry_fn(LOCAL_CRATE) {\n-        Some((def_id, _)) => (def_id, cx.tcx().def_span(def_id)),\n-        None => return None,\n-    };\n-\n+    let main_def_id = cx.tcx().entry_fn(LOCAL_CRATE).map(|(def_id, _)| def_id)?;\n     let instance = Instance::mono(cx.tcx(), main_def_id.to_def_id());\n \n     if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n@@ -381,12 +376,11 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     return cx.tcx().entry_fn(LOCAL_CRATE).map(|(_, et)| {\n         let use_start_lang_item = EntryFnType::Start != et;\n-        create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, use_start_lang_item)\n+        create_entry_fn::<Bx>(cx, main_llfn, main_def_id, use_start_lang_item)\n     });\n \n     fn create_entry_fn<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx: &'a Bx::CodegenCx,\n-        sp: Span,\n         rust_main: Bx::Value,\n         rust_main_def_id: LocalDefId,\n         use_start_lang_item: bool,\n@@ -411,8 +405,9 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             Some(llfn) => llfn,\n             None => {\n                 // FIXME: We should be smart and show a better diagnostic here.\n+                let span = cx.tcx().def_span(rust_main_def_id);\n                 cx.sess()\n-                    .struct_span_err(sp, \"entry symbol `main` declared multiple times\")\n+                    .struct_span_err(span, \"entry symbol `main` declared multiple times\")\n                     .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n                     .emit();\n                 cx.sess().abort_if_errors();"}]}