{"sha": "858077e5f8935968e699db8b15f7d9a66eddba54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ODA3N2U1Zjg5MzU5NjhlNjk5ZGI4YjE1ZjdkOWE2NmVkZGJhNTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-17T14:29:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-17T14:29:16Z"}, "message": "test and support two-phase reborrows of raw pointers (#727)\n\ntest and support two-phase reborrows of raw pointers", "tree": {"sha": "40dc7f253ded30b6c5d12f1f0d361e01d1f96d97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40dc7f253ded30b6c5d12f1f0d361e01d1f96d97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/858077e5f8935968e699db8b15f7d9a66eddba54", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc3sU8CRBK7hj4Ov3rIwAAdHIIAFAERj/hKGLMvZetiMV4dVXf\nlVjhee8nMJxBInggRIwGJ5oAz7qgbUTiwKjab+SCUz6pi9JbfjwmQQrBzuU5letP\nOzudC9617qTAoMDulSZ4hh/sjrowhL4EJNjyuP0kfEmW+ZtU1fUy0/ZiVmiqKg1V\nrdribKK6+D2XjVhv1cRshJpbnwEg/+fgaC7puxfahTQOP/W8Fqjr+ziSTpF0kFNj\noBYuadE0V84DOOzz0CuYQ7AmITnCs/rLuaDV4nQwG6QR7tylICpPqcauBg14TCQE\nOxxtxC9wSEDM5MJSAfEZUTFXChY8VaORM89OwpsXdpkS224eioFPQtTo1YLTzLc=\n=9ryc\n-----END PGP SIGNATURE-----\n", "payload": "tree 40dc7f253ded30b6c5d12f1f0d361e01d1f96d97\nparent 77737cdb2909a44b040015ed5f3dea4e24b766cf\nparent 9c161b80d05250a0a8f6e6f5f8d462c510aecf32\nauthor Ralf Jung <post@ralfj.de> 1558103356 +0200\ncommitter GitHub <noreply@github.com> 1558103356 +0200\n\ntest and support two-phase reborrows of raw pointers (#727)\n\ntest and support two-phase reborrows of raw pointers"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/858077e5f8935968e699db8b15f7d9a66eddba54", "html_url": "https://github.com/rust-lang/rust/commit/858077e5f8935968e699db8b15f7d9a66eddba54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/858077e5f8935968e699db8b15f7d9a66eddba54/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77737cdb2909a44b040015ed5f3dea4e24b766cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/77737cdb2909a44b040015ed5f3dea4e24b766cf", "html_url": "https://github.com/rust-lang/rust/commit/77737cdb2909a44b040015ed5f3dea4e24b766cf"}, {"sha": "9c161b80d05250a0a8f6e6f5f8d462c510aecf32", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c161b80d05250a0a8f6e6f5f8d462c510aecf32", "html_url": "https://github.com/rust-lang/rust/commit/9c161b80d05250a0a8f6e6f5f8d462c510aecf32"}], "stats": {"total": 321, "additions": 148, "deletions": 173}, "files": [{"sha": "d14d00018a7ab9a46f01c43b6e8533dc7983d68b", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 120, "deletions": 157, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/858077e5f8935968e699db8b15f7d9a66eddba54/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858077e5f8935968e699db8b15f7d9a66eddba54/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=858077e5f8935968e699db8b15f7d9a66eddba54", "patch": "@@ -42,6 +42,9 @@ pub enum Permission {\n     SharedReadWrite,\n     /// Greants shared read-only access.\n     SharedReadOnly,\n+    /// Grants no access, but separates two groups of SharedReadWrite so they are not\n+    /// all considered mutually compatible.\n+    Disabled,\n }\n \n /// An item in the per-location borrow stack.\n@@ -70,10 +73,9 @@ impl fmt::Display for Item {\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct Stack {\n     /// Used *mostly* as a stack; never empty.\n-    /// We sometimes push into the middle but never remove from the middle.\n-    /// The same tag may occur multiple times, e.g. from a two-phase borrow.\n     /// Invariants:\n     /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n+    /// * Except for `Untagged`, no tag occurs in the stack more than once.\n     borrows: Vec<Item>,\n }\n \n@@ -118,7 +120,7 @@ impl fmt::Display for AccessKind {\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum RefKind {\n     /// `&mut` and `Box`.\n-    Unique,\n+    Unique { two_phase: bool },\n     /// `&` with or without interior mutability.\n     Shared,\n     /// `*mut`/`*const` (raw pointers).\n@@ -128,7 +130,8 @@ pub enum RefKind {\n impl fmt::Display for RefKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            RefKind::Unique => write!(f, \"unique\"),\n+            RefKind::Unique { two_phase: false } => write!(f, \"unique\"),\n+            RefKind::Unique { two_phase: true } => write!(f, \"unique (two-phase)\"),\n             RefKind::Shared => write!(f, \"shared\"),\n             RefKind::Raw { mutable: true } => write!(f, \"raw (mutable)\"),\n             RefKind::Raw { mutable: false } => write!(f, \"raw (constant)\"),\n@@ -194,140 +197,136 @@ impl Default for Tag {\n     }\n }\n \n-/// Core relations on `Permission` define which accesses are allowed:\n-/// On every access, we try to find a *granting* item, and then we remove all\n-/// *incompatible* items above it.\n+\n+/// Core relation on `Permission` to define which accesses are allowed\n impl Permission {\n     /// This defines for a given permission, whether it permits the given kind of access.\n     fn grants(self, access: AccessKind) -> bool {\n-        match (self, access) {\n-            // Unique and SharedReadWrite allow any kind of access.\n-            (Permission::Unique, _) |\n-            (Permission::SharedReadWrite, _) =>\n-                true,\n-            // SharedReadOnly only permits read access.\n-            (Permission::SharedReadOnly, AccessKind::Read) =>\n-                true,\n-            (Permission::SharedReadOnly, AccessKind::Write) =>\n-                false,\n-        }\n-    }\n-\n-    /// This defines for a given permission, which other permissions it can tolerate \"above\" itself\n-    /// for which kinds of accesses.\n-    /// If true, then `other` is allowed to remain on top of `self` when `access` happens.\n-    fn compatible_with(self, access: AccessKind, other: Permission) -> bool {\n-        use self::Permission::*;\n-\n-        match (self, access, other) {\n-            // Some cases are impossible.\n-            (SharedReadOnly, _, SharedReadWrite) |\n-            (SharedReadOnly, _, Unique) =>\n-                bug!(\"There can never be a SharedReadWrite or a Unique on top of a SharedReadOnly\"),\n-            // When `other` is `SharedReadOnly`, that is NEVER compatible with\n-            // write accesses.\n-            // This makes sure read-only pointers become invalid on write accesses (ensures F2a).\n-            (_, AccessKind::Write, SharedReadOnly) =>\n-                false,\n-            // When `other` is `Unique`, that is compatible with nothing.\n-            // This makes sure unique pointers become invalid on incompatible accesses (ensures U2).\n-            (_, _, Unique) =>\n-                false,\n-            // When we are unique and this is a write/dealloc, we tolerate nothing.\n-            // This makes sure we re-assert uniqueness (\"being on top\") on write accesses.\n-            // (This is particularily important such that when a new mutable ref gets created, it gets\n-            // pushed onto the right item -- this behaves like a write and we assert uniqueness of the\n-            // pointer from which this comes, *if* it was a unique pointer.)\n-            (Unique, AccessKind::Write, _) =>\n-                false,\n-            // `SharedReadWrite` items can tolerate any other akin items for any kind of access.\n-            (SharedReadWrite, _, SharedReadWrite) =>\n-                true,\n-            // Any item can tolerate read accesses for shared items.\n-            // This includes unique items!  Reads from unique pointers do not invalidate\n-            // other pointers.\n-            (_, AccessKind::Read, SharedReadWrite) |\n-            (_, AccessKind::Read, SharedReadOnly) =>\n-                true,\n-            // That's it.\n-        }\n+        // Disabled grants nother. Otherwise, all items grant read access, and except for SharedReadOnly they grant write access.\n+        self != Permission::Disabled && (access == AccessKind::Read || self != Permission::SharedReadOnly)\n     }\n }\n \n /// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n-    /// Find the item granting the given kind of access to the given tag, and where that item is in the stack.\n-    fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<(usize, Permission)> {\n+    /// Find the item granting the given kind of access to the given tag, and return where\n+    /// it is on the stack.\n+    fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<usize> {\n         self.borrows.iter()\n             .enumerate() // we also need to know *where* in the stack\n             .rev() // search top-to-bottom\n             // Return permission of first item that grants access.\n             // We require a permission with the right tag, ensuring U3 and F3.\n             .find_map(|(idx, item)|\n-                if item.perm.grants(access) && tag == item.tag {\n-                    Some((idx, item.perm))\n+                if tag == item.tag && item.perm.grants(access) {\n+                    Some(idx)\n                 } else {\n                     None\n                 }\n             )\n     }\n \n+    /// Find the first write-incompatible item above the given one -- \n+    /// i.e, find the height to which the stack will be truncated when writing to `granting`.\n+    fn find_first_write_incompaible(&self, granting: usize) -> usize {\n+        let perm = self.borrows[granting].perm;\n+        match perm {\n+            Permission::SharedReadOnly =>\n+                bug!(\"Cannot use SharedReadOnly for writing\"),\n+            Permission::Disabled =>\n+                bug!(\"Cannot use Disabled for anything\"),\n+            Permission::Unique =>\n+                // On a write, everything above us is incompatible.\n+                granting+1,\n+            Permission::SharedReadWrite => {\n+                // The SharedReadWrite *just* above us are compatible, to skip those.\n+                let mut idx = granting+1;\n+                while let Some(item) = self.borrows.get(idx) {\n+                    if item.perm == Permission::SharedReadWrite {\n+                        // Go on.\n+                        idx += 1;\n+                    } else {\n+                        // Found first incompatible!\n+                        break;\n+                    }\n+                }\n+                idx\n+            }\n+        }\n+    }\n+\n+    /// Check if the given item is protected.\n+    fn check_protector(item: &Item, tag: Option<Tag>, global: &GlobalState) -> EvalResult<'tcx> {\n+        if let Some(call) = item.protector {\n+            if global.is_active(call) {\n+                if let Some(tag) = tag {\n+                    return err!(MachineError(format!(\n+                        \"not granting access to tag {} because incompatible item is protected: {}\",\n+                        tag, item\n+                    )));\n+                } else {\n+                    return err!(MachineError(format!(\n+                        \"deallocating while item is protected: {}\", item\n+                    )));\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n     /// If yes, return the index of the item that granted it.\n     fn access(\n         &mut self,\n         access: AccessKind,\n         tag: Tag,\n         global: &GlobalState,\n-    ) -> EvalResult<'tcx, usize> {\n-        // Two main steps: Find granting item, remove all incompatible items above.\n+    ) -> EvalResult<'tcx> {\n+        // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let (granting_idx, granting_perm) = self.find_granting(access, tag)\n+        let granting_idx = self.find_granting(access, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item granting {} access to tag {} found in borrow stack\",\n                 access, tag,\n             )))?;\n \n-        // Step 2: Remove everything incompatible above them.  Make sure we do not remove protected\n-        // items.\n-        // We do *not* maintain a stack discipline here.  We could, in principle, decide to only\n-        // keep the items immediately above `granting_idx` that are compatible, and then pop the rest.\n-        // However, that kills off entire \"branches\" of pointer derivation too easily:\n-        // in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement would pop the `Unique`\n-        // from the reborrow of the first statement, and subsequently also pop the `SharedReadWrite` for `raw`.\n-        // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n-        // reference and use that.\n-        {\n-            // Implemented with indices because there does not seem to be a nice iterator and range-based\n-            // API for this.\n-            let mut cur = granting_idx + 1;\n-            while let Some(item) = self.borrows.get(cur) {\n-                if granting_perm.compatible_with(access, item.perm) {\n-                    // Keep this, check next.\n-                    cur += 1;\n-                } else {\n-                    // Aha! This is a bad one, remove it, and make sure it is not protected.\n-                    let item = self.borrows.remove(cur);\n-                    if let Some(call) = item.protector {\n-                        if global.is_active(call) {\n-                            return err!(MachineError(format!(\n-                                \"not granting {} access to tag {} because incompatible item {} is protected\",\n-                                access, tag, item\n-                            )));\n-                        }\n-                    }\n-                    trace!(\"access: removing item {}\", item);\n+        // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n+        // items.  Behavior differs for reads and writes.\n+        if access == AccessKind::Write {\n+            // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n+            // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n+            let first_incompatible_idx = self.find_first_write_incompaible(granting_idx);\n+            while self.borrows.len() > first_incompatible_idx {\n+                let item = self.borrows.pop().unwrap();\n+                trace!(\"access: popping item {}\", item);\n+                Stack::check_protector(&item, Some(tag), global)?;\n+            }\n+        } else {\n+            // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n+            // The reason this is not following the stack discipline (by removing the first Unique and\n+            // everything on top of it) is that in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n+            // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n+            // `SharedReadWrite` for `raw`.\n+            // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n+            // reference and use that.\n+            // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n+            for idx in (granting_idx+1 .. self.borrows.len()).rev() {\n+                let item = &mut self.borrows[idx];\n+                if item.perm == Permission::Unique {\n+                    trace!(\"access: disabling item {}\", item);\n+                    Stack::check_protector(item, Some(tag), global)?;\n+                    item.perm = Permission::Disabled;\n                 }\n             }\n         }\n \n         // Done.\n-        return Ok(granting_idx);\n+        Ok(())\n     }\n \n     /// Deallocate a location: Like a write access, but also there must be no\n-    /// active protectors at all.\n+    /// active protectors at all because we will remove all items.\n     fn dealloc(\n         &mut self,\n         tag: Tag,\n@@ -340,16 +339,10 @@ impl<'tcx> Stack {\n                 tag,\n             )))?;\n \n-        // We must make sure there are no protected items remaining on the stack.\n-        // Also clear the stack, no more accesses are possible.\n-        for item in self.borrows.drain(..) {\n-            if let Some(call) = item.protector {\n-                if global.is_active(call) {\n-                    return err!(MachineError(format!(\n-                        \"deallocating with active protector ({})\", call\n-                    )))\n-                }\n-            }\n+        // Step 2: Remove all items.  Also checks for protectors.\n+        while self.borrows.len() > 0 {\n+            let item = self.borrows.pop().unwrap();\n+            Stack::check_protector(&item, None, global)?;\n         }\n \n         Ok(())\n@@ -379,7 +372,6 @@ impl<'tcx> Stack {\n     fn grant(\n         &mut self,\n         derived_from: Tag,\n-        weak: bool,\n         new: Item,\n         global: &GlobalState,\n     ) -> EvalResult<'tcx> {\n@@ -391,35 +383,26 @@ impl<'tcx> Stack {\n         };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let (derived_from_idx, _) = self.find_granting(access, derived_from)\n+        let granting_idx = self.find_granting(access, derived_from)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item to reborrow for {:?} from tag {} found in borrow stack\", new.perm, derived_from,\n             )))?;\n \n         // Compute where to put the new item.\n-        // Either way, we ensure that we insert the new item in a way that between\n+        // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        let new_idx = if weak {\n-            // A weak SharedReadOnly reborrow might be added below other items, violating the\n-            // invariant that only SharedReadOnly can sit on top of SharedReadOnly.\n-            assert!(new.perm != Permission::SharedReadOnly, \"Weak SharedReadOnly reborrows don't work\");\n-            // A very liberal reborrow because the new pointer does not expect any kind of aliasing guarantee.\n-            // Just insert new permission as child of old permission, and maintain everything else.\n-            // This inserts \"as far down as possible\", which is good because it makes this pointer as\n-            // long-lived as possible *and* we want all the items that are incompatible with this\n-            // to actually get removed from the stack.  If we pushed a `SharedReadWrite` on top of\n-            // a `SharedReadOnly`, we'd violate the invariant that `SaredReadOnly` are at the top\n-            // and we'd allow write access without invalidating frozen shared references!\n-            // This ensures F2b for `SharedReadWrite` by adding the new item below any\n-            // potentially existing `SharedReadOnly`.\n-            derived_from_idx + 1\n+        let new_idx = if new.perm == Permission::SharedReadWrite {\n+            assert!(access == AccessKind::Write, \"this case only makes sense for stack-like accesses\");\n+            // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n+            // access.  Instead of popping the stack, we insert the item at the place the stack would\n+            // be popped to (i.e., we insert it above all the write-compatible items).\n+            // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n+            self.find_first_write_incompaible(granting_idx)\n         } else {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n-            // Here, creating a reference actually counts as an access, and pops incompatible\n-            // stuff off the stack.\n+            // Here, creating a reference actually counts as an access.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            let check_idx = self.access(access, derived_from, global)?;\n-            assert_eq!(check_idx, derived_from_idx, \"somehow we saw different items??\");\n+            self.access(access, derived_from, global)?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we\n@@ -550,8 +533,7 @@ impl AllocationExtra<Tag> for Stacks {\n }\n \n /// Retagging/reborrowing.  There is some policy in here, such as which permissions\n-/// to grant for which references, when to add protectors, and how to realize two-phase\n-/// borrows in terms of the primitives above.\n+/// to grant for which references, and when to add protectors.\n impl<'a, 'mir, 'tcx> EvalContextPrivExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n     fn reborrow(\n@@ -560,7 +542,6 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         size: Size,\n         kind: RefKind,\n         new_tag: Tag,\n-        force_weak: bool,\n         protect: bool,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -576,7 +557,8 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n         let perm = match kind {\n-            RefKind::Unique => Permission::Unique,\n+            RefKind::Unique { two_phase: false } => Permission::Unique,\n+            RefKind::Unique { two_phase: true } => Permission::SharedReadWrite,\n             RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n             RefKind::Shared | RefKind::Raw { mutable: false } => {\n                 // Shared references and *const are a whole different kind of game, the\n@@ -585,19 +567,16 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n-                    let weak = perm == Permission::SharedReadWrite;\n                     let item = Item { perm, tag: new_tag, protector };\n                     alloc.extra.for_each(cur_ptr, size, |stack, global| {\n-                        stack.grant(cur_ptr.tag, force_weak || weak, item, global)\n+                        stack.grant(cur_ptr.tag, item, global)\n                     })\n                 });\n             }\n         };\n-        debug_assert_ne!(perm, Permission::SharedReadOnly, \"SharedReadOnly must be used frozen-sensitive\");\n-        let weak = perm == Permission::SharedReadWrite;\n         let item = Item { perm, tag: new_tag, protector };\n         alloc.extra.for_each(ptr, size, |stack, global| {\n-            stack.grant(ptr.tag, force_weak || weak, item, global)\n+            stack.grant(ptr.tag, item, global)\n         })\n     }\n \n@@ -608,7 +587,6 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         val: ImmTy<'tcx, Tag>,\n         kind: RefKind,\n         protect: bool,\n-        two_phase: bool,\n     ) -> EvalResult<'tcx, Immediate<Tag>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n@@ -628,22 +606,8 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         };\n \n         // Reborrow.\n-        // TODO: With `two_phase == true`, this performs a weak reborrow for a `Unique`. That\n-        // can lead to some possibly surprising effects, if the parent permission is\n-        // `SharedReadWrite` then we now have a `Unique` in the middle of them, which \"splits\"\n-        // them in terms of what remains valid when the `Unique` gets used.  Is that really\n-        // what we want?\n-        this.reborrow(place, size, kind, new_tag, /*force_weak:*/ two_phase, protect)?;\n+        this.reborrow(place, size, kind, new_tag, protect)?;\n         let new_place = place.replace_tag(new_tag);\n-        // Handle two-phase borrows.\n-        if two_phase {\n-            assert!(kind == RefKind::Unique, \"two-phase shared borrows make no sense\");\n-            // Grant read access *to the parent pointer* with the old tag *derived from the new tag* (`new_place`). \n-            // This means the old pointer has multiple items in the stack now, which otherwise cannot happen\n-            // for unique references -- but in this case it precisely expresses the semantics we want.\n-            let old_tag = place.ptr.to_ptr().unwrap().tag;\n-            this.reborrow(new_place, size, RefKind::Shared, old_tag, /*force_weak:*/ false, /*protect:*/ false)?;\n-        }\n \n         // Return new pointer.\n         Ok(new_place.to_ref())\n@@ -665,15 +629,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             match ty.sty {\n                 // References are simple.\n                 ty::Ref(_, _, MutMutable) =>\n-                    Some((RefKind::Unique, kind == RetagKind::FnEntry)),\n+                    Some((RefKind::Unique { two_phase: kind == RetagKind::TwoPhase}, kind == RetagKind::FnEntry)),\n                 ty::Ref(_, _, MutImmutable) =>\n                     Some((RefKind::Shared, kind == RetagKind::FnEntry)),\n                 // Raw pointers need to be enabled.\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == MutMutable }, false)),\n                 // Boxes do not get a protector: protectors reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n-                ty::Adt(..) if ty.is_box() => Some((RefKind::Unique, false)),\n+                ty::Adt(..) if ty.is_box() => Some((RefKind::Unique { two_phase: false }, false)),\n                 _ => None,\n             }\n         }\n@@ -684,7 +648,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n-            let val = this.retag_reference(val, mutbl, protector, kind == RetagKind::TwoPhase)?;\n+            let val = this.retag_reference(val, mutbl, protector)?;\n             this.write_immediate(val, place)?;\n             return Ok(());\n         }\n@@ -720,8 +684,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     let val = self.ecx.retag_reference(\n                         val,\n                         mutbl,\n-                        protector,\n-                        self.kind == RetagKind::TwoPhase\n+                        protector\n                     )?;\n                     self.ecx.write_immediate(val, place.into())?;\n                 }"}, {"sha": "58b9b4794b902356c06feb2422a8b3723ff436d9", "filename": "test-cargo-miri/test.stdout.ref", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/858077e5f8935968e699db8b15f7d9a66eddba54/test-cargo-miri%2Ftest.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/858077e5f8935968e699db8b15f7d9a66eddba54/test-cargo-miri%2Ftest.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref?ref=858077e5f8935968e699db8b15f7d9a66eddba54", "patch": "@@ -5,10 +5,9 @@ test test::rng ... ok\n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n \n \n-running 3 tests\n+running 2 tests\n test entropy_rng ... ok\n-test fixed_rng ... ok\n test simple ... ok\n \n-test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "ce3506709d5a09b46c0f09981b198d4d6b7b8dd5", "filename": "test-cargo-miri/test.stdout.ref2", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/858077e5f8935968e699db8b15f7d9a66eddba54/test-cargo-miri%2Ftest.stdout.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/858077e5f8935968e699db8b15f7d9a66eddba54/test-cargo-miri%2Ftest.stdout.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref2?ref=858077e5f8935968e699db8b15f7d9a66eddba54", "patch": "@@ -7,5 +7,5 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n running 1 test\n test simple ... ok\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n "}, {"sha": "ed9efa21e4fa9facb9595f84c16a75b685648e3e", "filename": "test-cargo-miri/tests/test.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/858077e5f8935968e699db8b15f7d9a66eddba54/test-cargo-miri%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858077e5f8935968e699db8b15f7d9a66eddba54/test-cargo-miri%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftests%2Ftest.rs?ref=858077e5f8935968e699db8b15f7d9a66eddba54", "patch": "@@ -1,20 +1,14 @@\n-use rand::{SeedableRng, FromEntropy, Rng, rngs::SmallRng};\n+use rand::{FromEntropy, Rng, rngs::SmallRng};\n \n+// Having more than 1 test does seem to make a difference\n+// (i.e., this calls ptr::swap which having just one test does not).\n #[test]\n fn simple() {\n     assert_eq!(4, 4);\n }\n \n // Having more than 1 test does seem to make a difference\n // (i.e., this calls ptr::swap which having just one test does not).\n-#[test]\n-fn fixed_rng() {\n-    let mut rng = rand::rngs::StdRng::seed_from_u64(0xdeadcafe);\n-    let x: u32 = rng.gen();\n-    let y: u32 = rng.gen();\n-    assert_ne!(x, y);\n-}\n-\n #[test]\n fn entropy_rng() {\n     // Use this opportunity to test querying the RNG (needs an external crate, hence tested here and not in the compiletest suite)"}, {"sha": "bf18c9a058cf969685bf8c5c4ab09caa4cb2c5d3", "filename": "tests/compile-fail/stacked_borrows/deallocate_against_barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/858077e5f8935968e699db8b15f7d9a66eddba54/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858077e5f8935968e699db8b15f7d9a66eddba54/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs?ref=858077e5f8935968e699db8b15f7d9a66eddba54", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: deallocating with active protect\n+// error-pattern: deallocating while item is protected\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "dd9fce110c2d304b250891b846dc692459f4eb40", "filename": "tests/compile-fail/stacked_borrows/interior_mut1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/858077e5f8935968e699db8b15f7d9a66eddba54/tests%2Fcompile-fail%2Fstacked_borrows%2Finterior_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858077e5f8935968e699db8b15f7d9a66eddba54/tests%2Fcompile-fail%2Fstacked_borrows%2Finterior_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Finterior_mut1.rs?ref=858077e5f8935968e699db8b15f7d9a66eddba54", "patch": "@@ -0,0 +1,10 @@\n+use std::cell::UnsafeCell;\n+\n+fn main() { unsafe {\n+    let c = &UnsafeCell::new(UnsafeCell::new(0));\n+    let inner_uniq = &mut *c.get();\n+    let inner_shr = &*inner_uniq; // a SharedRW with a tag\n+    *c.get() = UnsafeCell::new(1); // invalidates the SharedRW\n+    let _val = *inner_shr.get(); //~ ERROR borrow stack\n+    let _val = *inner_uniq.get();\n+} }"}, {"sha": "d27519df48a752132cdf8c16b601f3c99249421e", "filename": "tests/run-pass/stacked-borrows/interior_mutability.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/858077e5f8935968e699db8b15f7d9a66eddba54/tests%2Frun-pass%2Fstacked-borrows%2Finterior_mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858077e5f8935968e699db8b15f7d9a66eddba54/tests%2Frun-pass%2Fstacked-borrows%2Finterior_mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2Finterior_mutability.rs?ref=858077e5f8935968e699db8b15f7d9a66eddba54", "patch": "@@ -1,12 +1,12 @@\n #![feature(maybe_uninit, maybe_uninit_ref)]\n use std::mem::MaybeUninit;\n-use std::cell::Cell;\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell, UnsafeCell};\n \n fn main() {\n     aliasing_mut_and_shr();\n     aliasing_frz_and_shr();\n     into_interior_mutability();\n+    unsafe_cell_2phase();\n }\n \n fn aliasing_mut_and_shr() {\n@@ -57,3 +57,12 @@ fn into_interior_mutability() {\n     let ptr = unsafe { x.get_ref() };\n     assert_eq!(ptr.1, 1);\n }\n+\n+// Two-phase borrows of the pointer returned by UnsafeCell::get() should not\n+// invalidate aliases.\n+fn unsafe_cell_2phase() { unsafe {\n+    let x = &UnsafeCell::new(vec![]);\n+    let x2 = &*x;\n+    (*x.get()).push(0);\n+    let _val = (*x2.get()).get(0);\n+} }"}]}