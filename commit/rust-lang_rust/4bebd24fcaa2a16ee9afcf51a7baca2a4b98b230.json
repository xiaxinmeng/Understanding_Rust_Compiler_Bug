{"sha": "4bebd24fcaa2a16ee9afcf51a7baca2a4b98b230", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZWJkMjRmY2FhMmExNmVlOWFmY2Y1MWE3YmFjYTJhNGI5OGIyMzA=", "commit": {"author": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-06-18T05:23:51Z"}, "committer": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-06-26T18:31:35Z"}, "message": "Remove functions that always error", "tree": {"sha": "a8eeec073ef98061a4f34e91810529afb717e3ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8eeec073ef98061a4f34e91810529afb717e3ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bebd24fcaa2a16ee9afcf51a7baca2a4b98b230", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEvF2uTsFosfm5TJhQMFXVRymnJmYFAlsyhocACgkQMFXVRymn\nJmZOGgf7BsKVIdB+O0fQXD8xuWlbHjtYcIpQhCwhVcYlGml5bTMjUqpYK0DnWYmM\nWu/+IDQKGKtE6Iwcl6fmWhaZC+zdll4oSBxs+eBJ65n8m+/7ByZbtYwfYKzmUEyA\n6IJQawRYGejEQE61KrbJUEaqJMifwfqygf1qCfDiTNhxrkRIoEeuMSMGbOqYm2G/\nadaP1fCj3O3w0h6pRSt33F03XbN2yU/Slf0fLev6ZhJTev5haMtCReEDLI3KWp+s\nYXha0y2ysjfXYSfBSxf/cJiqsYG6XFlgxG4CCyJSvlvwvHm9SnwlZSw7i5jTSRrO\n6iEcohxA0WWfkqa3VELy9dOB8qs5Qw==\n=+Xtf\n-----END PGP SIGNATURE-----", "payload": "tree a8eeec073ef98061a4f34e91810529afb717e3ed\nparent 4286ad7f0d3e1c39ac31205e43011e29b1486dcf\nauthor jD91mZM2 <me@krake.one> 1529299431 +0200\ncommitter jD91mZM2 <me@krake.one> 1530037895 +0200\n\nRemove functions that always error\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bebd24fcaa2a16ee9afcf51a7baca2a4b98b230", "html_url": "https://github.com/rust-lang/rust/commit/4bebd24fcaa2a16ee9afcf51a7baca2a4b98b230", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bebd24fcaa2a16ee9afcf51a7baca2a4b98b230/comments", "author": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4286ad7f0d3e1c39ac31205e43011e29b1486dcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4286ad7f0d3e1c39ac31205e43011e29b1486dcf", "html_url": "https://github.com/rust-lang/rust/commit/4286ad7f0d3e1c39ac31205e43011e29b1486dcf"}], "stats": {"total": 181, "additions": 0, "deletions": 181}, "files": [{"sha": "0dab7db9a93dcd31fdcd32155fedafa0f844db82", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "modified", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/4bebd24fcaa2a16ee9afcf51a7baca2a4b98b230/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bebd24fcaa2a16ee9afcf51a7baca2a4b98b230/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=4bebd24fcaa2a16ee9afcf51a7baca2a4b98b230", "patch": "@@ -94,12 +94,6 @@ impl fmt::Debug for UnixStream {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixStream\");\n         builder.field(\"fd\", &self.0.raw());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n         builder.finish()\n     }\n }\n@@ -177,142 +171,6 @@ impl UnixStream {\n         self.0.duplicate().map(UnixStream)\n     }\n \n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    /// ```\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`read`]: ../../../../std/io/trait.Read.html#tymethod.read\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n-    /// [`Err`]: ../../../../std/result/enum.Result.html#variant.Err\n-    /// [`write`]: ../../../../std/io/trait.Write.html#tymethod.write\n-    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n-    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    /// let err = result.unwrap_err();\n-    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n-    /// ```\n-    pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n-    /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n-    /// ```\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n-    }\n-\n     /// Moves the socket into or out of nonblocking mode.\n     ///\n     /// # Examples\n@@ -342,27 +200,6 @@ impl UnixStream {\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n     }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    /// ```\n-    pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n-    }\n }\n \n impl io::Read for UnixStream {\n@@ -459,9 +296,6 @@ impl fmt::Debug for UnixListener {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixListener\");\n         builder.field(\"fd\", &self.0.raw());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n         builder.finish()\n     }\n }\n@@ -538,21 +372,6 @@ impl UnixListener {\n         self.0.duplicate().map(UnixListener)\n     }\n \n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n-    ///\n-    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    /// ```\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n-    }\n-\n     /// Moves the socket into or out of nonblocking mode.\n     ///\n     /// # Examples"}]}