{"sha": "3ce443828be823cac2791d2b8392c33db9320677", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZTQ0MzgyOGJlODIzY2FjMjc5MWQyYjgzOTJjMzNkYjkzMjA2Nzc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-28T12:04:13Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: adjust the RHS of comparison operators instead of assuming autorefs.", "tree": {"sha": "2d77afc66e961aacbebd03d429d1456a39469840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d77afc66e961aacbebd03d429d1456a39469840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ce443828be823cac2791d2b8392c33db9320677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce443828be823cac2791d2b8392c33db9320677", "html_url": "https://github.com/rust-lang/rust/commit/3ce443828be823cac2791d2b8392c33db9320677", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ce443828be823cac2791d2b8392c33db9320677/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "194fe695e3af6f03953cbb4ca66f159993f6214d", "url": "https://api.github.com/repos/rust-lang/rust/commits/194fe695e3af6f03953cbb4ca66f159993f6214d", "html_url": "https://github.com/rust-lang/rust/commit/194fe695e3af6f03953cbb4ca66f159993f6214d"}], "stats": {"total": 434, "additions": 114, "deletions": 320}, "files": [{"sha": "bb56439a157fe260f0ef13285a164a6ccf8d3010", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 13, "deletions": 87, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3ce443828be823cac2791d2b8392c33db9320677", "patch": "@@ -263,12 +263,6 @@ macro_rules! return_if_err {\n     )\n }\n \n-/// Whether the elements of an overloaded operation are passed by value or by reference\n-enum PassArgs {\n-    ByValue,\n-    ByRef,\n-}\n-\n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n                region_maps: &'a RegionMaps,\n@@ -382,9 +376,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprUnary(hir::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &base, Vec::new(), PassArgs::ByRef) {\n-                    self.select_from_expr(&base);\n-                }\n+                self.select_from_expr(&base);\n             }\n \n             hir::ExprField(ref base, _) => {         // base.f\n@@ -396,13 +388,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr,\n-                                                  &lhs,\n-                                                  vec![&rhs],\n-                                                  PassArgs::ByValue) {\n-                    self.select_from_expr(&lhs);\n-                    self.consume_expr(&rhs);\n-                }\n+                self.select_from_expr(&lhs);\n+                self.consume_expr(&rhs);\n             }\n \n             hir::ExprCall(ref callee, ref args) => {    // callee(args)\n@@ -485,29 +472,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprUnary(op, ref lhs) => {\n-                let pass_args = if op.is_by_value() {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n-\n-                if !self.walk_overloaded_operator(expr, &lhs, Vec::new(), pass_args) {\n-                    self.consume_expr(&lhs);\n-                }\n+            hir::ExprUnary(_, ref lhs) => {\n+                self.consume_expr(&lhs);\n             }\n \n-            hir::ExprBinary(op, ref lhs, ref rhs) => {\n-                let pass_args = if op.node.is_by_value() {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n-\n-                if !self.walk_overloaded_operator(expr, &lhs, vec![&rhs], pass_args) {\n-                    self.consume_expr(&lhs);\n-                    self.consume_expr(&rhs);\n-                }\n+            hir::ExprBinary(_, ref lhs, ref rhs) => {\n+                self.consume_expr(&lhs);\n+                self.consume_expr(&rhs);\n             }\n \n             hir::ExprBlock(ref blk) => {\n@@ -529,14 +500,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                // NB All our assignment operations take the RHS by value\n-                assert!(op.node.is_by_value());\n-\n-                if !self.walk_overloaded_operator(expr, lhs, vec![rhs], PassArgs::ByValue) {\n+            hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n+                if self.mc.infcx.tables.borrow().is_method_call(expr) {\n+                    self.consume_expr(lhs);\n+                } else {\n                     self.mutate_expr(expr, &lhs, MutateMode::WriteAndRead);\n-                    self.consume_expr(&rhs);\n                 }\n+                self.consume_expr(&rhs);\n             }\n \n             hir::ExprRepeat(ref base, _) => {\n@@ -784,50 +754,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-\n-    // When this returns true, it means that the expression *is* a\n-    // method-call (i.e. via the operator-overload).  This true result\n-    // also implies that walk_overloaded_operator already took care of\n-    // recursively processing the input arguments, and thus the caller\n-    // should not do so.\n-    fn walk_overloaded_operator(&mut self,\n-                                expr: &hir::Expr,\n-                                receiver: &hir::Expr,\n-                                rhs: Vec<&hir::Expr>,\n-                                pass_args: PassArgs)\n-                                -> bool\n-    {\n-        if !self.mc.infcx.tables.borrow().is_method_call(expr) {\n-            return false;\n-        }\n-\n-        match pass_args {\n-            PassArgs::ByValue => {\n-                self.consume_expr(receiver);\n-                for &arg in &rhs {\n-                    self.consume_expr(arg);\n-                }\n-\n-                return true;\n-            },\n-            PassArgs::ByRef => {},\n-        }\n-\n-        self.walk_expr(receiver);\n-\n-        // Arguments (but not receivers) to overloaded operator\n-        // methods are implicitly autoref'd which sadly does not use\n-        // adjustments, so we must hardcode the borrow here.\n-\n-        let r = self.tcx().node_scope_region(expr.id);\n-        let bk = ty::ImmBorrow;\n-\n-        for &arg in &rhs {\n-            self.borrow_expr(arg, r, bk, OverloadedOperator);\n-        }\n-        return true;\n-    }\n-\n     fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {\n         let mut mode = Unknown;\n         for pat in &arm.pats {"}, {"sha": "2c3f51969267f33811477d912c15e86fd73e4edd", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 18, "deletions": 111, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=3ce443828be823cac2791d2b8392c33db9320677", "patch": "@@ -21,7 +21,6 @@ use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::ty::subst::Subst;\n use rustc::hir;\n-use syntax::ptr::P;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n@@ -117,13 +116,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 },\n             };\n \n-            overloaded_lvalue(cx,\n-                              hir_expr,\n-                              adjustment.target,\n-                              Some(call),\n-                              PassArgs::ByValue,\n-                              expr.to_ref(),\n-                              vec![])\n+            overloaded_lvalue(cx, hir_expr, adjustment.target, Some(call), vec![expr.to_ref()])\n         }\n         Adjust::Borrow(AutoBorrow::Ref(r, m)) => {\n             ExprKind::Borrow {\n@@ -281,17 +274,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n             if cx.tables().is_method_call(expr) {\n-                let pass_args = if op.node.is_by_value() {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n-                overloaded_operator(cx,\n-                                    expr,\n-                                    None,\n-                                    pass_args,\n-                                    lhs.to_ref(),\n-                                    vec![rhs])\n+                overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n                 ExprKind::AssignOp {\n                     op: bin_op(op.node),\n@@ -305,17 +288,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             if cx.tables().is_method_call(expr) {\n-                let pass_args = if op.node.is_by_value() {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n-                overloaded_operator(cx,\n-                                    expr,\n-                                    None,\n-                                    pass_args,\n-                                    lhs.to_ref(),\n-                                    vec![rhs])\n+                overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n                 // FIXME overflow\n                 match (op.node, cx.constness) {\n@@ -365,13 +338,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprIndex(ref lhs, ref index) => {\n             if cx.tables().is_method_call(expr) {\n-                overloaded_lvalue(cx,\n-                                  expr,\n-                                  expr_ty,\n-                                  None,\n-                                  PassArgs::ByValue,\n-                                  lhs.to_ref(),\n-                                  vec![index])\n+                overloaded_lvalue(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n             } else {\n                 ExprKind::Index {\n                     lhs: lhs.to_ref(),\n@@ -382,26 +349,15 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n-                overloaded_lvalue(cx,\n-                                  expr,\n-                                  expr_ty,\n-                                  None,\n-                                  PassArgs::ByValue,\n-                                  arg.to_ref(),\n-                                  vec![])\n+                overloaded_lvalue(cx, expr, expr_ty, None, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n-                overloaded_operator(cx,\n-                                    expr,\n-                                    None,\n-                                    PassArgs::ByValue,\n-                                    arg.to_ref(),\n-                                    vec![])\n+                overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Unary {\n                     op: UnOp::Not,\n@@ -412,12 +368,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n             if cx.tables().is_method_call(expr) {\n-                overloaded_operator(cx,\n-                                    expr,\n-                                    None,\n-                                    PassArgs::ByValue,\n-                                    arg.to_ref(),\n-                                    vec![])\n+                overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n                 // FIXME runtime-overflow\n                 if let hir::ExprLit(_) = arg.node {\n@@ -873,77 +824,29 @@ fn bin_op(op: hir::BinOp_) -> BinOp {\n     }\n }\n \n-enum PassArgs {\n-    ByValue,\n-    ByRef,\n-}\n-\n fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                        expr: &'tcx hir::Expr,\n-                                       custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n-                                       pass_args: PassArgs,\n-                                       receiver: ExprRef<'tcx>,\n-                                       args: Vec<&'tcx P<hir::Expr>>)\n+                                       args: Vec<ExprRef<'tcx>>)\n                                        -> ExprKind<'tcx> {\n-    // the receiver has all the adjustments that are needed, so we can\n-    // just push a reference to it\n-    let mut argrefs = vec![receiver];\n-\n-    // the arguments, unfortunately, do not, so if this is a ByRef\n-    // operator, we have to gin up the autorefs (but by value is easy)\n-    match pass_args {\n-        PassArgs::ByValue => argrefs.extend(args.iter().map(|arg| arg.to_ref())),\n-\n-        PassArgs::ByRef => {\n-            let region = cx.tcx.node_scope_region(expr.id);\n-            let (temp_lifetime, was_shrunk) =\n-                cx.region_maps.temporary_scope2(expr.id);\n-            argrefs.extend(args.iter()\n-                .map(|arg| {\n-                    let arg_ty = cx.tables().expr_ty_adjusted(arg);\n-                    let adjusted_ty = cx.tcx.mk_ref(region,\n-                                                    ty::TypeAndMut {\n-                                                        ty: arg_ty,\n-                                                        mutbl: hir::MutImmutable,\n-                                                    });\n-                    Expr {\n-                        temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n-                        ty: adjusted_ty,\n-                        span: expr.span,\n-                        kind: ExprKind::Borrow {\n-                            region: region,\n-                            borrow_kind: BorrowKind::Shared,\n-                            arg: arg.to_ref(),\n-                        },\n-                    }\n-                    .to_ref()\n-                }))\n-        }\n-    }\n-\n-    // now create the call itself\n-    let fun = method_callee(cx, expr, custom_callee);\n+    let fun = method_callee(cx, expr, None);\n     ExprKind::Call {\n         ty: fun.ty,\n         fun: fun.to_ref(),\n-        args: argrefs,\n+        args,\n     }\n }\n \n fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      lvalue_ty: Ty<'tcx>,\n                                      custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n-                                     pass_args: PassArgs,\n-                                     receiver: ExprRef<'tcx>,\n-                                     args: Vec<&'tcx P<hir::Expr>>)\n+                                     args: Vec<ExprRef<'tcx>>)\n                                      -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n-    let recv_ty = match receiver {\n+    let recv_ty = match args[0] {\n         ExprRef::Hair(e) => cx.tables().expr_ty_adjusted(e),\n         ExprRef::Mirror(ref e) => e.ty\n     };\n@@ -963,13 +866,17 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n     let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n-    let ref_kind = overloaded_operator(cx, expr, custom_callee, pass_args, receiver, args);\n+    let fun = method_callee(cx, expr, custom_callee);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n         ty: ref_ty,\n         span: expr.span,\n-        kind: ref_kind,\n+        kind: ExprKind::Call {\n+            ty: fun.ty,\n+            fun: fun.to_ref(),\n+            args,\n+        },\n     };\n \n     // construct and return a deref wrapper `*foo()`"}, {"sha": "32c3f5c8a5edd98a65207489395fc4c1ec3a16d7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3ce443828be823cac2791d2b8392c33db9320677", "patch": "@@ -3424,10 +3424,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                                lvalue_pref);\n \n             if !oprnd_t.references_error() {\n+                oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n                 match unop {\n                     hir::UnDeref => {\n-                        oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n-\n                         if let Some(mt) = oprnd_t.builtin_deref(true, NoPreference) {\n                             oprnd_t = mt.ty;\n                         } else if let Some(ok) = self.try_overloaded_deref(\n@@ -3450,18 +3449,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     hir::UnNot => {\n-                        oprnd_t = self.structurally_resolved_type(oprnd.span,\n-                                                                  oprnd_t);\n-                        let result = self.check_user_unop(expr, &oprnd, oprnd_t, unop);\n+                        let result = self.check_user_unop(expr, oprnd_t, unop);\n                         // If it's builtin, we can reuse the type, this helps inference.\n                         if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n                             oprnd_t = result;\n                         }\n                     }\n                     hir::UnNeg => {\n-                        oprnd_t = self.structurally_resolved_type(oprnd.span,\n-                                                                  oprnd_t);\n-                        let result = self.check_user_unop(expr, &oprnd, oprnd_t, unop);\n+                        let result = self.check_user_unop(expr, oprnd_t, unop);\n                         // If it's builtin, we can reuse the type, this helps inference.\n                         if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n                             oprnd_t = result;"}, {"sha": "8e5b7a6546973425553455f0cdfe98c44678a041", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 57, "deletions": 45, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=3ce443828be823cac2791d2b8392c33db9320677", "patch": "@@ -11,11 +11,13 @@\n //! Code related to processing overloaded binary and unary operators.\n \n use super::FnCtxt;\n+use super::method::MethodCallee;\n use rustc::ty::{self, Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n+use syntax_pos::Span;\n use syntax::symbol::Symbol;\n use rustc::hir;\n \n@@ -181,14 +183,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // particularly for things like `String + &String`.\n         let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n-        let return_ty = self.lookup_op_method(expr, lhs_ty, &[rhs_ty_var],\n-                                              Op::Binary(op, is_assign), lhs_expr);\n+        let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n \n         // see `NB` above\n         let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n \n-        let return_ty = match return_ty {\n-            Ok(return_ty) => return_ty,\n+        let return_ty = match result {\n+            Ok(method) => {\n+                let by_ref_binop = !op.node.is_by_value();\n+                if is_assign == IsAssign::Yes || by_ref_binop {\n+                    if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                        let autoref = Adjustment {\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            target: method.sig.inputs()[0]\n+                        };\n+                        self.apply_adjustments(lhs_expr, vec![autoref]);\n+                    }\n+                }\n+                if by_ref_binop {\n+                    if let ty::TyRef(region, mt) = method.sig.inputs()[1].sty {\n+                        let autoref = Adjustment {\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            target: method.sig.inputs()[1]\n+                        };\n+                        // HACK(eddyb) Bypass checks due to reborrows being in\n+                        // some cases applied on the RHS, on top of which we need\n+                        // to autoref, which is not allowed by apply_adjustments.\n+                        // self.apply_adjustments(rhs_expr, vec![autoref]);\n+                        self.tables.borrow_mut().adjustments.entry(rhs_expr.id)\n+                            .or_insert(vec![]).push(autoref);\n+                    }\n+                }\n+                self.write_method_call(expr.id, method);\n+\n+                method.sig.output()\n+            }\n             Err(()) => {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n@@ -210,8 +239,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n                             if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n-                                self.lookup_op_method(expr, ty_mut.ty, &[rhs_ty],\n-                                                      Op::Binary(op, is_assign), lhs_expr).is_ok() {\n+                                self.lookup_op_method(ty_mut.ty, &[rhs_ty],\n+                                                      Op::Binary(op, is_assign)).is_ok() {\n                                 err.note(\n                                     &format!(\n                                         \"this is a reference to a type that `{}` can be applied \\\n@@ -298,14 +327,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_user_unop(&self,\n                            ex: &'gcx hir::Expr,\n-                           operand_expr: &'gcx hir::Expr,\n                            operand_ty: Ty<'tcx>,\n                            op: hir::UnOp)\n                            -> Ty<'tcx>\n     {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(ex, operand_ty, &[], Op::Unary(op), operand_expr) {\n-            Ok(t) => t,\n+        match self.lookup_op_method(operand_ty, &[], Op::Unary(op, ex.span)) {\n+            Ok(method) => {\n+                self.write_method_call(ex.id, method);\n+                method.sig.output()\n+            }\n             Err(()) => {\n                 let actual = self.resolve_type_vars_if_possible(&operand_ty);\n                 if !actual.references_error() {\n@@ -318,16 +349,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn lookup_op_method(&self,\n-                        expr: &'gcx hir::Expr,\n-                        lhs_ty: Ty<'tcx>,\n-                        other_tys: &[Ty<'tcx>],\n-                        op: Op,\n-                        lhs_expr: &'a hir::Expr)\n-                        -> Result<Ty<'tcx>,()>\n+    fn lookup_op_method(&self, lhs_ty: Ty<'tcx>, other_tys: &[Ty<'tcx>], op: Op)\n+                        -> Result<MethodCallee<'tcx>, ()>\n     {\n         let lang = &self.tcx.lang_items;\n \n+        let span = match op {\n+            Op::Binary(op, _) => op.span,\n+            Op::Unary(_, span) => span\n+        };\n         let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n             match op.node {\n                 hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n@@ -344,7 +374,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::BiGe | hir::BiGt |\n                 hir::BiEq | hir::BiNe |\n                 hir::BiAnd | hir::BiOr => {\n-                    span_bug!(op.span,\n+                    span_bug!(span,\n                               \"impossible assignment operation: {}=\",\n                               op.node.as_str())\n                 }\n@@ -368,52 +398,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::BiEq => (\"eq\", lang.eq_trait()),\n                 hir::BiNe => (\"ne\", lang.eq_trait()),\n                 hir::BiAnd | hir::BiOr => {\n-                    span_bug!(op.span, \"&& and || are not overloadable\")\n+                    span_bug!(span, \"&& and || are not overloadable\")\n                 }\n             }\n-        } else if let Op::Unary(hir::UnNot) = op {\n+        } else if let Op::Unary(hir::UnNot, _) = op {\n             (\"not\", lang.not_trait())\n-        } else if let Op::Unary(hir::UnNeg) = op {\n+        } else if let Op::Unary(hir::UnNeg, _) = op {\n             (\"neg\", lang.neg_trait())\n         } else {\n             bug!(\"lookup_op_method: op not supported: {:?}\", op)\n         };\n \n-        debug!(\"lookup_op_method(expr={:?}, lhs_ty={:?}, opname={:?}, \\\n-                                 trait_did={:?}, lhs_expr={:?})\",\n-               expr,\n+        debug!(\"lookup_op_method(lhs_ty={:?}, op={:?}, opname={:?}, trait_did={:?})\",\n                lhs_ty,\n+               op,\n                opname,\n-               trait_did,\n-               lhs_expr);\n+               trait_did);\n \n         let method = trait_did.and_then(|trait_did| {\n             let opname = Symbol::intern(opname);\n-            self.lookup_method_in_trait(expr.span, opname, trait_did, lhs_ty, Some(other_tys))\n+            self.lookup_method_in_trait(span, opname, trait_did, lhs_ty, Some(other_tys))\n         });\n \n         match method {\n             Some(ok) => {\n                 let method = self.register_infer_ok_obligations(ok);\n                 self.select_obligations_where_possible();\n \n-                let (lhs_by_ref, _rhs_by_ref) = match op {\n-                    Op::Binary(_, IsAssign::Yes) => (true, false),\n-                    Op::Binary(op, _) if !op.node.is_by_value() => (true, true),\n-                    Op::Binary(..) | Op::Unary(_) => (false, false),\n-                };\n-                if lhs_by_ref {\n-                    if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n-                        let autoref = Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n-                            target: method.sig.inputs()[0]\n-                        };\n-                        self.apply_adjustments(lhs_expr, vec![autoref]);\n-                    }\n-                }\n-                self.write_method_call(expr.id, method);\n-\n-                Ok(method.sig.output())\n+                Ok(method)\n             }\n             None => {\n                 Err(())\n@@ -479,7 +491,7 @@ impl BinOpCategory {\n }\n \n /// Whether the binary operation is an assignment (`a += b`), or not (`a + b`)\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n enum IsAssign {\n     No,\n     Yes,\n@@ -488,7 +500,7 @@ enum IsAssign {\n #[derive(Clone, Copy, Debug)]\n enum Op {\n     Binary(hir::BinOp, IsAssign),\n-    Unary(hir::UnOp),\n+    Unary(hir::UnOp, Span),\n }\n \n /// Returns true if this is a built-in arithmetic operation (e.g. u32"}, {"sha": "33fbc006e4e1fa417992fbc1909f37bee2b9b4f8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 20, "deletions": 63, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3ce443828be823cac2791d2b8392c33db9320677", "patch": "@@ -566,49 +566,38 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprCall(ref callee, ref args) => {\n                 if is_method_call {\n-                    self.constrain_call(expr, Some(&callee),\n-                                        args.iter().map(|e| &*e), false);\n+                    self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n                 } else {\n                     self.constrain_callee(callee.id, expr, &callee);\n-                    self.constrain_call(expr, None,\n-                                        args.iter().map(|e| &*e), false);\n+                    self.constrain_call(expr, None, args.iter().map(|e| &*e));\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n             hir::ExprMethodCall(.., ref args) => {\n-                self.constrain_call(expr, Some(&args[0]),\n-                                    args[1..].iter().map(|e| &*e), false);\n+                self.constrain_call(expr, Some(&args[0]), args[1..].iter().map(|e| &*e));\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n             hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n                 if is_method_call {\n-                    self.constrain_call(expr, Some(&lhs),\n-                                        Some(&**rhs).into_iter(), false);\n+                    self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n             hir::ExprIndex(ref lhs, ref rhs) if is_method_call => {\n-                self.constrain_call(expr, Some(&lhs),\n-                                    Some(&**rhs).into_iter(), true);\n+                self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n             },\n \n-            hir::ExprBinary(op, ref lhs, ref rhs) if is_method_call => {\n-                let implicitly_ref_args = !op.node.is_by_value();\n-\n-                // As `expr_method_call`, but the call is via an\n-                // overloaded op.  Note that we (sadly) currently use an\n-                // implicit \"by ref\" sort of passing style here.  This\n-                // should be converted to an adjustment!\n-                self.constrain_call(expr, Some(&lhs),\n-                                    Some(&**rhs).into_iter(), implicitly_ref_args);\n+            hir::ExprBinary(_, ref lhs, ref rhs) if is_method_call => {\n+                // As `ExprMethodCall`, but the call is via an overloaded op.\n+                self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n             }\n@@ -625,21 +614,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprUnary(op, ref lhs) if is_method_call => {\n-                let implicitly_ref_args = !op.is_by_value();\n-\n-                // As above.\n-                self.constrain_call(expr, Some(&lhs),\n-                                    None::<hir::Expr>.iter(), implicitly_ref_args);\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n             hir::ExprUnary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n-                if self.tables.borrow().is_method_call(expr) {\n-                    self.constrain_call(expr, Some(base),\n-                                        None::<hir::Expr>.iter(), true);\n+                if is_method_call {\n+                    self.constrain_call(expr, Some(base), None::<hir::Expr>.iter());\n                 }\n                 // For overloaded derefs, base_ty is the input to `Deref::deref`,\n                 // but it's a reference type uing the same region as the output.\n@@ -651,6 +629,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n+            hir::ExprUnary(_, ref lhs) if is_method_call => {\n+                // As above.\n+                self.constrain_call(expr, Some(&lhs), None::<hir::Expr>.iter());\n+\n+                intravisit::walk_expr(self, expr);\n+            }\n+\n             hir::ExprIndex(ref vec_expr, _) => {\n                 // For a[b], the lifetime of a must enclose the deref\n                 let vec_type = self.resolve_expr_type_adjusted(&vec_expr);\n@@ -802,19 +787,15 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n                                                            call_expr: &hir::Expr,\n                                                            receiver: Option<&hir::Expr>,\n-                                                           arg_exprs: I,\n-                                                           implicitly_ref_args: bool) {\n+                                                           arg_exprs: I) {\n         //! Invoked on every call site (i.e., normal calls, method calls,\n         //! and overloaded operators). Constrains the regions which appear\n         //! in the type of the function. Also constrains the regions that\n         //! appear in the arguments appropriately.\n \n-        debug!(\"constrain_call(call_expr={:?}, \\\n-                receiver={:?}, \\\n-                implicitly_ref_args={})\",\n+        debug!(\"constrain_call(call_expr={:?}, receiver={:?})\",\n                 call_expr,\n-                receiver,\n-                implicitly_ref_args);\n+                receiver);\n \n         // `callee_region` is the scope representing the time in which the\n         // call occurs.\n@@ -832,24 +813,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // valid for at least the lifetime of the function:\n             self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n                                            arg_expr.id, callee_region);\n-\n-            // unfortunately, there are two means of taking implicit\n-            // references, and we need to propagate constraints as a\n-            // result. modes are going away and the \"DerefArgs\" code\n-            // should be ported to use adjustments\n-            if implicitly_ref_args {\n-                self.link_by_ref(arg_expr, callee_scope);\n-            }\n         }\n \n         // as loop above, but for receiver\n         if let Some(r) = receiver {\n             debug!(\"receiver: {:?}\", r);\n             self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n                                            r.id, callee_region);\n-            if implicitly_ref_args {\n-                self.link_by_ref(&r, callee_scope);\n-            }\n         }\n     }\n \n@@ -1111,19 +1081,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Computes the guarantor for cases where the `expr` is being passed by implicit reference and\n-    /// must outlive `callee_scope`.\n-    fn link_by_ref(&self,\n-                   expr: &hir::Expr,\n-                   callee_scope: CodeExtent) {\n-        debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n-               expr, callee_scope);\n-        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-        let expr_cmt = ignore_err!(mc.cat_expr(expr));\n-        let borrow_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n-        self.link_region(expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n-    }\n-\n     /// Like `link_region()`, except that the region is extracted from the type of `id`,\n     /// which must be some reference (`&T`, `&str`, etc).\n     fn link_region_from_node_type(&self,"}, {"sha": "012fde16d875e256031ee3415597715ad7dfd31c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce443828be823cac2791d2b8392c33db9320677/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3ce443828be823cac2791d2b8392c33db9320677", "patch": "@@ -123,18 +123,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     tables.type_dependent_defs.remove(&e.id);\n                     tables.node_substs.remove(&e.id);\n \n-                    // weird but true: the by-ref binops put an\n-                    // adjustment on the lhs but not the rhs; the\n-                    // adjustment for rhs is kind of baked into the\n-                    // system.\n                     match e.node {\n                         hir::ExprBinary(..) => {\n                             if !op.node.is_by_value() {\n-                                tables.adjustments.remove(&lhs.id);\n+                                tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n+                                tables.adjustments.get_mut(&rhs.id).map(|a| a.pop());\n                             }\n                         },\n                         hir::ExprAssignOp(..) => {\n-                            tables.adjustments.remove(&lhs.id);\n+                            tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n                         },\n                         _ => {},\n                     }"}]}