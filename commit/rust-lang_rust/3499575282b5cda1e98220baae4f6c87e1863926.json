{"sha": "3499575282b5cda1e98220baae4f6c87e1863926", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0OTk1NzUyODJiNWNkYTFlOTgyMjBiYWFlNGY2Yzg3ZTE4NjM5MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-11T14:04:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-11T14:04:15Z"}, "message": "Auto merge of #56243 - RalfJung:test-deterministic, r=alexcrichton\n\nlibtest: Use deterministic HashMap, avoid spawning thread if there is no concurrency\n\nIt seems desirable to make a test and bench runner deterministic, which this achieves by using a deterministic hasher. Also, we we only have 1 thread, we don't bother spawning one and just use the main thread.\n\nThe motivation for this is to be able to run the test harness in miri, where we can neither access the OS RNG, nor spawn threads.", "tree": {"sha": "9fd1f65a0edde4bbf7c2fe895ac5ac9619b4864d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fd1f65a0edde4bbf7c2fe895ac5ac9619b4864d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3499575282b5cda1e98220baae4f6c87e1863926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3499575282b5cda1e98220baae4f6c87e1863926", "html_url": "https://github.com/rust-lang/rust/commit/3499575282b5cda1e98220baae4f6c87e1863926", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3499575282b5cda1e98220baae4f6c87e1863926/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a3121337122637fa11f0e5d42aec67551e8c125", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a3121337122637fa11f0e5d42aec67551e8c125", "html_url": "https://github.com/rust-lang/rust/commit/3a3121337122637fa11f0e5d42aec67551e8c125"}, {"sha": "c28c28779c082b6e1d0e7007a222392dc5d6c052", "url": "https://api.github.com/repos/rust-lang/rust/commits/c28c28779c082b6e1d0e7007a222392dc5d6c052", "html_url": "https://github.com/rust-lang/rust/commit/c28c28779c082b6e1d0e7007a222392dc5d6c052"}], "stats": {"total": 44, "additions": 28, "deletions": 16}, "files": [{"sha": "1c8734913c7231b943ce13e5ccadbb6d8f9f336d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3499575282b5cda1e98220baae4f6c87e1863926/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3499575282b5cda1e98220baae4f6c87e1863926/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3499575282b5cda1e98220baae4f6c87e1863926", "patch": "@@ -99,6 +99,10 @@ mod formatters;\n \n use formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n \n+/// Whether to execute tests concurrently or not\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Concurrent { Yes, No }\n+\n // The name of a test. By convention this follows the rules for rust\n // paths; i.e., it should be a series of identifiers separated by double\n // colons. This way if some test runner wants to arrange the tests\n@@ -1073,8 +1077,12 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n where\n     F: FnMut(TestEvent) -> io::Result<()>,\n {\n-    use std::collections::HashMap;\n+    use std::collections::{self, HashMap};\n+    use std::hash::BuildHasherDefault;\n     use std::sync::mpsc::RecvTimeoutError;\n+    // Use a deterministic hasher\n+    type TestMap =\n+        HashMap<TestDesc, Instant, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n \n     let tests_len = tests.len();\n \n@@ -1113,9 +1121,9 @@ where\n \n     let (tx, rx) = channel::<MonitorMsg>();\n \n-    let mut running_tests: HashMap<TestDesc, Instant> = HashMap::new();\n+    let mut running_tests: TestMap = HashMap::default();\n \n-    fn get_timed_out_tests(running_tests: &mut HashMap<TestDesc, Instant>) -> Vec<TestDesc> {\n+    fn get_timed_out_tests(running_tests: &mut TestMap) -> Vec<TestDesc> {\n         let now = Instant::now();\n         let timed_out = running_tests\n             .iter()\n@@ -1133,7 +1141,7 @@ where\n         timed_out\n     };\n \n-    fn calc_timeout(running_tests: &HashMap<TestDesc, Instant>) -> Option<Duration> {\n+    fn calc_timeout(running_tests: &TestMap) -> Option<Duration> {\n         running_tests.values().min().map(|next_timeout| {\n             let now = Instant::now();\n             if *next_timeout >= now {\n@@ -1148,7 +1156,7 @@ where\n         while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n             callback(TeWait(test.desc.clone()))?;\n-            run_test(opts, !opts.run_tests, test, tx.clone());\n+            run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::No);\n             let (test, result, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, stdout))?;\n         }\n@@ -1159,7 +1167,7 @@ where\n                 let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n                 running_tests.insert(test.desc.clone(), timeout);\n                 callback(TeWait(test.desc.clone()))?; //here no pad\n-                run_test(opts, !opts.run_tests, test, tx.clone());\n+                run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::Yes);\n                 pending += 1;\n             }\n \n@@ -1191,7 +1199,7 @@ where\n         // All benchmarks run at the end, in serial.\n         for b in filtered_benchs {\n             callback(TeWait(b.desc.clone()))?;\n-            run_test(opts, false, b, tx.clone());\n+            run_test(opts, false, b, tx.clone(), Concurrent::No);\n             let (test, result, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, stdout))?;\n         }\n@@ -1393,6 +1401,7 @@ pub fn run_test(\n     force_ignore: bool,\n     test: TestDescAndFn,\n     monitor_ch: Sender<MonitorMsg>,\n+    concurrency: Concurrent,\n ) {\n     let TestDescAndFn { desc, testfn } = test;\n \n@@ -1409,6 +1418,7 @@ pub fn run_test(\n         monitor_ch: Sender<MonitorMsg>,\n         nocapture: bool,\n         testfn: Box<dyn FnBox() + Send>,\n+        concurrency: Concurrent,\n     ) {\n         // Buffer for capturing standard I/O\n         let data = Arc::new(Mutex::new(Vec::new()));\n@@ -1443,7 +1453,7 @@ pub fn run_test(\n         // the test synchronously, regardless of the concurrency\n         // level.\n         let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n-        if supports_threads {\n+        if concurrency == Concurrent::Yes && supports_threads {\n             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n             cfg.spawn(runtest).unwrap();\n         } else {\n@@ -1464,13 +1474,14 @@ pub fn run_test(\n         }\n         DynTestFn(f) => {\n             let cb = move || __rust_begin_short_backtrace(f);\n-            run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb))\n+            run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb), concurrency)\n         }\n         StaticTestFn(f) => run_test_inner(\n             desc,\n             monitor_ch,\n             opts.nocapture,\n             Box::new(move || __rust_begin_short_backtrace(f)),\n+            concurrency,\n         ),\n     }\n }\n@@ -1753,6 +1764,7 @@ mod tests {\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n+    use Concurrent;\n \n \n     fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n@@ -1793,7 +1805,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res != TrOk);\n     }\n@@ -1811,7 +1823,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrIgnored);\n     }\n@@ -1831,7 +1843,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrOk);\n     }\n@@ -1851,7 +1863,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrOk);\n     }\n@@ -1873,7 +1885,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n     }\n@@ -1891,7 +1903,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrFailed);\n     }"}, {"sha": "80e75c89bfc1611a2cf0d9ac1f76b71d428a3074", "filename": "src/test/run-make-fulldeps/libtest-json/output.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3499575282b5cda1e98220baae4f6c87e1863926/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json", "raw_url": "https://github.com/rust-lang/rust/raw/3499575282b5cda1e98220baae4f6c87e1863926/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json?ref=3499575282b5cda1e98220baae4f6c87e1863926", "patch": "@@ -2,7 +2,7 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'b' panicked at 'assertion failed: false', f.rs:18:5\\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:18:5\\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }"}]}