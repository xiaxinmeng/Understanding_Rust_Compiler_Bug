{"sha": "9220641ba4d3c7a95db7355d9999da54d455607c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMjA2NDFiYTRkM2M3YTk1ZGI3MzU1ZDk5OTlkYTU0ZDQ1NTYwN2M=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-29T12:24:40Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-29T12:24:40Z"}, "message": "Merge #355\n\n355: Type variables / unification r=matklad a=flodiebold\n\nThis will really become necessary when we implement generics, but even now, it allows us to reason 'backwards' to infer types of expressions that we didn't understand for some reason.\r\n\r\nThis uses [ena](https://crates.io/crates/ena) to keep track of type variables.\r\n\r\nAlso turn `Ty::Tuple` from a `Vec` into an `Arc<[Ty]>` to keep `Ty` easily cloneable. Though to be honest I'm not sure how often we actually share data here, with all the make_muts and modifying...\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "7c240880b47d94ecb9c9d39766579e8ec563b018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c240880b47d94ecb9c9d39766579e8ec563b018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9220641ba4d3c7a95db7355d9999da54d455607c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9220641ba4d3c7a95db7355d9999da54d455607c", "html_url": "https://github.com/rust-lang/rust/commit/9220641ba4d3c7a95db7355d9999da54d455607c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9220641ba4d3c7a95db7355d9999da54d455607c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a9528c540b1e71d03d643244dd915f6420b38191", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9528c540b1e71d03d643244dd915f6420b38191", "html_url": "https://github.com/rust-lang/rust/commit/a9528c540b1e71d03d643244dd915f6420b38191"}, {"sha": "b1590bdf6a88c03e2aeeedbe04f4dbc4203073db", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1590bdf6a88c03e2aeeedbe04f4dbc4203073db", "html_url": "https://github.com/rust-lang/rust/commit/b1590bdf6a88c03e2aeeedbe04f4dbc4203073db"}], "stats": {"total": 519, "additions": 400, "deletions": 119}, "files": [{"sha": "fa3363bd2be7b9caaa9f27a10a0d3a1d0a409d8b", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9220641ba4d3c7a95db7355d9999da54d455607c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9220641ba4d3c7a95db7355d9999da54d455607c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9220641ba4d3c7a95db7355d9999da54d455607c", "patch": "@@ -271,6 +271,14 @@ name = \"either\"\n version = \"1.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"error-chain\"\n version = \"0.12.0\"\n@@ -737,6 +745,7 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"id-arena 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1546,6 +1555,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum digest 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"03b072242a8cbaf9c145665af9d250c59af3b958f83ed6824e13533cf76d5b90\"\n \"checksum drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"69b26e475fd29098530e709294e94e661974c851aed42512793f120fed4e199f\"\n \"checksum either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n+\"checksum ena 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f56c93cc076508c549d9bb747f79aa9b4eb098be7b8cad8830c3137ef52d1e00\"\n \"checksum error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07e791d3be96241c77c43846b665ef1384606da2cd2a48730abe606a12906e02\"\n \"checksum failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6dd377bcc1b1b7ce911967e3ec24fa19c3224394ec05b54aa7b083d498341ac7\"\n \"checksum failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"64c2d913fe8ed3b6c6518eedf4538255b989945c14c2a7d5cbff62a5e2120596\""}, {"sha": "c3fbd327d9fe0c79154598240c9c03654825f1a7", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=9220641ba4d3c7a95db7355d9999da54d455607c", "patch": "@@ -12,6 +12,7 @@ salsa = \"0.9.0\"\n rustc-hash = \"1.0\"\n parking_lot = \"0.7.0\"\n id-arena = \"2.0\"\n+ena = \"0.11\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_editor = { path = \"../ra_editor\" }\n ra_db = { path = \"../ra_db\" }"}, {"sha": "4ebd44d271f429b8c5f514f5302681914d2b6cb5", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 341, "deletions": 112, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=9220641ba4d3c7a95db7355d9999da54d455607c", "patch": "@@ -3,10 +3,11 @@ mod primitive;\n mod tests;\n \n use std::sync::Arc;\n-use std::fmt;\n+use std::{fmt, mem};\n \n use log;\n-use rustc_hash::{FxHashMap};\n+use rustc_hash::FxHashMap;\n+use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n \n use ra_db::{LocalSyntaxPtr, Cancelable};\n use ra_syntax::{\n@@ -17,10 +18,89 @@ use ra_syntax::{\n use crate::{\n     Def, DefId, FnScopes, Module, Function, Struct, Enum, Path, Name, AsName,\n     db::HirDatabase,\n-    adt::VariantData,\n     type_ref::{TypeRef, Mutability},\n };\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct TypeVarId(u32);\n+\n+impl UnifyKey for TypeVarId {\n+    type Value = TypeVarValue;\n+\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_index(i: u32) -> Self {\n+        TypeVarId(i)\n+    }\n+\n+    fn tag() -> &'static str {\n+        \"TypeVarId\"\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum TypeVarValue {\n+    Known(Ty),\n+    Unknown,\n+}\n+\n+impl TypeVarValue {\n+    pub fn known(&self) -> Option<&Ty> {\n+        match self {\n+            TypeVarValue::Known(ty) => Some(ty),\n+            TypeVarValue::Unknown => None,\n+        }\n+    }\n+}\n+\n+impl UnifyValue for TypeVarValue {\n+    type Error = NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n+        match (value1, value2) {\n+            // We should never equate two type variables, both of which have\n+            // known types. Instead, we recursively equate those types.\n+            (TypeVarValue::Known(..), TypeVarValue::Known(..)) => {\n+                panic!(\"equating two type variables, both of which have known types\")\n+            }\n+\n+            // If one side is known, prefer that one.\n+            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n+            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n+\n+            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum InferTy {\n+    TypeVar(TypeVarId),\n+    // later we'll have IntVar and FloatVar as well\n+}\n+\n+/// When inferring an expression, we propagate downward whatever type hint we\n+/// are able in the form of an `Expectation`.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+struct Expectation {\n+    ty: Ty,\n+    // TODO: In some cases, we need to be aware whether the expectation is that\n+    // the type match exactly what we passed, or whether it just needs to be\n+    // coercible to the expected type. See Expectation::rvalue_hint in rustc.\n+}\n+\n+impl Expectation {\n+    fn has_type(ty: Ty) -> Self {\n+        Expectation { ty }\n+    }\n+\n+    fn none() -> Self {\n+        Expectation { ty: Ty::Unknown }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Ty {\n     /// The primitive boolean type. Written as `bool`.\n@@ -75,23 +155,22 @@ pub enum Ty {\n \n     // A trait, defined with `dyn trait`.\n     // Dynamic(),\n-    /// The anonymous type of a closure. Used to represent the type of\n-    /// `|a| a`.\n+    // The anonymous type of a closure. Used to represent the type of\n+    // `|a| a`.\n     // Closure(DefId, ClosureSubsts<'tcx>),\n \n-    /// The anonymous type of a generator. Used to represent the type of\n-    /// `|a| yield a`.\n+    // The anonymous type of a generator. Used to represent the type of\n+    // `|a| yield a`.\n     // Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n \n-    /// A type representin the types stored inside a generator.\n-    /// This should only appear in GeneratorInteriors.\n+    // A type representin the types stored inside a generator.\n+    // This should only appear in GeneratorInteriors.\n     // GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n-\n     /// The never type `!`\n     Never,\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    Tuple(Vec<Ty>),\n+    Tuple(Arc<[Ty]>),\n \n     // The projection of an associated type.  For example,\n     // `<T as Trait<..>>::N`.pub\n@@ -106,14 +185,14 @@ pub enum Ty {\n \n     // A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     // Param(ParamTy),\n-\n-    // A placeholder type - universally quantified higher-ranked type.\n-    // Placeholder(ty::PlaceholderType),\n-\n-    // A type variable used during type checking.\n-    // Infer(InferTy),\n-    /// A placeholder for a type which could not be computed; this is\n-    /// propagated to avoid useless error messages.\n+    /// A type variable used during type checking. Not to be confused with a\n+    /// type parameter.\n+    Infer(InferTy),\n+\n+    /// A placeholder for a type which could not be computed; this is propagated\n+    /// to avoid useless error messages. Doubles as a placeholder where type\n+    /// variables are inserted before type checking, since we want to try to\n+    /// infer a better type here anyway.\n     Unknown,\n }\n \n@@ -137,8 +216,8 @@ impl Ty {\n                 let inner_tys = inner\n                     .iter()\n                     .map(|tr| Ty::from_hir(db, module, tr))\n-                    .collect::<Cancelable<_>>()?;\n-                Ty::Tuple(inner_tys)\n+                    .collect::<Cancelable<Vec<_>>>()?;\n+                Ty::Tuple(inner_tys.into())\n             }\n             TypeRef::Path(path) => Ty::from_hir_path(db, module, path)?,\n             TypeRef::RawPtr(inner, mutability) => {\n@@ -154,7 +233,7 @@ impl Ty {\n                 let inner_ty = Ty::from_hir(db, module, inner)?;\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n-            TypeRef::Placeholder => Ty::Unknown, // TODO\n+            TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n@@ -217,7 +296,41 @@ impl Ty {\n     }\n \n     pub fn unit() -> Self {\n-        Ty::Tuple(Vec::new())\n+        Ty::Tuple(Arc::new([]))\n+    }\n+\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        f(self);\n+        match self {\n+            Ty::Slice(t) => Arc::make_mut(t).walk_mut(f),\n+            Ty::RawPtr(t, _) => Arc::make_mut(t).walk_mut(f),\n+            Ty::Ref(t, _) => Arc::make_mut(t).walk_mut(f),\n+            Ty::Tuple(ts) => {\n+                // Without an Arc::make_mut_slice, we can't avoid the clone here:\n+                let mut v: Vec<_> = ts.iter().cloned().collect();\n+                for t in &mut v {\n+                    t.walk_mut(f);\n+                }\n+                *ts = v.into();\n+            }\n+            Ty::FnPtr(sig) => {\n+                let sig_mut = Arc::make_mut(sig);\n+                for input in &mut sig_mut.input {\n+                    input.walk_mut(f);\n+                }\n+                sig_mut.output.walk_mut(f);\n+            }\n+            Ty::Adt { .. } => {} // need to walk type parameters later\n+            _ => {}\n+        }\n+    }\n+\n+    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Ty {\n+        self.walk_mut(&mut |ty_mut| {\n+            let ty = mem::replace(ty_mut, Ty::Unknown);\n+            *ty_mut = f(ty);\n+        });\n+        self\n     }\n }\n \n@@ -236,7 +349,7 @@ impl fmt::Display for Ty {\n             Ty::Never => write!(f, \"!\"),\n             Ty::Tuple(ts) => {\n                 write!(f, \"(\")?;\n-                for t in ts {\n+                for t in ts.iter() {\n                     write!(f, \"{},\", t)?;\n                 }\n                 write!(f, \")\")\n@@ -250,6 +363,7 @@ impl fmt::Display for Ty {\n             }\n             Ty::Adt { name, .. } => write!(f, \"{}\", name),\n             Ty::Unknown => write!(f, \"[unknown]\"),\n+            Ty::Infer(..) => write!(f, \"_\"),\n         }\n     }\n }\n@@ -267,7 +381,11 @@ pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n                 .collect()\n         })\n         .unwrap_or_else(|| Ok(Vec::new()))?;\n-    let output = Ty::from_ast_opt(db, &module, node.ret_type().and_then(|rt| rt.type_ref()))?;\n+    let output = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n+        Ty::from_ast(db, &module, type_ref)?\n+    } else {\n+        Ty::unit()\n+    };\n     let sig = FnSig { input, output };\n     Ok(Ty::FnPtr(Arc::new(sig)))\n }\n@@ -342,41 +460,124 @@ pub struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n     scopes: Arc<FnScopes>,\n     module: Module,\n-    // TODO unification tables...\n+    var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(db: &'a D, scopes: Arc<FnScopes>, module: Module) -> Self {\n         InferenceContext {\n             type_of: FxHashMap::default(),\n+            var_unification_table: InPlaceUnificationTable::new(),\n             db,\n             scopes,\n             module,\n         }\n     }\n \n+    fn resolve_all(mut self) -> InferenceResult {\n+        let mut types = mem::replace(&mut self.type_of, FxHashMap::default());\n+        for ty in types.values_mut() {\n+            let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            *ty = resolved;\n+        }\n+        InferenceResult { type_of: types }\n+    }\n+\n     fn write_ty(&mut self, node: SyntaxNodeRef, ty: Ty) {\n         self.type_of.insert(LocalSyntaxPtr::new(node), ty);\n     }\n \n-    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> Option<Ty> {\n-        if *ty1 == Ty::Unknown {\n-            return Some(ty2.clone());\n-        }\n-        if *ty2 == Ty::Unknown {\n-            return Some(ty1.clone());\n+    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        match (ty1, ty2) {\n+            (Ty::Unknown, ..) => true,\n+            (.., Ty::Unknown) => true,\n+            (Ty::Bool, _)\n+            | (Ty::Str, _)\n+            | (Ty::Never, _)\n+            | (Ty::Char, _)\n+            | (Ty::Int(..), Ty::Int(..))\n+            | (Ty::Uint(..), Ty::Uint(..))\n+            | (Ty::Float(..), Ty::Float(..)) => ty1 == ty2,\n+            (\n+                Ty::Adt {\n+                    def_id: def_id1, ..\n+                },\n+                Ty::Adt {\n+                    def_id: def_id2, ..\n+                },\n+            ) if def_id1 == def_id2 => true,\n+            (Ty::Slice(t1), Ty::Slice(t2)) => self.unify(t1, t2),\n+            (Ty::RawPtr(t1, m1), Ty::RawPtr(t2, m2)) if m1 == m2 => self.unify(t1, t2),\n+            (Ty::Ref(t1, m1), Ty::Ref(t2, m2)) if m1 == m2 => self.unify(t1, t2),\n+            (Ty::FnPtr(sig1), Ty::FnPtr(sig2)) if sig1 == sig2 => true,\n+            (Ty::Tuple(ts1), Ty::Tuple(ts2)) if ts1.len() == ts2.len() => ts1\n+                .iter()\n+                .zip(ts2.iter())\n+                .all(|(t1, t2)| self.unify(t1, t2)),\n+            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2))) => {\n+                self.var_unification_table.union(*tv1, *tv2);\n+                true\n+            }\n+            (Ty::Infer(InferTy::TypeVar(tv)), other) | (other, Ty::Infer(InferTy::TypeVar(tv))) => {\n+                self.var_unification_table\n+                    .union_value(*tv, TypeVarValue::Known(other.clone()));\n+                true\n+            }\n+            _ => false,\n         }\n-        if ty1 == ty2 {\n-            return Some(ty1.clone());\n+    }\n+\n+    fn new_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::TypeVar(\n+            self.var_unification_table.new_key(TypeVarValue::Unknown),\n+        ))\n+    }\n+\n+    /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n+    fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n+        match ty {\n+            Ty::Unknown => self.new_type_var(),\n+            _ => ty,\n         }\n-        // TODO implement actual unification\n-        return None;\n     }\n \n-    fn unify_with_coercion(&mut self, ty1: &Ty, ty2: &Ty) -> Option<Ty> {\n-        // TODO implement coercion\n-        self.unify(ty1, ty2)\n+    fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| self.insert_type_vars_shallow(ty))\n+    }\n+\n+    /// Resolves the type as far as currently possible, replacing type variables\n+    /// by their known types. All types returned by the infer_* functions should\n+    /// be resolved as far as possible, i.e. contain no type variables with\n+    /// known type.\n+    fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(InferTy::TypeVar(tv)) => {\n+                if let Some(known_ty) = self.var_unification_table.probe_value(tv).known() {\n+                    // known_ty may contain other variables that are known by now\n+                    self.resolve_ty_as_possible(known_ty.clone())\n+                } else {\n+                    Ty::Infer(InferTy::TypeVar(tv))\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+\n+    /// Resolves the type completely; type variables without known type are\n+    /// replaced by Ty::Unknown.\n+    fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(InferTy::TypeVar(tv)) => {\n+                if let Some(known_ty) = self.var_unification_table.probe_value(tv).known() {\n+                    // known_ty may contain other variables that are known by now\n+                    self.resolve_ty_completely(known_ty.clone())\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            _ => ty,\n+        })\n     }\n \n     fn infer_path_expr(&mut self, expr: ast::PathExpr) -> Cancelable<Option<Ty>> {\n@@ -387,21 +588,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let name = ctry!(ast_path.segment().and_then(|s| s.name_ref()));\n             if let Some(scope_entry) = self.scopes.resolve_local_name(name) {\n                 let ty = ctry!(self.type_of.get(&scope_entry.ptr()));\n-                return Ok(Some(ty.clone()));\n+                let ty = self.resolve_ty_as_possible(ty.clone());\n+                return Ok(Some(ty));\n             };\n         };\n \n         // resolve in module\n         let resolved = ctry!(self.module.resolve_path(self.db, &path)?.take_values());\n         let ty = self.db.type_for_def(resolved)?;\n-        // TODO we will need to add type variables for type parameters etc. here\n+        let ty = self.insert_type_vars(ty);\n         Ok(Some(ty))\n     }\n \n-    fn resolve_variant(\n-        &self,\n-        path: Option<ast::Path>,\n-    ) -> Cancelable<(Ty, Option<Arc<VariantData>>)> {\n+    fn resolve_variant(&self, path: Option<ast::Path>) -> Cancelable<(Ty, Option<DefId>)> {\n         let path = if let Some(path) = path.and_then(Path::from_ast) {\n             path\n         } else {\n@@ -414,102 +613,116 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         Ok(match def_id.resolve(self.db)? {\n             Def::Struct(s) => {\n-                let struct_data = self.db.struct_data(def_id)?;\n                 let ty = type_for_struct(self.db, s)?;\n-                (ty, Some(struct_data.variant_data().clone()))\n+                (ty, Some(def_id))\n             }\n             _ => (Ty::Unknown, None),\n         })\n     }\n \n-    fn infer_expr_opt(&mut self, expr: Option<ast::Expr>) -> Cancelable<Ty> {\n+    fn infer_expr_opt(\n+        &mut self,\n+        expr: Option<ast::Expr>,\n+        expected: &Expectation,\n+    ) -> Cancelable<Ty> {\n         if let Some(e) = expr {\n-            self.infer_expr(e)\n+            self.infer_expr(e, expected)\n         } else {\n             Ok(Ty::Unknown)\n         }\n     }\n \n-    fn infer_expr(&mut self, expr: ast::Expr) -> Cancelable<Ty> {\n+    fn infer_expr(&mut self, expr: ast::Expr, expected: &Expectation) -> Cancelable<Ty> {\n         let ty = match expr {\n             ast::Expr::IfExpr(e) => {\n                 if let Some(condition) = e.condition() {\n-                    // TODO if no pat, this should be bool\n-                    self.infer_expr_opt(condition.expr())?;\n+                    let expected = if condition.pat().is_none() {\n+                        Expectation::has_type(Ty::Bool)\n+                    } else {\n+                        Expectation::none()\n+                    };\n+                    self.infer_expr_opt(condition.expr(), &expected)?;\n                     // TODO write type for pat\n                 };\n-                let if_ty = self.infer_block_opt(e.then_branch())?;\n-                let else_ty = self.infer_block_opt(e.else_branch())?;\n-                if let Some(ty) = self.unify(&if_ty, &else_ty) {\n-                    ty\n+                let if_ty = self.infer_block_opt(e.then_branch(), expected)?;\n+                if let Some(else_branch) = e.else_branch() {\n+                    self.infer_block(else_branch, expected)?;\n                 } else {\n-                    // TODO report diagnostic\n-                    Ty::Unknown\n+                    // no else branch -> unit\n+                    self.unify(&expected.ty, &Ty::unit()); // actually coerce\n                 }\n+                if_ty\n             }\n-            ast::Expr::BlockExpr(e) => self.infer_block_opt(e.block())?,\n+            ast::Expr::BlockExpr(e) => self.infer_block_opt(e.block(), expected)?,\n             ast::Expr::LoopExpr(e) => {\n-                self.infer_block_opt(e.loop_body())?;\n+                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n                 // TODO never, or the type of the break param\n                 Ty::Unknown\n             }\n             ast::Expr::WhileExpr(e) => {\n                 if let Some(condition) = e.condition() {\n-                    // TODO if no pat, this should be bool\n-                    self.infer_expr_opt(condition.expr())?;\n+                    let expected = if condition.pat().is_none() {\n+                        Expectation::has_type(Ty::Bool)\n+                    } else {\n+                        Expectation::none()\n+                    };\n+                    self.infer_expr_opt(condition.expr(), &expected)?;\n                     // TODO write type for pat\n                 };\n-                self.infer_block_opt(e.loop_body())?;\n+                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n                 // TODO always unit?\n-                Ty::Unknown\n+                Ty::unit()\n             }\n             ast::Expr::ForExpr(e) => {\n-                let _iterable_ty = self.infer_expr_opt(e.iterable());\n+                let _iterable_ty = self.infer_expr_opt(e.iterable(), &Expectation::none());\n                 if let Some(_pat) = e.pat() {\n                     // TODO write type for pat\n                 }\n-                self.infer_block_opt(e.loop_body())?;\n+                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n                 // TODO always unit?\n-                Ty::Unknown\n+                Ty::unit()\n             }\n             ast::Expr::LambdaExpr(e) => {\n-                let _body_ty = self.infer_expr_opt(e.body())?;\n+                let _body_ty = self.infer_expr_opt(e.body(), &Expectation::none())?;\n                 Ty::Unknown\n             }\n             ast::Expr::CallExpr(e) => {\n-                let callee_ty = self.infer_expr_opt(e.expr())?;\n-                if let Some(arg_list) = e.arg_list() {\n-                    for arg in arg_list.args() {\n-                        // TODO unify / expect argument type\n-                        self.infer_expr(arg)?;\n-                    }\n-                }\n-                match callee_ty {\n-                    Ty::FnPtr(sig) => sig.output.clone(),\n+                let callee_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n+                let (arg_tys, ret_ty) = match &callee_ty {\n+                    Ty::FnPtr(sig) => (&sig.input[..], sig.output.clone()),\n                     _ => {\n                         // not callable\n                         // TODO report an error?\n-                        Ty::Unknown\n+                        (&[][..], Ty::Unknown)\n+                    }\n+                };\n+                if let Some(arg_list) = e.arg_list() {\n+                    for (i, arg) in arg_list.args().enumerate() {\n+                        self.infer_expr(\n+                            arg,\n+                            &Expectation::has_type(arg_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n+                        )?;\n                     }\n                 }\n+                ret_ty\n             }\n             ast::Expr::MethodCallExpr(e) => {\n-                let _receiver_ty = self.infer_expr_opt(e.expr())?;\n+                let _receiver_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 if let Some(arg_list) = e.arg_list() {\n                     for arg in arg_list.args() {\n                         // TODO unify / expect argument type\n-                        self.infer_expr(arg)?;\n+                        self.infer_expr(arg, &Expectation::none())?;\n                     }\n                 }\n                 Ty::Unknown\n             }\n             ast::Expr::MatchExpr(e) => {\n-                let _ty = self.infer_expr_opt(e.expr())?;\n+                let _ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 if let Some(match_arm_list) = e.match_arm_list() {\n                     for arm in match_arm_list.arms() {\n                         // TODO type the bindings in pat\n                         // TODO type the guard\n-                        let _ty = self.infer_expr_opt(arm.expr())?;\n+                        let _ty = self.infer_expr_opt(arm.expr(), &Expectation::none())?;\n                     }\n                     // TODO unify all the match arm types\n                     Ty::Unknown\n@@ -522,22 +735,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ast::Expr::PathExpr(e) => self.infer_path_expr(e)?.unwrap_or(Ty::Unknown),\n             ast::Expr::ContinueExpr(_e) => Ty::Never,\n             ast::Expr::BreakExpr(_e) => Ty::Never,\n-            ast::Expr::ParenExpr(e) => self.infer_expr_opt(e.expr())?,\n+            ast::Expr::ParenExpr(e) => self.infer_expr_opt(e.expr(), expected)?,\n             ast::Expr::Label(_e) => Ty::Unknown,\n             ast::Expr::ReturnExpr(e) => {\n-                self.infer_expr_opt(e.expr())?;\n+                self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 Ty::Never\n             }\n             ast::Expr::MatchArmList(_) | ast::Expr::MatchArm(_) | ast::Expr::MatchGuard(_) => {\n                 // Can this even occur outside of a match expression?\n                 Ty::Unknown\n             }\n             ast::Expr::StructLit(e) => {\n-                let (ty, _variant_data) = self.resolve_variant(e.path())?;\n+                let (ty, def_id) = self.resolve_variant(e.path())?;\n                 if let Some(nfl) = e.named_field_list() {\n                     for field in nfl.fields() {\n-                        // TODO unify with / expect field type\n-                        self.infer_expr_opt(field.expr())?;\n+                        let field_ty = if let (Some(def_id), Some(nr)) = (def_id, field.name_ref())\n+                        {\n+                            self.db.type_for_field(def_id, nr.as_name())?\n+                        } else {\n+                            Ty::Unknown\n+                        };\n+                        self.infer_expr_opt(field.expr(), &Expectation::has_type(field_ty))?;\n                     }\n                 }\n                 ty\n@@ -548,39 +766,42 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             ast::Expr::IndexExpr(_e) => Ty::Unknown,\n             ast::Expr::FieldExpr(e) => {\n-                let receiver_ty = self.infer_expr_opt(e.expr())?;\n+                let receiver_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 if let Some(nr) = e.name_ref() {\n-                    match receiver_ty {\n+                    let ty = match receiver_ty {\n                         Ty::Tuple(fields) => {\n                             let i = nr.text().parse::<usize>().ok();\n                             i.and_then(|i| fields.get(i).cloned())\n                                 .unwrap_or(Ty::Unknown)\n                         }\n                         Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, nr.as_name())?,\n                         _ => Ty::Unknown,\n-                    }\n+                    };\n+                    self.insert_type_vars(ty)\n                 } else {\n                     Ty::Unknown\n                 }\n             }\n             ast::Expr::TryExpr(e) => {\n-                let _inner_ty = self.infer_expr_opt(e.expr())?;\n+                let _inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 Ty::Unknown\n             }\n             ast::Expr::CastExpr(e) => {\n-                let _inner_ty = self.infer_expr_opt(e.expr())?;\n+                let _inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 let cast_ty = Ty::from_ast_opt(self.db, &self.module, e.type_ref())?;\n+                let cast_ty = self.insert_type_vars(cast_ty);\n                 // TODO do the coercion...\n                 cast_ty\n             }\n             ast::Expr::RefExpr(e) => {\n-                let inner_ty = self.infer_expr_opt(e.expr())?;\n+                // TODO pass the expectation down\n+                let inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 let m = Mutability::from_mutable(e.is_mut());\n                 // TODO reference coercions etc.\n                 Ty::Ref(Arc::new(inner_ty), m)\n             }\n             ast::Expr::PrefixExpr(e) => {\n-                let inner_ty = self.infer_expr_opt(e.expr())?;\n+                let inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 match e.op() {\n                     Some(PrefixOp::Deref) => {\n                         match inner_ty {\n@@ -598,28 +819,34 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ast::Expr::BinExpr(_e) => Ty::Unknown,\n             ast::Expr::Literal(_e) => Ty::Unknown,\n         };\n+        // use a new type variable if we got Ty::Unknown here\n+        let ty = self.insert_type_vars_shallow(ty);\n+        self.unify(&ty, &expected.ty);\n         self.write_ty(expr.syntax(), ty.clone());\n         Ok(ty)\n     }\n \n-    fn infer_block_opt(&mut self, node: Option<ast::Block>) -> Cancelable<Ty> {\n+    fn infer_block_opt(\n+        &mut self,\n+        node: Option<ast::Block>,\n+        expected: &Expectation,\n+    ) -> Cancelable<Ty> {\n         if let Some(b) = node {\n-            self.infer_block(b)\n+            self.infer_block(b, expected)\n         } else {\n             Ok(Ty::Unknown)\n         }\n     }\n \n-    fn infer_block(&mut self, node: ast::Block) -> Cancelable<Ty> {\n+    fn infer_block(&mut self, node: ast::Block, expected: &Expectation) -> Cancelable<Ty> {\n         for stmt in node.statements() {\n             match stmt {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let decl_ty = Ty::from_ast_opt(self.db, &self.module, stmt.type_ref())?;\n+                    let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = stmt.initializer() {\n-                        // TODO pass expectation\n-                        let expr_ty = self.infer_expr(expr)?;\n-                        self.unify_with_coercion(&expr_ty, &decl_ty)\n-                            .unwrap_or(decl_ty)\n+                        let expr_ty = self.infer_expr(expr, &Expectation::has_type(decl_ty))?;\n+                        expr_ty\n                     } else {\n                         decl_ty\n                     };\n@@ -629,12 +856,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     };\n                 }\n                 ast::Stmt::ExprStmt(expr_stmt) => {\n-                    self.infer_expr_opt(expr_stmt.expr())?;\n+                    self.infer_expr_opt(expr_stmt.expr(), &Expectation::none())?;\n                 }\n             }\n         }\n         let ty = if let Some(expr) = node.expr() {\n-            self.infer_expr(expr)?\n+            self.infer_expr(expr, expected)?\n         } else {\n             Ty::unit()\n         };\n@@ -660,25 +887,27 @@ pub fn infer(db: &impl HirDatabase, function: Function) -> Cancelable<InferenceR\n             };\n             if let Some(type_ref) = param.type_ref() {\n                 let ty = Ty::from_ast(db, &ctx.module, type_ref)?;\n+                let ty = ctx.insert_type_vars(ty);\n                 ctx.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n             } else {\n                 // TODO self param\n+                let type_var = ctx.new_type_var();\n                 ctx.type_of\n-                    .insert(LocalSyntaxPtr::new(pat.syntax()), Ty::Unknown);\n+                    .insert(LocalSyntaxPtr::new(pat.syntax()), type_var);\n             };\n         }\n     }\n \n-    // TODO get Ty for node.ret_type() and pass that to infer_block as expectation\n-    // (see Expectation in rustc_typeck)\n+    let ret_ty = if let Some(type_ref) = node.ret_type().and_then(|n| n.type_ref()) {\n+        let ty = Ty::from_ast(db, &ctx.module, type_ref)?;\n+        ctx.insert_type_vars(ty)\n+    } else {\n+        Ty::unit()\n+    };\n \n     if let Some(block) = node.body() {\n-        ctx.infer_block(block)?;\n+        ctx.infer_block(block, &Expectation::has_type(ret_ty))?;\n     }\n \n-    // TODO 'resolve' the types: replace inference variables by their inferred results\n-\n-    Ok(InferenceResult {\n-        type_of: ctx.type_of,\n-    })\n+    Ok(ctx.resolve_all())\n }"}, {"sha": "93bf431c4d5763dc295168bb5841d6f32085476c", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=9220641ba4d3c7a95db7355d9999da54d455607c", "patch": "@@ -113,6 +113,27 @@ fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n     );\n }\n \n+#[test]\n+fn infer_backwards() {\n+    check_inference(\n+        r#\"\n+fn takes_u32(x: u32) {}\n+\n+struct S { i32_field: i32 }\n+\n+fn test() -> &mut &f64 {\n+    let a = unknown_function();\n+    takes_u32(a);\n+    let b = unknown_function();\n+    S { i32_field: b };\n+    let c = unknown_function();\n+    &mut &c\n+}\n+\"#,\n+        \"0006_backwards.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "916ca25a1881735710714c124d0442c2122a20c6", "filename": "crates/ra_hir/src/ty/tests/data/0002_let.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0002_let.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0002_let.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0002_let.txt?ref=9220641ba4d3c7a95db7355d9999da54d455607c", "patch": "@@ -1,5 +1,5 @@\n [21; 22) 'a': [unknown]\n-[52; 53) '1': [unknown]\n+[52; 53) '1': usize\n [11; 71) '{     ...= b; }': ()\n [63; 64) 'c': usize\n [25; 31) '1isize': [unknown]"}, {"sha": "2a12d264f5b5b62b09618810ecc6fd913c912798", "filename": "crates/ra_hir/src/ty/tests/data/0003_paths.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt?ref=9220641ba4d3c7a95db7355d9999da54d455607c", "patch": "@@ -1,7 +1,7 @@\n-[15; 20) '{ 1 }': [unknown]\n-[17; 18) '1': [unknown]\n-[50; 51) '1': [unknown]\n-[48; 53) '{ 1 }': [unknown]\n+[15; 20) '{ 1 }': u32\n+[17; 18) '1': u32\n+[50; 51) '1': u32\n+[48; 53) '{ 1 }': u32\n [82; 88) 'b::c()': u32\n [67; 91) '{     ...c(); }': ()\n [73; 74) 'a': fn() -> u32"}, {"sha": "b4af18b876e6886159db2934a8a027c468a2e29c", "filename": "crates/ra_hir/src/ty/tests/data/0004_struct.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt?ref=9220641ba4d3c7a95db7355d9999da54d455607c", "patch": "@@ -1,5 +1,5 @@\n [86; 90) 'C(1)': [unknown]\n-[121; 122) 'B': [unknown]\n+[121; 122) 'B': B\n [86; 87) 'C': [unknown]\n [129; 130) '1': [unknown]\n [107; 108) 'a': A\n@@ -13,4 +13,4 @@\n [96; 97) 'B': [unknown]\n [88; 89) '1': [unknown]\n [82; 83) 'c': [unknown]\n-[127; 131) 'C(1)': [unknown]\n+[127; 131) 'C(1)': C"}, {"sha": "12006940185d1f57ea41bf8a6ee7856fbdaadc45", "filename": "crates/ra_hir/src/ty/tests/data/0006_backwards.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0006_backwards.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9220641ba4d3c7a95db7355d9999da54d455607c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0006_backwards.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0006_backwards.txt?ref=9220641ba4d3c7a95db7355d9999da54d455607c", "patch": "@@ -0,0 +1,20 @@\n+[22; 24) '{}': ()\n+[14; 15) 'x': u32\n+[142; 158) 'unknow...nction': [unknown]\n+[126; 127) 'a': u32\n+[198; 216) 'unknow...tion()': f64\n+[228; 229) 'c': f64\n+[198; 214) 'unknow...nction': [unknown]\n+[166; 184) 'S { i3...d: b }': S\n+[222; 229) '&mut &c': &mut &f64\n+[194; 195) 'c': f64\n+[92; 110) 'unknow...tion()': u32\n+[142; 160) 'unknow...tion()': i32\n+[92; 108) 'unknow...nction': [unknown]\n+[116; 128) 'takes_u32(a)': ()\n+[78; 231) '{     ...t &c }': &mut &f64\n+[227; 229) '&c': &f64\n+[88; 89) 'a': u32\n+[181; 182) 'b': i32\n+[116; 125) 'takes_u32': fn(u32,) -> ()\n+[138; 139) 'b': i32"}]}