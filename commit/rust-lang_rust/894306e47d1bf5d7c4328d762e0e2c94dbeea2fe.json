{"sha": "894306e47d1bf5d7c4328d762e0e2c94dbeea2fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NDMwNmU0N2QxYmY1ZDdjNDMyOGQ3NjJlMGUyYzk0ZGJlZWEyZmU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-22T05:59:47Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-22T05:59:47Z"}, "message": "refactor pointer arithmetic handling", "tree": {"sha": "01d4e00fe04df539dc4e9ae3523974b47f335021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01d4e00fe04df539dc4e9ae3523974b47f335021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/894306e47d1bf5d7c4328d762e0e2c94dbeea2fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/894306e47d1bf5d7c4328d762e0e2c94dbeea2fe", "html_url": "https://github.com/rust-lang/rust/commit/894306e47d1bf5d7c4328d762e0e2c94dbeea2fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/894306e47d1bf5d7c4328d762e0e2c94dbeea2fe/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6eafb10b870b4b7fad784402a76d6cef046f5928", "url": "https://api.github.com/repos/rust-lang/rust/commits/6eafb10b870b4b7fad784402a76d6cef046f5928", "html_url": "https://github.com/rust-lang/rust/commit/6eafb10b870b4b7fad784402a76d6cef046f5928"}], "stats": {"total": 57, "additions": 29, "deletions": 28}, "files": [{"sha": "7cba12594f9b6a466c8502b653c7a79158167e9e", "filename": "src/operator.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/894306e47d1bf5d7c4328d762e0e2c94dbeea2fe/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894306e47d1bf5d7c4328d762e0e2c94dbeea2fe/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=894306e47d1bf5d7c4328d762e0e2c94dbeea2fe", "patch": "@@ -3,6 +3,7 @@ use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n+use memory::Pointer;\n use lvalue::Lvalue;\n use value::{\n     PrimVal,\n@@ -130,19 +131,6 @@ macro_rules! f64_arithmetic {\n     )\n }\n \n-macro_rules! ptr_add {\n-    ($signed:expr, $ptr:expr, $int:expr, $layout:expr) => ({\n-        let ptr = $ptr;\n-        let int = $int;\n-        let (res, over) = if $signed {\n-            ptr.overflowing_signed_offset(int as i128, $layout)\n-        } else {\n-            ptr.overflowing_offset(int as u64, $layout)\n-        };\n-        (PrimVal::Ptr(res), over)\n-    })\n-}\n-\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n@@ -202,27 +190,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 }\n                 // These work if one operand is a pointer, the other an integer\n-                Sub\n+                Add | Sub\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n                 && left.is_ptr() && right.is_bytes() => {\n-                    let left = left.to_ptr()?;\n-                    let right = right.to_bytes()? as i128; // this cast is fine as the kind is max. 64bit\n-                    let (res, over) = left.overflowing_signed_offset(-right, self.memory.layout);\n-                    return Ok((PrimVal::Ptr(res), over))\n-                }\n-                Add\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n-                && left.is_ptr() && right.is_bytes() => {\n-                    let left = left.to_ptr()?;\n-                    let right = right.to_bytes()?;\n-                    return Ok(ptr_add!(left_kind == isize, left, right, self.memory.layout));\n+                    // Cast to i128 is fine as we checked the kind to be ptr-sized\n+                    let (res, over) = self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize)?;\n+                    return Ok((PrimVal::Ptr(res), over));\n                 }\n                 Add\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n                 && left.is_bytes() && right.is_ptr() => {\n-                    let left = left.to_bytes()?;\n-                    let right = right.to_ptr()?;\n-                    return Ok(ptr_add!(left_kind == isize, right, left, self.memory.layout));\n+                    // This is a commutative operation, just swap the operands\n+                    let (res, over) = self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize)?;\n+                    return Ok((PrimVal::Ptr(res), over));\n                 }\n                 _ => {}\n             }\n@@ -300,6 +280,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         Ok((val, false))\n     }\n+\n+    fn ptr_int_arithmetic(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: Pointer,\n+        right: i128,\n+        signed: bool,\n+    ) -> EvalResult<'tcx, (Pointer, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n+        Ok(match bin_op {\n+            Sub =>\n+                // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n+                left.overflowing_signed_offset(-right, self.memory.layout),\n+            Add if signed =>\n+                left.overflowing_signed_offset(right, self.memory.layout),\n+            Add if !signed =>\n+                left.overflowing_offset(right as u64, self.memory.layout),\n+            _ => bug!(\"ptr_int_arithmetic called on unsupported operation\")\n+        })\n+    }\n }\n \n pub fn unary_op<'tcx>("}]}