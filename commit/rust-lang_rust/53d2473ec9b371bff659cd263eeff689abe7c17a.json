{"sha": "53d2473ec9b371bff659cd263eeff689abe7c17a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZDI0NzNlYzliMzcxYmZmNjU5Y2QyNjNlZWZmNjg5YWJlN2MxN2E=", "commit": {"author": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2019-04-10T10:26:24Z"}, "committer": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2019-04-10T10:26:24Z"}, "message": "warn on unused results for operation methods on nums", "tree": {"sha": "0b193075d09fb53143c24b34dc3a917938529d8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b193075d09fb53143c24b34dc3a917938529d8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53d2473ec9b371bff659cd263eeff689abe7c17a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53d2473ec9b371bff659cd263eeff689abe7c17a", "html_url": "https://github.com/rust-lang/rust/commit/53d2473ec9b371bff659cd263eeff689abe7c17a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53d2473ec9b371bff659cd263eeff689abe7c17a/comments", "author": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3750348daff89741e3153e0e120aa70a45ff5b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/3750348daff89741e3153e0e120aa70a45ff5b68", "html_url": "https://github.com/rust-lang/rust/commit/3750348daff89741e3153e0e120aa70a45ff5b68"}], "stats": {"total": 156, "additions": 156, "deletions": 0}, "files": [{"sha": "ea40c81d4bdcf14e641f361a0e15edfc0ae88c9d", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/53d2473ec9b371bff659cd263eeff689abe7c17a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d2473ec9b371bff659cd263eeff689abe7c17a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=53d2473ec9b371bff659cd263eeff689abe7c17a", "patch": "@@ -377,6 +377,8 @@ let m = \", $rot_result, \";\n assert_eq!(n.rotate_left(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn rotate_left(self, n: u32) -> Self {\n                 (self as $UnsignedT).rotate_left(n) as Self\n@@ -401,6 +403,8 @@ let m = \", $rot_op, \";\n assert_eq!(n.rotate_right(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn rotate_right(self, n: u32) -> Self {\n                 (self as $UnsignedT).rotate_right(n) as Self\n@@ -598,6 +602,8 @@ assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n@@ -620,6 +626,8 @@ assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(3), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n@@ -642,6 +650,8 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n@@ -665,6 +675,8 @@ assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_div(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n@@ -691,6 +703,8 @@ assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euclid(-1), None);\n assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n@@ -718,6 +732,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n@@ -745,6 +761,8 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n@@ -791,6 +809,8 @@ assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n@@ -812,6 +832,8 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n@@ -860,6 +882,8 @@ $EndFeature, \"\n ```\"),\n \n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n@@ -901,6 +925,8 @@ $EndFeature, \"\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn saturating_add(self, rhs: Self) -> Self {\n                 intrinsics::saturating_add(self, rhs)\n@@ -924,6 +950,8 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn saturating_sub(self, rhs: Self) -> Self {\n                 intrinsics::saturating_sub(self, rhs)\n@@ -947,6 +975,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($Self\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn saturating_mul(self, rhs: Self) -> Self {\n                 self.checked_mul(rhs).unwrap_or_else(|| {\n@@ -976,6 +1006,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n@@ -1001,6 +1033,8 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().wrapping_add(2), \", stringify!(\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_add(self, rhs)\n@@ -1022,6 +1056,8 @@ stringify!($SelfT), \"::max_value());\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_sub(self, rhs)\n@@ -1042,6 +1078,8 @@ assert_eq!(11i8.wrapping_mul(12), -124);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_mul(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_mul(self, rhs)\n@@ -1070,6 +1108,8 @@ assert_eq!((-128i8).wrapping_div(-1), -128);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_div(self, rhs: Self) -> Self {\n                 self.overflowing_div(rhs).0\n@@ -1098,6 +1138,8 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self.overflowing_div_euclid(rhs).0\n@@ -1126,6 +1168,8 @@ assert_eq!((-128i8).wrapping_rem(-1), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_rem(self, rhs: Self) -> Self {\n                 self.overflowing_rem(rhs).0\n@@ -1153,6 +1197,8 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self.overflowing_rem_euclid(rhs).0\n@@ -1203,6 +1249,8 @@ assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -1230,6 +1278,8 @@ assert_eq!((-128i16).wrapping_shr(64), -128);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -1284,6 +1334,8 @@ assert_eq!(3i8.wrapping_pow(6), -39);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n@@ -1326,6 +1378,8 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($Sel\n \"::MIN, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -1351,6 +1405,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($Sel\n \"::MAX, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -1374,6 +1430,8 @@ assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -1405,6 +1463,8 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n@@ -1438,6 +1498,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringi\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n@@ -1470,6 +1532,8 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (0, true)\n@@ -1502,6 +1566,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n@@ -1555,6 +1621,8 @@ assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n@@ -1578,6 +1646,8 @@ assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n@@ -1630,6 +1700,8 @@ assert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n@@ -1677,6 +1749,8 @@ assert_eq!(x.pow(5), 32);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn pow(self, mut exp: u32) -> Self {\n@@ -1732,6 +1806,8 @@ assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn div_euclid(self, rhs: Self) -> Self {\n@@ -1770,6 +1846,8 @@ assert_eq!(a.rem_euclid(-b), 3);\n assert_eq!((-a).rem_euclid(-b), 1);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn rem_euclid(self, rhs: Self) -> Self {\n@@ -2277,6 +2355,8 @@ let m = \", $rot_result, \";\n assert_eq!(n.rotate_left(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn rotate_left(self, n: u32) -> Self {\n                 intrinsics::rotate_left(self, n as $SelfT)\n@@ -2301,6 +2381,8 @@ let m = \", $rot_op, \";\n assert_eq!(n.rotate_right(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn rotate_right(self, n: u32) -> Self {\n                 intrinsics::rotate_right(self, n as $SelfT)\n@@ -2496,6 +2578,8 @@ Basic usage:\n assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n@@ -2516,6 +2600,8 @@ Basic usage:\n assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n@@ -2536,6 +2622,8 @@ Basic usage:\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n@@ -2556,6 +2644,8 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_div(self, rhs: Self) -> Option<Self> {\n                 match rhs {\n@@ -2579,6 +2669,8 @@ assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\n assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n@@ -2603,6 +2695,8 @@ Basic usage:\n assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n@@ -2627,6 +2721,8 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n@@ -2672,6 +2768,8 @@ Basic usage:\n assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n@@ -2692,6 +2790,8 @@ Basic usage:\n assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n@@ -2712,6 +2812,8 @@ Basic usage:\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n@@ -2750,6 +2852,8 @@ assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n ```\"),\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n             #[inline]\n             pub const fn saturating_add(self, rhs: Self) -> Self {\n@@ -2770,6 +2874,8 @@ Basic usage:\n assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n             #[inline]\n             pub const fn saturating_sub(self, rhs: Self) -> Self {\n@@ -2793,6 +2899,8 @@ assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($Se\n \"::MAX);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn saturating_mul(self, rhs: Self) -> Self {\n                 self.checked_mul(rhs).unwrap_or(Self::max_value())\n@@ -2815,6 +2923,8 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n@@ -2838,6 +2948,8 @@ assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::ma\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_add(self, rhs)\n@@ -2858,6 +2970,8 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::ma\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_sub(self, rhs)\n@@ -2879,6 +2993,8 @@ $EndFeature, \"\n         /// assert_eq!(25u8.wrapping_mul(12), 44);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n         #[inline]\n         pub const fn wrapping_mul(self, rhs: Self) -> Self {\n             intrinsics::overflowing_mul(self, rhs)\n@@ -2899,6 +3015,8 @@ Basic usage:\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_div(self, rhs: Self) -> Self {\n                 self / rhs\n@@ -2924,6 +3042,8 @@ Basic usage:\n assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n@@ -2946,6 +3066,8 @@ Basic usage:\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_rem(self, rhs: Self) -> Self {\n                 self % rhs\n@@ -2972,6 +3094,8 @@ Basic usage:\n assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n@@ -3026,6 +3150,8 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -3055,6 +3181,8 @@ Basic usage:\n assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -3076,6 +3204,8 @@ Basic usage:\n assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n@@ -3118,6 +3248,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -3144,6 +3276,8 @@ assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT),\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -3169,6 +3303,8 @@ $EndFeature, \"\n         /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n         #[inline]\n         pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n             let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -3196,6 +3332,8 @@ Basic usage\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n@@ -3226,6 +3364,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n@@ -3252,6 +3392,8 @@ Basic usage\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n@@ -3282,6 +3424,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n@@ -3329,6 +3473,8 @@ Basic usage\n assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n@@ -3353,6 +3499,8 @@ Basic usage\n assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n@@ -3374,6 +3522,8 @@ Basic usage:\n assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n@@ -3418,6 +3568,8 @@ Basic usage:\n \", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\", $EndFeature, \"\n ```\"),\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n         pub fn pow(self, mut exp: u32) -> Self {\n@@ -3459,6 +3611,8 @@ Basic usage:\n assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn div_euclid(self, rhs: Self) -> Self {\n@@ -3483,6 +3637,8 @@ Basic usage:\n assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn rem_euclid(self, rhs: Self) -> Self {"}]}