{"sha": "ddf055ad07b93d27c826e737b674b65ab760e901", "node_id": "C_kwDOAAsO6NoAKGRkZjA1NWFkMDdiOTNkMjdjODI2ZTczN2I2NzRiNjVhYjc2MGU5MDE", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-11-21T19:34:47Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-11-21T19:51:52Z"}, "message": "Merge commit 'f4850f7292efa33759b4f7f9b7621268979e9914' into clippyup", "tree": {"sha": "b21a1d662c0224105f4e436340c0f9a2e1950cdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b21a1d662c0224105f4e436340c0f9a2e1950cdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddf055ad07b93d27c826e737b674b65ab760e901", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmN71tgACgkQHKDfKvWd\naKVqbBAAqnydT2huTSci/f50hQ38M8MXtHrXNlGbCMFiyWcfTZRCsECxPSV6zvIg\na5lf1hiDv6AiH6gnHS3jU4T9PRnVEUyFPOzZs81boNZt2Vqr3mTL19kbBo58tmOt\n41a/IsZD2gcxJCeUN5g9/Acju+FTsgiytTCd+F2Rfdoypi0HXp665VNqNJbM5z6M\nmca1A9FEwLb4BY+6HA0yCx8OPefm52izVV2R23mGsXtU+l1q1ROBbiDeUu/jnKq/\nE1OgiKyEN7oBr3fdzbGXyToJbzyq18FE8ZiuaYF8HZDYBosWpivpEI22aRBvMtKl\nJdK1IObXPIWopuGjLzYEQcZfYt8f6VqSSi74YEKBveWTyWn0E3Kr7G8af+6PiFSL\n11jm+zIxf2wS4i/ErukwNjVww55NIcQpAuo2Sov25sRffyYOWsKZ2XJ5COpXcghT\nXMb+cQZ5oAaji1FKCCKTYB1LfApDvM/gnEah1R4iC2W4/od4zlGSLhxDE7i5aOtL\nBFDh8rguF7vYT5ydqndKYWJJfb6YftntkiZ0BQx/ckGR/f0VYIQH9QrEqlHcl9fv\n5T8wEjYEHhDexh6MctMommcY6tiQTvmkRMt8LNk6aMjYNgCsVCGydywSt0f141Fl\nXC4viW0dq0GaF7XWX1I6Inup65GkhvOmXMzs5tGJ81T3e6bu/TE=\n=iJQs\n-----END PGP SIGNATURE-----", "payload": "tree b21a1d662c0224105f4e436340c0f9a2e1950cdb\nparent 1cbc45942d5c0f6eb5d94e3b10762ba541958035\nparent f4850f7292efa33759b4f7f9b7621268979e9914\nauthor Philipp Krones <hello@philkrones.com> 1669059287 +0100\ncommitter Philipp Krones <hello@philkrones.com> 1669060312 +0100\n\nMerge commit 'f4850f7292efa33759b4f7f9b7621268979e9914' into clippyup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf055ad07b93d27c826e737b674b65ab760e901", "html_url": "https://github.com/rust-lang/rust/commit/ddf055ad07b93d27c826e737b674b65ab760e901", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddf055ad07b93d27c826e737b674b65ab760e901/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cbc45942d5c0f6eb5d94e3b10762ba541958035", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cbc45942d5c0f6eb5d94e3b10762ba541958035", "html_url": "https://github.com/rust-lang/rust/commit/1cbc45942d5c0f6eb5d94e3b10762ba541958035"}, {"sha": "f4850f7292efa33759b4f7f9b7621268979e9914", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4850f7292efa33759b4f7f9b7621268979e9914", "html_url": "https://github.com/rust-lang/rust/commit/f4850f7292efa33759b4f7f9b7621268979e9914"}], "stats": {"total": 26614, "additions": 8241, "deletions": 18373}, "files": [{"sha": "6f1f73c1fd2fe385e06badeb46983a8860864c44", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 156, "deletions": 3, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -4,13 +4,157 @@ All notable changes to this project will be documented in this file.\n See [Changelog Update](book/src/development/infrastructure/changelog_update.md) if you want to update this\n document.\n \n-## Unreleased / In Rust Nightly\n+## Unreleased / Beta / In Rust Nightly\n \n-[3c7e7dbc...master](https://github.com/rust-lang/rust-clippy/compare/3c7e7dbc...master)\n+[b52fb523...master](https://github.com/rust-lang/rust-clippy/compare/b52fb523...master)\n+\n+## Rust 1.65\n+\n+Current stable, released 2022-11-03\n+\n+[3c7e7dbc...b52fb523](https://github.com/rust-lang/rust-clippy/compare/3c7e7dbc...b52fb523)\n+\n+### Important Changes\n+\n+* Clippy now has an `--explain <LINT>` command to show the lint description in the console\n+  [#8952](https://github.com/rust-lang/rust-clippy/pull/8952)\n+\n+### New Lints\n+\n+* [`unused_peekable`]\n+  [#9258](https://github.com/rust-lang/rust-clippy/pull/9258)\n+* [`collapsible_str_replace`]\n+  [#9269](https://github.com/rust-lang/rust-clippy/pull/9269)\n+* [`manual_string_new`]\n+  [#9295](https://github.com/rust-lang/rust-clippy/pull/9295)\n+* [`iter_on_empty_collections`]\n+  [#9187](https://github.com/rust-lang/rust-clippy/pull/9187)\n+* [`iter_on_single_items`]\n+  [#9187](https://github.com/rust-lang/rust-clippy/pull/9187)\n+* [`bool_to_int_with_if`]\n+  [#9412](https://github.com/rust-lang/rust-clippy/pull/9412)\n+* [`multi_assignments`]\n+  [#9379](https://github.com/rust-lang/rust-clippy/pull/9379)\n+* [`result_large_err`]\n+  [#9373](https://github.com/rust-lang/rust-clippy/pull/9373)\n+* [`partialeq_to_none`]\n+  [#9288](https://github.com/rust-lang/rust-clippy/pull/9288)\n+* [`suspicious_to_owned`]\n+  [#8984](https://github.com/rust-lang/rust-clippy/pull/8984)\n+* [`cast_slice_from_raw_parts`]\n+  [#9247](https://github.com/rust-lang/rust-clippy/pull/9247)\n+* [`manual_instant_elapsed`]\n+  [#9264](https://github.com/rust-lang/rust-clippy/pull/9264)\n+\n+### Moves and Deprecations\n+\n+* Moved [`significant_drop_in_scrutinee`] to `nursery` (now allow-by-default)\n+  [#9302](https://github.com/rust-lang/rust-clippy/pull/9302)\n+* Rename `logic_bug` to [`overly_complex_bool_expr`]\n+  [#9306](https://github.com/rust-lang/rust-clippy/pull/9306)\n+* Rename `arithmetic` to [`arithmetic_side_effects`]\n+  [#9443](https://github.com/rust-lang/rust-clippy/pull/9443)\n+* Moved [`only_used_in_recursion`] to complexity (now warn-by-default)\n+  [#8804](https://github.com/rust-lang/rust-clippy/pull/8804)\n+* Moved [`assertions_on_result_states`] to restriction (now allow-by-default)\n+  [#9273](https://github.com/rust-lang/rust-clippy/pull/9273)\n+* Renamed `blacklisted_name` to [`disallowed_names`]\n+  [#8974](https://github.com/rust-lang/rust-clippy/pull/8974)\n+\n+### Enhancements\n+\n+* [`option_if_let_else`]: Now also checks for match expressions\n+  [#8696](https://github.com/rust-lang/rust-clippy/pull/8696)\n+* [`explicit_auto_deref`]: Now lints on implicit returns in closures\n+  [#9126](https://github.com/rust-lang/rust-clippy/pull/9126)\n+* [`needless_borrow`]: Now considers trait implementations\n+  [#9136](https://github.com/rust-lang/rust-clippy/pull/9136)\n+* [`suboptimal_flops`], [`imprecise_flops`]: Now lint on constant expressions\n+  [#9404](https://github.com/rust-lang/rust-clippy/pull/9404)\n+* [`if_let_mutex`]: Now detects mutex behind references and warns about deadlocks\n+  [#9318](https://github.com/rust-lang/rust-clippy/pull/9318)\n+\n+### False Positive Fixes\n+\n+* [`unit_arg`] [`default_trait_access`] [`missing_docs_in_private_items`]: No longer\n+  trigger in code generated from proc-macros\n+  [#8694](https://github.com/rust-lang/rust-clippy/pull/8694)\n+* [`unwrap_used`]: Now lints uses of `unwrap_err`\n+  [#9338](https://github.com/rust-lang/rust-clippy/pull/9338)\n+* [`expect_used`]: Now lints uses of `expect_err`\n+  [#9338](https://github.com/rust-lang/rust-clippy/pull/9338)\n+* [`transmute_undefined_repr`]: Now longer lints if the first field is compatible\n+  with the other type\n+  [#9287](https://github.com/rust-lang/rust-clippy/pull/9287)\n+* [`unnecessary_to_owned`]: No longer lints, if type change cased errors in\n+  the caller function\n+  [#9424](https://github.com/rust-lang/rust-clippy/pull/9424)\n+* [`match_like_matches_macro`]: No longer lints, if there are comments inside the\n+  match expression\n+  [#9276](https://github.com/rust-lang/rust-clippy/pull/9276)\n+* [`partialeq_to_none`]: No longer trigger in code generated from macros\n+  [#9389](https://github.com/rust-lang/rust-clippy/pull/9389)\n+* [`arithmetic_side_effects`]: No longer lints expressions that only use literals\n+  [#9365](https://github.com/rust-lang/rust-clippy/pull/9365)\n+* [`explicit_auto_deref`]: Now ignores references on block expressions when the type\n+  is `Sized`, on `dyn Trait` returns and when the suggestion is non-trivial\n+  [#9126](https://github.com/rust-lang/rust-clippy/pull/9126)\n+* [`trait_duplication_in_bounds`]: Now better tracks bounds to avoid false positives\n+  [#9167](https://github.com/rust-lang/rust-clippy/pull/9167)\n+* [`format_in_format_args`]: Now suggests cases where the result is formatted again\n+  [#9349](https://github.com/rust-lang/rust-clippy/pull/9349)\n+* [`only_used_in_recursion`]: No longer lints on function without recursions and\n+  takes external functions into account\n+  [#8804](https://github.com/rust-lang/rust-clippy/pull/8804)\n+* [`missing_const_for_fn`]: No longer lints in proc-macros\n+  [#9308](https://github.com/rust-lang/rust-clippy/pull/9308)\n+* [`non_ascii_literal`]: Allow non-ascii comments in tests and make sure `#[allow]`\n+  attributes work in tests\n+  [#9327](https://github.com/rust-lang/rust-clippy/pull/9327)\n+* [`question_mark`]: No longer lint `if let`s with subpatterns\n+  [#9348](https://github.com/rust-lang/rust-clippy/pull/9348)\n+* [`needless_collect`]: No longer lints in loops\n+  [#8992](https://github.com/rust-lang/rust-clippy/pull/8992)\n+* [`mut_mutex_lock`]: No longer lints if the mutex is behind an immutable reference\n+  [#9418](https://github.com/rust-lang/rust-clippy/pull/9418)\n+* [`needless_return`]: Now ignores returns with arguments\n+  [#9381](https://github.com/rust-lang/rust-clippy/pull/9381)\n+* [`range_plus_one`], [`range_minus_one`]: Now ignores code with macros\n+  [#9446](https://github.com/rust-lang/rust-clippy/pull/9446)\n+* [`assertions_on_result_states`]: No longer lints on the unit type\n+  [#9273](https://github.com/rust-lang/rust-clippy/pull/9273)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`unwrap_or_else_default`]: Now suggests `unwrap_or_default()` for empty strings\n+  [#9421](https://github.com/rust-lang/rust-clippy/pull/9421)\n+* [`if_then_some_else_none`]: Now also suggests `bool::then_some`\n+  [#9289](https://github.com/rust-lang/rust-clippy/pull/9289)\n+* [`redundant_closure_call`]: The suggestion now works for async closures\n+  [#9053](https://github.com/rust-lang/rust-clippy/pull/9053)\n+* [`suboptimal_flops`]: Now suggests parenthesis when they are required\n+  [#9394](https://github.com/rust-lang/rust-clippy/pull/9394)\n+* [`case_sensitive_file_extension_comparisons`]: Now suggests `map_or(..)` instead of `map(..).unwrap_or`\n+  [#9341](https://github.com/rust-lang/rust-clippy/pull/9341)\n+* Deprecated configuration values can now be updated automatically\n+  [#9252](https://github.com/rust-lang/rust-clippy/pull/9252)\n+* [`or_fun_call`]: Now suggest `Entry::or_default` for `Entry::or_insert(Default::default())`\n+  [#9342](https://github.com/rust-lang/rust-clippy/pull/9342)\n+* [`unwrap_used`]: Only suggests `expect` if [`expect_used`] is allowed\n+  [#9223](https://github.com/rust-lang/rust-clippy/pull/9223)\n+\n+### ICE Fixes\n+\n+* Fix ICE in [`useless_format`] for literals\n+  [#9406](https://github.com/rust-lang/rust-clippy/pull/9406)\n+* Fix infinite loop in [`vec_init_then_push`]\n+  [#9441](https://github.com/rust-lang/rust-clippy/pull/9441)\n+* Fix ICE when reading literals with weird proc-macro spans\n+  [#9303](https://github.com/rust-lang/rust-clippy/pull/9303)\n \n ## Rust 1.64\n \n-Current stable, released 2022-09-22\n+Released 2022-09-22\n \n [d7b5cbf0...3c7e7dbc](https://github.com/rust-lang/rust-clippy/compare/d7b5cbf0...3c7e7dbc)\n \n@@ -3903,6 +4047,7 @@ Released 2018-09-13\n [`format_push_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#format_push_string\n [`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n [`from_over_into`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n+[`from_raw_with_void_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_raw_with_void_ptr\n [`from_str_radix_10`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_str_radix_10\n [`future_not_send`]: https://rust-lang.github.io/rust-clippy/master/index.html#future_not_send\n [`get_first`]: https://rust-lang.github.io/rust-clippy/master/index.html#get_first\n@@ -3978,6 +4123,7 @@ Released 2018-09-13\n [`len_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n [`let_and_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\n [`let_underscore_drop`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_drop\n+[`let_underscore_future`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_future\n [`let_underscore_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_lock\n [`let_underscore_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_must_use\n [`let_unit_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_unit_value\n@@ -3996,6 +4142,8 @@ Released 2018-09-13\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n [`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n [`manual_instant_elapsed`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_instant_elapsed\n+[`manual_is_ascii_check`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_is_ascii_check\n+[`manual_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_let_else\n [`manual_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n@@ -4198,6 +4346,8 @@ Released 2018-09-13\n [`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n [`same_name_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_name_method\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n+[`seek_from_current`]: https://rust-lang.github.io/rust-clippy/master/index.html#seek_from_current\n+[`seek_to_start_instead_of_rewind`]: https://rust-lang.github.io/rust-clippy/master/index.html#seek_to_start_instead_of_rewind\n [`self_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_assignment\n [`self_named_constructors`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_named_constructors\n [`self_named_module_files`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_named_module_files\n@@ -4247,6 +4397,7 @@ Released 2018-09-13\n [`suspicious_splitn`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_splitn\n [`suspicious_to_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_to_owned\n [`suspicious_unary_op_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_unary_op_formatting\n+[`suspicious_xor_used_as_pow`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_xor_used_as_pow\n [`swap_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#swap_ptr_to_ref\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n@@ -4277,6 +4428,7 @@ Released 2018-09-13\n [`try_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#try_err\n [`type_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_complexity\n [`type_repetition_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#type_repetition_in_bounds\n+[`unchecked_duration_subtraction`]: https://rust-lang.github.io/rust-clippy/master/index.html#unchecked_duration_subtraction\n [`undocumented_unsafe_blocks`]: https://rust-lang.github.io/rust-clippy/master/index.html#undocumented_unsafe_blocks\n [`undropped_manually_drops`]: https://rust-lang.github.io/rust-clippy/master/index.html#undropped_manually_drops\n [`unicode_not_nfc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unicode_not_nfc\n@@ -4298,6 +4450,7 @@ Released 2018-09-13\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_owned_empty_strings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_owned_empty_strings\n+[`unnecessary_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_safety_doc\n [`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n [`unnecessary_to_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_to_owned"}, {"sha": "e3708bc485399fd42b32c6a1c24491771afa1a04", "filename": "src/tools/clippy/CODE_OF_CONDUCT.md", "status": "modified", "additions": 1, "deletions": 68, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FCODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FCODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCODE_OF_CONDUCT.md?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,70 +1,3 @@\n # The Rust Code of Conduct\n \n-A version of this document [can be found online](https://www.rust-lang.org/conduct.html).\n-\n-## Conduct\n-\n-**Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n-\n-* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience,\n-  gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age,\n-  religion, nationality, or other similar characteristic.\n-* On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and\n-  welcoming environment for all.\n-* Please be kind and courteous. There's no need to be mean or rude.\n-* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and\n-  numerous costs. There is seldom a right answer.\n-* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and\n-  see how it works.\n-* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We\n-  interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen\n-  Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their\n-  definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n-* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or\n-  made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation\n-  team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a\n-  safe place for you and we've got your back.\n-* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n-\n-## Moderation\n-\n-\n-These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation,\n-please contact the [Rust moderation team][mod_team].\n-\n-1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks,\n-   are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)\n-2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.\n-3. Moderators will first respond to such remarks with a warning.\n-4. If the warning is unheeded, the user will be \"kicked,\" i.e., kicked out of the communication channel to cool off.\n-5. If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.\n-6. Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended\n-   party a genuine apology.\n-7. If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a\n-   different moderator, **in private**. Complaints about bans in-channel are not allowed.\n-8. Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate\n-   situation, they should expect less leeway than others.\n-\n-In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically\n-unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly\n-if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can\n-drive people away from the community entirely.\n-\n-And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was\n-they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good\n-there was something you could've communicated better \u2014 remember that it's your responsibility to make your fellow\n-Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about\n-cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their\n-trust.\n-\n-The enforcement policies listed above apply to all official Rust venues; including official IRC channels (#rust,\n-#rust-internals, #rust-tools, #rust-libs, #rustc, #rust-beginners, #rust-docs, #rust-community, #rust-lang, and #cargo);\n-GitHub repositories under rust-lang, rust-lang-nursery, and rust-lang-deprecated; and all forums under rust-lang.org\n-(users.rust-lang.org, internals.rust-lang.org). For other projects adopting the Rust Code of Conduct, please contact the\n-maintainers of those projects for enforcement. If you wish to use this code of conduct for your own project, consider\n-explicitly mentioning your moderation policy or making a copy with your own moderation policy so as to avoid confusion.\n-\n-*Adapted from the [Node.js Policy on Trolling](http://blog.izs.me/post/30036893703/policy-on-trolling) as well as the\n-[Contributor Covenant v1.3.0](https://www.contributor-covenant.org/version/1/3/0/).*\n-\n-[mod_team]: https://www.rust-lang.org/team.html#Moderation-team\n+The Code of Conduct for this repository [can be found online](https://www.rust-lang.org/conduct.html)."}, {"sha": "3158080d2b3099dc66a99e826eeed90128d89fa6", "filename": "src/tools/clippy/CONTRIBUTING.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCONTRIBUTING.md?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -23,6 +23,7 @@ All contributors are expected to follow the [Rust Code of Conduct].\n   - [Issue and PR triage](#issue-and-pr-triage)\n   - [Bors and Homu](#bors-and-homu)\n   - [Contributions](#contributions)\n+  - [License](#license)\n \n [Zulip]: https://rust-lang.zulipchat.com/#narrow/stream/clippy\n [Rust Code of Conduct]: https://www.rust-lang.org/policies/code-of-conduct\n@@ -245,6 +246,38 @@ Contributions to Clippy should be made in the form of GitHub pull requests. Each\n be reviewed by a core contributor (someone with permission to land patches) and either landed in the\n main tree or given feedback for changes that would be required.\n \n+All PRs should include a `changelog` entry with a short comment explaining the change. The rule of thumb is basically,\n+\"what do you believe is important from an outsider's perspective?\" Often, PRs are only related to a single property of a\n+lint, and then it's good to mention that one. Otherwise, it's better to include too much detail than too little.\n+\n+Clippy's [changelog] is created from these comments. Every release, someone gets all commits from bors with a\n+`changelog: XYZ` entry and combines them into the changelog. This is a manual process.\n+\n+Examples:\n+- New lint\n+  ```\n+  changelog: new lint: [`missing_trait_methods`]\n+  ```\n+- False positive fix\n+  ```\n+  changelog: Fix [`unused_peekable`] false positive when peeked in a closure or called as `f(&mut peekable)`\n+  ```\n+- Purely internal change\n+  ```\n+  changelog: none\n+  ```\n+\n+Note this it is fine for a PR to include multiple `changelog` entries, e.g.:\n+```\n+changelog: Something 1\n+changelog: Something 2\n+changelog: Something 3\n+```\n+\n+[changelog]: CHANGELOG.md\n+\n+## License\n+\n All code in this repository is under the [Apache-2.0] or the [MIT] license.\n \n <!-- adapted from https://github.com/servo/servo/blob/master/CONTRIBUTING.md -->"}, {"sha": "fe425a2fb991fdb1377b985eb83d007156ad58dc", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "f74de7de42b8b0d20d5c59b2d71cace4f776c7e6", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,6 +1,6 @@\n # Clippy\n \n-[![Clippy Test](https://github.com/rust-lang/rust-clippy/workflows/Clippy%20Test/badge.svg?branch=auto&event=push)](https://github.com/rust-lang/rust-clippy/actions?query=workflow%3A%22Clippy+Test%22+event%3Apush+branch%3Aauto)\n+[![Clippy Test](https://github.com/rust-lang/rust-clippy/workflows/Clippy%20Test%20(bors)/badge.svg?branch=auto&event=push)](https://github.com/rust-lang/rust-clippy/actions?query=workflow%3A%22Clippy+Test+(bors)%22+event%3Apush+branch%3Aauto)\n [![License: MIT OR Apache-2.0](https://img.shields.io/crates/l/clippy.svg)](#license)\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n@@ -204,12 +204,6 @@ lints can be configured and the meaning of the variables.\n >\n > `clippy.toml` or `.clippy.toml` cannot be used to allow/deny lints.\n \n-> **Note**\n->\n-> Configuration changes will not apply for code that has already been compiled and cached under `./target/`;\n-> for example, adding a new string to `doc-valid-idents` may still result in Clippy flagging that string. To be sure\n-> that any configuration changes are applied, you may want to run `cargo clean` and re-compile your crate from scratch.\n-\n To deactivate the \u201cfor further information visit *lint-link*\u201d message you can\n define the `CLIPPY_DISABLE_DOCS_LINKS` environment variable.\n "}, {"sha": "510c7e852af6e9629f90ff90aeaf1886fa174fb9", "filename": "src/tools/clippy/clippy_dev/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2FCargo.toml?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -10,7 +10,6 @@ indoc = \"1.0\"\n itertools = \"0.10.1\"\n opener = \"0.5\"\n shell-escape = \"0.1\"\n-tempfile = \"3.2\"\n walkdir = \"2.3\"\n \n [features]"}, {"sha": "aafd0f71a59bc15951a87d2065d68820d1e398a9", "filename": "src/tools/clippy/clippy_dev/src/lint.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flint.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -36,20 +36,12 @@ pub fn run<'a>(path: &str, args: impl Iterator<Item = &'a String>) {\n     } else {\n         exit_if_err(Command::new(\"cargo\").arg(\"build\").status());\n \n-        // Run in a tempdir as changes to clippy do not retrigger linting\n-        let target = tempfile::Builder::new()\n-            .prefix(\"clippy\")\n-            .tempdir()\n-            .expect(\"failed to create tempdir\");\n-\n         let status = Command::new(cargo_clippy_path())\n             .arg(\"clippy\")\n             .args(args)\n             .current_dir(path)\n-            .env(\"CARGO_TARGET_DIR\", target.as_ref())\n             .status();\n \n-        target.close().expect(\"failed to remove tempdir\");\n         exit_if_err(status);\n     }\n }"}, {"sha": "837618c9294b7511f4cb8a22b79c127a23bc7f95", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 84, "deletions": 223, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -3,7 +3,7 @@ use aho_corasick::AhoCorasickBuilder;\n use indoc::writedoc;\n use itertools::Itertools;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n-use std::collections::{BTreeSet, HashMap, HashSet};\n+use std::collections::{HashMap, HashSet};\n use std::ffi::OsStr;\n use std::fmt::Write;\n use std::fs::{self, OpenOptions};\n@@ -36,6 +36,60 @@ pub enum UpdateMode {\n pub fn update(update_mode: UpdateMode) {\n     let (lints, deprecated_lints, renamed_lints) = gather_all();\n     generate_lint_files(update_mode, &lints, &deprecated_lints, &renamed_lints);\n+    remove_old_files(update_mode);\n+}\n+\n+/// Remove files no longer needed after <https://github.com/rust-lang/rust-clippy/pull/9541>\n+/// that may be reintroduced unintentionally\n+///\n+/// FIXME: This is a temporary measure that should be removed when there are no more PRs that\n+/// include the stray files\n+fn remove_old_files(update_mode: UpdateMode) {\n+    let mut failed = false;\n+    let mut remove_file = |path: &Path| match update_mode {\n+        UpdateMode::Check => {\n+            if path.exists() {\n+                failed = true;\n+                println!(\"unexpected file: {}\", path.display());\n+            }\n+        },\n+        UpdateMode::Change => {\n+            if fs::remove_file(path).is_ok() {\n+                println!(\"removed file: {}\", path.display());\n+            }\n+        },\n+    };\n+\n+    let files = [\n+        \"clippy_lints/src/lib.register_all.rs\",\n+        \"clippy_lints/src/lib.register_cargo.rs\",\n+        \"clippy_lints/src/lib.register_complexity.rs\",\n+        \"clippy_lints/src/lib.register_correctness.rs\",\n+        \"clippy_lints/src/lib.register_internal.rs\",\n+        \"clippy_lints/src/lib.register_lints.rs\",\n+        \"clippy_lints/src/lib.register_nursery.rs\",\n+        \"clippy_lints/src/lib.register_pedantic.rs\",\n+        \"clippy_lints/src/lib.register_perf.rs\",\n+        \"clippy_lints/src/lib.register_restriction.rs\",\n+        \"clippy_lints/src/lib.register_style.rs\",\n+        \"clippy_lints/src/lib.register_suspicious.rs\",\n+        \"src/docs.rs\",\n+    ];\n+\n+    for file in files {\n+        remove_file(Path::new(file));\n+    }\n+\n+    if let Ok(docs_dir) = fs::read_dir(\"src/docs\") {\n+        for doc_file in docs_dir {\n+            let path = doc_file.unwrap().path();\n+            remove_file(&path);\n+        }\n+    }\n+\n+    if failed {\n+        exit_with_failure();\n+    }\n }\n \n fn generate_lint_files(\n@@ -104,99 +158,23 @@ fn generate_lint_files(\n     );\n \n     process_file(\n-        \"clippy_lints/src/lib.register_lints.rs\",\n+        \"clippy_lints/src/declared_lints.rs\",\n         update_mode,\n-        &gen_register_lint_list(internal_lints.iter(), usable_lints.iter()),\n+        &gen_declared_lints(internal_lints.iter(), usable_lints.iter()),\n     );\n     process_file(\n         \"clippy_lints/src/lib.deprecated.rs\",\n         update_mode,\n         &gen_deprecated(deprecated_lints),\n     );\n \n-    let all_group_lints = usable_lints.iter().filter(|l| {\n-        matches!(\n-            &*l.group,\n-            \"correctness\" | \"suspicious\" | \"style\" | \"complexity\" | \"perf\"\n-        )\n-    });\n-    let content = gen_lint_group_list(\"all\", all_group_lints);\n-    process_file(\"clippy_lints/src/lib.register_all.rs\", update_mode, &content);\n-\n-    update_docs(update_mode, &usable_lints);\n-\n-    for (lint_group, lints) in Lint::by_lint_group(usable_lints.into_iter().chain(internal_lints)) {\n-        let content = gen_lint_group_list(&lint_group, lints.iter());\n-        process_file(\n-            format!(\"clippy_lints/src/lib.register_{lint_group}.rs\"),\n-            update_mode,\n-            &content,\n-        );\n-    }\n-\n     let content = gen_deprecated_lints_test(deprecated_lints);\n     process_file(\"tests/ui/deprecated.rs\", update_mode, &content);\n \n     let content = gen_renamed_lints_test(renamed_lints);\n     process_file(\"tests/ui/rename.rs\", update_mode, &content);\n }\n \n-fn update_docs(update_mode: UpdateMode, usable_lints: &[Lint]) {\n-    replace_region_in_file(update_mode, Path::new(\"src/docs.rs\"), \"docs! {\\n\", \"\\n}\\n\", |res| {\n-        for name in usable_lints.iter().map(|lint| lint.name.clone()).sorted() {\n-            writeln!(res, r#\"    \"{name}\",\"#).unwrap();\n-        }\n-    });\n-\n-    if update_mode == UpdateMode::Check {\n-        let mut extra = BTreeSet::new();\n-        let mut lint_names = usable_lints\n-            .iter()\n-            .map(|lint| lint.name.clone())\n-            .collect::<BTreeSet<_>>();\n-        for file in std::fs::read_dir(\"src/docs\").unwrap() {\n-            let filename = file.unwrap().file_name().into_string().unwrap();\n-            if let Some(name) = filename.strip_suffix(\".txt\") {\n-                if !lint_names.remove(name) {\n-                    extra.insert(name.to_string());\n-                }\n-            }\n-        }\n-\n-        let failed = print_lint_names(\"extra lint docs:\", &extra) | print_lint_names(\"missing lint docs:\", &lint_names);\n-\n-        if failed {\n-            exit_with_failure();\n-        }\n-    } else {\n-        if std::fs::remove_dir_all(\"src/docs\").is_err() {\n-            eprintln!(\"could not remove src/docs directory\");\n-        }\n-        if std::fs::create_dir(\"src/docs\").is_err() {\n-            eprintln!(\"could not recreate src/docs directory\");\n-        }\n-    }\n-    for lint in usable_lints {\n-        process_file(\n-            Path::new(\"src/docs\").join(lint.name.clone() + \".txt\"),\n-            update_mode,\n-            &lint.documentation,\n-        );\n-    }\n-}\n-\n-fn print_lint_names(header: &str, lints: &BTreeSet<String>) -> bool {\n-    if lints.is_empty() {\n-        return false;\n-    }\n-    println!(\"{header}\");\n-    for lint in lints.iter().sorted() {\n-        println!(\"    {lint}\");\n-    }\n-    println!();\n-    true\n-}\n-\n pub fn print_lints() {\n     let (lint_list, _, _) = gather_all();\n     let usable_lints = Lint::usable_lints(&lint_list);\n@@ -641,26 +619,17 @@ struct Lint {\n     desc: String,\n     module: String,\n     declaration_range: Range<usize>,\n-    documentation: String,\n }\n \n impl Lint {\n     #[must_use]\n-    fn new(\n-        name: &str,\n-        group: &str,\n-        desc: &str,\n-        module: &str,\n-        declaration_range: Range<usize>,\n-        documentation: String,\n-    ) -> Self {\n+    fn new(name: &str, group: &str, desc: &str, module: &str, declaration_range: Range<usize>) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             group: group.into(),\n             desc: remove_line_splices(desc),\n             module: module.into(),\n             declaration_range,\n-            documentation,\n         }\n     }\n \n@@ -716,25 +685,6 @@ impl RenamedLint {\n     }\n }\n \n-/// Generates the code for registering a group\n-fn gen_lint_group_list<'a>(group_name: &str, lints: impl Iterator<Item = &'a Lint>) -> String {\n-    let mut details: Vec<_> = lints.map(|l| (&l.module, l.name.to_uppercase())).collect();\n-    details.sort_unstable();\n-\n-    let mut output = GENERATED_FILE_COMMENT.to_string();\n-\n-    let _ = writeln!(\n-        output,\n-        \"store.register_group(true, \\\"clippy::{group_name}\\\", Some(\\\"clippy_{group_name}\\\"), vec![\",\n-    );\n-    for (module, name) in details {\n-        let _ = writeln!(output, \"    LintId::of({module}::{name}),\");\n-    }\n-    output.push_str(\"])\\n\");\n-\n-    output\n-}\n-\n /// Generates the `register_removed` code\n #[must_use]\n fn gen_deprecated(lints: &[DeprecatedLint]) -> String {\n@@ -759,7 +709,7 @@ fn gen_deprecated(lints: &[DeprecatedLint]) -> String {\n \n /// Generates the code for registering lints\n #[must_use]\n-fn gen_register_lint_list<'a>(\n+fn gen_declared_lints<'a>(\n     internal_lints: impl Iterator<Item = &'a Lint>,\n     usable_lints: impl Iterator<Item = &'a Lint>,\n ) -> String {\n@@ -770,15 +720,15 @@ fn gen_register_lint_list<'a>(\n     details.sort_unstable();\n \n     let mut output = GENERATED_FILE_COMMENT.to_string();\n-    output.push_str(\"store.register_lints(&[\\n\");\n+    output.push_str(\"pub(crate) static LINTS: &[&crate::LintInfo] = &[\\n\");\n \n     for (is_public, module_name, lint_name) in details {\n         if !is_public {\n             output.push_str(\"    #[cfg(feature = \\\"internal\\\")]\\n\");\n         }\n-        let _ = writeln!(output, \"    {module_name}::{lint_name},\");\n+        let _ = writeln!(output, \"    crate::{module_name}::{lint_name}_INFO,\");\n     }\n-    output.push_str(\"])\\n\");\n+    output.push_str(\"];\\n\");\n \n     output\n }\n@@ -910,35 +860,26 @@ fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n          }| token_kind == &TokenKind::Ident && *content == \"declare_clippy_lint\",\n     ) {\n         let start = range.start;\n-        let mut docs = String::with_capacity(128);\n-        let mut iter = iter.by_ref().filter(|t| !matches!(t.token_kind, TokenKind::Whitespace));\n+        let mut iter = iter\n+            .by_ref()\n+            .filter(|t| !matches!(t.token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n         // matches `!{`\n         match_tokens!(iter, Bang OpenBrace);\n-        let mut in_code = false;\n-        while let Some(t) = iter.next() {\n-            match t.token_kind {\n-                TokenKind::LineComment { .. } => {\n-                    if let Some(line) = t.content.strip_prefix(\"/// \").or_else(|| t.content.strip_prefix(\"///\")) {\n-                        if line.starts_with(\"```\") {\n-                            docs += \"```\\n\";\n-                            in_code = !in_code;\n-                        } else if !(in_code && line.starts_with(\"# \")) {\n-                            docs += line;\n-                            docs.push('\\n');\n-                        }\n-                    }\n-                },\n-                TokenKind::Pound => {\n-                    match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n-                    break;\n-                },\n-                TokenKind::Ident => {\n-                    break;\n-                },\n-                _ => {},\n-            }\n+        match iter.next() {\n+            // #[clippy::version = \"version\"] pub\n+            Some(LintDeclSearchResult {\n+                token_kind: TokenKind::Pound,\n+                ..\n+            }) => {\n+                match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n+            },\n+            // pub\n+            Some(LintDeclSearchResult {\n+                token_kind: TokenKind::Ident,\n+                ..\n+            }) => (),\n+            _ => continue,\n         }\n-        docs.pop(); // remove final newline\n \n         let (name, group, desc) = match_tokens!(\n             iter,\n@@ -956,7 +897,7 @@ fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n             ..\n         }) = iter.next()\n         {\n-            lints.push(Lint::new(name, group, desc, module, start..range.end, docs));\n+            lints.push(Lint::new(name, group, desc, module, start..range.end));\n         }\n     }\n }\n@@ -1186,15 +1127,13 @@ mod tests {\n                 \"\\\"really long text\\\"\",\n                 \"module_name\",\n                 Range::default(),\n-                String::new(),\n             ),\n             Lint::new(\n                 \"doc_markdown\",\n                 \"pedantic\",\n                 \"\\\"single line\\\"\",\n                 \"module_name\",\n                 Range::default(),\n-                String::new(),\n             ),\n         ];\n         assert_eq!(expected, result);\n@@ -1234,23 +1173,20 @@ mod tests {\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n-                String::new(),\n             ),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"internal\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n-                String::new(),\n             ),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"internal_style\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n-                String::new(),\n             ),\n         ];\n         let expected = vec![Lint::new(\n@@ -1259,59 +1195,29 @@ mod tests {\n             \"\\\"abc\\\"\",\n             \"module_name\",\n             Range::default(),\n-            String::new(),\n         )];\n         assert_eq!(expected, Lint::usable_lints(&lints));\n     }\n \n     #[test]\n     fn test_by_lint_group() {\n         let lints = vec![\n-            Lint::new(\n-                \"should_assert_eq\",\n-                \"group1\",\n-                \"\\\"abc\\\"\",\n-                \"module_name\",\n-                Range::default(),\n-                String::new(),\n-            ),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n             Lint::new(\n                 \"should_assert_eq2\",\n                 \"group2\",\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n-                String::new(),\n-            ),\n-            Lint::new(\n-                \"incorrect_match\",\n-                \"group1\",\n-                \"\\\"abc\\\"\",\n-                \"module_name\",\n-                Range::default(),\n-                String::new(),\n             ),\n+            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n         expected.insert(\n             \"group1\".to_string(),\n             vec![\n-                Lint::new(\n-                    \"should_assert_eq\",\n-                    \"group1\",\n-                    \"\\\"abc\\\"\",\n-                    \"module_name\",\n-                    Range::default(),\n-                    String::new(),\n-                ),\n-                Lint::new(\n-                    \"incorrect_match\",\n-                    \"group1\",\n-                    \"\\\"abc\\\"\",\n-                    \"module_name\",\n-                    Range::default(),\n-                    String::new(),\n-                ),\n+                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n             ],\n         );\n         expected.insert(\n@@ -1322,7 +1228,6 @@ mod tests {\n                 \"\\\"abc\\\"\",\n                 \"module_name\",\n                 Range::default(),\n-                String::new(),\n             )],\n         );\n         assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n@@ -1357,48 +1262,4 @@ mod tests {\n \n         assert_eq!(expected, gen_deprecated(&lints));\n     }\n-\n-    #[test]\n-    fn test_gen_lint_group_list() {\n-        let lints = vec![\n-            Lint::new(\n-                \"abc\",\n-                \"group1\",\n-                \"\\\"abc\\\"\",\n-                \"module_name\",\n-                Range::default(),\n-                String::new(),\n-            ),\n-            Lint::new(\n-                \"should_assert_eq\",\n-                \"group1\",\n-                \"\\\"abc\\\"\",\n-                \"module_name\",\n-                Range::default(),\n-                String::new(),\n-            ),\n-            Lint::new(\n-                \"internal\",\n-                \"internal_style\",\n-                \"\\\"abc\\\"\",\n-                \"module_name\",\n-                Range::default(),\n-                String::new(),\n-            ),\n-        ];\n-        let expected = GENERATED_FILE_COMMENT.to_string()\n-            + &[\n-                \"store.register_group(true, \\\"clippy::group1\\\", Some(\\\"clippy_group1\\\"), vec![\",\n-                \"    LintId::of(module_name::ABC),\",\n-                \"    LintId::of(module_name::INTERNAL),\",\n-                \"    LintId::of(module_name::SHOULD_ASSERT_EQ),\",\n-                \"])\",\n-            ]\n-            .join(\"\\n\")\n-            + \"\\n\";\n-\n-        let result = gen_lint_group_list(\"group1\", lints.iter());\n-\n-        assert_eq!(expected, result);\n-    }\n }"}, {"sha": "aedff24c12c6078b7aec3236f261837008df36e3", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -11,6 +11,7 @@ edition = \"2021\"\n [dependencies]\n cargo_metadata = \"0.14\"\n clippy_utils = { path = \"../clippy_utils\" }\n+declare_clippy_lint = { path = \"../declare_clippy_lint\" }\n if_chain = \"1.0\"\n itertools = \"0.10.1\"\n pulldown-cmark = { version = \"0.9\", default-features = false }"}, {"sha": "ecf8e83375dbf718173a941298d87613a6c646fb", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -11,14 +11,14 @@ use rustc_errors::Applicability;\n use rustc_hir::{\n     Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,\n };\n-use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, Level, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::sym;\n use rustc_span::symbol::Symbol;\n+use rustc_span::{sym, DUMMY_SP};\n use semver::Version;\n \n static UNIX_SYSTEMS: &[&str] = &[\n@@ -303,6 +303,26 @@ declare_lint_pass!(Attributes => [\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Attributes {\n+    fn check_crate(&mut self, cx: &LateContext<'tcx>) {\n+        for (name, level) in &cx.sess().opts.lint_opts {\n+            if name == \"clippy::restriction\" && *level > Level::Allow {\n+                span_lint_and_then(\n+                    cx,\n+                    BLANKET_CLIPPY_RESTRICTION_LINTS,\n+                    DUMMY_SP,\n+                    \"`clippy::restriction` is not meant to be enabled as a group\",\n+                    |diag| {\n+                        diag.note(format!(\n+                            \"because of the command line `--{} clippy::restriction`\",\n+                            level.as_str()\n+                        ));\n+                        diag.help(\"enable the restriction lints you need individually\");\n+                    },\n+                );\n+            }\n+        }\n+    }\n+\n     fn check_attribute(&mut self, cx: &LateContext<'tcx>, attr: &'tcx Attribute) {\n         if let Some(items) = &attr.meta_item_list() {\n             if let Some(ident) = attr.ident() {\n@@ -358,7 +378,9 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                                                         | \"enum_glob_use\"\n                                                         | \"redundant_pub_crate\"\n                                                         | \"macro_use_imports\"\n-                                                        | \"unsafe_removed_from_name\",\n+                                                        | \"unsafe_removed_from_name\"\n+                                                        | \"module_name_repetitions\"\n+                                                        | \"single_component_path_imports\"\n                                                 )\n                                             })\n                                         {\n@@ -441,9 +463,9 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, name: Symbol, items: &[NestedMe\n                     cx,\n                     BLANKET_CLIPPY_RESTRICTION_LINTS,\n                     lint.span(),\n-                    \"restriction lints are not meant to be all enabled\",\n+                    \"`clippy::restriction` is not meant to be enabled as a group\",\n                     None,\n-                    \"try enabling only the lints you really need\",\n+                    \"enable the restriction lints you need individually\",\n                 );\n             }\n         }\n@@ -464,6 +486,11 @@ fn check_lint_reason(cx: &LateContext<'_>, name: Symbol, items: &[NestedMetaItem\n         return;\n     }\n \n+    // Check if the attribute is in an external macro and therefore out of the developer's control\n+    if in_external_macro(cx.sess(), attr.span) {\n+        return;\n+    }\n+\n     span_lint_and_help(\n         cx,\n         ALLOW_ATTRIBUTES_WITHOUT_REASON,"}, {"sha": "d40a385435afb59e695d2d101633f4df737fbad0", "filename": "src/tools/clippy/clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -189,7 +188,7 @@ impl LateLintPass<'_> for AwaitHolding {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for conf in &self.conf_invalid_types {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::TypeNS)) {\n+            for id in clippy_utils::def_path_def_ids(cx, &segs) {\n                 self.def_ids.insert(id, conf.clone());\n             }\n         }"}, {"sha": "bdb3a011602729b5119024893cda47203588c74e", "filename": "src/tools/clippy/clippy_lints/src/bool_to_int_with_if.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_to_int_with_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_to_int_with_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_to_int_with_if.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,9 +1,10 @@\n+use clippy_utils::higher::If;\n use rustc_ast::LitKind;\n use rustc_hir::{Block, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use clippy_utils::{diagnostics::span_lint_and_then, is_else_clause, is_integer_literal, sugg::Sugg};\n+use clippy_utils::{diagnostics::span_lint_and_then, in_constant, is_else_clause, is_integer_literal, sugg::Sugg};\n use rustc_errors::Applicability;\n \n declare_clippy_lint! {\n@@ -12,7 +13,7 @@ declare_clippy_lint! {\n     /// this lint suggests using a `from()` function or an `as` coercion.\n     ///\n     /// ### Why is this bad?\n-    /// Coercion or `from()` is idiomatic way to convert bool to a number.\n+    /// Coercion or `from()` is another way to convert bool to a number.\n     /// Both methods are guaranteed to return 1 for true, and 0 for false.\n     ///\n     /// See https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E\n@@ -38,23 +39,23 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.65.0\"]\n     pub BOOL_TO_INT_WITH_IF,\n-    style,\n+    pedantic,\n     \"using if to convert bool to int\"\n }\n declare_lint_pass!(BoolToIntWithIf => [BOOL_TO_INT_WITH_IF]);\n \n impl<'tcx> LateLintPass<'tcx> for BoolToIntWithIf {\n-    fn check_expr(&mut self, ctx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx>) {\n-        if !expr.span.from_expansion() {\n-            check_if_else(ctx, expr);\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx>) {\n+        if !expr.span.from_expansion() && !in_constant(cx, expr.hir_id) {\n+            check_if_else(cx, expr);\n         }\n     }\n }\n \n-fn check_if_else<'tcx>(ctx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx>) {\n-    if let ExprKind::If(check, then, Some(else_)) = expr.kind\n+fn check_if_else<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx>) {\n+    if let Some(If { cond, then, r#else: Some(r#else) }) = If::hir(expr)\n         && let Some(then_lit) = int_literal(then)\n-        && let Some(else_lit) = int_literal(else_)\n+        && let Some(else_lit) = int_literal(r#else)\n     {\n         let inverted = if is_integer_literal(then_lit, 1) && is_integer_literal(else_lit, 0) {\n             false\n@@ -66,17 +67,17 @@ fn check_if_else<'tcx>(ctx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx\n         };\n         let mut applicability = Applicability::MachineApplicable;\n         let snippet = {\n-            let mut sugg = Sugg::hir_with_applicability(ctx, check, \"..\", &mut applicability);\n+            let mut sugg = Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability);\n             if inverted {\n                 sugg = !sugg;\n             }\n             sugg\n         };\n \n-        let ty = ctx.typeck_results().expr_ty(then_lit); // then and else must be of same type\n+        let ty = cx.typeck_results().expr_ty(then_lit); // then and else must be of same type\n \n         let suggestion = {\n-            let wrap_in_curly = is_else_clause(ctx.tcx, expr);\n+            let wrap_in_curly = is_else_clause(cx.tcx, expr);\n             let mut s = Sugg::NonParen(format!(\"{ty}::from({snippet})\").into());\n             if wrap_in_curly {\n                 s = s.blockify();\n@@ -87,7 +88,7 @@ fn check_if_else<'tcx>(ctx: &LateContext<'tcx>, expr: &'tcx rustc_hir::Expr<'tcx\n         let into_snippet = snippet.clone().maybe_par();\n         let as_snippet = snippet.as_ty(ty);\n \n-        span_lint_and_then(ctx,\n+        span_lint_and_then(cx,\n             BOOL_TO_INT_WITH_IF,\n             expr.span,\n             \"boolean to int conversion using if\","}, {"sha": "939bdbcdc7cd7e245b733bed959c419f0b336f76", "filename": "src/tools/clippy/clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbooleans.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n     }\n }\n \n-fn implements_ord<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n+fn implements_ord(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n     cx.tcx\n         .get_diagnostic_item(sym::Ord)"}, {"sha": "7148b5e6ebf45e09c2da8693aaf6184410ec6bbc", "filename": "src/tools/clippy/clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -593,7 +593,7 @@ declare_clippy_lint! {\n     /// let _: *mut [u8] = std::ptr::slice_from_raw_parts_mut(ptr, len);\n     /// ```\n     /// [safety requirements]: https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety\n-    #[clippy::version = \"1.64.0\"]\n+    #[clippy::version = \"1.65.0\"]\n     pub CAST_SLICE_FROM_RAW_PARTS,\n     suspicious,\n     \"casting a slice created from a pointer and length to a slice pointer\""}, {"sha": "1c3a89a97824c31ccdb1f4888fb2b85eb67b88ff", "filename": "src/tools/clippy/clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -4,11 +4,11 @@ use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::visitors::for_each_expr;\n-use clippy_utils::LimitStack;\n+use clippy_utils::{get_async_fn_body, is_async_fn, LimitStack};\n use core::ops::ControlFlow;\n use rustc_ast::ast::Attribute;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, ExprKind, FnDecl, HirId};\n+use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n@@ -56,15 +56,13 @@ impl CognitiveComplexity {\n         cx: &LateContext<'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl<'_>,\n-        body: &'tcx Body<'_>,\n+        expr: &'tcx Expr<'_>,\n         body_span: Span,\n     ) {\n         if body_span.from_expansion() {\n             return;\n         }\n \n-        let expr = body.value;\n-\n         let mut cc = 1u64;\n         let mut returns = 0u64;\n         let _: Option<!> = for_each_expr(expr, |e| {\n@@ -146,7 +144,18 @@ impl<'tcx> LateLintPass<'tcx> for CognitiveComplexity {\n     ) {\n         let def_id = cx.tcx.hir().local_def_id(hir_id);\n         if !cx.tcx.has_attr(def_id.to_def_id(), sym::test) {\n-            self.check(cx, kind, decl, body, span);\n+            let expr = if is_async_fn(kind) {\n+                match get_async_fn_body(cx.tcx, body) {\n+                    Some(b) => b,\n+                    None => {\n+                        return;\n+                    },\n+                }\n+            } else {\n+                body.value\n+            };\n+\n+            self.check(cx, kind, decl, expr, span);\n         }\n     }\n "}, {"sha": "0d3fc43a6443b69f23e38a42eb3569411aad39b1", "filename": "src/tools/clippy/clippy_lints/src/declared_lints.rs", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,628 @@\n+// This file was generated by `cargo dev update_lints`.\n+// Use that command to update this file and do not edit by hand.\n+// Manual edits will be overwritten.\n+\n+pub(crate) static LINTS: &[&crate::LintInfo] = &[\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::if_chain_style::IF_CHAIN_STYLE_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::invalid_paths::INVALID_PATHS_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::produce_ice::PRODUCE_ICE_INFO,\n+    #[cfg(feature = \"internal\")]\n+    crate::utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH_INFO,\n+    crate::almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE_INFO,\n+    crate::approx_const::APPROX_CONSTANT_INFO,\n+    crate::as_conversions::AS_CONVERSIONS_INFO,\n+    crate::asm_syntax::INLINE_ASM_X86_ATT_SYNTAX_INFO,\n+    crate::asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX_INFO,\n+    crate::assertions_on_constants::ASSERTIONS_ON_CONSTANTS_INFO,\n+    crate::assertions_on_result_states::ASSERTIONS_ON_RESULT_STATES_INFO,\n+    crate::async_yields_async::ASYNC_YIELDS_ASYNC_INFO,\n+    crate::attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON_INFO,\n+    crate::attrs::BLANKET_CLIPPY_RESTRICTION_LINTS_INFO,\n+    crate::attrs::DEPRECATED_CFG_ATTR_INFO,\n+    crate::attrs::DEPRECATED_SEMVER_INFO,\n+    crate::attrs::EMPTY_LINE_AFTER_OUTER_ATTR_INFO,\n+    crate::attrs::INLINE_ALWAYS_INFO,\n+    crate::attrs::MISMATCHED_TARGET_OS_INFO,\n+    crate::attrs::USELESS_ATTRIBUTE_INFO,\n+    crate::await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE_INFO,\n+    crate::await_holding_invalid::AWAIT_HOLDING_LOCK_INFO,\n+    crate::await_holding_invalid::AWAIT_HOLDING_REFCELL_REF_INFO,\n+    crate::blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS_INFO,\n+    crate::bool_assert_comparison::BOOL_ASSERT_COMPARISON_INFO,\n+    crate::bool_to_int_with_if::BOOL_TO_INT_WITH_IF_INFO,\n+    crate::booleans::NONMINIMAL_BOOL_INFO,\n+    crate::booleans::OVERLY_COMPLEX_BOOL_EXPR_INFO,\n+    crate::borrow_deref_ref::BORROW_DEREF_REF_INFO,\n+    crate::box_default::BOX_DEFAULT_INFO,\n+    crate::cargo::CARGO_COMMON_METADATA_INFO,\n+    crate::cargo::MULTIPLE_CRATE_VERSIONS_INFO,\n+    crate::cargo::NEGATIVE_FEATURE_NAMES_INFO,\n+    crate::cargo::REDUNDANT_FEATURE_NAMES_INFO,\n+    crate::cargo::WILDCARD_DEPENDENCIES_INFO,\n+    crate::casts::AS_PTR_CAST_MUT_INFO,\n+    crate::casts::AS_UNDERSCORE_INFO,\n+    crate::casts::BORROW_AS_PTR_INFO,\n+    crate::casts::CAST_ABS_TO_UNSIGNED_INFO,\n+    crate::casts::CAST_ENUM_CONSTRUCTOR_INFO,\n+    crate::casts::CAST_ENUM_TRUNCATION_INFO,\n+    crate::casts::CAST_LOSSLESS_INFO,\n+    crate::casts::CAST_NAN_TO_INT_INFO,\n+    crate::casts::CAST_POSSIBLE_TRUNCATION_INFO,\n+    crate::casts::CAST_POSSIBLE_WRAP_INFO,\n+    crate::casts::CAST_PRECISION_LOSS_INFO,\n+    crate::casts::CAST_PTR_ALIGNMENT_INFO,\n+    crate::casts::CAST_REF_TO_MUT_INFO,\n+    crate::casts::CAST_SIGN_LOSS_INFO,\n+    crate::casts::CAST_SLICE_DIFFERENT_SIZES_INFO,\n+    crate::casts::CAST_SLICE_FROM_RAW_PARTS_INFO,\n+    crate::casts::CHAR_LIT_AS_U8_INFO,\n+    crate::casts::FN_TO_NUMERIC_CAST_INFO,\n+    crate::casts::FN_TO_NUMERIC_CAST_ANY_INFO,\n+    crate::casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION_INFO,\n+    crate::casts::PTR_AS_PTR_INFO,\n+    crate::casts::UNNECESSARY_CAST_INFO,\n+    crate::checked_conversions::CHECKED_CONVERSIONS_INFO,\n+    crate::cognitive_complexity::COGNITIVE_COMPLEXITY_INFO,\n+    crate::collapsible_if::COLLAPSIBLE_ELSE_IF_INFO,\n+    crate::collapsible_if::COLLAPSIBLE_IF_INFO,\n+    crate::comparison_chain::COMPARISON_CHAIN_INFO,\n+    crate::copies::BRANCHES_SHARING_CODE_INFO,\n+    crate::copies::IFS_SAME_COND_INFO,\n+    crate::copies::IF_SAME_THEN_ELSE_INFO,\n+    crate::copies::SAME_FUNCTIONS_IN_IF_CONDITION_INFO,\n+    crate::copy_iterator::COPY_ITERATOR_INFO,\n+    crate::crate_in_macro_def::CRATE_IN_MACRO_DEF_INFO,\n+    crate::create_dir::CREATE_DIR_INFO,\n+    crate::dbg_macro::DBG_MACRO_INFO,\n+    crate::default::DEFAULT_TRAIT_ACCESS_INFO,\n+    crate::default::FIELD_REASSIGN_WITH_DEFAULT_INFO,\n+    crate::default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY_INFO,\n+    crate::default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK_INFO,\n+    crate::default_union_representation::DEFAULT_UNION_REPRESENTATION_INFO,\n+    crate::dereference::EXPLICIT_AUTO_DEREF_INFO,\n+    crate::dereference::EXPLICIT_DEREF_METHODS_INFO,\n+    crate::dereference::NEEDLESS_BORROW_INFO,\n+    crate::dereference::REF_BINDING_TO_REFERENCE_INFO,\n+    crate::derivable_impls::DERIVABLE_IMPLS_INFO,\n+    crate::derive::DERIVE_HASH_XOR_EQ_INFO,\n+    crate::derive::DERIVE_ORD_XOR_PARTIAL_ORD_INFO,\n+    crate::derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ_INFO,\n+    crate::derive::EXPL_IMPL_CLONE_ON_COPY_INFO,\n+    crate::derive::UNSAFE_DERIVE_DESERIALIZE_INFO,\n+    crate::disallowed_macros::DISALLOWED_MACROS_INFO,\n+    crate::disallowed_methods::DISALLOWED_METHODS_INFO,\n+    crate::disallowed_names::DISALLOWED_NAMES_INFO,\n+    crate::disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS_INFO,\n+    crate::disallowed_types::DISALLOWED_TYPES_INFO,\n+    crate::doc::DOC_LINK_WITH_QUOTES_INFO,\n+    crate::doc::DOC_MARKDOWN_INFO,\n+    crate::doc::MISSING_ERRORS_DOC_INFO,\n+    crate::doc::MISSING_PANICS_DOC_INFO,\n+    crate::doc::MISSING_SAFETY_DOC_INFO,\n+    crate::doc::NEEDLESS_DOCTEST_MAIN_INFO,\n+    crate::doc::UNNECESSARY_SAFETY_DOC_INFO,\n+    crate::double_parens::DOUBLE_PARENS_INFO,\n+    crate::drop_forget_ref::DROP_COPY_INFO,\n+    crate::drop_forget_ref::DROP_NON_DROP_INFO,\n+    crate::drop_forget_ref::DROP_REF_INFO,\n+    crate::drop_forget_ref::FORGET_COPY_INFO,\n+    crate::drop_forget_ref::FORGET_NON_DROP_INFO,\n+    crate::drop_forget_ref::FORGET_REF_INFO,\n+    crate::drop_forget_ref::UNDROPPED_MANUALLY_DROPS_INFO,\n+    crate::duplicate_mod::DUPLICATE_MOD_INFO,\n+    crate::else_if_without_else::ELSE_IF_WITHOUT_ELSE_INFO,\n+    crate::empty_drop::EMPTY_DROP_INFO,\n+    crate::empty_enum::EMPTY_ENUM_INFO,\n+    crate::empty_structs_with_brackets::EMPTY_STRUCTS_WITH_BRACKETS_INFO,\n+    crate::entry::MAP_ENTRY_INFO,\n+    crate::enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT_INFO,\n+    crate::enum_variants::ENUM_VARIANT_NAMES_INFO,\n+    crate::enum_variants::MODULE_INCEPTION_INFO,\n+    crate::enum_variants::MODULE_NAME_REPETITIONS_INFO,\n+    crate::equatable_if_let::EQUATABLE_IF_LET_INFO,\n+    crate::escape::BOXED_LOCAL_INFO,\n+    crate::eta_reduction::REDUNDANT_CLOSURE_INFO,\n+    crate::eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS_INFO,\n+    crate::excessive_bools::FN_PARAMS_EXCESSIVE_BOOLS_INFO,\n+    crate::excessive_bools::STRUCT_EXCESSIVE_BOOLS_INFO,\n+    crate::exhaustive_items::EXHAUSTIVE_ENUMS_INFO,\n+    crate::exhaustive_items::EXHAUSTIVE_STRUCTS_INFO,\n+    crate::exit::EXIT_INFO,\n+    crate::explicit_write::EXPLICIT_WRITE_INFO,\n+    crate::fallible_impl_from::FALLIBLE_IMPL_FROM_INFO,\n+    crate::float_literal::EXCESSIVE_PRECISION_INFO,\n+    crate::float_literal::LOSSY_FLOAT_LITERAL_INFO,\n+    crate::floating_point_arithmetic::IMPRECISE_FLOPS_INFO,\n+    crate::floating_point_arithmetic::SUBOPTIMAL_FLOPS_INFO,\n+    crate::format::USELESS_FORMAT_INFO,\n+    crate::format_args::FORMAT_IN_FORMAT_ARGS_INFO,\n+    crate::format_args::TO_STRING_IN_FORMAT_ARGS_INFO,\n+    crate::format_args::UNINLINED_FORMAT_ARGS_INFO,\n+    crate::format_args::UNUSED_FORMAT_SPECS_INFO,\n+    crate::format_impl::PRINT_IN_FORMAT_IMPL_INFO,\n+    crate::format_impl::RECURSIVE_FORMAT_IMPL_INFO,\n+    crate::format_push_string::FORMAT_PUSH_STRING_INFO,\n+    crate::formatting::POSSIBLE_MISSING_COMMA_INFO,\n+    crate::formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING_INFO,\n+    crate::formatting::SUSPICIOUS_ELSE_FORMATTING_INFO,\n+    crate::formatting::SUSPICIOUS_UNARY_OP_FORMATTING_INFO,\n+    crate::from_over_into::FROM_OVER_INTO_INFO,\n+    crate::from_raw_with_void_ptr::FROM_RAW_WITH_VOID_PTR_INFO,\n+    crate::from_str_radix_10::FROM_STR_RADIX_10_INFO,\n+    crate::functions::DOUBLE_MUST_USE_INFO,\n+    crate::functions::MUST_USE_CANDIDATE_INFO,\n+    crate::functions::MUST_USE_UNIT_INFO,\n+    crate::functions::NOT_UNSAFE_PTR_ARG_DEREF_INFO,\n+    crate::functions::RESULT_LARGE_ERR_INFO,\n+    crate::functions::RESULT_UNIT_ERR_INFO,\n+    crate::functions::TOO_MANY_ARGUMENTS_INFO,\n+    crate::functions::TOO_MANY_LINES_INFO,\n+    crate::future_not_send::FUTURE_NOT_SEND_INFO,\n+    crate::if_let_mutex::IF_LET_MUTEX_INFO,\n+    crate::if_not_else::IF_NOT_ELSE_INFO,\n+    crate::if_then_some_else_none::IF_THEN_SOME_ELSE_NONE_INFO,\n+    crate::implicit_hasher::IMPLICIT_HASHER_INFO,\n+    crate::implicit_return::IMPLICIT_RETURN_INFO,\n+    crate::implicit_saturating_add::IMPLICIT_SATURATING_ADD_INFO,\n+    crate::implicit_saturating_sub::IMPLICIT_SATURATING_SUB_INFO,\n+    crate::inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR_INFO,\n+    crate::index_refutable_slice::INDEX_REFUTABLE_SLICE_INFO,\n+    crate::indexing_slicing::INDEXING_SLICING_INFO,\n+    crate::indexing_slicing::OUT_OF_BOUNDS_INDEXING_INFO,\n+    crate::infinite_iter::INFINITE_ITER_INFO,\n+    crate::infinite_iter::MAYBE_INFINITE_ITER_INFO,\n+    crate::inherent_impl::MULTIPLE_INHERENT_IMPL_INFO,\n+    crate::inherent_to_string::INHERENT_TO_STRING_INFO,\n+    crate::inherent_to_string::INHERENT_TO_STRING_SHADOW_DISPLAY_INFO,\n+    crate::init_numbered_fields::INIT_NUMBERED_FIELDS_INFO,\n+    crate::inline_fn_without_body::INLINE_FN_WITHOUT_BODY_INFO,\n+    crate::instant_subtraction::MANUAL_INSTANT_ELAPSED_INFO,\n+    crate::instant_subtraction::UNCHECKED_DURATION_SUBTRACTION_INFO,\n+    crate::int_plus_one::INT_PLUS_ONE_INFO,\n+    crate::invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS_INFO,\n+    crate::invalid_utf8_in_unchecked::INVALID_UTF8_IN_UNCHECKED_INFO,\n+    crate::items_after_statements::ITEMS_AFTER_STATEMENTS_INFO,\n+    crate::iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR_INFO,\n+    crate::large_const_arrays::LARGE_CONST_ARRAYS_INFO,\n+    crate::large_enum_variant::LARGE_ENUM_VARIANT_INFO,\n+    crate::large_include_file::LARGE_INCLUDE_FILE_INFO,\n+    crate::large_stack_arrays::LARGE_STACK_ARRAYS_INFO,\n+    crate::len_zero::COMPARISON_TO_EMPTY_INFO,\n+    crate::len_zero::LEN_WITHOUT_IS_EMPTY_INFO,\n+    crate::len_zero::LEN_ZERO_INFO,\n+    crate::let_if_seq::USELESS_LET_IF_SEQ_INFO,\n+    crate::let_underscore::LET_UNDERSCORE_FUTURE_INFO,\n+    crate::let_underscore::LET_UNDERSCORE_LOCK_INFO,\n+    crate::let_underscore::LET_UNDERSCORE_MUST_USE_INFO,\n+    crate::lifetimes::EXTRA_UNUSED_LIFETIMES_INFO,\n+    crate::lifetimes::NEEDLESS_LIFETIMES_INFO,\n+    crate::literal_representation::DECIMAL_LITERAL_REPRESENTATION_INFO,\n+    crate::literal_representation::INCONSISTENT_DIGIT_GROUPING_INFO,\n+    crate::literal_representation::LARGE_DIGIT_GROUPS_INFO,\n+    crate::literal_representation::MISTYPED_LITERAL_SUFFIXES_INFO,\n+    crate::literal_representation::UNREADABLE_LITERAL_INFO,\n+    crate::literal_representation::UNUSUAL_BYTE_GROUPINGS_INFO,\n+    crate::loops::EMPTY_LOOP_INFO,\n+    crate::loops::EXPLICIT_COUNTER_LOOP_INFO,\n+    crate::loops::EXPLICIT_INTO_ITER_LOOP_INFO,\n+    crate::loops::EXPLICIT_ITER_LOOP_INFO,\n+    crate::loops::FOR_KV_MAP_INFO,\n+    crate::loops::ITER_NEXT_LOOP_INFO,\n+    crate::loops::MANUAL_FIND_INFO,\n+    crate::loops::MANUAL_FLATTEN_INFO,\n+    crate::loops::MANUAL_MEMCPY_INFO,\n+    crate::loops::MISSING_SPIN_LOOP_INFO,\n+    crate::loops::MUT_RANGE_BOUND_INFO,\n+    crate::loops::NEEDLESS_RANGE_LOOP_INFO,\n+    crate::loops::NEVER_LOOP_INFO,\n+    crate::loops::SAME_ITEM_PUSH_INFO,\n+    crate::loops::SINGLE_ELEMENT_LOOP_INFO,\n+    crate::loops::WHILE_IMMUTABLE_CONDITION_INFO,\n+    crate::loops::WHILE_LET_LOOP_INFO,\n+    crate::loops::WHILE_LET_ON_ITERATOR_INFO,\n+    crate::macro_use::MACRO_USE_IMPORTS_INFO,\n+    crate::main_recursion::MAIN_RECURSION_INFO,\n+    crate::manual_assert::MANUAL_ASSERT_INFO,\n+    crate::manual_async_fn::MANUAL_ASYNC_FN_INFO,\n+    crate::manual_bits::MANUAL_BITS_INFO,\n+    crate::manual_clamp::MANUAL_CLAMP_INFO,\n+    crate::manual_is_ascii_check::MANUAL_IS_ASCII_CHECK_INFO,\n+    crate::manual_let_else::MANUAL_LET_ELSE_INFO,\n+    crate::manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE_INFO,\n+    crate::manual_rem_euclid::MANUAL_REM_EUCLID_INFO,\n+    crate::manual_retain::MANUAL_RETAIN_INFO,\n+    crate::manual_string_new::MANUAL_STRING_NEW_INFO,\n+    crate::manual_strip::MANUAL_STRIP_INFO,\n+    crate::map_unit_fn::OPTION_MAP_UNIT_FN_INFO,\n+    crate::map_unit_fn::RESULT_MAP_UNIT_FN_INFO,\n+    crate::match_result_ok::MATCH_RESULT_OK_INFO,\n+    crate::matches::COLLAPSIBLE_MATCH_INFO,\n+    crate::matches::INFALLIBLE_DESTRUCTURING_MATCH_INFO,\n+    crate::matches::MANUAL_FILTER_INFO,\n+    crate::matches::MANUAL_MAP_INFO,\n+    crate::matches::MANUAL_UNWRAP_OR_INFO,\n+    crate::matches::MATCH_AS_REF_INFO,\n+    crate::matches::MATCH_BOOL_INFO,\n+    crate::matches::MATCH_LIKE_MATCHES_MACRO_INFO,\n+    crate::matches::MATCH_ON_VEC_ITEMS_INFO,\n+    crate::matches::MATCH_OVERLAPPING_ARM_INFO,\n+    crate::matches::MATCH_REF_PATS_INFO,\n+    crate::matches::MATCH_SAME_ARMS_INFO,\n+    crate::matches::MATCH_SINGLE_BINDING_INFO,\n+    crate::matches::MATCH_STR_CASE_MISMATCH_INFO,\n+    crate::matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS_INFO,\n+    crate::matches::MATCH_WILD_ERR_ARM_INFO,\n+    crate::matches::NEEDLESS_MATCH_INFO,\n+    crate::matches::REDUNDANT_PATTERN_MATCHING_INFO,\n+    crate::matches::REST_PAT_IN_FULLY_BOUND_STRUCTS_INFO,\n+    crate::matches::SIGNIFICANT_DROP_IN_SCRUTINEE_INFO,\n+    crate::matches::SINGLE_MATCH_INFO,\n+    crate::matches::SINGLE_MATCH_ELSE_INFO,\n+    crate::matches::TRY_ERR_INFO,\n+    crate::matches::WILDCARD_ENUM_MATCH_ARM_INFO,\n+    crate::matches::WILDCARD_IN_OR_PATTERNS_INFO,\n+    crate::mem_forget::MEM_FORGET_INFO,\n+    crate::mem_replace::MEM_REPLACE_OPTION_WITH_NONE_INFO,\n+    crate::mem_replace::MEM_REPLACE_WITH_DEFAULT_INFO,\n+    crate::mem_replace::MEM_REPLACE_WITH_UNINIT_INFO,\n+    crate::methods::BIND_INSTEAD_OF_MAP_INFO,\n+    crate::methods::BYTES_COUNT_TO_LEN_INFO,\n+    crate::methods::BYTES_NTH_INFO,\n+    crate::methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS_INFO,\n+    crate::methods::CHARS_LAST_CMP_INFO,\n+    crate::methods::CHARS_NEXT_CMP_INFO,\n+    crate::methods::CLONED_INSTEAD_OF_COPIED_INFO,\n+    crate::methods::CLONE_DOUBLE_REF_INFO,\n+    crate::methods::CLONE_ON_COPY_INFO,\n+    crate::methods::CLONE_ON_REF_PTR_INFO,\n+    crate::methods::COLLAPSIBLE_STR_REPLACE_INFO,\n+    crate::methods::ERR_EXPECT_INFO,\n+    crate::methods::EXPECT_FUN_CALL_INFO,\n+    crate::methods::EXPECT_USED_INFO,\n+    crate::methods::EXTEND_WITH_DRAIN_INFO,\n+    crate::methods::FILETYPE_IS_FILE_INFO,\n+    crate::methods::FILTER_MAP_IDENTITY_INFO,\n+    crate::methods::FILTER_MAP_NEXT_INFO,\n+    crate::methods::FILTER_NEXT_INFO,\n+    crate::methods::FLAT_MAP_IDENTITY_INFO,\n+    crate::methods::FLAT_MAP_OPTION_INFO,\n+    crate::methods::FROM_ITER_INSTEAD_OF_COLLECT_INFO,\n+    crate::methods::GET_FIRST_INFO,\n+    crate::methods::GET_LAST_WITH_LEN_INFO,\n+    crate::methods::GET_UNWRAP_INFO,\n+    crate::methods::IMPLICIT_CLONE_INFO,\n+    crate::methods::INEFFICIENT_TO_STRING_INFO,\n+    crate::methods::INSPECT_FOR_EACH_INFO,\n+    crate::methods::INTO_ITER_ON_REF_INFO,\n+    crate::methods::IS_DIGIT_ASCII_RADIX_INFO,\n+    crate::methods::ITERATOR_STEP_BY_ZERO_INFO,\n+    crate::methods::ITER_CLONED_COLLECT_INFO,\n+    crate::methods::ITER_COUNT_INFO,\n+    crate::methods::ITER_KV_MAP_INFO,\n+    crate::methods::ITER_NEXT_SLICE_INFO,\n+    crate::methods::ITER_NTH_INFO,\n+    crate::methods::ITER_NTH_ZERO_INFO,\n+    crate::methods::ITER_ON_EMPTY_COLLECTIONS_INFO,\n+    crate::methods::ITER_ON_SINGLE_ITEMS_INFO,\n+    crate::methods::ITER_OVEREAGER_CLONED_INFO,\n+    crate::methods::ITER_SKIP_NEXT_INFO,\n+    crate::methods::ITER_WITH_DRAIN_INFO,\n+    crate::methods::MANUAL_FILTER_MAP_INFO,\n+    crate::methods::MANUAL_FIND_MAP_INFO,\n+    crate::methods::MANUAL_OK_OR_INFO,\n+    crate::methods::MANUAL_SATURATING_ARITHMETIC_INFO,\n+    crate::methods::MANUAL_SPLIT_ONCE_INFO,\n+    crate::methods::MANUAL_STR_REPEAT_INFO,\n+    crate::methods::MAP_CLONE_INFO,\n+    crate::methods::MAP_COLLECT_RESULT_UNIT_INFO,\n+    crate::methods::MAP_ERR_IGNORE_INFO,\n+    crate::methods::MAP_FLATTEN_INFO,\n+    crate::methods::MAP_IDENTITY_INFO,\n+    crate::methods::MAP_UNWRAP_OR_INFO,\n+    crate::methods::MUT_MUTEX_LOCK_INFO,\n+    crate::methods::NAIVE_BYTECOUNT_INFO,\n+    crate::methods::NEEDLESS_COLLECT_INFO,\n+    crate::methods::NEEDLESS_OPTION_AS_DEREF_INFO,\n+    crate::methods::NEEDLESS_OPTION_TAKE_INFO,\n+    crate::methods::NEEDLESS_SPLITN_INFO,\n+    crate::methods::NEW_RET_NO_SELF_INFO,\n+    crate::methods::NONSENSICAL_OPEN_OPTIONS_INFO,\n+    crate::methods::NO_EFFECT_REPLACE_INFO,\n+    crate::methods::OBFUSCATED_IF_ELSE_INFO,\n+    crate::methods::OK_EXPECT_INFO,\n+    crate::methods::OPTION_AS_REF_DEREF_INFO,\n+    crate::methods::OPTION_FILTER_MAP_INFO,\n+    crate::methods::OPTION_MAP_OR_NONE_INFO,\n+    crate::methods::OR_FUN_CALL_INFO,\n+    crate::methods::OR_THEN_UNWRAP_INFO,\n+    crate::methods::PATH_BUF_PUSH_OVERWRITE_INFO,\n+    crate::methods::RANGE_ZIP_WITH_LEN_INFO,\n+    crate::methods::REPEAT_ONCE_INFO,\n+    crate::methods::RESULT_MAP_OR_INTO_OPTION_INFO,\n+    crate::methods::SEARCH_IS_SOME_INFO,\n+    crate::methods::SEEK_FROM_CURRENT_INFO,\n+    crate::methods::SEEK_TO_START_INSTEAD_OF_REWIND_INFO,\n+    crate::methods::SHOULD_IMPLEMENT_TRAIT_INFO,\n+    crate::methods::SINGLE_CHAR_ADD_STR_INFO,\n+    crate::methods::SINGLE_CHAR_PATTERN_INFO,\n+    crate::methods::SKIP_WHILE_NEXT_INFO,\n+    crate::methods::STABLE_SORT_PRIMITIVE_INFO,\n+    crate::methods::STRING_EXTEND_CHARS_INFO,\n+    crate::methods::SUSPICIOUS_MAP_INFO,\n+    crate::methods::SUSPICIOUS_SPLITN_INFO,\n+    crate::methods::SUSPICIOUS_TO_OWNED_INFO,\n+    crate::methods::UNINIT_ASSUMED_INIT_INFO,\n+    crate::methods::UNIT_HASH_INFO,\n+    crate::methods::UNNECESSARY_FILTER_MAP_INFO,\n+    crate::methods::UNNECESSARY_FIND_MAP_INFO,\n+    crate::methods::UNNECESSARY_FOLD_INFO,\n+    crate::methods::UNNECESSARY_JOIN_INFO,\n+    crate::methods::UNNECESSARY_LAZY_EVALUATIONS_INFO,\n+    crate::methods::UNNECESSARY_SORT_BY_INFO,\n+    crate::methods::UNNECESSARY_TO_OWNED_INFO,\n+    crate::methods::UNWRAP_OR_ELSE_DEFAULT_INFO,\n+    crate::methods::UNWRAP_USED_INFO,\n+    crate::methods::USELESS_ASREF_INFO,\n+    crate::methods::VEC_RESIZE_TO_ZERO_INFO,\n+    crate::methods::VERBOSE_FILE_READS_INFO,\n+    crate::methods::WRONG_SELF_CONVENTION_INFO,\n+    crate::methods::ZST_OFFSET_INFO,\n+    crate::minmax::MIN_MAX_INFO,\n+    crate::misc::SHORT_CIRCUIT_STATEMENT_INFO,\n+    crate::misc::TOPLEVEL_REF_ARG_INFO,\n+    crate::misc::USED_UNDERSCORE_BINDING_INFO,\n+    crate::misc::ZERO_PTR_INFO,\n+    crate::misc_early::BUILTIN_TYPE_SHADOW_INFO,\n+    crate::misc_early::DOUBLE_NEG_INFO,\n+    crate::misc_early::DUPLICATE_UNDERSCORE_ARGUMENT_INFO,\n+    crate::misc_early::MIXED_CASE_HEX_LITERALS_INFO,\n+    crate::misc_early::REDUNDANT_PATTERN_INFO,\n+    crate::misc_early::SEPARATED_LITERAL_SUFFIX_INFO,\n+    crate::misc_early::UNNEEDED_FIELD_PATTERN_INFO,\n+    crate::misc_early::UNNEEDED_WILDCARD_PATTERN_INFO,\n+    crate::misc_early::UNSEPARATED_LITERAL_SUFFIX_INFO,\n+    crate::misc_early::ZERO_PREFIXED_LITERAL_INFO,\n+    crate::mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER_INFO,\n+    crate::missing_const_for_fn::MISSING_CONST_FOR_FN_INFO,\n+    crate::missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS_INFO,\n+    crate::missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES_INFO,\n+    crate::missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS_INFO,\n+    crate::missing_trait_methods::MISSING_TRAIT_METHODS_INFO,\n+    crate::mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION_INFO,\n+    crate::mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION_INFO,\n+    crate::module_style::MOD_MODULE_FILES_INFO,\n+    crate::module_style::SELF_NAMED_MODULE_FILES_INFO,\n+    crate::multi_assignments::MULTI_ASSIGNMENTS_INFO,\n+    crate::mut_key::MUTABLE_KEY_TYPE_INFO,\n+    crate::mut_mut::MUT_MUT_INFO,\n+    crate::mut_reference::UNNECESSARY_MUT_PASSED_INFO,\n+    crate::mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL_INFO,\n+    crate::mutex_atomic::MUTEX_ATOMIC_INFO,\n+    crate::mutex_atomic::MUTEX_INTEGER_INFO,\n+    crate::needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE_INFO,\n+    crate::needless_bool::BOOL_COMPARISON_INFO,\n+    crate::needless_bool::NEEDLESS_BOOL_INFO,\n+    crate::needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE_INFO,\n+    crate::needless_continue::NEEDLESS_CONTINUE_INFO,\n+    crate::needless_for_each::NEEDLESS_FOR_EACH_INFO,\n+    crate::needless_late_init::NEEDLESS_LATE_INIT_INFO,\n+    crate::needless_parens_on_range_literals::NEEDLESS_PARENS_ON_RANGE_LITERALS_INFO,\n+    crate::needless_pass_by_value::NEEDLESS_PASS_BY_VALUE_INFO,\n+    crate::needless_question_mark::NEEDLESS_QUESTION_MARK_INFO,\n+    crate::needless_update::NEEDLESS_UPDATE_INFO,\n+    crate::neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD_INFO,\n+    crate::neg_multiply::NEG_MULTIPLY_INFO,\n+    crate::new_without_default::NEW_WITHOUT_DEFAULT_INFO,\n+    crate::no_effect::NO_EFFECT_INFO,\n+    crate::no_effect::NO_EFFECT_UNDERSCORE_BINDING_INFO,\n+    crate::no_effect::UNNECESSARY_OPERATION_INFO,\n+    crate::non_copy_const::BORROW_INTERIOR_MUTABLE_CONST_INFO,\n+    crate::non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST_INFO,\n+    crate::non_expressive_names::JUST_UNDERSCORES_AND_DIGITS_INFO,\n+    crate::non_expressive_names::MANY_SINGLE_CHAR_NAMES_INFO,\n+    crate::non_expressive_names::SIMILAR_NAMES_INFO,\n+    crate::non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS_INFO,\n+    crate::non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY_INFO,\n+    crate::nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES_INFO,\n+    crate::octal_escapes::OCTAL_ESCAPES_INFO,\n+    crate::only_used_in_recursion::ONLY_USED_IN_RECURSION_INFO,\n+    crate::operators::ABSURD_EXTREME_COMPARISONS_INFO,\n+    crate::operators::ARITHMETIC_SIDE_EFFECTS_INFO,\n+    crate::operators::ASSIGN_OP_PATTERN_INFO,\n+    crate::operators::BAD_BIT_MASK_INFO,\n+    crate::operators::CMP_NAN_INFO,\n+    crate::operators::CMP_OWNED_INFO,\n+    crate::operators::DOUBLE_COMPARISONS_INFO,\n+    crate::operators::DURATION_SUBSEC_INFO,\n+    crate::operators::EQ_OP_INFO,\n+    crate::operators::ERASING_OP_INFO,\n+    crate::operators::FLOAT_ARITHMETIC_INFO,\n+    crate::operators::FLOAT_CMP_INFO,\n+    crate::operators::FLOAT_CMP_CONST_INFO,\n+    crate::operators::FLOAT_EQUALITY_WITHOUT_ABS_INFO,\n+    crate::operators::IDENTITY_OP_INFO,\n+    crate::operators::INEFFECTIVE_BIT_MASK_INFO,\n+    crate::operators::INTEGER_ARITHMETIC_INFO,\n+    crate::operators::INTEGER_DIVISION_INFO,\n+    crate::operators::MISREFACTORED_ASSIGN_OP_INFO,\n+    crate::operators::MODULO_ARITHMETIC_INFO,\n+    crate::operators::MODULO_ONE_INFO,\n+    crate::operators::NEEDLESS_BITWISE_BOOL_INFO,\n+    crate::operators::OP_REF_INFO,\n+    crate::operators::PTR_EQ_INFO,\n+    crate::operators::SELF_ASSIGNMENT_INFO,\n+    crate::operators::VERBOSE_BIT_MASK_INFO,\n+    crate::option_env_unwrap::OPTION_ENV_UNWRAP_INFO,\n+    crate::option_if_let_else::OPTION_IF_LET_ELSE_INFO,\n+    crate::overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL_INFO,\n+    crate::panic_in_result_fn::PANIC_IN_RESULT_FN_INFO,\n+    crate::panic_unimplemented::PANIC_INFO,\n+    crate::panic_unimplemented::TODO_INFO,\n+    crate::panic_unimplemented::UNIMPLEMENTED_INFO,\n+    crate::panic_unimplemented::UNREACHABLE_INFO,\n+    crate::partial_pub_fields::PARTIAL_PUB_FIELDS_INFO,\n+    crate::partialeq_ne_impl::PARTIALEQ_NE_IMPL_INFO,\n+    crate::partialeq_to_none::PARTIALEQ_TO_NONE_INFO,\n+    crate::pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE_INFO,\n+    crate::pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF_INFO,\n+    crate::pattern_type_mismatch::PATTERN_TYPE_MISMATCH_INFO,\n+    crate::precedence::PRECEDENCE_INFO,\n+    crate::ptr::CMP_NULL_INFO,\n+    crate::ptr::INVALID_NULL_PTR_USAGE_INFO,\n+    crate::ptr::MUT_FROM_REF_INFO,\n+    crate::ptr::PTR_ARG_INFO,\n+    crate::ptr_offset_with_cast::PTR_OFFSET_WITH_CAST_INFO,\n+    crate::pub_use::PUB_USE_INFO,\n+    crate::question_mark::QUESTION_MARK_INFO,\n+    crate::ranges::MANUAL_RANGE_CONTAINS_INFO,\n+    crate::ranges::RANGE_MINUS_ONE_INFO,\n+    crate::ranges::RANGE_PLUS_ONE_INFO,\n+    crate::ranges::REVERSED_EMPTY_RANGES_INFO,\n+    crate::rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT_INFO,\n+    crate::read_zero_byte_vec::READ_ZERO_BYTE_VEC_INFO,\n+    crate::redundant_clone::REDUNDANT_CLONE_INFO,\n+    crate::redundant_closure_call::REDUNDANT_CLOSURE_CALL_INFO,\n+    crate::redundant_else::REDUNDANT_ELSE_INFO,\n+    crate::redundant_field_names::REDUNDANT_FIELD_NAMES_INFO,\n+    crate::redundant_pub_crate::REDUNDANT_PUB_CRATE_INFO,\n+    crate::redundant_slicing::DEREF_BY_SLICING_INFO,\n+    crate::redundant_slicing::REDUNDANT_SLICING_INFO,\n+    crate::redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES_INFO,\n+    crate::ref_option_ref::REF_OPTION_REF_INFO,\n+    crate::reference::DEREF_ADDROF_INFO,\n+    crate::regex::INVALID_REGEX_INFO,\n+    crate::regex::TRIVIAL_REGEX_INFO,\n+    crate::return_self_not_must_use::RETURN_SELF_NOT_MUST_USE_INFO,\n+    crate::returns::LET_AND_RETURN_INFO,\n+    crate::returns::NEEDLESS_RETURN_INFO,\n+    crate::same_name_method::SAME_NAME_METHOD_INFO,\n+    crate::self_named_constructors::SELF_NAMED_CONSTRUCTORS_INFO,\n+    crate::semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED_INFO,\n+    crate::serde_api::SERDE_API_MISUSE_INFO,\n+    crate::shadow::SHADOW_REUSE_INFO,\n+    crate::shadow::SHADOW_SAME_INFO,\n+    crate::shadow::SHADOW_UNRELATED_INFO,\n+    crate::single_char_lifetime_names::SINGLE_CHAR_LIFETIME_NAMES_INFO,\n+    crate::single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS_INFO,\n+    crate::size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT_INFO,\n+    crate::slow_vector_initialization::SLOW_VECTOR_INITIALIZATION_INFO,\n+    crate::std_instead_of_core::ALLOC_INSTEAD_OF_CORE_INFO,\n+    crate::std_instead_of_core::STD_INSTEAD_OF_ALLOC_INFO,\n+    crate::std_instead_of_core::STD_INSTEAD_OF_CORE_INFO,\n+    crate::strings::STRING_ADD_INFO,\n+    crate::strings::STRING_ADD_ASSIGN_INFO,\n+    crate::strings::STRING_FROM_UTF8_AS_BYTES_INFO,\n+    crate::strings::STRING_LIT_AS_BYTES_INFO,\n+    crate::strings::STRING_SLICE_INFO,\n+    crate::strings::STRING_TO_STRING_INFO,\n+    crate::strings::STR_TO_STRING_INFO,\n+    crate::strings::TRIM_SPLIT_WHITESPACE_INFO,\n+    crate::strlen_on_c_strings::STRLEN_ON_C_STRINGS_INFO,\n+    crate::suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS_INFO,\n+    crate::suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL_INFO,\n+    crate::suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL_INFO,\n+    crate::suspicious_xor_used_as_pow::SUSPICIOUS_XOR_USED_AS_POW_INFO,\n+    crate::swap::ALMOST_SWAPPED_INFO,\n+    crate::swap::MANUAL_SWAP_INFO,\n+    crate::swap_ptr_to_ref::SWAP_PTR_TO_REF_INFO,\n+    crate::tabs_in_doc_comments::TABS_IN_DOC_COMMENTS_INFO,\n+    crate::temporary_assignment::TEMPORARY_ASSIGNMENT_INFO,\n+    crate::to_digit_is_some::TO_DIGIT_IS_SOME_INFO,\n+    crate::trailing_empty_array::TRAILING_EMPTY_ARRAY_INFO,\n+    crate::trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS_INFO,\n+    crate::trait_bounds::TYPE_REPETITION_IN_BOUNDS_INFO,\n+    crate::transmute::CROSSPOINTER_TRANSMUTE_INFO,\n+    crate::transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS_INFO,\n+    crate::transmute::TRANSMUTE_BYTES_TO_STR_INFO,\n+    crate::transmute::TRANSMUTE_FLOAT_TO_INT_INFO,\n+    crate::transmute::TRANSMUTE_INT_TO_BOOL_INFO,\n+    crate::transmute::TRANSMUTE_INT_TO_CHAR_INFO,\n+    crate::transmute::TRANSMUTE_INT_TO_FLOAT_INFO,\n+    crate::transmute::TRANSMUTE_NUM_TO_BYTES_INFO,\n+    crate::transmute::TRANSMUTE_PTR_TO_PTR_INFO,\n+    crate::transmute::TRANSMUTE_PTR_TO_REF_INFO,\n+    crate::transmute::TRANSMUTE_UNDEFINED_REPR_INFO,\n+    crate::transmute::TRANSMUTING_NULL_INFO,\n+    crate::transmute::UNSOUND_COLLECTION_TRANSMUTE_INFO,\n+    crate::transmute::USELESS_TRANSMUTE_INFO,\n+    crate::transmute::WRONG_TRANSMUTE_INFO,\n+    crate::types::BORROWED_BOX_INFO,\n+    crate::types::BOX_COLLECTION_INFO,\n+    crate::types::LINKEDLIST_INFO,\n+    crate::types::OPTION_OPTION_INFO,\n+    crate::types::RC_BUFFER_INFO,\n+    crate::types::RC_MUTEX_INFO,\n+    crate::types::REDUNDANT_ALLOCATION_INFO,\n+    crate::types::TYPE_COMPLEXITY_INFO,\n+    crate::types::VEC_BOX_INFO,\n+    crate::undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS_INFO,\n+    crate::unicode::INVISIBLE_CHARACTERS_INFO,\n+    crate::unicode::NON_ASCII_LITERAL_INFO,\n+    crate::unicode::UNICODE_NOT_NFC_INFO,\n+    crate::uninit_vec::UNINIT_VEC_INFO,\n+    crate::unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD_INFO,\n+    crate::unit_types::LET_UNIT_VALUE_INFO,\n+    crate::unit_types::UNIT_ARG_INFO,\n+    crate::unit_types::UNIT_CMP_INFO,\n+    crate::unnamed_address::FN_ADDRESS_COMPARISONS_INFO,\n+    crate::unnamed_address::VTABLE_ADDRESS_COMPARISONS_INFO,\n+    crate::unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS_INFO,\n+    crate::unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS_INFO,\n+    crate::unnecessary_wraps::UNNECESSARY_WRAPS_INFO,\n+    crate::unnested_or_patterns::UNNESTED_OR_PATTERNS_INFO,\n+    crate::unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME_INFO,\n+    crate::unused_async::UNUSED_ASYNC_INFO,\n+    crate::unused_io_amount::UNUSED_IO_AMOUNT_INFO,\n+    crate::unused_peekable::UNUSED_PEEKABLE_INFO,\n+    crate::unused_rounding::UNUSED_ROUNDING_INFO,\n+    crate::unused_self::UNUSED_SELF_INFO,\n+    crate::unused_unit::UNUSED_UNIT_INFO,\n+    crate::unwrap::PANICKING_UNWRAP_INFO,\n+    crate::unwrap::UNNECESSARY_UNWRAP_INFO,\n+    crate::unwrap_in_result::UNWRAP_IN_RESULT_INFO,\n+    crate::upper_case_acronyms::UPPER_CASE_ACRONYMS_INFO,\n+    crate::use_self::USE_SELF_INFO,\n+    crate::useless_conversion::USELESS_CONVERSION_INFO,\n+    crate::vec::USELESS_VEC_INFO,\n+    crate::vec_init_then_push::VEC_INIT_THEN_PUSH_INFO,\n+    crate::wildcard_imports::ENUM_GLOB_USE_INFO,\n+    crate::wildcard_imports::WILDCARD_IMPORTS_INFO,\n+    crate::write::PRINTLN_EMPTY_STRING_INFO,\n+    crate::write::PRINT_LITERAL_INFO,\n+    crate::write::PRINT_STDERR_INFO,\n+    crate::write::PRINT_STDOUT_INFO,\n+    crate::write::PRINT_WITH_NEWLINE_INFO,\n+    crate::write::USE_DEBUG_INFO,\n+    crate::write::WRITELN_EMPTY_STRING_INFO,\n+    crate::write::WRITE_LITERAL_INFO,\n+    crate::write::WRITE_WITH_NEWLINE_INFO,\n+    crate::zero_div_zero::ZERO_DIVIDED_BY_ZERO_INFO,\n+    crate::zero_sized_map_values::ZERO_SIZED_MAP_VALUES_INFO,\n+];"}, {"sha": "9da64ffc13e169d93faae6c153f15c4845a80883", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 96, "deletions": 32, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -9,6 +9,7 @@ use clippy_utils::{\n };\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::graph::iterate::{CycleDetector, TriColorDepthFirstSearch};\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n@@ -274,9 +275,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing<'tcx> {\n         }\n \n         let typeck = cx.typeck_results();\n-        let (kind, sub_expr) = if let Some(x) = try_parse_ref_op(cx.tcx, typeck, expr) {\n-            x\n-        } else {\n+        let Some((kind, sub_expr)) = try_parse_ref_op(cx.tcx, typeck, expr) else {\n             // The whole chain of reference operations has been seen\n             if let Some((state, data)) = self.state.take() {\n                 report(cx, expr, state, data);\n@@ -806,30 +805,39 @@ fn walk_parents<'tcx>(\n                     .position(|arg| arg.hir_id == child_id)\n                     .zip(expr_sig(cx, func))\n                     .and_then(|(i, sig)| {\n-                        sig.input_with_hir(i).map(|(hir_ty, ty)| match hir_ty {\n-                            // Type inference for closures can depend on how they're called. Only go by the explicit\n-                            // types here.\n-                            Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n-                            None => {\n-                                if let ty::Param(param_ty) = ty.skip_binder().kind() {\n-                                    needless_borrow_impl_arg_position(\n-                                        cx,\n-                                        possible_borrowers,\n-                                        parent,\n-                                        i,\n-                                        *param_ty,\n-                                        e,\n-                                        precedence,\n-                                        msrv,\n-                                    )\n-                                } else {\n-                                    ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n-                                        .position_for_arg()\n-                                }\n-                            },\n+                        sig.input_with_hir(i).map(|(hir_ty, ty)| {\n+                            match hir_ty {\n+                                // Type inference for closures can depend on how they're called. Only go by the explicit\n+                                // types here.\n+                                Some(hir_ty) => {\n+                                    binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars())\n+                                },\n+                                None => {\n+                                    // `e.hir_id == child_id` for https://github.com/rust-lang/rust-clippy/issues/9739\n+                                    // `!call_is_qualified(func)` for https://github.com/rust-lang/rust-clippy/issues/9782\n+                                    if e.hir_id == child_id\n+                                        && !call_is_qualified(func)\n+                                        && let ty::Param(param_ty) = ty.skip_binder().kind()\n+                                    {\n+                                        needless_borrow_impl_arg_position(\n+                                            cx,\n+                                            possible_borrowers,\n+                                            parent,\n+                                            i,\n+                                            *param_ty,\n+                                            e,\n+                                            precedence,\n+                                            msrv,\n+                                        )\n+                                    } else {\n+                                        ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n+                                            .position_for_arg()\n+                                    }\n+                                },\n+                            }\n                         })\n                     }),\n-                ExprKind::MethodCall(_, receiver, args, _) => {\n+                ExprKind::MethodCall(method, receiver, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n                     if receiver.hir_id == child_id {\n                         // Check for calls to trait methods where the trait is implemented on a reference.\n@@ -867,7 +875,9 @@ fn walk_parents<'tcx>(\n                     }\n                     args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n                         let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n-                        if let ty::Param(param_ty) = ty.kind() {\n+                        // `e.hir_id == child_id` for https://github.com/rust-lang/rust-clippy/issues/9739\n+                        // `method.args.is_none()` for https://github.com/rust-lang/rust-clippy/issues/9782\n+                        if e.hir_id == child_id && method.args.is_none() && let ty::Param(param_ty) = ty.kind() {\n                             needless_borrow_impl_arg_position(\n                                 cx,\n                                 possible_borrowers,\n@@ -1045,13 +1055,25 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n     v.0\n }\n \n+fn call_is_qualified(expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Path(path) = &expr.kind {\n+        match path {\n+            QPath::Resolved(_, path) => path.segments.last().map_or(false, |segment| segment.args.is_some()),\n+            QPath::TypeRelative(_, segment) => segment.args.is_some(),\n+            QPath::LangItem(..) => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n // Checks whether:\n // * child is an expression of the form `&e` in an argument position requiring an `impl Trait`\n // * `e`'s type implements `Trait` and is copyable\n // If the conditions are met, returns `Some(Position::ImplArg(..))`; otherwise, returns `None`.\n //   The \"is copyable\" condition is to avoid the case where removing the `&` means `e` would have to\n // be moved, but it cannot be.\n-#[expect(clippy::too_many_arguments)]\n+#[expect(clippy::too_many_arguments, clippy::too_many_lines)]\n fn needless_borrow_impl_arg_position<'tcx>(\n     cx: &LateContext<'tcx>,\n     possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n@@ -1113,6 +1135,16 @@ fn needless_borrow_impl_arg_position<'tcx>(\n         return Position::Other(precedence);\n     }\n \n+    // See:\n+    // - https://github.com/rust-lang/rust-clippy/pull/9674#issuecomment-1289294201\n+    // - https://github.com/rust-lang/rust-clippy/pull/9674#issuecomment-1292225232\n+    if projection_predicates\n+        .iter()\n+        .any(|projection_predicate| is_mixed_projection_predicate(cx, callee_def_id, projection_predicate))\n+    {\n+        return Position::Other(precedence);\n+    }\n+\n     // `substs_with_referent_ty` can be constructed outside of `check_referent` because the same\n     // elements are modified each time `check_referent` is called.\n     let mut substs_with_referent_ty = substs_with_expr_ty.to_vec();\n@@ -1192,6 +1224,37 @@ fn has_ref_mut_self_method(cx: &LateContext<'_>, trait_def_id: DefId) -> bool {\n         })\n }\n \n+fn is_mixed_projection_predicate<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    callee_def_id: DefId,\n+    projection_predicate: &ProjectionPredicate<'tcx>,\n+) -> bool {\n+    let generics = cx.tcx.generics_of(callee_def_id);\n+    // The predicate requires the projected type to equal a type parameter from the parent context.\n+    if let Some(term_ty) = projection_predicate.term.ty()\n+        && let ty::Param(term_param_ty) = term_ty.kind()\n+        && (term_param_ty.index as usize) < generics.parent_count\n+    {\n+        // The inner-most self type is a type parameter from the current function.\n+        let mut projection_ty = projection_predicate.projection_ty;\n+        loop {\n+            match projection_ty.self_ty().kind() {\n+                ty::Projection(inner_projection_ty) => {\n+                    projection_ty = *inner_projection_ty;\n+                }\n+                ty::Param(param_ty) => {\n+                    return (param_ty.index as usize) >= generics.parent_count;\n+                }\n+                _ => {\n+                    return false;\n+                }\n+            }\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n fn referent_used_exactly_once<'tcx>(\n     cx: &LateContext<'tcx>,\n     possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n@@ -1203,6 +1266,8 @@ fn referent_used_exactly_once<'tcx>(\n         && let Some(statement) = mir.basic_blocks[location.block].statements.get(location.statement_index)\n         && let StatementKind::Assign(box (_, Rvalue::Ref(_, _, place))) = statement.kind\n         && !place.has_deref()\n+        // Ensure not in a loop (https://github.com/rust-lang/rust-clippy/issues/9710)\n+        && TriColorDepthFirstSearch::new(&mir.basic_blocks).run_from(location.block, &mut CycleDetector).is_none()\n     {\n         let body_owner_local_def_id = cx.tcx.hir().enclosing_body_owner(reference.hir_id);\n         if possible_borrowers\n@@ -1320,6 +1385,7 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n                 continue;\n             },\n             ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Projection(_) if ty.has_non_region_param() => TyPosition::new_deref_stable_for_result(precedence, ty),\n             ty::Infer(_) | ty::Error(_) | ty::Bound(..) | ty::Opaque(..) | ty::Placeholder(_) | ty::Dynamic(..) => {\n                 Position::ReborrowStable(precedence).into()\n             },\n@@ -1346,11 +1412,9 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             | ty::Closure(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Projection(_) => Position::DerefStable(\n-                precedence,\n-                ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n-            )\n-            .into(),\n+            | ty::Projection(_) => {\n+                Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds())).into()\n+            },\n         };\n     }\n }"}, {"sha": "68122b4cef577fede678085f08f58baa9181cbe1", "filename": "src/tools/clippy/clippy_lints/src/disallowed_macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_macros.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::macros::macro_backtrace;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::DefIdMap;\n use rustc_hir::{Expr, ForeignItem, HirId, ImplItem, Item, Pat, Path, Stmt, TraitItem, Ty};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -89,7 +88,7 @@ impl DisallowedMacros {\n                     &format!(\"use of a disallowed macro `{}`\", conf.path()),\n                     |diag| {\n                         if let Some(reason) = conf.reason() {\n-                            diag.note(&format!(\"{reason} (from clippy.toml)\"));\n+                            diag.note(reason);\n                         }\n                     },\n                 );\n@@ -104,7 +103,7 @@ impl LateLintPass<'_> for DisallowedMacros {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::MacroNS)) {\n+            for id in clippy_utils::def_path_def_ids(cx, &segs) {\n                 self.disallowed.insert(id, index);\n             }\n         }"}, {"sha": "ca8671c8f1aa0ea94dcc678433d9b08b3bf2d83d", "filename": "src/tools/clippy/clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{fn_def_id, get_parent_expr, path_def_id};\n \n-use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::DefIdMap;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -79,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, Some(Namespace::ValueNS)) {\n+            for id in clippy_utils::def_path_def_ids(cx, &segs) {\n                 self.disallowed.insert(id, index);\n             }\n         }\n@@ -104,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n         let msg = format!(\"use of a disallowed method `{}`\", conf.path());\n         span_lint_and_then(cx, DISALLOWED_METHODS, expr.span, &msg, |diag| {\n             if let Some(reason) = conf.reason() {\n-                diag.note(&format!(\"{reason} (from clippy.toml)\"));\n+                diag.note(reason);\n             }\n         });\n     }"}, {"sha": "aee3d8c4f08527234f622a6ea81dc6f551a9920f", "filename": "src/tools/clippy/clippy_lints/src/disallowed_types.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def::{Namespace, Res};\n+use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Item, ItemKind, PolyTraitRef, PrimTy, Ty, TyKind, UseKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -53,8 +53,8 @@ declare_clippy_lint! {\n #[derive(Clone, Debug)]\n pub struct DisallowedTypes {\n     conf_disallowed: Vec<conf::DisallowedPath>,\n-    def_ids: FxHashMap<DefId, Option<String>>,\n-    prim_tys: FxHashMap<PrimTy, Option<String>>,\n+    def_ids: FxHashMap<DefId, usize>,\n+    prim_tys: FxHashMap<PrimTy, usize>,\n }\n \n impl DisallowedTypes {\n@@ -69,13 +69,13 @@ impl DisallowedTypes {\n     fn check_res_emit(&self, cx: &LateContext<'_>, res: &Res, span: Span) {\n         match res {\n             Res::Def(_, did) => {\n-                if let Some(reason) = self.def_ids.get(did) {\n-                    emit(cx, &cx.tcx.def_path_str(*did), span, reason.as_deref());\n+                if let Some(&index) = self.def_ids.get(did) {\n+                    emit(cx, &cx.tcx.def_path_str(*did), span, &self.conf_disallowed[index]);\n                 }\n             },\n             Res::PrimTy(prim) => {\n-                if let Some(reason) = self.prim_tys.get(prim) {\n-                    emit(cx, prim.name_str(), span, reason.as_deref());\n+                if let Some(&index) = self.prim_tys.get(prim) {\n+                    emit(cx, prim.name_str(), span, &self.conf_disallowed[index]);\n                 }\n             },\n             _ => {},\n@@ -87,17 +87,19 @@ impl_lint_pass!(DisallowedTypes => [DISALLOWED_TYPES]);\n \n impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        for conf in &self.conf_disallowed {\n+        for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            let reason = conf.reason().map(|reason| format!(\"{reason} (from clippy.toml)\"));\n-            match clippy_utils::def_path_res(cx, &segs, Some(Namespace::TypeNS)) {\n-                Res::Def(_, id) => {\n-                    self.def_ids.insert(id, reason);\n-                },\n-                Res::PrimTy(ty) => {\n-                    self.prim_tys.insert(ty, reason);\n-                },\n-                _ => {},\n+\n+            for res in clippy_utils::def_path_res(cx, &segs) {\n+                match res {\n+                    Res::Def(_, id) => {\n+                        self.def_ids.insert(id, index);\n+                    },\n+                    Res::PrimTy(ty) => {\n+                        self.prim_tys.insert(ty, index);\n+                    },\n+                    _ => {},\n+                }\n             }\n         }\n     }\n@@ -119,14 +121,14 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n     }\n }\n \n-fn emit(cx: &LateContext<'_>, name: &str, span: Span, reason: Option<&str>) {\n+fn emit(cx: &LateContext<'_>, name: &str, span: Span, conf: &conf::DisallowedPath) {\n     span_lint_and_then(\n         cx,\n         DISALLOWED_TYPES,\n         span,\n         &format!(\"`{name}` is not allowed according to config\"),\n         |diag| {\n-            if let Some(reason) = reason {\n+            if let Some(reason) = conf.reason() {\n                 diag.note(reason);\n             }\n         },"}, {"sha": "4557e43288542eac8e232f059e0257039ce27ddd", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 76, "deletions": 47, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::token::CommentKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::EmitterWriter;\n-use rustc_errors::{Applicability, Handler, MultiSpan, SuggestionStyle};\n+use rustc_errors::{Applicability, Handler, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AnonConst, Expr};\n@@ -221,6 +221,42 @@ declare_clippy_lint! {\n     \"possible typo for an intra-doc link\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the doc comments of publicly visible\n+    /// safe functions and traits and warns if there is a `# Safety` section.\n+    ///\n+    /// ### Why is this bad?\n+    /// Safe functions and traits are safe to implement and therefore do not\n+    /// need to describe safety preconditions that users are required to uphold.\n+    ///\n+    /// ### Examples\n+    /// ```rust\n+    ///# type Universe = ();\n+    /// /// # Safety\n+    /// ///\n+    /// /// This function should not be called before the horsemen are ready.\n+    /// pub fn start_apocalypse_but_safely(u: &mut Universe) {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    ///\n+    /// The function is safe, so there shouldn't be any preconditions\n+    /// that have to be explained for safety reasons.\n+    ///\n+    /// ```rust\n+    ///# type Universe = ();\n+    /// /// This function should really be documented\n+    /// pub fn start_apocalypse(u: &mut Universe) {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub UNNECESSARY_SAFETY_DOC,\n+    style,\n+    \"`pub fn` or `pub trait` with `# Safety` docs\"\n+}\n+\n #[expect(clippy::module_name_repetitions)]\n #[derive(Clone)]\n pub struct DocMarkdown {\n@@ -243,7 +279,8 @@ impl_lint_pass!(DocMarkdown => [\n     MISSING_SAFETY_DOC,\n     MISSING_ERRORS_DOC,\n     MISSING_PANICS_DOC,\n-    NEEDLESS_DOCTEST_MAIN\n+    NEEDLESS_DOCTEST_MAIN,\n+    UNNECESSARY_SAFETY_DOC,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n@@ -254,7 +291,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let headers = check_attrs(cx, &self.valid_idents, attrs);\n+        let Some(headers) = check_attrs(cx, &self.valid_idents, attrs) else { return };\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, _, body_id) => {\n                 if !(is_entrypoint_fn(cx, item.owner_id.to_def_id()) || in_external_macro(cx.tcx.sess, item.span)) {\n@@ -265,29 +302,26 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(body.value);\n-                    lint_for_missing_headers(\n-                        cx,\n-                        item.owner_id.def_id,\n-                        item.span,\n-                        sig,\n-                        headers,\n-                        Some(body_id),\n-                        fpu.panic_span,\n-                    );\n+                    lint_for_missing_headers(cx, item.owner_id.def_id, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n             hir::ItemKind::Impl(impl_) => {\n                 self.in_trait_impl = impl_.of_trait.is_some();\n             },\n-            hir::ItemKind::Trait(_, unsafety, ..) => {\n-                if !headers.safety && unsafety == hir::Unsafety::Unsafe {\n-                    span_lint(\n-                        cx,\n-                        MISSING_SAFETY_DOC,\n-                        item.span,\n-                        \"docs for unsafe trait missing `# Safety` section\",\n-                    );\n-                }\n+            hir::ItemKind::Trait(_, unsafety, ..) => match (headers.safety, unsafety) {\n+                (false, hir::Unsafety::Unsafe) => span_lint(\n+                    cx,\n+                    MISSING_SAFETY_DOC,\n+                    cx.tcx.def_span(item.owner_id),\n+                    \"docs for unsafe trait missing `# Safety` section\",\n+                ),\n+                (true, hir::Unsafety::Normal) => span_lint(\n+                    cx,\n+                    UNNECESSARY_SAFETY_DOC,\n+                    cx.tcx.def_span(item.owner_id),\n+                    \"docs for safe trait have unnecessary `# Safety` section\",\n+                ),\n+                _ => (),\n             },\n             _ => (),\n         }\n@@ -301,17 +335,17 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let headers = check_attrs(cx, &self.valid_idents, attrs);\n+        let Some(headers) = check_attrs(cx, &self.valid_idents, attrs) else { return };\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             if !in_external_macro(cx.tcx.sess, item.span) {\n-                lint_for_missing_headers(cx, item.owner_id.def_id, item.span, sig, headers, None, None);\n+                lint_for_missing_headers(cx, item.owner_id.def_id, sig, headers, None, None);\n             }\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let headers = check_attrs(cx, &self.valid_idents, attrs);\n+        let Some(headers) = check_attrs(cx, &self.valid_idents, attrs) else { return };\n         if self.in_trait_impl || in_external_macro(cx.tcx.sess, item.span) {\n             return;\n         }\n@@ -323,23 +357,14 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                 panic_span: None,\n             };\n             fpu.visit_expr(body.value);\n-            lint_for_missing_headers(\n-                cx,\n-                item.owner_id.def_id,\n-                item.span,\n-                sig,\n-                headers,\n-                Some(body_id),\n-                fpu.panic_span,\n-            );\n+            lint_for_missing_headers(cx, item.owner_id.def_id, sig, headers, Some(body_id), fpu.panic_span);\n         }\n     }\n }\n \n-fn lint_for_missing_headers<'tcx>(\n-    cx: &LateContext<'tcx>,\n+fn lint_for_missing_headers(\n+    cx: &LateContext<'_>,\n     def_id: LocalDefId,\n-    span: impl Into<MultiSpan> + Copy,\n     sig: &hir::FnSig<'_>,\n     headers: DocHeaders,\n     body_id: Option<hir::BodyId>,\n@@ -359,13 +384,21 @@ fn lint_for_missing_headers<'tcx>(\n         return;\n     }\n \n-    if !headers.safety && sig.header.unsafety == hir::Unsafety::Unsafe {\n-        span_lint(\n+    let span = cx.tcx.def_span(def_id);\n+    match (headers.safety, sig.header.unsafety) {\n+        (false, hir::Unsafety::Unsafe) => span_lint(\n             cx,\n             MISSING_SAFETY_DOC,\n             span,\n             \"unsafe function's docs miss `# Safety` section\",\n-        );\n+        ),\n+        (true, hir::Unsafety::Normal) => span_lint(\n+            cx,\n+            UNNECESSARY_SAFETY_DOC,\n+            span,\n+            \"safe function's docs have unnecessary `# Safety` section\",\n+        ),\n+        _ => (),\n     }\n     if !headers.panics && panic_span.is_some() {\n         span_lint_and_note(\n@@ -467,7 +500,7 @@ struct DocHeaders {\n     panics: bool,\n }\n \n-fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs: &'a [Attribute]) -> DocHeaders {\n+fn check_attrs(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs: &[Attribute]) -> Option<DocHeaders> {\n     use pulldown_cmark::{BrokenLink, CowStr, Options};\n     /// We don't want the parser to choke on intra doc links. Since we don't\n     /// actually care about rendering them, just pretend that all broken links are\n@@ -488,11 +521,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n         } else if attr.has_name(sym::doc) {\n             // ignore mix of sugared and non-sugared doc\n             // don't trigger the safety or errors check\n-            return DocHeaders {\n-                safety: true,\n-                errors: true,\n-                panics: true,\n-            };\n+            return None;\n         }\n     }\n \n@@ -504,7 +533,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n     }\n \n     if doc.is_empty() {\n-        return DocHeaders::default();\n+        return Some(DocHeaders::default());\n     }\n \n     let mut cb = fake_broken_link_callback;\n@@ -527,7 +556,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n             (previous, current) => Err(((previous, previous_range), (current, current_range))),\n         }\n     });\n-    check_doc(cx, valid_idents, events, &spans)\n+    Some(check_doc(cx, valid_idents, events, &spans))\n }\n \n const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\"];"}, {"sha": "b77b5621b4c68be05a7fef4177687bbb13e823e4", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -250,7 +250,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n         let item_name = item.ident.name.as_str();\n         let item_camel = to_camel_case(item_name);\n         if !item.span.from_expansion() && is_present_in_source(cx, item.span) {\n-            if let Some(&(ref mod_name, ref mod_camel)) = self.modules.last() {\n+            if let Some((mod_name, mod_camel)) = self.modules.last() {\n                 // constants don't have surrounding modules\n                 if !mod_camel.is_empty() {\n                     if mod_name == &item.ident.name {"}, {"sha": "c691e6c5402d4808fc4b0be6ec2bc2079b5c1f41", "filename": "src/tools/clippy/clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::implements_trait;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -67,16 +66,14 @@ fn is_structural_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: T\n \n impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Let(let_expr) = expr.kind;\n-            if unary_pattern(let_expr.pat);\n+        if !in_external_macro(cx.sess(), expr.span)\n+            && let ExprKind::Let(let_expr) = expr.kind\n+            && unary_pattern(let_expr.pat) {\n             let exp_ty = cx.typeck_results().expr_ty(let_expr.init);\n             let pat_ty = cx.typeck_results().pat_ty(let_expr.pat);\n-            if is_structural_partial_eq(cx, exp_ty, pat_ty);\n-            then {\n+            let mut applicability = Applicability::MachineApplicable;\n \n-                let mut applicability = Applicability::MachineApplicable;\n+            if is_structural_partial_eq(cx, exp_ty, pat_ty) {\n                 let pat_str = match let_expr.pat.kind {\n                     PatKind::Struct(..) => format!(\n                         \"({})\",\n@@ -96,6 +93,20 @@ impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n                     ),\n                     applicability,\n                 );\n+            } else {\n+                span_lint_and_sugg(\n+                    cx,\n+                    EQUATABLE_IF_LET,\n+                    expr.span,\n+                    \"this pattern matching can be expressed using `matches!`\",\n+                    \"try\",\n+                    format!(\n+                        \"matches!({}, {})\",\n+                        snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                        snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                    ),\n+                    applicability,\n+                );\n             }\n         }\n     }"}, {"sha": "1d09adec12f3ffe7bdf58bb5785dc947aa86f0f9", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -176,13 +176,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {\n-    }\n+    fn fake_read(&mut self, _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {"}, {"sha": "fc2912f696e0384baa554564d683d4ba23f80fcd", "filename": "src/tools/clippy/clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 68, "deletions": 61, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,8 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use rustc_ast::ast::{AssocItemKind, Extern, Fn, FnSig, Impl, Item, ItemKind, Trait, Ty, TyKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use clippy_utils::{get_parent_as_impl, has_repr_attr, is_bool};\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, FnDecl, HirId, Item, ItemKind, TraitFn, TraitItem, TraitItemKind, Ty};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n+use rustc_target::spec::abi::Abi;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -83,6 +86,12 @@ pub struct ExcessiveBools {\n     max_fn_params_bools: u64,\n }\n \n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+enum Kind {\n+    Struct,\n+    Fn,\n+}\n+\n impl ExcessiveBools {\n     #[must_use]\n     pub fn new(max_struct_bools: u64, max_fn_params_bools: u64) -> Self {\n@@ -92,21 +101,20 @@ impl ExcessiveBools {\n         }\n     }\n \n-    fn check_fn_sig(&self, cx: &EarlyContext<'_>, fn_sig: &FnSig, span: Span) {\n-        match fn_sig.header.ext {\n-            Extern::Implicit(_) | Extern::Explicit(_, _) => return,\n-            Extern::None => (),\n+    fn too_many_bools<'tcx>(&self, tys: impl Iterator<Item = &'tcx Ty<'tcx>>, kind: Kind) -> bool {\n+        if let Ok(bools) = tys.filter(|ty| is_bool(ty)).count().try_into() {\n+            (if Kind::Fn == kind {\n+                self.max_fn_params_bools\n+            } else {\n+                self.max_struct_bools\n+            }) < bools\n+        } else {\n+            false\n         }\n+    }\n \n-        let fn_sig_bools = fn_sig\n-            .decl\n-            .inputs\n-            .iter()\n-            .filter(|param| is_bool_ty(&param.ty))\n-            .count()\n-            .try_into()\n-            .unwrap();\n-        if self.max_fn_params_bools < fn_sig_bools {\n+    fn check_fn_sig(&self, cx: &LateContext<'_>, fn_decl: &FnDecl<'_>, span: Span) {\n+        if !span.from_expansion() && self.too_many_bools(fn_decl.inputs.iter(), Kind::Fn) {\n             span_lint_and_help(\n                 cx,\n                 FN_PARAMS_EXCESSIVE_BOOLS,\n@@ -121,56 +129,55 @@ impl ExcessiveBools {\n \n impl_lint_pass!(ExcessiveBools => [STRUCT_EXCESSIVE_BOOLS, FN_PARAMS_EXCESSIVE_BOOLS]);\n \n-fn is_bool_ty(ty: &Ty) -> bool {\n-    if let TyKind::Path(None, path) = &ty.kind {\n-        if let [name] = path.segments.as_slice() {\n-            return name.ident.name == sym::bool;\n+impl<'tcx> LateLintPass<'tcx> for ExcessiveBools {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if item.span.from_expansion() {\n+            return;\n+        }\n+        if let ItemKind::Struct(variant_data, _) = &item.kind {\n+            if has_repr_attr(cx, item.hir_id()) {\n+                return;\n+            }\n+\n+            if self.too_many_bools(variant_data.fields().iter().map(|field| field.ty), Kind::Struct) {\n+                span_lint_and_help(\n+                    cx,\n+                    STRUCT_EXCESSIVE_BOOLS,\n+                    item.span,\n+                    &format!(\"more than {} bools in a struct\", self.max_struct_bools),\n+                    None,\n+                    \"consider using a state machine or refactoring bools into two-variant enums\",\n+                );\n+            }\n         }\n     }\n-    false\n-}\n \n-impl EarlyLintPass for ExcessiveBools {\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if item.span.from_expansion() {\n-            return;\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx TraitItem<'tcx>) {\n+        // functions with a body are already checked by `check_fn`\n+        if let TraitItemKind::Fn(fn_sig, TraitFn::Required(_)) = &trait_item.kind\n+            && fn_sig.header.abi == Abi::Rust\n+            {\n+            self.check_fn_sig(cx, fn_sig.decl, fn_sig.span);\n         }\n-        match &item.kind {\n-            ItemKind::Struct(variant_data, _) => {\n-                if item.attrs.iter().any(|attr| attr.has_name(sym::repr)) {\n-                    return;\n-                }\n+    }\n \n-                let struct_bools = variant_data\n-                    .fields()\n-                    .iter()\n-                    .filter(|field| is_bool_ty(&field.ty))\n-                    .count()\n-                    .try_into()\n-                    .unwrap();\n-                if self.max_struct_bools < struct_bools {\n-                    span_lint_and_help(\n-                        cx,\n-                        STRUCT_EXCESSIVE_BOOLS,\n-                        item.span,\n-                        &format!(\"more than {} bools in a struct\", self.max_struct_bools),\n-                        None,\n-                        \"consider using a state machine or refactoring bools into two-variant enums\",\n-                    );\n-                }\n-            },\n-            ItemKind::Impl(box Impl {\n-                of_trait: None, items, ..\n-            })\n-            | ItemKind::Trait(box Trait { items, .. }) => {\n-                for item in items {\n-                    if let AssocItemKind::Fn(box Fn { sig, .. }) = &item.kind {\n-                        self.check_fn_sig(cx, sig, item.span);\n-                    }\n-                }\n-            },\n-            ItemKind::Fn(box Fn { sig, .. }) => self.check_fn_sig(cx, sig, item.span),\n-            _ => (),\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        fn_kind: FnKind<'tcx>,\n+        fn_decl: &'tcx FnDecl<'tcx>,\n+        _: &'tcx Body<'tcx>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if let Some(fn_header) = fn_kind.header()\n+            && fn_header.abi == Abi::Rust\n+            && get_parent_as_impl(cx.tcx, hir_id)\n+                .map_or(true,\n+                    |impl_item| impl_item.of_trait.is_none()\n+                )\n+            {\n+            self.check_fn_sig(cx, fn_decl, span);\n         }\n     }\n }"}, {"sha": "9a1058470e18e6155af9a4c5a1ee711dde9553da", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n     }\n }\n \n-fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[hir::ImplItemRef]) {\n+fn lint_impl_body(cx: &LateContext<'_>, impl_span: Span, impl_items: &[hir::ImplItemRef]) {\n     use rustc_hir::intravisit::{self, Visitor};\n     use rustc_hir::{Expr, ImplItemKind};\n "}, {"sha": "00f5ba56496ecd5486a2c395f3d28a4fdcf2e6a6", "filename": "src/tools/clippy/clippy_lints/src/from_raw_with_void_ptr.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_raw_with_void_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_raw_with_void_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_raw_with_void_ptr.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,77 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_c_void;\n+use clippy_utils::{match_def_path, path_def_id, paths};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::RawPtr;\n+use rustc_middle::ty::TypeAndMut;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks if we're passing a `c_void` raw pointer to `{Box,Rc,Arc,Weak}::from_raw(_)`\n+    ///\n+    /// ### Why is this bad?\n+    /// When dealing with `c_void` raw pointers in FFI, it is easy to run into the pitfall of calling `from_raw` with the `c_void` pointer.\n+    /// The type signature of `Box::from_raw` is `fn from_raw(raw: *mut T) -> Box<T>`, so if you pass a `*mut c_void` you will get a `Box<c_void>` (and similarly for `Rc`, `Arc` and `Weak`).\n+    /// For this to be safe, `c_void` would need to have the same memory layout as the original type, which is often not the case.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::ffi::c_void;\n+    /// let ptr = Box::into_raw(Box::new(42usize)) as *mut c_void;\n+    /// let _ = unsafe { Box::from_raw(ptr) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::ffi::c_void;\n+    /// # let ptr = Box::into_raw(Box::new(42usize)) as *mut c_void;\n+    /// let _ = unsafe { Box::from_raw(ptr as *mut usize) };\n+    /// ```\n+    ///\n+    #[clippy::version = \"1.66.0\"]\n+    pub FROM_RAW_WITH_VOID_PTR,\n+    suspicious,\n+    \"creating a `Box` from a void raw pointer\"\n+}\n+declare_lint_pass!(FromRawWithVoidPtr => [FROM_RAW_WITH_VOID_PTR]);\n+\n+impl LateLintPass<'_> for FromRawWithVoidPtr {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if let ExprKind::Call(box_from_raw, [arg]) = expr.kind\n+        && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = box_from_raw.kind\n+        && seg.ident.name == sym!(from_raw)\n+        && let Some(type_str) = path_def_id(cx, ty).and_then(|id| def_id_matches_type(cx, id))\n+        && let arg_kind = cx.typeck_results().expr_ty(arg).kind()\n+        && let RawPtr(TypeAndMut { ty, .. }) = arg_kind\n+        && is_c_void(cx, *ty) {\n+            let msg = format!(\"creating a `{type_str}` from a void raw pointer\");\n+            span_lint_and_help(cx, FROM_RAW_WITH_VOID_PTR, expr.span, &msg, Some(arg.span), \"cast this to a pointer of the appropriate type\");\n+        }\n+    }\n+}\n+\n+/// Checks whether a `DefId` matches `Box`, `Rc`, `Arc`, or one of the `Weak` types.\n+/// Returns a static string slice with the name of the type, if one was found.\n+fn def_id_matches_type(cx: &LateContext<'_>, def_id: DefId) -> Option<&'static str> {\n+    // Box\n+    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n+        return Some(\"Box\");\n+    }\n+\n+    if let Some(symbol) = cx.tcx.get_diagnostic_name(def_id) {\n+        if symbol == sym::Arc {\n+            return Some(\"Arc\");\n+        } else if symbol == sym::Rc {\n+            return Some(\"Rc\");\n+        }\n+    }\n+\n+    if match_def_path(cx, def_id, &paths::WEAK_RC) || match_def_path(cx, def_id, &paths::WEAK_ARC) {\n+        Some(\"Weak\")\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "ae0e08334463803dbfce17b707bdbbab3fda0773", "filename": "src/tools/clippy/clippy_lints/src/functions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -254,7 +254,7 @@ declare_clippy_lint! {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[clippy::version = \"1.64.0\"]\n+    #[clippy::version = \"1.65.0\"]\n     pub RESULT_LARGE_ERR,\n     perf,\n     \"function returning `Result` with large `Err` type\""}, {"sha": "d22bede36b419944b372f84594dd294b926442e1", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -50,7 +50,9 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n+        } else if is_public\n+            && !is_proc_macro(cx.sess(), attrs)\n+            && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n         {\n             check_must_use_candidate(\n                 cx,\n@@ -175,15 +177,15 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut DefIdSet)\n         return false; // ignore `_` patterns\n     }\n     if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n-        is_mutable_ty(cx, cx.tcx.typeck(pat.hir_id.owner.def_id).pat_ty(pat), pat.span, tys)\n+        is_mutable_ty(cx, cx.tcx.typeck(pat.hir_id.owner.def_id).pat_ty(pat), tys)\n     } else {\n         false\n     }\n }\n \n static KNOWN_WRAPPER_TYS: &[Symbol] = &[sym::Rc, sym::Arc];\n \n-fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut DefIdSet) -> bool {\n+fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, tys: &mut DefIdSet) -> bool {\n     match *ty.kind() {\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n@@ -192,12 +194,12 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n                 || KNOWN_WRAPPER_TYS\n                     .iter()\n                     .any(|&sym| cx.tcx.is_diagnostic_item(sym, adt.did()))\n-                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n+                    && substs.types().any(|ty| is_mutable_ty(cx, ty, tys))\n         },\n-        ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n-        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n+        ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, tys)),\n+        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, tys),\n         ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n-            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n+            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, tys)\n         },\n         // calling something constitutes a side effect, so return true on all callables\n         // also never calls need not be used, so return true for them, too\n@@ -225,12 +227,7 @@ fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bo\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n                     if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n-                        && is_mutable_ty(\n-                            cx,\n-                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n-                            arg.span,\n-                            &mut tys,\n-                        )\n+                        && is_mutable_ty(cx, cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg), &mut tys)\n                         && is_mutated_static(arg)\n                     {\n                         return ControlFlow::Break(());\n@@ -243,12 +240,7 @@ fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bo\n                 let mut tys = DefIdSet::default();\n                 for arg in std::iter::once(receiver).chain(args.iter()) {\n                     if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n-                        && is_mutable_ty(\n-                            cx,\n-                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n-                            arg.span,\n-                            &mut tys,\n-                        )\n+                        && is_mutable_ty(cx, cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg), &mut tys)\n                         && is_mutated_static(arg)\n                     {\n                         return ControlFlow::Break(());"}, {"sha": "f7e30b051a694a84d6be001e103f067a804d58b7", "filename": "src/tools/clippy/clippy_lints/src/functions/result.rs", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -2,12 +2,12 @@ use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Adt, Ty};\n use rustc_span::{sym, Span};\n \n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n-use clippy_utils::ty::{approx_ty_size, is_type_diagnostic_item};\n+use clippy_utils::ty::{approx_ty_size, is_type_diagnostic_item, AdtVariantInfo};\n \n use super::{RESULT_LARGE_ERR, RESULT_UNIT_ERR};\n \n@@ -84,17 +84,57 @@ fn check_result_unit_err(cx: &LateContext<'_>, err_ty: Ty<'_>, fn_header_span: S\n }\n \n fn check_result_large_err<'tcx>(cx: &LateContext<'tcx>, err_ty: Ty<'tcx>, hir_ty_span: Span, large_err_threshold: u64) {\n-    let ty_size = approx_ty_size(cx, err_ty);\n-    if ty_size >= large_err_threshold {\n-        span_lint_and_then(\n-            cx,\n-            RESULT_LARGE_ERR,\n-            hir_ty_span,\n-            \"the `Err`-variant returned from this function is very large\",\n-            |diag: &mut Diagnostic| {\n-                diag.span_label(hir_ty_span, format!(\"the `Err`-variant is at least {ty_size} bytes\"));\n-                diag.help(format!(\"try reducing the size of `{err_ty}`, for example by boxing large elements or replacing it with `Box<{err_ty}>`\"));\n-            },\n-        );\n+    if_chain! {\n+        if let Adt(adt, subst) = err_ty.kind();\n+        if let Some(local_def_id) = err_ty.ty_adt_def().expect(\"already checked this is adt\").did().as_local();\n+        if let Some(hir::Node::Item(item)) = cx\n+            .tcx\n+            .hir()\n+            .find_by_def_id(local_def_id);\n+        if let hir::ItemKind::Enum(ref def, _) = item.kind;\n+        then {\n+            let variants_size = AdtVariantInfo::new(cx, *adt, subst);\n+            if variants_size[0].size >= large_err_threshold {\n+                span_lint_and_then(\n+                    cx,\n+                    RESULT_LARGE_ERR,\n+                    hir_ty_span,\n+                    \"the `Err`-variant returned from this function is very large\",\n+                    |diag| {\n+                        diag.span_label(\n+                            def.variants[variants_size[0].ind].span,\n+                            format!(\"the largest variant contains at least {} bytes\", variants_size[0].size),\n+                        );\n+\n+                        for variant in &variants_size[1..] {\n+                            if variant.size >= large_err_threshold {\n+                                let variant_def = &def.variants[variant.ind];\n+                                diag.span_label(\n+                                    variant_def.span,\n+                                    format!(\"the variant `{}` contains at least {} bytes\", variant_def.ident, variant.size),\n+                                );\n+                            }\n+                        }\n+\n+                        diag.help(format!(\"try reducing the size of `{err_ty}`, for example by boxing large elements or replacing it with `Box<{err_ty}>`\"));\n+                    }\n+                );\n+            }\n+        }\n+        else {\n+            let ty_size = approx_ty_size(cx, err_ty);\n+            if ty_size >= large_err_threshold {\n+                span_lint_and_then(\n+                    cx,\n+                    RESULT_LARGE_ERR,\n+                    hir_ty_span,\n+                    \"the `Err`-variant returned from this function is very large\",\n+                    |diag: &mut Diagnostic| {\n+                        diag.span_label(hir_ty_span, format!(\"the `Err`-variant is at least {ty_size} bytes\"));\n+                        diag.help(format!(\"try reducing the size of `{err_ty}`, for example by boxing large elements or replacing it with `Box<{err_ty}>`\"));\n+                    },\n+                );\n+            }\n+        }\n     }\n }"}, {"sha": "64a4a3fa741bca2e6af1c40663564a3d5c3e1f83", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -66,8 +66,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         use rustc_span::BytePos;\n \n-        fn suggestion<'tcx>(\n-            cx: &LateContext<'tcx>,\n+        fn suggestion(\n+            cx: &LateContext<'_>,\n             diag: &mut Diagnostic,\n             generics_span: Span,\n             generics_suggestion_span: Span,"}, {"sha": "0d5099bde6de015b5aa069e5bdeb6611afd9d471", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -207,8 +207,8 @@ impl SliceLintInformation {\n     }\n }\n \n-fn filter_lintable_slices<'a, 'tcx>(\n-    cx: &'a LateContext<'tcx>,\n+fn filter_lintable_slices<'tcx>(\n+    cx: &LateContext<'tcx>,\n     slice_lint_info: FxIndexMap<hir::HirId, SliceLintInformation>,\n     max_suggested_slice: u64,\n     scope: &'tcx hir::Expr<'tcx>,"}, {"sha": "4cd7dff4cfd762c95352f230beb6b8b3f0652458", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -171,11 +171,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n \n /// Returns a tuple of options with the start and end (exclusive) values of\n /// the range. If the start or end is not constant, None is returned.\n-fn to_const_range<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    range: higher::Range<'_>,\n-    array_size: u128,\n-) -> (Option<u128>, Option<u128>) {\n+fn to_const_range(cx: &LateContext<'_>, range: higher::Range<'_>, array_size: u128) -> (Option<u128>, Option<u128>) {\n     let s = range\n         .start\n         .map(|expr| constant(cx, cx.typeck_results(), expr).map(|(c, _)| c));"}, {"sha": "60754b224fc840a8f21ff7b153f028f3b5f48ee0", "filename": "src/tools/clippy/clippy_lints/src/instant_subtraction.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finstant_subtraction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finstant_subtraction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finstant_subtraction.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,184 @@\n+use clippy_utils::{\n+    diagnostics::{self, span_lint_and_sugg},\n+    meets_msrv, msrvs, source,\n+    sugg::Sugg,\n+    ty,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{source_map::Spanned, sym};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Lints subtraction between `Instant::now()` and another `Instant`.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is easy to accidentally write `prev_instant - Instant::now()`, which will always be 0ns\n+    /// as `Instant` subtraction saturates.\n+    ///\n+    /// `prev_instant.elapsed()` also more clearly signals intention.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::time::Instant;\n+    /// let prev_instant = Instant::now();\n+    /// let duration = Instant::now() - prev_instant;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::time::Instant;\n+    /// let prev_instant = Instant::now();\n+    /// let duration = prev_instant.elapsed();\n+    /// ```\n+    #[clippy::version = \"1.65.0\"]\n+    pub MANUAL_INSTANT_ELAPSED,\n+    pedantic,\n+    \"subtraction between `Instant::now()` and previous `Instant`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Lints subtraction between an [`Instant`] and a [`Duration`].\n+    ///\n+    /// ### Why is this bad?\n+    /// Unchecked subtraction could cause underflow on certain platforms, leading to\n+    /// unintentional panics.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::time::{Instant, Duration};\n+    /// let time_passed = Instant::now() - Duration::from_secs(5);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::time::{Instant, Duration};\n+    /// let time_passed = Instant::now().checked_sub(Duration::from_secs(5));\n+    /// ```\n+    ///\n+    /// [`Duration`]: std::time::Duration\n+    /// [`Instant::now()`]: std::time::Instant::now;\n+    #[clippy::version = \"1.65.0\"]\n+    pub UNCHECKED_DURATION_SUBTRACTION,\n+    suspicious,\n+    \"finds unchecked subtraction of a 'Duration' from an 'Instant'\"\n+}\n+\n+pub struct InstantSubtraction {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl InstantSubtraction {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(InstantSubtraction => [MANUAL_INSTANT_ELAPSED, UNCHECKED_DURATION_SUBTRACTION]);\n+\n+impl LateLintPass<'_> for InstantSubtraction {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Sub, ..\n+            },\n+            lhs,\n+            rhs,\n+        ) = expr.kind\n+        {\n+            if_chain! {\n+                if is_instant_now_call(cx, lhs);\n+\n+                if is_an_instant(cx, rhs);\n+                if let Some(sugg) = Sugg::hir_opt(cx, rhs);\n+\n+                then {\n+                    print_manual_instant_elapsed_sugg(cx, expr, sugg)\n+                } else {\n+                    if_chain! {\n+                        if !expr.span.from_expansion();\n+                        if meets_msrv(self.msrv, msrvs::TRY_FROM);\n+\n+                        if is_an_instant(cx, lhs);\n+                        if is_a_duration(cx, rhs);\n+\n+                        then {\n+                            print_unchecked_duration_subtraction_sugg(cx, lhs, rhs, expr)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn is_instant_now_call(cx: &LateContext<'_>, expr_block: &'_ Expr<'_>) -> bool {\n+    if let ExprKind::Call(fn_expr, []) = expr_block.kind\n+        && let Some(fn_id) = clippy_utils::path_def_id(cx, fn_expr)\n+        && clippy_utils::match_def_path(cx, fn_id, &clippy_utils::paths::INSTANT_NOW)\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_an_instant(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let expr_ty = cx.typeck_results().expr_ty(expr);\n+\n+    match expr_ty.kind() {\n+        rustc_middle::ty::Adt(def, _) => clippy_utils::match_def_path(cx, def.did(), &clippy_utils::paths::INSTANT),\n+        _ => false,\n+    }\n+}\n+\n+fn is_a_duration(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let expr_ty = cx.typeck_results().expr_ty(expr);\n+    ty::is_type_diagnostic_item(cx, expr_ty, sym::Duration)\n+}\n+\n+fn print_manual_instant_elapsed_sugg(cx: &LateContext<'_>, expr: &Expr<'_>, sugg: Sugg<'_>) {\n+    span_lint_and_sugg(\n+        cx,\n+        MANUAL_INSTANT_ELAPSED,\n+        expr.span,\n+        \"manual implementation of `Instant::elapsed`\",\n+        \"try\",\n+        format!(\"{}.elapsed()\", sugg.maybe_par()),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn print_unchecked_duration_subtraction_sugg(\n+    cx: &LateContext<'_>,\n+    left_expr: &Expr<'_>,\n+    right_expr: &Expr<'_>,\n+    expr: &Expr<'_>,\n+) {\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    let left_expr =\n+        source::snippet_with_applicability(cx, left_expr.span, \"std::time::Instant::now()\", &mut applicability);\n+    let right_expr = source::snippet_with_applicability(\n+        cx,\n+        right_expr.span,\n+        \"std::time::Duration::from_secs(1)\",\n+        &mut applicability,\n+    );\n+\n+    diagnostics::span_lint_and_sugg(\n+        cx,\n+        UNCHECKED_DURATION_SUBTRACTION,\n+        expr.span,\n+        \"unchecked subtraction of a 'Duration' from an 'Instant'\",\n+        \"try\",\n+        format!(\"{left_expr}.checked_sub({right_expr}).unwrap()\"),\n+        applicability,\n+    );\n+}"}, {"sha": "1b14e525d9a84462dd3ed9e4daf24c455bcd0f97", "filename": "src/tools/clippy/clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -63,58 +63,54 @@ impl IntPlusOne {\n     fn check_binop(cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n         match (binop, &lhs.kind, &rhs.kind) {\n             // case where `x - 1 >= ...` or `-1 + x >= ...`\n-            (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n+            (BinOpKind::Ge, ExprKind::Binary(lhskind, lhslhs, lhsrhs), _) => {\n                 match (lhskind.node, &lhslhs.kind, &lhsrhs.kind) {\n                     // `-1 + x`\n-                    (BinOpKind::Add, &ExprKind::Lit(lit), _) if Self::check_lit(lit, -1) => {\n+                    (BinOpKind::Add, ExprKind::Lit(lit), _) if Self::check_lit(*lit, -1) => {\n                         Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::Lhs)\n                     },\n                     // `x - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n+                    (BinOpKind::Sub, _, ExprKind::Lit(lit)) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::Lhs)\n                     },\n                     _ => None,\n                 }\n             },\n             // case where `... >= y + 1` or `... >= 1 + y`\n-            (BinOpKind::Ge, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs))\n-                if rhskind.node == BinOpKind::Add =>\n-            {\n+            (BinOpKind::Ge, _, ExprKind::Binary(rhskind, rhslhs, rhsrhs)) if rhskind.node == BinOpKind::Add => {\n                 match (&rhslhs.kind, &rhsrhs.kind) {\n                     // `y + 1` and `1 + y`\n-                    (&ExprKind::Lit(lit), _) if Self::check_lit(lit, 1) => {\n+                    (ExprKind::Lit(lit), _) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::Rhs)\n                     },\n-                    (_, &ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n+                    (_, ExprKind::Lit(lit)) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::Rhs)\n                     },\n                     _ => None,\n                 }\n             },\n             // case where `x + 1 <= ...` or `1 + x <= ...`\n-            (BinOpKind::Le, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _)\n-                if lhskind.node == BinOpKind::Add =>\n-            {\n+            (BinOpKind::Le, ExprKind::Binary(lhskind, lhslhs, lhsrhs), _) if lhskind.node == BinOpKind::Add => {\n                 match (&lhslhs.kind, &lhsrhs.kind) {\n                     // `1 + x` and `x + 1`\n-                    (&ExprKind::Lit(lit), _) if Self::check_lit(lit, 1) => {\n+                    (ExprKind::Lit(lit), _) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::Lhs)\n                     },\n-                    (_, &ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n+                    (_, ExprKind::Lit(lit)) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::Lhs)\n                     },\n                     _ => None,\n                 }\n             },\n             // case where `... >= y - 1` or `... >= -1 + y`\n-            (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n+            (BinOpKind::Le, _, ExprKind::Binary(rhskind, rhslhs, rhsrhs)) => {\n                 match (rhskind.node, &rhslhs.kind, &rhsrhs.kind) {\n                     // `-1 + y`\n-                    (BinOpKind::Add, &ExprKind::Lit(lit), _) if Self::check_lit(lit, -1) => {\n+                    (BinOpKind::Add, ExprKind::Lit(lit), _) if Self::check_lit(*lit, -1) => {\n                         Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::Rhs)\n                     },\n                     // `y - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n+                    (BinOpKind::Sub, _, ExprKind::Lit(lit)) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::Rhs)\n                     },\n                     _ => None,"}, {"sha": "6ea637412d5b1b47eb655871a0ab252d135cd0e9", "filename": "src/tools/clippy/clippy_lints/src/invalid_upcast_comparisons.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -38,7 +38,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n \n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n+fn numeric_cast_precast_bounds(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<(FullInt, FullInt)> {\n     if let ExprKind::Cast(cast_exp, _) = expr.kind {\n         let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n         let cast_ty = cx.typeck_results().expr_ty(expr);"}, {"sha": "b18456ee523401759104bbb383178e7d87b5cb5c", "filename": "src/tools/clippy/clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,12 +1,15 @@\n //! lint when there is a large size difference between variants on an enum\n \n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{diagnostics::span_lint_and_then, ty::approx_ty_size, ty::is_copy};\n+use clippy_utils::{\n+    diagnostics::span_lint_and_then,\n+    ty::{approx_ty_size, is_copy, AdtVariantInfo},\n+};\n use rustc_errors::Applicability;\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{Adt, AdtDef, GenericArg, List, Ty};\n+use rustc_middle::ty::{Adt, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n \n@@ -72,49 +75,6 @@ impl LargeEnumVariant {\n     }\n }\n \n-struct FieldInfo {\n-    ind: usize,\n-    size: u64,\n-}\n-\n-struct VariantInfo {\n-    ind: usize,\n-    size: u64,\n-    fields_size: Vec<FieldInfo>,\n-}\n-\n-fn variants_size<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    adt: AdtDef<'tcx>,\n-    subst: &'tcx List<GenericArg<'tcx>>,\n-) -> Vec<VariantInfo> {\n-    let mut variants_size = adt\n-        .variants()\n-        .iter()\n-        .enumerate()\n-        .map(|(i, variant)| {\n-            let mut fields_size = variant\n-                .fields\n-                .iter()\n-                .enumerate()\n-                .map(|(i, f)| FieldInfo {\n-                    ind: i,\n-                    size: approx_ty_size(cx, f.ty(cx.tcx, subst)),\n-                })\n-                .collect::<Vec<_>>();\n-            fields_size.sort_by(|a, b| (a.size.cmp(&b.size)));\n-\n-            VariantInfo {\n-                ind: i,\n-                size: fields_size.iter().map(|info| info.size).sum(),\n-                fields_size,\n-            }\n-        })\n-        .collect::<Vec<_>>();\n-    variants_size.sort_by(|a, b| (b.size.cmp(&a.size)));\n-    variants_size\n-}\n-\n impl_lint_pass!(LargeEnumVariant => [LARGE_ENUM_VARIANT]);\n \n impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n@@ -130,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n             if adt.variants().len() <= 1 {\n                 return;\n             }\n-            let variants_size = variants_size(cx, *adt, subst);\n+            let variants_size = AdtVariantInfo::new(cx, *adt, subst);\n \n             let mut difference = variants_size[0].size - variants_size[1].size;\n             if difference > self.maximum_size_difference_allowed {\n@@ -173,16 +133,16 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n                                 .fields_size\n                                 .iter()\n                                 .rev()\n-                                .map_while(|val| {\n+                                .map_while(|&(ind, size)| {\n                                     if difference > self.maximum_size_difference_allowed {\n-                                        difference = difference.saturating_sub(val.size);\n+                                        difference = difference.saturating_sub(size);\n                                         Some((\n-                                            fields[val.ind].ty.span,\n+                                            fields[ind].ty.span,\n                                             format!(\n                                                 \"Box<{}>\",\n                                                 snippet_with_applicability(\n                                                     cx,\n-                                                    fields[val.ind].ty.span,\n+                                                    fields[ind].ty.span,\n                                                     \"..\",\n                                                     &mut applicability\n                                                 )"}, {"sha": "4c133c06a157ac9e0fcc6ce422bc1c2191404536", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -366,8 +366,7 @@ fn check_for_is_empty<'tcx>(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, receiver, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind)\n-    {\n+    if let (&ExprKind::MethodCall(method_path, receiver, args, _), ExprKind::Lit(lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {"}, {"sha": "61f87b91400d76405f8fcb914066040f49a9b4ff", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 68, "deletions": 89, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,13 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::{is_must_use_ty, is_type_diagnostic_item, match_type};\n+use clippy_utils::ty::{implements_trait, is_must_use_ty, match_type};\n use clippy_utils::{is_must_use_func_call, paths};\n-use if_chain::if_chain;\n use rustc_hir::{Local, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -30,13 +28,14 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.42.0\"]\n     pub LET_UNDERSCORE_MUST_USE,\n     restriction,\n-    \"non-binding let on a `#[must_use]` expression\"\n+    \"non-binding `let` on a `#[must_use]` expression\"\n }\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `let _ = sync_lock`.\n-    /// This supports `mutex` and `rwlock` in `std::sync` and `parking_lot`.\n+    /// Checks for `let _ = sync_lock`. This supports `mutex` and `rwlock` in\n+    /// `parking_lot`. For `std` locks see the `rustc` lint\n+    /// [`let_underscore_lock`](https://doc.rust-lang.org/nightly/rustc/lints/listing/deny-by-default.html#let-underscore-lock)\n     ///\n     /// ### Why is this bad?\n     /// This statement immediately drops the lock instead of\n@@ -57,50 +56,41 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.43.0\"]\n     pub LET_UNDERSCORE_LOCK,\n     correctness,\n-    \"non-binding let on a synchronization lock\"\n+    \"non-binding `let` on a synchronization lock\"\n }\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `let _ = <expr>`\n-    /// where expr has a type that implements `Drop`\n+    /// Checks for `let _ = <expr>` where the resulting type of expr implements `Future`\n     ///\n     /// ### Why is this bad?\n-    /// This statement immediately drops the initializer\n-    /// expression instead of extending its lifetime to the end of the scope, which\n-    /// is often not intended. To extend the expression's lifetime to the end of the\n-    /// scope, use an underscore-prefixed name instead (i.e. _var). If you want to\n-    /// explicitly drop the expression, `std::mem::drop` conveys your intention\n-    /// better and is less error-prone.\n+    /// Futures must be polled for work to be done. The original intention was most likely to await the future\n+    /// and ignore the resulting value.\n     ///\n     /// ### Example\n     /// ```rust\n-    /// # struct DroppableItem;\n-    /// {\n-    ///     let _ = DroppableItem;\n-    ///     //                   ^ dropped here\n-    ///     /* more code */\n+    /// async fn foo() -> Result<(), ()> {\n+    ///     Ok(())\n     /// }\n+    /// let _ = foo();\n     /// ```\n     ///\n     /// Use instead:\n     /// ```rust\n-    /// # struct DroppableItem;\n-    /// {\n-    ///     let _droppable = DroppableItem;\n-    ///     /* more code */\n-    ///     // dropped at end of scope\n+    /// # async fn context() {\n+    /// async fn foo() -> Result<(), ()> {\n+    ///     Ok(())\n     /// }\n+    /// let _ = foo().await;\n+    /// # }\n     /// ```\n-    #[clippy::version = \"1.50.0\"]\n-    pub LET_UNDERSCORE_DROP,\n-    pedantic,\n-    \"non-binding let on a type that implements `Drop`\"\n+    #[clippy::version = \"1.66\"]\n+    pub LET_UNDERSCORE_FUTURE,\n+    suspicious,\n+    \"non-binding `let` on a future\"\n }\n \n-declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK, LET_UNDERSCORE_DROP]);\n-\n-const SYNC_GUARD_SYMS: [Symbol; 3] = [sym::MutexGuard, sym::RwLockReadGuard, sym::RwLockWriteGuard];\n+declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK, LET_UNDERSCORE_FUTURE]);\n \n const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n     &paths::PARKING_LOT_MUTEX_GUARD,\n@@ -110,64 +100,53 @@ const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n \n impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n     fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n-        if in_external_macro(cx.tcx.sess, local.span) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let PatKind::Wild = local.pat.kind;\n-            if let Some(init) = local.init;\n-            then {\n-                let init_ty = cx.typeck_results().expr_ty(init);\n-                let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n-                    GenericArgKind::Type(inner_ty) => {\n-                        SYNC_GUARD_SYMS\n-                            .iter()\n-                            .any(|&sym| is_type_diagnostic_item(cx, inner_ty, sym))\n-                            || SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n-                    },\n-\n-                    GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n-                });\n-                if contains_sync_guard {\n-                    span_lint_and_help(\n-                        cx,\n-                        LET_UNDERSCORE_LOCK,\n-                        local.span,\n-                        \"non-binding let on a synchronization lock\",\n-                        None,\n-                        \"consider using an underscore-prefixed named \\\n-                            binding or dropping explicitly with `std::mem::drop`\",\n-                    );\n-                } else if init_ty.needs_drop(cx.tcx, cx.param_env) {\n-                    span_lint_and_help(\n-                        cx,\n-                        LET_UNDERSCORE_DROP,\n-                        local.span,\n-                        \"non-binding `let` on a type that implements `Drop`\",\n-                        None,\n-                        \"consider using an underscore-prefixed named \\\n+        if !in_external_macro(cx.tcx.sess, local.span)\n+            && let PatKind::Wild = local.pat.kind\n+            && let Some(init) = local.init\n+        {\n+            let init_ty = cx.typeck_results().expr_ty(init);\n+            let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n+                GenericArgKind::Type(inner_ty) => SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path)),\n+                GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+            });\n+            if contains_sync_guard {\n+                span_lint_and_help(\n+                    cx,\n+                    LET_UNDERSCORE_LOCK,\n+                    local.span,\n+                    \"non-binding `let` on a synchronization lock\",\n+                    None,\n+                    \"consider using an underscore-prefixed named \\\n                             binding or dropping explicitly with `std::mem::drop`\",\n-                    );\n-                } else if is_must_use_ty(cx, cx.typeck_results().expr_ty(init)) {\n-                    span_lint_and_help(\n-                        cx,\n-                        LET_UNDERSCORE_MUST_USE,\n-                        local.span,\n-                        \"non-binding let on an expression with `#[must_use]` type\",\n-                        None,\n-                        \"consider explicitly using expression value\",\n-                    );\n-                } else if is_must_use_func_call(cx, init) {\n-                    span_lint_and_help(\n-                        cx,\n-                        LET_UNDERSCORE_MUST_USE,\n-                        local.span,\n-                        \"non-binding let on a result of a `#[must_use]` function\",\n-                        None,\n-                        \"consider explicitly using function result\",\n-                    );\n-                }\n+                );\n+            } else if let Some(future_trait_def_id) = cx.tcx.lang_items().future_trait()\n+                && implements_trait(cx, cx.typeck_results().expr_ty(init), future_trait_def_id, &[]) {\n+                span_lint_and_help(\n+                    cx,\n+                    LET_UNDERSCORE_FUTURE,\n+                    local.span,\n+                    \"non-binding `let` on a future\",\n+                    None,\n+                    \"consider awaiting the future or dropping explicitly with `std::mem::drop`\"\n+                );\n+            } else if is_must_use_ty(cx, cx.typeck_results().expr_ty(init)) {\n+                span_lint_and_help(\n+                    cx,\n+                    LET_UNDERSCORE_MUST_USE,\n+                    local.span,\n+                    \"non-binding `let` on an expression with `#[must_use]` type\",\n+                    None,\n+                    \"consider explicitly using expression value\",\n+                );\n+            } else if is_must_use_func_call(cx, init) {\n+                span_lint_and_help(\n+                    cx,\n+                    LET_UNDERSCORE_MUST_USE,\n+                    local.span,\n+                    \"non-binding `let` on a result of a `#[must_use]` function\",\n+                    None,\n+                    \"consider explicitly using function result\",\n+                );\n             }\n         }\n     }"}, {"sha": "c455e1561b71648329a1899a87578a675d8a408d", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "removed", "additions": 0, "deletions": 368, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,368 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n-    LintId::of(almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE),\n-    LintId::of(approx_const::APPROX_CONSTANT),\n-    LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n-    LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n-    LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n-    LintId::of(attrs::DEPRECATED_CFG_ATTR),\n-    LintId::of(attrs::DEPRECATED_SEMVER),\n-    LintId::of(attrs::MISMATCHED_TARGET_OS),\n-    LintId::of(attrs::USELESS_ATTRIBUTE),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n-    LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n-    LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n-    LintId::of(bool_to_int_with_if::BOOL_TO_INT_WITH_IF),\n-    LintId::of(booleans::NONMINIMAL_BOOL),\n-    LintId::of(booleans::OVERLY_COMPLEX_BOOL_EXPR),\n-    LintId::of(borrow_deref_ref::BORROW_DEREF_REF),\n-    LintId::of(box_default::BOX_DEFAULT),\n-    LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n-    LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n-    LintId::of(casts::CAST_ENUM_TRUNCATION),\n-    LintId::of(casts::CAST_NAN_TO_INT),\n-    LintId::of(casts::CAST_REF_TO_MUT),\n-    LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n-    LintId::of(casts::CAST_SLICE_FROM_RAW_PARTS),\n-    LintId::of(casts::CHAR_LIT_AS_U8),\n-    LintId::of(casts::FN_TO_NUMERIC_CAST),\n-    LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n-    LintId::of(casts::UNNECESSARY_CAST),\n-    LintId::of(collapsible_if::COLLAPSIBLE_ELSE_IF),\n-    LintId::of(collapsible_if::COLLAPSIBLE_IF),\n-    LintId::of(comparison_chain::COMPARISON_CHAIN),\n-    LintId::of(copies::IFS_SAME_COND),\n-    LintId::of(copies::IF_SAME_THEN_ELSE),\n-    LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n-    LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n-    LintId::of(default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY),\n-    LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n-    LintId::of(dereference::NEEDLESS_BORROW),\n-    LintId::of(derivable_impls::DERIVABLE_IMPLS),\n-    LintId::of(derive::DERIVE_HASH_XOR_EQ),\n-    LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n-    LintId::of(disallowed_macros::DISALLOWED_MACROS),\n-    LintId::of(disallowed_methods::DISALLOWED_METHODS),\n-    LintId::of(disallowed_names::DISALLOWED_NAMES),\n-    LintId::of(disallowed_types::DISALLOWED_TYPES),\n-    LintId::of(doc::MISSING_SAFETY_DOC),\n-    LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n-    LintId::of(double_parens::DOUBLE_PARENS),\n-    LintId::of(drop_forget_ref::DROP_COPY),\n-    LintId::of(drop_forget_ref::DROP_NON_DROP),\n-    LintId::of(drop_forget_ref::DROP_REF),\n-    LintId::of(drop_forget_ref::FORGET_COPY),\n-    LintId::of(drop_forget_ref::FORGET_NON_DROP),\n-    LintId::of(drop_forget_ref::FORGET_REF),\n-    LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n-    LintId::of(duplicate_mod::DUPLICATE_MOD),\n-    LintId::of(entry::MAP_ENTRY),\n-    LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n-    LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n-    LintId::of(enum_variants::MODULE_INCEPTION),\n-    LintId::of(escape::BOXED_LOCAL),\n-    LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n-    LintId::of(explicit_write::EXPLICIT_WRITE),\n-    LintId::of(float_literal::EXCESSIVE_PRECISION),\n-    LintId::of(format::USELESS_FORMAT),\n-    LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n-    LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n-    LintId::of(format_args::UNUSED_FORMAT_SPECS),\n-    LintId::of(format_impl::PRINT_IN_FORMAT_IMPL),\n-    LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n-    LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n-    LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n-    LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n-    LintId::of(formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n-    LintId::of(from_over_into::FROM_OVER_INTO),\n-    LintId::of(from_str_radix_10::FROM_STR_RADIX_10),\n-    LintId::of(functions::DOUBLE_MUST_USE),\n-    LintId::of(functions::MUST_USE_UNIT),\n-    LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n-    LintId::of(functions::RESULT_LARGE_ERR),\n-    LintId::of(functions::RESULT_UNIT_ERR),\n-    LintId::of(functions::TOO_MANY_ARGUMENTS),\n-    LintId::of(if_let_mutex::IF_LET_MUTEX),\n-    LintId::of(implicit_saturating_add::IMPLICIT_SATURATING_ADD),\n-    LintId::of(implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n-    LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n-    LintId::of(infinite_iter::INFINITE_ITER),\n-    LintId::of(inherent_to_string::INHERENT_TO_STRING),\n-    LintId::of(inherent_to_string::INHERENT_TO_STRING_SHADOW_DISPLAY),\n-    LintId::of(init_numbered_fields::INIT_NUMBERED_FIELDS),\n-    LintId::of(inline_fn_without_body::INLINE_FN_WITHOUT_BODY),\n-    LintId::of(int_plus_one::INT_PLUS_ONE),\n-    LintId::of(invalid_utf8_in_unchecked::INVALID_UTF8_IN_UNCHECKED),\n-    LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n-    LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n-    LintId::of(len_zero::COMPARISON_TO_EMPTY),\n-    LintId::of(len_zero::LEN_WITHOUT_IS_EMPTY),\n-    LintId::of(len_zero::LEN_ZERO),\n-    LintId::of(let_underscore::LET_UNDERSCORE_LOCK),\n-    LintId::of(lifetimes::EXTRA_UNUSED_LIFETIMES),\n-    LintId::of(lifetimes::NEEDLESS_LIFETIMES),\n-    LintId::of(literal_representation::INCONSISTENT_DIGIT_GROUPING),\n-    LintId::of(literal_representation::MISTYPED_LITERAL_SUFFIXES),\n-    LintId::of(literal_representation::UNUSUAL_BYTE_GROUPINGS),\n-    LintId::of(loops::EMPTY_LOOP),\n-    LintId::of(loops::EXPLICIT_COUNTER_LOOP),\n-    LintId::of(loops::FOR_KV_MAP),\n-    LintId::of(loops::ITER_NEXT_LOOP),\n-    LintId::of(loops::MANUAL_FIND),\n-    LintId::of(loops::MANUAL_FLATTEN),\n-    LintId::of(loops::MANUAL_MEMCPY),\n-    LintId::of(loops::MISSING_SPIN_LOOP),\n-    LintId::of(loops::MUT_RANGE_BOUND),\n-    LintId::of(loops::NEEDLESS_COLLECT),\n-    LintId::of(loops::NEEDLESS_RANGE_LOOP),\n-    LintId::of(loops::NEVER_LOOP),\n-    LintId::of(loops::SAME_ITEM_PUSH),\n-    LintId::of(loops::SINGLE_ELEMENT_LOOP),\n-    LintId::of(loops::WHILE_IMMUTABLE_CONDITION),\n-    LintId::of(loops::WHILE_LET_LOOP),\n-    LintId::of(loops::WHILE_LET_ON_ITERATOR),\n-    LintId::of(main_recursion::MAIN_RECURSION),\n-    LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n-    LintId::of(manual_bits::MANUAL_BITS),\n-    LintId::of(manual_clamp::MANUAL_CLAMP),\n-    LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n-    LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n-    LintId::of(manual_retain::MANUAL_RETAIN),\n-    LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n-    LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n-    LintId::of(match_result_ok::MATCH_RESULT_OK),\n-    LintId::of(matches::COLLAPSIBLE_MATCH),\n-    LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n-    LintId::of(matches::MANUAL_FILTER),\n-    LintId::of(matches::MANUAL_MAP),\n-    LintId::of(matches::MANUAL_UNWRAP_OR),\n-    LintId::of(matches::MATCH_AS_REF),\n-    LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),\n-    LintId::of(matches::MATCH_OVERLAPPING_ARM),\n-    LintId::of(matches::MATCH_REF_PATS),\n-    LintId::of(matches::MATCH_SINGLE_BINDING),\n-    LintId::of(matches::MATCH_STR_CASE_MISMATCH),\n-    LintId::of(matches::NEEDLESS_MATCH),\n-    LintId::of(matches::REDUNDANT_PATTERN_MATCHING),\n-    LintId::of(matches::SINGLE_MATCH),\n-    LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n-    LintId::of(mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n-    LintId::of(mem_replace::MEM_REPLACE_WITH_DEFAULT),\n-    LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n-    LintId::of(methods::BIND_INSTEAD_OF_MAP),\n-    LintId::of(methods::BYTES_COUNT_TO_LEN),\n-    LintId::of(methods::BYTES_NTH),\n-    LintId::of(methods::CHARS_LAST_CMP),\n-    LintId::of(methods::CHARS_NEXT_CMP),\n-    LintId::of(methods::CLONE_DOUBLE_REF),\n-    LintId::of(methods::CLONE_ON_COPY),\n-    LintId::of(methods::COLLAPSIBLE_STR_REPLACE),\n-    LintId::of(methods::ERR_EXPECT),\n-    LintId::of(methods::EXPECT_FUN_CALL),\n-    LintId::of(methods::EXTEND_WITH_DRAIN),\n-    LintId::of(methods::FILTER_MAP_IDENTITY),\n-    LintId::of(methods::FILTER_NEXT),\n-    LintId::of(methods::FLAT_MAP_IDENTITY),\n-    LintId::of(methods::GET_FIRST),\n-    LintId::of(methods::GET_LAST_WITH_LEN),\n-    LintId::of(methods::INSPECT_FOR_EACH),\n-    LintId::of(methods::INTO_ITER_ON_REF),\n-    LintId::of(methods::IS_DIGIT_ASCII_RADIX),\n-    LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n-    LintId::of(methods::ITER_CLONED_COLLECT),\n-    LintId::of(methods::ITER_COUNT),\n-    LintId::of(methods::ITER_KV_MAP),\n-    LintId::of(methods::ITER_NEXT_SLICE),\n-    LintId::of(methods::ITER_NTH),\n-    LintId::of(methods::ITER_NTH_ZERO),\n-    LintId::of(methods::ITER_OVEREAGER_CLONED),\n-    LintId::of(methods::ITER_SKIP_NEXT),\n-    LintId::of(methods::MANUAL_FILTER_MAP),\n-    LintId::of(methods::MANUAL_FIND_MAP),\n-    LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n-    LintId::of(methods::MANUAL_SPLIT_ONCE),\n-    LintId::of(methods::MANUAL_STR_REPEAT),\n-    LintId::of(methods::MAP_CLONE),\n-    LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n-    LintId::of(methods::MAP_FLATTEN),\n-    LintId::of(methods::MAP_IDENTITY),\n-    LintId::of(methods::MUT_MUTEX_LOCK),\n-    LintId::of(methods::NEEDLESS_OPTION_AS_DEREF),\n-    LintId::of(methods::NEEDLESS_OPTION_TAKE),\n-    LintId::of(methods::NEEDLESS_SPLITN),\n-    LintId::of(methods::NEW_RET_NO_SELF),\n-    LintId::of(methods::NONSENSICAL_OPEN_OPTIONS),\n-    LintId::of(methods::NO_EFFECT_REPLACE),\n-    LintId::of(methods::OBFUSCATED_IF_ELSE),\n-    LintId::of(methods::OK_EXPECT),\n-    LintId::of(methods::OPTION_AS_REF_DEREF),\n-    LintId::of(methods::OPTION_FILTER_MAP),\n-    LintId::of(methods::OPTION_MAP_OR_NONE),\n-    LintId::of(methods::OR_FUN_CALL),\n-    LintId::of(methods::OR_THEN_UNWRAP),\n-    LintId::of(methods::RANGE_ZIP_WITH_LEN),\n-    LintId::of(methods::REPEAT_ONCE),\n-    LintId::of(methods::RESULT_MAP_OR_INTO_OPTION),\n-    LintId::of(methods::SEARCH_IS_SOME),\n-    LintId::of(methods::SHOULD_IMPLEMENT_TRAIT),\n-    LintId::of(methods::SINGLE_CHAR_ADD_STR),\n-    LintId::of(methods::SINGLE_CHAR_PATTERN),\n-    LintId::of(methods::SKIP_WHILE_NEXT),\n-    LintId::of(methods::STRING_EXTEND_CHARS),\n-    LintId::of(methods::SUSPICIOUS_MAP),\n-    LintId::of(methods::SUSPICIOUS_SPLITN),\n-    LintId::of(methods::SUSPICIOUS_TO_OWNED),\n-    LintId::of(methods::UNINIT_ASSUMED_INIT),\n-    LintId::of(methods::UNIT_HASH),\n-    LintId::of(methods::UNNECESSARY_FILTER_MAP),\n-    LintId::of(methods::UNNECESSARY_FIND_MAP),\n-    LintId::of(methods::UNNECESSARY_FOLD),\n-    LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n-    LintId::of(methods::UNNECESSARY_SORT_BY),\n-    LintId::of(methods::UNNECESSARY_TO_OWNED),\n-    LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n-    LintId::of(methods::USELESS_ASREF),\n-    LintId::of(methods::VEC_RESIZE_TO_ZERO),\n-    LintId::of(methods::WRONG_SELF_CONVENTION),\n-    LintId::of(methods::ZST_OFFSET),\n-    LintId::of(minmax::MIN_MAX),\n-    LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n-    LintId::of(misc::TOPLEVEL_REF_ARG),\n-    LintId::of(misc::ZERO_PTR),\n-    LintId::of(misc_early::BUILTIN_TYPE_SHADOW),\n-    LintId::of(misc_early::DOUBLE_NEG),\n-    LintId::of(misc_early::DUPLICATE_UNDERSCORE_ARGUMENT),\n-    LintId::of(misc_early::MIXED_CASE_HEX_LITERALS),\n-    LintId::of(misc_early::REDUNDANT_PATTERN),\n-    LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n-    LintId::of(misc_early::ZERO_PREFIXED_LITERAL),\n-    LintId::of(mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION),\n-    LintId::of(multi_assignments::MULTI_ASSIGNMENTS),\n-    LintId::of(mut_key::MUTABLE_KEY_TYPE),\n-    LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n-    LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n-    LintId::of(needless_bool::BOOL_COMPARISON),\n-    LintId::of(needless_bool::NEEDLESS_BOOL),\n-    LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n-    LintId::of(needless_late_init::NEEDLESS_LATE_INIT),\n-    LintId::of(needless_parens_on_range_literals::NEEDLESS_PARENS_ON_RANGE_LITERALS),\n-    LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n-    LintId::of(needless_update::NEEDLESS_UPDATE),\n-    LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n-    LintId::of(neg_multiply::NEG_MULTIPLY),\n-    LintId::of(new_without_default::NEW_WITHOUT_DEFAULT),\n-    LintId::of(no_effect::NO_EFFECT),\n-    LintId::of(no_effect::UNNECESSARY_OPERATION),\n-    LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n-    LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n-    LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n-    LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n-    LintId::of(octal_escapes::OCTAL_ESCAPES),\n-    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n-    LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n-    LintId::of(operators::ASSIGN_OP_PATTERN),\n-    LintId::of(operators::BAD_BIT_MASK),\n-    LintId::of(operators::CMP_NAN),\n-    LintId::of(operators::CMP_OWNED),\n-    LintId::of(operators::DOUBLE_COMPARISONS),\n-    LintId::of(operators::DURATION_SUBSEC),\n-    LintId::of(operators::EQ_OP),\n-    LintId::of(operators::ERASING_OP),\n-    LintId::of(operators::FLOAT_EQUALITY_WITHOUT_ABS),\n-    LintId::of(operators::IDENTITY_OP),\n-    LintId::of(operators::INEFFECTIVE_BIT_MASK),\n-    LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n-    LintId::of(operators::MODULO_ONE),\n-    LintId::of(operators::OP_REF),\n-    LintId::of(operators::PTR_EQ),\n-    LintId::of(operators::SELF_ASSIGNMENT),\n-    LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n-    LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n-    LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n-    LintId::of(partialeq_to_none::PARTIALEQ_TO_NONE),\n-    LintId::of(precedence::PRECEDENCE),\n-    LintId::of(ptr::CMP_NULL),\n-    LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n-    LintId::of(ptr::MUT_FROM_REF),\n-    LintId::of(ptr::PTR_ARG),\n-    LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n-    LintId::of(question_mark::QUESTION_MARK),\n-    LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n-    LintId::of(ranges::REVERSED_EMPTY_RANGES),\n-    LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n-    LintId::of(read_zero_byte_vec::READ_ZERO_BYTE_VEC),\n-    LintId::of(redundant_clone::REDUNDANT_CLONE),\n-    LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n-    LintId::of(redundant_field_names::REDUNDANT_FIELD_NAMES),\n-    LintId::of(redundant_slicing::REDUNDANT_SLICING),\n-    LintId::of(redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n-    LintId::of(reference::DEREF_ADDROF),\n-    LintId::of(regex::INVALID_REGEX),\n-    LintId::of(returns::LET_AND_RETURN),\n-    LintId::of(returns::NEEDLESS_RETURN),\n-    LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n-    LintId::of(serde_api::SERDE_API_MISUSE),\n-    LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n-    LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n-    LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n-    LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n-    LintId::of(strings::TRIM_SPLIT_WHITESPACE),\n-    LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n-    LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n-    LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n-    LintId::of(swap::ALMOST_SWAPPED),\n-    LintId::of(swap::MANUAL_SWAP),\n-    LintId::of(swap_ptr_to_ref::SWAP_PTR_TO_REF),\n-    LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n-    LintId::of(temporary_assignment::TEMPORARY_ASSIGNMENT),\n-    LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n-    LintId::of(transmute::CROSSPOINTER_TRANSMUTE),\n-    LintId::of(transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n-    LintId::of(transmute::TRANSMUTE_BYTES_TO_STR),\n-    LintId::of(transmute::TRANSMUTE_FLOAT_TO_INT),\n-    LintId::of(transmute::TRANSMUTE_INT_TO_BOOL),\n-    LintId::of(transmute::TRANSMUTE_INT_TO_CHAR),\n-    LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n-    LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n-    LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n-    LintId::of(transmute::TRANSMUTING_NULL),\n-    LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n-    LintId::of(transmute::USELESS_TRANSMUTE),\n-    LintId::of(transmute::WRONG_TRANSMUTE),\n-    LintId::of(types::BORROWED_BOX),\n-    LintId::of(types::BOX_COLLECTION),\n-    LintId::of(types::REDUNDANT_ALLOCATION),\n-    LintId::of(types::TYPE_COMPLEXITY),\n-    LintId::of(types::VEC_BOX),\n-    LintId::of(unicode::INVISIBLE_CHARACTERS),\n-    LintId::of(uninit_vec::UNINIT_VEC),\n-    LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n-    LintId::of(unit_types::LET_UNIT_VALUE),\n-    LintId::of(unit_types::UNIT_ARG),\n-    LintId::of(unit_types::UNIT_CMP),\n-    LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n-    LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n-    LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n-    LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n-    LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n-    LintId::of(unused_unit::UNUSED_UNIT),\n-    LintId::of(unwrap::PANICKING_UNWRAP),\n-    LintId::of(unwrap::UNNECESSARY_UNWRAP),\n-    LintId::of(upper_case_acronyms::UPPER_CASE_ACRONYMS),\n-    LintId::of(useless_conversion::USELESS_CONVERSION),\n-    LintId::of(vec::USELESS_VEC),\n-    LintId::of(vec_init_then_push::VEC_INIT_THEN_PUSH),\n-    LintId::of(write::PRINTLN_EMPTY_STRING),\n-    LintId::of(write::PRINT_LITERAL),\n-    LintId::of(write::PRINT_WITH_NEWLINE),\n-    LintId::of(write::WRITELN_EMPTY_STRING),\n-    LintId::of(write::WRITE_LITERAL),\n-    LintId::of(write::WRITE_WITH_NEWLINE),\n-    LintId::of(zero_div_zero::ZERO_DIVIDED_BY_ZERO),\n-])"}, {"sha": "c890523fe5aebc1808dba4de08d1d4956f2fca28", "filename": "src/tools/clippy/clippy_lints/src/lib.register_cargo.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_cargo.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,11 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), vec![\n-    LintId::of(cargo::CARGO_COMMON_METADATA),\n-    LintId::of(cargo::MULTIPLE_CRATE_VERSIONS),\n-    LintId::of(cargo::NEGATIVE_FEATURE_NAMES),\n-    LintId::of(cargo::REDUNDANT_FEATURE_NAMES),\n-    LintId::of(cargo::WILDCARD_DEPENDENCIES),\n-])"}, {"sha": "8be9dc4baf19360a6977a0a7aa118a612e8bde4b", "filename": "src/tools/clippy/clippy_lints/src/lib.register_complexity.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,111 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec![\n-    LintId::of(attrs::DEPRECATED_CFG_ATTR),\n-    LintId::of(booleans::NONMINIMAL_BOOL),\n-    LintId::of(borrow_deref_ref::BORROW_DEREF_REF),\n-    LintId::of(casts::CHAR_LIT_AS_U8),\n-    LintId::of(casts::UNNECESSARY_CAST),\n-    LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n-    LintId::of(derivable_impls::DERIVABLE_IMPLS),\n-    LintId::of(double_parens::DOUBLE_PARENS),\n-    LintId::of(explicit_write::EXPLICIT_WRITE),\n-    LintId::of(format::USELESS_FORMAT),\n-    LintId::of(format_args::UNUSED_FORMAT_SPECS),\n-    LintId::of(functions::TOO_MANY_ARGUMENTS),\n-    LintId::of(int_plus_one::INT_PLUS_ONE),\n-    LintId::of(lifetimes::EXTRA_UNUSED_LIFETIMES),\n-    LintId::of(lifetimes::NEEDLESS_LIFETIMES),\n-    LintId::of(loops::EXPLICIT_COUNTER_LOOP),\n-    LintId::of(loops::MANUAL_FIND),\n-    LintId::of(loops::MANUAL_FLATTEN),\n-    LintId::of(loops::SINGLE_ELEMENT_LOOP),\n-    LintId::of(loops::WHILE_LET_LOOP),\n-    LintId::of(manual_clamp::MANUAL_CLAMP),\n-    LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n-    LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n-    LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n-    LintId::of(matches::MANUAL_FILTER),\n-    LintId::of(matches::MANUAL_UNWRAP_OR),\n-    LintId::of(matches::MATCH_AS_REF),\n-    LintId::of(matches::MATCH_SINGLE_BINDING),\n-    LintId::of(matches::NEEDLESS_MATCH),\n-    LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n-    LintId::of(methods::BIND_INSTEAD_OF_MAP),\n-    LintId::of(methods::BYTES_COUNT_TO_LEN),\n-    LintId::of(methods::CLONE_ON_COPY),\n-    LintId::of(methods::FILTER_MAP_IDENTITY),\n-    LintId::of(methods::FILTER_NEXT),\n-    LintId::of(methods::FLAT_MAP_IDENTITY),\n-    LintId::of(methods::GET_LAST_WITH_LEN),\n-    LintId::of(methods::INSPECT_FOR_EACH),\n-    LintId::of(methods::ITER_COUNT),\n-    LintId::of(methods::ITER_KV_MAP),\n-    LintId::of(methods::MANUAL_FILTER_MAP),\n-    LintId::of(methods::MANUAL_FIND_MAP),\n-    LintId::of(methods::MANUAL_SPLIT_ONCE),\n-    LintId::of(methods::MAP_FLATTEN),\n-    LintId::of(methods::MAP_IDENTITY),\n-    LintId::of(methods::NEEDLESS_OPTION_AS_DEREF),\n-    LintId::of(methods::NEEDLESS_OPTION_TAKE),\n-    LintId::of(methods::NEEDLESS_SPLITN),\n-    LintId::of(methods::OPTION_AS_REF_DEREF),\n-    LintId::of(methods::OPTION_FILTER_MAP),\n-    LintId::of(methods::OR_THEN_UNWRAP),\n-    LintId::of(methods::RANGE_ZIP_WITH_LEN),\n-    LintId::of(methods::REPEAT_ONCE),\n-    LintId::of(methods::SEARCH_IS_SOME),\n-    LintId::of(methods::SKIP_WHILE_NEXT),\n-    LintId::of(methods::UNNECESSARY_FILTER_MAP),\n-    LintId::of(methods::UNNECESSARY_FIND_MAP),\n-    LintId::of(methods::UNNECESSARY_SORT_BY),\n-    LintId::of(methods::USELESS_ASREF),\n-    LintId::of(misc::SHORT_CIRCUIT_STATEMENT),\n-    LintId::of(misc_early::UNNEEDED_WILDCARD_PATTERN),\n-    LintId::of(misc_early::ZERO_PREFIXED_LITERAL),\n-    LintId::of(mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION),\n-    LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n-    LintId::of(needless_bool::BOOL_COMPARISON),\n-    LintId::of(needless_bool::NEEDLESS_BOOL),\n-    LintId::of(needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n-    LintId::of(needless_question_mark::NEEDLESS_QUESTION_MARK),\n-    LintId::of(needless_update::NEEDLESS_UPDATE),\n-    LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n-    LintId::of(no_effect::NO_EFFECT),\n-    LintId::of(no_effect::UNNECESSARY_OPERATION),\n-    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n-    LintId::of(operators::DOUBLE_COMPARISONS),\n-    LintId::of(operators::DURATION_SUBSEC),\n-    LintId::of(operators::IDENTITY_OP),\n-    LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n-    LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n-    LintId::of(precedence::PRECEDENCE),\n-    LintId::of(ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n-    LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n-    LintId::of(redundant_slicing::REDUNDANT_SLICING),\n-    LintId::of(reference::DEREF_ADDROF),\n-    LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n-    LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n-    LintId::of(swap::MANUAL_SWAP),\n-    LintId::of(temporary_assignment::TEMPORARY_ASSIGNMENT),\n-    LintId::of(transmute::CROSSPOINTER_TRANSMUTE),\n-    LintId::of(transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n-    LintId::of(transmute::TRANSMUTE_BYTES_TO_STR),\n-    LintId::of(transmute::TRANSMUTE_FLOAT_TO_INT),\n-    LintId::of(transmute::TRANSMUTE_INT_TO_BOOL),\n-    LintId::of(transmute::TRANSMUTE_INT_TO_CHAR),\n-    LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n-    LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n-    LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n-    LintId::of(transmute::USELESS_TRANSMUTE),\n-    LintId::of(types::BORROWED_BOX),\n-    LintId::of(types::TYPE_COMPLEXITY),\n-    LintId::of(types::VEC_BOX),\n-    LintId::of(unit_types::UNIT_ARG),\n-    LintId::of(unwrap::UNNECESSARY_UNWRAP),\n-    LintId::of(useless_conversion::USELESS_CONVERSION),\n-    LintId::of(zero_div_zero::ZERO_DIVIDED_BY_ZERO),\n-])"}, {"sha": "bb94037ec2e7949ba52a2b25ba0bd89ae6794e89", "filename": "src/tools/clippy/clippy_lints/src/lib.register_correctness.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,78 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), vec![\n-    LintId::of(approx_const::APPROX_CONSTANT),\n-    LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n-    LintId::of(attrs::DEPRECATED_SEMVER),\n-    LintId::of(attrs::MISMATCHED_TARGET_OS),\n-    LintId::of(attrs::USELESS_ATTRIBUTE),\n-    LintId::of(booleans::OVERLY_COMPLEX_BOOL_EXPR),\n-    LintId::of(casts::CAST_REF_TO_MUT),\n-    LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n-    LintId::of(copies::IFS_SAME_COND),\n-    LintId::of(copies::IF_SAME_THEN_ELSE),\n-    LintId::of(derive::DERIVE_HASH_XOR_EQ),\n-    LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n-    LintId::of(drop_forget_ref::DROP_COPY),\n-    LintId::of(drop_forget_ref::DROP_REF),\n-    LintId::of(drop_forget_ref::FORGET_COPY),\n-    LintId::of(drop_forget_ref::FORGET_REF),\n-    LintId::of(drop_forget_ref::UNDROPPED_MANUALLY_DROPS),\n-    LintId::of(enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT),\n-    LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n-    LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n-    LintId::of(functions::NOT_UNSAFE_PTR_ARG_DEREF),\n-    LintId::of(if_let_mutex::IF_LET_MUTEX),\n-    LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n-    LintId::of(infinite_iter::INFINITE_ITER),\n-    LintId::of(inherent_to_string::INHERENT_TO_STRING_SHADOW_DISPLAY),\n-    LintId::of(inline_fn_without_body::INLINE_FN_WITHOUT_BODY),\n-    LintId::of(invalid_utf8_in_unchecked::INVALID_UTF8_IN_UNCHECKED),\n-    LintId::of(let_underscore::LET_UNDERSCORE_LOCK),\n-    LintId::of(literal_representation::MISTYPED_LITERAL_SUFFIXES),\n-    LintId::of(loops::ITER_NEXT_LOOP),\n-    LintId::of(loops::NEVER_LOOP),\n-    LintId::of(loops::WHILE_IMMUTABLE_CONDITION),\n-    LintId::of(matches::MATCH_STR_CASE_MISMATCH),\n-    LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n-    LintId::of(methods::CLONE_DOUBLE_REF),\n-    LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n-    LintId::of(methods::NONSENSICAL_OPEN_OPTIONS),\n-    LintId::of(methods::SUSPICIOUS_SPLITN),\n-    LintId::of(methods::UNINIT_ASSUMED_INIT),\n-    LintId::of(methods::UNIT_HASH),\n-    LintId::of(methods::VEC_RESIZE_TO_ZERO),\n-    LintId::of(methods::ZST_OFFSET),\n-    LintId::of(minmax::MIN_MAX),\n-    LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n-    LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n-    LintId::of(operators::BAD_BIT_MASK),\n-    LintId::of(operators::CMP_NAN),\n-    LintId::of(operators::EQ_OP),\n-    LintId::of(operators::ERASING_OP),\n-    LintId::of(operators::INEFFECTIVE_BIT_MASK),\n-    LintId::of(operators::MODULO_ONE),\n-    LintId::of(operators::SELF_ASSIGNMENT),\n-    LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n-    LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n-    LintId::of(ptr::MUT_FROM_REF),\n-    LintId::of(ranges::REVERSED_EMPTY_RANGES),\n-    LintId::of(read_zero_byte_vec::READ_ZERO_BYTE_VEC),\n-    LintId::of(regex::INVALID_REGEX),\n-    LintId::of(serde_api::SERDE_API_MISUSE),\n-    LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n-    LintId::of(swap::ALMOST_SWAPPED),\n-    LintId::of(transmute::TRANSMUTING_NULL),\n-    LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n-    LintId::of(transmute::WRONG_TRANSMUTE),\n-    LintId::of(unicode::INVISIBLE_CHARACTERS),\n-    LintId::of(uninit_vec::UNINIT_VEC),\n-    LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n-    LintId::of(unit_types::UNIT_CMP),\n-    LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n-    LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n-    LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n-    LintId::of(unwrap::PANICKING_UNWRAP),\n-])"}, {"sha": "40c94c6e8d33dc8101986d7ba7251433288adaa5", "filename": "src/tools/clippy/clippy_lints/src/lib.register_internal.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_internal.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,22 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n-    LintId::of(utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL),\n-    LintId::of(utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS),\n-    LintId::of(utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS),\n-    LintId::of(utils::internal_lints::if_chain_style::IF_CHAIN_STYLE),\n-    LintId::of(utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL),\n-    LintId::of(utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR),\n-    LintId::of(utils::internal_lints::invalid_paths::INVALID_PATHS),\n-    LintId::of(utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON),\n-    LintId::of(utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT),\n-    LintId::of(utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n-    LintId::of(utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS),\n-    LintId::of(utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n-    LintId::of(utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL),\n-    LintId::of(utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA),\n-    LintId::of(utils::internal_lints::produce_ice::PRODUCE_ICE),\n-    LintId::of(utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH),\n-])"}, {"sha": "800e3a8767133d1597dedb4c5f452ac603c52b20", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "removed", "additions": 0, "deletions": 620, "changes": 620, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,620 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_lints(&[\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::if_chain_style::IF_CHAIN_STYLE,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::invalid_paths::INVALID_PATHS,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::produce_ice::PRODUCE_ICE,\n-    #[cfg(feature = \"internal\")]\n-    utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH,\n-    almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n-    approx_const::APPROX_CONSTANT,\n-    as_conversions::AS_CONVERSIONS,\n-    asm_syntax::INLINE_ASM_X86_ATT_SYNTAX,\n-    asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX,\n-    assertions_on_constants::ASSERTIONS_ON_CONSTANTS,\n-    assertions_on_result_states::ASSERTIONS_ON_RESULT_STATES,\n-    async_yields_async::ASYNC_YIELDS_ASYNC,\n-    attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON,\n-    attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n-    attrs::DEPRECATED_CFG_ATTR,\n-    attrs::DEPRECATED_SEMVER,\n-    attrs::EMPTY_LINE_AFTER_OUTER_ATTR,\n-    attrs::INLINE_ALWAYS,\n-    attrs::MISMATCHED_TARGET_OS,\n-    attrs::USELESS_ATTRIBUTE,\n-    await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE,\n-    await_holding_invalid::AWAIT_HOLDING_LOCK,\n-    await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n-    blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS,\n-    bool_assert_comparison::BOOL_ASSERT_COMPARISON,\n-    bool_to_int_with_if::BOOL_TO_INT_WITH_IF,\n-    booleans::NONMINIMAL_BOOL,\n-    booleans::OVERLY_COMPLEX_BOOL_EXPR,\n-    borrow_deref_ref::BORROW_DEREF_REF,\n-    box_default::BOX_DEFAULT,\n-    cargo::CARGO_COMMON_METADATA,\n-    cargo::MULTIPLE_CRATE_VERSIONS,\n-    cargo::NEGATIVE_FEATURE_NAMES,\n-    cargo::REDUNDANT_FEATURE_NAMES,\n-    cargo::WILDCARD_DEPENDENCIES,\n-    casts::AS_PTR_CAST_MUT,\n-    casts::AS_UNDERSCORE,\n-    casts::BORROW_AS_PTR,\n-    casts::CAST_ABS_TO_UNSIGNED,\n-    casts::CAST_ENUM_CONSTRUCTOR,\n-    casts::CAST_ENUM_TRUNCATION,\n-    casts::CAST_LOSSLESS,\n-    casts::CAST_NAN_TO_INT,\n-    casts::CAST_POSSIBLE_TRUNCATION,\n-    casts::CAST_POSSIBLE_WRAP,\n-    casts::CAST_PRECISION_LOSS,\n-    casts::CAST_PTR_ALIGNMENT,\n-    casts::CAST_REF_TO_MUT,\n-    casts::CAST_SIGN_LOSS,\n-    casts::CAST_SLICE_DIFFERENT_SIZES,\n-    casts::CAST_SLICE_FROM_RAW_PARTS,\n-    casts::CHAR_LIT_AS_U8,\n-    casts::FN_TO_NUMERIC_CAST,\n-    casts::FN_TO_NUMERIC_CAST_ANY,\n-    casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n-    casts::PTR_AS_PTR,\n-    casts::UNNECESSARY_CAST,\n-    checked_conversions::CHECKED_CONVERSIONS,\n-    cognitive_complexity::COGNITIVE_COMPLEXITY,\n-    collapsible_if::COLLAPSIBLE_ELSE_IF,\n-    collapsible_if::COLLAPSIBLE_IF,\n-    comparison_chain::COMPARISON_CHAIN,\n-    copies::BRANCHES_SHARING_CODE,\n-    copies::IFS_SAME_COND,\n-    copies::IF_SAME_THEN_ELSE,\n-    copies::SAME_FUNCTIONS_IN_IF_CONDITION,\n-    copy_iterator::COPY_ITERATOR,\n-    crate_in_macro_def::CRATE_IN_MACRO_DEF,\n-    create_dir::CREATE_DIR,\n-    dbg_macro::DBG_MACRO,\n-    default::DEFAULT_TRAIT_ACCESS,\n-    default::FIELD_REASSIGN_WITH_DEFAULT,\n-    default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY,\n-    default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n-    default_union_representation::DEFAULT_UNION_REPRESENTATION,\n-    dereference::EXPLICIT_AUTO_DEREF,\n-    dereference::EXPLICIT_DEREF_METHODS,\n-    dereference::NEEDLESS_BORROW,\n-    dereference::REF_BINDING_TO_REFERENCE,\n-    derivable_impls::DERIVABLE_IMPLS,\n-    derive::DERIVE_HASH_XOR_EQ,\n-    derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n-    derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ,\n-    derive::EXPL_IMPL_CLONE_ON_COPY,\n-    derive::UNSAFE_DERIVE_DESERIALIZE,\n-    disallowed_macros::DISALLOWED_MACROS,\n-    disallowed_methods::DISALLOWED_METHODS,\n-    disallowed_names::DISALLOWED_NAMES,\n-    disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS,\n-    disallowed_types::DISALLOWED_TYPES,\n-    doc::DOC_LINK_WITH_QUOTES,\n-    doc::DOC_MARKDOWN,\n-    doc::MISSING_ERRORS_DOC,\n-    doc::MISSING_PANICS_DOC,\n-    doc::MISSING_SAFETY_DOC,\n-    doc::NEEDLESS_DOCTEST_MAIN,\n-    double_parens::DOUBLE_PARENS,\n-    drop_forget_ref::DROP_COPY,\n-    drop_forget_ref::DROP_NON_DROP,\n-    drop_forget_ref::DROP_REF,\n-    drop_forget_ref::FORGET_COPY,\n-    drop_forget_ref::FORGET_NON_DROP,\n-    drop_forget_ref::FORGET_REF,\n-    drop_forget_ref::UNDROPPED_MANUALLY_DROPS,\n-    duplicate_mod::DUPLICATE_MOD,\n-    else_if_without_else::ELSE_IF_WITHOUT_ELSE,\n-    empty_drop::EMPTY_DROP,\n-    empty_enum::EMPTY_ENUM,\n-    empty_structs_with_brackets::EMPTY_STRUCTS_WITH_BRACKETS,\n-    entry::MAP_ENTRY,\n-    enum_clike::ENUM_CLIKE_UNPORTABLE_VARIANT,\n-    enum_variants::ENUM_VARIANT_NAMES,\n-    enum_variants::MODULE_INCEPTION,\n-    enum_variants::MODULE_NAME_REPETITIONS,\n-    equatable_if_let::EQUATABLE_IF_LET,\n-    escape::BOXED_LOCAL,\n-    eta_reduction::REDUNDANT_CLOSURE,\n-    eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n-    excessive_bools::FN_PARAMS_EXCESSIVE_BOOLS,\n-    excessive_bools::STRUCT_EXCESSIVE_BOOLS,\n-    exhaustive_items::EXHAUSTIVE_ENUMS,\n-    exhaustive_items::EXHAUSTIVE_STRUCTS,\n-    exit::EXIT,\n-    explicit_write::EXPLICIT_WRITE,\n-    fallible_impl_from::FALLIBLE_IMPL_FROM,\n-    float_literal::EXCESSIVE_PRECISION,\n-    float_literal::LOSSY_FLOAT_LITERAL,\n-    floating_point_arithmetic::IMPRECISE_FLOPS,\n-    floating_point_arithmetic::SUBOPTIMAL_FLOPS,\n-    format::USELESS_FORMAT,\n-    format_args::FORMAT_IN_FORMAT_ARGS,\n-    format_args::TO_STRING_IN_FORMAT_ARGS,\n-    format_args::UNINLINED_FORMAT_ARGS,\n-    format_args::UNUSED_FORMAT_SPECS,\n-    format_impl::PRINT_IN_FORMAT_IMPL,\n-    format_impl::RECURSIVE_FORMAT_IMPL,\n-    format_push_string::FORMAT_PUSH_STRING,\n-    formatting::POSSIBLE_MISSING_COMMA,\n-    formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n-    formatting::SUSPICIOUS_ELSE_FORMATTING,\n-    formatting::SUSPICIOUS_UNARY_OP_FORMATTING,\n-    from_over_into::FROM_OVER_INTO,\n-    from_str_radix_10::FROM_STR_RADIX_10,\n-    functions::DOUBLE_MUST_USE,\n-    functions::MUST_USE_CANDIDATE,\n-    functions::MUST_USE_UNIT,\n-    functions::NOT_UNSAFE_PTR_ARG_DEREF,\n-    functions::RESULT_LARGE_ERR,\n-    functions::RESULT_UNIT_ERR,\n-    functions::TOO_MANY_ARGUMENTS,\n-    functions::TOO_MANY_LINES,\n-    future_not_send::FUTURE_NOT_SEND,\n-    if_let_mutex::IF_LET_MUTEX,\n-    if_not_else::IF_NOT_ELSE,\n-    if_then_some_else_none::IF_THEN_SOME_ELSE_NONE,\n-    implicit_hasher::IMPLICIT_HASHER,\n-    implicit_return::IMPLICIT_RETURN,\n-    implicit_saturating_add::IMPLICIT_SATURATING_ADD,\n-    implicit_saturating_sub::IMPLICIT_SATURATING_SUB,\n-    inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR,\n-    index_refutable_slice::INDEX_REFUTABLE_SLICE,\n-    indexing_slicing::INDEXING_SLICING,\n-    indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n-    infinite_iter::INFINITE_ITER,\n-    infinite_iter::MAYBE_INFINITE_ITER,\n-    inherent_impl::MULTIPLE_INHERENT_IMPL,\n-    inherent_to_string::INHERENT_TO_STRING,\n-    inherent_to_string::INHERENT_TO_STRING_SHADOW_DISPLAY,\n-    init_numbered_fields::INIT_NUMBERED_FIELDS,\n-    inline_fn_without_body::INLINE_FN_WITHOUT_BODY,\n-    int_plus_one::INT_PLUS_ONE,\n-    invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS,\n-    invalid_utf8_in_unchecked::INVALID_UTF8_IN_UNCHECKED,\n-    items_after_statements::ITEMS_AFTER_STATEMENTS,\n-    iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR,\n-    large_const_arrays::LARGE_CONST_ARRAYS,\n-    large_enum_variant::LARGE_ENUM_VARIANT,\n-    large_include_file::LARGE_INCLUDE_FILE,\n-    large_stack_arrays::LARGE_STACK_ARRAYS,\n-    len_zero::COMPARISON_TO_EMPTY,\n-    len_zero::LEN_WITHOUT_IS_EMPTY,\n-    len_zero::LEN_ZERO,\n-    let_if_seq::USELESS_LET_IF_SEQ,\n-    let_underscore::LET_UNDERSCORE_DROP,\n-    let_underscore::LET_UNDERSCORE_LOCK,\n-    let_underscore::LET_UNDERSCORE_MUST_USE,\n-    lifetimes::EXTRA_UNUSED_LIFETIMES,\n-    lifetimes::NEEDLESS_LIFETIMES,\n-    literal_representation::DECIMAL_LITERAL_REPRESENTATION,\n-    literal_representation::INCONSISTENT_DIGIT_GROUPING,\n-    literal_representation::LARGE_DIGIT_GROUPS,\n-    literal_representation::MISTYPED_LITERAL_SUFFIXES,\n-    literal_representation::UNREADABLE_LITERAL,\n-    literal_representation::UNUSUAL_BYTE_GROUPINGS,\n-    loops::EMPTY_LOOP,\n-    loops::EXPLICIT_COUNTER_LOOP,\n-    loops::EXPLICIT_INTO_ITER_LOOP,\n-    loops::EXPLICIT_ITER_LOOP,\n-    loops::FOR_KV_MAP,\n-    loops::ITER_NEXT_LOOP,\n-    loops::MANUAL_FIND,\n-    loops::MANUAL_FLATTEN,\n-    loops::MANUAL_MEMCPY,\n-    loops::MISSING_SPIN_LOOP,\n-    loops::MUT_RANGE_BOUND,\n-    loops::NEEDLESS_COLLECT,\n-    loops::NEEDLESS_RANGE_LOOP,\n-    loops::NEVER_LOOP,\n-    loops::SAME_ITEM_PUSH,\n-    loops::SINGLE_ELEMENT_LOOP,\n-    loops::WHILE_IMMUTABLE_CONDITION,\n-    loops::WHILE_LET_LOOP,\n-    loops::WHILE_LET_ON_ITERATOR,\n-    macro_use::MACRO_USE_IMPORTS,\n-    main_recursion::MAIN_RECURSION,\n-    manual_assert::MANUAL_ASSERT,\n-    manual_async_fn::MANUAL_ASYNC_FN,\n-    manual_bits::MANUAL_BITS,\n-    manual_clamp::MANUAL_CLAMP,\n-    manual_instant_elapsed::MANUAL_INSTANT_ELAPSED,\n-    manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n-    manual_rem_euclid::MANUAL_REM_EUCLID,\n-    manual_retain::MANUAL_RETAIN,\n-    manual_string_new::MANUAL_STRING_NEW,\n-    manual_strip::MANUAL_STRIP,\n-    map_unit_fn::OPTION_MAP_UNIT_FN,\n-    map_unit_fn::RESULT_MAP_UNIT_FN,\n-    match_result_ok::MATCH_RESULT_OK,\n-    matches::COLLAPSIBLE_MATCH,\n-    matches::INFALLIBLE_DESTRUCTURING_MATCH,\n-    matches::MANUAL_FILTER,\n-    matches::MANUAL_MAP,\n-    matches::MANUAL_UNWRAP_OR,\n-    matches::MATCH_AS_REF,\n-    matches::MATCH_BOOL,\n-    matches::MATCH_LIKE_MATCHES_MACRO,\n-    matches::MATCH_ON_VEC_ITEMS,\n-    matches::MATCH_OVERLAPPING_ARM,\n-    matches::MATCH_REF_PATS,\n-    matches::MATCH_SAME_ARMS,\n-    matches::MATCH_SINGLE_BINDING,\n-    matches::MATCH_STR_CASE_MISMATCH,\n-    matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-    matches::MATCH_WILD_ERR_ARM,\n-    matches::NEEDLESS_MATCH,\n-    matches::REDUNDANT_PATTERN_MATCHING,\n-    matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-    matches::SIGNIFICANT_DROP_IN_SCRUTINEE,\n-    matches::SINGLE_MATCH,\n-    matches::SINGLE_MATCH_ELSE,\n-    matches::TRY_ERR,\n-    matches::WILDCARD_ENUM_MATCH_ARM,\n-    matches::WILDCARD_IN_OR_PATTERNS,\n-    mem_forget::MEM_FORGET,\n-    mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n-    mem_replace::MEM_REPLACE_WITH_DEFAULT,\n-    mem_replace::MEM_REPLACE_WITH_UNINIT,\n-    methods::BIND_INSTEAD_OF_MAP,\n-    methods::BYTES_COUNT_TO_LEN,\n-    methods::BYTES_NTH,\n-    methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n-    methods::CHARS_LAST_CMP,\n-    methods::CHARS_NEXT_CMP,\n-    methods::CLONED_INSTEAD_OF_COPIED,\n-    methods::CLONE_DOUBLE_REF,\n-    methods::CLONE_ON_COPY,\n-    methods::CLONE_ON_REF_PTR,\n-    methods::COLLAPSIBLE_STR_REPLACE,\n-    methods::ERR_EXPECT,\n-    methods::EXPECT_FUN_CALL,\n-    methods::EXPECT_USED,\n-    methods::EXTEND_WITH_DRAIN,\n-    methods::FILETYPE_IS_FILE,\n-    methods::FILTER_MAP_IDENTITY,\n-    methods::FILTER_MAP_NEXT,\n-    methods::FILTER_NEXT,\n-    methods::FLAT_MAP_IDENTITY,\n-    methods::FLAT_MAP_OPTION,\n-    methods::FROM_ITER_INSTEAD_OF_COLLECT,\n-    methods::GET_FIRST,\n-    methods::GET_LAST_WITH_LEN,\n-    methods::GET_UNWRAP,\n-    methods::IMPLICIT_CLONE,\n-    methods::INEFFICIENT_TO_STRING,\n-    methods::INSPECT_FOR_EACH,\n-    methods::INTO_ITER_ON_REF,\n-    methods::IS_DIGIT_ASCII_RADIX,\n-    methods::ITERATOR_STEP_BY_ZERO,\n-    methods::ITER_CLONED_COLLECT,\n-    methods::ITER_COUNT,\n-    methods::ITER_KV_MAP,\n-    methods::ITER_NEXT_SLICE,\n-    methods::ITER_NTH,\n-    methods::ITER_NTH_ZERO,\n-    methods::ITER_ON_EMPTY_COLLECTIONS,\n-    methods::ITER_ON_SINGLE_ITEMS,\n-    methods::ITER_OVEREAGER_CLONED,\n-    methods::ITER_SKIP_NEXT,\n-    methods::ITER_WITH_DRAIN,\n-    methods::MANUAL_FILTER_MAP,\n-    methods::MANUAL_FIND_MAP,\n-    methods::MANUAL_OK_OR,\n-    methods::MANUAL_SATURATING_ARITHMETIC,\n-    methods::MANUAL_SPLIT_ONCE,\n-    methods::MANUAL_STR_REPEAT,\n-    methods::MAP_CLONE,\n-    methods::MAP_COLLECT_RESULT_UNIT,\n-    methods::MAP_ERR_IGNORE,\n-    methods::MAP_FLATTEN,\n-    methods::MAP_IDENTITY,\n-    methods::MAP_UNWRAP_OR,\n-    methods::MUT_MUTEX_LOCK,\n-    methods::NAIVE_BYTECOUNT,\n-    methods::NEEDLESS_OPTION_AS_DEREF,\n-    methods::NEEDLESS_OPTION_TAKE,\n-    methods::NEEDLESS_SPLITN,\n-    methods::NEW_RET_NO_SELF,\n-    methods::NONSENSICAL_OPEN_OPTIONS,\n-    methods::NO_EFFECT_REPLACE,\n-    methods::OBFUSCATED_IF_ELSE,\n-    methods::OK_EXPECT,\n-    methods::OPTION_AS_REF_DEREF,\n-    methods::OPTION_FILTER_MAP,\n-    methods::OPTION_MAP_OR_NONE,\n-    methods::OR_FUN_CALL,\n-    methods::OR_THEN_UNWRAP,\n-    methods::PATH_BUF_PUSH_OVERWRITE,\n-    methods::RANGE_ZIP_WITH_LEN,\n-    methods::REPEAT_ONCE,\n-    methods::RESULT_MAP_OR_INTO_OPTION,\n-    methods::SEARCH_IS_SOME,\n-    methods::SHOULD_IMPLEMENT_TRAIT,\n-    methods::SINGLE_CHAR_ADD_STR,\n-    methods::SINGLE_CHAR_PATTERN,\n-    methods::SKIP_WHILE_NEXT,\n-    methods::STABLE_SORT_PRIMITIVE,\n-    methods::STRING_EXTEND_CHARS,\n-    methods::SUSPICIOUS_MAP,\n-    methods::SUSPICIOUS_SPLITN,\n-    methods::SUSPICIOUS_TO_OWNED,\n-    methods::UNINIT_ASSUMED_INIT,\n-    methods::UNIT_HASH,\n-    methods::UNNECESSARY_FILTER_MAP,\n-    methods::UNNECESSARY_FIND_MAP,\n-    methods::UNNECESSARY_FOLD,\n-    methods::UNNECESSARY_JOIN,\n-    methods::UNNECESSARY_LAZY_EVALUATIONS,\n-    methods::UNNECESSARY_SORT_BY,\n-    methods::UNNECESSARY_TO_OWNED,\n-    methods::UNWRAP_OR_ELSE_DEFAULT,\n-    methods::UNWRAP_USED,\n-    methods::USELESS_ASREF,\n-    methods::VEC_RESIZE_TO_ZERO,\n-    methods::VERBOSE_FILE_READS,\n-    methods::WRONG_SELF_CONVENTION,\n-    methods::ZST_OFFSET,\n-    minmax::MIN_MAX,\n-    misc::SHORT_CIRCUIT_STATEMENT,\n-    misc::TOPLEVEL_REF_ARG,\n-    misc::USED_UNDERSCORE_BINDING,\n-    misc::ZERO_PTR,\n-    misc_early::BUILTIN_TYPE_SHADOW,\n-    misc_early::DOUBLE_NEG,\n-    misc_early::DUPLICATE_UNDERSCORE_ARGUMENT,\n-    misc_early::MIXED_CASE_HEX_LITERALS,\n-    misc_early::REDUNDANT_PATTERN,\n-    misc_early::SEPARATED_LITERAL_SUFFIX,\n-    misc_early::UNNEEDED_FIELD_PATTERN,\n-    misc_early::UNNEEDED_WILDCARD_PATTERN,\n-    misc_early::UNSEPARATED_LITERAL_SUFFIX,\n-    misc_early::ZERO_PREFIXED_LITERAL,\n-    mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER,\n-    missing_const_for_fn::MISSING_CONST_FOR_FN,\n-    missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n-    missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES,\n-    missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS,\n-    missing_trait_methods::MISSING_TRAIT_METHODS,\n-    mixed_read_write_in_expression::DIVERGING_SUB_EXPRESSION,\n-    mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION,\n-    module_style::MOD_MODULE_FILES,\n-    module_style::SELF_NAMED_MODULE_FILES,\n-    multi_assignments::MULTI_ASSIGNMENTS,\n-    mut_key::MUTABLE_KEY_TYPE,\n-    mut_mut::MUT_MUT,\n-    mut_reference::UNNECESSARY_MUT_PASSED,\n-    mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL,\n-    mutex_atomic::MUTEX_ATOMIC,\n-    mutex_atomic::MUTEX_INTEGER,\n-    needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE,\n-    needless_bool::BOOL_COMPARISON,\n-    needless_bool::NEEDLESS_BOOL,\n-    needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n-    needless_continue::NEEDLESS_CONTINUE,\n-    needless_for_each::NEEDLESS_FOR_EACH,\n-    needless_late_init::NEEDLESS_LATE_INIT,\n-    needless_parens_on_range_literals::NEEDLESS_PARENS_ON_RANGE_LITERALS,\n-    needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n-    needless_question_mark::NEEDLESS_QUESTION_MARK,\n-    needless_update::NEEDLESS_UPDATE,\n-    neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD,\n-    neg_multiply::NEG_MULTIPLY,\n-    new_without_default::NEW_WITHOUT_DEFAULT,\n-    no_effect::NO_EFFECT,\n-    no_effect::NO_EFFECT_UNDERSCORE_BINDING,\n-    no_effect::UNNECESSARY_OPERATION,\n-    non_copy_const::BORROW_INTERIOR_MUTABLE_CONST,\n-    non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST,\n-    non_expressive_names::JUST_UNDERSCORES_AND_DIGITS,\n-    non_expressive_names::MANY_SINGLE_CHAR_NAMES,\n-    non_expressive_names::SIMILAR_NAMES,\n-    non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS,\n-    non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY,\n-    nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES,\n-    octal_escapes::OCTAL_ESCAPES,\n-    only_used_in_recursion::ONLY_USED_IN_RECURSION,\n-    operators::ABSURD_EXTREME_COMPARISONS,\n-    operators::ARITHMETIC_SIDE_EFFECTS,\n-    operators::ASSIGN_OP_PATTERN,\n-    operators::BAD_BIT_MASK,\n-    operators::CMP_NAN,\n-    operators::CMP_OWNED,\n-    operators::DOUBLE_COMPARISONS,\n-    operators::DURATION_SUBSEC,\n-    operators::EQ_OP,\n-    operators::ERASING_OP,\n-    operators::FLOAT_ARITHMETIC,\n-    operators::FLOAT_CMP,\n-    operators::FLOAT_CMP_CONST,\n-    operators::FLOAT_EQUALITY_WITHOUT_ABS,\n-    operators::IDENTITY_OP,\n-    operators::INEFFECTIVE_BIT_MASK,\n-    operators::INTEGER_ARITHMETIC,\n-    operators::INTEGER_DIVISION,\n-    operators::MISREFACTORED_ASSIGN_OP,\n-    operators::MODULO_ARITHMETIC,\n-    operators::MODULO_ONE,\n-    operators::NEEDLESS_BITWISE_BOOL,\n-    operators::OP_REF,\n-    operators::PTR_EQ,\n-    operators::SELF_ASSIGNMENT,\n-    operators::VERBOSE_BIT_MASK,\n-    option_env_unwrap::OPTION_ENV_UNWRAP,\n-    option_if_let_else::OPTION_IF_LET_ELSE,\n-    overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n-    panic_in_result_fn::PANIC_IN_RESULT_FN,\n-    panic_unimplemented::PANIC,\n-    panic_unimplemented::TODO,\n-    panic_unimplemented::UNIMPLEMENTED,\n-    panic_unimplemented::UNREACHABLE,\n-    partial_pub_fields::PARTIAL_PUB_FIELDS,\n-    partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n-    partialeq_to_none::PARTIALEQ_TO_NONE,\n-    pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE,\n-    pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF,\n-    pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n-    precedence::PRECEDENCE,\n-    ptr::CMP_NULL,\n-    ptr::INVALID_NULL_PTR_USAGE,\n-    ptr::MUT_FROM_REF,\n-    ptr::PTR_ARG,\n-    ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n-    pub_use::PUB_USE,\n-    question_mark::QUESTION_MARK,\n-    ranges::MANUAL_RANGE_CONTAINS,\n-    ranges::RANGE_MINUS_ONE,\n-    ranges::RANGE_PLUS_ONE,\n-    ranges::REVERSED_EMPTY_RANGES,\n-    rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT,\n-    read_zero_byte_vec::READ_ZERO_BYTE_VEC,\n-    redundant_clone::REDUNDANT_CLONE,\n-    redundant_closure_call::REDUNDANT_CLOSURE_CALL,\n-    redundant_else::REDUNDANT_ELSE,\n-    redundant_field_names::REDUNDANT_FIELD_NAMES,\n-    redundant_pub_crate::REDUNDANT_PUB_CRATE,\n-    redundant_slicing::DEREF_BY_SLICING,\n-    redundant_slicing::REDUNDANT_SLICING,\n-    redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n-    ref_option_ref::REF_OPTION_REF,\n-    reference::DEREF_ADDROF,\n-    regex::INVALID_REGEX,\n-    regex::TRIVIAL_REGEX,\n-    return_self_not_must_use::RETURN_SELF_NOT_MUST_USE,\n-    returns::LET_AND_RETURN,\n-    returns::NEEDLESS_RETURN,\n-    same_name_method::SAME_NAME_METHOD,\n-    self_named_constructors::SELF_NAMED_CONSTRUCTORS,\n-    semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED,\n-    serde_api::SERDE_API_MISUSE,\n-    shadow::SHADOW_REUSE,\n-    shadow::SHADOW_SAME,\n-    shadow::SHADOW_UNRELATED,\n-    single_char_lifetime_names::SINGLE_CHAR_LIFETIME_NAMES,\n-    single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n-    size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n-    slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n-    std_instead_of_core::ALLOC_INSTEAD_OF_CORE,\n-    std_instead_of_core::STD_INSTEAD_OF_ALLOC,\n-    std_instead_of_core::STD_INSTEAD_OF_CORE,\n-    strings::STRING_ADD,\n-    strings::STRING_ADD_ASSIGN,\n-    strings::STRING_FROM_UTF8_AS_BYTES,\n-    strings::STRING_LIT_AS_BYTES,\n-    strings::STRING_SLICE,\n-    strings::STRING_TO_STRING,\n-    strings::STR_TO_STRING,\n-    strings::TRIM_SPLIT_WHITESPACE,\n-    strlen_on_c_strings::STRLEN_ON_C_STRINGS,\n-    suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS,\n-    suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n-    suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n-    swap::ALMOST_SWAPPED,\n-    swap::MANUAL_SWAP,\n-    swap_ptr_to_ref::SWAP_PTR_TO_REF,\n-    tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n-    temporary_assignment::TEMPORARY_ASSIGNMENT,\n-    to_digit_is_some::TO_DIGIT_IS_SOME,\n-    trailing_empty_array::TRAILING_EMPTY_ARRAY,\n-    trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n-    trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n-    transmute::CROSSPOINTER_TRANSMUTE,\n-    transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n-    transmute::TRANSMUTE_BYTES_TO_STR,\n-    transmute::TRANSMUTE_FLOAT_TO_INT,\n-    transmute::TRANSMUTE_INT_TO_BOOL,\n-    transmute::TRANSMUTE_INT_TO_CHAR,\n-    transmute::TRANSMUTE_INT_TO_FLOAT,\n-    transmute::TRANSMUTE_NUM_TO_BYTES,\n-    transmute::TRANSMUTE_PTR_TO_PTR,\n-    transmute::TRANSMUTE_PTR_TO_REF,\n-    transmute::TRANSMUTE_UNDEFINED_REPR,\n-    transmute::TRANSMUTING_NULL,\n-    transmute::UNSOUND_COLLECTION_TRANSMUTE,\n-    transmute::USELESS_TRANSMUTE,\n-    transmute::WRONG_TRANSMUTE,\n-    types::BORROWED_BOX,\n-    types::BOX_COLLECTION,\n-    types::LINKEDLIST,\n-    types::OPTION_OPTION,\n-    types::RC_BUFFER,\n-    types::RC_MUTEX,\n-    types::REDUNDANT_ALLOCATION,\n-    types::TYPE_COMPLEXITY,\n-    types::VEC_BOX,\n-    undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS,\n-    unicode::INVISIBLE_CHARACTERS,\n-    unicode::NON_ASCII_LITERAL,\n-    unicode::UNICODE_NOT_NFC,\n-    uninit_vec::UNINIT_VEC,\n-    unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD,\n-    unit_types::LET_UNIT_VALUE,\n-    unit_types::UNIT_ARG,\n-    unit_types::UNIT_CMP,\n-    unnamed_address::FN_ADDRESS_COMPARISONS,\n-    unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n-    unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS,\n-    unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS,\n-    unnecessary_wraps::UNNECESSARY_WRAPS,\n-    unnested_or_patterns::UNNESTED_OR_PATTERNS,\n-    unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n-    unused_async::UNUSED_ASYNC,\n-    unused_io_amount::UNUSED_IO_AMOUNT,\n-    unused_peekable::UNUSED_PEEKABLE,\n-    unused_rounding::UNUSED_ROUNDING,\n-    unused_self::UNUSED_SELF,\n-    unused_unit::UNUSED_UNIT,\n-    unwrap::PANICKING_UNWRAP,\n-    unwrap::UNNECESSARY_UNWRAP,\n-    unwrap_in_result::UNWRAP_IN_RESULT,\n-    upper_case_acronyms::UPPER_CASE_ACRONYMS,\n-    use_self::USE_SELF,\n-    useless_conversion::USELESS_CONVERSION,\n-    vec::USELESS_VEC,\n-    vec_init_then_push::VEC_INIT_THEN_PUSH,\n-    wildcard_imports::ENUM_GLOB_USE,\n-    wildcard_imports::WILDCARD_IMPORTS,\n-    write::PRINTLN_EMPTY_STRING,\n-    write::PRINT_LITERAL,\n-    write::PRINT_STDERR,\n-    write::PRINT_STDOUT,\n-    write::PRINT_WITH_NEWLINE,\n-    write::USE_DEBUG,\n-    write::WRITELN_EMPTY_STRING,\n-    write::WRITE_LITERAL,\n-    write::WRITE_WITH_NEWLINE,\n-    zero_div_zero::ZERO_DIVIDED_BY_ZERO,\n-    zero_sized_map_values::ZERO_SIZED_MAP_VALUES,\n-])"}, {"sha": "65616d28d8f10aef2e4aad619c7f7a20c7bb4a07", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,39 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n-    LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n-    LintId::of(casts::AS_PTR_CAST_MUT),\n-    LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n-    LintId::of(copies::BRANCHES_SHARING_CODE),\n-    LintId::of(derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ),\n-    LintId::of(equatable_if_let::EQUATABLE_IF_LET),\n-    LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n-    LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),\n-    LintId::of(floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n-    LintId::of(future_not_send::FUTURE_NOT_SEND),\n-    LintId::of(index_refutable_slice::INDEX_REFUTABLE_SLICE),\n-    LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n-    LintId::of(matches::SIGNIFICANT_DROP_IN_SCRUTINEE),\n-    LintId::of(methods::ITER_ON_EMPTY_COLLECTIONS),\n-    LintId::of(methods::ITER_ON_SINGLE_ITEMS),\n-    LintId::of(methods::ITER_WITH_DRAIN),\n-    LintId::of(methods::PATH_BUF_PUSH_OVERWRITE),\n-    LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n-    LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n-    LintId::of(mutex_atomic::MUTEX_ATOMIC),\n-    LintId::of(mutex_atomic::MUTEX_INTEGER),\n-    LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n-    LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n-    LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n-    LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n-    LintId::of(regex::TRIVIAL_REGEX),\n-    LintId::of(strings::STRING_LIT_AS_BYTES),\n-    LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n-    LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n-    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n-    LintId::of(unused_peekable::UNUSED_PEEKABLE),\n-    LintId::of(unused_rounding::UNUSED_ROUNDING),\n-    LintId::of(use_self::USE_SELF),\n-])"}, {"sha": "44e969585b50d4f7459971c7bc4f755c9461458a", "filename": "src/tools/clippy/clippy_lints/src/lib.register_pedantic.rs", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,104 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n-    LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(casts::BORROW_AS_PTR),\n-    LintId::of(casts::CAST_LOSSLESS),\n-    LintId::of(casts::CAST_POSSIBLE_TRUNCATION),\n-    LintId::of(casts::CAST_POSSIBLE_WRAP),\n-    LintId::of(casts::CAST_PRECISION_LOSS),\n-    LintId::of(casts::CAST_PTR_ALIGNMENT),\n-    LintId::of(casts::CAST_SIGN_LOSS),\n-    LintId::of(casts::PTR_AS_PTR),\n-    LintId::of(checked_conversions::CHECKED_CONVERSIONS),\n-    LintId::of(copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n-    LintId::of(copy_iterator::COPY_ITERATOR),\n-    LintId::of(default::DEFAULT_TRAIT_ACCESS),\n-    LintId::of(dereference::EXPLICIT_DEREF_METHODS),\n-    LintId::of(dereference::REF_BINDING_TO_REFERENCE),\n-    LintId::of(derive::EXPL_IMPL_CLONE_ON_COPY),\n-    LintId::of(derive::UNSAFE_DERIVE_DESERIALIZE),\n-    LintId::of(doc::DOC_LINK_WITH_QUOTES),\n-    LintId::of(doc::DOC_MARKDOWN),\n-    LintId::of(doc::MISSING_ERRORS_DOC),\n-    LintId::of(doc::MISSING_PANICS_DOC),\n-    LintId::of(empty_enum::EMPTY_ENUM),\n-    LintId::of(enum_variants::MODULE_NAME_REPETITIONS),\n-    LintId::of(eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS),\n-    LintId::of(excessive_bools::FN_PARAMS_EXCESSIVE_BOOLS),\n-    LintId::of(excessive_bools::STRUCT_EXCESSIVE_BOOLS),\n-    LintId::of(format_args::UNINLINED_FORMAT_ARGS),\n-    LintId::of(functions::MUST_USE_CANDIDATE),\n-    LintId::of(functions::TOO_MANY_LINES),\n-    LintId::of(if_not_else::IF_NOT_ELSE),\n-    LintId::of(implicit_hasher::IMPLICIT_HASHER),\n-    LintId::of(inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n-    LintId::of(infinite_iter::MAYBE_INFINITE_ITER),\n-    LintId::of(invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n-    LintId::of(items_after_statements::ITEMS_AFTER_STATEMENTS),\n-    LintId::of(iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR),\n-    LintId::of(large_stack_arrays::LARGE_STACK_ARRAYS),\n-    LintId::of(let_underscore::LET_UNDERSCORE_DROP),\n-    LintId::of(literal_representation::LARGE_DIGIT_GROUPS),\n-    LintId::of(literal_representation::UNREADABLE_LITERAL),\n-    LintId::of(loops::EXPLICIT_INTO_ITER_LOOP),\n-    LintId::of(loops::EXPLICIT_ITER_LOOP),\n-    LintId::of(macro_use::MACRO_USE_IMPORTS),\n-    LintId::of(manual_assert::MANUAL_ASSERT),\n-    LintId::of(manual_instant_elapsed::MANUAL_INSTANT_ELAPSED),\n-    LintId::of(manual_string_new::MANUAL_STRING_NEW),\n-    LintId::of(matches::MATCH_BOOL),\n-    LintId::of(matches::MATCH_ON_VEC_ITEMS),\n-    LintId::of(matches::MATCH_SAME_ARMS),\n-    LintId::of(matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n-    LintId::of(matches::MATCH_WILD_ERR_ARM),\n-    LintId::of(matches::SINGLE_MATCH_ELSE),\n-    LintId::of(methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n-    LintId::of(methods::CLONED_INSTEAD_OF_COPIED),\n-    LintId::of(methods::FILTER_MAP_NEXT),\n-    LintId::of(methods::FLAT_MAP_OPTION),\n-    LintId::of(methods::FROM_ITER_INSTEAD_OF_COLLECT),\n-    LintId::of(methods::IMPLICIT_CLONE),\n-    LintId::of(methods::INEFFICIENT_TO_STRING),\n-    LintId::of(methods::MANUAL_OK_OR),\n-    LintId::of(methods::MAP_UNWRAP_OR),\n-    LintId::of(methods::NAIVE_BYTECOUNT),\n-    LintId::of(methods::STABLE_SORT_PRIMITIVE),\n-    LintId::of(methods::UNNECESSARY_JOIN),\n-    LintId::of(misc::USED_UNDERSCORE_BINDING),\n-    LintId::of(mismatching_type_param_order::MISMATCHING_TYPE_PARAM_ORDER),\n-    LintId::of(mut_mut::MUT_MUT),\n-    LintId::of(needless_continue::NEEDLESS_CONTINUE),\n-    LintId::of(needless_for_each::NEEDLESS_FOR_EACH),\n-    LintId::of(needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n-    LintId::of(no_effect::NO_EFFECT_UNDERSCORE_BINDING),\n-    LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n-    LintId::of(non_expressive_names::SIMILAR_NAMES),\n-    LintId::of(operators::FLOAT_CMP),\n-    LintId::of(operators::NEEDLESS_BITWISE_BOOL),\n-    LintId::of(operators::VERBOSE_BIT_MASK),\n-    LintId::of(pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n-    LintId::of(pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n-    LintId::of(ranges::RANGE_MINUS_ONE),\n-    LintId::of(ranges::RANGE_PLUS_ONE),\n-    LintId::of(redundant_else::REDUNDANT_ELSE),\n-    LintId::of(ref_option_ref::REF_OPTION_REF),\n-    LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n-    LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n-    LintId::of(strings::STRING_ADD_ASSIGN),\n-    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n-    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-    LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n-    LintId::of(types::LINKEDLIST),\n-    LintId::of(types::OPTION_OPTION),\n-    LintId::of(unicode::UNICODE_NOT_NFC),\n-    LintId::of(unnecessary_wraps::UNNECESSARY_WRAPS),\n-    LintId::of(unnested_or_patterns::UNNESTED_OR_PATTERNS),\n-    LintId::of(unused_async::UNUSED_ASYNC),\n-    LintId::of(unused_self::UNUSED_SELF),\n-    LintId::of(wildcard_imports::ENUM_GLOB_USE),\n-    LintId::of(wildcard_imports::WILDCARD_IMPORTS),\n-    LintId::of(zero_sized_map_values::ZERO_SIZED_MAP_VALUES),\n-])"}, {"sha": "8e927470e02ffea36f947a6133ba0dacb98f4226", "filename": "src/tools/clippy/clippy_lints/src/lib.register_perf.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,34 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n-    LintId::of(box_default::BOX_DEFAULT),\n-    LintId::of(entry::MAP_ENTRY),\n-    LintId::of(escape::BOXED_LOCAL),\n-    LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n-    LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n-    LintId::of(functions::RESULT_LARGE_ERR),\n-    LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n-    LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n-    LintId::of(loops::MANUAL_MEMCPY),\n-    LintId::of(loops::MISSING_SPIN_LOOP),\n-    LintId::of(loops::NEEDLESS_COLLECT),\n-    LintId::of(manual_retain::MANUAL_RETAIN),\n-    LintId::of(methods::COLLAPSIBLE_STR_REPLACE),\n-    LintId::of(methods::EXPECT_FUN_CALL),\n-    LintId::of(methods::EXTEND_WITH_DRAIN),\n-    LintId::of(methods::ITER_NTH),\n-    LintId::of(methods::ITER_OVEREAGER_CLONED),\n-    LintId::of(methods::MANUAL_STR_REPEAT),\n-    LintId::of(methods::OR_FUN_CALL),\n-    LintId::of(methods::SINGLE_CHAR_PATTERN),\n-    LintId::of(methods::UNNECESSARY_TO_OWNED),\n-    LintId::of(operators::CMP_OWNED),\n-    LintId::of(redundant_clone::REDUNDANT_CLONE),\n-    LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n-    LintId::of(types::BOX_COLLECTION),\n-    LintId::of(types::REDUNDANT_ALLOCATION),\n-    LintId::of(vec::USELESS_VEC),\n-    LintId::of(vec_init_then_push::VEC_INIT_THEN_PUSH),\n-])"}, {"sha": "f62d57af5b47f1aed2849a352043102bb818b5cc", "filename": "src/tools/clippy/clippy_lints/src/lib.register_restriction.rs", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,90 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n-    LintId::of(as_conversions::AS_CONVERSIONS),\n-    LintId::of(asm_syntax::INLINE_ASM_X86_ATT_SYNTAX),\n-    LintId::of(asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n-    LintId::of(assertions_on_result_states::ASSERTIONS_ON_RESULT_STATES),\n-    LintId::of(attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON),\n-    LintId::of(casts::AS_UNDERSCORE),\n-    LintId::of(casts::FN_TO_NUMERIC_CAST_ANY),\n-    LintId::of(create_dir::CREATE_DIR),\n-    LintId::of(dbg_macro::DBG_MACRO),\n-    LintId::of(default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n-    LintId::of(default_union_representation::DEFAULT_UNION_REPRESENTATION),\n-    LintId::of(disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS),\n-    LintId::of(else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n-    LintId::of(empty_drop::EMPTY_DROP),\n-    LintId::of(empty_structs_with_brackets::EMPTY_STRUCTS_WITH_BRACKETS),\n-    LintId::of(exhaustive_items::EXHAUSTIVE_ENUMS),\n-    LintId::of(exhaustive_items::EXHAUSTIVE_STRUCTS),\n-    LintId::of(exit::EXIT),\n-    LintId::of(float_literal::LOSSY_FLOAT_LITERAL),\n-    LintId::of(format_push_string::FORMAT_PUSH_STRING),\n-    LintId::of(if_then_some_else_none::IF_THEN_SOME_ELSE_NONE),\n-    LintId::of(implicit_return::IMPLICIT_RETURN),\n-    LintId::of(indexing_slicing::INDEXING_SLICING),\n-    LintId::of(inherent_impl::MULTIPLE_INHERENT_IMPL),\n-    LintId::of(large_include_file::LARGE_INCLUDE_FILE),\n-    LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n-    LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n-    LintId::of(matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n-    LintId::of(matches::TRY_ERR),\n-    LintId::of(matches::WILDCARD_ENUM_MATCH_ARM),\n-    LintId::of(mem_forget::MEM_FORGET),\n-    LintId::of(methods::CLONE_ON_REF_PTR),\n-    LintId::of(methods::EXPECT_USED),\n-    LintId::of(methods::FILETYPE_IS_FILE),\n-    LintId::of(methods::GET_UNWRAP),\n-    LintId::of(methods::MAP_ERR_IGNORE),\n-    LintId::of(methods::UNWRAP_USED),\n-    LintId::of(methods::VERBOSE_FILE_READS),\n-    LintId::of(misc_early::SEPARATED_LITERAL_SUFFIX),\n-    LintId::of(misc_early::UNNEEDED_FIELD_PATTERN),\n-    LintId::of(misc_early::UNSEPARATED_LITERAL_SUFFIX),\n-    LintId::of(missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS),\n-    LintId::of(missing_enforced_import_rename::MISSING_ENFORCED_IMPORT_RENAMES),\n-    LintId::of(missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS),\n-    LintId::of(missing_trait_methods::MISSING_TRAIT_METHODS),\n-    LintId::of(mixed_read_write_in_expression::MIXED_READ_WRITE_IN_EXPRESSION),\n-    LintId::of(module_style::MOD_MODULE_FILES),\n-    LintId::of(module_style::SELF_NAMED_MODULE_FILES),\n-    LintId::of(operators::ARITHMETIC_SIDE_EFFECTS),\n-    LintId::of(operators::FLOAT_ARITHMETIC),\n-    LintId::of(operators::FLOAT_CMP_CONST),\n-    LintId::of(operators::INTEGER_ARITHMETIC),\n-    LintId::of(operators::INTEGER_DIVISION),\n-    LintId::of(operators::MODULO_ARITHMETIC),\n-    LintId::of(panic_in_result_fn::PANIC_IN_RESULT_FN),\n-    LintId::of(panic_unimplemented::PANIC),\n-    LintId::of(panic_unimplemented::TODO),\n-    LintId::of(panic_unimplemented::UNIMPLEMENTED),\n-    LintId::of(panic_unimplemented::UNREACHABLE),\n-    LintId::of(partial_pub_fields::PARTIAL_PUB_FIELDS),\n-    LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n-    LintId::of(pub_use::PUB_USE),\n-    LintId::of(redundant_slicing::DEREF_BY_SLICING),\n-    LintId::of(same_name_method::SAME_NAME_METHOD),\n-    LintId::of(shadow::SHADOW_REUSE),\n-    LintId::of(shadow::SHADOW_SAME),\n-    LintId::of(shadow::SHADOW_UNRELATED),\n-    LintId::of(single_char_lifetime_names::SINGLE_CHAR_LIFETIME_NAMES),\n-    LintId::of(std_instead_of_core::ALLOC_INSTEAD_OF_CORE),\n-    LintId::of(std_instead_of_core::STD_INSTEAD_OF_ALLOC),\n-    LintId::of(std_instead_of_core::STD_INSTEAD_OF_CORE),\n-    LintId::of(strings::STRING_ADD),\n-    LintId::of(strings::STRING_SLICE),\n-    LintId::of(strings::STRING_TO_STRING),\n-    LintId::of(strings::STR_TO_STRING),\n-    LintId::of(types::RC_BUFFER),\n-    LintId::of(types::RC_MUTEX),\n-    LintId::of(undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS),\n-    LintId::of(unicode::NON_ASCII_LITERAL),\n-    LintId::of(unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS),\n-    LintId::of(unwrap_in_result::UNWRAP_IN_RESULT),\n-    LintId::of(write::PRINT_STDERR),\n-    LintId::of(write::PRINT_STDOUT),\n-    LintId::of(write::USE_DEBUG),\n-])"}, {"sha": "3312f5648552ee914299c4b2e17532d2584c619d", "filename": "src/tools/clippy/clippy_lints/src/lib.register_style.rs", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,131 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n-    LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n-    LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n-    LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n-    LintId::of(bool_to_int_with_if::BOOL_TO_INT_WITH_IF),\n-    LintId::of(casts::FN_TO_NUMERIC_CAST),\n-    LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n-    LintId::of(collapsible_if::COLLAPSIBLE_ELSE_IF),\n-    LintId::of(collapsible_if::COLLAPSIBLE_IF),\n-    LintId::of(comparison_chain::COMPARISON_CHAIN),\n-    LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n-    LintId::of(default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY),\n-    LintId::of(dereference::NEEDLESS_BORROW),\n-    LintId::of(disallowed_macros::DISALLOWED_MACROS),\n-    LintId::of(disallowed_methods::DISALLOWED_METHODS),\n-    LintId::of(disallowed_names::DISALLOWED_NAMES),\n-    LintId::of(disallowed_types::DISALLOWED_TYPES),\n-    LintId::of(doc::MISSING_SAFETY_DOC),\n-    LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n-    LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n-    LintId::of(enum_variants::MODULE_INCEPTION),\n-    LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n-    LintId::of(float_literal::EXCESSIVE_PRECISION),\n-    LintId::of(from_over_into::FROM_OVER_INTO),\n-    LintId::of(from_str_radix_10::FROM_STR_RADIX_10),\n-    LintId::of(functions::DOUBLE_MUST_USE),\n-    LintId::of(functions::MUST_USE_UNIT),\n-    LintId::of(functions::RESULT_UNIT_ERR),\n-    LintId::of(implicit_saturating_add::IMPLICIT_SATURATING_ADD),\n-    LintId::of(implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n-    LintId::of(inherent_to_string::INHERENT_TO_STRING),\n-    LintId::of(init_numbered_fields::INIT_NUMBERED_FIELDS),\n-    LintId::of(len_zero::COMPARISON_TO_EMPTY),\n-    LintId::of(len_zero::LEN_WITHOUT_IS_EMPTY),\n-    LintId::of(len_zero::LEN_ZERO),\n-    LintId::of(literal_representation::INCONSISTENT_DIGIT_GROUPING),\n-    LintId::of(literal_representation::UNUSUAL_BYTE_GROUPINGS),\n-    LintId::of(loops::FOR_KV_MAP),\n-    LintId::of(loops::NEEDLESS_RANGE_LOOP),\n-    LintId::of(loops::SAME_ITEM_PUSH),\n-    LintId::of(loops::WHILE_LET_ON_ITERATOR),\n-    LintId::of(main_recursion::MAIN_RECURSION),\n-    LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n-    LintId::of(manual_bits::MANUAL_BITS),\n-    LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n-    LintId::of(match_result_ok::MATCH_RESULT_OK),\n-    LintId::of(matches::COLLAPSIBLE_MATCH),\n-    LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n-    LintId::of(matches::MANUAL_MAP),\n-    LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),\n-    LintId::of(matches::MATCH_OVERLAPPING_ARM),\n-    LintId::of(matches::MATCH_REF_PATS),\n-    LintId::of(matches::REDUNDANT_PATTERN_MATCHING),\n-    LintId::of(matches::SINGLE_MATCH),\n-    LintId::of(mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n-    LintId::of(mem_replace::MEM_REPLACE_WITH_DEFAULT),\n-    LintId::of(methods::BYTES_NTH),\n-    LintId::of(methods::CHARS_LAST_CMP),\n-    LintId::of(methods::CHARS_NEXT_CMP),\n-    LintId::of(methods::ERR_EXPECT),\n-    LintId::of(methods::GET_FIRST),\n-    LintId::of(methods::INTO_ITER_ON_REF),\n-    LintId::of(methods::IS_DIGIT_ASCII_RADIX),\n-    LintId::of(methods::ITER_CLONED_COLLECT),\n-    LintId::of(methods::ITER_NEXT_SLICE),\n-    LintId::of(methods::ITER_NTH_ZERO),\n-    LintId::of(methods::ITER_SKIP_NEXT),\n-    LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n-    LintId::of(methods::MAP_CLONE),\n-    LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n-    LintId::of(methods::MUT_MUTEX_LOCK),\n-    LintId::of(methods::NEW_RET_NO_SELF),\n-    LintId::of(methods::OBFUSCATED_IF_ELSE),\n-    LintId::of(methods::OK_EXPECT),\n-    LintId::of(methods::OPTION_MAP_OR_NONE),\n-    LintId::of(methods::RESULT_MAP_OR_INTO_OPTION),\n-    LintId::of(methods::SHOULD_IMPLEMENT_TRAIT),\n-    LintId::of(methods::SINGLE_CHAR_ADD_STR),\n-    LintId::of(methods::STRING_EXTEND_CHARS),\n-    LintId::of(methods::UNNECESSARY_FOLD),\n-    LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n-    LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n-    LintId::of(methods::WRONG_SELF_CONVENTION),\n-    LintId::of(misc::TOPLEVEL_REF_ARG),\n-    LintId::of(misc::ZERO_PTR),\n-    LintId::of(misc_early::BUILTIN_TYPE_SHADOW),\n-    LintId::of(misc_early::DOUBLE_NEG),\n-    LintId::of(misc_early::DUPLICATE_UNDERSCORE_ARGUMENT),\n-    LintId::of(misc_early::MIXED_CASE_HEX_LITERALS),\n-    LintId::of(misc_early::REDUNDANT_PATTERN),\n-    LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n-    LintId::of(needless_late_init::NEEDLESS_LATE_INIT),\n-    LintId::of(needless_parens_on_range_literals::NEEDLESS_PARENS_ON_RANGE_LITERALS),\n-    LintId::of(neg_multiply::NEG_MULTIPLY),\n-    LintId::of(new_without_default::NEW_WITHOUT_DEFAULT),\n-    LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n-    LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n-    LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n-    LintId::of(operators::ASSIGN_OP_PATTERN),\n-    LintId::of(operators::OP_REF),\n-    LintId::of(operators::PTR_EQ),\n-    LintId::of(partialeq_to_none::PARTIALEQ_TO_NONE),\n-    LintId::of(ptr::CMP_NULL),\n-    LintId::of(ptr::PTR_ARG),\n-    LintId::of(question_mark::QUESTION_MARK),\n-    LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n-    LintId::of(redundant_field_names::REDUNDANT_FIELD_NAMES),\n-    LintId::of(redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n-    LintId::of(returns::LET_AND_RETURN),\n-    LintId::of(returns::NEEDLESS_RETURN),\n-    LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n-    LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n-    LintId::of(strings::TRIM_SPLIT_WHITESPACE),\n-    LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n-    LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n-    LintId::of(unit_types::LET_UNIT_VALUE),\n-    LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n-    LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n-    LintId::of(unused_unit::UNUSED_UNIT),\n-    LintId::of(upper_case_acronyms::UPPER_CASE_ACRONYMS),\n-    LintId::of(write::PRINTLN_EMPTY_STRING),\n-    LintId::of(write::PRINT_LITERAL),\n-    LintId::of(write::PRINT_WITH_NEWLINE),\n-    LintId::of(write::WRITELN_EMPTY_STRING),\n-    LintId::of(write::WRITE_LITERAL),\n-    LintId::of(write::WRITE_WITH_NEWLINE),\n-])"}, {"sha": "b70c4bb73e57d129bbf291c7d6220f428e877a55", "filename": "src/tools/clippy/clippy_lints/src/lib.register_suspicious.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,38 +0,0 @@\n-// This file was generated by `cargo dev update_lints`.\n-// Use that command to update this file and do not edit by hand.\n-// Manual edits will be overwritten.\n-\n-store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec![\n-    LintId::of(almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE),\n-    LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n-    LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n-    LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n-    LintId::of(casts::CAST_ENUM_TRUNCATION),\n-    LintId::of(casts::CAST_NAN_TO_INT),\n-    LintId::of(casts::CAST_SLICE_FROM_RAW_PARTS),\n-    LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n-    LintId::of(drop_forget_ref::DROP_NON_DROP),\n-    LintId::of(drop_forget_ref::FORGET_NON_DROP),\n-    LintId::of(duplicate_mod::DUPLICATE_MOD),\n-    LintId::of(format_impl::PRINT_IN_FORMAT_IMPL),\n-    LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n-    LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n-    LintId::of(formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n-    LintId::of(loops::EMPTY_LOOP),\n-    LintId::of(loops::MUT_RANGE_BOUND),\n-    LintId::of(methods::NO_EFFECT_REPLACE),\n-    LintId::of(methods::SUSPICIOUS_MAP),\n-    LintId::of(methods::SUSPICIOUS_TO_OWNED),\n-    LintId::of(multi_assignments::MULTI_ASSIGNMENTS),\n-    LintId::of(mut_key::MUTABLE_KEY_TYPE),\n-    LintId::of(octal_escapes::OCTAL_ESCAPES),\n-    LintId::of(operators::FLOAT_EQUALITY_WITHOUT_ABS),\n-    LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n-    LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n-    LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n-    LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n-    LintId::of(swap_ptr_to_ref::SWAP_PTR_TO_REF),\n-])"}, {"sha": "b481314abedc8b8f91178583863b2e5253a32ed6", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 135, "deletions": 132, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -32,8 +32,8 @@ extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_analysis;\n-extern crate rustc_hir_typeck;\n extern crate rustc_hir_pretty;\n+extern crate rustc_hir_typeck;\n extern crate rustc_index;\n extern crate rustc_infer;\n extern crate rustc_lexer;\n@@ -47,122 +47,24 @@ extern crate rustc_trait_selection;\n \n #[macro_use]\n extern crate clippy_utils;\n+#[macro_use]\n+extern crate declare_clippy_lint;\n+\n+use std::io;\n+use std::path::PathBuf;\n \n use clippy_utils::parse_msrv;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_lint::LintId;\n+use rustc_lint::{Lint, LintId};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n \n-/// Macro used to declare a Clippy lint.\n-///\n-/// Every lint declaration consists of 4 parts:\n-///\n-/// 1. The documentation, which is used for the website\n-/// 2. The `LINT_NAME`. See [lint naming][lint_naming] on lint naming conventions.\n-/// 3. The `lint_level`, which is a mapping from *one* of our lint groups to `Allow`, `Warn` or\n-///    `Deny`. The lint level here has nothing to do with what lint groups the lint is a part of.\n-/// 4. The `description` that contains a short explanation on what's wrong with code where the\n-///    lint is triggered.\n-///\n-/// Currently the categories `style`, `correctness`, `suspicious`, `complexity` and `perf` are\n-/// enabled by default. As said in the README.md of this repository, if the lint level mapping\n-/// changes, please update README.md.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(rustc_private)]\n-/// extern crate rustc_session;\n-/// use rustc_session::declare_tool_lint;\n-/// use clippy_lints::declare_clippy_lint;\n-///\n-/// declare_clippy_lint! {\n-///     /// ### What it does\n-///     /// Checks for ... (describe what the lint matches).\n-///     ///\n-///     /// ### Why is this bad?\n-///     /// Supply the reason for linting the code.\n-///     ///\n-///     /// ### Example\n-///     /// ```rust\n-///     /// Insert a short example of code that triggers the lint\n-///     /// ```\n-///     ///\n-///     /// Use instead:\n-///     /// ```rust\n-///     /// Insert a short example of improved code that doesn't trigger the lint\n-///     /// ```\n-///     pub LINT_NAME,\n-///     pedantic,\n-///     \"description\"\n-/// }\n-/// ```\n-/// [lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n-#[macro_export]\n-macro_rules! declare_clippy_lint {\n-    { $(#[$attr:meta])* pub $name:tt, style, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, correctness, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Deny, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, suspicious, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, complexity, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, perf, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, pedantic, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, restriction, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, cargo, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, nursery, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, internal, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, internal_warn, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n-}\n-\n #[cfg(feature = \"internal\")]\n pub mod deprecated_lints;\n #[cfg_attr(feature = \"internal\", allow(clippy::missing_clippy_version_attribute))]\n mod utils;\n \n+mod declared_lints;\n mod renamed_lints;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n@@ -231,6 +133,7 @@ mod format_impl;\n mod format_push_string;\n mod formatting;\n mod from_over_into;\n+mod from_raw_with_void_ptr;\n mod from_str_radix_10;\n mod functions;\n mod future_not_send;\n@@ -249,6 +152,7 @@ mod inherent_impl;\n mod inherent_to_string;\n mod init_numbered_fields;\n mod inline_fn_without_body;\n+mod instant_subtraction;\n mod int_plus_one;\n mod invalid_upcast_comparisons;\n mod invalid_utf8_in_unchecked;\n@@ -270,7 +174,8 @@ mod manual_assert;\n mod manual_async_fn;\n mod manual_bits;\n mod manual_clamp;\n-mod manual_instant_elapsed;\n+mod manual_is_ascii_check;\n+mod manual_let_else;\n mod manual_non_exhaustive;\n mod manual_rem_euclid;\n mod manual_retain;\n@@ -365,6 +270,7 @@ mod strings;\n mod strlen_on_c_strings;\n mod suspicious_operation_groupings;\n mod suspicious_trait_impl;\n+mod suspicious_xor_used_as_pow;\n mod swap;\n mod swap_ptr_to_ref;\n mod tabs_in_doc_comments;\n@@ -404,8 +310,8 @@ mod zero_div_zero;\n mod zero_sized_map_values;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n \n-pub use crate::utils::conf::Conf;\n use crate::utils::conf::{format_error, TryConf};\n+pub use crate::utils::conf::{lookup_conf_file, Conf};\n \n /// Register all pre expansion lints\n ///\n@@ -462,8 +368,8 @@ fn read_msrv(conf: &Conf, sess: &Session) -> Option<RustcVersion> {\n }\n \n #[doc(hidden)]\n-pub fn read_conf(sess: &Session) -> Conf {\n-    let file_name = match utils::conf::lookup_conf_file() {\n+pub fn read_conf(sess: &Session, path: &io::Result<Option<PathBuf>>) -> Conf {\n+    let file_name = match path {\n         Ok(Some(path)) => path,\n         Ok(None) => return Conf::default(),\n         Err(error) => {\n@@ -473,7 +379,7 @@ pub fn read_conf(sess: &Session) -> Conf {\n         },\n     };\n \n-    let TryConf { conf, errors, warnings } = utils::conf::read(&file_name);\n+    let TryConf { conf, errors, warnings } = utils::conf::read(file_name);\n     // all conf errors are non-fatal, we just use the default conf in case of error\n     for error in errors {\n         sess.err(format!(\n@@ -495,31 +401,121 @@ pub fn read_conf(sess: &Session) -> Conf {\n     conf\n }\n \n+#[derive(Default)]\n+struct RegistrationGroups {\n+    all: Vec<LintId>,\n+    cargo: Vec<LintId>,\n+    complexity: Vec<LintId>,\n+    correctness: Vec<LintId>,\n+    nursery: Vec<LintId>,\n+    pedantic: Vec<LintId>,\n+    perf: Vec<LintId>,\n+    restriction: Vec<LintId>,\n+    style: Vec<LintId>,\n+    suspicious: Vec<LintId>,\n+    #[cfg(feature = \"internal\")]\n+    internal: Vec<LintId>,\n+}\n+\n+impl RegistrationGroups {\n+    #[rustfmt::skip]\n+    fn register(self, store: &mut rustc_lint::LintStore) {\n+        store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), self.all);\n+        store.register_group(true, \"clippy::cargo\", Some(\"clippy_cargo\"), self.cargo);\n+        store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), self.complexity);\n+        store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), self.correctness);\n+        store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), self.nursery);\n+        store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), self.pedantic);\n+        store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), self.perf);\n+        store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), self.restriction);\n+        store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), self.style);\n+        store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), self.suspicious);\n+        #[cfg(feature = \"internal\")]\n+        store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), self.internal);\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub(crate) enum LintCategory {\n+    Cargo,\n+    Complexity,\n+    Correctness,\n+    Nursery,\n+    Pedantic,\n+    Perf,\n+    Restriction,\n+    Style,\n+    Suspicious,\n+    #[cfg(feature = \"internal\")]\n+    Internal,\n+}\n+#[allow(clippy::enum_glob_use)]\n+use LintCategory::*;\n+\n+impl LintCategory {\n+    fn is_all(self) -> bool {\n+        matches!(self, Correctness | Suspicious | Style | Complexity | Perf)\n+    }\n+\n+    fn group(self, groups: &mut RegistrationGroups) -> &mut Vec<LintId> {\n+        match self {\n+            Cargo => &mut groups.cargo,\n+            Complexity => &mut groups.complexity,\n+            Correctness => &mut groups.correctness,\n+            Nursery => &mut groups.nursery,\n+            Pedantic => &mut groups.pedantic,\n+            Perf => &mut groups.perf,\n+            Restriction => &mut groups.restriction,\n+            Style => &mut groups.style,\n+            Suspicious => &mut groups.suspicious,\n+            #[cfg(feature = \"internal\")]\n+            Internal => &mut groups.internal,\n+        }\n+    }\n+}\n+\n+pub(crate) struct LintInfo {\n+    /// Double reference to maintain pointer equality\n+    lint: &'static &'static Lint,\n+    category: LintCategory,\n+    explanation: &'static str,\n+}\n+\n+pub fn explain(name: &str) {\n+    let target = format!(\"clippy::{}\", name.to_ascii_uppercase());\n+    match declared_lints::LINTS.iter().find(|info| info.lint.name == target) {\n+        Some(info) => print!(\"{}\", info.explanation),\n+        None => println!(\"unknown lint: {name}\"),\n+    }\n+}\n+\n+fn register_categories(store: &mut rustc_lint::LintStore) {\n+    let mut groups = RegistrationGroups::default();\n+\n+    for LintInfo { lint, category, .. } in declared_lints::LINTS {\n+        if category.is_all() {\n+            groups.all.push(LintId::of(lint));\n+        }\n+\n+        category.group(&mut groups).push(LintId::of(lint));\n+    }\n+\n+    let lints: Vec<&'static Lint> = declared_lints::LINTS.iter().map(|info| *info.lint).collect();\n+\n+    store.register_lints(&lints);\n+    groups.register(store);\n+}\n+\n /// Register all lints and lint groups with the rustc plugin registry\n ///\n /// Used in `./src/driver.rs`.\n #[expect(clippy::too_many_lines)]\n pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf: &Conf) {\n     register_removed_non_tool_lints(store);\n+    register_categories(store);\n \n     include!(\"lib.deprecated.rs\");\n \n-    include!(\"lib.register_lints.rs\");\n-    include!(\"lib.register_restriction.rs\");\n-    include!(\"lib.register_pedantic.rs\");\n-\n-    #[cfg(feature = \"internal\")]\n-    include!(\"lib.register_internal.rs\");\n-\n-    include!(\"lib.register_all.rs\");\n-    include!(\"lib.register_style.rs\");\n-    include!(\"lib.register_complexity.rs\");\n-    include!(\"lib.register_correctness.rs\");\n-    include!(\"lib.register_suspicious.rs\");\n-    include!(\"lib.register_perf.rs\");\n-    include!(\"lib.register_cargo.rs\");\n-    include!(\"lib.register_nursery.rs\");\n-\n     #[cfg(feature = \"internal\")]\n     {\n         if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n@@ -614,6 +610,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     store.register_late_pass(move |_| Box::new(matches::Matches::new(msrv)));\n+    let matches_for_let_else = conf.matches_for_let_else;\n+    store.register_late_pass(move |_| Box::new(manual_let_else::ManualLetElse::new(msrv, matches_for_let_else)));\n     store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n     store.register_late_pass(move |_| Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n     store.register_late_pass(move |_| Box::new(manual_strip::ManualStrip::new(msrv)));\n@@ -735,7 +733,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let max_trait_bounds = conf.max_trait_bounds;\n     store.register_late_pass(move |_| Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n     store.register_late_pass(|_| Box::new(comparison_chain::ComparisonChain));\n-    store.register_late_pass(|_| Box::new(mut_key::MutableKeyType));\n+    let ignore_interior_mutability = conf.ignore_interior_mutability.clone();\n+    store.register_late_pass(move |_| Box::new(mut_key::MutableKeyType::new(ignore_interior_mutability.clone())));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n     store.register_late_pass(|_| Box::new(format_impl::FormatImpl::new()));\n@@ -794,10 +793,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(floating_point_arithmetic::FloatingPointArithmetic));\n     store.register_early_pass(|| Box::new(as_conversions::AsConversions));\n     store.register_late_pass(|_| Box::new(let_underscore::LetUnderscore));\n-    store.register_early_pass(|| Box::new(single_component_path_imports::SingleComponentPathImports));\n+    store.register_early_pass(|| Box::<single_component_path_imports::SingleComponentPathImports>::default());\n     let max_fn_params_bools = conf.max_fn_params_bools;\n     let max_struct_bools = conf.max_struct_bools;\n-    store.register_early_pass(move || {\n+    store.register_late_pass(move |_| {\n         Box::new(excessive_bools::ExcessiveBools::new(\n             max_struct_bools,\n             max_fn_params_bools,\n@@ -879,13 +878,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::<only_used_in_recursion::OnlyUsedInRecursion>::default());\n     let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n     store.register_late_pass(move |_| Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n+    let allow_print_in_tests = conf.allow_print_in_tests;\n+    store.register_late_pass(move |_| Box::new(write::Write::new(allow_print_in_tests)));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n     store.register_late_pass(move |_| {\n         Box::new(cargo::Cargo {\n             ignore_publish: cargo_ignore_publish,\n         })\n     });\n-    store.register_late_pass(|_| Box::<write::Write>::default());\n     store.register_early_pass(|| Box::new(crate_in_macro_def::CrateInMacroDef));\n     store.register_early_pass(|| Box::new(empty_structs_with_brackets::EmptyStructsWithBrackets));\n     store.register_late_pass(|_| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));\n@@ -908,7 +908,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move |_| Box::new(operators::Operators::new(verbose_bit_mask_threshold)));\n     store.register_late_pass(|_| Box::new(invalid_utf8_in_unchecked::InvalidUtf8InUnchecked));\n     store.register_late_pass(|_| Box::<std_instead_of_core::StdReexports>::default());\n-    store.register_late_pass(|_| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n+    store.register_late_pass(move |_| Box::new(instant_subtraction::InstantSubtraction::new(msrv)));\n     store.register_late_pass(|_| Box::new(partialeq_to_none::PartialeqToNone));\n     store.register_late_pass(move |_| Box::new(manual_clamp::ManualClamp::new(msrv)));\n     store.register_late_pass(|_| Box::new(manual_string_new::ManualStringNew));\n@@ -919,6 +919,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(implicit_saturating_add::ImplicitSaturatingAdd));\n     store.register_early_pass(|| Box::new(partial_pub_fields::PartialPubFields));\n     store.register_late_pass(|_| Box::new(missing_trait_methods::MissingTraitMethods));\n+    store.register_late_pass(|_| Box::new(from_raw_with_void_ptr::FromRawWithVoidPtr));\n+    store.register_late_pass(|_| Box::new(suspicious_xor_used_as_pow::ConfusingXorAndPow));\n+    store.register_late_pass(move |_| Box::new(manual_is_ascii_check::ManualIsAsciiCheck::new(msrv)));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "0bb9eca15287d13256f863186e68ea0067638e07", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 88, "deletions": 43, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::intravisit::nested_filter::{self as hir_nested_filter, NestedFilter};\n@@ -152,6 +152,7 @@ fn check_fn_inner<'tcx>(\n         .params\n         .iter()\n         .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n+\n     for typ in types {\n         for pred in generics.bounds_for_param(cx.tcx.hir().local_def_id(typ.hir_id)) {\n             if pred.origin == PredicateOrigin::WhereClause {\n@@ -188,15 +189,30 @@ fn check_fn_inner<'tcx>(\n             }\n         }\n     }\n-    if could_use_elision(cx, decl, body, trait_sig, generics.params) {\n-        span_lint(\n+\n+    if let Some(elidable_lts) = could_use_elision(cx, decl, body, trait_sig, generics.params) {\n+        let lts = elidable_lts\n+            .iter()\n+            // In principle, the result of the call to `Node::ident` could be `unwrap`ped, as `DefId` should refer to a\n+            // `Node::GenericParam`.\n+            .filter_map(|&(def_id, _)| cx.tcx.hir().get_by_def_id(def_id).ident())\n+            .map(|ident| ident.to_string())\n+            .collect::<Vec<_>>()\n+            .join(\", \");\n+\n+        span_lint_and_then(\n             cx,\n             NEEDLESS_LIFETIMES,\n             span.with_hi(decl.output.span().hi()),\n-            \"explicit lifetimes given in parameter types where they could be elided \\\n-             (or replaced with `'_` if needed by type declaration)\",\n+            &format!(\"the following explicit lifetimes could be elided: {lts}\"),\n+            |diag| {\n+                if let Some(span) = elidable_lts.iter().find_map(|&(_, span)| span) {\n+                    diag.span_help(span, \"replace with `'_` in generic arguments such as here\");\n+                }\n+            },\n         );\n     }\n+\n     if report_extra_lifetimes {\n         self::report_extra_lifetimes(cx, decl, generics);\n     }\n@@ -227,7 +243,7 @@ fn could_use_elision<'tcx>(\n     body: Option<BodyId>,\n     trait_sig: Option<&[Ident]>,\n     named_generics: &'tcx [GenericParam<'_>],\n-) -> bool {\n+) -> Option<Vec<(LocalDefId, Option<Span>)>> {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -254,15 +270,15 @@ fn could_use_elision<'tcx>(\n     }\n \n     if input_visitor.abort() || output_visitor.abort() {\n-        return false;\n+        return None;\n     }\n \n     let input_lts = input_visitor.lts;\n     let output_lts = output_visitor.lts;\n \n     if let Some(trait_sig) = trait_sig {\n         if explicit_self_type(cx, func, trait_sig.first().copied()) {\n-            return false;\n+            return None;\n         }\n     }\n \n@@ -271,22 +287,22 @@ fn could_use_elision<'tcx>(\n \n         let first_ident = body.params.first().and_then(|param| param.pat.simple_ident());\n         if explicit_self_type(cx, func, first_ident) {\n-            return false;\n+            return None;\n         }\n \n         let mut checker = BodyLifetimeChecker {\n             lifetimes_used_in_body: false,\n         };\n         checker.visit_expr(body.value);\n         if checker.lifetimes_used_in_body {\n-            return false;\n+            return None;\n         }\n     }\n \n     // check for lifetimes from higher scopes\n     for lt in input_lts.iter().chain(output_lts.iter()) {\n         if !allowed_lts.contains(lt) {\n-            return false;\n+            return None;\n         }\n     }\n \n@@ -302,48 +318,45 @@ fn could_use_elision<'tcx>(\n         for lt in input_visitor.nested_elision_site_lts {\n             if let RefLt::Named(def_id) = lt {\n                 if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n-                    return false;\n+                    return None;\n                 }\n             }\n         }\n         for lt in output_visitor.nested_elision_site_lts {\n             if let RefLt::Named(def_id) = lt {\n                 if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n-                    return false;\n+                    return None;\n                 }\n             }\n         }\n     }\n \n-    // no input lifetimes? easy case!\n-    if input_lts.is_empty() {\n-        false\n-    } else if output_lts.is_empty() {\n-        // no output lifetimes, check distinctness of input lifetimes\n+    // A lifetime can be newly elided if:\n+    // - It occurs only once among the inputs.\n+    // - If there are multiple input lifetimes, then the newly elided lifetime does not occur among the\n+    //   outputs (because eliding such an lifetime would create an ambiguity).\n+    let elidable_lts = named_lifetime_occurrences(&input_lts)\n+        .into_iter()\n+        .filter_map(|(def_id, occurrences)| {\n+            if occurrences == 1 && (input_lts.len() == 1 || !output_lts.contains(&RefLt::Named(def_id))) {\n+                Some((\n+                    def_id,\n+                    input_visitor\n+                        .lifetime_generic_arg_spans\n+                        .get(&def_id)\n+                        .or_else(|| output_visitor.lifetime_generic_arg_spans.get(&def_id))\n+                        .copied(),\n+                ))\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>();\n \n-        // only unnamed and static, ok\n-        let unnamed_and_static = input_lts.iter().all(|lt| *lt == RefLt::Unnamed || *lt == RefLt::Static);\n-        if unnamed_and_static {\n-            return false;\n-        }\n-        // we have no output reference, so we only need all distinct lifetimes\n-        input_lts.len() == unique_lifetimes(&input_lts)\n+    if elidable_lts.is_empty() {\n+        None\n     } else {\n-        // we have output references, so we need one input reference,\n-        // and all output lifetimes must be the same\n-        if unique_lifetimes(&output_lts) > 1 {\n-            return false;\n-        }\n-        if input_lts.len() == 1 {\n-            match (&input_lts[0], &output_lts[0]) {\n-                (&RefLt::Named(n1), &RefLt::Named(n2)) if n1 == n2 => true,\n-                (&RefLt::Named(_), &RefLt::Unnamed) => true,\n-                _ => false, /* already elided, different named lifetimes\n-                             * or something static going on */\n-            }\n-        } else {\n-            false\n-        }\n+        Some(elidable_lts)\n     }\n }\n \n@@ -359,16 +372,31 @@ fn allowed_lts_from(tcx: TyCtxt<'_>, named_generics: &[GenericParam<'_>]) -> FxH\n     allowed_lts\n }\n \n-/// Number of unique lifetimes in the given vector.\n+/// Number of times each named lifetime occurs in the given slice. Returns a vector to preserve\n+/// relative order.\n #[must_use]\n-fn unique_lifetimes(lts: &[RefLt]) -> usize {\n-    lts.iter().collect::<FxHashSet<_>>().len()\n+fn named_lifetime_occurrences(lts: &[RefLt]) -> Vec<(LocalDefId, usize)> {\n+    let mut occurrences = Vec::new();\n+    for lt in lts {\n+        if let &RefLt::Named(curr_def_id) = lt {\n+            if let Some(pair) = occurrences\n+                .iter_mut()\n+                .find(|(prev_def_id, _)| *prev_def_id == curr_def_id)\n+            {\n+                pair.1 += 1;\n+            } else {\n+                occurrences.push((curr_def_id, 1));\n+            }\n+        }\n+    }\n+    occurrences\n }\n \n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     lts: Vec<RefLt>,\n+    lifetime_generic_arg_spans: FxHashMap<LocalDefId, Span>,\n     nested_elision_site_lts: Vec<RefLt>,\n     unelided_trait_object_lifetime: bool,\n }\n@@ -378,6 +406,7 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         Self {\n             cx,\n             lts: Vec::new(),\n+            lifetime_generic_arg_spans: FxHashMap::default(),\n             nested_elision_site_lts: Vec::new(),\n             unelided_trait_object_lifetime: false,\n         }\n@@ -467,6 +496,22 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             _ => walk_ty(self, ty),\n         }\n     }\n+\n+    fn visit_generic_arg(&mut self, generic_arg: &'tcx GenericArg<'tcx>) {\n+        if let GenericArg::Lifetime(l) = generic_arg\n+            && let LifetimeName::Param(def_id, _) = l.name\n+        {\n+            self.lifetime_generic_arg_spans.entry(def_id).or_insert(l.span);\n+        }\n+        // Replace with `walk_generic_arg` if/when https://github.com/rust-lang/rust/pull/103692 lands.\n+        // walk_generic_arg(self, generic_arg);\n+        match generic_arg {\n+            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n+            GenericArg::Type(ty) => self.visit_ty(ty),\n+            GenericArg::Const(ct) => self.visit_anon_const(&ct.value),\n+            GenericArg::Infer(inf) => self.visit_infer(inf),\n+        }\n+    }\n }\n \n /// Are any lifetimes mentioned in the `where` clause? If so, we don't try to"}, {"sha": "8e52cac4323c3102541c8e6efa238ca0b1c1bd69", "filename": "src/tools/clippy/clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -9,7 +9,6 @@ mod manual_flatten;\n mod manual_memcpy;\n mod missing_spin_loop;\n mod mut_range_bound;\n-mod needless_collect;\n mod needless_range_loop;\n mod never_loop;\n mod same_item_push;\n@@ -205,28 +204,6 @@ declare_clippy_lint! {\n     \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\"\n }\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for functions collecting an iterator when collect\n-    /// is not needed.\n-    ///\n-    /// ### Why is this bad?\n-    /// `collect` causes the allocation of a new data structure,\n-    /// when this allocation may not be needed.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let iterator = vec![1].into_iter();\n-    /// let len = iterator.clone().collect::<Vec<_>>().len();\n-    /// // should be\n-    /// let len = iterator.count();\n-    /// ```\n-    #[clippy::version = \"1.30.0\"]\n-    pub NEEDLESS_COLLECT,\n-    perf,\n-    \"collecting an iterator when collect is not needed\"\n-}\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks `for` loops over slices with an explicit counter\n@@ -605,7 +582,6 @@ declare_lint_pass!(Loops => [\n     EXPLICIT_INTO_ITER_LOOP,\n     ITER_NEXT_LOOP,\n     WHILE_LET_LOOP,\n-    NEEDLESS_COLLECT,\n     EXPLICIT_COUNTER_LOOP,\n     EMPTY_LOOP,\n     WHILE_LET_ON_ITERATOR,\n@@ -667,8 +643,6 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n             while_immutable_condition::check(cx, condition, body);\n             missing_spin_loop::check(cx, condition, body);\n         }\n-\n-        needless_collect::check(expr, cx);\n     }\n }\n "}, {"sha": "4dae93f6028d421cd9fa7f759bcb4eaf1190959e", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -52,8 +52,8 @@ fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId>\n     None\n }\n \n-fn check_for_mutation<'tcx>(\n-    cx: &LateContext<'tcx>,\n+fn check_for_mutation(\n+    cx: &LateContext<'_>,\n     body: &Expr<'_>,\n     bound_id_start: Option<HirId>,\n     bound_id_end: Option<HirId>,\n@@ -113,13 +113,7 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n         }\n     }\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {\n-    }\n+    fn fake_read(&mut self, _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }\n \n impl MutatePairDelegate<'_, '_> {"}, {"sha": "14f161f51026526a1cfe63bd0aaae6b6e915c23c", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 71, "deletions": 43, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n+use rustc_hir::{Block, Destination, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_span::Span;\n use std::iter::{once, Iterator};\n@@ -16,7 +16,7 @@ pub(super) fn check(\n     span: Span,\n     for_loop: Option<&ForLoop<'_>>,\n ) {\n-    match never_loop_block(block, loop_id) {\n+    match never_loop_block(block, &mut Vec::new(), loop_id) {\n         NeverLoopResult::AlwaysBreak => {\n             span_lint_and_then(cx, NEVER_LOOP, span, \"this loop never actually loops\", |diag| {\n                 if let Some(ForLoop {\n@@ -92,35 +92,34 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n     }\n }\n \n-fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    let mut iter = block\n+fn never_loop_block(block: &Block<'_>, ignore_ids: &mut Vec<HirId>, main_loop_id: HirId) -> NeverLoopResult {\n+    let iter = block\n         .stmts\n         .iter()\n         .filter_map(stmt_to_expr)\n         .chain(block.expr.map(|expr| (expr, None)));\n-    never_loop_expr_seq(&mut iter, main_loop_id)\n-}\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item = (&'a Expr<'a>, Option<&'a Block<'a>>)>>(\n-    es: &mut T,\n-    main_loop_id: HirId,\n-) -> NeverLoopResult {\n-    es.map(|(e, els)| {\n-        let e = never_loop_expr(e, main_loop_id);\n-        els.map_or(e, |els| combine_branches(e, never_loop_block(els, main_loop_id)))\n+    iter.map(|(e, els)| {\n+        let e = never_loop_expr(e, ignore_ids, main_loop_id);\n+        // els is an else block in a let...else binding\n+        els.map_or(e, |els| {\n+            combine_branches(e, never_loop_block(els, ignore_ids, main_loop_id))\n+        })\n     })\n     .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<(&'tcx Expr<'tcx>, Option<&'tcx Block<'tcx>>)> {\n     match stmt.kind {\n-        StmtKind::Semi(e, ..) | StmtKind::Expr(e, ..) => Some((e, None)),\n+        StmtKind::Semi(e) | StmtKind::Expr(e) => Some((e, None)),\n+        // add the let...else expression (if present)\n         StmtKind::Local(local) => local.init.map(|init| (init, local.els)),\n         StmtKind::Item(..) => None,\n     }\n }\n \n-fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+#[allow(clippy::too_many_lines)]\n+fn never_loop_expr(expr: &Expr<'_>, ignore_ids: &mut Vec<HirId>, main_loop_id: HirId) -> NeverLoopResult {\n     match expr.kind {\n         ExprKind::Box(e)\n         | ExprKind::Unary(_, e)\n@@ -129,47 +128,56 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Field(e, _)\n         | ExprKind::AddrOf(_, _, e)\n         | ExprKind::Repeat(e, _)\n-        | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n-        ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, main_loop_id),\n-        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), main_loop_id),\n-        ExprKind::MethodCall(_, receiver, es, _) => {\n-            never_loop_expr_all(&mut std::iter::once(receiver).chain(es.iter()), main_loop_id)\n-        },\n+        | ExprKind::DropTemps(e) => never_loop_expr(e, ignore_ids, main_loop_id),\n+        ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, ignore_ids, main_loop_id),\n+        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), ignore_ids, main_loop_id),\n+        ExprKind::MethodCall(_, receiver, es, _) => never_loop_expr_all(\n+            &mut std::iter::once(receiver).chain(es.iter()),\n+            ignore_ids,\n+            main_loop_id,\n+        ),\n         ExprKind::Struct(_, fields, base) => {\n-            let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), main_loop_id);\n+            let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), ignore_ids, main_loop_id);\n             if let Some(base) = base {\n-                combine_both(fields, never_loop_expr(base, main_loop_id))\n+                combine_both(fields, never_loop_expr(base, ignore_ids, main_loop_id))\n             } else {\n                 fields\n             }\n         },\n-        ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), main_loop_id),\n+        ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), ignore_ids, main_loop_id),\n         ExprKind::Binary(_, e1, e2)\n         | ExprKind::Assign(e1, e2, _)\n         | ExprKind::AssignOp(_, e1, e2)\n-        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().copied(), main_loop_id),\n+        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().copied(), ignore_ids, main_loop_id),\n         ExprKind::Loop(b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n-            absorb_break(never_loop_block(b, main_loop_id))\n+            absorb_break(never_loop_block(b, ignore_ids, main_loop_id))\n         },\n         ExprKind::If(e, e2, e3) => {\n-            let e1 = never_loop_expr(e, main_loop_id);\n-            let e2 = never_loop_expr(e2, main_loop_id);\n-            let e3 = e3\n-                .as_ref()\n-                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n+            let e1 = never_loop_expr(e, ignore_ids, main_loop_id);\n+            let e2 = never_loop_expr(e2, ignore_ids, main_loop_id);\n+            let e3 = e3.as_ref().map_or(NeverLoopResult::Otherwise, |e| {\n+                never_loop_expr(e, ignore_ids, main_loop_id)\n+            });\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n         ExprKind::Match(e, arms, _) => {\n-            let e = never_loop_expr(e, main_loop_id);\n+            let e = never_loop_expr(e, ignore_ids, main_loop_id);\n             if arms.is_empty() {\n                 e\n             } else {\n-                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| a.body), main_loop_id);\n+                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| a.body), ignore_ids, main_loop_id);\n                 combine_seq(e, arms)\n             }\n         },\n-        ExprKind::Block(b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Block(b, l) => {\n+            if l.is_some() {\n+                ignore_ids.push(b.hir_id);\n+            }\n+            let ret = never_loop_block(b, ignore_ids, main_loop_id);\n+            ignore_ids.pop();\n+            ret\n+        },\n         ExprKind::Continue(d) => {\n             let id = d\n                 .target_id\n@@ -180,20 +188,32 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n+        // checks if break targets a block instead of a loop\n+        ExprKind::Break(Destination { target_id: Ok(t), .. }, e) if ignore_ids.contains(&t) => e\n+            .map_or(NeverLoopResult::Otherwise, |e| {\n+                combine_seq(never_loop_expr(e, ignore_ids, main_loop_id), NeverLoopResult::Otherwise)\n+            }),\n         ExprKind::Break(_, e) | ExprKind::Ret(e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n-            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+            combine_seq(\n+                never_loop_expr(e, ignore_ids, main_loop_id),\n+                NeverLoopResult::AlwaysBreak,\n+            )\n         }),\n         ExprKind::InlineAsm(asm) => asm\n             .operands\n             .iter()\n             .map(|(o, _)| match o {\n                 InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n-                    never_loop_expr(expr, main_loop_id)\n+                    never_loop_expr(expr, ignore_ids, main_loop_id)\n                 },\n-                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter().copied(), main_loop_id),\n-                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                    never_loop_expr_all(&mut once(*in_expr).chain(out_expr.iter().copied()), main_loop_id)\n+                InlineAsmOperand::Out { expr, .. } => {\n+                    never_loop_expr_all(&mut expr.iter().copied(), ignore_ids, main_loop_id)\n                 },\n+                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => never_loop_expr_all(\n+                    &mut once(*in_expr).chain(out_expr.iter().copied()),\n+                    ignore_ids,\n+                    main_loop_id,\n+                ),\n                 InlineAsmOperand::Const { .. }\n                 | InlineAsmOperand::SymFn { .. }\n                 | InlineAsmOperand::SymStatic { .. } => NeverLoopResult::Otherwise,\n@@ -208,13 +228,21 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     }\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    es.map(|e| never_loop_expr(e, main_loop_id))\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(\n+    es: &mut T,\n+    ignore_ids: &mut Vec<HirId>,\n+    main_loop_id: HirId,\n+) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, ignore_ids, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    e.map(|e| never_loop_expr(e, main_loop_id))\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(\n+    e: &mut T,\n+    ignore_ids: &mut Vec<HirId>,\n+    main_loop_id: HirId,\n+) -> NeverLoopResult {\n+    e.map(|e| never_loop_expr(e, ignore_ids, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n "}, {"sha": "331cda1db8990c8927794f5828420b71e9fa55fd", "filename": "src/tools/clippy/clippy_lints/src/manual_instant_elapsed.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_instant_elapsed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_instant_elapsed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_instant_elapsed.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,69 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Spanned;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Lints subtraction between `Instant::now()` and another `Instant`.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is easy to accidentally write `prev_instant - Instant::now()`, which will always be 0ns\n-    /// as `Instant` subtraction saturates.\n-    ///\n-    /// `prev_instant.elapsed()` also more clearly signals intention.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// use std::time::Instant;\n-    /// let prev_instant = Instant::now();\n-    /// let duration = Instant::now() - prev_instant;\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// use std::time::Instant;\n-    /// let prev_instant = Instant::now();\n-    /// let duration = prev_instant.elapsed();\n-    /// ```\n-    #[clippy::version = \"1.64.0\"]\n-    pub MANUAL_INSTANT_ELAPSED,\n-    pedantic,\n-    \"subtraction between `Instant::now()` and previous `Instant`\"\n-}\n-\n-declare_lint_pass!(ManualInstantElapsed => [MANUAL_INSTANT_ELAPSED]);\n-\n-impl LateLintPass<'_> for ManualInstantElapsed {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n-        if let ExprKind::Binary(Spanned {node: BinOpKind::Sub, ..}, lhs, rhs) = expr.kind\n-            && check_instant_now_call(cx, lhs)\n-            && let ty_resolved = cx.typeck_results().expr_ty(rhs)\n-            && let rustc_middle::ty::Adt(def, _) = ty_resolved.kind()\n-            && clippy_utils::match_def_path(cx, def.did(), &clippy_utils::paths::INSTANT)\n-            && let Some(sugg) = clippy_utils::sugg::Sugg::hir_opt(cx, rhs)\n-        {\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_INSTANT_ELAPSED,\n-                expr.span,\n-                \"manual implementation of `Instant::elapsed`\",\n-                \"try\",\n-                format!(\"{}.elapsed()\", sugg.maybe_par()),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-}\n-\n-fn check_instant_now_call(cx: &LateContext<'_>, expr_block: &'_ Expr<'_>) -> bool {\n-    if let ExprKind::Call(fn_expr, []) = expr_block.kind\n-        && let Some(fn_id) = clippy_utils::path_def_id(cx, fn_expr)\n-        && clippy_utils::match_def_path(cx, fn_id, &clippy_utils::paths::INSTANT_NOW)\n-    {\n-        true\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "bb8c142f8e4680e3b1ccea794cedc942f903d5e3", "filename": "src/tools/clippy/clippy_lints/src/manual_is_ascii_check.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_is_ascii_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_is_ascii_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_is_ascii_check.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,158 @@\n+use rustc_ast::LitKind::{Byte, Char};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, PatKind, RangeEnd};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{def_id::DefId, sym};\n+\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg, in_constant, macros::root_macro_call, meets_msrv, msrvs, source::snippet,\n+};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Suggests to use dedicated built-in methods,\n+    /// `is_ascii_(lowercase|uppercase|digit)` for checking on corresponding ascii range\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the built-in functions is more readable and makes it\n+    /// clear that it's not a specific subset of characters, but all\n+    /// ASCII (lowercase|uppercase|digit) characters.\n+    /// ### Example\n+    /// ```rust\n+    /// fn main() {\n+    ///     assert!(matches!('x', 'a'..='z'));\n+    ///     assert!(matches!(b'X', b'A'..=b'Z'));\n+    ///     assert!(matches!('2', '0'..='9'));\n+    ///     assert!(matches!('x', 'A'..='Z' | 'a'..='z'));\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn main() {\n+    ///     assert!('x'.is_ascii_lowercase());\n+    ///     assert!(b'X'.is_ascii_uppercase());\n+    ///     assert!('2'.is_ascii_digit());\n+    ///     assert!('x'.is_ascii_alphabetic());\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub MANUAL_IS_ASCII_CHECK,\n+    style,\n+    \"use dedicated method to check ascii range\"\n+}\n+impl_lint_pass!(ManualIsAsciiCheck => [MANUAL_IS_ASCII_CHECK]);\n+\n+pub struct ManualIsAsciiCheck {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualIsAsciiCheck {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq)]\n+enum CharRange {\n+    /// 'a'..='z' | b'a'..=b'z'\n+    LowerChar,\n+    /// 'A'..='Z' | b'A'..=b'Z'\n+    UpperChar,\n+    /// AsciiLower | AsciiUpper\n+    FullChar,\n+    /// '0..=9'\n+    Digit,\n+    Otherwise,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualIsAsciiCheck {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if !meets_msrv(self.msrv, msrvs::IS_ASCII_DIGIT) {\n+            return;\n+        }\n+\n+        if in_constant(cx, expr.hir_id) && !meets_msrv(self.msrv, msrvs::IS_ASCII_DIGIT_CONST) {\n+            return;\n+        }\n+\n+        let Some(macro_call) = root_macro_call(expr.span) else { return };\n+\n+        if is_matches_macro(cx, macro_call.def_id) {\n+            if let ExprKind::Match(recv, [arm, ..], _) = expr.kind {\n+                let range = check_pat(&arm.pat.kind);\n+\n+                if let Some(sugg) = match range {\n+                    CharRange::UpperChar => Some(\"is_ascii_uppercase\"),\n+                    CharRange::LowerChar => Some(\"is_ascii_lowercase\"),\n+                    CharRange::FullChar => Some(\"is_ascii_alphabetic\"),\n+                    CharRange::Digit => Some(\"is_ascii_digit\"),\n+                    CharRange::Otherwise => None,\n+                } {\n+                    let default_snip = \"..\";\n+                    // `snippet_with_applicability` may set applicability to `MaybeIncorrect` for\n+                    // macro span, so we check applicability manually by comparing `recv` is not default.\n+                    let recv = snippet(cx, recv.span, default_snip);\n+\n+                    let applicability = if recv == default_snip {\n+                        Applicability::HasPlaceholders\n+                    } else {\n+                        Applicability::MachineApplicable\n+                    };\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        MANUAL_IS_ASCII_CHECK,\n+                        macro_call.span,\n+                        \"manual check for common ascii range\",\n+                        \"try\",\n+                        format!(\"{recv}.{sugg}()\"),\n+                        applicability,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn check_pat(pat_kind: &PatKind<'_>) -> CharRange {\n+    match pat_kind {\n+        PatKind::Or(pats) => {\n+            let ranges = pats.iter().map(|p| check_pat(&p.kind)).collect::<Vec<_>>();\n+\n+            if ranges.len() == 2 && ranges.contains(&CharRange::UpperChar) && ranges.contains(&CharRange::LowerChar) {\n+                CharRange::FullChar\n+            } else {\n+                CharRange::Otherwise\n+            }\n+        },\n+        PatKind::Range(Some(start), Some(end), kind) if *kind == RangeEnd::Included => check_range(start, end),\n+        _ => CharRange::Otherwise,\n+    }\n+}\n+\n+fn check_range(start: &Expr<'_>, end: &Expr<'_>) -> CharRange {\n+    if let ExprKind::Lit(start_lit) = &start.kind\n+        && let ExprKind::Lit(end_lit) = &end.kind {\n+        match (&start_lit.node, &end_lit.node) {\n+            (Char('a'), Char('z')) | (Byte(b'a'), Byte(b'z')) => CharRange::LowerChar,\n+            (Char('A'), Char('Z')) | (Byte(b'A'), Byte(b'Z')) => CharRange::UpperChar,\n+            (Char('0'), Char('9')) | (Byte(b'0'), Byte(b'9')) => CharRange::Digit,\n+            _ => CharRange::Otherwise,\n+        }\n+    } else {\n+        CharRange::Otherwise\n+    }\n+}\n+\n+fn is_matches_macro(cx: &LateContext<'_>, macro_def_id: DefId) -> bool {\n+    if let Some(name) = cx.tcx.get_diagnostic_name(macro_def_id) {\n+        return sym::matches_macro == name;\n+    }\n+\n+    false\n+}"}, {"sha": "1846596fa4c8e259ab6f0ffb580807a47de5381b", "filename": "src/tools/clippy/clippy_lints/src/manual_let_else.rs", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,297 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::IfLetOrMatch;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::{for_each_expr, Descend};\n+use clippy_utils::{meets_msrv, msrvs, peel_blocks};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use serde::Deserialize;\n+use std::ops::ControlFlow;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Warn of cases where `let...else` could be used\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// `let...else` provides a standard construct for this pattern\n+    /// that people can easily recognize. It's also more compact.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # let w = Some(0);\n+    /// let v = if let Some(v) = w { v } else { return };\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// # #![feature(let_else)]\n+    /// # fn main () {\n+    /// # let w = Some(0);\n+    /// let Some(v) = w else { return };\n+    /// # }\n+    /// ```\n+    #[clippy::version = \"1.67.0\"]\n+    pub MANUAL_LET_ELSE,\n+    pedantic,\n+    \"manual implementation of a let...else statement\"\n+}\n+\n+pub struct ManualLetElse {\n+    msrv: Option<RustcVersion>,\n+    matches_behaviour: MatchLintBehaviour,\n+}\n+\n+impl ManualLetElse {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>, matches_behaviour: MatchLintBehaviour) -> Self {\n+        Self {\n+            msrv,\n+            matches_behaviour,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(ManualLetElse => [MANUAL_LET_ELSE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n+    fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &'tcx Stmt<'tcx>) {\n+        let if_let_or_match = if_chain! {\n+            if meets_msrv(self.msrv, msrvs::LET_ELSE);\n+            if !in_external_macro(cx.sess(), stmt.span);\n+            if let StmtKind::Local(local) = stmt.kind;\n+            if let Some(init) = local.init;\n+            if local.els.is_none();\n+            if local.ty.is_none();\n+            if init.span.ctxt() == stmt.span.ctxt();\n+            if let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init);\n+            then {\n+                if_let_or_match\n+            } else {\n+                return;\n+            }\n+        };\n+\n+        match if_let_or_match {\n+            IfLetOrMatch::IfLet(if_let_expr, let_pat, if_then, if_else) => if_chain! {\n+                if expr_is_simple_identity(let_pat, if_then);\n+                if let Some(if_else) = if_else;\n+                if expr_diverges(cx, if_else);\n+                then {\n+                    emit_manual_let_else(cx, stmt.span, if_let_expr, let_pat, if_else);\n+                }\n+            },\n+            IfLetOrMatch::Match(match_expr, arms, source) => {\n+                if self.matches_behaviour == MatchLintBehaviour::Never {\n+                    return;\n+                }\n+                if source != MatchSource::Normal {\n+                    return;\n+                }\n+                // Any other number than two arms doesn't (neccessarily)\n+                // have a trivial mapping to let else.\n+                if arms.len() != 2 {\n+                    return;\n+                }\n+                // Guards don't give us an easy mapping either\n+                if arms.iter().any(|arm| arm.guard.is_some()) {\n+                    return;\n+                }\n+                let check_types = self.matches_behaviour == MatchLintBehaviour::WellKnownTypes;\n+                let diverging_arm_opt = arms\n+                    .iter()\n+                    .enumerate()\n+                    .find(|(_, arm)| expr_diverges(cx, arm.body) && pat_allowed_for_else(cx, arm.pat, check_types));\n+                let Some((idx, diverging_arm)) = diverging_arm_opt else { return; };\n+                let pat_arm = &arms[1 - idx];\n+                if !expr_is_simple_identity(pat_arm.pat, pat_arm.body) {\n+                    return;\n+                }\n+\n+                emit_manual_let_else(cx, stmt.span, match_expr, pat_arm.pat, diverging_arm.body);\n+            },\n+        }\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}\n+\n+fn emit_manual_let_else(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, pat: &Pat<'_>, else_body: &Expr<'_>) {\n+    span_lint_and_then(\n+        cx,\n+        MANUAL_LET_ELSE,\n+        span,\n+        \"this could be rewritten as `let...else`\",\n+        |diag| {\n+            // This is far from perfect, for example there needs to be:\n+            // * mut additions for the bindings\n+            // * renamings of the bindings\n+            // * unused binding collision detection with existing ones\n+            // * putting patterns with at the top level | inside ()\n+            // for this to be machine applicable.\n+            let app = Applicability::HasPlaceholders;\n+\n+            if let Some(sn_pat) = snippet_opt(cx, pat.span) &&\n+                let Some(sn_expr) = snippet_opt(cx, expr.span) &&\n+                let Some(sn_else) = snippet_opt(cx, else_body.span)\n+            {\n+                let else_bl = if matches!(else_body.kind, ExprKind::Block(..)) {\n+                    sn_else\n+                } else {\n+                    format!(\"{{ {sn_else} }}\")\n+                };\n+                let sugg = format!(\"let {sn_pat} = {sn_expr} else {else_bl};\");\n+                diag.span_suggestion(span, \"consider writing\", sugg, app);\n+            }\n+        },\n+    );\n+}\n+\n+fn expr_diverges(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+    fn is_never(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+        if let Some(ty) = cx.typeck_results().expr_ty_opt(expr) {\n+            return ty.is_never();\n+        }\n+        false\n+    }\n+    // We can't just call is_never on expr and be done, because the type system\n+    // sometimes coerces the ! type to something different before we can get\n+    // our hands on it. So instead, we do a manual search. We do fall back to\n+    // is_never in some places when there is no better alternative.\n+    for_each_expr(expr, |ex| {\n+        match ex.kind {\n+            ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => ControlFlow::Break(()),\n+            ExprKind::Call(call, _) => {\n+                if is_never(cx, ex) || is_never(cx, call) {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::Yes)\n+            },\n+            ExprKind::MethodCall(..) => {\n+                if is_never(cx, ex) {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::Yes)\n+            },\n+            ExprKind::If(if_expr, if_then, if_else) => {\n+                let else_diverges = if_else.map_or(false, |ex| expr_diverges(cx, ex));\n+                let diverges = expr_diverges(cx, if_expr) || (else_diverges && expr_diverges(cx, if_then));\n+                if diverges {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::No)\n+            },\n+            ExprKind::Match(match_expr, match_arms, _) => {\n+                let diverges = expr_diverges(cx, match_expr)\n+                    || match_arms.iter().all(|arm| {\n+                        let guard_diverges = arm.guard.as_ref().map_or(false, |g| expr_diverges(cx, g.body()));\n+                        guard_diverges || expr_diverges(cx, arm.body)\n+                    });\n+                if diverges {\n+                    return ControlFlow::Break(());\n+                }\n+                ControlFlow::Continue(Descend::No)\n+            },\n+\n+            // Don't continue into loops or labeled blocks, as they are breakable,\n+            // and we'd have to start checking labels.\n+            ExprKind::Block(_, Some(_)) | ExprKind::Loop(..) => ControlFlow::Continue(Descend::No),\n+\n+            // Default: descend\n+            _ => ControlFlow::Continue(Descend::Yes),\n+        }\n+    })\n+    .is_some()\n+}\n+\n+fn pat_allowed_for_else(cx: &LateContext<'_>, pat: &'_ Pat<'_>, check_types: bool) -> bool {\n+    // Check whether the pattern contains any bindings, as the\n+    // binding might potentially be used in the body.\n+    // TODO: only look for *used* bindings.\n+    let mut has_bindings = false;\n+    pat.each_binding_or_first(&mut |_, _, _, _| has_bindings = true);\n+    if has_bindings {\n+        return false;\n+    }\n+\n+    // If we shouldn't check the types, exit early.\n+    if !check_types {\n+        return true;\n+    }\n+\n+    // Check whether any possibly \"unknown\" patterns are included,\n+    // because users might not know which values some enum has.\n+    // Well-known enums are excepted, as we assume people know them.\n+    // We do a deep check, to be able to disallow Err(En::Foo(_))\n+    // for usage of the En::Foo variant, as we disallow En::Foo(_),\n+    // but we allow Err(_).\n+    let typeck_results = cx.typeck_results();\n+    let mut has_disallowed = false;\n+    pat.walk_always(|pat| {\n+        // Only do the check if the type is \"spelled out\" in the pattern\n+        if !matches!(\n+            pat.kind,\n+            PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..)\n+        ) {\n+            return;\n+        };\n+        let ty = typeck_results.pat_ty(pat);\n+        // Option and Result are allowed, everything else isn't.\n+        if !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) {\n+            has_disallowed = true;\n+        }\n+    });\n+    !has_disallowed\n+}\n+\n+/// Checks if the passed block is a simple identity referring to bindings created by the pattern\n+fn expr_is_simple_identity(pat: &'_ Pat<'_>, expr: &'_ Expr<'_>) -> bool {\n+    // We support patterns with multiple bindings and tuples, like:\n+    //   let ... = if let (Some(foo), bar) = g() { (foo, bar) } else { ... }\n+    let peeled = peel_blocks(expr);\n+    let paths = match peeled.kind {\n+        ExprKind::Tup(exprs) | ExprKind::Array(exprs) => exprs,\n+        ExprKind::Path(_) => std::slice::from_ref(peeled),\n+        _ => return false,\n+    };\n+    let mut pat_bindings = FxHashSet::default();\n+    pat.each_binding_or_first(&mut |_ann, _hir_id, _sp, ident| {\n+        pat_bindings.insert(ident);\n+    });\n+    if pat_bindings.len() < paths.len() {\n+        return false;\n+    }\n+    for path in paths {\n+        if_chain! {\n+            if let ExprKind::Path(QPath::Resolved(_ty, path)) = path.kind;\n+            if let [path_seg] = path.segments;\n+            then {\n+                if !pat_bindings.remove(&path_seg.ident) {\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+    true\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Deserialize)]\n+pub enum MatchLintBehaviour {\n+    AllTypes,\n+    WellKnownTypes,\n+    Never,\n+}"}, {"sha": "59195d1ae4e0a5854865b83243de49155df97f83", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -119,7 +119,7 @@ fn is_unit_expression(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n /// semicolons, which causes problems when generating a suggestion. Given an\n /// expression that evaluates to '()' or '!', recursively remove useless braces\n /// and semi-colons until is suitable for including in the suggestion template\n-fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) -> Option<Span> {\n+fn reduce_unit_expression(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Span> {\n     if !is_unit_expression(cx, expr) {\n         return None;\n     }"}, {"sha": "d18c92caba2a6f0b3eaa65b5dcee86cde686d021", "filename": "src/tools/clippy/clippy_lints/src/matches/infallible_destructuring_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{path_to_local_id, peel_blocks, strip_pat_refs};\n use rustc_errors::Applicability;\n-use rustc_hir::{ExprKind, Local, MatchSource, PatKind, QPath};\n+use rustc_hir::{ByRef, ExprKind, Local, MatchSource, PatKind, QPath};\n use rustc_lint::LateContext;\n \n use super::INFALLIBLE_DESTRUCTURING_MATCH;\n@@ -16,7 +16,7 @@ pub(crate) fn check(cx: &LateContext<'_>, local: &Local<'_>) -> bool {\n         if let PatKind::TupleStruct(\n             QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n         if args.len() == 1;\n-        if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n+        if let PatKind::Binding(binding, arg, ..) = strip_pat_refs(&args[0]).kind;\n         let body = peel_blocks(arms[0].body);\n         if path_to_local_id(body, arg);\n \n@@ -30,8 +30,9 @@ pub(crate) fn check(cx: &LateContext<'_>, local: &Local<'_>) -> bool {\n                 Consider using `let`\",\n                 \"try this\",\n                 format!(\n-                    \"let {}({}) = {};\",\n+                    \"let {}({}{}) = {};\",\n                     snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n+                    if binding.0 == ByRef::Yes { \"ref \" } else { \"\" },\n                     snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n                     snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n                 ),"}, {"sha": "d521a529e0d6463f12486033c3351d9218a67817", "filename": "src/tools/clippy/clippy_lints/src/matches/manual_filter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -62,7 +62,7 @@ fn peels_blocks_incl_unsafe<'a>(expr: &'a Expr<'a>) -> &'a Expr<'a> {\n //    <expr>\n // }\n // Returns true if <expr> resolves to `Some(x)`, `false` otherwise\n-fn is_some_expr<'tcx>(cx: &LateContext<'_>, target: HirId, ctxt: SyntaxContext, expr: &'tcx Expr<'_>) -> bool {\n+fn is_some_expr(cx: &LateContext<'_>, target: HirId, ctxt: SyntaxContext, expr: &Expr<'_>) -> bool {\n     if let Some(inner_expr) = peels_blocks_incl_unsafe_opt(expr) {\n         // there can be not statements in the block as they would be removed when switching to `.filter`\n         if let ExprKind::Call(callee, [arg]) = inner_expr.kind {"}, {"sha": "f587c69f7302d41ab7f10d3040e8d37ef9209dfd", "filename": "src/tools/clippy/clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -83,8 +83,8 @@ fn set_diagnostic<'tcx>(diag: &mut Diagnostic, cx: &LateContext<'tcx>, expr: &'t\n \n /// If the expression is an `ExprKind::Match`, check if the scrutinee has a significant drop that\n /// may have a surprising lifetime.\n-fn has_significant_drop_in_scrutinee<'tcx, 'a>(\n-    cx: &'a LateContext<'tcx>,\n+fn has_significant_drop_in_scrutinee<'tcx>(\n+    cx: &LateContext<'tcx>,\n     scrutinee: &'tcx Expr<'tcx>,\n     source: MatchSource,\n ) -> Option<(Vec<FoundSigDrop>, &'static str)> {\n@@ -226,7 +226,7 @@ impl<'a, 'tcx> SigDropHelper<'a, 'tcx> {\n     /// This will try to set the current suggestion (so it can be moved into the suggestions vec\n     /// later). If `allow_move_and_clone` is false, the suggestion *won't* be set -- this gives us\n     /// an opportunity to look for another type in the chain that will be trivially copyable.\n-    /// However, if we are at the the end of the chain, we want to accept whatever is there. (The\n+    /// However, if we are at the end of the chain, we want to accept whatever is there. (The\n     /// suggestion won't actually be output, but the diagnostic message will be output, so the user\n     /// can determine the best way to handle the lint.)\n     fn try_setting_current_suggestion(&mut self, expr: &'tcx Expr<'_>, allow_move_and_clone: bool) {\n@@ -377,7 +377,7 @@ impl<'a, 'tcx> ArmSigDropHelper<'a, 'tcx> {\n     }\n }\n \n-fn has_significant_drop_in_arms<'tcx, 'a>(cx: &'a LateContext<'tcx>, arms: &'tcx [Arm<'_>]) -> FxHashSet<Span> {\n+fn has_significant_drop_in_arms<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) -> FxHashSet<Span> {\n     let mut helper = ArmSigDropHelper::new(cx);\n     for arm in arms {\n         helper.visit_expr(arm.body);"}, {"sha": "19b49c44d5704d316e09239e40ea91141c906b61", "filename": "src/tools/clippy/clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -153,7 +153,7 @@ fn pat_in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'a>, pat: &Pat<'_>) ->\n }\n \n /// Returns `true` if the given type is an enum we know won't be expanded in the future\n-fn in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'_>) -> bool {\n+fn in_candidate_enum(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     // list of candidate `Enum`s we know will never get any more members\n     let candidates = [sym::Cow, sym::Option, sym::Result];\n "}, {"sha": "27a05337a290f2c6cce4ee0635e44672ef71e5df", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -9,8 +9,8 @@ use rustc_lint::LateContext;\n use rustc_lint::Lint;\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n     info: &crate::methods::BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,"}, {"sha": "2efff4c3c5497b9d361b3b375b04c29e1ecdc331", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_last_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -4,7 +4,7 @@ use rustc_lint::LateContext;\n use super::CHARS_LAST_CMP;\n \n /// Checks for the `CHARS_LAST_CMP` lint.\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+pub(super) fn check(cx: &LateContext<'_>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n     if chars_cmp::check(cx, info, &[\"chars\", \"last\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {"}, {"sha": "5b8713f7d79035d92803413ae6b509c98d5f4fe9", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_last_cmp_with_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp_with_unwrap.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -4,7 +4,7 @@ use rustc_lint::LateContext;\n use super::CHARS_LAST_CMP;\n \n /// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+pub(super) fn check(cx: &LateContext<'_>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n     if chars_cmp_with_unwrap::check(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {"}, {"sha": "b631fecab9729e4de4c6ed853aa9928ed1eb175a", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_next_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -3,6 +3,6 @@ use rustc_lint::LateContext;\n use super::CHARS_NEXT_CMP;\n \n /// Checks for the `CHARS_NEXT_CMP` lint.\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+pub(super) fn check(cx: &LateContext<'_>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n     crate::methods::chars_cmp::check(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n }"}, {"sha": "caf21d3ff3bcb8a055ed5072be1c6fba88ca579a", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_next_cmp_with_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp_with_unwrap.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -3,6 +3,6 @@ use rustc_lint::LateContext;\n use super::CHARS_NEXT_CMP;\n \n /// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+pub(super) fn check(cx: &LateContext<'_>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n     crate::methods::chars_cmp_with_unwrap::check(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n }"}, {"sha": "ac61b4377885b8cfd2a179c901ee844be0cd8aef", "filename": "src/tools/clippy/clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n         // If the parent node's `to` argument is the same as the `to` argument\n         // of the last replace call in the current chain, don't lint as it was already linted\n         if let Some(parent) = get_parent_expr(cx, expr)\n-            && let Some((\"replace\", _, [current_from, current_to], _)) = method_call(parent)\n+            && let Some((\"replace\", _, [current_from, current_to], _, _)) = method_call(parent)\n             && eq_expr_value(cx, to, current_to)\n             && from_kind == cx.typeck_results().expr_ty(current_from).peel_refs().kind()\n         {\n@@ -48,7 +48,7 @@ fn collect_replace_calls<'tcx>(\n     let mut from_args = VecDeque::new();\n \n     let _: Option<()> = for_each_expr(expr, |e| {\n-        if let Some((\"replace\", _, [from, to], _)) = method_call(e) {\n+        if let Some((\"replace\", _, [from, to], _, _)) = method_call(e) {\n             if eq_expr_value(cx, to_arg, to) && cx.typeck_results().expr_ty(from).peel_refs().is_char() {\n                 methods.push_front(e);\n                 from_args.push_front(from);\n@@ -78,7 +78,7 @@ fn check_consecutive_replace_calls<'tcx>(\n         .collect();\n     let app = Applicability::MachineApplicable;\n     let earliest_replace_call = replace_methods.methods.front().unwrap();\n-    if let Some((_, _, [..], span_lo)) = method_call(earliest_replace_call) {\n+    if let Some((_, _, [..], span_lo, _)) = method_call(earliest_replace_call) {\n         span_lint_and_sugg(\n             cx,\n             COLLAPSIBLE_STR_REPLACE,"}, {"sha": "cce8f797e98c6a1c4e948caa3c31d26137f75c5e", "filename": "src/tools/clippy/clippy_lints/src/methods/expect_used.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_in_test_function;\n+use clippy_utils::is_in_cfg_test;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -18,16 +18,16 @@ pub(super) fn check(\n     let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) && !is_err {\n-        Some((EXPECT_USED, \"an Option\", \"None\", \"\"))\n+        Some((EXPECT_USED, \"an `Option`\", \"None\", \"\"))\n     } else if is_type_diagnostic_item(cx, obj_ty, sym::Result) {\n-        Some((EXPECT_USED, \"a Result\", if is_err { \"Ok\" } else { \"Err\" }, \"an \"))\n+        Some((EXPECT_USED, \"a `Result`\", if is_err { \"Ok\" } else { \"Err\" }, \"an \"))\n     } else {\n         None\n     };\n \n     let method = if is_err { \"expect_err\" } else { \"expect\" };\n \n-    if allow_expect_in_tests && is_in_test_function(cx.tcx, expr.hir_id) {\n+    if allow_expect_in_tests && is_in_cfg_test(cx.tcx, expr.hir_id) {\n         return;\n     }\n \n@@ -36,7 +36,7 @@ pub(super) fn check(\n             cx,\n             lint,\n             expr.span,\n-            &format!(\"used `{method}()` on `{kind}` value\"),\n+            &format!(\"used `{method}()` on {kind} value\"),\n             None,\n             &format!(\"if this value is {none_prefix}`{none_value}`, it will panic\"),\n         );"}, {"sha": "f888c58a72de93a605f3193e5dbfc5907d86ef24", "filename": "src/tools/clippy/clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -17,7 +17,7 @@ use super::MANUAL_FILTER_MAP;\n use super::MANUAL_FIND_MAP;\n use super::OPTION_FILTER_MAP;\n \n-fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Symbol) -> bool {\n+fn is_method(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol) -> bool {\n     match &expr.kind {\n         hir::ExprKind::Path(QPath::TypeRelative(_, mname)) => mname.ident.name == method_name,\n         hir::ExprKind::Path(QPath::Resolved(_, segments)) => {\n@@ -46,7 +46,7 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n     }\n }\n \n-fn is_option_filter_map<'tcx>(cx: &LateContext<'tcx>, filter_arg: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) -> bool {\n+fn is_option_filter_map(cx: &LateContext<'_>, filter_arg: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) -> bool {\n     is_method(cx, map_arg, sym::unwrap) && is_method(cx, filter_arg, sym!(is_some))\n }\n \n@@ -66,8 +66,8 @@ fn is_filter_some_map_unwrap(\n \n /// lint use of `filter().map()` or `find().map()` for `Iterators`\n #[allow(clippy::too_many_arguments)]\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n     filter_recv: &hir::Expr<'_>,\n     filter_arg: &hir::Expr<'_>,"}, {"sha": "d8c821bc9eeee1cfb6eadf374a8c6e718668f472", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -12,8 +12,8 @@ use rustc_span::symbol::{Symbol, sym};\n use super::INEFFICIENT_TO_STRING;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n+pub fn check(\n+    cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n     method_name: Symbol,\n     receiver: &hir::Expr<'_>,"}, {"sha": "c830958d5c80e58865bd1c93b9091fdbd5e5f239", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_nth_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -10,7 +10,7 @@ use rustc_span::sym;\n \n use super::ITER_NTH_ZERO;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     if_chain! {\n         if is_trait_method(cx, expr, sym::Iterator);\n         if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg);"}, {"sha": "70abe4891d9857e8ccee90b8abfc8065a744b941", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_on_single_or_empty_collections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -25,7 +25,7 @@ impl IterType {\n     }\n }\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, method_name: &str, recv: &Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: &str, recv: &Expr<'_>) {\n     let item = match recv.kind {\n         ExprKind::Array([]) => None,\n         ExprKind::Array([e]) => Some(e),"}, {"sha": "a7284c64497766b2b404b2377c5d0317b074d5d0", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -67,7 +67,7 @@ enum MinMax {\n     Max,\n }\n \n-fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<MinMax> {\n+fn is_min_or_max(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<MinMax> {\n     // `T::max_value()` `T::min_value()` inherent methods\n     if_chain! {\n         if let hir::ExprKind::Call(func, args) = &expr.kind;"}, {"sha": "a08f7254053fe1a499b74a22250f06a53297c4dd", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -59,10 +59,8 @@ pub(super) fn check(\n         if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n         if is_path_diagnostic_item(cx, repeat_fn, sym::iter_repeat);\n         if is_type_lang_item(cx, cx.typeck_results().expr_ty(collect_expr), LangItem::String);\n-        if let Some(collect_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n         if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);\n         if let Some(iter_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n-        if cx.tcx.trait_of_item(collect_id) == Some(iter_trait_id);\n         if cx.tcx.trait_of_item(take_id) == Some(iter_trait_id);\n         if let Some(repeat_kind) = parse_repeat_arg(cx, repeat_arg);\n         let ctxt = collect_expr.span.ctxt();"}, {"sha": "6bc783c6d505af108a508067f772a9fefcda5103", "filename": "src/tools/clippy/clippy_lints/src/methods/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -15,11 +15,11 @@ use rustc_span::{sym, Span};\n \n use super::MAP_CLONE;\n \n-pub(super) fn check<'tcx>(\n+pub(super) fn check(\n     cx: &LateContext<'_>,\n     e: &hir::Expr<'_>,\n     recv: &hir::Expr<'_>,\n-    arg: &'tcx hir::Expr<'_>,\n+    arg: &hir::Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) {\n     if_chain! {"}, {"sha": "a0300d278709d7e82ab20a5928d6ec74e4d6c8e0", "filename": "src/tools/clippy/clippy_lints/src/methods/map_collect_result_unit.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_trait_method;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n@@ -11,18 +10,10 @@ use rustc_span::symbol::sym;\n \n use super::MAP_COLLECT_RESULT_UNIT;\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    iter: &hir::Expr<'_>,\n-    map_fn: &hir::Expr<'_>,\n-    collect_recv: &hir::Expr<'_>,\n-) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, iter: &hir::Expr<'_>, map_fn: &hir::Expr<'_>) {\n+    // return of collect `Result<(),_>`\n+    let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n     if_chain! {\n-        // called on Iterator\n-        if is_trait_method(cx, collect_recv, sym::Iterator);\n-        // return of collect `Result<(),_>`\n-        let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n         if is_type_diagnostic_item(cx, collect_ret_ty, sym::Result);\n         if let ty::Adt(_, substs) = collect_ret_ty.kind();\n         if let Some(result_t) = substs.types().next();"}, {"sha": "b773b3e423f407c78e8e1c68b959a205c0d87b41", "filename": "src/tools/clippy/clippy_lints/src/methods/map_err_ignore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_err_ignore.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -6,7 +6,7 @@ use rustc_span::sym;\n \n use super::MAP_ERR_IGNORE;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'_>, e: &Expr<'_>, arg: &'tcx Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, e: &Expr<'_>, arg: &Expr<'_>) {\n     if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id)\n         && let Some(impl_id) = cx.tcx.impl_of_method(method_id)\n         && is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Result)"}, {"sha": "38165ab4fb26f4053a256c012a933307538b8452", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 178, "deletions": 103, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -54,6 +54,7 @@ mod map_flatten;\n mod map_identity;\n mod map_unwrap_or;\n mod mut_mutex_lock;\n+mod needless_collect;\n mod needless_option_as_deref;\n mod needless_option_take;\n mod no_effect_replace;\n@@ -69,6 +70,8 @@ mod path_buf_push_overwrite;\n mod range_zip_with_len;\n mod repeat_once;\n mod search_is_some;\n+mod seek_from_current;\n+mod seek_to_start_instead_of_rewind;\n mod single_char_add_str;\n mod single_char_insert_string;\n mod single_char_pattern;\n@@ -101,12 +104,11 @@ mod zst_offset;\n use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::ty::{contains_adt_constructor, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, is_trait_method, iter_input_pats, meets_msrv, msrvs, return_ty};\n+use clippy_utils::ty::{contains_ty_adt_constructor_opaque, implements_trait, is_copy, is_type_diagnostic_item};\n+use clippy_utils::{contains_return, is_bool, is_trait_method, iter_input_pats, meets_msrv, msrvs, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n-use rustc_hir::{Expr, ExprKind, PrimTy, QPath, TraitItem, TraitItemKind};\n+use rustc_hir::{Expr, ExprKind, TraitItem, TraitItemKind};\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -156,9 +158,9 @@ declare_clippy_lint! {\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// let hello = \"hesuo worpd\".replace(&['s', 'u', 'p'], \"l\");\n+    /// let hello = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\");\n     /// ```\n-    #[clippy::version = \"1.64.0\"]\n+    #[clippy::version = \"1.65.0\"]\n     pub COLLAPSIBLE_STR_REPLACE,\n     perf,\n     \"collapse consecutive calls to str::replace (2 or more) into a single call\"\n@@ -829,32 +831,30 @@ declare_clippy_lint! {\n     /// etc. instead.\n     ///\n     /// ### Why is this bad?\n-    /// The function will always be called and potentially\n-    /// allocate an object acting as the default.\n+    /// The function will always be called. This is only bad if it allocates or\n+    /// does some non-trivial amount of work.\n     ///\n     /// ### Known problems\n-    /// If the function has side-effects, not calling it will\n-    /// change the semantic of the program, but you shouldn't rely on that anyway.\n+    /// If the function has side-effects, not calling it will change the\n+    /// semantic of the program, but you shouldn't rely on that.\n+    ///\n+    /// The lint also cannot figure out whether the function you call is\n+    /// actually expensive to call or not.\n     ///\n     /// ### Example\n     /// ```rust\n     /// # let foo = Some(String::new());\n-    /// foo.unwrap_or(String::new());\n+    /// foo.unwrap_or(String::from(\"empty\"));\n     /// ```\n     ///\n     /// Use instead:\n     /// ```rust\n     /// # let foo = Some(String::new());\n-    /// foo.unwrap_or_else(String::new);\n-    ///\n-    /// // or\n-    ///\n-    /// # let foo = Some(String::new());\n-    /// foo.unwrap_or_default();\n+    /// foo.unwrap_or_else(|| String::from(\"empty\"));\n     /// ```\n     #[clippy::version = \"pre 1.29.0\"]\n     pub OR_FUN_CALL,\n-    perf,\n+    nursery,\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n@@ -1728,7 +1728,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for usage of `_.as_ref().map(Deref::deref)` or it's aliases (such as String::as_str).\n+    /// Checks for usage of `_.as_ref().map(Deref::deref)` or its aliases (such as String::as_str).\n     ///\n     /// ### Why is this bad?\n     /// Readability, this can be written more concisely as\n@@ -2094,8 +2094,7 @@ declare_clippy_lint! {\n     /// let s = \"Hello world!\";\n     /// let cow = Cow::Borrowed(s);\n     ///\n-    /// let data = cow.into_owned();\n-    /// assert!(matches!(data, String))\n+    /// let _data: String = cow.into_owned();\n     /// ```\n     #[clippy::version = \"1.65.0\"]\n     pub SUSPICIOUS_TO_OWNED,\n@@ -2426,7 +2425,7 @@ declare_clippy_lint! {\n     /// ### Known problems\n     ///\n     /// The type of the resulting iterator might become incompatible with its usage\n-    #[clippy::version = \"1.64.0\"]\n+    #[clippy::version = \"1.65.0\"]\n     pub ITER_ON_SINGLE_ITEMS,\n     nursery,\n     \"Iterator for array of length 1\"\n@@ -2458,7 +2457,7 @@ declare_clippy_lint! {\n     /// ### Known problems\n     ///\n     /// The type of the resulting iterator might become incompatible with its usage\n-    #[clippy::version = \"1.64.0\"]\n+    #[clippy::version = \"1.65.0\"]\n     pub ITER_ON_EMPTY_COLLECTIONS,\n     nursery,\n     \"Iterator for empty array\"\n@@ -3066,6 +3065,102 @@ declare_clippy_lint! {\n     \"iterating on map using `iter` when `keys` or `values` would do\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks an argument of `seek` method of `Seek` trait\n+    /// and if it start seek from `SeekFrom::Current(0)`, suggests `stream_position` instead.\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// Readability. Use dedicated method.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// use std::fs::File;\n+    /// use std::io::{self, Write, Seek, SeekFrom};\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut f = File::create(\"foo.txt\")?;\n+    ///     f.write_all(b\"Hello\")?;\n+    ///     eprintln!(\"Written {} bytes\", f.seek(SeekFrom::Current(0))?);\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,no_run\n+    /// use std::fs::File;\n+    /// use std::io::{self, Write, Seek, SeekFrom};\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut f = File::create(\"foo.txt\")?;\n+    ///     f.write_all(b\"Hello\")?;\n+    ///     eprintln!(\"Written {} bytes\", f.stream_position()?);\n+    ///\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub SEEK_FROM_CURRENT,\n+    complexity,\n+    \"use dedicated method for seek from current position\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for jumps to the start of a stream that implements `Seek`\n+    /// and uses the `seek` method providing `Start` as parameter.\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// Readability. There is a specific method that was implemented for\n+    /// this exact scenario.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::io;\n+    /// fn foo<T: io::Seek>(t: &mut T) {\n+    ///     t.seek(io::SeekFrom::Start(0));\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::io;\n+    /// fn foo<T: io::Seek>(t: &mut T) {\n+    ///     t.rewind();\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub SEEK_TO_START_INSTEAD_OF_REWIND,\n+    complexity,\n+    \"jumping to the start of stream using `seek` method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for functions collecting an iterator when collect\n+    /// is not needed.\n+    ///\n+    /// ### Why is this bad?\n+    /// `collect` causes the allocation of a new data structure,\n+    /// when this allocation may not be needed.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let iterator = vec![1].into_iter();\n+    /// let len = iterator.clone().collect::<Vec<_>>().len();\n+    /// // should be\n+    /// let len = iterator.count();\n+    /// ```\n+    #[clippy::version = \"1.30.0\"]\n+    pub NEEDLESS_COLLECT,\n+    nursery,\n+    \"collecting an iterator when collect is not needed\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -3190,16 +3285,19 @@ impl_lint_pass!(Methods => [\n     VEC_RESIZE_TO_ZERO,\n     VERBOSE_FILE_READS,\n     ITER_KV_MAP,\n+    SEEK_FROM_CURRENT,\n+    SEEK_TO_START_INSTEAD_OF_REWIND,\n+    NEEDLESS_COLLECT,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n fn method_call<'tcx>(\n     recv: &'tcx hir::Expr<'tcx>,\n-) -> Option<(&'tcx str, &'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>], Span)> {\n-    if let ExprKind::MethodCall(path, receiver, args, _) = recv.kind {\n+) -> Option<(&'tcx str, &'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>], Span, Span)> {\n+    if let ExprKind::MethodCall(path, receiver, args, call_span) = recv.kind {\n         if !args.iter().any(|e| e.span.from_expansion()) && !receiver.span.from_expansion() {\n             let name = path.ident.name.as_str();\n-            return Some((name, receiver, args, path.ident.span));\n+            return Some((name, receiver, args, path.ident.span, call_span));\n         }\n     }\n     None\n@@ -3316,36 +3414,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id());\n \n-            // walk the return type and check for Self (this does not check associated types)\n-            if let Some(self_adt) = self_ty.ty_adt_def() {\n-                if contains_adt_constructor(ret_ty, self_adt) {\n-                    return;\n-                }\n-            } else if ret_ty.contains(self_ty) {\n+            if contains_ty_adt_constructor_opaque(cx, ret_ty, self_ty) {\n                 return;\n             }\n \n-            // if return type is impl trait, check the associated types\n-            if let ty::Opaque(def_id, _) = *ret_ty.kind() {\n-                // one of the associated types must be Self\n-                for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n-                    if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n-                        let assoc_ty = match projection_predicate.term.unpack() {\n-                            ty::TermKind::Ty(ty) => ty,\n-                            ty::TermKind::Const(_c) => continue,\n-                        };\n-                        // walk the associated type and check for Self\n-                        if let Some(self_adt) = self_ty.ty_adt_def() {\n-                            if contains_adt_constructor(assoc_ty, self_adt) {\n-                                return;\n-                            }\n-                        } else if assoc_ty.contains(self_ty) {\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-\n             if name == \"new\" && ret_ty != self_ty {\n                 span_lint(\n                     cx,\n@@ -3411,7 +3483,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n impl Methods {\n     #[allow(clippy::too_many_lines)]\n     fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((name, recv, args, span)) = method_call(expr) {\n+        if let Some((name, recv, args, span, call_span)) = method_call(expr) {\n             match (name, args) {\n                 (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                     zst_offset::check(cx, expr, recv);\n@@ -3430,28 +3502,31 @@ impl Methods {\n                 (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n                 (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n                 (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, self.msrv),\n-                (\"collect\", []) => match method_call(recv) {\n-                    Some((name @ (\"cloned\" | \"copied\"), recv2, [], _)) => {\n-                        iter_cloned_collect::check(cx, name, expr, recv2);\n-                    },\n-                    Some((\"map\", m_recv, [m_arg], _)) => {\n-                        map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n-                    },\n-                    Some((\"take\", take_self_arg, [take_arg], _)) => {\n-                        if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n-                            manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n-                        }\n-                    },\n-                    _ => {},\n+                (\"collect\", []) if is_trait_method(cx, expr, sym::Iterator) => {\n+                    needless_collect::check(cx, span, expr, recv, call_span);\n+                    match method_call(recv) {\n+                        Some((name @ (\"cloned\" | \"copied\"), recv2, [], _, _)) => {\n+                            iter_cloned_collect::check(cx, name, expr, recv2);\n+                        },\n+                        Some((\"map\", m_recv, [m_arg], _, _)) => {\n+                            map_collect_result_unit::check(cx, expr, m_recv, m_arg);\n+                        },\n+                        Some((\"take\", take_self_arg, [take_arg], _, _)) => {\n+                            if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n+                                manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n                 },\n                 (\"count\", []) if is_trait_method(cx, expr, sym::Iterator) => match method_call(recv) {\n-                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n-                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), recv2, [], _)) => {\n+                    Some((\"cloned\", recv2, [], _, _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n+                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), recv2, [], _, _)) => {\n                         iter_count::check(cx, expr, recv2, name2);\n                     },\n-                    Some((\"map\", _, [arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n-                    Some((\"filter\", recv2, [arg], _)) => bytecount::check(cx, expr, recv2, arg),\n-                    Some((\"bytes\", recv2, [], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n+                    Some((\"map\", _, [arg], _, _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    Some((\"filter\", recv2, [arg], _, _)) => bytecount::check(cx, expr, recv2, arg),\n+                    Some((\"bytes\", recv2, [], _, _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {\n@@ -3463,8 +3538,8 @@ impl Methods {\n                     }\n                 },\n                 (\"expect\", [_]) => match method_call(recv) {\n-                    Some((\"ok\", recv, [], _)) => ok_expect::check(cx, expr, recv),\n-                    Some((\"err\", recv, [], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n+                    Some((\"ok\", recv, [], _, _)) => ok_expect::check(cx, expr, recv),\n+                    Some((\"err\", recv, [], err_span, _)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n                     _ => expect_used::check(cx, expr, recv, false, self.allow_expect_in_tests),\n                 },\n                 (\"expect_err\", [_]) => expect_used::check(cx, expr, recv, true, self.allow_expect_in_tests),\n@@ -3484,13 +3559,13 @@ impl Methods {\n                     flat_map_option::check(cx, expr, arg, span);\n                 },\n                 (\"flatten\", []) => match method_call(recv) {\n-                    Some((\"map\", recv, [map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n-                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n+                    Some((\"map\", recv, [map_arg], map_span, _)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n+                    Some((\"cloned\", recv2, [], _, _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n                     _ => {},\n                 },\n                 (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n                 (\"for_each\", [_]) => {\n-                    if let Some((\"inspect\", _, [_], span2)) = method_call(recv) {\n+                    if let Some((\"inspect\", _, [_], span2, _)) = method_call(recv) {\n                         inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n@@ -3510,12 +3585,12 @@ impl Methods {\n                     iter_on_single_or_empty_collections::check(cx, expr, name, recv);\n                 },\n                 (\"join\", [join_arg]) => {\n-                    if let Some((\"collect\", _, _, span)) = method_call(recv) {\n+                    if let Some((\"collect\", _, _, span, _)) = method_call(recv) {\n                         unnecessary_join::check(cx, expr, recv, join_arg, span);\n                     }\n                 },\n                 (\"last\", []) | (\"skip\", [_]) => {\n-                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2, _)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3527,13 +3602,13 @@ impl Methods {\n                 (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n                     if name == \"map\" {\n                         map_clone::check(cx, expr, recv, m_arg, self.msrv);\n-                        if let Some((map_name @ (\"iter\" | \"into_iter\"), recv2, _, _)) = method_call(recv) {\n+                        if let Some((map_name @ (\"iter\" | \"into_iter\"), recv2, _, _, _)) = method_call(recv) {\n                             iter_kv_map::check(cx, map_name, expr, recv2, m_arg);\n                         }\n                     } else {\n                         map_err_ignore::check(cx, expr, m_arg);\n                     }\n-                    if let Some((name, recv2, args, span2)) = method_call(recv) {\n+                    if let Some((name, recv2, args, span2,_)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n                             (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n@@ -3553,7 +3628,7 @@ impl Methods {\n                     manual_ok_or::check(cx, expr, recv, def, map);\n                 },\n                 (\"next\", []) => {\n-                    if let Some((name2, recv2, args2, _)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _, _)) = method_call(recv) {\n                         match (name2, args2) {\n                             (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n                             (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n@@ -3566,10 +3641,10 @@ impl Methods {\n                     }\n                 },\n                 (\"nth\", [n_arg]) => match method_call(recv) {\n-                    Some((\"bytes\", recv2, [], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n-                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n-                    Some((\"iter\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n-                    Some((\"iter_mut\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                    Some((\"bytes\", recv2, [], _, _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                    Some((\"cloned\", recv2, [], _, _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n+                    Some((\"iter\", recv2, [], _, _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                    Some((\"iter_mut\", recv2, [], _, _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n                     _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n                 },\n                 (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n@@ -3604,6 +3679,14 @@ impl Methods {\n                 (\"resize\", [count_arg, default_arg]) => {\n                     vec_resize_to_zero::check(cx, expr, count_arg, default_arg, span);\n                 },\n+                (\"seek\", [arg]) => {\n+                    if meets_msrv(self.msrv, msrvs::SEEK_FROM_CURRENT) {\n+                        seek_from_current::check(cx, expr, recv, arg);\n+                    }\n+                    if meets_msrv(self.msrv, msrvs::SEEK_REWIND) {\n+                        seek_to_start_instead_of_rewind::check(cx, expr, recv, arg, span);\n+                    }\n+                },\n                 (\"sort\", []) => {\n                     stable_sort_primitive::check(cx, expr, recv);\n                 },\n@@ -3626,7 +3709,7 @@ impl Methods {\n                 },\n                 (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n                 (\"take\", [_arg]) => {\n-                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2, _)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3649,13 +3732,13 @@ impl Methods {\n                 },\n                 (\"unwrap\", []) => {\n                     match method_call(recv) {\n-                        Some((\"get\", recv, [get_arg], _)) => {\n+                        Some((\"get\", recv, [get_arg], _, _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, false);\n                         },\n-                        Some((\"get_mut\", recv, [get_arg], _)) => {\n+                        Some((\"get_mut\", recv, [get_arg], _, _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, true);\n                         },\n-                        Some((\"or\", recv, [or_arg], or_span)) => {\n+                        Some((\"or\", recv, [or_arg], or_span, _)) => {\n                             or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n                         },\n                         _ => {},\n@@ -3664,19 +3747,19 @@ impl Methods {\n                 },\n                 (\"unwrap_err\", []) => unwrap_used::check(cx, expr, recv, true, self.allow_unwrap_in_tests),\n                 (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n-                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), lhs, [rhs], _)) => {\n+                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), lhs, [rhs], _, _)) => {\n                         manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                     },\n-                    Some((\"map\", m_recv, [m_arg], span)) => {\n+                    Some((\"map\", m_recv, [m_arg], span, _)) => {\n                         option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n                     },\n-                    Some((\"then_some\", t_recv, [t_arg], _)) => {\n+                    Some((\"then_some\", t_recv, [t_arg], _, _)) => {\n                         obfuscated_if_else::check(cx, expr, t_recv, t_arg, u_arg);\n                     },\n                     _ => {},\n                 },\n                 (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n-                    Some((\"map\", recv, [map_arg], _))\n+                    Some((\"map\", recv, [map_arg], _, _))\n                         if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, self.msrv) => {},\n                     _ => {\n                         unwrap_or_else_default::check(cx, expr, recv, u_arg);\n@@ -3697,7 +3780,7 @@ impl Methods {\n }\n \n fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n-    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), f_recv, [arg], span)) = method_call(recv) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), f_recv, [arg], span, _)) = method_call(recv) {\n         search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span);\n     }\n }\n@@ -3906,14 +3989,6 @@ impl OutType {\n     }\n }\n \n-fn is_bool(ty: &hir::Ty<'_>) -> bool {\n-    if let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n-        matches!(path.res, Res::PrimTy(PrimTy::Bool))\n-    } else {\n-        false\n-    }\n-}\n-\n fn fn_header_equals(expected: hir::FnHeader, actual: hir::FnHeader) -> bool {\n     expected.constness == actual.constness\n         && expected.unsafety == actual.unsafety"}, {"sha": "b088e642e0e9acd258e5e422ce1984d08b06d226", "filename": "src/tools/clippy/clippy_lints/src/methods/needless_collect.rs", "status": "renamed", "additions": 139, "deletions": 84, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -3,94 +3,99 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local, path_to_local_id, CaptureKind};\n-use if_chain::if_chain;\n+use clippy_utils::ty::{is_type_diagnostic_item, make_normalized_projection, make_projection};\n+use clippy_utils::{\n+    can_move_expr_to_closure, get_enclosing_block, get_parent_node, is_trait_method, path_to_local, path_to_local_id,\n+    CaptureKind,\n+};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind};\n+use rustc_hir::{\n+    BindingAnnotation, Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind,\n+};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Ty};\n-use rustc_span::sym;\n-use rustc_span::Span;\n+use rustc_middle::ty::{self, AssocKind, EarlyBinder, GenericArg, GenericArgKind, Ty};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, Span, Symbol};\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n-pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    check_needless_collect_direct_usage(expr, cx);\n-    check_needless_collect_indirect_usage(expr, cx);\n-}\n-fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method, receiver, args, _) = expr.kind;\n-        if let ExprKind::MethodCall(chain_method, ..) = receiver.kind;\n-        if chain_method.ident.name == sym!(collect) && is_trait_method(cx, receiver, sym::Iterator);\n-        then {\n-            let ty = cx.typeck_results().expr_ty(receiver);\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            let is_empty_sugg = \"next().is_none()\".to_string();\n-            let method_name = method.ident.name.as_str();\n-            let sugg = if is_type_diagnostic_item(cx, ty, sym::Vec) ||\n-                        is_type_diagnostic_item(cx, ty, sym::VecDeque) ||\n-                        is_type_diagnostic_item(cx, ty, sym::LinkedList) ||\n-                        is_type_diagnostic_item(cx, ty, sym::BinaryHeap) {\n-                match method_name {\n-                    \"len\" => \"count()\".to_string(),\n-                    \"is_empty\" => is_empty_sugg,\n-                    \"contains\" => {\n-                        let contains_arg = snippet_with_applicability(cx, args[0].span, \"??\", &mut applicability);\n-                        let (arg, pred) = contains_arg\n-                            .strip_prefix('&')\n-                            .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n-                        format!(\"any(|{arg}| x == {pred})\")\n-                    }\n-                    _ => return,\n-                }\n-            }\n-            else if is_type_diagnostic_item(cx, ty, sym::BTreeMap) ||\n-                is_type_diagnostic_item(cx, ty, sym::HashMap) {\n-                match method_name {\n-                    \"is_empty\" => is_empty_sugg,\n-                    _ => return,\n-                }\n-            }\n-            else {\n-                return;\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                NEEDLESS_COLLECT,\n-                chain_method.ident.span.with_hi(expr.span.hi()),\n-                NEEDLESS_COLLECT_MSG,\n-                \"replace with\",\n-                sugg,\n-                applicability,\n-            );\n-        }\n-    }\n-}\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    name_span: Span,\n+    collect_expr: &'tcx Expr<'_>,\n+    iter_expr: &'tcx Expr<'tcx>,\n+    call_span: Span,\n+) {\n+    if let Some(parent) = get_parent_node(cx.tcx, collect_expr.hir_id) {\n+        match parent {\n+            Node::Expr(parent) => {\n+                if let ExprKind::MethodCall(name, _, args @ ([] | [_]), _) = parent.kind {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let name = name.ident.as_str();\n+                    let collect_ty = cx.typeck_results().expr_ty(collect_expr);\n \n-fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    if let ExprKind::Block(block, _) = expr.kind {\n-        for stmt in block.stmts {\n-            if_chain! {\n-                if let StmtKind::Local(local) = stmt.kind;\n-                if let PatKind::Binding(_, id, ..) = local.pat.kind;\n-                if let Some(init_expr) = local.init;\n-                if let ExprKind::MethodCall(method_name, iter_source, [], ..) = init_expr.kind;\n-                if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n-                let ty = cx.typeck_results().expr_ty(init_expr);\n-                if is_type_diagnostic_item(cx, ty, sym::Vec) ||\n-                    is_type_diagnostic_item(cx, ty, sym::VecDeque) ||\n-                    is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n-                    is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                let iter_ty = cx.typeck_results().expr_ty(iter_source);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, id, cx, get_captured_ids(cx, iter_ty));\n-                if let [iter_call] = &*iter_calls;\n-                then {\n+                    let sugg: String = match name {\n+                        \"len\" => {\n+                            if let Some(adt) = collect_ty.ty_adt_def()\n+                                && matches!(\n+                                    cx.tcx.get_diagnostic_name(adt.did()),\n+                                    Some(sym::Vec | sym::VecDeque | sym::LinkedList | sym::BinaryHeap)\n+                                )\n+                            {\n+                                \"count()\".into()\n+                            } else {\n+                                return;\n+                            }\n+                        },\n+                        \"is_empty\"\n+                            if is_is_empty_sig(cx, parent.hir_id)\n+                                && iterates_same_ty(cx, cx.typeck_results().expr_ty(iter_expr), collect_ty) =>\n+                        {\n+                            \"next().is_none()\".into()\n+                        },\n+                        \"contains\" => {\n+                            if is_contains_sig(cx, parent.hir_id, iter_expr)\n+                                && let Some(arg) = args.first()\n+                            {\n+                                let (span, prefix) = if let ExprKind::AddrOf(_, _, arg) = arg.kind {\n+                                    (arg.span, \"\")\n+                                } else {\n+                                    (arg.span, \"*\")\n+                                };\n+                                let snip = snippet_with_applicability(cx, span, \"??\", &mut app);\n+                                format!(\"any(|x| x == {prefix}{snip})\")\n+                            } else {\n+                                return;\n+                            }\n+                        },\n+                        _ => return,\n+                    };\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        call_span.with_hi(parent.span.hi()),\n+                        NEEDLESS_COLLECT_MSG,\n+                        \"replace with\",\n+                        sugg,\n+                        app,\n+                    );\n+                }\n+            },\n+            Node::Local(l) => {\n+                if let PatKind::Binding(BindingAnnotation::NONE | BindingAnnotation::MUT, id, _, None)\n+                    = l.pat.kind\n+                    && let ty = cx.typeck_results().expr_ty(collect_expr)\n+                    && [sym::Vec, sym::VecDeque, sym::BinaryHeap, sym::LinkedList].into_iter()\n+                        .any(|item| is_type_diagnostic_item(cx, ty, item))\n+                    && let iter_ty = cx.typeck_results().expr_ty(iter_expr)\n+                    && let Some(block) = get_enclosing_block(cx, l.hir_id)\n+                    && let Some(iter_calls) = detect_iter_and_into_iters(block, id, cx, get_captured_ids(cx, iter_ty))\n+                    && let [iter_call] = &*iter_calls\n+                {\n                     let mut used_count_visitor = UsedCountVisitor {\n                         cx,\n                         id,\n@@ -102,32 +107,82 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                     }\n \n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n-                    let mut span = MultiSpan::from_span(method_name.ident.span);\n+                    let mut span = MultiSpan::from_span(name_span);\n                     span.push_span_label(iter_call.span, \"the iterator could be used here instead\");\n                     span_lint_hir_and_then(\n                         cx,\n                         super::NEEDLESS_COLLECT,\n-                        init_expr.hir_id,\n+                        collect_expr.hir_id,\n                         span,\n                         NEEDLESS_COLLECT_MSG,\n                         |diag| {\n-                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_expr, \"..\"), iter_call.get_iter_method(cx));\n                             diag.multipart_suggestion(\n                                 iter_call.get_suggestion_text(),\n                                 vec![\n-                                    (stmt.span, String::new()),\n+                                    (l.span, String::new()),\n                                     (iter_call.span, iter_replacement)\n                                 ],\n                                 Applicability::MaybeIncorrect,\n                             );\n                         },\n                     );\n                 }\n-            }\n+            },\n+            _ => (),\n         }\n     }\n }\n \n+/// Checks if the given method call matches the expected signature of `([&[mut]] self) -> bool`\n+fn is_is_empty_sig(cx: &LateContext<'_>, call_id: HirId) -> bool {\n+    cx.typeck_results().type_dependent_def_id(call_id).map_or(false, |id| {\n+        let sig = cx.tcx.fn_sig(id).skip_binder();\n+        sig.inputs().len() == 1 && sig.output().is_bool()\n+    })\n+}\n+\n+/// Checks if `<iter_ty as Iterator>::Item` is the same as `<collect_ty as IntoIter>::Item`\n+fn iterates_same_ty<'tcx>(cx: &LateContext<'tcx>, iter_ty: Ty<'tcx>, collect_ty: Ty<'tcx>) -> bool {\n+    let item = Symbol::intern(\"Item\");\n+    if let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator)\n+        && let Some(into_iter_trait) = cx.tcx.get_diagnostic_item(sym::IntoIterator)\n+        && let Some(iter_item_ty) = make_normalized_projection(cx.tcx, cx.param_env, iter_trait, item, [iter_ty])\n+        && let Some(into_iter_item_proj) = make_projection(cx.tcx, into_iter_trait, item, [collect_ty])\n+        && let Ok(into_iter_item_ty) = cx.tcx.try_normalize_erasing_regions(\n+            cx.param_env,\n+            cx.tcx.mk_projection(into_iter_item_proj.item_def_id, into_iter_item_proj.substs)\n+        )\n+    {\n+        iter_item_ty == into_iter_item_ty\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Checks if the given method call matches the expected signature of\n+/// `([&[mut]] self, &<iter_ty as Iterator>::Item) -> bool`\n+fn is_contains_sig(cx: &LateContext<'_>, call_id: HirId, iter_expr: &Expr<'_>) -> bool {\n+    let typeck = cx.typeck_results();\n+    if let Some(id) = typeck.type_dependent_def_id(call_id)\n+        && let sig = cx.tcx.fn_sig(id)\n+        && sig.skip_binder().output().is_bool()\n+        && let [_, search_ty] = *sig.skip_binder().inputs()\n+        && let ty::Ref(_, search_ty, Mutability::Not) = *cx.tcx.erase_late_bound_regions(sig.rebind(search_ty)).kind()\n+        && let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator)\n+        && let Some(iter_item) = cx.tcx\n+            .associated_items(iter_trait)\n+            .find_by_name_and_kind(cx.tcx, Ident::with_dummy_span(Symbol::intern(\"Item\")), AssocKind::Type, iter_trait)\n+        && let substs = cx.tcx.mk_substs([GenericArg::from(typeck.expr_ty_adjusted(iter_expr))].into_iter())\n+        && let proj_ty = cx.tcx.mk_projection(iter_item.def_id, substs)\n+        && let Ok(item_ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, proj_ty)\n+    {\n+        item_ty == EarlyBinder(search_ty).subst(cx.tcx, cx.typeck_results().node_substs(call_id))\n+    } else {\n+        false\n+    }\n+}\n+\n struct IterFunction {\n     func: IterFunctionKind,\n     span: Span,", "previous_filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs"}, {"sha": "e6eb64bcbde64ad0abd70e444e806a30ee51777d", "filename": "src/tools/clippy/clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -13,8 +13,8 @@ use rustc_span::sym;\n use super::OPTION_AS_REF_DEREF;\n \n /// lint use of `_.as_ref().map(Deref::deref)` for `Option`s\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n     as_ref_recv: &hir::Expr<'_>,\n     map_arg: &hir::Expr<'_>,"}, {"sha": "4460f38fcc18f8ff5743eda8ecdbb1347617ce88", "filename": "src/tools/clippy/clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -83,6 +83,8 @@ pub(super) fn check<'tcx>(\n         method_span: Span,\n         self_expr: &hir::Expr<'_>,\n         arg: &'tcx hir::Expr<'_>,\n+        // `Some` if fn has second argument\n+        second_arg: Option<&hir::Expr<'_>>,\n         span: Span,\n         // None if lambda is required\n         fun_span: Option<Span>,\n@@ -109,30 +111,40 @@ pub(super) fn check<'tcx>(\n             if poss.contains(&name);\n \n             then {\n-                let macro_expanded_snipped;\n-                let sugg: Cow<'_, str> = {\n+                let sugg = {\n                     let (snippet_span, use_lambda) = match (fn_has_arguments, fun_span) {\n                         (false, Some(fun_span)) => (fun_span, false),\n                         _ => (arg.span, true),\n                     };\n-                    let snippet = {\n-                        let not_macro_argument_snippet = snippet_with_macro_callsite(cx, snippet_span, \"..\");\n-                        if not_macro_argument_snippet == \"vec![]\" {\n-                            macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n+\n+                    let format_span = |span: Span| {\n+                        let not_macro_argument_snippet = snippet_with_macro_callsite(cx, span, \"..\");\n+                        let snip = if not_macro_argument_snippet == \"vec![]\" {\n+                            let macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n                             match macro_expanded_snipped.strip_prefix(\"$crate::vec::\") {\n-                                Some(stripped) => Cow::from(stripped),\n+                                Some(stripped) => Cow::Owned(stripped.to_owned()),\n                                 None => macro_expanded_snipped,\n                             }\n                         } else {\n                             not_macro_argument_snippet\n-                        }\n+                        };\n+\n+                        snip.to_string()\n                     };\n \n-                    if use_lambda {\n+                    let snip = format_span(snippet_span);\n+                    let snip = if use_lambda {\n                         let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n-                        format!(\"|{l_arg}| {snippet}\").into()\n+                        format!(\"|{l_arg}| {snip}\")\n                     } else {\n-                        snippet\n+                        snip\n+                    };\n+\n+                    if let Some(f) = second_arg {\n+                        let f = format_span(f.span);\n+                        format!(\"{snip}, {f}\")\n+                    } else {\n+                        snip\n                     }\n                 };\n                 let span_replace_word = method_span.with_hi(span.hi());\n@@ -149,8 +161,8 @@ pub(super) fn check<'tcx>(\n         }\n     }\n \n-    if let [arg] = args {\n-        let inner_arg = if let hir::ExprKind::Block(\n+    let extract_inner_arg = |arg: &'tcx hir::Expr<'_>| {\n+        if let hir::ExprKind::Block(\n             hir::Block {\n                 stmts: [],\n                 expr: Some(expr),\n@@ -162,19 +174,32 @@ pub(super) fn check<'tcx>(\n             expr\n         } else {\n             arg\n-        };\n+        }\n+    };\n+\n+    if let [arg] = args {\n+        let inner_arg = extract_inner_arg(arg);\n         match inner_arg.kind {\n             hir::ExprKind::Call(fun, or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, arg, or_has_args, expr.span, method_span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };\n-                    check_general_case(cx, name, method_span, receiver, arg, expr.span, fun_span);\n+                    check_general_case(cx, name, method_span, receiver, arg, None, expr.span, fun_span);\n                 }\n             },\n             hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n-                check_general_case(cx, name, method_span, receiver, arg, expr.span, None);\n+                check_general_case(cx, name, method_span, receiver, arg, None, expr.span, None);\n             },\n             _ => (),\n         }\n     }\n+\n+    // `map_or` takes two arguments\n+    if let [arg, lambda] = args {\n+        let inner_arg = extract_inner_arg(arg);\n+        if let hir::ExprKind::Call(fun, or_args) = inner_arg.kind {\n+            let fun_span = if or_args.is_empty() { Some(fun.span) } else { None };\n+            check_general_case(cx, name, method_span, receiver, arg, Some(lambda), expr.span, fun_span);\n+        }\n+    }\n }"}, {"sha": "361a3082f949a12baec89f13955c8701ebb8aaad", "filename": "src/tools/clippy/clippy_lints/src/methods/seek_from_current.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_from_current.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_from_current.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_from_current.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,48 @@\n+use rustc_ast::ast::{LitIntType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg, get_trait_def_id, match_def_path, paths, source::snippet_with_applicability,\n+    ty::implements_trait,\n+};\n+\n+use super::SEEK_FROM_CURRENT;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'tcx Expr<'_>, arg: &'tcx Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(recv);\n+\n+    if let Some(def_id) = get_trait_def_id(cx, &paths::STD_IO_SEEK) {\n+        if implements_trait(cx, ty, def_id, &[]) && arg_is_seek_from_current(cx, arg) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let snip = snippet_with_applicability(cx, recv.span, \"..\", &mut applicability);\n+\n+            span_lint_and_sugg(\n+                cx,\n+                SEEK_FROM_CURRENT,\n+                expr.span,\n+                \"using `SeekFrom::Current` to start from current position\",\n+                \"replace with\",\n+                format!(\"{snip}.stream_position()\"),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+fn arg_is_seek_from_current<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if let ExprKind::Call(f, args) = expr.kind &&\n+        let ExprKind::Path(ref path) = f.kind &&\n+        let Some(def_id) = cx.qpath_res(path, f.hir_id).opt_def_id() &&\n+        match_def_path(cx, def_id, &paths::STD_IO_SEEK_FROM_CURRENT) {\n+        // check if argument of `SeekFrom::Current` is `0`\n+        if args.len() == 1 &&\n+            let ExprKind::Lit(ref lit) = args[0].kind &&\n+            let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node {\n+            return true\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "7e3bed1e41a9457d9ca485d17ac4c0b92cf52dc7", "filename": "src/tools/clippy/clippy_lints/src/methods/seek_to_start_instead_of_rewind.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_to_start_instead_of_rewind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_to_start_instead_of_rewind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fseek_to_start_instead_of_rewind.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,45 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::ty::implements_trait;\n+use clippy_utils::{get_trait_def_id, match_def_path, paths};\n+use rustc_ast::ast::{LitIntType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::Span;\n+\n+use super::SEEK_TO_START_INSTEAD_OF_REWIND;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    recv: &'tcx Expr<'_>,\n+    arg: &'tcx Expr<'_>,\n+    name_span: Span,\n+) {\n+    // Get receiver type\n+    let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+\n+    if let Some(seek_trait_id) = get_trait_def_id(cx, &paths::STD_IO_SEEK) &&\n+        implements_trait(cx, ty, seek_trait_id, &[]) &&\n+        let ExprKind::Call(func, args1) = arg.kind &&\n+        let ExprKind::Path(ref path) = func.kind &&\n+        let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id() &&\n+        match_def_path(cx, def_id, &paths::STD_IO_SEEKFROM_START) &&\n+        args1.len() == 1 &&\n+        let ExprKind::Lit(ref lit) = args1[0].kind &&\n+        let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node\n+    {\n+        let method_call_span = expr.span.with_lo(name_span.lo());\n+        span_lint_and_then(\n+            cx,\n+            SEEK_TO_START_INSTEAD_OF_REWIND,\n+            method_call_span,\n+            \"used `seek` to go to the start of the stream\",\n+            |diag| {\n+                let app = Applicability::MachineApplicable;\n+\n+                diag.span_suggestion(method_call_span, \"replace with\", \"rewind()\", app);\n+            },\n+        );\n+    }\n+}"}, {"sha": "f35d81cee8e97f969bb8b16c04ff39b494270704", "filename": "src/tools/clippy/clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -18,7 +18,11 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         let target = &arglists[0].0;\n         let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n         let ref_str = if *self_ty.kind() == ty::Str {\n-            \"\"\n+            if matches!(target.kind, hir::ExprKind::Index(..)) {\n+                \"&\"\n+            } else {\n+                \"\"\n+            }\n         } else if is_type_lang_item(cx, self_ty, hir::LangItem::String) {\n             \"&\"\n         } else {"}, {"sha": "2ac0786b37b1e73fd431cd3267c30b0992bed0b3", "filename": "src/tools/clippy/clippy_lints/src/methods/suspicious_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -8,7 +8,7 @@ use rustc_span::sym;\n \n use super::SUSPICIOUS_MAP;\n \n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, count_recv: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) {\n+pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, count_recv: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) {\n     if_chain! {\n         if is_trait_method(cx, count_recv, sym::Iterator);\n         let closure = expr_or_init(cx, map_arg);"}, {"sha": "087e1e4343b707b4e29a87bcd9012ecd38e6de62", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -31,7 +31,7 @@ pub(super) fn check<'tcx>(\n                 cx,\n                 UNNECESSARY_JOIN,\n                 span.with_hi(expr.span.hi()),\n-                r#\"called `.collect<Vec<String>>().join(\"\")` on an iterator\"#,\n+                r#\"called `.collect::<Vec<String>>().join(\"\")` on an iterator\"#,\n                 \"try using\",\n                 \"collect::<String>()\".to_owned(),\n                 applicability,"}, {"sha": "90983f249cd59eae7dcb6af4f4b1eb4b5762ce6c", "filename": "src/tools/clippy/clippy_lints/src/methods/unwrap_used.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_in_test_function, is_lint_allowed};\n+use clippy_utils::{is_in_cfg_test, is_lint_allowed};\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::sym;\n@@ -18,16 +18,16 @@ pub(super) fn check(\n     let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) && !is_err {\n-        Some((UNWRAP_USED, \"an Option\", \"None\", \"\"))\n+        Some((UNWRAP_USED, \"an `Option`\", \"None\", \"\"))\n     } else if is_type_diagnostic_item(cx, obj_ty, sym::Result) {\n-        Some((UNWRAP_USED, \"a Result\", if is_err { \"Ok\" } else { \"Err\" }, \"an \"))\n+        Some((UNWRAP_USED, \"a `Result`\", if is_err { \"Ok\" } else { \"Err\" }, \"an \"))\n     } else {\n         None\n     };\n \n     let method_suffix = if is_err { \"_err\" } else { \"\" };\n \n-    if allow_unwrap_in_tests && is_in_test_function(cx.tcx, expr.hir_id) {\n+    if allow_unwrap_in_tests && is_in_cfg_test(cx.tcx, expr.hir_id) {\n         return;\n     }\n \n@@ -45,7 +45,7 @@ pub(super) fn check(\n             cx,\n             lint,\n             expr.span,\n-            &format!(\"used `unwrap{method_suffix}()` on `{kind}` value\"),\n+            &format!(\"used `unwrap{method_suffix}()` on {kind} value\"),\n             None,\n             &help,\n         );"}, {"sha": "4712846939e6a0fcaae2a242895f7d9709988314", "filename": "src/tools/clippy/clippy_lints/src/missing_enforced_import_rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -59,7 +59,7 @@ impl LateLintPass<'_> for ImportRename {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for Rename { path, rename } in &self.conf_renames {\n             let segs = path.split(\"::\").collect::<Vec<_>>();\n-            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs, None) {\n+            for id in clippy_utils::def_path_def_ids(cx, &segs) {\n                 self.renames.insert(id, Symbol::intern(rename));\n             }\n         }"}, {"sha": "321fa4b7f9996681000b59321216a3474766df11", "filename": "src/tools/clippy/clippy_lints/src/mixed_read_write_in_expression.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -218,7 +218,7 @@ enum StopEarly {\n     Stop,\n }\n \n-fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr<'_>) -> StopEarly {\n+fn check_expr<'tcx>(vis: &mut ReadVisitor<'_, 'tcx>, expr: &'tcx Expr<'_>) -> StopEarly {\n     if expr.hir_id == vis.last_expr.hir_id {\n         return StopEarly::KeepGoing;\n     }\n@@ -265,7 +265,7 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr<'_>) -\n     StopEarly::KeepGoing\n }\n \n-fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt<'_>) -> StopEarly {\n+fn check_stmt<'tcx>(vis: &mut ReadVisitor<'_, 'tcx>, stmt: &'tcx Stmt<'_>) -> StopEarly {\n     match stmt.kind {\n         StmtKind::Expr(expr) | StmtKind::Semi(expr) => check_expr(vis, expr),\n         // If the declaration is of a local variable, check its initializer"}, {"sha": "a651020ca6566341d086bb723d4a85af68c1187e", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 91, "deletions": 64, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::trait_ref_of_method;\n+use clippy_utils::{def_path_def_ids, trait_ref_of_method};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{Adt, Array, Ref, Slice, Tuple, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n use std::iter;\n@@ -78,100 +79,126 @@ declare_clippy_lint! {\n     \"Check for mutable `Map`/`Set` key type\"\n }\n \n-declare_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n+#[derive(Clone)]\n+pub struct MutableKeyType {\n+    ignore_interior_mutability: Vec<String>,\n+    ignore_mut_def_ids: FxHashSet<hir::def_id::DefId>,\n+}\n+\n+impl_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n \n impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n+    fn check_crate(&mut self, cx: &LateContext<'tcx>) {\n+        self.ignore_mut_def_ids.clear();\n+        let mut path = Vec::new();\n+        for ty in &self.ignore_interior_mutability {\n+            path.extend(ty.split(\"::\"));\n+            for id in def_path_def_ids(cx, &path[..]) {\n+                self.ignore_mut_def_ids.insert(id);\n+            }\n+            path.clear();\n+        }\n+    }\n+\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id(), sig.decl);\n+            self.check_sig(cx, item.hir_id(), sig.decl);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n             if trait_ref_of_method(cx, item.owner_id.def_id).is_none() {\n-                check_sig(cx, item.hir_id(), sig.decl);\n+                self.check_sig(cx, item.hir_id(), sig.decl);\n             }\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'tcx>) {\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id(), sig.decl);\n+            self.check_sig(cx, item.hir_id(), sig.decl);\n         }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'_>, local: &hir::Local<'_>) {\n         if let hir::PatKind::Wild = local.pat.kind {\n             return;\n         }\n-        check_ty(cx, local.span, cx.typeck_results().pat_ty(local.pat));\n+        self.check_ty_(cx, local.span, cx.typeck_results().pat_ty(local.pat));\n     }\n }\n \n-fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::FnDecl<'_>) {\n-    let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n-    let fn_sig = cx.tcx.fn_sig(fn_def_id);\n-    for (hir_ty, ty) in iter::zip(decl.inputs, fn_sig.inputs().skip_binder()) {\n-        check_ty(cx, hir_ty.span, *ty);\n+impl MutableKeyType {\n+    pub fn new(ignore_interior_mutability: Vec<String>) -> Self {\n+        Self {\n+            ignore_interior_mutability,\n+            ignore_mut_def_ids: FxHashSet::default(),\n+        }\n     }\n-    check_ty(cx, decl.output.span(), cx.tcx.erase_late_bound_regions(fn_sig.output()));\n-}\n \n-// We want to lint 1. sets or maps with 2. not immutable key types and 3. no unerased\n-// generics (because the compiler cannot ensure immutability for unknown types).\n-fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n-    let ty = ty.peel_refs();\n-    if let Adt(def, substs) = ty.kind() {\n-        let is_keyed_type = [sym::HashMap, sym::BTreeMap, sym::HashSet, sym::BTreeSet]\n-            .iter()\n-            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n-        if is_keyed_type && is_interior_mutable_type(cx, substs.type_at(0), span) {\n-            span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n+    fn check_sig(&self, cx: &LateContext<'_>, item_hir_id: hir::HirId, decl: &hir::FnDecl<'_>) {\n+        let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n+        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n+        for (hir_ty, ty) in iter::zip(decl.inputs, fn_sig.inputs().skip_binder()) {\n+            self.check_ty_(cx, hir_ty.span, *ty);\n         }\n+        self.check_ty_(cx, decl.output.span(), cx.tcx.erase_late_bound_regions(fn_sig.output()));\n     }\n-}\n \n-/// Determines if a type contains interior mutability which would affect its implementation of\n-/// [`Hash`] or [`Ord`].\n-fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n-    match *ty.kind() {\n-        Ref(_, inner_ty, mutbl) => {\n-            mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span)\n-        }\n-        Slice(inner_ty) => is_interior_mutable_type(cx, inner_ty, span),\n-        Array(inner_ty, size) => {\n-            size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n-                && is_interior_mutable_type(cx, inner_ty, span)\n-        }\n-        Tuple(fields) => fields.iter().any(|ty| is_interior_mutable_type(cx, ty, span)),\n-        Adt(def, substs) => {\n-            // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n-            // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n-            // because they have no impl for `Hash` or `Ord`.\n-            let is_std_collection = [\n-                sym::Option,\n-                sym::Result,\n-                sym::LinkedList,\n-                sym::Vec,\n-                sym::VecDeque,\n-                sym::BTreeMap,\n-                sym::BTreeSet,\n-                sym::Rc,\n-                sym::Arc,\n-            ]\n-            .iter()\n-            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n-            let is_box = Some(def.did()) == cx.tcx.lang_items().owned_box();\n-            if is_std_collection || is_box {\n-                // The type is mutable if any of its type parameters are\n-                substs.types().any(|ty| is_interior_mutable_type(cx, ty, span))\n-            } else {\n-                !ty.has_escaping_bound_vars()\n-                    && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                    && !ty.is_freeze(cx.tcx, cx.param_env)\n+    // We want to lint 1. sets or maps with 2. not immutable key types and 3. no unerased\n+    // generics (because the compiler cannot ensure immutability for unknown types).\n+    fn check_ty_<'tcx>(&self, cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n+        let ty = ty.peel_refs();\n+        if let Adt(def, substs) = ty.kind() {\n+            let is_keyed_type = [sym::HashMap, sym::BTreeMap, sym::HashSet, sym::BTreeSet]\n+                .iter()\n+                .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n+            if is_keyed_type && self.is_interior_mutable_type(cx, substs.type_at(0)) {\n+                span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n             }\n         }\n-        _ => false,\n+    }\n+\n+    /// Determines if a type contains interior mutability which would affect its implementation of\n+    /// [`Hash`] or [`Ord`].\n+    fn is_interior_mutable_type<'tcx>(&self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+        match *ty.kind() {\n+            Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || self.is_interior_mutable_type(cx, inner_ty),\n+            Slice(inner_ty) => self.is_interior_mutable_type(cx, inner_ty),\n+            Array(inner_ty, size) => {\n+                size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n+                    && self.is_interior_mutable_type(cx, inner_ty)\n+            },\n+            Tuple(fields) => fields.iter().any(|ty| self.is_interior_mutable_type(cx, ty)),\n+            Adt(def, substs) => {\n+                // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n+                // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n+                // because they have no impl for `Hash` or `Ord`.\n+                let def_id = def.did();\n+                let is_std_collection = [\n+                    sym::Option,\n+                    sym::Result,\n+                    sym::LinkedList,\n+                    sym::Vec,\n+                    sym::VecDeque,\n+                    sym::BTreeMap,\n+                    sym::BTreeSet,\n+                    sym::Rc,\n+                    sym::Arc,\n+                ]\n+                .iter()\n+                .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def_id));\n+                let is_box = Some(def_id) == cx.tcx.lang_items().owned_box();\n+                if is_std_collection || is_box || self.ignore_mut_def_ids.contains(&def_id) {\n+                    // The type is mutable if any of its type parameters are\n+                    substs.types().any(|ty| self.is_interior_mutable_type(cx, ty))\n+                } else {\n+                    !ty.has_escaping_bound_vars()\n+                        && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n+                        && !ty.is_freeze(cx.tcx, cx.param_env)\n+                }\n+            },\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "bc90e131b7f3be65b1ff008599796c50d5da7f7f", "filename": "src/tools/clippy/clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -68,13 +68,15 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind() {\n-                span_lint(\n-                    self.cx,\n-                    MUT_MUT,\n-                    expr.span,\n-                    \"this expression mutably borrows a mutable reference. Consider reborrowing\",\n-                );\n+            } else if let ty::Ref(_, ty, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind() {\n+                if ty.peel_refs().is_sized(self.cx.tcx, self.cx.param_env) {\n+                    span_lint(\n+                        self.cx,\n+                        MUT_MUT,\n+                        expr.span,\n+                        \"this expression mutably borrows a mutable reference. Consider reborrowing\",\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "498e1408e52a064836a713f5d184f5a5ad1bd64d", "filename": "src/tools/clippy/clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 69, "deletions": 39, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -36,14 +36,14 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessBorrowedRef => [NEEDLESS_BORROWED_REFERENCE]);\n \n impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n-    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if pat.span.from_expansion() {\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, ref_pat: &'tcx Pat<'_>) {\n+        if ref_pat.span.from_expansion() {\n             // OK, simple enough, lints doesn't check in macro.\n             return;\n         }\n \n         // Do not lint patterns that are part of an OR `|` pattern, the binding mode must match in all arms\n-        for (_, node) in cx.tcx.hir().parent_iter(pat.hir_id) {\n+        for (_, node) in cx.tcx.hir().parent_iter(ref_pat.hir_id) {\n             let Node::Pat(pat) = node else { break };\n \n             if matches!(pat.kind, PatKind::Or(_)) {\n@@ -52,20 +52,20 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n         }\n \n         // Only lint immutable refs, because `&mut ref T` may be useful.\n-        let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind else { return };\n+        let PatKind::Ref(pat, Mutability::Not) = ref_pat.kind else { return };\n \n-        match sub_pat.kind {\n+        match pat.kind {\n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n             PatKind::Binding(BindingAnnotation::REF, _, ident, None) => {\n                 span_lint_and_then(\n                     cx,\n                     NEEDLESS_BORROWED_REFERENCE,\n-                    pat.span,\n+                    ref_pat.span,\n                     \"this pattern takes a reference on something that is being dereferenced\",\n                     |diag| {\n                         // `&ref ident`\n                         //  ^^^^^\n-                        let span = pat.span.until(ident.span);\n+                        let span = ref_pat.span.until(ident.span);\n                         diag.span_suggestion_verbose(\n                             span,\n                             \"try removing the `&ref` part\",\n@@ -84,41 +84,71 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n                 }),\n                 after,\n             ) => {\n-                let mut suggestions = Vec::new();\n-\n-                for element_pat in itertools::chain(before, after) {\n-                    if let PatKind::Binding(BindingAnnotation::REF, _, ident, None) = element_pat.kind {\n-                        // `&[..., ref ident, ...]`\n-                        //         ^^^^\n-                        let span = element_pat.span.until(ident.span);\n-                        suggestions.push((span, String::new()));\n-                    } else {\n-                        return;\n-                    }\n-                }\n+                check_subpatterns(\n+                    cx,\n+                    \"dereferencing a slice pattern where every element takes a reference\",\n+                    ref_pat,\n+                    pat,\n+                    itertools::chain(before, after),\n+                );\n+            },\n+            PatKind::Tuple(subpatterns, _) | PatKind::TupleStruct(_, subpatterns, _) => {\n+                check_subpatterns(\n+                    cx,\n+                    \"dereferencing a tuple pattern where every element takes a reference\",\n+                    ref_pat,\n+                    pat,\n+                    subpatterns,\n+                );\n+            },\n+            PatKind::Struct(_, fields, _) => {\n+                check_subpatterns(\n+                    cx,\n+                    \"dereferencing a struct pattern where every field's pattern takes a reference\",\n+                    ref_pat,\n+                    pat,\n+                    fields.iter().map(|field| field.pat),\n+                );\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n \n-                if !suggestions.is_empty() {\n-                    span_lint_and_then(\n-                        cx,\n-                        NEEDLESS_BORROWED_REFERENCE,\n-                        pat.span,\n-                        \"dereferencing a slice pattern where every element takes a reference\",\n-                        |diag| {\n-                            // `&[...]`\n-                            //  ^\n-                            let span = pat.span.until(sub_pat.span);\n-                            suggestions.push((span, String::new()));\n+fn check_subpatterns<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    message: &str,\n+    ref_pat: &Pat<'_>,\n+    pat: &Pat<'_>,\n+    subpatterns: impl IntoIterator<Item = &'tcx Pat<'tcx>>,\n+) {\n+    let mut suggestions = Vec::new();\n \n-                            diag.multipart_suggestion(\n-                                \"try removing the `&` and `ref` parts\",\n-                                suggestions,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        },\n-                    );\n-                }\n+    for subpattern in subpatterns {\n+        match subpattern.kind {\n+            PatKind::Binding(BindingAnnotation::REF, _, ident, None) => {\n+                // `ref ident`\n+                //  ^^^^\n+                let span = subpattern.span.until(ident.span);\n+                suggestions.push((span, String::new()));\n             },\n-            _ => {},\n+            PatKind::Wild => {},\n+            _ => return,\n         }\n     }\n+\n+    if !suggestions.is_empty() {\n+        span_lint_and_then(cx, NEEDLESS_BORROWED_REFERENCE, ref_pat.span, message, |diag| {\n+            // `&pat`\n+            //  ^\n+            let span = ref_pat.span.until(pat.span);\n+            suggestions.push((span, String::new()));\n+\n+            diag.multipart_suggestion(\n+                \"try removing the `&` and `ref` parts\",\n+                suggestions,\n+                Applicability::MachineApplicable,\n+            );\n+        });\n+    }\n }"}, {"sha": "38a75034cd314857f0c1489a1def0cdaf5db7007", "filename": "src/tools/clippy/clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -287,7 +287,7 @@ const DROP_ELSE_BLOCK_MSG: &str = \"consider dropping the `else` clause\";\n \n const DROP_CONTINUE_EXPRESSION_MSG: &str = \"consider dropping the `continue` expression\";\n \n-fn emit_warning<'a>(cx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str, typ: LintType) {\n+fn emit_warning(cx: &EarlyContext<'_>, data: &LintData<'_>, header: &str, typ: LintType) {\n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n@@ -313,7 +313,7 @@ fn emit_warning<'a>(cx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str,\n     );\n }\n \n-fn suggestion_snippet_for_continue_inside_if<'a>(cx: &EarlyContext<'_>, data: &'a LintData<'_>) -> String {\n+fn suggestion_snippet_for_continue_inside_if(cx: &EarlyContext<'_>, data: &LintData<'_>) -> String {\n     let cond_code = snippet(cx, data.if_cond.span, \"..\");\n \n     let continue_code = snippet_block(cx, data.if_block.span, \"..\", Some(data.if_expr.span));\n@@ -327,7 +327,7 @@ fn suggestion_snippet_for_continue_inside_if<'a>(cx: &EarlyContext<'_>, data: &'\n     )\n }\n \n-fn suggestion_snippet_for_continue_inside_else<'a>(cx: &EarlyContext<'_>, data: &'a LintData<'_>) -> String {\n+fn suggestion_snippet_for_continue_inside_else(cx: &EarlyContext<'_>, data: &LintData<'_>) -> String {\n     let cond_code = snippet(cx, data.if_cond.span, \"..\");\n \n     // Region B\n@@ -361,7 +361,7 @@ fn suggestion_snippet_for_continue_inside_else<'a>(cx: &EarlyContext<'_>, data:\n     )\n }\n \n-fn check_and_warn<'a>(cx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n+fn check_and_warn(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::Loop(loop_block, ..) = &expr.kind;\n         if let Some(last_stmt) = loop_block.stmts.last();"}, {"sha": "2ef902965f66d4db276533355a4706eac991baeb", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -340,11 +340,5 @@ impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n \n     fn mutate(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: HirId) {}\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {\n-    }\n+    fn fake_read(&mut self, _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }"}, {"sha": "ae0a41db918a3447067342479161c62939e71e9e", "filename": "src/tools/clippy/clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -58,9 +58,9 @@ impl EarlyLintPass for OctalEscapes {\n \n         if let ExprKind::Lit(token_lit) = &expr.kind {\n             if matches!(token_lit.kind, LitKind::Str) {\n-                check_lit(cx, &token_lit, expr.span, true);\n+                check_lit(cx, token_lit, expr.span, true);\n             } else if matches!(token_lit.kind, LitKind::ByteStr) {\n-                check_lit(cx, &token_lit, expr.span, false);\n+                check_lit(cx, token_lit, expr.span, false);\n             }\n         }\n     }"}, {"sha": "20b82d81a2aeb64e57d11994ceb3755a96e4cde4", "filename": "src/tools/clippy/clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,5 +1,9 @@\n use super::ARITHMETIC_SIDE_EFFECTS;\n-use clippy_utils::{consts::constant_simple, diagnostics::span_lint};\n+use clippy_utils::{\n+    consts::{constant, constant_simple},\n+    diagnostics::span_lint,\n+    peel_hir_expr_refs,\n+};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -38,24 +42,6 @@ impl ArithmeticSideEffects {\n         }\n     }\n \n-    /// Assuming that `expr` is a literal integer, checks operators (+=, -=, *, /) in a\n-    /// non-constant environment that won't overflow.\n-    fn has_valid_op(op: &Spanned<hir::BinOpKind>, expr: &hir::Expr<'_>) -> bool {\n-        if let hir::ExprKind::Lit(ref lit) = expr.kind &&\n-            let ast::LitKind::Int(value, _) = lit.node\n-        {\n-            match (&op.node, value) {\n-                (hir::BinOpKind::Div | hir::BinOpKind::Rem, 0) => false,\n-                (hir::BinOpKind::Add | hir::BinOpKind::Sub, 0)\n-                    | (hir::BinOpKind::Div | hir::BinOpKind::Rem, _)\n-                    | (hir::BinOpKind::Mul, 0 | 1) => true,\n-                _ => false,\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n     /// Checks if the given `expr` has any of the inner `allowed` elements.\n     fn is_allowed_ty(&self, ty: Ty<'_>) -> bool {\n         self.allowed\n@@ -74,15 +60,14 @@ impl ArithmeticSideEffects {\n         self.expr_span = Some(expr.span);\n     }\n \n-    /// If `expr` does not match any variant of `LiteralIntegerTy`, returns `None`.\n-    fn literal_integer<'expr, 'tcx>(expr: &'expr hir::Expr<'tcx>) -> Option<LiteralIntegerTy<'expr, 'tcx>> {\n-        if matches!(expr.kind, hir::ExprKind::Lit(_)) {\n-            return Some(LiteralIntegerTy::Value(expr));\n+    /// If `expr` is not a literal integer like `1`, returns `None`.\n+    fn literal_integer(expr: &hir::Expr<'_>) -> Option<u128> {\n+        if let hir::ExprKind::Lit(ref lit) = expr.kind && let ast::LitKind::Int(n, _) = lit.node {\n+            Some(n)\n         }\n-        if let hir::ExprKind::AddrOf(.., inn) = expr.kind && let hir::ExprKind::Lit(_) = inn.kind {\n-            return Some(LiteralIntegerTy::Ref(inn));\n+        else {\n+            None\n         }\n-        None\n     }\n \n     /// Manages when the lint should be triggered. Operations in constant environments, hard coded\n@@ -117,10 +102,20 @@ impl ArithmeticSideEffects {\n             return;\n         }\n         let has_valid_op = if Self::is_integral(lhs_ty) && Self::is_integral(rhs_ty) {\n-            match (Self::literal_integer(lhs), Self::literal_integer(rhs)) {\n-                (None, Some(lit_int_ty)) | (Some(lit_int_ty), None) => Self::has_valid_op(op, lit_int_ty.into()),\n-                (Some(LiteralIntegerTy::Value(_)), Some(LiteralIntegerTy::Value(_))) => true,\n-                (None, None) | (Some(_), Some(_)) => false,\n+            let (actual_lhs, lhs_ref_counter) = peel_hir_expr_refs(lhs);\n+            let (actual_rhs, rhs_ref_counter) = peel_hir_expr_refs(rhs);\n+            match (Self::literal_integer(actual_lhs), Self::literal_integer(actual_rhs)) {\n+                (None, None) => false,\n+                (None, Some(n)) | (Some(n), None) => match (&op.node, n) {\n+                    (hir::BinOpKind::Div | hir::BinOpKind::Rem, 0) => false,\n+                    (hir::BinOpKind::Add | hir::BinOpKind::Sub, 0)\n+                    | (hir::BinOpKind::Div | hir::BinOpKind::Rem, _)\n+                    | (hir::BinOpKind::Mul, 0 | 1) => true,\n+                    _ => false,\n+                },\n+                (Some(_), Some(_)) => {\n+                    matches!((lhs_ref_counter, rhs_ref_counter), (0, 0))\n+                },\n             }\n         } else {\n             false\n@@ -129,21 +124,45 @@ impl ArithmeticSideEffects {\n             self.issue_lint(cx, expr);\n         }\n     }\n+\n+    fn manage_unary_ops<'tcx>(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        expr: &hir::Expr<'tcx>,\n+        un_expr: &hir::Expr<'tcx>,\n+        un_op: hir::UnOp,\n+    ) {\n+        let hir::UnOp::Neg = un_op else { return; };\n+        if constant(cx, cx.typeck_results(), un_expr).is_some() {\n+            return;\n+        }\n+        let ty = cx.typeck_results().expr_ty(expr).peel_refs();\n+        if self.is_allowed_ty(ty) {\n+            return;\n+        }\n+        let actual_un_expr = peel_hir_expr_refs(un_expr).0;\n+        if Self::literal_integer(actual_un_expr).is_some() {\n+            return;\n+        }\n+        self.issue_lint(cx, expr);\n+    }\n+\n+    fn should_skip_expr(&mut self, expr: &hir::Expr<'_>) -> bool {\n+        self.expr_span.is_some() || self.const_span.map_or(false, |sp| sp.contains(expr.span))\n+    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for ArithmeticSideEffects {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &hir::Expr<'tcx>) {\n-        if self.expr_span.is_some() || self.const_span.map_or(false, |sp| sp.contains(expr.span)) {\n+        if self.should_skip_expr(expr) {\n             return;\n         }\n         match &expr.kind {\n-            hir::ExprKind::Binary(op, lhs, rhs) | hir::ExprKind::AssignOp(op, lhs, rhs) => {\n+            hir::ExprKind::AssignOp(op, lhs, rhs) | hir::ExprKind::Binary(op, lhs, rhs) => {\n                 self.manage_bin_ops(cx, expr, op, lhs, rhs);\n             },\n-            hir::ExprKind::Unary(hir::UnOp::Neg, _) => {\n-                if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n-                    self.issue_lint(cx, expr);\n-                }\n+            hir::ExprKind::Unary(un_op, un_expr) => {\n+                self.manage_unary_ops(cx, expr, un_expr, *un_op);\n             },\n             _ => {},\n         }\n@@ -177,22 +196,3 @@ impl<'tcx> LateLintPass<'tcx> for ArithmeticSideEffects {\n         }\n     }\n }\n-\n-/// Tells if an expression is a integer declared by value or by reference.\n-///\n-/// If `LiteralIntegerTy::Ref`, then the contained value will be `hir::ExprKind::Lit` rather\n-/// than `hirExprKind::Addr`.\n-enum LiteralIntegerTy<'expr, 'tcx> {\n-    /// For example, `&199`\n-    Ref(&'expr hir::Expr<'tcx>),\n-    /// For example, `1` or `i32::MAX`\n-    Value(&'expr hir::Expr<'tcx>),\n-}\n-\n-impl<'expr, 'tcx> From<LiteralIntegerTy<'expr, 'tcx>> for &'expr hir::Expr<'tcx> {\n-    fn from(from: LiteralIntegerTy<'expr, 'tcx>) -> Self {\n-        match from {\n-            LiteralIntegerTy::Ref(elem) | LiteralIntegerTy::Value(elem) => elem,\n-        }\n-    }\n-}"}, {"sha": "d7917e86a861f4fa57f5ada7f497293e51214f65", "filename": "src/tools/clippy/clippy_lints/src/operators/op_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -199,7 +199,7 @@ fn in_impl<'tcx>(\n     }\n }\n \n-fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n+fn are_equal(cx: &LateContext<'_>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n     if_chain! {\n         if let ty::Adt(adt_def, _) = middle_ty.kind();\n         if let Some(local_did) = adt_def.did().as_local();"}, {"sha": "472f52380bbf479ac0c22b9218b0637abcc3c4ea", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -213,11 +213,14 @@ fn try_convert_match<'tcx>(\n     cx: &LateContext<'tcx>,\n     arms: &[Arm<'tcx>],\n ) -> Option<(&'tcx Pat<'tcx>, &'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n-    if arms.len() == 2 {\n-        return if is_none_or_err_arm(cx, &arms[1]) {\n-            Some((arms[0].pat, arms[0].body, arms[1].body))\n-        } else if is_none_or_err_arm(cx, &arms[0]) {\n-            Some((arms[1].pat, arms[1].body, arms[0].body))\n+    if let [first_arm, second_arm] = arms\n+        && first_arm.guard.is_none()\n+        && second_arm.guard.is_none()\n+        {\n+        return if is_none_or_err_arm(cx, second_arm) {\n+            Some((first_arm.pat, first_arm.body, second_arm.body))\n+        } else if is_none_or_err_arm(cx, first_arm) {\n+            Some((second_arm.pat, second_arm.body, first_arm.body))\n         } else {\n             None\n         };"}, {"sha": "456ded3fc02680de1c7e03a2433399f5e965b857", "filename": "src/tools/clippy/clippy_lints/src/partialeq_to_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_to_none.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -33,7 +33,7 @@ declare_clippy_lint! {\n     ///     if f.is_some() { \"yay\" } else { \"nay\" }\n     /// }\n     /// ```\n-    #[clippy::version = \"1.64.0\"]\n+    #[clippy::version = \"1.65.0\"]\n     pub PARTIALEQ_TO_NONE,\n     style,\n     \"Binary comparison to `Option<T>::None` relies on `T: PartialEq`, which is unneeded\""}, {"sha": "97b5a4ce36413f4820b209a68f45c3beeb26db54", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -130,7 +130,7 @@ enum DerefPossible {\n     Impossible,\n }\n \n-fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, deref_possible: DerefPossible) -> bool {\n+fn apply_lint(cx: &LateContext<'_>, pat: &Pat<'_>, deref_possible: DerefPossible) -> bool {\n     let maybe_mismatch = find_first_mismatch(cx, pat);\n     if let Some((span, mutability, level)) = maybe_mismatch {\n         span_lint_and_help(\n@@ -163,7 +163,7 @@ enum Level {\n     Lower,\n }\n \n-fn find_first_mismatch<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> Option<(Span, Mutability, Level)> {\n+fn find_first_mismatch(cx: &LateContext<'_>, pat: &Pat<'_>) -> Option<(Span, Mutability, Level)> {\n     let mut result = None;\n     pat.walk(|p| {\n         if result.is_some() {"}, {"sha": "47b8891e12302b4e4ef6f9526f1b012307158d4d", "filename": "src/tools/clippy/clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -105,17 +105,17 @@ fn expr_as_ptr_offset_call<'tcx>(\n }\n \n // Is the type of the expression a usize?\n-fn is_expr_ty_usize<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n+fn is_expr_ty_usize(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     cx.typeck_results().expr_ty(expr) == cx.tcx.types.usize\n }\n \n // Is the type of the expression a raw pointer?\n-fn is_expr_ty_raw_ptr<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n+fn is_expr_ty_raw_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     cx.typeck_results().expr_ty(expr).is_unsafe_ptr()\n }\n \n-fn build_suggestion<'tcx>(\n-    cx: &LateContext<'tcx>,\n+fn build_suggestion(\n+    cx: &LateContext<'_>,\n     method: Method,\n     receiver_expr: &Expr<'_>,\n     cast_lhs_expr: &Expr<'_>,"}, {"sha": "5269bbd1f1acc06d510294fd2b018de8cf78c4c6", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -189,6 +189,7 @@ fn is_early_return(smbl: Symbol, cx: &LateContext<'_>, if_block: &IfBlockType<'_\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, Some(let_pat_sym)))\n                             || is_res_lang_ctor(cx, res, ResultErr)\n                                 && expr_return_none_or_err(smbl, cx, if_then, let_expr, Some(let_pat_sym))\n+                                && if_else.is_none()\n                     },\n                     _ => false,\n                 }"}, {"sha": "8e675d34a183698b970e86e0fca4f5dd27c1903d", "filename": "src/tools/clippy/clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -105,8 +105,8 @@ impl EarlyLintPass for RedundantClosureCall {\n \n impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n-        fn count_closure_usage<'a, 'tcx>(\n-            cx: &'a LateContext<'tcx>,\n+        fn count_closure_usage<'tcx>(\n+            cx: &LateContext<'tcx>,\n             block: &'tcx hir::Block<'_>,\n             path: &'tcx hir::Path<'tcx>,\n         ) -> usize {"}, {"sha": "833dc4913b46922a215653311abb91bb6da5c745", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -70,7 +70,8 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n \n         if let ItemKind::Mod { .. } = item.kind {\n-            self.is_exported.push(cx.effective_visibilities.is_exported(item.owner_id.def_id));\n+            self.is_exported\n+                .push(cx.effective_visibilities.is_exported(item.owner_id.def_id));\n         }\n     }\n "}, {"sha": "8e214218f23ae1d5f617147d4e9ca2ff42cb37af", "filename": "src/tools/clippy/clippy_lints/src/renamed_lints.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frenamed_lints.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -11,8 +11,6 @@ pub static RENAMED_LINTS: &[(&str, &str)] = &[\n     (\"clippy::disallowed_method\", \"clippy::disallowed_methods\"),\n     (\"clippy::disallowed_type\", \"clippy::disallowed_types\"),\n     (\"clippy::eval_order_dependence\", \"clippy::mixed_read_write_in_expression\"),\n-    (\"clippy::for_loop_over_option\", \"for_loops_over_fallibles\"),\n-    (\"clippy::for_loop_over_result\", \"for_loops_over_fallibles\"),\n     (\"clippy::identity_conversion\", \"clippy::useless_conversion\"),\n     (\"clippy::if_let_some_result\", \"clippy::match_result_ok\"),\n     (\"clippy::logic_bug\", \"clippy::overly_complex_bool_expr\"),\n@@ -31,10 +29,13 @@ pub static RENAMED_LINTS: &[(&str, &str)] = &[\n     (\"clippy::to_string_in_display\", \"clippy::recursive_format_impl\"),\n     (\"clippy::zero_width_space\", \"clippy::invisible_characters\"),\n     (\"clippy::drop_bounds\", \"drop_bounds\"),\n+    (\"clippy::for_loop_over_option\", \"for_loops_over_fallibles\"),\n+    (\"clippy::for_loop_over_result\", \"for_loops_over_fallibles\"),\n     (\"clippy::for_loops_over_fallibles\", \"for_loops_over_fallibles\"),\n     (\"clippy::into_iter_on_array\", \"array_into_iter\"),\n     (\"clippy::invalid_atomic_ordering\", \"invalid_atomic_ordering\"),\n     (\"clippy::invalid_ref\", \"invalid_value\"),\n+    (\"clippy::let_underscore_drop\", \"let_underscore_drop\"),\n     (\"clippy::mem_discriminant_non_enum\", \"enum_intrinsics_non_enums\"),\n     (\"clippy::panic_params\", \"non_fmt_panics\"),\n     (\"clippy::positional_named_format_parameters\", \"named_arguments_used_positionally\"),"}, {"sha": "2036e85db7e8ca73f5f73e80cbfa570498016131", "filename": "src/tools/clippy/clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 127, "deletions": 92, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use rustc_ast::node_id::{NodeId, NodeMap};\n use rustc_ast::{ptr::P, Crate, Item, ItemKind, MacroDef, ModKind, UseTreeKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{edition::Edition, symbol::kw, Span, Symbol};\n \n declare_clippy_lint! {\n@@ -33,51 +34,32 @@ declare_clippy_lint! {\n     \"imports with single component path are redundant\"\n }\n \n-declare_lint_pass!(SingleComponentPathImports => [SINGLE_COMPONENT_PATH_IMPORTS]);\n+#[derive(Default)]\n+pub struct SingleComponentPathImports {\n+    /// Buffer found usages to emit when visiting that item so that `#[allow]` works as expected\n+    found: NodeMap<Vec<SingleUse>>,\n+}\n+\n+struct SingleUse {\n+    name: Symbol,\n+    span: Span,\n+    item_id: NodeId,\n+    can_suggest: bool,\n+}\n+\n+impl_lint_pass!(SingleComponentPathImports => [SINGLE_COMPONENT_PATH_IMPORTS]);\n \n impl EarlyLintPass for SingleComponentPathImports {\n     fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n         if cx.sess().opts.edition < Edition::Edition2018 {\n             return;\n         }\n-        check_mod(cx, &krate.items);\n-    }\n-}\n \n-fn check_mod(cx: &EarlyContext<'_>, items: &[P<Item>]) {\n-    // keep track of imports reused with `self` keyword,\n-    // such as `self::crypto_hash` in the example below\n-    // ```rust,ignore\n-    // use self::crypto_hash::{Algorithm, Hasher};\n-    // ```\n-    let mut imports_reused_with_self = Vec::new();\n-\n-    // keep track of single use statements\n-    // such as `crypto_hash` in the example below\n-    // ```rust,ignore\n-    // use crypto_hash;\n-    // ```\n-    let mut single_use_usages = Vec::new();\n-\n-    // keep track of macros defined in the module as we don't want it to trigger on this (#7106)\n-    // ```rust,ignore\n-    // macro_rules! foo { () => {} };\n-    // pub(crate) use foo;\n-    // ```\n-    let mut macros = Vec::new();\n-\n-    for item in items {\n-        track_uses(\n-            cx,\n-            item,\n-            &mut imports_reused_with_self,\n-            &mut single_use_usages,\n-            &mut macros,\n-        );\n+        self.check_mod(cx, &krate.items);\n     }\n \n-    for (name, span, can_suggest) in single_use_usages {\n-        if !imports_reused_with_self.contains(&name) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        for SingleUse { span, can_suggest, .. } in self.found.remove(&item.id).into_iter().flatten() {\n             if can_suggest {\n                 span_lint_and_sugg(\n                     cx,\n@@ -102,74 +84,127 @@ fn check_mod(cx: &EarlyContext<'_>, items: &[P<Item>]) {\n     }\n }\n \n-fn track_uses(\n-    cx: &EarlyContext<'_>,\n-    item: &Item,\n-    imports_reused_with_self: &mut Vec<Symbol>,\n-    single_use_usages: &mut Vec<(Symbol, Span, bool)>,\n-    macros: &mut Vec<Symbol>,\n-) {\n-    if item.span.from_expansion() || item.vis.kind.is_pub() {\n-        return;\n-    }\n+impl SingleComponentPathImports {\n+    fn check_mod(&mut self, cx: &EarlyContext<'_>, items: &[P<Item>]) {\n+        // keep track of imports reused with `self` keyword, such as `self::crypto_hash` in the example\n+        // below. Removing the `use crypto_hash;` would make this a compile error\n+        // ```\n+        // use crypto_hash;\n+        //\n+        // use self::crypto_hash::{Algorithm, Hasher};\n+        // ```\n+        let mut imports_reused_with_self = Vec::new();\n \n-    match &item.kind {\n-        ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) => {\n-            check_mod(cx, items);\n-        },\n-        ItemKind::MacroDef(MacroDef { macro_rules: true, .. }) => {\n-            macros.push(item.ident.name);\n-        },\n-        ItemKind::Use(use_tree) => {\n-            let segments = &use_tree.prefix.segments;\n-\n-            // keep track of `use some_module;` usages\n-            if segments.len() == 1 {\n-                if let UseTreeKind::Simple(None, _, _) = use_tree.kind {\n-                    let name = segments[0].ident.name;\n-                    if !macros.contains(&name) {\n-                        single_use_usages.push((name, item.span, true));\n-                    }\n-                }\n-                return;\n+        // keep track of single use statements such as `crypto_hash` in the example below\n+        // ```\n+        // use crypto_hash;\n+        // ```\n+        let mut single_use_usages = Vec::new();\n+\n+        // keep track of macros defined in the module as we don't want it to trigger on this (#7106)\n+        // ```\n+        // macro_rules! foo { () => {} };\n+        // pub(crate) use foo;\n+        // ```\n+        let mut macros = Vec::new();\n+\n+        for item in items {\n+            self.track_uses(\n+                cx,\n+                item,\n+                &mut imports_reused_with_self,\n+                &mut single_use_usages,\n+                &mut macros,\n+            );\n+        }\n+\n+        for usage in single_use_usages {\n+            if !imports_reused_with_self.contains(&usage.name) {\n+                self.found.entry(usage.item_id).or_default().push(usage);\n             }\n+        }\n+    }\n \n-            if segments.is_empty() {\n-                // keep track of `use {some_module, some_other_module};` usages\n-                if let UseTreeKind::Nested(trees) = &use_tree.kind {\n-                    for tree in trees {\n-                        let segments = &tree.0.prefix.segments;\n-                        if segments.len() == 1 {\n-                            if let UseTreeKind::Simple(None, _, _) = tree.0.kind {\n-                                let name = segments[0].ident.name;\n-                                if !macros.contains(&name) {\n-                                    single_use_usages.push((name, tree.0.span, false));\n-                                }\n-                            }\n+    fn track_uses(\n+        &mut self,\n+        cx: &EarlyContext<'_>,\n+        item: &Item,\n+        imports_reused_with_self: &mut Vec<Symbol>,\n+        single_use_usages: &mut Vec<SingleUse>,\n+        macros: &mut Vec<Symbol>,\n+    ) {\n+        if item.span.from_expansion() || item.vis.kind.is_pub() {\n+            return;\n+        }\n+\n+        match &item.kind {\n+            ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) => {\n+                self.check_mod(cx, items);\n+            },\n+            ItemKind::MacroDef(MacroDef { macro_rules: true, .. }) => {\n+                macros.push(item.ident.name);\n+            },\n+            ItemKind::Use(use_tree) => {\n+                let segments = &use_tree.prefix.segments;\n+\n+                // keep track of `use some_module;` usages\n+                if segments.len() == 1 {\n+                    if let UseTreeKind::Simple(None, _, _) = use_tree.kind {\n+                        let name = segments[0].ident.name;\n+                        if !macros.contains(&name) {\n+                            single_use_usages.push(SingleUse {\n+                                name,\n+                                span: item.span,\n+                                item_id: item.id,\n+                                can_suggest: true,\n+                            });\n                         }\n                     }\n+                    return;\n                 }\n-            } else {\n-                // keep track of `use self::some_module` usages\n-                if segments[0].ident.name == kw::SelfLower {\n-                    // simple case such as `use self::module::SomeStruct`\n-                    if segments.len() > 1 {\n-                        imports_reused_with_self.push(segments[1].ident.name);\n-                        return;\n-                    }\n \n-                    // nested case such as `use self::{module1::Struct1, module2::Struct2}`\n+                if segments.is_empty() {\n+                    // keep track of `use {some_module, some_other_module};` usages\n                     if let UseTreeKind::Nested(trees) = &use_tree.kind {\n                         for tree in trees {\n                             let segments = &tree.0.prefix.segments;\n-                            if !segments.is_empty() {\n-                                imports_reused_with_self.push(segments[0].ident.name);\n+                            if segments.len() == 1 {\n+                                if let UseTreeKind::Simple(None, _, _) = tree.0.kind {\n+                                    let name = segments[0].ident.name;\n+                                    if !macros.contains(&name) {\n+                                        single_use_usages.push(SingleUse {\n+                                            name,\n+                                            span: tree.0.span,\n+                                            item_id: item.id,\n+                                            can_suggest: false,\n+                                        });\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // keep track of `use self::some_module` usages\n+                    if segments[0].ident.name == kw::SelfLower {\n+                        // simple case such as `use self::module::SomeStruct`\n+                        if segments.len() > 1 {\n+                            imports_reused_with_self.push(segments[1].ident.name);\n+                            return;\n+                        }\n+\n+                        // nested case such as `use self::{module1::Struct1, module2::Struct2}`\n+                        if let UseTreeKind::Nested(trees) = &use_tree.kind {\n+                            for tree in trees {\n+                                let segments = &tree.0.prefix.segments;\n+                                if !segments.is_empty() {\n+                                    imports_reused_with_self.push(segments[0].ident.name);\n+                                }\n                             }\n                         }\n                     }\n                 }\n-            }\n-        },\n-        _ => {},\n+            },\n+            _ => {},\n+        }\n     }\n }"}, {"sha": "a2109038a05782900e88d1d751b7aa5244040aca", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -168,7 +168,7 @@ impl SlowVectorInit {\n         };\n     }\n \n-    fn emit_lint<'tcx>(cx: &LateContext<'tcx>, slow_fill: &Expr<'_>, vec_alloc: &VecAllocation<'_>, msg: &str) {\n+    fn emit_lint(cx: &LateContext<'_>, slow_fill: &Expr<'_>, vec_alloc: &VecAllocation<'_>, msg: &str) {\n         let len_expr = Sugg::hir(cx, vec_alloc.len_expr, \"len\");\n \n         span_lint_and_then(cx, SLOW_VECTOR_INITIALIZATION, slow_fill.span, msg, |diag| {"}, {"sha": "301aa5798bf556eeeb4bf2389fc671c25c08cbf0", "filename": "src/tools/clippy/clippy_lints/src/suspicious_xor_used_as_pow.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_xor_used_as_pow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_xor_used_as_pow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_xor_used_as_pow.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,53 @@\n+use clippy_utils::{numeric_literal::NumericLiteral, source::snippet_with_context};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Warns for a Bitwise XOR (`^`) operator being probably confused as a powering. It will not trigger if any of the numbers are not in decimal.\n+    /// ### Why is this bad?\n+    ///\tIt's most probably a typo and may lead to unexpected behaviours.\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 3_i32 ^ 4_i32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = 3_i32.pow(4);\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub SUSPICIOUS_XOR_USED_AS_POW,\n+    restriction,\n+    \"XOR (`^`) operator possibly used as exponentiation operator\"\n+}\n+declare_lint_pass!(ConfusingXorAndPow => [SUSPICIOUS_XOR_USED_AS_POW]);\n+\n+impl LateLintPass<'_> for ConfusingXorAndPow {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if !in_external_macro(cx.sess(), expr.span) &&\n+        \tlet ExprKind::Binary(op, left, right) = &expr.kind &&\n+            op.node == BinOpKind::BitXor &&\n+            left.span.ctxt() == right.span.ctxt() &&\n+            let ExprKind::Lit(lit_left) = &left.kind &&\n+            let ExprKind::Lit(lit_right) = &right.kind &&\n+            let snip_left = snippet_with_context(cx, lit_left.span, lit_left.span.ctxt(), \"..\", &mut Applicability::MaybeIncorrect) &&\n+            let snip_right = snippet_with_context(cx, lit_right.span, lit_right.span.ctxt(), \"..\", &mut Applicability::MaybeIncorrect) &&\n+            let Some(left_val) = NumericLiteral::from_lit_kind(&snip_left.0, &lit_left.node) &&\n+            let Some(right_val) = NumericLiteral::from_lit_kind(&snip_right.0, &lit_right.node) &&\n+\t\t\tleft_val.is_decimal() &&\n+\t\t\tright_val.is_decimal() {\n+\t\t\t\t\tclippy_utils::diagnostics::span_lint_and_sugg(\n+\t\t\t\t\t        cx,\n+\t\t\t\t\t        SUSPICIOUS_XOR_USED_AS_POW,\n+\t\t\t\t\t        expr.span,\n+\t\t\t\t\t        \"`^` is not the exponentiation operator\",\n+\t\t\t\t\t        \"did you mean to write\",\n+\t\t\t\t\t        format!(\"{}.pow({})\", left_val.format(), right_val.format()),\n+\t\t\t\t\t        Applicability::MaybeIncorrect,\n+\t\t\t\t\t    );\n+\t\t}\n+    }\n+}"}, {"sha": "c374529d1ea9f5abc9fd54bf49a36163c47463e7", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{can_mut_borrow_both, eq_expr_value, std_or_core};\n+use clippy_utils::{can_mut_borrow_both, eq_expr_value, in_constant, std_or_core};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n@@ -16,6 +16,8 @@ declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for manual swapping.\n     ///\n+    /// Note that the lint will not be emitted in const blocks, as the suggestion would not be applicable.\n+    ///\n     /// ### Why is this bad?\n     /// The `std::mem::swap` function exposes the intent better\n     /// without deinitializing or copying either variable.\n@@ -138,6 +140,10 @@ fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, spa\n \n /// Implementation of the `MANUAL_SWAP` lint.\n fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n+    if in_constant(cx, block.hir_id) {\n+        return;\n+    }\n+\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();"}, {"sha": "63b326048a48fe2c1f4322daa6b3d8fe10fbe573", "filename": "src/tools/clippy/clippy_lints/src/trailing_empty_array.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use rustc_hir::{HirId, Item, ItemKind};\n+use clippy_utils::has_repr_attr;\n+use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::Const;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -72,7 +72,3 @@ fn is_struct_with_trailing_zero_sized_array(cx: &LateContext<'_>, item: &Item<'_\n         }\n     }\n }\n-\n-fn has_repr_attr(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n-    cx.tcx.hir().attrs(hir_id).iter().any(|attr| attr.has_name(sym::repr))\n-}"}, {"sha": "34642f4b122f22f097df02fada46a66a69129192", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 66, "deletions": 98, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -27,32 +27,24 @@ pub(super) fn check<'tcx>(\n \n             // `Repr(C)` <-> unordered type.\n             // If the first field of the `Repr(C)` type matches then the transmute is ok\n-            (\n-                ReducedTy::OrderedFields(_, Some(from_sub_ty)),\n-                ReducedTy::UnorderedFields(to_sub_ty),\n-            )\n-            | (\n-                ReducedTy::UnorderedFields(from_sub_ty),\n-                ReducedTy::OrderedFields(_, Some(to_sub_ty)),\n-            ) => {\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::UnorderedFields(to_sub_ty))\n+            | (ReducedTy::UnorderedFields(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty))) => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            }\n-            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty))\n-                if reduced_tys.to_fat_ptr =>\n-            {\n+            },\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty)) if reduced_tys.to_fat_ptr => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            }\n+            },\n             (ReducedTy::Other(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty)))\n                 if reduced_tys.from_fat_ptr =>\n             {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            }\n+            },\n \n             // ptr <-> ptr\n             (ReducedTy::Other(from_sub_ty), ReducedTy::Other(to_sub_ty))\n@@ -62,19 +54,19 @@ pub(super) fn check<'tcx>(\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            }\n+            },\n \n             // fat ptr <-> (*size, *size)\n             (ReducedTy::Other(_), ReducedTy::UnorderedFields(to_ty))\n                 if reduced_tys.from_fat_ptr && is_size_pair(to_ty) =>\n             {\n                 return false;\n-            }\n+            },\n             (ReducedTy::UnorderedFields(from_ty), ReducedTy::Other(_))\n                 if reduced_tys.to_fat_ptr && is_size_pair(from_ty) =>\n             {\n                 return false;\n-            }\n+            },\n \n             // fat ptr -> some struct | some struct -> fat ptr\n             (ReducedTy::Other(_), _) if reduced_tys.from_fat_ptr => {\n@@ -85,14 +77,12 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty.peel_refs() {\n-                            diag.note(&format!(\n-                                \"the contained type `{from_ty}` has an undefined layout\"\n-                            ));\n+                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n                         }\n                     },\n                 );\n                 return true;\n-            }\n+            },\n             (_, ReducedTy::Other(_)) if reduced_tys.to_fat_ptr => {\n                 span_lint_and_then(\n                     cx,\n@@ -101,18 +91,14 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute to `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty.peel_refs() {\n-                            diag.note(&format!(\n-                                \"the contained type `{to_ty}` has an undefined layout\"\n-                            ));\n+                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n                         }\n                     },\n                 );\n                 return true;\n-            }\n+            },\n \n-            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty))\n-                if from_ty != to_ty =>\n-            {\n+            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n                 let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n                         = (from_ty.kind(), to_ty.kind())\n                         && from_def == to_def\n@@ -139,25 +125,19 @@ pub(super) fn check<'tcx>(\n                             ));\n                         } else {\n                             if from_ty_orig.peel_refs() != from_ty {\n-                                diag.note(&format!(\n-                                    \"the contained type `{from_ty}` has an undefined layout\"\n-                                ));\n+                                diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n                             }\n                             if to_ty_orig.peel_refs() != to_ty {\n-                                diag.note(&format!(\n-                                    \"the contained type `{to_ty}` has an undefined layout\"\n-                                ));\n+                                diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n                             }\n                         }\n                     },\n                 );\n                 return true;\n-            }\n+            },\n             (\n                 ReducedTy::UnorderedFields(from_ty),\n-                ReducedTy::Other(_)\n-                | ReducedTy::OrderedFields(..)\n-                | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n             ) => {\n                 span_lint_and_then(\n                     cx,\n@@ -166,18 +146,14 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty {\n-                            diag.note(&format!(\n-                                \"the contained type `{from_ty}` has an undefined layout\"\n-                            ));\n+                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n                         }\n                     },\n                 );\n                 return true;\n-            }\n+            },\n             (\n-                ReducedTy::Other(_)\n-                | ReducedTy::OrderedFields(..)\n-                | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n                 ReducedTy::UnorderedFields(to_ty),\n             ) => {\n                 span_lint_and_then(\n@@ -187,25 +163,19 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute into `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty {\n-                            diag.note(&format!(\n-                                \"the contained type `{to_ty}` has an undefined layout\"\n-                            ));\n+                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n                         }\n                     },\n                 );\n                 return true;\n-            }\n+            },\n             (\n-                ReducedTy::OrderedFields(..)\n-                | ReducedTy::Other(_)\n-                | ReducedTy::TypeErasure { raw_ptr_only: true },\n-                ReducedTy::OrderedFields(..)\n-                | ReducedTy::Other(_)\n-                | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n             )\n             | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => {\n                 break;\n-            }\n+            },\n         }\n     }\n \n@@ -223,38 +193,42 @@ struct ReducedTys<'tcx> {\n }\n \n /// Remove references so long as both types are references.\n-fn reduce_refs<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    mut from_ty: Ty<'tcx>,\n-    mut to_ty: Ty<'tcx>,\n-) -> ReducedTys<'tcx> {\n+fn reduce_refs<'tcx>(cx: &LateContext<'tcx>, mut from_ty: Ty<'tcx>, mut to_ty: Ty<'tcx>) -> ReducedTys<'tcx> {\n     let mut from_raw_ptr = false;\n     let mut to_raw_ptr = false;\n-    let (from_fat_ptr, to_fat_ptr) =\n-        loop {\n-            break match (from_ty.kind(), to_ty.kind()) {\n-                (\n-                    &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n-                    &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n-                ) => {\n-                    from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n-                    from_ty = from_sub_ty;\n-                    to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                }\n-                (\n-                    &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })),\n-                    _,\n-                ) if !unsized_ty.is_sized(cx.tcx, cx.param_env) => (true, false),\n-                (\n-                    _,\n-                    &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })),\n-                ) if !unsized_ty.is_sized(cx.tcx, cx.param_env) => (false, true),\n-                _ => (false, false),\n-            };\n+    let (from_fat_ptr, to_fat_ptr) = loop {\n+        break match (from_ty.kind(), to_ty.kind()) {\n+            (\n+                &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n+                &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n+            ) => {\n+                from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n+                from_ty = from_sub_ty;\n+                to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n+                to_ty = to_sub_ty;\n+                continue;\n+            },\n+            (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n+                if !unsized_ty.is_sized(cx.tcx, cx.param_env) =>\n+            {\n+                (true, false)\n+            },\n+            (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n+                if !unsized_ty.is_sized(cx.tcx, cx.param_env) =>\n+            {\n+                (false, true)\n+            },\n+            _ => (false, false),\n         };\n-    ReducedTys { from_ty, to_ty, from_raw_ptr, to_raw_ptr, from_fat_ptr, to_fat_ptr }\n+    };\n+    ReducedTys {\n+        from_ty,\n+        to_ty,\n+        from_raw_ptr,\n+        to_raw_ptr,\n+        from_fat_ptr,\n+        to_fat_ptr,\n+    }\n }\n \n enum ReducedTy<'tcx> {\n@@ -277,11 +251,11 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n         return match *ty.kind() {\n             ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => {\n                 ReducedTy::TypeErasure { raw_ptr_only: false }\n-            }\n+            },\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n                 ty = sub_ty;\n                 continue;\n-            }\n+            },\n             ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Tuple(args) => {\n                 let mut iter = args.iter();\n@@ -293,7 +267,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     continue;\n                 }\n                 ReducedTy::UnorderedFields(ty)\n-            }\n+            },\n             ty::Adt(def, substs) if def.is_struct() => {\n                 let mut iter = def\n                     .non_enum_variant()\n@@ -312,12 +286,10 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 } else {\n                     ReducedTy::UnorderedFields(ty)\n                 }\n-            }\n-            ty::Adt(def, _)\n-                if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) =>\n-            {\n+            },\n+            ty::Adt(def, _) if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) => {\n                 ReducedTy::TypeErasure { raw_ptr_only: false }\n-            }\n+            },\n             // TODO: Check if the conversion to or from at least one of a union's fields is valid.\n             ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Foreign(_) | ty::Param(_) => ReducedTy::TypeErasure { raw_ptr_only: false },\n@@ -356,11 +328,7 @@ fn same_except_params<'tcx>(subs1: SubstsRef<'tcx>, subs2: SubstsRef<'tcx>) -> b\n     for (ty1, ty2) in subs1.types().zip(subs2.types()).filter(|(ty1, ty2)| ty1 != ty2) {\n         match (ty1.kind(), ty2.kind()) {\n             (ty::Param(_), _) | (_, ty::Param(_)) => (),\n-            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2))\n-                if adt1 == adt2 && same_except_params(subs1, subs2) =>\n-            {\n-                ()\n-            }\n+            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2)) if adt1 == adt2 && same_except_params(subs1, subs2) => (),\n             _ => return false,\n         }\n     }"}, {"sha": "49d863ec03f1d014c575c776da02a9b3c712d1ba", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,9 +1,9 @@\n+use rustc_hir as hir;\n use rustc_hir::Expr;\n use rustc_hir_typeck::{cast, FnCtxt, Inherited};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;\n-use rustc_hir as hir;\n \n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment\n@@ -55,9 +55,14 @@ fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>\n         );\n \n         if let Ok(check) = cast::CastCheck::new(\n-            &fn_ctxt, e, from_ty, to_ty,\n+            &fn_ctxt,\n+            e,\n+            from_ty,\n+            to_ty,\n             // We won't show any error to the user, so we don't care what the span is here.\n-            DUMMY_SP, DUMMY_SP, hir::Constness::NotConst,\n+            DUMMY_SP,\n+            DUMMY_SP,\n+            hir::Constness::NotConst,\n         ) {\n             let res = check.do_check(&fn_ctxt);\n "}, {"sha": "43665a922d444750b6445975dd00fb12625fa1e2", "filename": "src/tools/clippy/clippy_lints/src/types/box_collection.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -39,12 +39,19 @@ fn get_std_collection(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Symbol>\n     let id = path_def_id(cx, param)?;\n     cx.tcx\n         .get_diagnostic_name(id)\n-        .filter(|&name| matches!(name, sym::HashMap | sym::Vec | sym::HashSet\n-            | sym::VecDeque\n-            | sym::LinkedList\n-            | sym::BTreeMap\n-            | sym::BTreeSet\n-            | sym::BinaryHeap))\n+        .filter(|&name| {\n+            matches!(\n+                name,\n+                sym::HashMap\n+                    | sym::Vec\n+                    | sym::HashSet\n+                    | sym::VecDeque\n+                    | sym::LinkedList\n+                    | sym::BTreeMap\n+                    | sym::BTreeSet\n+                    | sym::BinaryHeap\n+            )\n+        })\n         .or_else(|| {\n             cx.tcx\n                 .lang_items()"}, {"sha": "20978e81dc584619c5ade53fc1f15b806920fdf1", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -379,7 +379,9 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        let is_exported = cx.effective_visibilities.is_exported(cx.tcx.hir().local_def_id(field.hir_id));\n+        let is_exported = cx\n+            .effective_visibilities\n+            .is_exported(cx.tcx.hir().local_def_id(field.hir_id));\n \n         self.check_ty(\n             cx,"}, {"sha": "fae5385ffc848dc3d09805baac4d749f3fc5dfc4", "filename": "src/tools/clippy/clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -5,16 +5,12 @@ use rustc_errors::Applicability;\n use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::LateContext;\n+use rustc_middle::ty::TypeVisitable;\n use rustc_span::symbol::sym;\n \n use super::{utils, REDUNDANT_ALLOCATION};\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    hir_ty: &hir::Ty<'_>,\n-    qpath: &QPath<'_>,\n-    def_id: DefId,\n-) -> bool {\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n     let mut applicability = Applicability::MaybeIncorrect;\n     let outer_sym = if Some(def_id) == cx.tcx.lang_items().owned_box() {\n         \"Box\"\n@@ -34,12 +30,7 @@ pub(super) fn check(\n             hir_ty.span,\n             &format!(\"usage of `{outer_sym}<{generic_snippet}>`\"),\n             |diag| {\n-                diag.span_suggestion(\n-                    hir_ty.span,\n-                    \"try\",\n-                    format!(\"{generic_snippet}\"),\n-                    applicability,\n-                );\n+                diag.span_suggestion(hir_ty.span, \"try\", format!(\"{generic_snippet}\"), applicability);\n                 diag.note(&format!(\n                     \"`{generic_snippet}` is already a pointer, `{outer_sym}<{generic_snippet}>` allocates a pointer on the heap\"\n                 ));\n@@ -61,15 +52,16 @@ pub(super) fn check(\n         return false\n     };\n     let inner_span = match qpath_generic_tys(inner_qpath).next() {\n-        Some(ty) => {\n+        Some(hir_ty) => {\n             // Reallocation of a fat pointer causes it to become thin. `hir_ty_to_ty` is safe to use\n             // here because `mod.rs` guarantees this lint is only run on types outside of bodies and\n             // is not run on locals.\n-            if !hir_ty_to_ty(cx.tcx, ty).is_sized(cx.tcx, cx.param_env) {\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+            if ty.has_escaping_bound_vars() || !ty.is_sized(cx.tcx, cx.param_env) {\n                 return false;\n             }\n-            ty.span\n-        }\n+            hir_ty.span\n+        },\n         None => return false,\n     };\n     if inner_sym == outer_sym {"}, {"sha": "7a3c7cd8a99fc714c1a0d3e7039a2e985f23c8bf", "filename": "src/tools/clippy/clippy_lints/src/types/vec_box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -42,7 +42,7 @@ pub(super) fn check(\n             if !ty_ty.has_escaping_bound_vars();\n             if ty_ty.is_sized(cx.tcx, cx.param_env);\n             if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n-            if ty_ty_size <= box_size_threshold;\n+            if ty_ty_size < box_size_threshold;\n             then {\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "e8f15a4447352a9cedd66892e34831cb089a800f", "filename": "src/tools/clippy/clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -68,7 +68,8 @@ impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n             && !in_external_macro(cx.tcx.sess, block.span)\n             && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id)\n             && !is_unsafe_from_proc_macro(cx, block.span)\n-            && !block_has_safety_comment(cx, block)\n+            && !block_has_safety_comment(cx, block.span)\n+            && !block_parents_have_safety_comment(cx, block.hir_id)\n         {\n             let source_map = cx.tcx.sess.source_map();\n             let span = if source_map.is_multiline(block.span) {\n@@ -126,8 +127,41 @@ fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, span: Span) -> bool {\n         .map_or(true, |src| !src.starts_with(\"unsafe\"))\n }\n \n+// Checks if any parent {expression, statement, block, local, const, static}\n+// has a safety comment\n+fn block_parents_have_safety_comment(cx: &LateContext<'_>, id: hir::HirId) -> bool {\n+    if let Some(node) = get_parent_node(cx.tcx, id) {\n+        return match node {\n+            Node::Expr(expr) => !is_branchy(expr) && span_in_body_has_safety_comment(cx, expr.span),\n+            Node::Stmt(hir::Stmt {\n+                kind:\n+                    hir::StmtKind::Local(hir::Local { span, .. })\n+                    | hir::StmtKind::Expr(hir::Expr { span, .. })\n+                    | hir::StmtKind::Semi(hir::Expr { span, .. }),\n+                ..\n+            })\n+            | Node::Local(hir::Local { span, .. })\n+            | Node::Item(hir::Item {\n+                kind: hir::ItemKind::Const(..) | ItemKind::Static(..),\n+                span,\n+                ..\n+            }) => span_in_body_has_safety_comment(cx, *span),\n+            _ => false,\n+        };\n+    }\n+    false\n+}\n+\n+/// Checks if an expression is \"branchy\", e.g. loop, match/if/etc.\n+fn is_branchy(expr: &hir::Expr<'_>) -> bool {\n+    matches!(\n+        expr.kind,\n+        hir::ExprKind::If(..) | hir::ExprKind::Loop(..) | hir::ExprKind::Match(..)\n+    )\n+}\n+\n /// Checks if the lines immediately preceding the block contain a safety comment.\n-fn block_has_safety_comment(cx: &LateContext<'_>, block: &hir::Block<'_>) -> bool {\n+fn block_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n     // This intentionally ignores text before the start of a function so something like:\n     // ```\n     //     // SAFETY: reason\n@@ -136,7 +170,7 @@ fn block_has_safety_comment(cx: &LateContext<'_>, block: &hir::Block<'_>) -> boo\n     // won't work. This is to avoid dealing with where such a comment should be place relative to\n     // attributes and doc comments.\n \n-    span_from_macro_expansion_has_safety_comment(cx, block.span) || span_in_body_has_safety_comment(cx, block.span)\n+    span_from_macro_expansion_has_safety_comment(cx, span) || span_in_body_has_safety_comment(cx, span)\n }\n \n /// Checks if the lines immediately preceding the item contain a safety comment."}, {"sha": "952586527689af042908087005a2c5974580b1ad", "filename": "src/tools/clippy/clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -50,7 +50,7 @@ fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext<'_>, span: Span) {\n         },\n         UseTreeKind::Simple(None, ..) | UseTreeKind::Glob => {},\n         UseTreeKind::Nested(ref nested_use_tree) => {\n-            for &(ref use_tree, _) in nested_use_tree {\n+            for (use_tree, _) in nested_use_tree {\n                 check_use_tree(use_tree, cx, span);\n             }\n         },"}, {"sha": "4ee16d9a5e4ad94d4a8631ad95ff845ed252fde4", "filename": "src/tools/clippy/clippy_lints/src/unused_peekable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -36,7 +36,7 @@ declare_clippy_lint! {\n     ///     // ...\n     /// }\n     /// ```\n-    #[clippy::version = \"1.64.0\"]\n+    #[clippy::version = \"1.65.0\"]\n     pub UNUSED_PEEKABLE,\n     nursery,\n     \"creating a peekable iterator without using any of its methods\""}, {"sha": "aac6719a8dc0feef10b0ea7c4f1578f8732195ca", "filename": "src/tools/clippy/clippy_lints/src/unused_rounding.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_rounding.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -30,16 +30,15 @@ declare_clippy_lint! {\n declare_lint_pass!(UnusedRounding => [UNUSED_ROUNDING]);\n \n fn is_useless_rounding(expr: &Expr) -> Option<(&str, String)> {\n-    if let ExprKind::MethodCall(box MethodCall { seg, receiver, .. }) = &expr.kind\n-        && let method_name = seg.ident.name.as_str()\n+    if let ExprKind::MethodCall(box MethodCall { seg:name_ident, receiver, .. }) = &expr.kind\n+        && let method_name = name_ident.ident.name.as_str()\n         && (method_name == \"ceil\" || method_name == \"round\" || method_name == \"floor\")\n         && let ExprKind::Lit(token_lit) = &receiver.kind\n         && token_lit.is_semantic_float() {\n-            let f = token_lit.symbol.as_str().parse::<f64>().unwrap();\n             let mut f_str = token_lit.symbol.to_string();\n-            match token_lit.suffix {\n-                Some(suffix) => f_str.push_str(suffix.as_str()),\n-                None => {}\n+            let f = f_str.trim_end_matches('_').parse::<f64>().unwrap();\n+            if let Some(suffix) = token_lit.suffix {\n+                f_str.push_str(suffix.as_str());\n             }\n             if f.fract() == 0.0 {\n                 Some((method_name, f_str))"}, {"sha": "cad8da18c2fbc5c80f14a259600f019ee8226963", "filename": "src/tools/clippy/clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_unit.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{position_before_rarrow, snippet_opt};\n use if_chain::if_chain;\n-use rustc_ast::ast;\n-use rustc_ast::visit::FnKind;\n+use rustc_ast::{ast, visit::FnKind, ClosureBinder};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -43,6 +42,11 @@ impl EarlyLintPass for UnusedUnit {\n             if let ast::TyKind::Tup(ref vals) = ty.kind;\n             if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n             then {\n+                // implicit types in closure signatures are forbidden when `for<...>` is present\n+                if let FnKind::Closure(&ClosureBinder::For { .. }, ..) = kind {\n+                    return;\n+                }\n+\n                 lint_unneeded_unit_return(cx, ty, span);\n             }\n         }"}, {"sha": "e2860db71a5a772a945f11bced95c435051bf8d7", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -30,7 +30,6 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// - Unaddressed false negative in fn bodies of trait implementations\n-    /// - False positive with associated types in traits (#4140)\n     ///\n     /// ### Example\n     /// ```rust\n@@ -103,6 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             if parameters.as_ref().map_or(true, |params| {\n                 !params.parenthesized && !params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n             });\n+            if !item.span.from_expansion();\n             if !is_from_proc_macro(cx, item); // expensive, should be last check\n             then {\n                 StackItem::Check {\n@@ -234,24 +234,13 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             then {} else { return; }\n         }\n         match expr.kind {\n-            ExprKind::Struct(QPath::Resolved(_, path), ..) => match path.res {\n-                Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } => (),\n-                Res::Def(DefKind::Variant, _) => lint_path_to_variant(cx, path),\n-                _ => span_lint(cx, path.span),\n-            },\n-            // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+            ExprKind::Struct(QPath::Resolved(_, path), ..) => check_path(cx, path),\n             ExprKind::Call(fun, _) => {\n                 if let ExprKind::Path(QPath::Resolved(_, path)) = fun.kind {\n-                    if let Res::Def(DefKind::Ctor(ctor_of, _), ..) = path.res {\n-                        match ctor_of {\n-                            CtorOf::Variant => lint_path_to_variant(cx, path),\n-                            CtorOf::Struct => span_lint(cx, path.span),\n-                        }\n-                    }\n+                    check_path(cx, path);\n                 }\n             },\n-            // unit enum variants (`Enum::A`)\n-            ExprKind::Path(QPath::Resolved(_, path)) => lint_path_to_variant(cx, path),\n+            ExprKind::Path(QPath::Resolved(_, path)) => check_path(cx, path),\n             _ => (),\n         }\n     }\n@@ -267,15 +256,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                  | PatKind::Struct(QPath::Resolved(_, path), _, _) = pat.kind;\n             if cx.typeck_results().pat_ty(pat) == cx.tcx.type_of(impl_id);\n             then {\n-                match path.res {\n-                    Res::Def(DefKind::Ctor(ctor_of, _), ..) => match ctor_of {\n-                            CtorOf::Variant => lint_path_to_variant(cx, path),\n-                            CtorOf::Struct => span_lint(cx, path.span),\n-                    },\n-                    Res::Def(DefKind::Variant, ..) => lint_path_to_variant(cx, path),\n-                    Res::Def(DefKind::Struct, ..) => span_lint(cx, path.span),\n-                    _ => ()\n-                }\n+                check_path(cx, path);\n             }\n         }\n     }\n@@ -313,6 +294,16 @@ fn span_lint(cx: &LateContext<'_>, span: Span) {\n     );\n }\n \n+fn check_path(cx: &LateContext<'_>, path: &Path<'_>) {\n+    match path.res {\n+        Res::Def(DefKind::Ctor(CtorOf::Variant, _) | DefKind::Variant, ..) => {\n+            lint_path_to_variant(cx, path);\n+        },\n+        Res::Def(DefKind::Ctor(CtorOf::Struct, _) | DefKind::Struct, ..) => span_lint(cx, path.span),\n+        _ => (),\n+    }\n+}\n+\n fn lint_path_to_variant(cx: &LateContext<'_>, path: &Path<'_>) {\n     if let [.., self_seg, _variant] = path.segments {\n         let span = path"}, {"sha": "b37d4239477eaa1c2ed866cd3112173f71f6f2b7", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -53,11 +53,11 @@ impl DisallowedPath {\n         path\n     }\n \n-    pub fn reason(&self) -> Option<&str> {\n+    pub fn reason(&self) -> Option<String> {\n         match self {\n             Self::WithReason {\n                 reason: Some(reason), ..\n-            } => Some(reason),\n+            } => Some(format!(\"{reason} (from clippy.toml)\")),\n             _ => None,\n         }\n     }\n@@ -213,7 +213,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE, APPROX_CONSTANT, DEPRECATED_CFG_ATTR, INDEX_REFUTABLE_SLICE, MAP_CLONE, BORROW_AS_PTR, MANUAL_BITS, ERR_EXPECT, CAST_ABS_TO_UNSIGNED, UNINLINED_FORMAT_ARGS, MANUAL_CLAMP, MANUAL_LET_ELSE, UNCHECKED_DURATION_SUBTRACTION.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n@@ -335,6 +335,12 @@ define_Conf! {\n     ///\n     /// Enables verbose mode. Triggers if there is more than one uppercase char next to each other\n     (upper_case_acronyms_aggressive: bool = false),\n+    /// Lint: MANUAL_LET_ELSE.\n+    ///\n+    /// Whether the matches should be considered by the lint, and whether there should\n+    /// be filtering for common types.\n+    (matches_for_let_else: crate::manual_let_else::MatchLintBehaviour =\n+        crate::manual_let_else::MatchLintBehaviour::WellKnownTypes),\n     /// Lint: _CARGO_COMMON_METADATA.\n     ///\n     /// For internal testing only, ignores the current `publish` settings in the Cargo manifest.\n@@ -373,23 +379,36 @@ define_Conf! {\n     (max_include_file_size: u64 = 1_000_000),\n     /// Lint: EXPECT_USED.\n     ///\n-    /// Whether `expect` should be allowed in test functions\n+    /// Whether `expect` should be allowed within `#[cfg(test)]`\n     (allow_expect_in_tests: bool = false),\n     /// Lint: UNWRAP_USED.\n     ///\n-    /// Whether `unwrap` should be allowed in test functions\n+    /// Whether `unwrap` should be allowed in test cfg\n     (allow_unwrap_in_tests: bool = false),\n     /// Lint: DBG_MACRO.\n     ///\n     /// Whether `dbg!` should be allowed in test functions\n     (allow_dbg_in_tests: bool = false),\n-    /// Lint: RESULT_LARGE_ERR\n+    /// Lint: PRINT_STDOUT, PRINT_STDERR.\n+    ///\n+    /// Whether print macros (ex. `println!`) should be allowed in test functions\n+    (allow_print_in_tests: bool = false),\n+    /// Lint: RESULT_LARGE_ERR.\n     ///\n     /// The maximum size of the `Err`-variant in a `Result` returned from a function\n     (large_error_threshold: u64 = 128),\n+    /// Lint: MUTABLE_KEY.\n+    ///\n+    /// A list of paths to types that should be treated like `Arc`, i.e. ignored but\n+    /// for the generic parameters for determining interior mutability\n+    (ignore_interior_mutability: Vec<String> = Vec::from([\"bytes::Bytes\".into()])),\n }\n \n /// Search for the configuration file.\n+///\n+/// # Errors\n+///\n+/// Returns any unexpected filesystem error encountered when searching for the config file\n pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n     /// Possible filename to search for.\n     const CONFIG_FILE_NAMES: [&str; 2] = [\".clippy.toml\", \"clippy.toml\"];"}, {"sha": "4b33d492a0e478f7ab5c0003f45ede45a917887d", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/interning_defined_symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n-use clippy_utils::{def_path_res, is_expn_of, match_def_path, paths};\n+use clippy_utils::{def_path_def_ids, is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n         }\n \n         for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n+            for def_id in def_path_def_ids(cx, module) {\n                 for item in cx.tcx.module_children(def_id).iter() {\n                     if_chain! {\n                         if let Res::Def(DefKind::Const, item_def_id) = item.res;"}, {"sha": "680935f2329e4e5037ffdf2c1f01022c962f3702", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/invalid_paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::def_path_res;\n use clippy_utils::diagnostics::span_lint;\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::DefKind;\n use rustc_hir::Item;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n // This is not a complete resolver for paths. It works on all the paths currently used in the paths\n // module.  That's all it does and all it needs to do.\n pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if def_path_res(cx, path, None) != Res::Err {\n+    if !def_path_res(cx, path).is_empty() {\n         return true;\n     }\n "}, {"sha": "1aebb8b3104ba611482d1f86c9b4e5f2a0b00fc8", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/lint_without_lint_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -256,7 +256,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     }\n }\n \n-pub(super) fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n+pub(super) fn is_lint_ref_type(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     if let TyKind::Rptr(\n         _,\n         MutTy {"}, {"sha": "08980cb12ed6b4d94e9cff29002c97815e65dbc7", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "modified", "additions": 7, "deletions": 38, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{def_path_res, is_lint_allowed, match_any_def_paths, peel_hir_expr_refs};\n+use clippy_utils::{def_path_def_ids, is_lint_allowed, match_any_def_paths, peel_hir_expr_refs};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n@@ -11,9 +11,9 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, ExprKind, Local, Mutability, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n-use rustc_middle::ty::{self, AssocKind, DefIdTree, Ty};\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n use std::str;\n@@ -110,7 +110,7 @@ impl UnnecessaryDefPath {\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, item_arg);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n-            if let Some(def_id) = inherent_def_path_res(cx, &segments[..]);\n+            if let Some(def_id) = def_path_def_ids(cx, &segments[..]).next();\n             then {\n                 // Check if the target item is a diagnostic item or LangItem.\n                 #[rustfmt::skip]\n@@ -209,7 +209,7 @@ impl UnnecessaryDefPath {\n     fn check_array(&mut self, cx: &LateContext<'_>, elements: &[Expr<'_>], span: Span) {\n         let Some(path) = path_from_array(elements) else { return };\n \n-        if let Some(def_id) = inherent_def_path_res(cx, &path.iter().map(AsRef::as_ref).collect::<Vec<_>>()) {\n+        for def_id in def_path_def_ids(cx, &path.iter().map(AsRef::as_ref).collect::<Vec<_>>()) {\n             self.array_def_ids.insert((def_id, span));\n         }\n     }\n@@ -246,7 +246,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n \n fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n     let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n-        let &alloc = alloc.provenance().values().next()?;\n+        let &alloc = alloc.provenance().ptrs().values().next()?;\n         if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n             (alloc.inner(), ty)\n         } else {\n@@ -262,6 +262,7 @@ fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation\n     {\n         alloc\n             .provenance()\n+            .ptrs()\n             .values()\n             .map(|&alloc| {\n                 if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n@@ -293,38 +294,6 @@ fn path_from_array(exprs: &[Expr<'_>]) -> Option<Vec<String>> {\n         .collect()\n }\n \n-// def_path_res will match field names before anything else, but for this we want to match\n-// inherent functions first.\n-fn inherent_def_path_res(cx: &LateContext<'_>, segments: &[&str]) -> Option<DefId> {\n-    def_path_res(cx, segments, None).opt_def_id().map(|def_id| {\n-        if cx.tcx.def_kind(def_id) == DefKind::Field {\n-            let method_name = *segments.last().unwrap();\n-            cx.tcx\n-                .def_key(def_id)\n-                .parent\n-                .and_then(|parent_idx| {\n-                    cx.tcx\n-                        .inherent_impls(DefId {\n-                            index: parent_idx,\n-                            krate: def_id.krate,\n-                        })\n-                        .iter()\n-                        .find_map(|impl_id| {\n-                            cx.tcx.associated_items(*impl_id).find_by_name_and_kind(\n-                                cx.tcx,\n-                                Ident::from_str(method_name),\n-                                AssocKind::Fn,\n-                                *impl_id,\n-                            )\n-                        })\n-                })\n-                .map_or(def_id, |item| item.def_id)\n-        } else {\n-            def_id\n-        }\n-    })\n-}\n-\n fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<&'static str> {\n     if let Some((lang_item, _)) = cx.tcx.lang_items().iter().find(|(_, id)| *id == def_id) {\n         Some(lang_item.variant_name())"}, {"sha": "6b321765bc082d8c1912bd1413e9dfdbee71e059", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn, MacroCall};\n use clippy_utils::source::{expand_past_previous_comma, snippet_opt};\n+use clippy_utils::{is_in_cfg_test, is_in_test_function};\n use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, HirIdMap, Impl, Item, ItemKind};\n@@ -232,6 +233,16 @@ declare_clippy_lint! {\n #[derive(Default)]\n pub struct Write {\n     in_debug_impl: bool,\n+    allow_print_in_tests: bool,\n+}\n+\n+impl Write {\n+    pub fn new(allow_print_in_tests: bool) -> Self {\n+        Self {\n+            allow_print_in_tests,\n+            ..Default::default()\n+        }\n+    }\n }\n \n impl_lint_pass!(Write => [\n@@ -271,13 +282,15 @@ impl<'tcx> LateLintPass<'tcx> for Write {\n             .as_ref()\n             .map_or(false, |crate_name| crate_name == \"build_script_build\");\n \n+        let allowed_in_tests = self.allow_print_in_tests\n+            && (is_in_test_function(cx.tcx, expr.hir_id) || is_in_cfg_test(cx.tcx, expr.hir_id));\n         match diag_name {\n-            sym::print_macro | sym::println_macro => {\n+            sym::print_macro | sym::println_macro if !allowed_in_tests => {\n                 if !is_build_script {\n                     span_lint(cx, PRINT_STDOUT, macro_call.span, &format!(\"use of `{name}!`\"));\n                 }\n             },\n-            sym::eprint_macro | sym::eprintln_macro => {\n+            sym::eprint_macro | sym::eprintln_macro if !allowed_in_tests => {\n                 span_lint(cx, PRINT_STDERR, macro_call.span, &format!(\"use of `{name}!`\"));\n             },\n             sym::write_macro | sym::writeln_macro => {},"}, {"sha": "fb9f4740ecc5003922077019e7c3c12e4d634e77", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "939c61189ec8dadf090cad8f5ee3019143fa5e2a", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -148,11 +148,19 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n         (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n         (\n-            MethodCall(box ast::MethodCall { seg: ls, receiver: lr, args: la, .. }),\n-            MethodCall(box ast::MethodCall { seg: rs, receiver: rr, args: ra, .. })\n-        ) => {\n-            eq_path_seg(ls, rs) && eq_expr(lr, rr) && over(la, ra, |l, r| eq_expr(l, r))\n-        },\n+            MethodCall(box ast::MethodCall {\n+                seg: ls,\n+                receiver: lr,\n+                args: la,\n+                ..\n+            }),\n+            MethodCall(box ast::MethodCall {\n+                seg: rs,\n+                receiver: rr,\n+                args: ra,\n+                ..\n+            }),\n+        ) => eq_path_seg(ls, rs) && eq_expr(lr, rr) && over(la, ra, |l, r| eq_expr(l, r)),\n         (Binary(lo, ll, lr), Binary(ro, rl, rr)) => lo.node == ro.node && eq_expr(ll, rl) && eq_expr(lr, rr),\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n         (Lit(l), Lit(r)) => l == r,\n@@ -191,7 +199,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n                 fn_decl: rf,\n                 body: re,\n                 ..\n-            })\n+            }),\n         ) => {\n             eq_closure_binder(lb, rb)\n                 && lc == rc"}, {"sha": "315aea9aa091bc3b4f8f8f3d3e83fb0cc3c83b2f", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -51,8 +51,8 @@ pub enum Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n-            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (Self::Str(ls), Self::Str(rs)) => ls == rs,\n+            (Self::Binary(l), Self::Binary(r)) => l == r,\n             (&Self::Char(l), &Self::Char(r)) => l == r,\n             (&Self::Int(l), &Self::Int(r)) => l == r,\n             (&Self::F64(l), &Self::F64(r)) => {\n@@ -69,8 +69,8 @@ impl PartialEq for Constant {\n             },\n             (&Self::Bool(l), &Self::Bool(r)) => l == r,\n             (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n+            (Self::Repeat(lv, ls), Self::Repeat(rv, rs)) => ls == rs && lv == rv,\n+            (Self::Ref(lb), Self::Ref(rb)) => *lb == *rb,\n             // TODO: are there inter-type equalities?\n             _ => false,\n         }\n@@ -126,17 +126,17 @@ impl Hash for Constant {\n impl Constant {\n     pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n-            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (Self::Str(ls), Self::Str(rs)) => Some(ls.cmp(rs)),\n+            (Self::Char(l), Self::Char(r)) => Some(l.cmp(r)),\n             (&Self::Int(l), &Self::Int(r)) => match *cmp_type.kind() {\n                 ty::Int(int_ty) => Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty))),\n                 ty::Uint(_) => Some(l.cmp(&r)),\n                 _ => bug!(\"Not an int type\"),\n             },\n             (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n             (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n-            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Self::Tuple(ref l), &Self::Tuple(ref r)) if l.len() == r.len() => match *cmp_type.kind() {\n+            (Self::Bool(l), Self::Bool(r)) => Some(l.cmp(r)),\n+            (Self::Tuple(l), Self::Tuple(r)) if l.len() == r.len() => match *cmp_type.kind() {\n                 ty::Tuple(tys) if tys.len() == l.len() => l\n                     .iter()\n                     .zip(r)\n@@ -146,17 +146,16 @@ impl Constant {\n                     .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n                 _ => None,\n             },\n-            (&Self::Vec(ref l), &Self::Vec(ref r)) => {\n-                let cmp_type = match *cmp_type.kind() {\n-                    ty::Array(ty, _) | ty::Slice(ty) => ty,\n-                    _ => return None,\n+            (Self::Vec(l), Self::Vec(r)) => {\n+                let (ty::Array(cmp_type, _) | ty::Slice(cmp_type)) = *cmp_type.kind() else {\n+                    return None\n                 };\n                 iter::zip(l, r)\n                     .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n                     .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n                     .unwrap_or_else(|| Some(l.len().cmp(&r.len())))\n             },\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n+            (Self::Repeat(lv, ls), Self::Repeat(rv, rs)) => {\n                 match Self::partial_cmp(\n                     tcx,\n                     match *cmp_type.kind() {\n@@ -170,7 +169,7 @@ impl Constant {\n                     x => x,\n                 }\n             },\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(\n+            (Self::Ref(lb), Self::Ref(rb)) => Self::partial_cmp(\n                 tcx,\n                 match *cmp_type.kind() {\n                     ty::Ref(_, ty, _) => ty,\n@@ -401,10 +400,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         use self::Constant::{Int, F32, F64};\n         match *o {\n             Int(value) => {\n-                let ity = match *ty.kind() {\n-                    ty::Int(ity) => ity,\n-                    _ => return None,\n-                };\n+                let ty::Int(ity) = *ty.kind() else { return None };\n                 // sign extend\n                 let value = sext(self.lcx.tcx, value, ity);\n                 let value = value.checked_neg()?;"}, {"sha": "16b160b6fd27ef688b888d8e9fbd9cee5d2da35b", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -72,8 +72,8 @@ pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: impl Into<Mult\n ///    |\n ///    = help: consider using `f64::NAN` if you would like a constant representing NaN\n /// ```\n-pub fn span_lint_and_help<'a, T: LintContext>(\n-    cx: &'a T,\n+pub fn span_lint_and_help<T: LintContext>(\n+    cx: &T,\n     lint: &'static Lint,\n     span: impl Into<MultiSpan>,\n     msg: &str,\n@@ -114,8 +114,8 @@ pub fn span_lint_and_help<'a, T: LintContext>(\n /// 10 |     forget(&SomeStruct);\n ///    |            ^^^^^^^^^^^\n /// ```\n-pub fn span_lint_and_note<'a, T: LintContext>(\n-    cx: &'a T,\n+pub fn span_lint_and_note<T: LintContext>(\n+    cx: &T,\n     lint: &'static Lint,\n     span: impl Into<MultiSpan>,\n     msg: &str,\n@@ -192,8 +192,8 @@ pub fn span_lint_hir_and_then(\n ///     = note: `-D fold-any` implied by `-D warnings`\n /// ```\n #[cfg_attr(feature = \"internal\", allow(clippy::collapsible_span_lint_calls))]\n-pub fn span_lint_and_sugg<'a, T: LintContext>(\n-    cx: &'a T,\n+pub fn span_lint_and_sugg<T: LintContext>(\n+    cx: &T,\n     lint: &'static Lint,\n     sp: Span,\n     msg: &str,"}, {"sha": "0231a51adf48286103381c147be10b9d9c457502", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::HirIdMap;\n use rustc_hir::{\n     ArrayLen, BinOpKind, BindingAnnotation, Block, BodyId, Closure, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n     GenericArgs, Guard, HirId, InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n+    PathSegment, PrimTy, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n@@ -131,13 +131,10 @@ impl HirEqInterExpr<'_, '_, '_> {\n             ([], None, [], None) => {\n                 // For empty blocks, check to see if the tokens are equal. This will catch the case where a macro\n                 // expanded to nothing, or the cfg attribute was used.\n-                let (left, right) = match (\n+                let (Some(left), Some(right)) = (\n                     snippet_opt(self.inner.cx, left.span),\n                     snippet_opt(self.inner.cx, right.span),\n-                ) {\n-                    (Some(left), Some(right)) => (left, right),\n-                    _ => return true,\n-                };\n+                ) else { return true };\n                 let mut left_pos = 0;\n                 let left = tokenize(&left)\n                     .map(|t| {\n@@ -269,7 +266,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::Let(l), &ExprKind::Let(r)) => {\n                 self.eq_pat(l.pat, r.pat) && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) && self.eq_expr(l.init, r.init)\n             },\n-            (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n+            (ExprKind::Lit(l), ExprKind::Lit(r)) => l.node == r.node,\n             (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n             },\n@@ -294,8 +291,8 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::Repeat(le, ll), &ExprKind::Repeat(re, rl)) => {\n                 self.eq_expr(le, re) && self.eq_array_length(ll, rl)\n             },\n-            (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (ExprKind::Ret(l), ExprKind::Ret(r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n+            (ExprKind::Path(l), ExprKind::Path(r)) => self.eq_qpath(l, r),\n             (&ExprKind::Struct(l_path, lf, ref lo), &ExprKind::Struct(r_path, rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path)\n                     && both(lo, ro, |l, r| self.eq_expr(l, r))\n@@ -365,7 +362,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 }\n                 eq\n             },\n-            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (PatKind::Path(l), PatKind::Path(r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(l), &PatKind::Lit(r)) => self.eq_expr(l, r),\n             (&PatKind::Tuple(l, ls), &PatKind::Tuple(r, rs)) => ls == rs && over(l, r, |l, r| self.eq_pat(l, r)),\n             (&PatKind::Range(ref ls, ref le, li), &PatKind::Range(ref rs, ref re, ri)) => {\n@@ -432,13 +429,11 @@ impl HirEqInterExpr<'_, '_, '_> {\n         match (&left.kind, &right.kind) {\n             (&TyKind::Slice(l_vec), &TyKind::Slice(r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(lt, ll), &TyKind::Array(rt, rl)) => self.eq_ty(lt, rt) && self.eq_array_length(ll, rl),\n-            (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n-                l_mut.mutbl == r_mut.mutbl && self.eq_ty(l_mut.ty, r_mut.ty)\n-            },\n-            (&TyKind::Rptr(_, ref l_rmut), &TyKind::Rptr(_, ref r_rmut)) => {\n+            (TyKind::Ptr(l_mut), TyKind::Ptr(r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(l_mut.ty, r_mut.ty),\n+            (TyKind::Rptr(_, l_rmut), TyKind::Rptr(_, r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(l_rmut.ty, r_rmut.ty)\n             },\n-            (&TyKind::Path(ref l), &TyKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (TyKind::Path(l), TyKind::Path(r)) => self.eq_qpath(l, r),\n             (&TyKind::Tup(l), &TyKind::Tup(r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyKind::Infer, &TyKind::Infer) => true,\n             _ => false,\n@@ -1033,6 +1028,14 @@ pub fn hash_stmt(cx: &LateContext<'_>, s: &Stmt<'_>) -> u64 {\n     h.finish()\n }\n \n+pub fn is_bool(ty: &Ty<'_>) -> bool {\n+    if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {\n+        matches!(path.res, Res::PrimTy(PrimTy::Bool))\n+    } else {\n+        false\n+    }\n+}\n+\n pub fn hash_expr(cx: &LateContext<'_>, e: &Expr<'_>) -> u64 {\n     let mut h = SpanlessHash::new(cx);\n     h.hash_expr(e);"}, {"sha": "9e2682925a22116c71acdb6847f1572207f84d74", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 176, "deletions": 139, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -66,7 +66,7 @@ pub mod visitors;\n pub use self::attrs::*;\n pub use self::check_proc_macro::{is_from_proc_macro, is_span_if, is_span_match};\n pub use self::hir_utils::{\n-    both, count_eq, eq_expr_value, hash_expr, hash_stmt, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n+    both, count_eq, eq_expr_value, hash_expr, hash_stmt, is_bool, over, HirEqInterExpr, SpanlessEq, SpanlessHash,\n };\n \n use core::ops::ControlFlow;\n@@ -80,17 +80,16 @@ use rustc_ast::ast::{self, LitKind};\n use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Closure, Constness,\n-    Destination, Expr, ExprKind, FnDecl, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind,\n-    LangItem, Local, MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy,\n-    QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n+    self as hir, def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Closure, Constness, Destination,\n+    Expr, ExprKind, FnDecl, HirId, Impl, ImplItem, ImplItemKind, ImplItemRef, IsAsync, Item, ItemKind, LangItem, Local,\n+    MatchSource, Mutability, Node, OwnerId, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind,\n+    TraitItem, TraitItemKind, TraitItemRef, TraitRef, TyKind, UnOp,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n@@ -109,11 +108,10 @@ use rustc_middle::ty::{FloatTy, IntTy, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n-use rustc_span::source_map::original_sp;\n use rustc_span::source_map::SourceMap;\n use rustc_span::sym;\n-use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::Integer;\n \n use crate::consts::{constant, Constant};\n@@ -436,11 +434,7 @@ pub fn is_expr_path_def_path(cx: &LateContext<'_>, expr: &Expr<'_>, segments: &[\n \n /// If `maybe_path` is a path node which resolves to an item, resolves it to a `DefId` and checks if\n /// it matches the given lang item.\n-pub fn is_path_lang_item<'tcx>(\n-    cx: &LateContext<'_>,\n-    maybe_path: &impl MaybePath<'tcx>,\n-    lang_item: LangItem,\n-) -> bool {\n+pub fn is_path_lang_item<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>, lang_item: LangItem) -> bool {\n     path_def_id(cx, maybe_path).map_or(false, |id| cx.tcx.lang_items().get(lang_item) == Some(id))\n }\n \n@@ -535,136 +529,188 @@ pub fn path_def_id<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>\n     path_res(cx, maybe_path).opt_def_id()\n }\n \n-fn find_primitive<'tcx>(tcx: TyCtxt<'tcx>, name: &str) -> impl Iterator<Item = DefId> + 'tcx {\n-    let single = |ty| tcx.incoherent_impls(ty).iter().copied();\n-    let empty = || [].iter().copied();\n-    match name {\n-        \"bool\" => single(BoolSimplifiedType),\n-        \"char\" => single(CharSimplifiedType),\n-        \"str\" => single(StrSimplifiedType),\n-        \"array\" => single(ArraySimplifiedType),\n-        \"slice\" => single(SliceSimplifiedType),\n+fn find_primitive_impls<'tcx>(tcx: TyCtxt<'tcx>, name: &str) -> impl Iterator<Item = DefId> + 'tcx {\n+    let ty = match name {\n+        \"bool\" => BoolSimplifiedType,\n+        \"char\" => CharSimplifiedType,\n+        \"str\" => StrSimplifiedType,\n+        \"array\" => ArraySimplifiedType,\n+        \"slice\" => SliceSimplifiedType,\n         // FIXME: rustdoc documents these two using just `pointer`.\n         //\n         // Maybe this is something we should do here too.\n-        \"const_ptr\" => single(PtrSimplifiedType(Mutability::Not)),\n-        \"mut_ptr\" => single(PtrSimplifiedType(Mutability::Mut)),\n-        \"isize\" => single(IntSimplifiedType(IntTy::Isize)),\n-        \"i8\" => single(IntSimplifiedType(IntTy::I8)),\n-        \"i16\" => single(IntSimplifiedType(IntTy::I16)),\n-        \"i32\" => single(IntSimplifiedType(IntTy::I32)),\n-        \"i64\" => single(IntSimplifiedType(IntTy::I64)),\n-        \"i128\" => single(IntSimplifiedType(IntTy::I128)),\n-        \"usize\" => single(UintSimplifiedType(UintTy::Usize)),\n-        \"u8\" => single(UintSimplifiedType(UintTy::U8)),\n-        \"u16\" => single(UintSimplifiedType(UintTy::U16)),\n-        \"u32\" => single(UintSimplifiedType(UintTy::U32)),\n-        \"u64\" => single(UintSimplifiedType(UintTy::U64)),\n-        \"u128\" => single(UintSimplifiedType(UintTy::U128)),\n-        \"f32\" => single(FloatSimplifiedType(FloatTy::F32)),\n-        \"f64\" => single(FloatSimplifiedType(FloatTy::F64)),\n-        _ => empty(),\n-    }\n-}\n-\n-/// Resolves a def path like `std::vec::Vec`. `namespace_hint` can be supplied to disambiguate\n-/// between `std::vec` the module and `std::vec` the macro\n-///\n-/// This function is expensive and should be used sparingly.\n-pub fn def_path_res(cx: &LateContext<'_>, path: &[&str], namespace_hint: Option<Namespace>) -> Res {\n-    fn item_child_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str, matches_ns: impl Fn(Res) -> bool) -> Option<Res> {\n-        match tcx.def_kind(def_id) {\n-            DefKind::Mod | DefKind::Enum | DefKind::Trait => tcx\n-                .module_children(def_id)\n-                .iter()\n-                .find(|item| item.ident.name.as_str() == name && matches_ns(item.res.expect_non_local()))\n-                .map(|child| child.res.expect_non_local()),\n-            DefKind::Impl => tcx\n-                .associated_item_def_ids(def_id)\n-                .iter()\n-                .copied()\n-                .find(|assoc_def_id| tcx.item_name(*assoc_def_id).as_str() == name)\n-                .map(|assoc_def_id| Res::Def(tcx.def_kind(assoc_def_id), assoc_def_id)),\n-            DefKind::Struct | DefKind::Union => tcx\n-                .adt_def(def_id)\n-                .non_enum_variant()\n-                .fields\n-                .iter()\n-                .find(|f| f.name.as_str() == name)\n-                .map(|f| Res::Def(DefKind::Field, f.did)),\n-            _ => None,\n+        \"const_ptr\" => PtrSimplifiedType(Mutability::Not),\n+        \"mut_ptr\" => PtrSimplifiedType(Mutability::Mut),\n+        \"isize\" => IntSimplifiedType(IntTy::Isize),\n+        \"i8\" => IntSimplifiedType(IntTy::I8),\n+        \"i16\" => IntSimplifiedType(IntTy::I16),\n+        \"i32\" => IntSimplifiedType(IntTy::I32),\n+        \"i64\" => IntSimplifiedType(IntTy::I64),\n+        \"i128\" => IntSimplifiedType(IntTy::I128),\n+        \"usize\" => UintSimplifiedType(UintTy::Usize),\n+        \"u8\" => UintSimplifiedType(UintTy::U8),\n+        \"u16\" => UintSimplifiedType(UintTy::U16),\n+        \"u32\" => UintSimplifiedType(UintTy::U32),\n+        \"u64\" => UintSimplifiedType(UintTy::U64),\n+        \"u128\" => UintSimplifiedType(UintTy::U128),\n+        \"f32\" => FloatSimplifiedType(FloatTy::F32),\n+        \"f64\" => FloatSimplifiedType(FloatTy::F64),\n+        _ => return [].iter().copied(),\n+    };\n+\n+    tcx.incoherent_impls(ty).iter().copied()\n+}\n+\n+fn non_local_item_children_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: Symbol) -> Vec<Res> {\n+    match tcx.def_kind(def_id) {\n+        DefKind::Mod | DefKind::Enum | DefKind::Trait => tcx\n+            .module_children(def_id)\n+            .iter()\n+            .filter(|item| item.ident.name == name)\n+            .map(|child| child.res.expect_non_local())\n+            .collect(),\n+        DefKind::Impl => tcx\n+            .associated_item_def_ids(def_id)\n+            .iter()\n+            .copied()\n+            .filter(|assoc_def_id| tcx.item_name(*assoc_def_id) == name)\n+            .map(|assoc_def_id| Res::Def(tcx.def_kind(assoc_def_id), assoc_def_id))\n+            .collect(),\n+        _ => Vec::new(),\n+    }\n+}\n+\n+fn local_item_children_by_name(tcx: TyCtxt<'_>, local_id: LocalDefId, name: Symbol) -> Vec<Res> {\n+    let hir = tcx.hir();\n+\n+    let root_mod;\n+    let item_kind = match hir.find_by_def_id(local_id) {\n+        Some(Node::Crate(r#mod)) => {\n+            root_mod = ItemKind::Mod(r#mod);\n+            &root_mod\n+        },\n+        Some(Node::Item(item)) => &item.kind,\n+        _ => return Vec::new(),\n+    };\n+\n+    let res = |ident: Ident, owner_id: OwnerId| {\n+        if ident.name == name {\n+            let def_id = owner_id.to_def_id();\n+            Some(Res::Def(tcx.def_kind(def_id), def_id))\n+        } else {\n+            None\n         }\n+    };\n+\n+    match item_kind {\n+        ItemKind::Mod(r#mod) => r#mod\n+            .item_ids\n+            .iter()\n+            .filter_map(|&item_id| res(hir.item(item_id).ident, item_id.owner_id))\n+            .collect(),\n+        ItemKind::Impl(r#impl) => r#impl\n+            .items\n+            .iter()\n+            .filter_map(|&ImplItemRef { ident, id, .. }| res(ident, id.owner_id))\n+            .collect(),\n+        ItemKind::Trait(.., trait_item_refs) => trait_item_refs\n+            .iter()\n+            .filter_map(|&TraitItemRef { ident, id, .. }| res(ident, id.owner_id))\n+            .collect(),\n+        _ => Vec::new(),\n     }\n+}\n+\n+fn item_children_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: Symbol) -> Vec<Res> {\n+    if let Some(local_id) = def_id.as_local() {\n+        local_item_children_by_name(tcx, local_id, name)\n+    } else {\n+        non_local_item_children_by_name(tcx, def_id, name)\n+    }\n+}\n \n-    fn find_crate(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n+/// Resolves a def path like `std::vec::Vec`.\n+///\n+/// Can return multiple resolutions when there are multiple versions of the same crate, e.g.\n+/// `memchr::memchr` could return the functions from both memchr 1.0 and memchr 2.0.\n+///\n+/// Also returns multiple results when there are mulitple paths under the same name e.g. `std::vec`\n+/// would have both a [`DefKind::Mod`] and [`DefKind::Macro`].\n+///\n+/// This function is expensive and should be used sparingly.\n+pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Vec<Res> {\n+    fn find_crates(tcx: TyCtxt<'_>, name: Symbol) -> impl Iterator<Item = DefId> + '_ {\n         tcx.crates(())\n             .iter()\n             .copied()\n-            .find(|&num| tcx.crate_name(num).as_str() == name)\n+            .filter(move |&num| tcx.crate_name(num) == name)\n             .map(CrateNum::as_def_id)\n     }\n \n-    let (base, path) = match *path {\n+    let tcx = cx.tcx;\n+\n+    let (base, mut path) = match *path {\n         [primitive] => {\n-            return PrimTy::from_name(Symbol::intern(primitive)).map_or(Res::Err, Res::PrimTy);\n+            return vec![PrimTy::from_name(Symbol::intern(primitive)).map_or(Res::Err, Res::PrimTy)];\n         },\n         [base, ref path @ ..] => (base, path),\n-        _ => return Res::Err,\n+        _ => return Vec::new(),\n     };\n-    let tcx = cx.tcx;\n-    let starts = find_primitive(tcx, base)\n-        .chain(find_crate(tcx, base))\n+\n+    let base_sym = Symbol::intern(base);\n+\n+    let local_crate = if tcx.crate_name(LOCAL_CRATE) == base_sym {\n+        Some(LOCAL_CRATE.as_def_id())\n+    } else {\n+        None\n+    };\n+\n+    let starts = find_primitive_impls(tcx, base)\n+        .chain(find_crates(tcx, base_sym))\n+        .chain(local_crate)\n         .map(|id| Res::Def(tcx.def_kind(id), id));\n \n-    for first in starts {\n-        let last = path\n-            .iter()\n-            .copied()\n-            .enumerate()\n-            // for each segment, find the child item\n-            .try_fold(first, |res, (idx, segment)| {\n-                let matches_ns = |res: Res| {\n-                    // If at the last segment in the path, respect the namespace hint\n-                    if idx == path.len() - 1 {\n-                        match namespace_hint {\n-                            Some(ns) => res.matches_ns(ns),\n-                            None => true,\n-                        }\n-                    } else {\n-                        res.matches_ns(Namespace::TypeNS)\n-                    }\n-                };\n-\n-                let def_id = res.def_id();\n-                if let Some(item) = item_child_by_name(tcx, def_id, segment, matches_ns) {\n-                    Some(item)\n-                } else if matches!(res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n-                    // it is not a child item so check inherent impl items\n-                    tcx.inherent_impls(def_id)\n-                        .iter()\n-                        .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment, matches_ns))\n-                } else {\n-                    None\n-                }\n-            });\n+    let mut resolutions: Vec<Res> = starts.collect();\n \n-        if let Some(last) = last {\n-            return last;\n-        }\n+    while let [segment, rest @ ..] = path {\n+        path = rest;\n+        let segment = Symbol::intern(segment);\n+\n+        resolutions = resolutions\n+            .into_iter()\n+            .filter_map(|res| res.opt_def_id())\n+            .flat_map(|def_id| {\n+                // When the current def_id is e.g. `struct S`, check the impl items in\n+                // `impl S { ... }`\n+                let inherent_impl_children = tcx\n+                    .inherent_impls(def_id)\n+                    .iter()\n+                    .flat_map(|&impl_def_id| item_children_by_name(tcx, impl_def_id, segment));\n+\n+                let direct_children = item_children_by_name(tcx, def_id, segment);\n+\n+                inherent_impl_children.chain(direct_children)\n+            })\n+            .collect();\n     }\n \n-    Res::Err\n+    resolutions\n+}\n+\n+/// Resolves a def path like `std::vec::Vec` to its [`DefId`]s, see [`def_path_res`].\n+pub fn def_path_def_ids(cx: &LateContext<'_>, path: &[&str]) -> impl Iterator<Item = DefId> {\n+    def_path_res(cx, path).into_iter().filter_map(|res| res.opt_def_id())\n }\n \n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n ///\n /// This function is expensive and should be used sparingly.\n pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n-    match def_path_res(cx, path, Some(Namespace::TypeNS)) {\n+    def_path_res(cx, path).into_iter().find_map(|res| match res {\n         Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n         _ => None,\n-    }\n+    })\n }\n \n /// Gets the `hir::TraitRef` of the trait the given method is implemented for.\n@@ -784,9 +830,9 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n         if method.ident.name == sym::new {\n             if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n                 if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n-                    return std_types_symbols\n-                        .iter()\n-                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did()) || Some(adt.did()) == cx.tcx.lang_items().string());\n+                    return std_types_symbols.iter().any(|&symbol| {\n+                        cx.tcx.is_diagnostic_item(symbol, adt.did()) || Some(adt.did()) == cx.tcx.lang_items().string()\n+                    });\n                 }\n             }\n         }\n@@ -963,7 +1009,7 @@ impl std::ops::BitOrAssign for CaptureKind {\n /// Note as this will walk up to parent expressions until the capture can be determined it should\n /// only be used while making a closure somewhere a value is consumed. e.g. a block, match arm, or\n /// function argument (other than a receiver).\n-pub fn capture_local_usage<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind {\n+pub fn capture_local_usage(cx: &LateContext<'_>, e: &Expr<'_>) -> CaptureKind {\n     fn pat_capture_kind(cx: &LateContext<'_>, pat: &Pat<'_>) -> CaptureKind {\n         let mut capture = CaptureKind::Ref(Mutability::Not);\n         pat.each_binding_or_first(&mut |_, id, span, _| match cx\n@@ -1260,23 +1306,6 @@ pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n     .is_some()\n }\n \n-/// Extends the span to the beginning of the spans line, incl. whitespaces.\n-///\n-/// ```rust\n-///        let x = ();\n-/// //             ^^\n-/// // will be converted to\n-///        let x = ();\n-/// // ^^^^^^^^^^^^^^\n-/// ```\n-fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n-    let span = original_sp(span, DUMMY_SP);\n-    let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n-    let line_no = source_map_and_line.line;\n-    let line_start = source_map_and_line.sf.lines(|lines| lines[line_no]);\n-    span.with_lo(line_start)\n-}\n-\n /// Gets the parent node, if any.\n pub fn get_parent_node(tcx: TyCtxt<'_>, id: HirId) -> Option<Node<'_>> {\n     tcx.hir().parent_iter(id).next().map(|(_, node)| node)\n@@ -1749,6 +1778,10 @@ pub fn has_attr(attrs: &[ast::Attribute], symbol: Symbol) -> bool {\n     attrs.iter().any(|attr| attr.has_name(symbol))\n }\n \n+pub fn has_repr_attr(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+    has_attr(cx.tcx.hir().attrs(hir_id), sym::repr)\n+}\n+\n pub fn any_parent_has_attr(tcx: TyCtxt<'_>, node: HirId, symbol: Symbol) -> bool {\n     let map = &tcx.hir();\n     let mut prev_enclosing_node = None;\n@@ -1821,7 +1854,7 @@ pub fn match_any_def_paths(cx: &LateContext<'_>, did: DefId, paths: &[&[&str]])\n }\n \n /// Checks if the given `DefId` matches the path.\n-pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n+pub fn match_def_path(cx: &LateContext<'_>, did: DefId, syms: &[&str]) -> bool {\n     // We should probably move to Symbols in Clippy as well rather than interning every time.\n     let path = cx.get_def_path(did);\n     syms.iter().map(|x| Symbol::intern(x)).eq(path.iter().copied())\n@@ -1870,7 +1903,11 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n \n /// Checks if the given function kind is an async function.\n pub fn is_async_fn(kind: FnKind<'_>) -> bool {\n-    matches!(kind, FnKind::ItemFn(_, _, header) if header.asyncness.is_async())\n+    match kind {\n+        FnKind::ItemFn(_, _, header) => header.asyncness == IsAsync::Async,\n+        FnKind::Method(_, sig) => sig.header.asyncness == IsAsync::Async,\n+        FnKind::Closure => false,\n+    }\n }\n \n /// Peels away all the compiler generated code surrounding the body of an async function,"}, {"sha": "79b19e6fb3eb051eff7a865ac44ea944e4d9cd88", "filename": "src/tools/clippy/clippy_utils/src/msrvs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -12,13 +12,14 @@ macro_rules! msrv_aliases {\n \n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n+    1,65,0 { LET_ELSE }\n     1,62,0 { BOOL_THEN_SOME }\n     1,58,0 { FORMAT_ARGS_CAPTURE }\n     1,53,0 { OR_PATTERNS, MANUAL_BITS, BTREE_MAP_RETAIN, BTREE_SET_RETAIN, ARRAY_INTO_ITERATOR }\n     1,52,0 { STR_SPLIT_ONCE, REM_EUCLID_CONST }\n-    1,51,0 { BORROW_AS_PTR, UNSIGNED_ABS }\n+    1,51,0 { BORROW_AS_PTR, SEEK_FROM_CURRENT, UNSIGNED_ABS }\n     1,50,0 { BOOL_THEN, CLAMP }\n-    1,47,0 { TAU }\n+    1,47,0 { TAU, IS_ASCII_DIGIT_CONST }\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }\n     1,43,0 { LOG2_10, LOG10_2 }\n@@ -37,4 +38,5 @@ msrv_aliases! {\n     1,18,0 { HASH_MAP_RETAIN, HASH_SET_RETAIN }\n     1,17,0 { FIELD_INIT_SHORTHAND, STATIC_IN_CONST, EXPECT_ERR }\n     1,16,0 { STR_REPEAT }\n+    1,55,0 { SEEK_REWIND }\n }"}, {"sha": "6c09c146082ab41e673ea06b142afb334fea833c", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -115,6 +115,9 @@ pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n pub const CONVERT_IDENTITY: [&str; 3] = [\"core\", \"convert\", \"identity\"];\n pub const STD_FS_CREATE_DIR: [&str; 3] = [\"std\", \"fs\", \"create_dir\"];\n+pub const STD_IO_SEEK: [&str; 3] = [\"std\", \"io\", \"Seek\"];\n+pub const STD_IO_SEEK_FROM_CURRENT: [&str; 4] = [\"std\", \"io\", \"SeekFrom\", \"Current\"];\n+pub const STD_IO_SEEKFROM_START: [&str; 4] = [\"std\", \"io\", \"SeekFrom\", \"Start\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n pub const STRING_NEW: [&str; 4] = [\"alloc\", \"string\", \"String\", \"new\"];"}, {"sha": "65722f142aa69c4c8b5055e325b32b60ff3adb17", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -18,7 +18,7 @@ use std::borrow::Cow;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n-pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<RustcVersion>) -> McfResult {\n+pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: Option<RustcVersion>) -> McfResult {\n     let def_id = body.source.def_id();\n     let mut current = def_id;\n     loop {\n@@ -276,9 +276,9 @@ fn check_place<'tcx>(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &B\n     Ok(())\n }\n \n-fn check_terminator<'a, 'tcx>(\n+fn check_terminator<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: &'a Body<'tcx>,\n+    body: &Body<'tcx>,\n     terminator: &Terminator<'tcx>,\n     msrv: Option<RustcVersion>,\n ) -> McfResult {"}, {"sha": "eacfa91ba556d41d454f2b3a63c5a325ae4311cd", "filename": "src/tools/clippy/clippy_utils/src/source.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -2,13 +2,12 @@\n \n #![allow(clippy::module_name_repetitions)]\n \n-use crate::line_span;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_span::hygiene;\n-use rustc_span::source_map::SourceMap;\n-use rustc_span::{BytePos, Pos, Span, SpanData, SyntaxContext};\n+use rustc_span::source_map::{original_sp, SourceMap};\n+use rustc_span::{BytePos, Pos, Span, SpanData, SyntaxContext, DUMMY_SP};\n use std::borrow::Cow;\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n@@ -55,6 +54,23 @@ fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePo\n     })\n }\n \n+/// Extends the span to the beginning of the spans line, incl. whitespaces.\n+///\n+/// ```rust\n+///        let x = ();\n+/// //             ^^\n+/// // will be converted to\n+///        let x = ();\n+/// // ^^^^^^^^^^^^^^\n+/// ```\n+fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    let span = original_sp(span, DUMMY_SP);\n+    let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n+    let line_no = source_map_and_line.line;\n+    let line_start = source_map_and_line.sf.lines(|lines| lines[line_no]);\n+    span.with_lo(line_start)\n+}\n+\n /// Returns the indentation of the line of a span\n ///\n /// ```rust,ignore"}, {"sha": "3cacdb493772138594a03114722fc2b10c9c74ff", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -801,7 +801,7 @@ pub struct DerefClosure {\n /// Returns `None` if no such use cases have been triggered in closure body\n ///\n /// note: this only works on single line immutable closures with exactly one input parameter.\n-pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, closure: &'tcx hir::Expr<'_>) -> Option<DerefClosure> {\n+pub fn deref_closure_args(cx: &LateContext<'_>, closure: &hir::Expr<'_>) -> Option<DerefClosure> {\n     if let hir::ExprKind::Closure(&Closure { fn_decl, body, .. }) = closure.kind {\n         let closure_body = cx.tcx.hir().body(body);\n         // is closure arg a type annotated double reference (i.e.: `|x: &&i32| ...`)"}, {"sha": "897edfc5495f45b87f9f04d6f042fa85c01303cd", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 221, "deletions": 3, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -13,8 +13,9 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy,\n-    Region, RegionKind, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n+    self, AdtDef, AssocKind, Binder, BoundRegion, DefIdTree, FnSig, GenericParamDefKind, IntTy, List, ParamEnv,\n+    Predicate, PredicateKind, ProjectionTy, Region, RegionKind, SubstsRef, Ty, TyCtxt, TypeSuperVisitable,\n+    TypeVisitable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::symbol::Ident;\n@@ -59,6 +60,58 @@ pub fn contains_adt_constructor<'tcx>(ty: Ty<'tcx>, adt: AdtDef<'tcx>) -> bool {\n     })\n }\n \n+/// Walks into `ty` and returns `true` if any inner type is an instance of the given type, or adt\n+/// constructor of the same type.\n+///\n+/// This method also recurses into opaque type predicates, so call it with `impl Trait<U>` and `U`\n+/// will also return `true`.\n+pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, needle: Ty<'tcx>) -> bool {\n+    ty.walk().any(|inner| match inner.unpack() {\n+        GenericArgKind::Type(inner_ty) => {\n+            if inner_ty == needle {\n+                return true;\n+            }\n+\n+            if inner_ty.ty_adt_def() == needle.ty_adt_def() {\n+                return true;\n+            }\n+\n+            if let ty::Opaque(def_id, _) = *inner_ty.kind() {\n+                for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n+                    match predicate.kind().skip_binder() {\n+                        // For `impl Trait<U>`, it will register a predicate of `T: Trait<U>`, so we go through\n+                        // and check substituions to find `U`.\n+                        ty::PredicateKind::Trait(trait_predicate) => {\n+                            if trait_predicate\n+                                .trait_ref\n+                                .substs\n+                                .types()\n+                                .skip(1) // Skip the implicit `Self` generic parameter\n+                                .any(|ty| contains_ty_adt_constructor_opaque(cx, ty, needle))\n+                            {\n+                                return true;\n+                            }\n+                        },\n+                        // For `impl Trait<Assoc=U>`, it will register a predicate of `<T as Trait>::Assoc = U`,\n+                        // so we check the term for `U`.\n+                        ty::PredicateKind::Projection(projection_predicate) => {\n+                            if let ty::TermKind::Ty(ty) = projection_predicate.term.unpack() {\n+                                if contains_ty_adt_constructor_opaque(cx, ty, needle) {\n+                                    return true;\n+                                }\n+                            };\n+                        },\n+                        _ => (),\n+                    }\n+                }\n+            }\n+\n+            false\n+        },\n+        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+    })\n+}\n+\n /// Resolves `<T as Iterator>::Item` for `T`\n /// Do not invoke without first verifying that the type implements `Iterator`\n pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n@@ -701,7 +754,7 @@ impl core::ops::Add<u32> for EnumValue {\n     }\n }\n \n-/// Attempts to read the given constant as though it were an an enum value.\n+/// Attempts to read the given constant as though it were an enum value.\n #[expect(clippy::cast_possible_truncation, clippy::cast_possible_wrap)]\n pub fn read_explicit_enum_value(tcx: TyCtxt<'_>, id: DefId) -> Option<EnumValue> {\n     if let Ok(ConstValue::Scalar(Scalar::Int(value))) = tcx.const_eval_poly(id) {\n@@ -782,6 +835,42 @@ pub fn for_each_top_level_late_bound_region<B>(\n     ty.visit_with(&mut V { index: 0, f })\n }\n \n+pub struct AdtVariantInfo {\n+    pub ind: usize,\n+    pub size: u64,\n+\n+    /// (ind, size)\n+    pub fields_size: Vec<(usize, u64)>,\n+}\n+\n+impl AdtVariantInfo {\n+    /// Returns ADT variants ordered by size\n+    pub fn new<'tcx>(cx: &LateContext<'tcx>, adt: AdtDef<'tcx>, subst: &'tcx List<GenericArg<'tcx>>) -> Vec<Self> {\n+        let mut variants_size = adt\n+            .variants()\n+            .iter()\n+            .enumerate()\n+            .map(|(i, variant)| {\n+                let mut fields_size = variant\n+                    .fields\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, f)| (i, approx_ty_size(cx, f.ty(cx.tcx, subst))))\n+                    .collect::<Vec<_>>();\n+                fields_size.sort_by(|(_, a_size), (_, b_size)| (a_size.cmp(b_size)));\n+\n+                Self {\n+                    ind: i,\n+                    size: fields_size.iter().map(|(_, size)| size).sum(),\n+                    fields_size,\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        variants_size.sort_by(|a, b| (b.size.cmp(&a.size)));\n+        variants_size\n+    }\n+}\n+\n /// Gets the struct or enum variant from the given `Res`\n pub fn variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<&'tcx VariantDef> {\n     match res {\n@@ -876,3 +965,132 @@ pub fn approx_ty_size<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> u64 {\n         (Err(_), _) => 0,\n     }\n }\n+\n+/// Makes the projection type for the named associated type in the given impl or trait impl.\n+///\n+/// This function is for associated types which are \"known\" to exist, and as such, will only return\n+/// `None` when debug assertions are disabled in order to prevent ICE's. With debug assertions\n+/// enabled this will check that the named associated type exists, the correct number of\n+/// substitutions are given, and that the correct kinds of substitutions are given (lifetime,\n+/// constant or type). This will not check if type normalization would succeed.\n+pub fn make_projection<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    container_id: DefId,\n+    assoc_ty: Symbol,\n+    substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+) -> Option<ProjectionTy<'tcx>> {\n+    fn helper<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        container_id: DefId,\n+        assoc_ty: Symbol,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<ProjectionTy<'tcx>> {\n+        let Some(assoc_item) = tcx\n+            .associated_items(container_id)\n+            .find_by_name_and_kind(tcx, Ident::with_dummy_span(assoc_ty), AssocKind::Type, container_id)\n+        else {\n+            debug_assert!(false, \"type `{assoc_ty}` not found in `{container_id:?}`\");\n+            return None;\n+        };\n+        #[cfg(debug_assertions)]\n+        {\n+            let generics = tcx.generics_of(assoc_item.def_id);\n+            let generic_count = generics.parent_count + generics.params.len();\n+            let params = generics\n+                .parent\n+                .map_or([].as_slice(), |id| &*tcx.generics_of(id).params)\n+                .iter()\n+                .chain(&generics.params)\n+                .map(|x| &x.kind);\n+\n+            debug_assert!(\n+                generic_count == substs.len(),\n+                \"wrong number of substs for `{:?}`: found `{}` expected `{}`.\\n\\\n+                    note: the expected parameters are: {:#?}\\n\\\n+                    the given arguments are: `{:#?}`\",\n+                assoc_item.def_id,\n+                substs.len(),\n+                generic_count,\n+                params.map(GenericParamDefKind::descr).collect::<Vec<_>>(),\n+                substs,\n+            );\n+\n+            if let Some((idx, (param, arg))) = params\n+                .clone()\n+                .zip(substs.iter().map(GenericArg::unpack))\n+                .enumerate()\n+                .find(|(_, (param, arg))| {\n+                    !matches!(\n+                        (param, arg),\n+                        (GenericParamDefKind::Lifetime, GenericArgKind::Lifetime(_))\n+                            | (GenericParamDefKind::Type { .. }, GenericArgKind::Type(_))\n+                            | (GenericParamDefKind::Const { .. }, GenericArgKind::Const(_))\n+                    )\n+                })\n+            {\n+                debug_assert!(\n+                    false,\n+                    \"mismatched subst type at index {}: expected a {}, found `{:?}`\\n\\\n+                        note: the expected parameters are {:#?}\\n\\\n+                        the given arguments are {:#?}\",\n+                    idx,\n+                    param.descr(),\n+                    arg,\n+                    params.map(GenericParamDefKind::descr).collect::<Vec<_>>(),\n+                    substs,\n+                );\n+            }\n+        }\n+\n+        Some(ProjectionTy {\n+            substs,\n+            item_def_id: assoc_item.def_id,\n+        })\n+    }\n+    helper(\n+        tcx,\n+        container_id,\n+        assoc_ty,\n+        tcx.mk_substs(substs.into_iter().map(Into::into)),\n+    )\n+}\n+\n+/// Normalizes the named associated type in the given impl or trait impl.\n+///\n+/// This function is for associated types which are \"known\" to be valid with the given\n+/// substitutions, and as such, will only return `None` when debug assertions are disabled in order\n+/// to prevent ICE's. With debug assertions enabled this will check that that type normalization\n+/// succeeds as well as everything checked by `make_projection`.\n+pub fn make_normalized_projection<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    container_id: DefId,\n+    assoc_ty: Symbol,\n+    substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+) -> Option<Ty<'tcx>> {\n+    fn helper<'tcx>(tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: ProjectionTy<'tcx>) -> Option<Ty<'tcx>> {\n+        #[cfg(debug_assertions)]\n+        if let Some((i, subst)) = ty\n+            .substs\n+            .iter()\n+            .enumerate()\n+            .find(|(_, subst)| subst.has_late_bound_regions())\n+        {\n+            debug_assert!(\n+                false,\n+                \"substs contain late-bound region at index `{i}` which can't be normalized.\\n\\\n+                    use `TyCtxt::erase_late_bound_regions`\\n\\\n+                    note: subst is `{subst:#?}`\",\n+            );\n+            return None;\n+        }\n+        match tcx.try_normalize_erasing_regions(param_env, tcx.mk_projection(ty.item_def_id, ty.substs)) {\n+            Ok(ty) => Some(ty),\n+            Err(e) => {\n+                debug_assert!(false, \"failed to normalize type `{ty}`: {e:#?}\");\n+                None\n+            },\n+        }\n+    }\n+    helper(tcx, param_env, make_projection(tcx, container_id, assoc_ty, substs)?)\n+}"}, {"sha": "797722cfc1fcc5c0a60b74cf9178037c4a0ed686", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -73,12 +73,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n         self.update(cmt);\n     }\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {}\n+    fn fake_read(&mut self, _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }\n \n pub struct ParamBindingIdCollector {"}, {"sha": "578109840fb70c44fd456aacd4105889c868bcc5", "filename": "src/tools/clippy/declare_clippy_lint/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2FCargo.toml?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+name = \"declare_clippy_lint\"\n+version = \"0.1.67\"\n+edition = \"2021\"\n+publish = false\n+\n+[lib]\n+proc-macro = true\n+\n+[dependencies]\n+itertools = \"0.10.1\"\n+quote = \"1.0.21\"\n+syn = \"1.0.100\""}, {"sha": "962766916dd1f1fe8b9762b57fcb8cc5ed7bd4cd", "filename": "src/tools/clippy/declare_clippy_lint/src/lib.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdeclare_clippy_lint%2Fsrc%2Flib.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -0,0 +1,173 @@\n+#![feature(let_chains)]\n+#![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n+\n+use proc_macro::TokenStream;\n+use quote::{format_ident, quote};\n+use syn::parse::{Parse, ParseStream};\n+use syn::{parse_macro_input, Attribute, Error, Ident, Lit, LitStr, Meta, Result, Token};\n+\n+fn parse_attr<const LEN: usize>(path: [&'static str; LEN], attr: &Attribute) -> Option<LitStr> {\n+    if let Meta::NameValue(name_value) = attr.parse_meta().ok()? {\n+        let path_idents = name_value.path.segments.iter().map(|segment| &segment.ident);\n+\n+        if itertools::equal(path_idents, path)\n+            && let Lit::Str(lit) = name_value.lit\n+        {\n+            return Some(lit);\n+        }\n+    }\n+\n+    None\n+}\n+\n+struct ClippyLint {\n+    attrs: Vec<Attribute>,\n+    explanation: String,\n+    name: Ident,\n+    category: Ident,\n+    description: LitStr,\n+}\n+\n+impl Parse for ClippyLint {\n+    fn parse(input: ParseStream) -> Result<Self> {\n+        let attrs = input.call(Attribute::parse_outer)?;\n+\n+        let mut in_code = false;\n+        let mut explanation = String::new();\n+        let mut version = None;\n+        for attr in &attrs {\n+            if let Some(lit) = parse_attr([\"doc\"], attr) {\n+                let value = lit.value();\n+                let line = value.strip_prefix(' ').unwrap_or(&value);\n+\n+                if line.starts_with(\"```\") {\n+                    explanation += \"```\\n\";\n+                    in_code = !in_code;\n+                } else if !(in_code && line.starts_with(\"# \")) {\n+                    explanation += line;\n+                    explanation.push('\\n');\n+                }\n+            } else if let Some(lit) = parse_attr([\"clippy\", \"version\"], attr) {\n+                if let Some(duplicate) = version.replace(lit) {\n+                    return Err(Error::new_spanned(duplicate, \"duplicate clippy::version\"));\n+                }\n+            } else {\n+                return Err(Error::new_spanned(attr, \"unexpected attribute\"));\n+            }\n+        }\n+\n+        input.parse::<Token![pub]>()?;\n+        let name = input.parse()?;\n+        input.parse::<Token![,]>()?;\n+\n+        let category = input.parse()?;\n+        input.parse::<Token![,]>()?;\n+\n+        let description = input.parse()?;\n+\n+        Ok(Self {\n+            attrs,\n+            explanation,\n+            name,\n+            category,\n+            description,\n+        })\n+    }\n+}\n+\n+/// Macro used to declare a Clippy lint.\n+///\n+/// Every lint declaration consists of 4 parts:\n+///\n+/// 1. The documentation, which is used for the website and `cargo clippy --explain`\n+/// 2. The `LINT_NAME`. See [lint naming][lint_naming] on lint naming conventions.\n+/// 3. The `lint_level`, which is a mapping from *one* of our lint groups to `Allow`, `Warn` or\n+///    `Deny`. The lint level here has nothing to do with what lint groups the lint is a part of.\n+/// 4. The `description` that contains a short explanation on what's wrong with code where the\n+///    lint is triggered.\n+///\n+/// Currently the categories `style`, `correctness`, `suspicious`, `complexity` and `perf` are\n+/// enabled by default. As said in the README.md of this repository, if the lint level mapping\n+/// changes, please update README.md.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use rustc_session::declare_tool_lint;\n+///\n+/// declare_clippy_lint! {\n+///     /// ### What it does\n+///     /// Checks for ... (describe what the lint matches).\n+///     ///\n+///     /// ### Why is this bad?\n+///     /// Supply the reason for linting the code.\n+///     ///\n+///     /// ### Example\n+///     /// ```rust\n+///     /// Insert a short example of code that triggers the lint\n+///     /// ```\n+///     ///\n+///     /// Use instead:\n+///     /// ```rust\n+///     /// Insert a short example of improved code that doesn't trigger the lint\n+///     /// ```\n+///     #[clippy::version = \"1.65.0\"]\n+///     pub LINT_NAME,\n+///     pedantic,\n+///     \"description\"\n+/// }\n+/// ```\n+/// [lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n+#[proc_macro]\n+pub fn declare_clippy_lint(input: TokenStream) -> TokenStream {\n+    let ClippyLint {\n+        attrs,\n+        explanation,\n+        name,\n+        category,\n+        description,\n+    } = parse_macro_input!(input as ClippyLint);\n+\n+    let mut category = category.to_string();\n+\n+    let level = format_ident!(\n+        \"{}\",\n+        match category.as_str() {\n+            \"correctness\" => \"Deny\",\n+            \"style\" | \"suspicious\" | \"complexity\" | \"perf\" | \"internal_warn\" => \"Warn\",\n+            \"pedantic\" | \"restriction\" | \"cargo\" | \"nursery\" | \"internal\" => \"Allow\",\n+            _ => panic!(\"unknown category {category}\"),\n+        },\n+    );\n+\n+    let info = if category == \"internal_warn\" {\n+        None\n+    } else {\n+        let info_name = format_ident!(\"{name}_INFO\");\n+\n+        (&mut category[0..1]).make_ascii_uppercase();\n+        let category_variant = format_ident!(\"{category}\");\n+\n+        Some(quote! {\n+            pub(crate) static #info_name: &'static crate::LintInfo = &crate::LintInfo {\n+                lint: &#name,\n+                category: crate::LintCategory::#category_variant,\n+                explanation: #explanation,\n+            };\n+        })\n+    };\n+\n+    let output = quote! {\n+        declare_tool_lint! {\n+            #(#attrs)*\n+            pub clippy::#name,\n+            #level,\n+            #description,\n+            report_in_external_macro: true\n+        }\n+\n+        #info\n+    };\n+\n+    TokenStream::from(output)\n+}"}, {"sha": "ee8ab7c1d7cbbc60395caddeb15bc8d3dcf24d58", "filename": "src/tools/clippy/lintcheck/src/main.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -544,34 +544,6 @@ fn gather_stats(clippy_warnings: &[ClippyWarning]) -> (String, HashMap<&String,\n     (stats_string, counter)\n }\n \n-/// check if the latest modification of the logfile is older than the modification date of the\n-/// clippy binary, if this is true, we should clean the lintchec shared target directory and recheck\n-fn lintcheck_needs_rerun(lintcheck_logs_path: &Path, paths: [&Path; 2]) -> bool {\n-    if !lintcheck_logs_path.exists() {\n-        return true;\n-    }\n-\n-    let clippy_modified: std::time::SystemTime = {\n-        let [cargo, driver] = paths.map(|p| {\n-            std::fs::metadata(p)\n-                .expect(\"failed to get metadata of file\")\n-                .modified()\n-                .expect(\"failed to get modification date\")\n-        });\n-        // the oldest modification of either of the binaries\n-        std::cmp::max(cargo, driver)\n-    };\n-\n-    let logs_modified: std::time::SystemTime = std::fs::metadata(lintcheck_logs_path)\n-        .expect(\"failed to get metadata of file\")\n-        .modified()\n-        .expect(\"failed to get modification date\");\n-\n-    // time is represented in seconds since X\n-    // logs_modified 2 and clippy_modified 5 means clippy binary is older and we need to recheck\n-    logs_modified < clippy_modified\n-}\n-\n #[allow(clippy::too_many_lines)]\n fn main() {\n     // We're being executed as a `RUSTC_WRAPPER` as part of `--recursive`\n@@ -594,23 +566,6 @@ fn main() {\n     let cargo_clippy_path = fs::canonicalize(format!(\"target/debug/cargo-clippy{EXE_SUFFIX}\")).unwrap();\n     let clippy_driver_path = fs::canonicalize(format!(\"target/debug/clippy-driver{EXE_SUFFIX}\")).unwrap();\n \n-    // if the clippy bin is newer than our logs, throw away target dirs to force clippy to\n-    // refresh the logs\n-    if lintcheck_needs_rerun(\n-        &config.lintcheck_results_path,\n-        [&cargo_clippy_path, &clippy_driver_path],\n-    ) {\n-        let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n-        // if we get an Err here, the shared target dir probably does simply not exist\n-        if let Ok(metadata) = std::fs::metadata(shared_target_dir) {\n-            if metadata.is_dir() {\n-                println!(\"Clippy is newer than lint check logs, clearing lintcheck shared target dir...\");\n-                std::fs::remove_dir_all(shared_target_dir)\n-                    .expect(\"failed to remove target/lintcheck/shared_target_dir\");\n-            }\n-        }\n-    }\n-\n     // assert that clippy is found\n     assert!(\n         cargo_clippy_path.is_file(),\n@@ -678,7 +633,7 @@ fn main() {\n         .unwrap();\n \n     let server = config.recursive.then(|| {\n-        fs::remove_dir_all(\"target/lintcheck/shared_target_dir/recursive\").unwrap_or_default();\n+        let _ = fs::remove_dir_all(\"target/lintcheck/shared_target_dir/recursive\");\n \n         LintcheckServer::spawn(recursive_options)\n     });"}, {"sha": "a806c1564796ae2a5bb3b5fd5b0fde0659e17d9e", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/ddf055ad07b93d27c826e737b674b65ab760e901/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=ddf055ad07b93d27c826e737b674b65ab760e901", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-10-20\"\n-components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]\n+channel = \"nightly-2022-11-21\"\n+components = [\"cargo\", \"llvm-tools\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "c033ad294a38d974e0e9e65497a15d58c3b95e40", "filename": "src/tools/clippy/src/docs.rs", "status": "removed", "additions": 0, "deletions": 606, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs.rs?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,606 +0,0 @@\n-// autogenerated. Please look at /clippy_dev/src/update_lints.rs\n-\n-macro_rules! include_lint {\n-    ($file_name: expr) => {\n-        include_str!($file_name)\n-    };\n-}\n-\n-macro_rules! docs {\n-    ($($lint_name: expr,)*) => {\n-        pub fn explain(lint: &str) {\n-            println!(\"{}\", match lint {\n-                $(\n-                    $lint_name => include_lint!(concat!(\"docs/\", concat!($lint_name, \".txt\"))),\n-                )*\n-                _ => \"unknown lint\",\n-            })\n-        }\n-    }\n-}\n-\n-docs! {\n-    \"absurd_extreme_comparisons\",\n-    \"alloc_instead_of_core\",\n-    \"allow_attributes_without_reason\",\n-    \"almost_complete_letter_range\",\n-    \"almost_swapped\",\n-    \"approx_constant\",\n-    \"arithmetic_side_effects\",\n-    \"as_conversions\",\n-    \"as_ptr_cast_mut\",\n-    \"as_underscore\",\n-    \"assertions_on_constants\",\n-    \"assertions_on_result_states\",\n-    \"assign_op_pattern\",\n-    \"async_yields_async\",\n-    \"await_holding_invalid_type\",\n-    \"await_holding_lock\",\n-    \"await_holding_refcell_ref\",\n-    \"bad_bit_mask\",\n-    \"bind_instead_of_map\",\n-    \"blanket_clippy_restriction_lints\",\n-    \"blocks_in_if_conditions\",\n-    \"bool_assert_comparison\",\n-    \"bool_comparison\",\n-    \"bool_to_int_with_if\",\n-    \"borrow_as_ptr\",\n-    \"borrow_deref_ref\",\n-    \"borrow_interior_mutable_const\",\n-    \"borrowed_box\",\n-    \"box_collection\",\n-    \"box_default\",\n-    \"boxed_local\",\n-    \"branches_sharing_code\",\n-    \"builtin_type_shadow\",\n-    \"bytes_count_to_len\",\n-    \"bytes_nth\",\n-    \"cargo_common_metadata\",\n-    \"case_sensitive_file_extension_comparisons\",\n-    \"cast_abs_to_unsigned\",\n-    \"cast_enum_constructor\",\n-    \"cast_enum_truncation\",\n-    \"cast_lossless\",\n-    \"cast_nan_to_int\",\n-    \"cast_possible_truncation\",\n-    \"cast_possible_wrap\",\n-    \"cast_precision_loss\",\n-    \"cast_ptr_alignment\",\n-    \"cast_ref_to_mut\",\n-    \"cast_sign_loss\",\n-    \"cast_slice_different_sizes\",\n-    \"cast_slice_from_raw_parts\",\n-    \"char_lit_as_u8\",\n-    \"chars_last_cmp\",\n-    \"chars_next_cmp\",\n-    \"checked_conversions\",\n-    \"clone_double_ref\",\n-    \"clone_on_copy\",\n-    \"clone_on_ref_ptr\",\n-    \"cloned_instead_of_copied\",\n-    \"cmp_nan\",\n-    \"cmp_null\",\n-    \"cmp_owned\",\n-    \"cognitive_complexity\",\n-    \"collapsible_else_if\",\n-    \"collapsible_if\",\n-    \"collapsible_match\",\n-    \"collapsible_str_replace\",\n-    \"comparison_chain\",\n-    \"comparison_to_empty\",\n-    \"copy_iterator\",\n-    \"crate_in_macro_def\",\n-    \"create_dir\",\n-    \"crosspointer_transmute\",\n-    \"dbg_macro\",\n-    \"debug_assert_with_mut_call\",\n-    \"decimal_literal_representation\",\n-    \"declare_interior_mutable_const\",\n-    \"default_instead_of_iter_empty\",\n-    \"default_numeric_fallback\",\n-    \"default_trait_access\",\n-    \"default_union_representation\",\n-    \"deprecated_cfg_attr\",\n-    \"deprecated_semver\",\n-    \"deref_addrof\",\n-    \"deref_by_slicing\",\n-    \"derivable_impls\",\n-    \"derive_hash_xor_eq\",\n-    \"derive_ord_xor_partial_ord\",\n-    \"derive_partial_eq_without_eq\",\n-    \"disallowed_macros\",\n-    \"disallowed_methods\",\n-    \"disallowed_names\",\n-    \"disallowed_script_idents\",\n-    \"disallowed_types\",\n-    \"diverging_sub_expression\",\n-    \"doc_link_with_quotes\",\n-    \"doc_markdown\",\n-    \"double_comparisons\",\n-    \"double_must_use\",\n-    \"double_neg\",\n-    \"double_parens\",\n-    \"drop_copy\",\n-    \"drop_non_drop\",\n-    \"drop_ref\",\n-    \"duplicate_mod\",\n-    \"duplicate_underscore_argument\",\n-    \"duration_subsec\",\n-    \"else_if_without_else\",\n-    \"empty_drop\",\n-    \"empty_enum\",\n-    \"empty_line_after_outer_attr\",\n-    \"empty_loop\",\n-    \"empty_structs_with_brackets\",\n-    \"enum_clike_unportable_variant\",\n-    \"enum_glob_use\",\n-    \"enum_variant_names\",\n-    \"eq_op\",\n-    \"equatable_if_let\",\n-    \"erasing_op\",\n-    \"err_expect\",\n-    \"excessive_precision\",\n-    \"exhaustive_enums\",\n-    \"exhaustive_structs\",\n-    \"exit\",\n-    \"expect_fun_call\",\n-    \"expect_used\",\n-    \"expl_impl_clone_on_copy\",\n-    \"explicit_auto_deref\",\n-    \"explicit_counter_loop\",\n-    \"explicit_deref_methods\",\n-    \"explicit_into_iter_loop\",\n-    \"explicit_iter_loop\",\n-    \"explicit_write\",\n-    \"extend_with_drain\",\n-    \"extra_unused_lifetimes\",\n-    \"fallible_impl_from\",\n-    \"field_reassign_with_default\",\n-    \"filetype_is_file\",\n-    \"filter_map_identity\",\n-    \"filter_map_next\",\n-    \"filter_next\",\n-    \"flat_map_identity\",\n-    \"flat_map_option\",\n-    \"float_arithmetic\",\n-    \"float_cmp\",\n-    \"float_cmp_const\",\n-    \"float_equality_without_abs\",\n-    \"fn_address_comparisons\",\n-    \"fn_params_excessive_bools\",\n-    \"fn_to_numeric_cast\",\n-    \"fn_to_numeric_cast_any\",\n-    \"fn_to_numeric_cast_with_truncation\",\n-    \"for_kv_map\",\n-    \"forget_copy\",\n-    \"forget_non_drop\",\n-    \"forget_ref\",\n-    \"format_in_format_args\",\n-    \"format_push_string\",\n-    \"from_iter_instead_of_collect\",\n-    \"from_over_into\",\n-    \"from_str_radix_10\",\n-    \"future_not_send\",\n-    \"get_first\",\n-    \"get_last_with_len\",\n-    \"get_unwrap\",\n-    \"identity_op\",\n-    \"if_let_mutex\",\n-    \"if_not_else\",\n-    \"if_same_then_else\",\n-    \"if_then_some_else_none\",\n-    \"ifs_same_cond\",\n-    \"implicit_clone\",\n-    \"implicit_hasher\",\n-    \"implicit_return\",\n-    \"implicit_saturating_add\",\n-    \"implicit_saturating_sub\",\n-    \"imprecise_flops\",\n-    \"inconsistent_digit_grouping\",\n-    \"inconsistent_struct_constructor\",\n-    \"index_refutable_slice\",\n-    \"indexing_slicing\",\n-    \"ineffective_bit_mask\",\n-    \"inefficient_to_string\",\n-    \"infallible_destructuring_match\",\n-    \"infinite_iter\",\n-    \"inherent_to_string\",\n-    \"inherent_to_string_shadow_display\",\n-    \"init_numbered_fields\",\n-    \"inline_always\",\n-    \"inline_asm_x86_att_syntax\",\n-    \"inline_asm_x86_intel_syntax\",\n-    \"inline_fn_without_body\",\n-    \"inspect_for_each\",\n-    \"int_plus_one\",\n-    \"integer_arithmetic\",\n-    \"integer_division\",\n-    \"into_iter_on_ref\",\n-    \"invalid_null_ptr_usage\",\n-    \"invalid_regex\",\n-    \"invalid_upcast_comparisons\",\n-    \"invalid_utf8_in_unchecked\",\n-    \"invisible_characters\",\n-    \"is_digit_ascii_radix\",\n-    \"items_after_statements\",\n-    \"iter_cloned_collect\",\n-    \"iter_count\",\n-    \"iter_kv_map\",\n-    \"iter_next_loop\",\n-    \"iter_next_slice\",\n-    \"iter_not_returning_iterator\",\n-    \"iter_nth\",\n-    \"iter_nth_zero\",\n-    \"iter_on_empty_collections\",\n-    \"iter_on_single_items\",\n-    \"iter_overeager_cloned\",\n-    \"iter_skip_next\",\n-    \"iter_with_drain\",\n-    \"iterator_step_by_zero\",\n-    \"just_underscores_and_digits\",\n-    \"large_const_arrays\",\n-    \"large_digit_groups\",\n-    \"large_enum_variant\",\n-    \"large_include_file\",\n-    \"large_stack_arrays\",\n-    \"large_types_passed_by_value\",\n-    \"len_without_is_empty\",\n-    \"len_zero\",\n-    \"let_and_return\",\n-    \"let_underscore_drop\",\n-    \"let_underscore_lock\",\n-    \"let_underscore_must_use\",\n-    \"let_unit_value\",\n-    \"linkedlist\",\n-    \"lossy_float_literal\",\n-    \"macro_use_imports\",\n-    \"main_recursion\",\n-    \"manual_assert\",\n-    \"manual_async_fn\",\n-    \"manual_bits\",\n-    \"manual_clamp\",\n-    \"manual_filter\",\n-    \"manual_filter_map\",\n-    \"manual_find\",\n-    \"manual_find_map\",\n-    \"manual_flatten\",\n-    \"manual_instant_elapsed\",\n-    \"manual_map\",\n-    \"manual_memcpy\",\n-    \"manual_non_exhaustive\",\n-    \"manual_ok_or\",\n-    \"manual_range_contains\",\n-    \"manual_rem_euclid\",\n-    \"manual_retain\",\n-    \"manual_saturating_arithmetic\",\n-    \"manual_split_once\",\n-    \"manual_str_repeat\",\n-    \"manual_string_new\",\n-    \"manual_strip\",\n-    \"manual_swap\",\n-    \"manual_unwrap_or\",\n-    \"many_single_char_names\",\n-    \"map_clone\",\n-    \"map_collect_result_unit\",\n-    \"map_entry\",\n-    \"map_err_ignore\",\n-    \"map_flatten\",\n-    \"map_identity\",\n-    \"map_unwrap_or\",\n-    \"match_as_ref\",\n-    \"match_bool\",\n-    \"match_like_matches_macro\",\n-    \"match_on_vec_items\",\n-    \"match_overlapping_arm\",\n-    \"match_ref_pats\",\n-    \"match_result_ok\",\n-    \"match_same_arms\",\n-    \"match_single_binding\",\n-    \"match_str_case_mismatch\",\n-    \"match_wild_err_arm\",\n-    \"match_wildcard_for_single_variants\",\n-    \"maybe_infinite_iter\",\n-    \"mem_forget\",\n-    \"mem_replace_option_with_none\",\n-    \"mem_replace_with_default\",\n-    \"mem_replace_with_uninit\",\n-    \"min_max\",\n-    \"mismatched_target_os\",\n-    \"mismatching_type_param_order\",\n-    \"misrefactored_assign_op\",\n-    \"missing_const_for_fn\",\n-    \"missing_docs_in_private_items\",\n-    \"missing_enforced_import_renames\",\n-    \"missing_errors_doc\",\n-    \"missing_inline_in_public_items\",\n-    \"missing_panics_doc\",\n-    \"missing_safety_doc\",\n-    \"missing_spin_loop\",\n-    \"missing_trait_methods\",\n-    \"mistyped_literal_suffixes\",\n-    \"mixed_case_hex_literals\",\n-    \"mixed_read_write_in_expression\",\n-    \"mod_module_files\",\n-    \"module_inception\",\n-    \"module_name_repetitions\",\n-    \"modulo_arithmetic\",\n-    \"modulo_one\",\n-    \"multi_assignments\",\n-    \"multiple_crate_versions\",\n-    \"multiple_inherent_impl\",\n-    \"must_use_candidate\",\n-    \"must_use_unit\",\n-    \"mut_from_ref\",\n-    \"mut_mut\",\n-    \"mut_mutex_lock\",\n-    \"mut_range_bound\",\n-    \"mutable_key_type\",\n-    \"mutex_atomic\",\n-    \"mutex_integer\",\n-    \"naive_bytecount\",\n-    \"needless_arbitrary_self_type\",\n-    \"needless_bitwise_bool\",\n-    \"needless_bool\",\n-    \"needless_borrow\",\n-    \"needless_borrowed_reference\",\n-    \"needless_collect\",\n-    \"needless_continue\",\n-    \"needless_doctest_main\",\n-    \"needless_for_each\",\n-    \"needless_late_init\",\n-    \"needless_lifetimes\",\n-    \"needless_match\",\n-    \"needless_option_as_deref\",\n-    \"needless_option_take\",\n-    \"needless_parens_on_range_literals\",\n-    \"needless_pass_by_value\",\n-    \"needless_question_mark\",\n-    \"needless_range_loop\",\n-    \"needless_return\",\n-    \"needless_splitn\",\n-    \"needless_update\",\n-    \"neg_cmp_op_on_partial_ord\",\n-    \"neg_multiply\",\n-    \"negative_feature_names\",\n-    \"never_loop\",\n-    \"new_ret_no_self\",\n-    \"new_without_default\",\n-    \"no_effect\",\n-    \"no_effect_replace\",\n-    \"no_effect_underscore_binding\",\n-    \"non_ascii_literal\",\n-    \"non_octal_unix_permissions\",\n-    \"non_send_fields_in_send_ty\",\n-    \"nonminimal_bool\",\n-    \"nonsensical_open_options\",\n-    \"nonstandard_macro_braces\",\n-    \"not_unsafe_ptr_arg_deref\",\n-    \"obfuscated_if_else\",\n-    \"octal_escapes\",\n-    \"ok_expect\",\n-    \"only_used_in_recursion\",\n-    \"op_ref\",\n-    \"option_as_ref_deref\",\n-    \"option_env_unwrap\",\n-    \"option_filter_map\",\n-    \"option_if_let_else\",\n-    \"option_map_or_none\",\n-    \"option_map_unit_fn\",\n-    \"option_option\",\n-    \"or_fun_call\",\n-    \"or_then_unwrap\",\n-    \"out_of_bounds_indexing\",\n-    \"overflow_check_conditional\",\n-    \"overly_complex_bool_expr\",\n-    \"panic\",\n-    \"panic_in_result_fn\",\n-    \"panicking_unwrap\",\n-    \"partial_pub_fields\",\n-    \"partialeq_ne_impl\",\n-    \"partialeq_to_none\",\n-    \"path_buf_push_overwrite\",\n-    \"pattern_type_mismatch\",\n-    \"possible_missing_comma\",\n-    \"precedence\",\n-    \"print_in_format_impl\",\n-    \"print_literal\",\n-    \"print_stderr\",\n-    \"print_stdout\",\n-    \"print_with_newline\",\n-    \"println_empty_string\",\n-    \"ptr_arg\",\n-    \"ptr_as_ptr\",\n-    \"ptr_eq\",\n-    \"ptr_offset_with_cast\",\n-    \"pub_use\",\n-    \"question_mark\",\n-    \"range_minus_one\",\n-    \"range_plus_one\",\n-    \"range_zip_with_len\",\n-    \"rc_buffer\",\n-    \"rc_clone_in_vec_init\",\n-    \"rc_mutex\",\n-    \"read_zero_byte_vec\",\n-    \"recursive_format_impl\",\n-    \"redundant_allocation\",\n-    \"redundant_clone\",\n-    \"redundant_closure\",\n-    \"redundant_closure_call\",\n-    \"redundant_closure_for_method_calls\",\n-    \"redundant_else\",\n-    \"redundant_feature_names\",\n-    \"redundant_field_names\",\n-    \"redundant_pattern\",\n-    \"redundant_pattern_matching\",\n-    \"redundant_pub_crate\",\n-    \"redundant_slicing\",\n-    \"redundant_static_lifetimes\",\n-    \"ref_binding_to_reference\",\n-    \"ref_option_ref\",\n-    \"repeat_once\",\n-    \"rest_pat_in_fully_bound_structs\",\n-    \"result_large_err\",\n-    \"result_map_or_into_option\",\n-    \"result_map_unit_fn\",\n-    \"result_unit_err\",\n-    \"return_self_not_must_use\",\n-    \"reversed_empty_ranges\",\n-    \"same_functions_in_if_condition\",\n-    \"same_item_push\",\n-    \"same_name_method\",\n-    \"search_is_some\",\n-    \"self_assignment\",\n-    \"self_named_constructors\",\n-    \"self_named_module_files\",\n-    \"semicolon_if_nothing_returned\",\n-    \"separated_literal_suffix\",\n-    \"serde_api_misuse\",\n-    \"shadow_reuse\",\n-    \"shadow_same\",\n-    \"shadow_unrelated\",\n-    \"short_circuit_statement\",\n-    \"should_implement_trait\",\n-    \"significant_drop_in_scrutinee\",\n-    \"similar_names\",\n-    \"single_char_add_str\",\n-    \"single_char_lifetime_names\",\n-    \"single_char_pattern\",\n-    \"single_component_path_imports\",\n-    \"single_element_loop\",\n-    \"single_match\",\n-    \"single_match_else\",\n-    \"size_of_in_element_count\",\n-    \"skip_while_next\",\n-    \"slow_vector_initialization\",\n-    \"stable_sort_primitive\",\n-    \"std_instead_of_alloc\",\n-    \"std_instead_of_core\",\n-    \"str_to_string\",\n-    \"string_add\",\n-    \"string_add_assign\",\n-    \"string_extend_chars\",\n-    \"string_from_utf8_as_bytes\",\n-    \"string_lit_as_bytes\",\n-    \"string_slice\",\n-    \"string_to_string\",\n-    \"strlen_on_c_strings\",\n-    \"struct_excessive_bools\",\n-    \"suboptimal_flops\",\n-    \"suspicious_arithmetic_impl\",\n-    \"suspicious_assignment_formatting\",\n-    \"suspicious_else_formatting\",\n-    \"suspicious_map\",\n-    \"suspicious_op_assign_impl\",\n-    \"suspicious_operation_groupings\",\n-    \"suspicious_splitn\",\n-    \"suspicious_to_owned\",\n-    \"suspicious_unary_op_formatting\",\n-    \"swap_ptr_to_ref\",\n-    \"tabs_in_doc_comments\",\n-    \"temporary_assignment\",\n-    \"to_digit_is_some\",\n-    \"to_string_in_format_args\",\n-    \"todo\",\n-    \"too_many_arguments\",\n-    \"too_many_lines\",\n-    \"toplevel_ref_arg\",\n-    \"trailing_empty_array\",\n-    \"trait_duplication_in_bounds\",\n-    \"transmute_bytes_to_str\",\n-    \"transmute_float_to_int\",\n-    \"transmute_int_to_bool\",\n-    \"transmute_int_to_char\",\n-    \"transmute_int_to_float\",\n-    \"transmute_num_to_bytes\",\n-    \"transmute_ptr_to_ptr\",\n-    \"transmute_ptr_to_ref\",\n-    \"transmute_undefined_repr\",\n-    \"transmutes_expressible_as_ptr_casts\",\n-    \"transmuting_null\",\n-    \"trim_split_whitespace\",\n-    \"trivial_regex\",\n-    \"trivially_copy_pass_by_ref\",\n-    \"try_err\",\n-    \"type_complexity\",\n-    \"type_repetition_in_bounds\",\n-    \"undocumented_unsafe_blocks\",\n-    \"undropped_manually_drops\",\n-    \"unicode_not_nfc\",\n-    \"unimplemented\",\n-    \"uninit_assumed_init\",\n-    \"uninit_vec\",\n-    \"uninlined_format_args\",\n-    \"unit_arg\",\n-    \"unit_cmp\",\n-    \"unit_hash\",\n-    \"unit_return_expecting_ord\",\n-    \"unnecessary_cast\",\n-    \"unnecessary_filter_map\",\n-    \"unnecessary_find_map\",\n-    \"unnecessary_fold\",\n-    \"unnecessary_join\",\n-    \"unnecessary_lazy_evaluations\",\n-    \"unnecessary_mut_passed\",\n-    \"unnecessary_operation\",\n-    \"unnecessary_owned_empty_strings\",\n-    \"unnecessary_self_imports\",\n-    \"unnecessary_sort_by\",\n-    \"unnecessary_to_owned\",\n-    \"unnecessary_unwrap\",\n-    \"unnecessary_wraps\",\n-    \"unneeded_field_pattern\",\n-    \"unneeded_wildcard_pattern\",\n-    \"unnested_or_patterns\",\n-    \"unreachable\",\n-    \"unreadable_literal\",\n-    \"unsafe_derive_deserialize\",\n-    \"unsafe_removed_from_name\",\n-    \"unseparated_literal_suffix\",\n-    \"unsound_collection_transmute\",\n-    \"unused_async\",\n-    \"unused_format_specs\",\n-    \"unused_io_amount\",\n-    \"unused_peekable\",\n-    \"unused_rounding\",\n-    \"unused_self\",\n-    \"unused_unit\",\n-    \"unusual_byte_groupings\",\n-    \"unwrap_in_result\",\n-    \"unwrap_or_else_default\",\n-    \"unwrap_used\",\n-    \"upper_case_acronyms\",\n-    \"use_debug\",\n-    \"use_self\",\n-    \"used_underscore_binding\",\n-    \"useless_asref\",\n-    \"useless_attribute\",\n-    \"useless_conversion\",\n-    \"useless_format\",\n-    \"useless_let_if_seq\",\n-    \"useless_transmute\",\n-    \"useless_vec\",\n-    \"vec_box\",\n-    \"vec_init_then_push\",\n-    \"vec_resize_to_zero\",\n-    \"verbose_bit_mask\",\n-    \"verbose_file_reads\",\n-    \"vtable_address_comparisons\",\n-    \"while_immutable_condition\",\n-    \"while_let_loop\",\n-    \"while_let_on_iterator\",\n-    \"wildcard_dependencies\",\n-    \"wildcard_enum_match_arm\",\n-    \"wildcard_imports\",\n-    \"wildcard_in_or_patterns\",\n-    \"write_literal\",\n-    \"write_with_newline\",\n-    \"writeln_empty_string\",\n-    \"wrong_self_convention\",\n-    \"wrong_transmute\",\n-    \"zero_divided_by_zero\",\n-    \"zero_prefixed_literal\",\n-    \"zero_ptr\",\n-    \"zero_sized_map_values\",\n-    \"zst_offset\",\n-\n-}"}, {"sha": "590bee28aa2376be4492aa4c9a53e918ec63805b", "filename": "src/tools/clippy/src/docs/absurd_extreme_comparisons.txt", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fabsurd_extreme_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fabsurd_extreme_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fabsurd_extreme_comparisons.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,25 +0,0 @@\n-### What it does\n-Checks for comparisons where one side of the relation is\n-either the minimum or maximum value for its type and warns if it involves a\n-case that is always true or always false. Only integer and boolean types are\n-checked.\n-\n-### Why is this bad?\n-An expression like `min <= x` may misleadingly imply\n-that it is possible for `x` to be less than the minimum. Expressions like\n-`max < x` are probably mistakes.\n-\n-### Known problems\n-For `usize` the size of the current compile target will\n-be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n-a comparison to detect target pointer width will trigger this lint. One can\n-use `mem::sizeof` and compare its value or conditional compilation\n-attributes\n-like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n-\n-### Example\n-```\n-let vec: Vec<isize> = Vec::new();\n-if vec.len() <= 0 {}\n-if 100 > i32::MAX {}\n-```\n\\ No newline at end of file"}, {"sha": "488a36e9276c24d1bd1ded86983a6c423b39c9cb", "filename": "src/tools/clippy/src/docs/alloc_instead_of_core.txt", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falloc_instead_of_core.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falloc_instead_of_core.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falloc_instead_of_core.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,18 +0,0 @@\n-### What it does\n-\n-Finds items imported through `alloc` when available through `core`.\n-\n-### Why is this bad?\n-\n-Crates which have `no_std` compatibility and may optionally require alloc may wish to ensure types are\n-imported from core to ensure disabling `alloc` does not cause the crate to fail to compile. This lint\n-is also useful for crates migrating to become `no_std` compatible.\n-\n-### Example\n-```\n-use alloc::slice::from_ref;\n-```\n-Use instead:\n-```\n-use core::slice::from_ref;\n-```\n\\ No newline at end of file"}, {"sha": "fcc4f49b08b37be204fdc034de517c8ba7f1f747", "filename": "src/tools/clippy/src/docs/allow_attributes_without_reason.txt", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fallow_attributes_without_reason.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fallow_attributes_without_reason.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fallow_attributes_without_reason.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,22 +0,0 @@\n-### What it does\n-Checks for attributes that allow lints without a reason.\n-\n-(This requires the `lint_reasons` feature)\n-\n-### Why is this bad?\n-Allowing a lint should always have a reason. This reason should be documented to\n-ensure that others understand the reasoning\n-\n-### Example\n-```\n-#![feature(lint_reasons)]\n-\n-#![allow(clippy::some_lint)]\n-```\n-\n-Use instead:\n-```\n-#![feature(lint_reasons)]\n-\n-#![allow(clippy::some_lint, reason = \"False positive rust-lang/rust-clippy#1002020\")]\n-```\n\\ No newline at end of file"}, {"sha": "01cbaf9eae259e26155ea29a65fd71addcbd1825", "filename": "src/tools/clippy/src/docs/almost_complete_letter_range.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falmost_complete_letter_range.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falmost_complete_letter_range.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falmost_complete_letter_range.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Checks for ranges which almost include the entire range of letters from 'a' to 'z', but\n-don't because they're a half open range.\n-\n-### Why is this bad?\n-This (`'a'..'z'`) is almost certainly a typo meant to include all letters.\n-\n-### Example\n-```\n-let _ = 'a'..'z';\n-```\n-Use instead:\n-```\n-let _ = 'a'..='z';\n-```\n\\ No newline at end of file"}, {"sha": "cd10a8d5409b10afab8778ac88d91e4e5bbdbbfb", "filename": "src/tools/clippy/src/docs/almost_swapped.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falmost_swapped.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falmost_swapped.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Falmost_swapped.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Checks for `foo = bar; bar = foo` sequences.\n-\n-### Why is this bad?\n-This looks like a failed attempt to swap.\n-\n-### Example\n-```\n-a = b;\n-b = a;\n-```\n-If swapping is intended, use `swap()` instead:\n-```\n-std::mem::swap(&mut a, &mut b);\n-```\n\\ No newline at end of file"}, {"sha": "393fa4b5ef7ecd6734a6a78c64694646c45505be", "filename": "src/tools/clippy/src/docs/approx_constant.txt", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fapprox_constant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fapprox_constant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fapprox_constant.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,24 +0,0 @@\n-### What it does\n-Checks for floating point literals that approximate\n-constants which are defined in\n-[`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\n-or\n-[`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\n-respectively, suggesting to use the predefined constant.\n-\n-### Why is this bad?\n-Usually, the definition in the standard library is more\n-precise than what people come up with. If you find that your definition is\n-actually more precise, please [file a Rust\n-issue](https://github.com/rust-lang/rust/issues).\n-\n-### Example\n-```\n-let x = 3.14;\n-let y = 1_f64 / x;\n-```\n-Use instead:\n-```\n-let x = std::f32::consts::PI;\n-let y = std::f64::consts::FRAC_1_PI;\n-```\n\\ No newline at end of file"}, {"sha": "4ae8bce88ad5ff7a5bda7c789ad86d8c770f607f", "filename": "src/tools/clippy/src/docs/arithmetic_side_effects.txt", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Farithmetic_side_effects.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Farithmetic_side_effects.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Farithmetic_side_effects.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,33 +0,0 @@\n-### What it does\n-Checks any kind of arithmetic operation of any type.\n-\n-Operators like `+`, `-`, `*` or `<<` are usually capable of overflowing according to the [Rust\n-Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n-or can panic (`/`, `%`).\n-\n-Known safe built-in types like `Wrapping` or `Saturating`, floats, operations in constant\n-environments, allowed types and non-constant operations that won't overflow are ignored.\n-\n-### Why is this bad?\n-For integers, overflow will trigger a panic in debug builds or wrap the result in\n-release mode; division by zero will cause a panic in either mode. As a result, it is\n-desirable to explicitly call checked, wrapping or saturating arithmetic methods.\n-\n-#### Example\n-```\n-// `n` can be any number, including `i32::MAX`.\n-fn foo(n: i32) -> i32 {\n-  n + 1\n-}\n-```\n-\n-Third-party types can also overflow or present unwanted side-effects.\n-\n-#### Example\n-```\n-use rust_decimal::Decimal;\n-let _n = Decimal::MAX + Decimal::MAX;\n-```\n-\n-### Allowed types\n-Custom allowed types can be specified through the \"arithmetic-side-effects-allowed\" filter.\n\\ No newline at end of file"}, {"sha": "4af479bd8111cd213e98fc7a7b14a172a9714b87", "filename": "src/tools/clippy/src/docs/as_conversions.txt", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_conversions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_conversions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_conversions.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,32 +0,0 @@\n-### What it does\n-Checks for usage of `as` conversions.\n-\n-Note that this lint is specialized in linting *every single* use of `as`\n-regardless of whether good alternatives exist or not.\n-If you want more precise lints for `as`, please consider using these separate lints:\n-`unnecessary_cast`, `cast_lossless/cast_possible_truncation/cast_possible_wrap/cast_precision_loss/cast_sign_loss`,\n-`fn_to_numeric_cast(_with_truncation)`, `char_lit_as_u8`, `ref_to_mut` and `ptr_as_ptr`.\n-There is a good explanation the reason why this lint should work in this way and how it is useful\n-[in this issue](https://github.com/rust-lang/rust-clippy/issues/5122).\n-\n-### Why is this bad?\n-`as` conversions will perform many kinds of\n-conversions, including silently lossy conversions and dangerous coercions.\n-There are cases when it makes sense to use `as`, so the lint is\n-Allow by default.\n-\n-### Example\n-```\n-let a: u32;\n-...\n-f(a as u16);\n-```\n-\n-Use instead:\n-```\n-f(a.try_into()?);\n-\n-// or\n-\n-f(a.try_into().expect(\"Unexpected u16 overflow in f\"));\n-```\n\\ No newline at end of file"}, {"sha": "228dde996bb2f41f5985bc3ebe984fcc25031af4", "filename": "src/tools/clippy/src/docs/as_ptr_cast_mut.txt", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_ptr_cast_mut.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_ptr_cast_mut.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_ptr_cast_mut.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,19 +0,0 @@\n-### What it does\n-Checks for the result of a `&self`-taking `as_ptr` being cast to a mutable pointer\n-\n-### Why is this bad?\n-Since `as_ptr` takes a `&self`, the pointer won't have write permissions unless interior\n-mutability is used, making it unlikely that having it as a mutable pointer is correct.\n-\n-### Example\n-```\n-let string = String::with_capacity(1);\n-let ptr = string.as_ptr() as *mut u8;\n-unsafe { ptr.write(4) }; // UNDEFINED BEHAVIOUR\n-```\n-Use instead:\n-```\n-let mut string = String::with_capacity(1);\n-let ptr = string.as_mut_ptr();\n-unsafe { ptr.write(4) };\n-```\n\\ No newline at end of file"}, {"sha": "2d9b0c358936bc7c04d4c708da7a0bf72641cecf", "filename": "src/tools/clippy/src/docs/as_underscore.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_underscore.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_underscore.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fas_underscore.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Check for the usage of `as _` conversion using inferred type.\n-\n-### Why is this bad?\n-The conversion might include lossy conversion and dangerous cast that might go\n-undetected due to the type being inferred.\n-\n-The lint is allowed by default as using `_` is less wordy than always specifying the type.\n-\n-### Example\n-```\n-fn foo(n: usize) {}\n-let n: u16 = 256;\n-foo(n as _);\n-```\n-Use instead:\n-```\n-fn foo(n: usize) {}\n-let n: u16 = 256;\n-foo(n as usize);\n-```\n\\ No newline at end of file"}, {"sha": "270c1e3b639d96fe496986e003eb62b3dae41f0c", "filename": "src/tools/clippy/src/docs/assertions_on_constants.txt", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassertions_on_constants.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassertions_on_constants.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassertions_on_constants.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,14 +0,0 @@\n-### What it does\n-Checks for `assert!(true)` and `assert!(false)` calls.\n-\n-### Why is this bad?\n-Will be optimized out by the compiler or should probably be replaced by a\n-`panic!()` or `unreachable!()`\n-\n-### Example\n-```\n-assert!(false)\n-assert!(true)\n-const B: bool = false;\n-assert!(B)\n-```\n\\ No newline at end of file"}, {"sha": "0889084fd3ad61447b36aaf81a7fde499afd3577", "filename": "src/tools/clippy/src/docs/assertions_on_result_states.txt", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassertions_on_result_states.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassertions_on_result_states.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassertions_on_result_states.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,14 +0,0 @@\n-### What it does\n-Checks for `assert!(r.is_ok())` or `assert!(r.is_err())` calls.\n-\n-### Why is this bad?\n-An assertion failure cannot output an useful message of the error.\n-\n-### Known problems\n-The suggested replacement decreases the readability of code and log output.\n-\n-### Example\n-```\n-assert!(r.is_ok());\n-assert!(r.is_err());\n-```\n\\ No newline at end of file"}, {"sha": "f355c0cc18d37d69bf4563727d65ce09c28f5a4c", "filename": "src/tools/clippy/src/docs/assign_op_pattern.txt", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassign_op_pattern.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassign_op_pattern.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fassign_op_pattern.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,28 +0,0 @@\n-### What it does\n-Checks for `a = a op b` or `a = b commutative_op a`\n-patterns.\n-\n-### Why is this bad?\n-These can be written as the shorter `a op= b`.\n-\n-### Known problems\n-While forbidden by the spec, `OpAssign` traits may have\n-implementations that differ from the regular `Op` impl.\n-\n-### Example\n-```\n-let mut a = 5;\n-let b = 0;\n-// ...\n-\n-a = a + b;\n-```\n-\n-Use instead:\n-```\n-let mut a = 5;\n-let b = 0;\n-// ...\n-\n-a += b;\n-```\n\\ No newline at end of file"}, {"sha": "a40de6d2e473642505f16e46054228bf658eb885", "filename": "src/tools/clippy/src/docs/async_yields_async.txt", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fasync_yields_async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fasync_yields_async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fasync_yields_async.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,28 +0,0 @@\n-### What it does\n-Checks for async blocks that yield values of types\n-that can themselves be awaited.\n-\n-### Why is this bad?\n-An await is likely missing.\n-\n-### Example\n-```\n-async fn foo() {}\n-\n-fn bar() {\n-  let x = async {\n-    foo()\n-  };\n-}\n-```\n-\n-Use instead:\n-```\n-async fn foo() {}\n-\n-fn bar() {\n-  let x = async {\n-    foo().await\n-  };\n-}\n-```\n\\ No newline at end of file"}, {"sha": "e9c768772ff6b8ec4485802bb64d4fe9db265598", "filename": "src/tools/clippy/src/docs/await_holding_invalid_type.txt", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_invalid_type.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_invalid_type.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_invalid_type.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,29 +0,0 @@\n-### What it does\n-Allows users to configure types which should not be held across `await`\n-suspension points.\n-\n-### Why is this bad?\n-There are some types which are perfectly \"safe\" to be used concurrently\n-from a memory access perspective but will cause bugs at runtime if they\n-are held in such a way.\n-\n-### Example\n-\n-```\n-await-holding-invalid-types = [\n-  # You can specify a type name\n-  \"CustomLockType\",\n-  # You can (optionally) specify a reason\n-  { path = \"OtherCustomLockType\", reason = \"Relies on a thread local\" }\n-]\n-```\n-\n-```\n-struct CustomLockType;\n-struct OtherCustomLockType;\n-async fn foo() {\n-  let _x = CustomLockType;\n-  let _y = OtherCustomLockType;\n-  baz().await; // Lint violation\n-}\n-```\n\\ No newline at end of file"}, {"sha": "0f450a11160ccca10c011e7fef781770c421a372", "filename": "src/tools/clippy/src/docs/await_holding_lock.txt", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_lock.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_lock.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_lock.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,51 +0,0 @@\n-### What it does\n-Checks for calls to await while holding a non-async-aware MutexGuard.\n-\n-### Why is this bad?\n-The Mutex types found in std::sync and parking_lot\n-are not designed to operate in an async context across await points.\n-\n-There are two potential solutions. One is to use an async-aware Mutex\n-type. Many asynchronous foundation crates provide such a Mutex type. The\n-other solution is to ensure the mutex is unlocked before calling await,\n-either by introducing a scope or an explicit call to Drop::drop.\n-\n-### Known problems\n-Will report false positive for explicitly dropped guards\n-([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)). A workaround for this is\n-to wrap the `.lock()` call in a block instead of explicitly dropping the guard.\n-\n-### Example\n-```\n-async fn foo(x: &Mutex<u32>) {\n-  let mut guard = x.lock().unwrap();\n-  *guard += 1;\n-  baz().await;\n-}\n-\n-async fn bar(x: &Mutex<u32>) {\n-  let mut guard = x.lock().unwrap();\n-  *guard += 1;\n-  drop(guard); // explicit drop\n-  baz().await;\n-}\n-```\n-\n-Use instead:\n-```\n-async fn foo(x: &Mutex<u32>) {\n-  {\n-    let mut guard = x.lock().unwrap();\n-    *guard += 1;\n-  }\n-  baz().await;\n-}\n-\n-async fn bar(x: &Mutex<u32>) {\n-  {\n-    let mut guard = x.lock().unwrap();\n-    *guard += 1;\n-  } // guard dropped here at end of scope\n-  baz().await;\n-}\n-```\n\\ No newline at end of file"}, {"sha": "226a261b9cc5208dcf26ea386ac9898f77685fdb", "filename": "src/tools/clippy/src/docs/await_holding_refcell_ref.txt", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_refcell_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_refcell_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fawait_holding_refcell_ref.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,47 +0,0 @@\n-### What it does\n-Checks for calls to await while holding a `RefCell` `Ref` or `RefMut`.\n-\n-### Why is this bad?\n-`RefCell` refs only check for exclusive mutable access\n-at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n-risks panics from a mutable ref shared while other refs are outstanding.\n-\n-### Known problems\n-Will report false positive for explicitly dropped refs\n-([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)). A workaround for this is\n-to wrap the `.borrow[_mut]()` call in a block instead of explicitly dropping the ref.\n-\n-### Example\n-```\n-async fn foo(x: &RefCell<u32>) {\n-  let mut y = x.borrow_mut();\n-  *y += 1;\n-  baz().await;\n-}\n-\n-async fn bar(x: &RefCell<u32>) {\n-  let mut y = x.borrow_mut();\n-  *y += 1;\n-  drop(y); // explicit drop\n-  baz().await;\n-}\n-```\n-\n-Use instead:\n-```\n-async fn foo(x: &RefCell<u32>) {\n-  {\n-     let mut y = x.borrow_mut();\n-     *y += 1;\n-  }\n-  baz().await;\n-}\n-\n-async fn bar(x: &RefCell<u32>) {\n-  {\n-    let mut y = x.borrow_mut();\n-    *y += 1;\n-  } // y dropped here at end of scope\n-  baz().await;\n-}\n-```\n\\ No newline at end of file"}, {"sha": "d40024ee56209f060cf84cb763ac9aa8911a1f7e", "filename": "src/tools/clippy/src/docs/bad_bit_mask.txt", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbad_bit_mask.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbad_bit_mask.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbad_bit_mask.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,30 +0,0 @@\n-### What it does\n-Checks for incompatible bit masks in comparisons.\n-\n-The formula for detecting if an expression of the type `_ <bit_op> m\n-<cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n-{`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\n-table:\n-\n-|Comparison  |Bit Op|Example      |is always|Formula               |\n-|------------|------|-------------|---------|----------------------|\n-|`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n-|`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n-|`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n-|`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n-|`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n-|`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |\n-\n-### Why is this bad?\n-If the bits that the comparison cares about are always\n-set to zero or one by the bit mask, the comparison is constant `true` or\n-`false` (depending on mask, compared value, and operators).\n-\n-So the code is actively misleading, and the only reason someone would write\n-this intentionally is to win an underhanded Rust contest or create a\n-test-case for this lint.\n-\n-### Example\n-```\n-if (x & 1 == 2) { }\n-```\n\\ No newline at end of file"}, {"sha": "148575803d389de69b51e7e832d713d792c957df", "filename": "src/tools/clippy/src/docs/bind_instead_of_map.txt", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbind_instead_of_map.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbind_instead_of_map.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbind_instead_of_map.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,22 +0,0 @@\n-### What it does\n-Checks for usage of `_.and_then(|x| Some(y))`, `_.and_then(|x| Ok(y))` or\n-`_.or_else(|x| Err(y))`.\n-\n-### Why is this bad?\n-Readability, this can be written more concisely as\n-`_.map(|x| y)` or `_.map_err(|x| y)`.\n-\n-### Example\n-```\n-let _ = opt().and_then(|s| Some(s.len()));\n-let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });\n-let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });\n-```\n-\n-The correct use would be:\n-\n-```\n-let _ = opt().map(|s| s.len());\n-let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\n-let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n-```\n\\ No newline at end of file"}, {"sha": "28a4ebf7169bfa744c691d707c06f0cbce55bfaf", "filename": "src/tools/clippy/src/docs/blanket_clippy_restriction_lints.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fblanket_clippy_restriction_lints.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fblanket_clippy_restriction_lints.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fblanket_clippy_restriction_lints.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.\n-\n-### Why is this bad?\n-Restriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\n-These lints should only be enabled on a lint-by-lint basis and with careful consideration.\n-\n-### Example\n-```\n-#![deny(clippy::restriction)]\n-```\n-\n-Use instead:\n-```\n-#![deny(clippy::as_conversions)]\n-```\n\\ No newline at end of file"}, {"sha": "3afa14853fd216139e4ff8d891fcfab8b57e1eaf", "filename": "src/tools/clippy/src/docs/blocks_in_if_conditions.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fblocks_in_if_conditions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fblocks_in_if_conditions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fblocks_in_if_conditions.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Checks for `if` conditions that use blocks containing an\n-expression, statements or conditions that use closures with blocks.\n-\n-### Why is this bad?\n-Style, using blocks in the condition makes it hard to read.\n-\n-### Examples\n-```\n-if { true } { /* ... */ }\n-\n-if { let x = somefunc(); x } { /* ... */ }\n-```\n-\n-Use instead:\n-```\n-if true { /* ... */ }\n-\n-let res = { let x = somefunc(); x };\n-if res { /* ... */ }\n-```\n\\ No newline at end of file"}, {"sha": "df7ca00cc2ba497488c8e5b8ffcb2696e6eee7bb", "filename": "src/tools/clippy/src/docs/bool_assert_comparison.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_assert_comparison.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_assert_comparison.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_assert_comparison.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-This lint warns about boolean comparisons in assert-like macros.\n-\n-### Why is this bad?\n-It is shorter to use the equivalent.\n-\n-### Example\n-```\n-assert_eq!(\"a\".is_empty(), false);\n-assert_ne!(\"a\".is_empty(), true);\n-```\n-\n-Use instead:\n-```\n-assert!(!\"a\".is_empty());\n-```\n\\ No newline at end of file"}, {"sha": "0996f60cec44ca3dc32c65c5810e743d146a3129", "filename": "src/tools/clippy/src/docs/bool_comparison.txt", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_comparison.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_comparison.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_comparison.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,18 +0,0 @@\n-### What it does\n-Checks for expressions of the form `x == true`,\n-`x != true` and order comparisons such as `x < true` (or vice versa) and\n-suggest using the variable directly.\n-\n-### Why is this bad?\n-Unnecessary code.\n-\n-### Example\n-```\n-if x == true {}\n-if y == false {}\n-```\n-use `x` directly:\n-```\n-if x {}\n-if !y {}\n-```\n\\ No newline at end of file"}, {"sha": "63535b454c9f12b961a6f1e0ed3de83335f80bb0", "filename": "src/tools/clippy/src/docs/bool_to_int_with_if.txt", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_to_int_with_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_to_int_with_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbool_to_int_with_if.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,26 +0,0 @@\n-### What it does\n-Instead of using an if statement to convert a bool to an int,\n-this lint suggests using a `from()` function or an `as` coercion.\n-\n-### Why is this bad?\n-Coercion or `from()` is idiomatic way to convert bool to a number.\n-Both methods are guaranteed to return 1 for true, and 0 for false.\n-\n-See https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E\n-\n-### Example\n-```\n-if condition {\n-    1_i64\n-} else {\n-    0\n-};\n-```\n-Use instead:\n-```\n-i64::from(condition);\n-```\n-or\n-```\n-condition as i64;\n-```\n\\ No newline at end of file"}, {"sha": "0be865abd578095f3ec4c54651d234eb40d382ae", "filename": "src/tools/clippy/src/docs/borrow_as_ptr.txt", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_as_ptr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_as_ptr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_as_ptr.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,26 +0,0 @@\n-### What it does\n-Checks for the usage of `&expr as *const T` or\n-`&mut expr as *mut T`, and suggest using `ptr::addr_of` or\n-`ptr::addr_of_mut` instead.\n-\n-### Why is this bad?\n-This would improve readability and avoid creating a reference\n-that points to an uninitialized value or unaligned place.\n-Read the `ptr::addr_of` docs for more information.\n-\n-### Example\n-```\n-let val = 1;\n-let p = &val as *const i32;\n-\n-let mut val_mut = 1;\n-let p_mut = &mut val_mut as *mut i32;\n-```\n-Use instead:\n-```\n-let val = 1;\n-let p = std::ptr::addr_of!(val);\n-\n-let mut val_mut = 1;\n-let p_mut = std::ptr::addr_of_mut!(val_mut);\n-```\n\\ No newline at end of file"}, {"sha": "352480d3f26a723cab9c783a631cab10c5f91e65", "filename": "src/tools/clippy/src/docs/borrow_deref_ref.txt", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_deref_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_deref_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_deref_ref.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,27 +0,0 @@\n-### What it does\n-Checks for `&*(&T)`.\n-\n-### Why is this bad?\n-Dereferencing and then borrowing a reference value has no effect in most cases.\n-\n-### Known problems\n-False negative on such code:\n-```\n-let x = &12;\n-let addr_x = &x as *const _ as usize;\n-let addr_y = &&*x as *const _ as usize; // assert ok now, and lint triggered.\n-                                        // But if we fix it, assert will fail.\n-assert_ne!(addr_x, addr_y);\n-```\n-\n-### Example\n-```\n-let s = &String::new();\n-\n-let a: &String = &* s;\n-```\n-\n-Use instead:\n-```\n-let a: &String = s;\n-```\n\\ No newline at end of file"}, {"sha": "e55b6a77e6667aa7679e1e35c5b033f24be3b1a1", "filename": "src/tools/clippy/src/docs/borrow_interior_mutable_const.txt", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_interior_mutable_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_interior_mutable_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrow_interior_mutable_const.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,40 +0,0 @@\n-### What it does\n-Checks if `const` items which is interior mutable (e.g.,\n-contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.) has been borrowed directly.\n-\n-### Why is this bad?\n-Consts are copied everywhere they are referenced, i.e.,\n-every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n-or `AtomicXxxx` will be created, which defeats the whole purpose of using\n-these types in the first place.\n-\n-The `const` value should be stored inside a `static` item.\n-\n-### Known problems\n-When an enum has variants with interior mutability, use of its non\n-interior mutable variants can generate false positives. See issue\n-[#3962](https://github.com/rust-lang/rust-clippy/issues/3962)\n-\n-Types that have underlying or potential interior mutability trigger the lint whether\n-the interior mutable field is used or not. See issues\n-[#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n-[#3825](https://github.com/rust-lang/rust-clippy/issues/3825)\n-\n-### Example\n-```\n-use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n-\n-CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n-assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n-```\n-\n-Use instead:\n-```\n-use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n-\n-static STATIC_ATOM: AtomicUsize = CONST_ATOM;\n-STATIC_ATOM.store(9, SeqCst);\n-assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n-```\n\\ No newline at end of file"}, {"sha": "d7089be662a581bd9cf9718b2be607eb172d259f", "filename": "src/tools/clippy/src/docs/borrowed_box.txt", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrowed_box.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrowed_box.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fborrowed_box.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,19 +0,0 @@\n-### What it does\n-Checks for use of `&Box<T>` anywhere in the code.\n-Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n-\n-### Why is this bad?\n-A `&Box<T>` parameter requires the function caller to box `T` first before passing it to a function.\n-Using `&T` defines a concrete type for the parameter and generalizes the function, this would also\n-auto-deref to `&T` at the function call site if passed a `&Box<T>`.\n-\n-### Example\n-```\n-fn foo(bar: &Box<T>) { ... }\n-```\n-\n-Better:\n-\n-```\n-fn foo(bar: &T) { ... }\n-```\n\\ No newline at end of file"}, {"sha": "053f24c46281d397f8a1fbbe661a1cfdd1037a3e", "filename": "src/tools/clippy/src/docs/box_collection.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbox_collection.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbox_collection.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbox_collection.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-Checks for use of `Box<T>` where T is a collection such as Vec anywhere in the code.\n-Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n-\n-### Why is this bad?\n-Collections already keeps their contents in a separate area on\n-the heap. So if you `Box` them, you just add another level of indirection\n-without any benefit whatsoever.\n-\n-### Example\n-```\n-struct X {\n-    values: Box<Vec<Foo>>,\n-}\n-```\n-\n-Better:\n-\n-```\n-struct X {\n-    values: Vec<Foo>,\n-}\n-```\n\\ No newline at end of file"}, {"sha": "1c670c7733377f04f3dcaefdd4158b7ff59332f2", "filename": "src/tools/clippy/src/docs/box_default.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbox_default.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbox_default.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbox_default.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,17 +0,0 @@\n-### What it does\n-checks for `Box::new(T::default())`, which is better written as\n-`Box::<T>::default()`.\n-\n-### Why is this bad?\n-First, it's more complex, involving two calls instead of one.\n-Second, `Box::default()` can be faster\n-[in certain cases](https://nnethercote.github.io/perf-book/standard-library-types.html#box).\n-\n-### Example\n-```\n-let x: Box<String> = Box::new(Default::default());\n-```\n-Use instead:\n-```\n-let x: Box<String> = Box::default();\n-```\n\\ No newline at end of file"}, {"sha": "8b1febf1455fdc359e520db3c9f95f5c14bdb282", "filename": "src/tools/clippy/src/docs/boxed_local.txt", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fboxed_local.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fboxed_local.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fboxed_local.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,18 +0,0 @@\n-### What it does\n-Checks for usage of `Box<T>` where an unboxed `T` would\n-work fine.\n-\n-### Why is this bad?\n-This is an unnecessary allocation, and bad for\n-performance. It is only necessary to allocate if you wish to move the box\n-into something.\n-\n-### Example\n-```\n-fn foo(x: Box<u32>) {}\n-```\n-\n-Use instead:\n-```\n-fn foo(x: u32) {}\n-```\n\\ No newline at end of file"}, {"sha": "79be6124798a254ec8db803b30ea7ba4e9676168", "filename": "src/tools/clippy/src/docs/branches_sharing_code.txt", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbranches_sharing_code.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbranches_sharing_code.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbranches_sharing_code.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,32 +0,0 @@\n-### What it does\n-Checks if the `if` and `else` block contain shared code that can be\n-moved out of the blocks.\n-\n-### Why is this bad?\n-Duplicate code is less maintainable.\n-\n-### Known problems\n-* The lint doesn't check if the moved expressions modify values that are being used in\n-  the if condition. The suggestion can in that case modify the behavior of the program.\n-  See [rust-clippy#7452](https://github.com/rust-lang/rust-clippy/issues/7452)\n-\n-### Example\n-```\n-let foo = if \u2026 {\n-    println!(\"Hello World\");\n-    13\n-} else {\n-    println!(\"Hello World\");\n-    42\n-};\n-```\n-\n-Use instead:\n-```\n-println!(\"Hello World\");\n-let foo = if \u2026 {\n-    13\n-} else {\n-    42\n-};\n-```\n\\ No newline at end of file"}, {"sha": "15b1c9df7baab0738c2bb707218955b11d4db60f", "filename": "src/tools/clippy/src/docs/builtin_type_shadow.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbuiltin_type_shadow.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbuiltin_type_shadow.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbuiltin_type_shadow.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Warns if a generic shadows a built-in type.\n-\n-### Why is this bad?\n-This gives surprising type errors.\n-\n-### Example\n-\n-```\n-impl<u32> Foo<u32> {\n-    fn impl_func(&self) -> u32 {\n-        42\n-    }\n-}\n-```\n\\ No newline at end of file"}, {"sha": "ca7bf9a38da8e25262eb0b4f761bcb622a3db13d", "filename": "src/tools/clippy/src/docs/bytes_count_to_len.txt", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbytes_count_to_len.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbytes_count_to_len.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbytes_count_to_len.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,18 +0,0 @@\n-### What it does\n-It checks for `str::bytes().count()` and suggests replacing it with\n-`str::len()`.\n-\n-### Why is this bad?\n-`str::bytes().count()` is longer and may not be as performant as using\n-`str::len()`.\n-\n-### Example\n-```\n-\"hello\".bytes().count();\n-String::from(\"hello\").bytes().count();\n-```\n-Use instead:\n-```\n-\"hello\".len();\n-String::from(\"hello\").len();\n-```\n\\ No newline at end of file"}, {"sha": "260de343353d8d3c1807cf47e79d5dbfad8640cd", "filename": "src/tools/clippy/src/docs/bytes_nth.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbytes_nth.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbytes_nth.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fbytes_nth.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for the use of `.bytes().nth()`.\n-\n-### Why is this bad?\n-`.as_bytes().get()` is more efficient and more\n-readable.\n-\n-### Example\n-```\n-\"Hello\".bytes().nth(3);\n-```\n-\n-Use instead:\n-```\n-\"Hello\".as_bytes().get(3);\n-```\n\\ No newline at end of file"}, {"sha": "1998647a92740b7ad0f99d6c2d42cc5424c4f9d3", "filename": "src/tools/clippy/src/docs/cargo_common_metadata.txt", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcargo_common_metadata.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcargo_common_metadata.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcargo_common_metadata.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,33 +0,0 @@\n-### What it does\n-Checks to see if all common metadata is defined in\n-`Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n-\n-### Why is this bad?\n-It will be more difficult for users to discover the\n-purpose of the crate, and key information related to it.\n-\n-### Example\n-```\n-[package]\n-name = \"clippy\"\n-version = \"0.0.212\"\n-repository = \"https://github.com/rust-lang/rust-clippy\"\n-readme = \"README.md\"\n-license = \"MIT OR Apache-2.0\"\n-keywords = [\"clippy\", \"lint\", \"plugin\"]\n-categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n-```\n-\n-Should include a description field like:\n-\n-```\n-[package]\n-name = \"clippy\"\n-version = \"0.0.212\"\n-description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n-repository = \"https://github.com/rust-lang/rust-clippy\"\n-readme = \"README.md\"\n-license = \"MIT OR Apache-2.0\"\n-keywords = [\"clippy\", \"lint\", \"plugin\"]\n-categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n-```\n\\ No newline at end of file"}, {"sha": "8e6e18ed4e23a94da0e12c6a38c3064871fcc723", "filename": "src/tools/clippy/src/docs/case_sensitive_file_extension_comparisons.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcase_sensitive_file_extension_comparisons.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Checks for calls to `ends_with` with possible file extensions\n-and suggests to use a case-insensitive approach instead.\n-\n-### Why is this bad?\n-`ends_with` is case-sensitive and may not detect files with a valid extension.\n-\n-### Example\n-```\n-fn is_rust_file(filename: &str) -> bool {\n-    filename.ends_with(\".rs\")\n-}\n-```\n-Use instead:\n-```\n-fn is_rust_file(filename: &str) -> bool {\n-    let filename = std::path::Path::new(filename);\n-    filename.extension()\n-        .map_or(false, |ext| ext.eq_ignore_ascii_case(\"rs\"))\n-}\n-```\n\\ No newline at end of file"}, {"sha": "c5d8ee034ce596d89a8ce62ae83d5962d7f892dc", "filename": "src/tools/clippy/src/docs/cast_abs_to_unsigned.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_abs_to_unsigned.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_abs_to_unsigned.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_abs_to_unsigned.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for uses of the `abs()` method that cast the result to unsigned.\n-\n-### Why is this bad?\n-The `unsigned_abs()` method avoids panic when called on the MIN value.\n-\n-### Example\n-```\n-let x: i32 = -42;\n-let y: u32 = x.abs() as u32;\n-```\n-Use instead:\n-```\n-let x: i32 = -42;\n-let y: u32 = x.unsigned_abs();\n-```\n\\ No newline at end of file"}, {"sha": "675c03a42bc23679e2132be6d00b43a1735c188a", "filename": "src/tools/clippy/src/docs/cast_enum_constructor.txt", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_enum_constructor.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_enum_constructor.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_enum_constructor.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,11 +0,0 @@\n-### What it does\n-Checks for casts from an enum tuple constructor to an integer.\n-\n-### Why is this bad?\n-The cast is easily confused with casting a c-like enum value to an integer.\n-\n-### Example\n-```\n-enum E { X(i32) };\n-let _ = E::X as usize;\n-```\n\\ No newline at end of file"}, {"sha": "abe32a8296da228ff5447d8f715aa6425abcfbe9", "filename": "src/tools/clippy/src/docs/cast_enum_truncation.txt", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_enum_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_enum_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_enum_truncation.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,12 +0,0 @@\n-### What it does\n-Checks for casts from an enum type to an integral type which will definitely truncate the\n-value.\n-\n-### Why is this bad?\n-The resulting integral value will not match the value of the variant it came from.\n-\n-### Example\n-```\n-enum E { X = 256 };\n-let _ = E::X as u8;\n-```\n\\ No newline at end of file"}, {"sha": "c3a61dd470fc9b4feabd4d4db2612e8ca8c71f4f", "filename": "src/tools/clippy/src/docs/cast_lossless.txt", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_lossless.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_lossless.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_lossless.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,26 +0,0 @@\n-### What it does\n-Checks for casts between numerical types that may\n-be replaced by safe conversion functions.\n-\n-### Why is this bad?\n-Rust's `as` keyword will perform many kinds of\n-conversions, including silently lossy conversions. Conversion functions such\n-as `i32::from` will only perform lossless conversions. Using the conversion\n-functions prevents conversions from turning into silent lossy conversions if\n-the types of the input expressions ever change, and make it easier for\n-people reading the code to know that the conversion is lossless.\n-\n-### Example\n-```\n-fn as_u64(x: u8) -> u64 {\n-    x as u64\n-}\n-```\n-\n-Using `::from` would look like this:\n-\n-```\n-fn as_u64(x: u8) -> u64 {\n-    u64::from(x)\n-}\n-```\n\\ No newline at end of file"}, {"sha": "122f5da0c921883aed797ca3880a4c71daf5f867", "filename": "src/tools/clippy/src/docs/cast_nan_to_int.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_nan_to_int.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_nan_to_int.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_nan_to_int.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Checks for a known NaN float being cast to an integer\n-\n-### Why is this bad?\n-NaNs are cast into zero, so one could simply use this and make the\n-code more readable. The lint could also hint at a programmer error.\n-\n-### Example\n-```\n-let _: (0.0_f32 / 0.0) as u64;\n-```\n-Use instead:\n-```\n-let _: = 0_u64;\n-```\n\\ No newline at end of file"}, {"sha": "0b164848cc7c23647a27ac5138e5f82346c876bb", "filename": "src/tools/clippy/src/docs/cast_possible_truncation.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_possible_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_possible_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_possible_truncation.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for casts between numerical types that may\n-truncate large values. This is expected behavior, so the cast is `Allow` by\n-default.\n-\n-### Why is this bad?\n-In some problem domains, it is good practice to avoid\n-truncation. This lint can be activated to help assess where additional\n-checks could be beneficial.\n-\n-### Example\n-```\n-fn as_u8(x: u64) -> u8 {\n-    x as u8\n-}\n-```\n\\ No newline at end of file"}, {"sha": "f883fc9cfb994793e5520453df94f183d2230319", "filename": "src/tools/clippy/src/docs/cast_possible_wrap.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_possible_wrap.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_possible_wrap.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_possible_wrap.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,17 +0,0 @@\n-### What it does\n-Checks for casts from an unsigned type to a signed type of\n-the same size. Performing such a cast is a 'no-op' for the compiler,\n-i.e., nothing is changed at the bit level, and the binary representation of\n-the value is reinterpreted. This can cause wrapping if the value is too big\n-for the target signed type. However, the cast works as defined, so this lint\n-is `Allow` by default.\n-\n-### Why is this bad?\n-While such a cast is not bad in itself, the results can\n-be surprising when this is not the intended behavior, as demonstrated by the\n-example below.\n-\n-### Example\n-```\n-u32::MAX as i32; // will yield a value of `-1`\n-```\n\\ No newline at end of file"}, {"sha": "f915d9f8a6d0d2bd191bfd7ea43e3b17fa36c22c", "filename": "src/tools/clippy/src/docs/cast_precision_loss.txt", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_precision_loss.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_precision_loss.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_precision_loss.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,19 +0,0 @@\n-### What it does\n-Checks for casts from any numerical to a float type where\n-the receiving type cannot store all values from the original type without\n-rounding errors. This possible rounding is to be expected, so this lint is\n-`Allow` by default.\n-\n-Basically, this warns on casting any integer with 32 or more bits to `f32`\n-or any 64-bit integer to `f64`.\n-\n-### Why is this bad?\n-It's not bad at all. But in some applications it can be\n-helpful to know where precision loss can take place. This lint can help find\n-those places in the code.\n-\n-### Example\n-```\n-let x = u64::MAX;\n-x as f64;\n-```\n\\ No newline at end of file"}, {"sha": "6a6d4dcaa2ae5ecdce3d53b2cc2f9f51d59e2281", "filename": "src/tools/clippy/src/docs/cast_ptr_alignment.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_ptr_alignment.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_ptr_alignment.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_ptr_alignment.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Checks for casts, using `as` or `pointer::cast`,\n-from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n-\n-### Why is this bad?\n-Dereferencing the resulting pointer may be undefined\n-behavior.\n-\n-### Known problems\n-Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\n-on the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\n-u64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n-\n-### Example\n-```\n-let _ = (&1u8 as *const u8) as *const u16;\n-let _ = (&mut 1u8 as *mut u8) as *mut u16;\n-\n-(&1u8 as *const u8).cast::<u16>();\n-(&mut 1u8 as *mut u8).cast::<u16>();\n-```\n\\ No newline at end of file"}, {"sha": "fb5b4dbb62d82386ab073958a1a97ded27bddeb9", "filename": "src/tools/clippy/src/docs/cast_ref_to_mut.txt", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_ref_to_mut.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_ref_to_mut.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_ref_to_mut.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,28 +0,0 @@\n-### What it does\n-Checks for casts of `&T` to `&mut T` anywhere in the code.\n-\n-### Why is this bad?\n-It\u2019s basically guaranteed to be undefined behavior.\n-`UnsafeCell` is the only way to obtain aliasable data that is considered\n-mutable.\n-\n-### Example\n-```\n-fn x(r: &i32) {\n-    unsafe {\n-        *(r as *const _ as *mut _) += 1;\n-    }\n-}\n-```\n-\n-Instead consider using interior mutability types.\n-\n-```\n-use std::cell::UnsafeCell;\n-\n-fn x(r: &UnsafeCell<i32>) {\n-    unsafe {\n-        *r.get() += 1;\n-    }\n-}\n-```\n\\ No newline at end of file"}, {"sha": "d64fe1b07f46932d14dc2569ee8dab845a9b62ab", "filename": "src/tools/clippy/src/docs/cast_sign_loss.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_sign_loss.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_sign_loss.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_sign_loss.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Checks for casts from a signed to an unsigned numerical\n-type. In this case, negative values wrap around to large positive values,\n-which can be quite surprising in practice. However, as the cast works as\n-defined, this lint is `Allow` by default.\n-\n-### Why is this bad?\n-Possibly surprising results. You can activate this lint\n-as a one-time check to see where numerical wrapping can arise.\n-\n-### Example\n-```\n-let y: i8 = -1;\n-y as u128; // will return 18446744073709551615\n-```\n\\ No newline at end of file"}, {"sha": "c01ef0ba92c03d0c66381a52e5506f7b9bfddeec", "filename": "src/tools/clippy/src/docs/cast_slice_different_sizes.txt", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_slice_different_sizes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_slice_different_sizes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_slice_different_sizes.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,38 +0,0 @@\n-### What it does\n-Checks for `as` casts between raw pointers to slices with differently sized elements.\n-\n-### Why is this bad?\n-The produced raw pointer to a slice does not update its length metadata. The produced\n-pointer will point to a different number of bytes than the original pointer because the\n-length metadata of a raw slice pointer is in elements rather than bytes.\n-Producing a slice reference from the raw pointer will either create a slice with\n-less data (which can be surprising) or create a slice with more data and cause Undefined Behavior.\n-\n-### Example\n-// Missing data\n-```\n-let a = [1_i32, 2, 3, 4];\n-let p = &a as *const [i32] as *const [u8];\n-unsafe {\n-    println!(\"{:?}\", &*p);\n-}\n-```\n-// Undefined Behavior (note: also potential alignment issues)\n-```\n-let a = [1_u8, 2, 3, 4];\n-let p = &a as *const [u8] as *const [u32];\n-unsafe {\n-    println!(\"{:?}\", &*p);\n-}\n-```\n-Instead use `ptr::slice_from_raw_parts` to construct a slice from a data pointer and the correct length\n-```\n-let a = [1_i32, 2, 3, 4];\n-let old_ptr = &a as *const [i32];\n-// The data pointer is cast to a pointer to the target `u8` not `[u8]`\n-// The length comes from the known length of 4 i32s times the 4 bytes per i32\n-let new_ptr = core::ptr::slice_from_raw_parts(old_ptr as *const u8, 16);\n-unsafe {\n-    println!(\"{:?}\", &*new_ptr);\n-}\n-```\n\\ No newline at end of file"}, {"sha": "b58c739766aab1d482014b8b69f882151ea5da41", "filename": "src/tools/clippy/src/docs/cast_slice_from_raw_parts.txt", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_slice_from_raw_parts.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_slice_from_raw_parts.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcast_slice_from_raw_parts.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,20 +0,0 @@\n-### What it does\n-Checks for a raw slice being cast to a slice pointer\n-\n-### Why is this bad?\n-This can result in multiple `&mut` references to the same location when only a pointer is\n-required.\n-`ptr::slice_from_raw_parts` is a safe alternative that doesn't require\n-the same [safety requirements] to be upheld.\n-\n-### Example\n-```\n-let _: *const [u8] = std::slice::from_raw_parts(ptr, len) as *const _;\n-let _: *mut [u8] = std::slice::from_raw_parts_mut(ptr, len) as *mut _;\n-```\n-Use instead:\n-```\n-let _: *const [u8] = std::ptr::slice_from_raw_parts(ptr, len);\n-let _: *mut [u8] = std::ptr::slice_from_raw_parts_mut(ptr, len);\n-```\n-[safety requirements]: https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety\n\\ No newline at end of file"}, {"sha": "00d60b9a451b9f4b82be87cded214d1a7b930b55", "filename": "src/tools/clippy/src/docs/char_lit_as_u8.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchar_lit_as_u8.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchar_lit_as_u8.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchar_lit_as_u8.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Checks for expressions where a character literal is cast\n-to `u8` and suggests using a byte literal instead.\n-\n-### Why is this bad?\n-In general, casting values to smaller types is\n-error-prone and should be avoided where possible. In the particular case of\n-converting a character literal to u8, it is easy to avoid by just using a\n-byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n-than `'a' as u8`.\n-\n-### Example\n-```\n-'x' as u8\n-```\n-\n-A better version, using the byte literal:\n-\n-```\n-b'x'\n-```\n\\ No newline at end of file"}, {"sha": "4c1d8838973a73d2c2699b68787cfe55d062901c", "filename": "src/tools/clippy/src/docs/chars_last_cmp.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchars_last_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchars_last_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchars_last_cmp.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,17 +0,0 @@\n-### What it does\n-Checks for usage of `_.chars().last()` or\n-`_.chars().next_back()` on a `str` to check if it ends with a given char.\n-\n-### Why is this bad?\n-Readability, this can be written more concisely as\n-`_.ends_with(_)`.\n-\n-### Example\n-```\n-name.chars().last() == Some('_') || name.chars().next_back() == Some('-');\n-```\n-\n-Use instead:\n-```\n-name.ends_with('_') || name.ends_with('-');\n-```\n\\ No newline at end of file"}, {"sha": "77cbce2de00f91f65298aacf0daddc3d3f6613d8", "filename": "src/tools/clippy/src/docs/chars_next_cmp.txt", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchars_next_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchars_next_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchars_next_cmp.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,19 +0,0 @@\n-### What it does\n-Checks for usage of `.chars().next()` on a `str` to check\n-if it starts with a given char.\n-\n-### Why is this bad?\n-Readability, this can be written more concisely as\n-`_.starts_with(_)`.\n-\n-### Example\n-```\n-let name = \"foo\";\n-if name.chars().next() == Some('_') {};\n-```\n-\n-Use instead:\n-```\n-let name = \"foo\";\n-if name.starts_with('_') {};\n-```\n\\ No newline at end of file"}, {"sha": "536b01294ee170493d4c6f6acee6813dbe79a9a6", "filename": "src/tools/clippy/src/docs/checked_conversions.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchecked_conversions.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchecked_conversions.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fchecked_conversions.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Checks for explicit bounds checking when casting.\n-\n-### Why is this bad?\n-Reduces the readability of statements & is error prone.\n-\n-### Example\n-```\n-foo <= i32::MAX as u32;\n-```\n-\n-Use instead:\n-```\n-i32::try_from(foo).is_ok();\n-```\n\\ No newline at end of file"}, {"sha": "2729635bd246f0710c1c2b8cbd9a4f4a35165023", "filename": "src/tools/clippy/src/docs/clone_double_ref.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_double_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_double_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_double_ref.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for usage of `.clone()` on an `&&T`.\n-\n-### Why is this bad?\n-Cloning an `&&T` copies the inner `&T`, instead of\n-cloning the underlying `T`.\n-\n-### Example\n-```\n-fn main() {\n-    let x = vec![1];\n-    let y = &&x;\n-    let z = y.clone();\n-    println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n-}\n-```\n\\ No newline at end of file"}, {"sha": "99a0bdb4c4ac0f668c16d2e650b66af7289c4b07", "filename": "src/tools/clippy/src/docs/clone_on_copy.txt", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_on_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_on_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_on_copy.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,11 +0,0 @@\n-### What it does\n-Checks for usage of `.clone()` on a `Copy` type.\n-\n-### Why is this bad?\n-The only reason `Copy` types implement `Clone` is for\n-generics, not for using the `clone` method on a concrete type.\n-\n-### Example\n-```\n-42u64.clone();\n-```\n\\ No newline at end of file"}, {"sha": "2d83f8fefc12239c201a135679543a418f9ed02b", "filename": "src/tools/clippy/src/docs/clone_on_ref_ptr.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_on_ref_ptr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_on_ref_ptr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fclone_on_ref_ptr.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Checks for usage of `.clone()` on a ref-counted pointer,\n-(`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\n-function syntax instead (e.g., `Rc::clone(foo)`).\n-\n-### Why is this bad?\n-Calling '.clone()' on an Rc, Arc, or Weak\n-can obscure the fact that only the pointer is being cloned, not the underlying\n-data.\n-\n-### Example\n-```\n-let x = Rc::new(1);\n-\n-x.clone();\n-```\n-\n-Use instead:\n-```\n-Rc::clone(&x);\n-```\n\\ No newline at end of file"}, {"sha": "2f2014d5fd2990e7d559cf95e675d8d4fa1a9a17", "filename": "src/tools/clippy/src/docs/cloned_instead_of_copied.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcloned_instead_of_copied.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcloned_instead_of_copied.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcloned_instead_of_copied.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for usages of `cloned()` on an `Iterator` or `Option` where\n-`copied()` could be used instead.\n-\n-### Why is this bad?\n-`copied()` is better because it guarantees that the type being cloned\n-implements `Copy`.\n-\n-### Example\n-```\n-[1, 2, 3].iter().cloned();\n-```\n-Use instead:\n-```\n-[1, 2, 3].iter().copied();\n-```\n\\ No newline at end of file"}, {"sha": "e2ad04d932359aa55e6cf5b1e0fd03e93aeeb8ec", "filename": "src/tools/clippy/src/docs/cmp_nan.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_nan.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_nan.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_nan.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for comparisons to NaN.\n-\n-### Why is this bad?\n-NaN does not compare meaningfully to anything \u2013 not\n-even itself \u2013 so those comparisons are simply wrong.\n-\n-### Example\n-```\n-if x == f32::NAN { }\n-```\n-\n-Use instead:\n-```\n-if x.is_nan() { }\n-```\n\\ No newline at end of file"}, {"sha": "02fd15124f0389b6e7c0ba637fddb737d39f8df2", "filename": "src/tools/clippy/src/docs/cmp_null.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_null.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_null.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_null.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-This lint checks for equality comparisons with `ptr::null`\n-\n-### Why is this bad?\n-It's easier and more readable to use the inherent\n-`.is_null()`\n-method instead\n-\n-### Example\n-```\n-use std::ptr;\n-\n-if x == ptr::null {\n-    // ..\n-}\n-```\n-\n-Use instead:\n-```\n-if x.is_null() {\n-    // ..\n-}\n-```\n\\ No newline at end of file"}, {"sha": "f8d4956ff1d4b7b010df92dffb8ccc7a16dc1684", "filename": "src/tools/clippy/src/docs/cmp_owned.txt", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_owned.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_owned.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcmp_owned.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,18 +0,0 @@\n-### What it does\n-Checks for conversions to owned values just for the sake\n-of a comparison.\n-\n-### Why is this bad?\n-The comparison can operate on a reference, so creating\n-an owned value effectively throws it away directly afterwards, which is\n-needlessly consuming code and heap space.\n-\n-### Example\n-```\n-if x.to_owned() == y {}\n-```\n-\n-Use instead:\n-```\n-if x == y {}\n-```\n\\ No newline at end of file"}, {"sha": "fdd75f6479cd00cf24d503b37b9f3d48c38249da", "filename": "src/tools/clippy/src/docs/cognitive_complexity.txt", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcognitive_complexity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcognitive_complexity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcognitive_complexity.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,13 +0,0 @@\n-### What it does\n-Checks for methods with high cognitive complexity.\n-\n-### Why is this bad?\n-Methods of high cognitive complexity tend to be hard to\n-both read and maintain. Also LLVM will tend to optimize small methods better.\n-\n-### Known problems\n-Sometimes it's hard to find a way to reduce the\n-complexity.\n-\n-### Example\n-You'll see it when you get the warning.\n\\ No newline at end of file"}, {"sha": "4ddfca17731f7b95a2622c2255e8c75ff16ea89e", "filename": "src/tools/clippy/src/docs/collapsible_else_if.txt", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_else_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_else_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_else_if.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,29 +0,0 @@\n-### What it does\n-Checks for collapsible `else { if ... }` expressions\n-that can be collapsed to `else if ...`.\n-\n-### Why is this bad?\n-Each `if`-statement adds one level of nesting, which\n-makes code look more complex than it really is.\n-\n-### Example\n-```\n-\n-if x {\n-    \u2026\n-} else {\n-    if y {\n-        \u2026\n-    }\n-}\n-```\n-\n-Should be written:\n-\n-```\n-if x {\n-    \u2026\n-} else if y {\n-    \u2026\n-}\n-```\n\\ No newline at end of file"}, {"sha": "e1264ee062e955437c7199981de2dd21a2eaa135", "filename": "src/tools/clippy/src/docs/collapsible_if.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_if.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_if.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_if.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-Checks for nested `if` statements which can be collapsed\n-by `&&`-combining their conditions.\n-\n-### Why is this bad?\n-Each `if`-statement adds one level of nesting, which\n-makes code look more complex than it really is.\n-\n-### Example\n-```\n-if x {\n-    if y {\n-        // \u2026\n-    }\n-}\n-```\n-\n-Use instead:\n-```\n-if x && y {\n-    // \u2026\n-}\n-```\n\\ No newline at end of file"}, {"sha": "0d59594a03a27c2f1957912613c548ec7cde34dd", "filename": "src/tools/clippy/src/docs/collapsible_match.txt", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_match.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_match.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_match.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,31 +0,0 @@\n-### What it does\n-Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n-without adding any branches.\n-\n-Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n-cases where merging would most likely make the code more readable.\n-\n-### Why is this bad?\n-It is unnecessarily verbose and complex.\n-\n-### Example\n-```\n-fn func(opt: Option<Result<u64, String>>) {\n-    let n = match opt {\n-        Some(n) => match n {\n-            Ok(n) => n,\n-            _ => return,\n-        }\n-        None => return,\n-    };\n-}\n-```\n-Use instead:\n-```\n-fn func(opt: Option<Result<u64, String>>) {\n-    let n = match opt {\n-        Some(Ok(n)) => n,\n-        _ => return,\n-    };\n-}\n-```\n\\ No newline at end of file"}, {"sha": "c24c25a3028a5d5dce4806d16b028aa46125c7e2", "filename": "src/tools/clippy/src/docs/collapsible_str_replace.txt", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_str_replace.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_str_replace.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcollapsible_str_replace.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,19 +0,0 @@\n-### What it does\n-Checks for consecutive calls to `str::replace` (2 or more)\n-that can be collapsed into a single call.\n-\n-### Why is this bad?\n-Consecutive `str::replace` calls scan the string multiple times\n-with repetitive code.\n-\n-### Example\n-```\n-let hello = \"hesuo worpd\"\n-    .replace('s', \"l\")\n-    .replace(\"u\", \"l\")\n-    .replace('p', \"l\");\n-```\n-Use instead:\n-```\n-let hello = \"hesuo worpd\".replace(&['s', 'u', 'p'], \"l\");\n-```\n\\ No newline at end of file"}, {"sha": "43b09f31ff4aa7a6596db9d2456d6c19f63185fa", "filename": "src/tools/clippy/src/docs/comparison_chain.txt", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcomparison_chain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcomparison_chain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcomparison_chain.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,36 +0,0 @@\n-### What it does\n-Checks comparison chains written with `if` that can be\n-rewritten with `match` and `cmp`.\n-\n-### Why is this bad?\n-`if` is not guaranteed to be exhaustive and conditionals can get\n-repetitive\n-\n-### Known problems\n-The match statement may be slower due to the compiler\n-not inlining the call to cmp. See issue [#5354](https://github.com/rust-lang/rust-clippy/issues/5354)\n-\n-### Example\n-```\n-fn f(x: u8, y: u8) {\n-    if x > y {\n-        a()\n-    } else if x < y {\n-        b()\n-    } else {\n-        c()\n-    }\n-}\n-```\n-\n-Use instead:\n-```\n-use std::cmp::Ordering;\n-fn f(x: u8, y: u8) {\n-     match x.cmp(&y) {\n-         Ordering::Greater => a(),\n-         Ordering::Less => b(),\n-         Ordering::Equal => c()\n-     }\n-}\n-```\n\\ No newline at end of file"}, {"sha": "db6f74fe2706b5bbca627b24980f86865d219bc7", "filename": "src/tools/clippy/src/docs/comparison_to_empty.txt", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcomparison_to_empty.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcomparison_to_empty.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcomparison_to_empty.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,31 +0,0 @@\n-### What it does\n-Checks for comparing to an empty slice such as `\"\"` or `[]`,\n-and suggests using `.is_empty()` where applicable.\n-\n-### Why is this bad?\n-Some structures can answer `.is_empty()` much faster\n-than checking for equality. So it is good to get into the habit of using\n-`.is_empty()`, and having it is cheap.\n-Besides, it makes the intent clearer than a manual comparison in some contexts.\n-\n-### Example\n-\n-```\n-if s == \"\" {\n-    ..\n-}\n-\n-if arr == [] {\n-    ..\n-}\n-```\n-Use instead:\n-```\n-if s.is_empty() {\n-    ..\n-}\n-\n-if arr.is_empty() {\n-    ..\n-}\n-```\n\\ No newline at end of file"}, {"sha": "5f9a2a015b86c7bd9bd2c3956bfeff4fe6702e31", "filename": "src/tools/clippy/src/docs/copy_iterator.txt", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcopy_iterator.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcopy_iterator.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcopy_iterator.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,20 +0,0 @@\n-### What it does\n-Checks for types that implement `Copy` as well as\n-`Iterator`.\n-\n-### Why is this bad?\n-Implicit copies can be confusing when working with\n-iterator combinators.\n-\n-### Example\n-```\n-#[derive(Copy, Clone)]\n-struct Countdown(u8);\n-\n-impl Iterator for Countdown {\n-    // ...\n-}\n-\n-let a: Vec<_> = my_iterator.take(1).collect();\n-let b: Vec<_> = my_iterator.collect();\n-```\n\\ No newline at end of file"}, {"sha": "047e986dee71fae10dd59b6faf35eabbbff50db7", "filename": "src/tools/clippy/src/docs/crate_in_macro_def.txt", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcrate_in_macro_def.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcrate_in_macro_def.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcrate_in_macro_def.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,35 +0,0 @@\n-### What it does\n-Checks for use of `crate` as opposed to `$crate` in a macro definition.\n-\n-### Why is this bad?\n-`crate` refers to the macro call's crate, whereas `$crate` refers to the macro definition's\n-crate. Rarely is the former intended. See:\n-https://doc.rust-lang.org/reference/macros-by-example.html#hygiene\n-\n-### Example\n-```\n-#[macro_export]\n-macro_rules! print_message {\n-    () => {\n-        println!(\"{}\", crate::MESSAGE);\n-    };\n-}\n-pub const MESSAGE: &str = \"Hello!\";\n-```\n-Use instead:\n-```\n-#[macro_export]\n-macro_rules! print_message {\n-    () => {\n-        println!(\"{}\", $crate::MESSAGE);\n-    };\n-}\n-pub const MESSAGE: &str = \"Hello!\";\n-```\n-\n-Note that if the use of `crate` is intentional, an `allow` attribute can be applied to the\n-macro definition, e.g.:\n-```\n-#[allow(clippy::crate_in_macro_def)]\n-macro_rules! ok { ... crate::foo ... }\n-```\n\\ No newline at end of file"}, {"sha": "e4e7937684e6efebae130aed520866705fda8e77", "filename": "src/tools/clippy/src/docs/create_dir.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcreate_dir.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcreate_dir.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcreate_dir.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Checks usage of `std::fs::create_dir` and suggest using `std::fs::create_dir_all` instead.\n-\n-### Why is this bad?\n-Sometimes `std::fs::create_dir` is mistakenly chosen over `std::fs::create_dir_all`.\n-\n-### Example\n-```\n-std::fs::create_dir(\"foo\");\n-```\n-\n-Use instead:\n-```\n-std::fs::create_dir_all(\"foo\");\n-```\n\\ No newline at end of file"}, {"sha": "49dea154970e50ab216792d52a157dfd24e2f960", "filename": "src/tools/clippy/src/docs/crosspointer_transmute.txt", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcrosspointer_transmute.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcrosspointer_transmute.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fcrosspointer_transmute.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,12 +0,0 @@\n-### What it does\n-Checks for transmutes between a type `T` and `*T`.\n-\n-### Why is this bad?\n-It's easy to mistakenly transmute between a type and a\n-pointer to that type.\n-\n-### Example\n-```\n-core::intrinsics::transmute(t) // where the result type is the same as\n-                               // `*t` or `&t`'s\n-```\n\\ No newline at end of file"}, {"sha": "3e1a9a043f9f41617cefd86d3b2c044620856525", "filename": "src/tools/clippy/src/docs/dbg_macro.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdbg_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdbg_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdbg_macro.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for usage of dbg!() macro.\n-\n-### Why is this bad?\n-`dbg!` macro is intended as a debugging tool. It\n-should not be in version control.\n-\n-### Example\n-```\n-dbg!(true)\n-```\n-\n-Use instead:\n-```\n-true\n-```\n\\ No newline at end of file"}, {"sha": "2c44abe1f05c806108d329d07ccb021a0011a20b", "filename": "src/tools/clippy/src/docs/debug_assert_with_mut_call.txt", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdebug_assert_with_mut_call.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdebug_assert_with_mut_call.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdebug_assert_with_mut_call.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,18 +0,0 @@\n-### What it does\n-Checks for function/method calls with a mutable\n-parameter in `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!` macros.\n-\n-### Why is this bad?\n-In release builds `debug_assert!` macros are optimized out by the\n-compiler.\n-Therefore mutating something in a `debug_assert!` macro results in different behavior\n-between a release and debug build.\n-\n-### Example\n-```\n-debug_assert_eq!(vec![3].pop(), Some(3));\n-\n-// or\n-\n-debug_assert!(takes_a_mut_parameter(&mut x));\n-```\n\\ No newline at end of file"}, {"sha": "daca9bbb3a848c7dd2b9314b952ee68760230ae5", "filename": "src/tools/clippy/src/docs/decimal_literal_representation.txt", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdecimal_literal_representation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdecimal_literal_representation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdecimal_literal_representation.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,13 +0,0 @@\n-### What it does\n-Warns if there is a better representation for a numeric literal.\n-\n-### Why is this bad?\n-Especially for big powers of 2 a hexadecimal representation is more\n-readable than a decimal representation.\n-\n-### Example\n-```\n-`255` => `0xFF`\n-`65_535` => `0xFFFF`\n-`4_042_322_160` => `0xF0F0_F0F0`\n-```\n\\ No newline at end of file"}, {"sha": "2801b5ccff8028aaa4dc0c8899e28bf01915d3ca", "filename": "src/tools/clippy/src/docs/declare_interior_mutable_const.txt", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeclare_interior_mutable_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeclare_interior_mutable_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeclare_interior_mutable_const.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,46 +0,0 @@\n-### What it does\n-Checks for declaration of `const` items which is interior\n-mutable (e.g., contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.).\n-\n-### Why is this bad?\n-Consts are copied everywhere they are referenced, i.e.,\n-every time you refer to the const a fresh instance of the `Cell` or `Mutex`\n-or `AtomicXxxx` will be created, which defeats the whole purpose of using\n-these types in the first place.\n-\n-The `const` should better be replaced by a `static` item if a global\n-variable is wanted, or replaced by a `const fn` if a constructor is wanted.\n-\n-### Known problems\n-A \"non-constant\" const item is a legacy way to supply an\n-initialized value to downstream `static` items (e.g., the\n-`std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n-and this lint should be suppressed.\n-\n-Even though the lint avoids triggering on a constant whose type has enums that have variants\n-with interior mutability, and its value uses non interior mutable variants (see\n-[#3962](https://github.com/rust-lang/rust-clippy/issues/3962) and\n-[#3825](https://github.com/rust-lang/rust-clippy/issues/3825) for examples);\n-it complains about associated constants without default values only based on its types;\n-which might not be preferable.\n-There're other enums plus associated constants cases that the lint cannot handle.\n-\n-Types that have underlying or potential interior mutability trigger the lint whether\n-the interior mutable field is used or not. See issues\n-[#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n-\n-### Example\n-```\n-use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-\n-const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n-CONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\n-assert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n-```\n-\n-Use instead:\n-```\n-static STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\n-STATIC_ATOM.store(9, SeqCst);\n-assert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n-```\n\\ No newline at end of file"}, {"sha": "b63ef3d18fc411d16f22e1f70f801b50d87a443f", "filename": "src/tools/clippy/src/docs/default_instead_of_iter_empty.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_instead_of_iter_empty.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_instead_of_iter_empty.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_instead_of_iter_empty.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-It checks for `std::iter::Empty::default()` and suggests replacing it with\n-`std::iter::empty()`.\n-### Why is this bad?\n-`std::iter::empty()` is the more idiomatic way.\n-### Example\n-```\n-let _ = std::iter::Empty::<usize>::default();\n-let iter: std::iter::Empty<usize> = std::iter::Empty::default();\n-```\n-Use instead:\n-```\n-let _ = std::iter::empty::<usize>();\n-let iter: std::iter::Empty<usize> = std::iter::empty();\n-```\n\\ No newline at end of file"}, {"sha": "15076a0a68bf6717c884c45cd79bb90f076b1700", "filename": "src/tools/clippy/src/docs/default_numeric_fallback.txt", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_numeric_fallback.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_numeric_fallback.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_numeric_fallback.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,28 +0,0 @@\n-### What it does\n-Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\n-inference.\n-\n-Default numeric fallback means that if numeric types have not yet been bound to concrete\n-types at the end of type inference, then integer type is bound to `i32`, and similarly\n-floating type is bound to `f64`.\n-\n-See [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.\n-\n-### Why is this bad?\n-For those who are very careful about types, default numeric fallback\n-can be a pitfall that cause unexpected runtime behavior.\n-\n-### Known problems\n-This lint can only be allowed at the function level or above.\n-\n-### Example\n-```\n-let i = 10;\n-let f = 1.23;\n-```\n-\n-Use instead:\n-```\n-let i = 10i32;\n-let f = 1.23f64;\n-```\n\\ No newline at end of file"}, {"sha": "e69298969c8ed807f08c6023713ede2b5d5c4af2", "filename": "src/tools/clippy/src/docs/default_trait_access.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_trait_access.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_trait_access.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_trait_access.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for literal calls to `Default::default()`.\n-\n-### Why is this bad?\n-It's easier for the reader if the name of the type is used, rather than the\n-generic `Default`.\n-\n-### Example\n-```\n-let s: String = Default::default();\n-```\n-\n-Use instead:\n-```\n-let s = String::default();\n-```\n\\ No newline at end of file"}, {"sha": "f79ff9760e57ebaf1dfea011d14fb91cdf3d837c", "filename": "src/tools/clippy/src/docs/default_union_representation.txt", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_union_representation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_union_representation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdefault_union_representation.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,36 +0,0 @@\n-### What it does\n-Displays a warning when a union is declared with the default representation (without a `#[repr(C)]` attribute).\n-\n-### Why is this bad?\n-Unions in Rust have unspecified layout by default, despite many people thinking that they\n-lay out each field at the start of the union (like C does). That is, there are no guarantees\n-about the offset of the fields for unions with multiple non-ZST fields without an explicitly\n-specified layout. These cases may lead to undefined behavior in unsafe blocks.\n-\n-### Example\n-```\n-union Foo {\n-    a: i32,\n-    b: u32,\n-}\n-\n-fn main() {\n-    let _x: u32 = unsafe {\n-        Foo { a: 0_i32 }.b // Undefined behavior: `b` is allowed to be padding\n-    };\n-}\n-```\n-Use instead:\n-```\n-#[repr(C)]\n-union Foo {\n-    a: i32,\n-    b: u32,\n-}\n-\n-fn main() {\n-    let _x: u32 = unsafe {\n-        Foo { a: 0_i32 }.b // Now defined behavior, this is just an i32 -> u32 transmute\n-    };\n-}\n-```\n\\ No newline at end of file"}, {"sha": "9f264887a057e3c4eb347abef608a7ab7dcc8c73", "filename": "src/tools/clippy/src/docs/deprecated_cfg_attr.txt", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeprecated_cfg_attr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeprecated_cfg_attr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeprecated_cfg_attr.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,24 +0,0 @@\n-### What it does\n-Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n-with `#[rustfmt::skip]`.\n-\n-### Why is this bad?\n-Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\n-are stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n-\n-### Known problems\n-This lint doesn't detect crate level inner attributes, because they get\n-processed before the PreExpansionPass lints get executed. See\n-[#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n-\n-### Example\n-```\n-#[cfg_attr(rustfmt, rustfmt_skip)]\n-fn main() { }\n-```\n-\n-Use instead:\n-```\n-#[rustfmt::skip]\n-fn main() { }\n-```\n\\ No newline at end of file"}, {"sha": "c9574a99b2bec22abdd5b766a55f04b1dd41b494", "filename": "src/tools/clippy/src/docs/deprecated_semver.txt", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeprecated_semver.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeprecated_semver.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdeprecated_semver.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,13 +0,0 @@\n-### What it does\n-Checks for `#[deprecated]` annotations with a `since`\n-field that is not a valid semantic version.\n-\n-### Why is this bad?\n-For checking the version of the deprecation, it must be\n-a valid semver. Failing that, the contained information is useless.\n-\n-### Example\n-```\n-#[deprecated(since = \"forever\")]\n-fn something_else() { /* ... */ }\n-```\n\\ No newline at end of file"}, {"sha": "fa711b924d48015fd81c79f45f0a4303f9ffb2fb", "filename": "src/tools/clippy/src/docs/deref_addrof.txt", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderef_addrof.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderef_addrof.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderef_addrof.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,22 +0,0 @@\n-### What it does\n-Checks for usage of `*&` and `*&mut` in expressions.\n-\n-### Why is this bad?\n-Immediately dereferencing a reference is no-op and\n-makes the code less clear.\n-\n-### Known problems\n-Multiple dereference/addrof pairs are not handled so\n-the suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n-\n-### Example\n-```\n-let a = f(*&mut b);\n-let c = *&d;\n-```\n-\n-Use instead:\n-```\n-let a = f(b);\n-let c = d;\n-```\n\\ No newline at end of file"}, {"sha": "4dad24ac00cad9ae2532af665ccb2516d939c1bb", "filename": "src/tools/clippy/src/docs/deref_by_slicing.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderef_by_slicing.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderef_by_slicing.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderef_by_slicing.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,17 +0,0 @@\n-### What it does\n-Checks for slicing expressions which are equivalent to dereferencing the\n-value.\n-\n-### Why is this bad?\n-Some people may prefer to dereference rather than slice.\n-\n-### Example\n-```\n-let vec = vec![1, 2, 3];\n-let slice = &vec[..];\n-```\n-Use instead:\n-```\n-let vec = vec![1, 2, 3];\n-let slice = &*vec;\n-```\n\\ No newline at end of file"}, {"sha": "5cee43956cc360eb5ca0af1d7767fc390d24625c", "filename": "src/tools/clippy/src/docs/derivable_impls.txt", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderivable_impls.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderivable_impls.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderivable_impls.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,35 +0,0 @@\n-### What it does\n-Detects manual `std::default::Default` implementations that are identical to a derived implementation.\n-\n-### Why is this bad?\n-It is less concise.\n-\n-### Example\n-```\n-struct Foo {\n-    bar: bool\n-}\n-\n-impl Default for Foo {\n-    fn default() -> Self {\n-        Self {\n-            bar: false\n-        }\n-    }\n-}\n-```\n-\n-Use instead:\n-```\n-#[derive(Default)]\n-struct Foo {\n-    bar: bool\n-}\n-```\n-\n-### Known problems\n-Derive macros [sometimes use incorrect bounds](https://github.com/rust-lang/rust/issues/26925)\n-in generic types and the user defined `impl` may be more generalized or\n-specialized than what derive will produce. This lint can't detect the manual `impl`\n-has exactly equal bounds, and therefore this lint is disabled for types with\n-generic parameters.\n\\ No newline at end of file"}, {"sha": "fbf623d5adbc10a0fa3890059c1522cca9f51940", "filename": "src/tools/clippy/src/docs/derive_hash_xor_eq.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_hash_xor_eq.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_hash_xor_eq.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_hash_xor_eq.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-Checks for deriving `Hash` but implementing `PartialEq`\n-explicitly or vice versa.\n-\n-### Why is this bad?\n-The implementation of these traits must agree (for\n-example for use with `HashMap`) so it\u2019s probably a bad idea to use a\n-default-generated `Hash` implementation with an explicitly defined\n-`PartialEq`. In particular, the following must hold for any type:\n-\n-```\n-k1 == k2 \u21d2 hash(k1) == hash(k2)\n-```\n-\n-### Example\n-```\n-#[derive(Hash)]\n-struct Foo;\n-\n-impl PartialEq for Foo {\n-    ...\n-}\n-```\n\\ No newline at end of file"}, {"sha": "f2107a5f69eea93e87e2c7544940bf5020407629", "filename": "src/tools/clippy/src/docs/derive_ord_xor_partial_ord.txt", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_ord_xor_partial_ord.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_ord_xor_partial_ord.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_ord_xor_partial_ord.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,44 +0,0 @@\n-### What it does\n-Checks for deriving `Ord` but implementing `PartialOrd`\n-explicitly or vice versa.\n-\n-### Why is this bad?\n-The implementation of these traits must agree (for\n-example for use with `sort`) so it\u2019s probably a bad idea to use a\n-default-generated `Ord` implementation with an explicitly defined\n-`PartialOrd`. In particular, the following must hold for any type\n-implementing `Ord`:\n-\n-```\n-k1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n-```\n-\n-### Example\n-```\n-#[derive(Ord, PartialEq, Eq)]\n-struct Foo;\n-\n-impl PartialOrd for Foo {\n-    ...\n-}\n-```\n-Use instead:\n-```\n-#[derive(PartialEq, Eq)]\n-struct Foo;\n-\n-impl PartialOrd for Foo {\n-    fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n-       Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for Foo {\n-    ...\n-}\n-```\n-or, if you don't need a custom ordering:\n-```\n-#[derive(Ord, PartialOrd, PartialEq, Eq)]\n-struct Foo;\n-```\n\\ No newline at end of file"}, {"sha": "932fabad666c3431d3fdd39c3168cda2d418b900", "filename": "src/tools/clippy/src/docs/derive_partial_eq_without_eq.txt", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_partial_eq_without_eq.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_partial_eq_without_eq.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fderive_partial_eq_without_eq.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,25 +0,0 @@\n-### What it does\n-Checks for types that derive `PartialEq` and could implement `Eq`.\n-\n-### Why is this bad?\n-If a type `T` derives `PartialEq` and all of its members implement `Eq`,\n-then `T` can always implement `Eq`. Implementing `Eq` allows `T` to be used\n-in APIs that require `Eq` types. It also allows structs containing `T` to derive\n-`Eq` themselves.\n-\n-### Example\n-```\n-#[derive(PartialEq)]\n-struct Foo {\n-    i_am_eq: i32,\n-    i_am_eq_too: Vec<String>,\n-}\n-```\n-Use instead:\n-```\n-#[derive(PartialEq, Eq)]\n-struct Foo {\n-    i_am_eq: i32,\n-    i_am_eq_too: Vec<String>,\n-}\n-```\n\\ No newline at end of file"}, {"sha": "96fa15afabfd2b617d45cc9f351ef717cd46e7fc", "filename": "src/tools/clippy/src/docs/disallowed_macros.txt", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_macros.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_macros.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_macros.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,36 +0,0 @@\n-### What it does\n-Denies the configured macros in clippy.toml\n-\n-Note: Even though this lint is warn-by-default, it will only trigger if\n-macros are defined in the clippy.toml file.\n-\n-### Why is this bad?\n-Some macros are undesirable in certain contexts, and it's beneficial to\n-lint for them as needed.\n-\n-### Example\n-An example clippy.toml configuration:\n-```\n-disallowed-macros = [\n-    # Can use a string as the path of the disallowed macro.\n-    \"std::print\",\n-    # Can also use an inline table with a `path` key.\n-    { path = \"std::println\" },\n-    # When using an inline table, can add a `reason` for why the macro\n-    # is disallowed.\n-    { path = \"serde::Serialize\", reason = \"no serializing\" },\n-]\n-```\n-```\n-use serde::Serialize;\n-\n-// Example code where clippy issues a warning\n-println!(\"warns\");\n-\n-// The diagnostic will contain the message \"no serializing\"\n-#[derive(Serialize)]\n-struct Data {\n-    name: String,\n-    value: usize,\n-}\n-```\n\\ No newline at end of file"}, {"sha": "d8ad5b6a6674cd2c4bb0a79f3b13ca391b1e06ce", "filename": "src/tools/clippy/src/docs/disallowed_methods.txt", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_methods.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_methods.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_methods.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,41 +0,0 @@\n-### What it does\n-Denies the configured methods and functions in clippy.toml\n-\n-Note: Even though this lint is warn-by-default, it will only trigger if\n-methods are defined in the clippy.toml file.\n-\n-### Why is this bad?\n-Some methods are undesirable in certain contexts, and it's beneficial to\n-lint for them as needed.\n-\n-### Example\n-An example clippy.toml configuration:\n-```\n-disallowed-methods = [\n-    # Can use a string as the path of the disallowed method.\n-    \"std::boxed::Box::new\",\n-    # Can also use an inline table with a `path` key.\n-    { path = \"std::time::Instant::now\" },\n-    # When using an inline table, can add a `reason` for why the method\n-    # is disallowed.\n-    { path = \"std::vec::Vec::leak\", reason = \"no leaking memory\" },\n-]\n-```\n-\n-```\n-// Example code where clippy issues a warning\n-let xs = vec![1, 2, 3, 4];\n-xs.leak(); // Vec::leak is disallowed in the config.\n-// The diagnostic contains the message \"no leaking memory\".\n-\n-let _now = Instant::now(); // Instant::now is disallowed in the config.\n-\n-let _box = Box::new(3); // Box::new is disallowed in the config.\n-```\n-\n-Use instead:\n-```\n-// Example code which does not raise clippy warning\n-let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the config.\n-xs.push(123); // Vec::push is _not_ disallowed in the config.\n-```\n\\ No newline at end of file"}, {"sha": "f4aaee9c77b7baed6014435108a093d22b4cb55f", "filename": "src/tools/clippy/src/docs/disallowed_names.txt", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_names.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,12 +0,0 @@\n-### What it does\n-Checks for usage of disallowed names for variables, such\n-as `foo`.\n-\n-### Why is this bad?\n-These names are usually placeholder names and should be\n-avoided.\n-\n-### Example\n-```\n-let foo = 3.14;\n-```\n\\ No newline at end of file"}, {"sha": "2151b7a20dedc0bd92841cdc550c96f1c05b45ba", "filename": "src/tools/clippy/src/docs/disallowed_script_idents.txt", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_script_idents.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_script_idents.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_script_idents.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,32 +0,0 @@\n-### What it does\n-Checks for usage of unicode scripts other than those explicitly allowed\n-by the lint config.\n-\n-This lint doesn't take into account non-text scripts such as `Unknown` and `Linear_A`.\n-It also ignores the `Common` script type.\n-While configuring, be sure to use official script name [aliases] from\n-[the list of supported scripts][supported_scripts].\n-\n-See also: [`non_ascii_idents`].\n-\n-[aliases]: http://www.unicode.org/reports/tr24/tr24-31.html#Script_Value_Aliases\n-[supported_scripts]: https://www.unicode.org/iso15924/iso15924-codes.html\n-\n-### Why is this bad?\n-It may be not desired to have many different scripts for\n-identifiers in the codebase.\n-\n-Note that if you only want to allow plain English, you might want to use\n-built-in [`non_ascii_idents`] lint instead.\n-\n-[`non_ascii_idents`]: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents\n-\n-### Example\n-```\n-// Assuming that `clippy.toml` contains the following line:\n-// allowed-locales = [\"Latin\", \"Cyrillic\"]\n-let counter = 10; // OK, latin is allowed.\n-let \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // OK, cyrillic is allowed.\n-let z\u00e4hler = 10; // OK, it's still latin.\n-let \u30ab\u30a6\u30f3\u30bf = 10; // Will spawn the lint.\n-```\n\\ No newline at end of file"}, {"sha": "2bcbcddee5666d10d749568713f34c185e057afb", "filename": "src/tools/clippy/src/docs/disallowed_types.txt", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_types.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_types.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdisallowed_types.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,33 +0,0 @@\n-### What it does\n-Denies the configured types in clippy.toml.\n-\n-Note: Even though this lint is warn-by-default, it will only trigger if\n-types are defined in the clippy.toml file.\n-\n-### Why is this bad?\n-Some types are undesirable in certain contexts.\n-\n-### Example:\n-An example clippy.toml configuration:\n-```\n-disallowed-types = [\n-    # Can use a string as the path of the disallowed type.\n-    \"std::collections::BTreeMap\",\n-    # Can also use an inline table with a `path` key.\n-    { path = \"std::net::TcpListener\" },\n-    # When using an inline table, can add a `reason` for why the type\n-    # is disallowed.\n-    { path = \"std::net::Ipv4Addr\", reason = \"no IPv4 allowed\" },\n-]\n-```\n-\n-```\n-use std::collections::BTreeMap;\n-// or its use\n-let x = std::collections::BTreeMap::new();\n-```\n-Use instead:\n-```\n-// A similar type that is allowed by the config\n-use std::collections::HashMap;\n-```\n\\ No newline at end of file"}, {"sha": "19436221802512d51c30904ba06904eada8a8de0", "filename": "src/tools/clippy/src/docs/diverging_sub_expression.txt", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdiverging_sub_expression.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdiverging_sub_expression.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdiverging_sub_expression.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,19 +0,0 @@\n-### What it does\n-Checks for diverging calls that are not match arms or\n-statements.\n-\n-### Why is this bad?\n-It is often confusing to read. In addition, the\n-sub-expression evaluation order for Rust is not well documented.\n-\n-### Known problems\n-Someone might want to use `some_bool || panic!()` as a\n-shorthand.\n-\n-### Example\n-```\n-let a = b() || panic!() || c();\n-// `c()` is dead, `panic!()` is only called if `b()` returns `false`\n-let x = (a, b, c, panic!());\n-// can simply be replaced by `panic!()`\n-```\n\\ No newline at end of file"}, {"sha": "107c8ac116d93bb836d29cacbff9d86f46b2fb96", "filename": "src/tools/clippy/src/docs/doc_link_with_quotes.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdoc_link_with_quotes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdoc_link_with_quotes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdoc_link_with_quotes.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Detects the syntax `['foo']` in documentation comments (notice quotes instead of backticks)\n-outside of code blocks\n-### Why is this bad?\n-It is likely a typo when defining an intra-doc link\n-\n-### Example\n-```\n-/// See also: ['foo']\n-fn bar() {}\n-```\n-Use instead:\n-```\n-/// See also: [`foo`]\n-fn bar() {}\n-```\n\\ No newline at end of file"}, {"sha": "94f54c587e3021ab81cfe05aa1b5834cc3e2ad97", "filename": "src/tools/clippy/src/docs/doc_markdown.txt", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdoc_markdown.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdoc_markdown.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdoc_markdown.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,35 +0,0 @@\n-### What it does\n-Checks for the presence of `_`, `::` or camel-case words\n-outside ticks in documentation.\n-\n-### Why is this bad?\n-*Rustdoc* supports markdown formatting, `_`, `::` and\n-camel-case probably indicates some code which should be included between\n-ticks. `_` can also be used for emphasis in markdown, this lint tries to\n-consider that.\n-\n-### Known problems\n-Lots of bad docs won\u2019t be fixed, what the lint checks\n-for is limited, and there are still false positives. HTML elements and their\n-content are not linted.\n-\n-In addition, when writing documentation comments, including `[]` brackets\n-inside a link text would trip the parser. Therefore, documenting link with\n-`[`SmallVec<[T; INLINE_CAPACITY]>`]` and then [`SmallVec<[T; INLINE_CAPACITY]>`]: SmallVec\n-would fail.\n-\n-### Examples\n-```\n-/// Do something with the foo_bar parameter. See also\n-/// that::other::module::foo.\n-// ^ `foo_bar` and `that::other::module::foo` should be ticked.\n-fn doit(foo_bar: usize) {}\n-```\n-\n-```\n-// Link text with `[]` brackets should be written as following:\n-/// Consume the array and return the inner\n-/// [`SmallVec<[T; INLINE_CAPACITY]>`][SmallVec].\n-/// [SmallVec]: SmallVec\n-fn main() {}\n-```\n\\ No newline at end of file"}, {"sha": "7dc6818779f4b168e9e6d38e7b58fc75d074c53a", "filename": "src/tools/clippy/src/docs/double_comparisons.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_comparisons.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,17 +0,0 @@\n-### What it does\n-Checks for double comparisons that could be simplified to a single expression.\n-\n-\n-### Why is this bad?\n-Readability.\n-\n-### Example\n-```\n-if x == y || x < y {}\n-```\n-\n-Use instead:\n-\n-```\n-if x <= y {}\n-```\n\\ No newline at end of file"}, {"sha": "0017d10d40d339344e8c1f4a7aec32fa2227a818", "filename": "src/tools/clippy/src/docs/double_must_use.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_must_use.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_must_use.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_must_use.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,17 +0,0 @@\n-### What it does\n-Checks for a `#[must_use]` attribute without\n-further information on functions and methods that return a type already\n-marked as `#[must_use]`.\n-\n-### Why is this bad?\n-The attribute isn't needed. Not using the result\n-will already be reported. Alternatively, one can add some text to the\n-attribute to improve the lint message.\n-\n-### Examples\n-```\n-#[must_use]\n-fn double_must_use() -> Result<(), ()> {\n-    unimplemented!();\n-}\n-```\n\\ No newline at end of file"}, {"sha": "a07f67496d7ccec92f2b90254a8bb68bd0632a1c", "filename": "src/tools/clippy/src/docs/double_neg.txt", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_neg.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_neg.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_neg.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,12 +0,0 @@\n-### What it does\n-Detects expressions of the form `--x`.\n-\n-### Why is this bad?\n-It can mislead C/C++ programmers to think `x` was\n-decremented.\n-\n-### Example\n-```\n-let mut x = 3;\n---x;\n-```\n\\ No newline at end of file"}, {"sha": "260d7dd575e55049891e8cdd4aae82da7675e507", "filename": "src/tools/clippy/src/docs/double_parens.txt", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_parens.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_parens.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdouble_parens.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,24 +0,0 @@\n-### What it does\n-Checks for unnecessary double parentheses.\n-\n-### Why is this bad?\n-This makes code harder to read and might indicate a\n-mistake.\n-\n-### Example\n-```\n-fn simple_double_parens() -> i32 {\n-    ((0))\n-}\n-\n-foo((0));\n-```\n-\n-Use instead:\n-```\n-fn simple_no_parens() -> i32 {\n-    0\n-}\n-\n-foo(0);\n-```\n\\ No newline at end of file"}, {"sha": "f917ca8ed21a69592c822db3bb9ca07dc863a006", "filename": "src/tools/clippy/src/docs/drop_copy.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_copy.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Checks for calls to `std::mem::drop` with a value\n-that derives the Copy trait\n-\n-### Why is this bad?\n-Calling `std::mem::drop` [does nothing for types that\n-implement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\n-value will be copied and moved into the function on invocation.\n-\n-### Example\n-```\n-let x: i32 = 42; // i32 implements Copy\n-std::mem::drop(x) // A copy of x is passed to the function, leaving the\n-                  // original unaffected\n-```\n\\ No newline at end of file"}, {"sha": "ee1e3a6c216efc33146496d279267cddb3f1e148", "filename": "src/tools/clippy/src/docs/drop_non_drop.txt", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_non_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_non_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_non_drop.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,13 +0,0 @@\n-### What it does\n-Checks for calls to `std::mem::drop` with a value that does not implement `Drop`.\n-\n-### Why is this bad?\n-Calling `std::mem::drop` is no different than dropping such a type. A different value may\n-have been intended.\n-\n-### Example\n-```\n-struct Foo;\n-let x = Foo;\n-std::mem::drop(x);\n-```\n\\ No newline at end of file"}, {"sha": "c4f7adf0cfa33d9359bfa54fa878950b62da84da", "filename": "src/tools/clippy/src/docs/drop_ref.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_ref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_ref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fdrop_ref.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,17 +0,0 @@\n-### What it does\n-Checks for calls to `std::mem::drop` with a reference\n-instead of an owned value.\n-\n-### Why is this bad?\n-Calling `drop` on a reference will only drop the\n-reference itself, which is a no-op. It will not call the `drop` method (from\n-the `Drop` trait implementation) on the underlying referenced value, which\n-is likely what was intended.\n-\n-### Example\n-```\n-let mut lock_guard = mutex.lock();\n-std::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n-// still locked\n-operation_that_requires_mutex_to_be_unlocked();\n-```\n\\ No newline at end of file"}, {"sha": "709a9aba03ad29d1519993a1fd689e6c9855da9c", "filename": "src/tools/clippy/src/docs/duplicate_mod.txt", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduplicate_mod.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduplicate_mod.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduplicate_mod.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,31 +0,0 @@\n-### What it does\n-Checks for files that are included as modules multiple times.\n-\n-### Why is this bad?\n-Loading a file as a module more than once causes it to be compiled\n-multiple times, taking longer and putting duplicate content into the\n-module tree.\n-\n-### Example\n-```\n-// lib.rs\n-mod a;\n-mod b;\n-```\n-```\n-// a.rs\n-#[path = \"./b.rs\"]\n-mod b;\n-```\n-\n-Use instead:\n-\n-```\n-// lib.rs\n-mod a;\n-mod b;\n-```\n-```\n-// a.rs\n-use crate::b;\n-```\n\\ No newline at end of file"}, {"sha": "a8fcd6a9fbe680cc7cd987ac16ff2d733879a15f", "filename": "src/tools/clippy/src/docs/duplicate_underscore_argument.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduplicate_underscore_argument.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduplicate_underscore_argument.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduplicate_underscore_argument.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for function arguments having the similar names\n-differing by an underscore.\n-\n-### Why is this bad?\n-It affects code readability.\n-\n-### Example\n-```\n-fn foo(a: i32, _a: i32) {}\n-```\n-\n-Use instead:\n-```\n-fn bar(a: i32, _b: i32) {}\n-```\n\\ No newline at end of file"}, {"sha": "e7e0ca88745ee1e616baf3b40734906fd72f05cb", "filename": "src/tools/clippy/src/docs/duration_subsec.txt", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduration_subsec.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduration_subsec.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fduration_subsec.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,19 +0,0 @@\n-### What it does\n-Checks for calculation of subsecond microseconds or milliseconds\n-from other `Duration` methods.\n-\n-### Why is this bad?\n-It's more concise to call `Duration::subsec_micros()` or\n-`Duration::subsec_millis()` than to calculate them.\n-\n-### Example\n-```\n-let micros = duration.subsec_nanos() / 1_000;\n-let millis = duration.subsec_nanos() / 1_000_000;\n-```\n-\n-Use instead:\n-```\n-let micros = duration.subsec_micros();\n-let millis = duration.subsec_millis();\n-```\n\\ No newline at end of file"}, {"sha": "33f5d0f9185920519b53728ed28ad90ee8dff1d0", "filename": "src/tools/clippy/src/docs/else_if_without_else.txt", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Felse_if_without_else.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Felse_if_without_else.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Felse_if_without_else.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,27 +0,0 @@\n-### What it does\n-Checks for usage of if expressions with an `else if` branch,\n-but without a final `else` branch.\n-\n-### Why is this bad?\n-Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).\n-\n-### Example\n-```\n-if x.is_positive() {\n-    a();\n-} else if x.is_negative() {\n-    b();\n-}\n-```\n-\n-Use instead:\n-\n-```\n-if x.is_positive() {\n-    a();\n-} else if x.is_negative() {\n-    b();\n-} else {\n-    // We don't care about zero.\n-}\n-```\n\\ No newline at end of file"}, {"sha": "d0c0c24a9c8802460603c23d738cf4dfda2be435", "filename": "src/tools/clippy/src/docs/empty_drop.txt", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_drop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_drop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_drop.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,20 +0,0 @@\n-### What it does\n-Checks for empty `Drop` implementations.\n-\n-### Why is this bad?\n-Empty `Drop` implementations have no effect when dropping an instance of the type. They are\n-most likely useless. However, an empty `Drop` implementation prevents a type from being\n-destructured, which might be the intention behind adding the implementation as a marker.\n-\n-### Example\n-```\n-struct S;\n-\n-impl Drop for S {\n-    fn drop(&mut self) {}\n-}\n-```\n-Use instead:\n-```\n-struct S;\n-```\n\\ No newline at end of file"}, {"sha": "f7b41c41ee5a1c146475336cd786ef70038120ae", "filename": "src/tools/clippy/src/docs/empty_enum.txt", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_enum.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_enum.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_enum.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,27 +0,0 @@\n-### What it does\n-Checks for `enum`s with no variants.\n-\n-As of this writing, the `never_type` is still a\n-nightly-only experimental API. Therefore, this lint is only triggered\n-if the `never_type` is enabled.\n-\n-### Why is this bad?\n-If you want to introduce a type which\n-can't be instantiated, you should use `!` (the primitive type \"never\"),\n-or a wrapper around it, because `!` has more extensive\n-compiler support (type inference, etc...) and wrappers\n-around it are the conventional way to define an uninhabited type.\n-For further information visit [never type documentation](https://doc.rust-lang.org/std/primitive.never.html)\n-\n-\n-### Example\n-```\n-enum Test {}\n-```\n-\n-Use instead:\n-```\n-#![feature(never_type)]\n-\n-struct Test(!);\n-```\n\\ No newline at end of file"}, {"sha": "c85242bbee0ec503c806db781256ea270c6a166a", "filename": "src/tools/clippy/src/docs/empty_line_after_outer_attr.txt", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_line_after_outer_attr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_line_after_outer_attr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_line_after_outer_attr.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,35 +0,0 @@\n-### What it does\n-Checks for empty lines after outer attributes\n-\n-### Why is this bad?\n-Most likely the attribute was meant to be an inner attribute using a '!'.\n-If it was meant to be an outer attribute, then the following item\n-should not be separated by empty lines.\n-\n-### Known problems\n-Can cause false positives.\n-\n-From the clippy side it's difficult to detect empty lines between an attributes and the\n-following item because empty lines and comments are not part of the AST. The parsing\n-currently works for basic cases but is not perfect.\n-\n-### Example\n-```\n-#[allow(dead_code)]\n-\n-fn not_quite_good_code() { }\n-```\n-\n-Use instead:\n-```\n-// Good (as inner attribute)\n-#![allow(dead_code)]\n-\n-fn this_is_fine() { }\n-\n-// or\n-\n-// Good (as outer attribute)\n-#[allow(dead_code)]\n-fn this_is_fine_too() { }\n-```\n\\ No newline at end of file"}, {"sha": "fea49a74d04e0cfebe15598e7848293327f02527", "filename": "src/tools/clippy/src/docs/empty_loop.txt", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_loop.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,27 +0,0 @@\n-### What it does\n-Checks for empty `loop` expressions.\n-\n-### Why is this bad?\n-These busy loops burn CPU cycles without doing\n-anything. It is _almost always_ a better idea to `panic!` than to have\n-a busy loop.\n-\n-If panicking isn't possible, think of the environment and either:\n-  - block on something\n-  - sleep the thread for some microseconds\n-  - yield or pause the thread\n-\n-For `std` targets, this can be done with\n-[`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\n-or [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n-\n-For `no_std` targets, doing this is more complicated, especially because\n-`#[panic_handler]`s can't panic. To stop/pause the thread, you will\n-probably need to invoke some target-specific intrinsic. Examples include:\n-  - [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n-  - [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)\n-\n-### Example\n-```\n-loop {}\n-```\n\\ No newline at end of file"}, {"sha": "ab5e35ae2ada8c475775f307275790b1bd7e16a2", "filename": "src/tools/clippy/src/docs/empty_structs_with_brackets.txt", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_structs_with_brackets.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_structs_with_brackets.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fempty_structs_with_brackets.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,14 +0,0 @@\n-### What it does\n-Finds structs without fields (a so-called \"empty struct\") that are declared with brackets.\n-\n-### Why is this bad?\n-Empty brackets after a struct declaration can be omitted.\n-\n-### Example\n-```\n-struct Cookie {}\n-```\n-Use instead:\n-```\n-struct Cookie;\n-```\n\\ No newline at end of file"}, {"sha": "d30a973a5a1357eab121909c688ad05f160de47e", "filename": "src/tools/clippy/src/docs/enum_clike_unportable_variant.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_clike_unportable_variant.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_clike_unportable_variant.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_clike_unportable_variant.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for C-like enumerations that are\n-`repr(isize/usize)` and have values that don't fit into an `i32`.\n-\n-### Why is this bad?\n-This will truncate the variant value on 32 bit\n-architectures, but works fine on 64 bit.\n-\n-### Example\n-```\n-#[repr(usize)]\n-enum NonPortable {\n-    X = 0x1_0000_0000,\n-    Y = 0,\n-}\n-```\n\\ No newline at end of file"}, {"sha": "3776822c35b0c21a9d6330c1b7a374c14cf8d232", "filename": "src/tools/clippy/src/docs/enum_glob_use.txt", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_glob_use.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_glob_use.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_glob_use.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,24 +0,0 @@\n-### What it does\n-Checks for `use Enum::*`.\n-\n-### Why is this bad?\n-It is usually better style to use the prefixed name of\n-an enumeration variant, rather than importing variants.\n-\n-### Known problems\n-Old-style enumerations that prefix the variants are\n-still around.\n-\n-### Example\n-```\n-use std::cmp::Ordering::*;\n-\n-foo(Less);\n-```\n-\n-Use instead:\n-```\n-use std::cmp::Ordering;\n-\n-foo(Ordering::Less)\n-```\n\\ No newline at end of file"}, {"sha": "e726925edda82ca777546cf7e613ee78304c10a0", "filename": "src/tools/clippy/src/docs/enum_variant_names.txt", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_variant_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_variant_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fenum_variant_names.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,30 +0,0 @@\n-### What it does\n-Detects enumeration variants that are prefixed or suffixed\n-by the same characters.\n-\n-### Why is this bad?\n-Enumeration variant names should specify their variant,\n-not repeat the enumeration name.\n-\n-### Limitations\n-Characters with no casing will be considered when comparing prefixes/suffixes\n-This applies to numbers and non-ascii characters without casing\n-e.g. `Foo1` and `Foo2` is considered to have different prefixes\n-(the prefixes are `Foo1` and `Foo2` respectively), as also `Bar\u8783`, `Bar\u87f9`\n-\n-### Example\n-```\n-enum Cake {\n-    BlackForestCake,\n-    HummingbirdCake,\n-    BattenbergCake,\n-}\n-```\n-Use instead:\n-```\n-enum Cake {\n-    BlackForest,\n-    Hummingbird,\n-    Battenberg,\n-}\n-```\n\\ No newline at end of file"}, {"sha": "2d75a0ec546e72043fb085d8cdfa4406311bc856", "filename": "src/tools/clippy/src/docs/eq_op.txt", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Feq_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Feq_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Feq_op.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,22 +0,0 @@\n-### What it does\n-Checks for equal operands to comparison, logical and\n-bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n-`||`, `&`, `|`, `^`, `-` and `/`).\n-\n-### Why is this bad?\n-This is usually just a typo or a copy and paste error.\n-\n-### Known problems\n-False negatives: We had some false positives regarding\n-calls (notably [racer](https://github.com/phildawes/racer) had one instance\n-of `x.pop() && x.pop()`), so we removed matching any function or method\n-calls. We may introduce a list of known pure functions in the future.\n-\n-### Example\n-```\n-if x + 1 == x + 1 {}\n-\n-// or\n-\n-assert_eq!(a, a);\n-```\n\\ No newline at end of file"}, {"sha": "9997046954c20d3779fe82a2384579dfc6ca8be0", "filename": "src/tools/clippy/src/docs/equatable_if_let.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fequatable_if_let.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fequatable_if_let.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fequatable_if_let.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-Checks for pattern matchings that can be expressed using equality.\n-\n-### Why is this bad?\n-\n-* It reads better and has less cognitive load because equality won't cause binding.\n-* It is a [Yoda condition](https://en.wikipedia.org/wiki/Yoda_conditions). Yoda conditions are widely\n-criticized for increasing the cognitive load of reading the code.\n-* Equality is a simple bool expression and can be merged with `&&` and `||` and\n-reuse if blocks\n-\n-### Example\n-```\n-if let Some(2) = x {\n-    do_thing();\n-}\n-```\n-Use instead:\n-```\n-if x == Some(2) {\n-    do_thing();\n-}\n-```\n\\ No newline at end of file"}, {"sha": "3d285a6d86e48f8e7e7ebbebd97b83ad5489c6f5", "filename": "src/tools/clippy/src/docs/erasing_op.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ferasing_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ferasing_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ferasing_op.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-Checks for erasing operations, e.g., `x * 0`.\n-\n-### Why is this bad?\n-The whole expression can be replaced by zero.\n-This is most likely not the intended outcome and should probably be\n-corrected\n-\n-### Example\n-```\n-let x = 1;\n-0 / x;\n-0 * x;\n-x & 0;\n-```\n\\ No newline at end of file"}, {"sha": "1dc83c5ce0ee05ded2a906da263f6f2cdbedcfe2", "filename": "src/tools/clippy/src/docs/err_expect.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ferr_expect.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ferr_expect.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ferr_expect.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for `.err().expect()` calls on the `Result` type.\n-\n-### Why is this bad?\n-`.expect_err()` can be called directly to avoid the extra type conversion from `err()`.\n-\n-### Example\n-```\n-let x: Result<u32, &str> = Ok(10);\n-x.err().expect(\"Testing err().expect()\");\n-```\n-Use instead:\n-```\n-let x: Result<u32, &str> = Ok(10);\n-x.expect_err(\"Testing expect_err\");\n-```\n\\ No newline at end of file"}, {"sha": "517879c47152b20fb30798b191cb0d627e403ca3", "filename": "src/tools/clippy/src/docs/excessive_precision.txt", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexcessive_precision.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexcessive_precision.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexcessive_precision.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,18 +0,0 @@\n-### What it does\n-Checks for float literals with a precision greater\n-than that supported by the underlying type.\n-\n-### Why is this bad?\n-Rust will truncate the literal silently.\n-\n-### Example\n-```\n-let v: f32 = 0.123_456_789_9;\n-println!(\"{}\", v); //  0.123_456_789\n-```\n-\n-Use instead:\n-```\n-let v: f64 = 0.123_456_789_9;\n-println!(\"{}\", v); //  0.123_456_789_9\n-```\n\\ No newline at end of file"}, {"sha": "d1032a7a29aa04d68b3384edfc0dcc9dd4b310a2", "filename": "src/tools/clippy/src/docs/exhaustive_enums.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexhaustive_enums.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexhaustive_enums.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexhaustive_enums.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-Warns on any exported `enum`s that are not tagged `#[non_exhaustive]`\n-\n-### Why is this bad?\n-Exhaustive enums are typically fine, but a project which does\n-not wish to make a stability commitment around exported enums may wish to\n-disable them by default.\n-\n-### Example\n-```\n-enum Foo {\n-    Bar,\n-    Baz\n-}\n-```\n-Use instead:\n-```\n-#[non_exhaustive]\n-enum Foo {\n-    Bar,\n-    Baz\n-}\n-```\n\\ No newline at end of file"}, {"sha": "fd6e4f5caf1f257b04d4f0712b064fe44eb40ff6", "filename": "src/tools/clippy/src/docs/exhaustive_structs.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexhaustive_structs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexhaustive_structs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexhaustive_structs.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-Warns on any exported `structs`s that are not tagged `#[non_exhaustive]`\n-\n-### Why is this bad?\n-Exhaustive structs are typically fine, but a project which does\n-not wish to make a stability commitment around exported structs may wish to\n-disable them by default.\n-\n-### Example\n-```\n-struct Foo {\n-    bar: u8,\n-    baz: String,\n-}\n-```\n-Use instead:\n-```\n-#[non_exhaustive]\n-struct Foo {\n-    bar: u8,\n-    baz: String,\n-}\n-```\n\\ No newline at end of file"}, {"sha": "1e6154d43e0538550a3c6b40f984d79d4bb259ea", "filename": "src/tools/clippy/src/docs/exit.txt", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexit.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexit.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexit.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,12 +0,0 @@\n-### What it does\n-`exit()`  terminates the program and doesn't provide a\n-stack trace.\n-\n-### Why is this bad?\n-Ideally a program is terminated by finishing\n-the main function.\n-\n-### Example\n-```\n-std::process::exit(0)\n-```\n\\ No newline at end of file"}, {"sha": "d82d9aa9baff240c08aa50ceb41107973ffb44a9", "filename": "src/tools/clippy/src/docs/expect_fun_call.txt", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpect_fun_call.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpect_fun_call.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpect_fun_call.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,24 +0,0 @@\n-### What it does\n-Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n-etc., and suggests to use `unwrap_or_else` instead\n-\n-### Why is this bad?\n-The function will always be called.\n-\n-### Known problems\n-If the function has side-effects, not calling it will\n-change the semantics of the program, but you shouldn't rely on that anyway.\n-\n-### Example\n-```\n-foo.expect(&format!(\"Err {}: {}\", err_code, err_msg));\n-\n-// or\n-\n-foo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str());\n-```\n-\n-Use instead:\n-```\n-foo.unwrap_or_else(|| panic!(\"Err {}: {}\", err_code, err_msg));\n-```\n\\ No newline at end of file"}, {"sha": "4a6981e334fd368b1b2d521d395506c8d7fdb494", "filename": "src/tools/clippy/src/docs/expect_used.txt", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpect_used.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpect_used.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpect_used.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,26 +0,0 @@\n-### What it does\n-Checks for `.expect()` or `.expect_err()` calls on `Result`s and `.expect()` call on `Option`s.\n-\n-### Why is this bad?\n-Usually it is better to handle the `None` or `Err` case.\n-Still, for a lot of quick-and-dirty code, `expect` is a good choice, which is why\n-this lint is `Allow` by default.\n-\n-`result.expect()` will let the thread panic on `Err`\n-values. Normally, you want to implement more sophisticated error handling,\n-and propagate errors upwards with `?` operator.\n-\n-### Examples\n-```\n-option.expect(\"one\");\n-result.expect(\"one\");\n-```\n-\n-Use instead:\n-```\n-option?;\n-\n-// or\n-\n-result?;\n-```\n\\ No newline at end of file"}, {"sha": "391d93b6713cca2005d7d14b2b97fd24c48e8098", "filename": "src/tools/clippy/src/docs/expl_impl_clone_on_copy.txt", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpl_impl_clone_on_copy.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpl_impl_clone_on_copy.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexpl_impl_clone_on_copy.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,20 +0,0 @@\n-### What it does\n-Checks for explicit `Clone` implementations for `Copy`\n-types.\n-\n-### Why is this bad?\n-To avoid surprising behavior, these traits should\n-agree and the behavior of `Copy` cannot be overridden. In almost all\n-situations a `Copy` type should have a `Clone` implementation that does\n-nothing more than copy the object, which is what `#[derive(Copy, Clone)]`\n-gets you.\n-\n-### Example\n-```\n-#[derive(Copy)]\n-struct Foo;\n-\n-impl Clone for Foo {\n-    // ..\n-}\n-```\n\\ No newline at end of file"}, {"sha": "65b256317725288a2f95142e309ca0effd3db921", "filename": "src/tools/clippy/src/docs/explicit_auto_deref.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_auto_deref.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_auto_deref.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_auto_deref.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for dereferencing expressions which would be covered by auto-deref.\n-\n-### Why is this bad?\n-This unnecessarily complicates the code.\n-\n-### Example\n-```\n-let x = String::new();\n-let y: &str = &*x;\n-```\n-Use instead:\n-```\n-let x = String::new();\n-let y: &str = &x;\n-```\n\\ No newline at end of file"}, {"sha": "2661a43e10341f95851551e53b0b7695bc308cf4", "filename": "src/tools/clippy/src/docs/explicit_counter_loop.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_counter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_counter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_counter_loop.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Checks `for` loops over slices with an explicit counter\n-and suggests the use of `.enumerate()`.\n-\n-### Why is this bad?\n-Using `.enumerate()` makes the intent more clear,\n-declutters the code and may be faster in some instances.\n-\n-### Example\n-```\n-let mut i = 0;\n-for item in &v {\n-    bar(i, *item);\n-    i += 1;\n-}\n-```\n-\n-Use instead:\n-```\n-for (i, item) in v.iter().enumerate() { bar(i, *item); }\n-```\n\\ No newline at end of file"}, {"sha": "e14e981c7073bee00239c22eb5420c6ca87669a3", "filename": "src/tools/clippy/src/docs/explicit_deref_methods.txt", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_deref_methods.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_deref_methods.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_deref_methods.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,24 +0,0 @@\n-### What it does\n-Checks for explicit `deref()` or `deref_mut()` method calls.\n-\n-### Why is this bad?\n-Dereferencing by `&*x` or `&mut *x` is clearer and more concise,\n-when not part of a method chain.\n-\n-### Example\n-```\n-use std::ops::Deref;\n-let a: &mut String = &mut String::from(\"foo\");\n-let b: &str = a.deref();\n-```\n-\n-Use instead:\n-```\n-let a: &mut String = &mut String::from(\"foo\");\n-let b = &*a;\n-```\n-\n-This lint excludes:\n-```\n-let _ = d.unwrap().deref();\n-```\n\\ No newline at end of file"}, {"sha": "3931dfd69a318d74f9112bd2ea4b7baff6757b7a", "filename": "src/tools/clippy/src/docs/explicit_into_iter_loop.txt", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_into_iter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_into_iter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_into_iter_loop.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,20 +0,0 @@\n-### What it does\n-Checks for loops on `y.into_iter()` where `y` will do, and\n-suggests the latter.\n-\n-### Why is this bad?\n-Readability.\n-\n-### Example\n-```\n-// with `y` a `Vec` or slice:\n-for x in y.into_iter() {\n-    // ..\n-}\n-```\n-can be rewritten to\n-```\n-for x in y {\n-    // ..\n-}\n-```\n\\ No newline at end of file"}, {"sha": "cabe72e91d04f6395df2a64f5180c9ec0ebe15e9", "filename": "src/tools/clippy/src/docs/explicit_iter_loop.txt", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_iter_loop.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_iter_loop.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_iter_loop.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,25 +0,0 @@\n-### What it does\n-Checks for loops on `x.iter()` where `&x` will do, and\n-suggests the latter.\n-\n-### Why is this bad?\n-Readability.\n-\n-### Known problems\n-False negatives. We currently only warn on some known\n-types.\n-\n-### Example\n-```\n-// with `y` a `Vec` or slice:\n-for x in y.iter() {\n-    // ..\n-}\n-```\n-\n-Use instead:\n-```\n-for x in &y {\n-    // ..\n-}\n-```\n\\ No newline at end of file"}, {"sha": "eafed5d39e5c63e48783ae846b87de9c1c901ffe", "filename": "src/tools/clippy/src/docs/explicit_write.txt", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_write.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_write.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fexplicit_write.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,18 +0,0 @@\n-### What it does\n-Checks for usage of `write!()` / `writeln()!` which can be\n-replaced with `(e)print!()` / `(e)println!()`\n-\n-### Why is this bad?\n-Using `(e)println! is clearer and more concise\n-\n-### Example\n-```\n-writeln!(&mut std::io::stderr(), \"foo: {:?}\", bar).unwrap();\n-writeln!(&mut std::io::stdout(), \"foo: {:?}\", bar).unwrap();\n-```\n-\n-Use instead:\n-```\n-eprintln!(\"foo: {:?}\", bar);\n-println!(\"foo: {:?}\", bar);\n-```\n\\ No newline at end of file"}, {"sha": "2f31dcf5f74013c933a071068115a2de1a20945e", "filename": "src/tools/clippy/src/docs/extend_with_drain.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fextend_with_drain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fextend_with_drain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fextend_with_drain.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Checks for occurrences where one vector gets extended instead of append\n-\n-### Why is this bad?\n-Using `append` instead of `extend` is more concise and faster\n-\n-### Example\n-```\n-let mut a = vec![1, 2, 3];\n-let mut b = vec![4, 5, 6];\n-\n-a.extend(b.drain(..));\n-```\n-\n-Use instead:\n-```\n-let mut a = vec![1, 2, 3];\n-let mut b = vec![4, 5, 6];\n-\n-a.append(&mut b);\n-```\n\\ No newline at end of file"}, {"sha": "bc1814aa4752dae2cf7574f3fa00b98553edd2ad", "filename": "src/tools/clippy/src/docs/extra_unused_lifetimes.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fextra_unused_lifetimes.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fextra_unused_lifetimes.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fextra_unused_lifetimes.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-Checks for lifetimes in generics that are never used\n-anywhere else.\n-\n-### Why is this bad?\n-The additional lifetimes make the code look more\n-complicated, while there is nothing out of the ordinary going on. Removing\n-them leads to more readable code.\n-\n-### Example\n-```\n-// unnecessary lifetimes\n-fn unused_lifetime<'a>(x: u8) {\n-    // ..\n-}\n-```\n-\n-Use instead:\n-```\n-fn no_lifetime(x: u8) {\n-    // ...\n-}\n-```\n\\ No newline at end of file"}, {"sha": "588a5bb103d46e8cccd30f84c1982069c9c1d5e7", "filename": "src/tools/clippy/src/docs/fallible_impl_from.txt", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffallible_impl_from.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffallible_impl_from.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffallible_impl_from.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,32 +0,0 @@\n-### What it does\n-Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n-\n-### Why is this bad?\n-`TryFrom` should be used if there's a possibility of failure.\n-\n-### Example\n-```\n-struct Foo(i32);\n-\n-impl From<String> for Foo {\n-    fn from(s: String) -> Self {\n-        Foo(s.parse().unwrap())\n-    }\n-}\n-```\n-\n-Use instead:\n-```\n-struct Foo(i32);\n-\n-impl TryFrom<String> for Foo {\n-    type Error = ();\n-    fn try_from(s: String) -> Result<Self, Self::Error> {\n-        if let Ok(parsed) = s.parse() {\n-            Ok(Foo(parsed))\n-        } else {\n-            Err(())\n-        }\n-    }\n-}\n-```\n\\ No newline at end of file"}, {"sha": "e58b7239fde9e039676d3208a95a8ebbcf991cce", "filename": "src/tools/clippy/src/docs/field_reassign_with_default.txt", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffield_reassign_with_default.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffield_reassign_with_default.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffield_reassign_with_default.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,23 +0,0 @@\n-### What it does\n-Checks for immediate reassignment of fields initialized\n-with Default::default().\n-\n-### Why is this bad?\n-It's more idiomatic to use the [functional update syntax](https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax).\n-\n-### Known problems\n-Assignments to patterns that are of tuple type are not linted.\n-\n-### Example\n-```\n-let mut a: A = Default::default();\n-a.i = 42;\n-```\n-\n-Use instead:\n-```\n-let a = A {\n-    i: 42,\n-    .. Default::default()\n-};\n-```\n\\ No newline at end of file"}, {"sha": "ad14bd62c4de483b76e3d6d04f85a6120614996d", "filename": "src/tools/clippy/src/docs/filetype_is_file.txt", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffiletype_is_file.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffiletype_is_file.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffiletype_is_file.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,29 +0,0 @@\n-### What it does\n-Checks for `FileType::is_file()`.\n-\n-### Why is this bad?\n-When people testing a file type with `FileType::is_file`\n-they are testing whether a path is something they can get bytes from. But\n-`is_file` doesn't cover special file types in unix-like systems, and doesn't cover\n-symlink in windows. Using `!FileType::is_dir()` is a better way to that intention.\n-\n-### Example\n-```\n-let metadata = std::fs::metadata(\"foo.txt\")?;\n-let filetype = metadata.file_type();\n-\n-if filetype.is_file() {\n-    // read file\n-}\n-```\n-\n-should be written as:\n-\n-```\n-let metadata = std::fs::metadata(\"foo.txt\")?;\n-let filetype = metadata.file_type();\n-\n-if !filetype.is_dir() {\n-    // read file\n-}\n-```\n\\ No newline at end of file"}, {"sha": "83b666f2e27820a7493ace384d6e5676dc81ed6d", "filename": "src/tools/clippy/src/docs/filter_map_identity.txt", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_map_identity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_map_identity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_map_identity.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,14 +0,0 @@\n-### What it does\n-Checks for usage of `filter_map(|x| x)`.\n-\n-### Why is this bad?\n-Readability, this can be written more concisely by using `flatten`.\n-\n-### Example\n-```\n-iter.filter_map(|x| x);\n-```\n-Use instead:\n-```\n-iter.flatten();\n-```\n\\ No newline at end of file"}, {"sha": "b38620b56a50fecc0abeb311a07f30a84c2a6bae", "filename": "src/tools/clippy/src/docs/filter_map_next.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_map_next.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_map_next.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_map_next.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for usage of `_.filter_map(_).next()`.\n-\n-### Why is this bad?\n-Readability, this can be written more concisely as\n-`_.find_map(_)`.\n-\n-### Example\n-```\n- (0..3).filter_map(|x| if x == 2 { Some(x) } else { None }).next();\n-```\n-Can be written as\n-\n-```\n- (0..3).find_map(|x| if x == 2 { Some(x) } else { None });\n-```\n\\ No newline at end of file"}, {"sha": "898a74166dc14649f0faa4fb561968049f14bc9a", "filename": "src/tools/clippy/src/docs/filter_next.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_next.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_next.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffilter_next.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for usage of `_.filter(_).next()`.\n-\n-### Why is this bad?\n-Readability, this can be written more concisely as\n-`_.find(_)`.\n-\n-### Example\n-```\n-vec.iter().filter(|x| **x == 0).next();\n-```\n-\n-Use instead:\n-```\n-vec.iter().find(|x| **x == 0);\n-```\n\\ No newline at end of file"}, {"sha": "a5ee79b4982fb753d1d99c77b40491d9b26c0013", "filename": "src/tools/clippy/src/docs/flat_map_identity.txt", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fflat_map_identity.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fflat_map_identity.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fflat_map_identity.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,14 +0,0 @@\n-### What it does\n-Checks for usage of `flat_map(|x| x)`.\n-\n-### Why is this bad?\n-Readability, this can be written more concisely by using `flatten`.\n-\n-### Example\n-```\n-iter.flat_map(|x| x);\n-```\n-Can be written as\n-```\n-iter.flatten();\n-```\n\\ No newline at end of file"}, {"sha": "d50b9156d3654c19262e8460e2ddf1f3d22a5483", "filename": "src/tools/clippy/src/docs/flat_map_option.txt", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fflat_map_option.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fflat_map_option.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Fflat_map_option.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,16 +0,0 @@\n-### What it does\n-Checks for usages of `Iterator::flat_map()` where `filter_map()` could be\n-used instead.\n-\n-### Why is this bad?\n-When applicable, `filter_map()` is more clear since it shows that\n-`Option` is used to produce 0 or 1 items.\n-\n-### Example\n-```\n-let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().flat_map(|x| x.parse().ok()).collect();\n-```\n-Use instead:\n-```\n-let nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().filter_map(|x| x.parse().ok()).collect();\n-```\n\\ No newline at end of file"}, {"sha": "1f9bce5abd59fdd52e2210a73ea648687a55c1ce", "filename": "src/tools/clippy/src/docs/float_arithmetic.txt", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_arithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_arithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_arithmetic.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,11 +0,0 @@\n-### What it does\n-Checks for float arithmetic.\n-\n-### Why is this bad?\n-For some embedded systems or kernel development, it\n-can be useful to rule out floating-point numbers.\n-\n-### Example\n-```\n-a + 1.0;\n-```\n\\ No newline at end of file"}, {"sha": "c19907c903e9df1d6592666ddc5f07bf58977841", "filename": "src/tools/clippy/src/docs/float_cmp.txt", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_cmp.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_cmp.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_cmp.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,28 +0,0 @@\n-### What it does\n-Checks for (in-)equality comparisons on floating-point\n-values (apart from zero), except in functions called `*eq*` (which probably\n-implement equality for a type involving floats).\n-\n-### Why is this bad?\n-Floating point calculations are usually imprecise, so\n-asking if two values are *exactly* equal is asking for trouble. For a good\n-guide on what to do, see [the floating point\n-guide](http://www.floating-point-gui.de/errors/comparison).\n-\n-### Example\n-```\n-let x = 1.2331f64;\n-let y = 1.2332f64;\n-\n-if y == 1.23f64 { }\n-if y != x {} // where both are floats\n-```\n-\n-Use instead:\n-```\n-let error_margin = f64::EPSILON; // Use an epsilon for comparison\n-// Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-// let error_margin = std::f64::EPSILON;\n-if (y - 1.23f64).abs() < error_margin { }\n-if (y - x).abs() > error_margin { }\n-```\n\\ No newline at end of file"}, {"sha": "9208feaacd81011198713479d3f80d72b33a2c41", "filename": "src/tools/clippy/src/docs/float_cmp_const.txt", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_cmp_const.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_cmp_const.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_cmp_const.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,26 +0,0 @@\n-### What it does\n-Checks for (in-)equality comparisons on floating-point\n-value and constant, except in functions called `*eq*` (which probably\n-implement equality for a type involving floats).\n-\n-### Why is this bad?\n-Floating point calculations are usually imprecise, so\n-asking if two values are *exactly* equal is asking for trouble. For a good\n-guide on what to do, see [the floating point\n-guide](http://www.floating-point-gui.de/errors/comparison).\n-\n-### Example\n-```\n-let x: f64 = 1.0;\n-const ONE: f64 = 1.00;\n-\n-if x == ONE { } // where both are floats\n-```\n-\n-Use instead:\n-```\n-let error_margin = f64::EPSILON; // Use an epsilon for comparison\n-// Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n-// let error_margin = std::f64::EPSILON;\n-if (x - ONE).abs() < error_margin { }\n-```\n\\ No newline at end of file"}, {"sha": "556b574e15d303a4b8c6774b1f9e94ec6b3c89dd", "filename": "src/tools/clippy/src/docs/float_equality_without_abs.txt", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_equality_without_abs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_equality_without_abs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffloat_equality_without_abs.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,26 +0,0 @@\n-### What it does\n-Checks for statements of the form `(a - b) < f32::EPSILON` or\n-`(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n-\n-### Why is this bad?\n-The code without `.abs()` is more likely to have a bug.\n-\n-### Known problems\n-If the user can ensure that b is larger than a, the `.abs()` is\n-technically unnecessary. However, it will make the code more robust and doesn't have any\n-large performance implications. If the abs call was deliberately left out for performance\n-reasons, it is probably better to state this explicitly in the code, which then can be done\n-with an allow.\n-\n-### Example\n-```\n-pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n-    (a - b) < f32::EPSILON\n-}\n-```\n-Use instead:\n-```\n-pub fn is_roughly_equal(a: f32, b: f32) -> bool {\n-    (a - b).abs() < f32::EPSILON\n-}\n-```\n\\ No newline at end of file"}, {"sha": "7d2b7b681deb15ff2edf37bf9b60d9b3cd60a3b7", "filename": "src/tools/clippy/src/docs/fn_address_comparisons.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_address_comparisons.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_address_comparisons.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_address_comparisons.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,17 +0,0 @@\n-### What it does\n-Checks for comparisons with an address of a function item.\n-\n-### Why is this bad?\n-Function item address is not guaranteed to be unique and could vary\n-between different code generation units. Furthermore different function items could have\n-the same address after being merged together.\n-\n-### Example\n-```\n-type F = fn();\n-fn a() {}\n-let f: F = a;\n-if f == a {\n-    // ...\n-}\n-```\n\\ No newline at end of file"}, {"sha": "2eae0563368c1adb6e91dc7080d1c839e5c07141", "filename": "src/tools/clippy/src/docs/fn_params_excessive_bools.txt", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_params_excessive_bools.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_params_excessive_bools.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_params_excessive_bools.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,31 +0,0 @@\n-### What it does\n-Checks for excessive use of\n-bools in function definitions.\n-\n-### Why is this bad?\n-Calls to such functions\n-are confusing and error prone, because it's\n-hard to remember argument order and you have\n-no type system support to back you up. Using\n-two-variant enums instead of bools often makes\n-API easier to use.\n-\n-### Example\n-```\n-fn f(is_round: bool, is_hot: bool) { ... }\n-```\n-\n-Use instead:\n-```\n-enum Shape {\n-    Round,\n-    Spiky,\n-}\n-\n-enum Temperature {\n-    Hot,\n-    IceCold,\n-}\n-\n-fn f(shape: Shape, temperature: Temperature) { ... }\n-```\n\\ No newline at end of file"}, {"sha": "1f587f6d7176891c2999504b86bc80923eddf3ae", "filename": "src/tools/clippy/src/docs/fn_to_numeric_cast.txt", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,21 +0,0 @@\n-### What it does\n-Checks for casts of function pointers to something other than usize\n-\n-### Why is this bad?\n-Casting a function pointer to anything other than usize/isize is not portable across\n-architectures, because you end up losing bits if the target type is too small or end up with a\n-bunch of extra bits that waste space and add more instructions to the final binary than\n-strictly necessary for the problem\n-\n-Casting to isize also doesn't make sense since there are no signed addresses.\n-\n-### Example\n-```\n-fn fun() -> i32 { 1 }\n-let _ = fun as i64;\n-```\n-\n-Use instead:\n-```\n-let _ = fun as usize;\n-```\n\\ No newline at end of file"}, {"sha": "ee3c33d237255999c8332a1722c1a2e2248527d8", "filename": "src/tools/clippy/src/docs/fn_to_numeric_cast_any.txt", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast_any.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast_any.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast_any.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,35 +0,0 @@\n-### What it does\n-Checks for casts of a function pointer to any integer type.\n-\n-### Why is this bad?\n-Casting a function pointer to an integer can have surprising results and can occur\n-accidentally if parentheses are omitted from a function call. If you aren't doing anything\n-low-level with function pointers then you can opt-out of casting functions to integers in\n-order to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\n-pointer casts in your code.\n-\n-### Example\n-```\n-// fn1 is cast as `usize`\n-fn fn1() -> u16 {\n-    1\n-};\n-let _ = fn1 as usize;\n-```\n-\n-Use instead:\n-```\n-// maybe you intended to call the function?\n-fn fn2() -> u16 {\n-    1\n-};\n-let _ = fn2() as usize;\n-\n-// or\n-\n-// maybe you intended to cast it to a function type?\n-fn fn3() -> u16 {\n-    1\n-}\n-let _ = fn3 as fn() -> u16;\n-```\n\\ No newline at end of file"}, {"sha": "69f12fa319f184c12807d8f7037ba971a0c441b0", "filename": "src/tools/clippy/src/docs/fn_to_numeric_cast_with_truncation.txt", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1cbc45942d5c0f6eb5d94e3b10762ba541958035/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdocs%2Ffn_to_numeric_cast_with_truncation.txt?ref=1cbc45942d5c0f6eb5d94e3b10762ba541958035", "patch": "@@ -1,26 +0,0 @@\n-### What it does\n-Checks for casts of a function pointer to a numeric type not wide enough to\n-store address.\n-\n-### Why is this bad?\n-Such a cast discards some bits of the function's address. If this is intended, it would be more\n-clearly expressed by casting to usize first, then casting the usize to the intended type (with\n-a comment) to perform the truncation.\n-\n-### Example\n-```\n-fn fn1() -> i16 {\n-    1\n-};\n-let _ = fn1 as i32;\n-```\n-\n-Use instead:\n-```\n-// Cast to usize first, then comment with the reason for the truncation\n-fn fn1() -> i16 {\n-    1\n-};\n-let fn_ptr = fn1 as usize;\n-let fn_ptr_truncated = fn_ptr as i32;\n-```\n\\ No newline at end of file"}]}