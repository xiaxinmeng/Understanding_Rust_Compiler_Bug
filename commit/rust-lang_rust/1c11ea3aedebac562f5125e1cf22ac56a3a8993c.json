{"sha": "1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMTFlYTNhZWRlYmFjNTYyZjUxMjVlMWNmMjJhYzU2YTNhODk5M2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-22T03:15:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-22T03:15:48Z"}, "message": "Auto merge of #37602 - jseyfried:directory_ownership, r=nikomatsakis\n\nparser: simplify directory ownership semantics\n\nThis PR simplifies the semantics of \"directory ownership\". After this PR,\n - a non-inline module without a `#[path]` attribute (e.g. `mod foo;`) is allowed iff its parent module/block (whichever is nearer) is a directory owner,\n - an non-inline module is a directory owner iff its corresponding file is named `mod.rs` (c.f. [comment](https://github.com/rust-lang/rust/issues/32401#issuecomment-201021902)),\n - a block is never a directory owner (c.f. #31534), and\n - an inline module is a directory owner iff either\n   - its parent module/block is a directory owner (again, c.f. #31534), or\n   - it has a `#[path]` attribute (c.f. #36789).\n\nThese semantics differ from today's in three orthogonal ways:\n - `#[path = \"foo.rs\"] mod foo;` is no longer a directory owner. This is a [breaking-change].\n - #36789 is generalized to apply to modules that are not directory owners in addition to blocks.\n - A macro-expanded non-inline module is only allowed where an ordinary non-inline module would be allowed. Today, we incorrectly allow macro-expanded non-inline modules in modules that are not directory owners (but not in blocks). This is a [breaking-change].\n\nFixes #32401.\nr? @nikomatsakis", "tree": {"sha": "1180560b8f50cc12c6476116044567d0a4a6b097", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1180560b8f50cc12c6476116044567d0a4a6b097"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "html_url": "https://github.com/rust-lang/rust/commit/1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82d8833a456a408fe8b761a3b5e88475b65066c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/82d8833a456a408fe8b761a3b5e88475b65066c8", "html_url": "https://github.com/rust-lang/rust/commit/82d8833a456a408fe8b761a3b5e88475b65066c8"}, {"sha": "fa8c53bae4592395565fc3c06cdcc093fc4b0dbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8c53bae4592395565fc3c06cdcc093fc4b0dbe", "html_url": "https://github.com/rust-lang/rust/commit/fa8c53bae4592395565fc3c06cdcc093fc4b0dbe"}], "stats": {"total": 287, "additions": 199, "deletions": 88}, "files": [{"sha": "c369bc10e94824955c2bd1285fc4259a7bfa0fc9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -204,6 +204,13 @@ declare_lint! {\n     \"detects extra requirements in impls that were erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub LEGACY_DIRECTORY_OWNERSHIP,\n+    Warn,\n+    \"non-inline, non-`#[path]` modules (e.g. `mod foo;`) were erroneously allowed in some files \\\n+     not named `mod.rs`\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -242,7 +249,8 @@ impl LintPass for HardwiredLints {\n             LIFETIME_UNDERSCORE,\n             SAFE_EXTERN_STATICS,\n             PATTERNS_IN_FNS_WITHOUT_BODY,\n-            EXTRA_REQUIREMENT_IN_IMPL\n+            EXTRA_REQUIREMENT_IN_IMPL,\n+            LEGACY_DIRECTORY_OWNERSHIP\n         )\n     }\n }"}, {"sha": "1a3ea5db871ebedc1363cba4e1f9550f9623fcbc", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -232,6 +232,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(EXTRA_REQUIREMENT_IN_IMPL),\n             reference: \"issue #37166 <https://github.com/rust-lang/rust/issues/37166>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(LEGACY_DIRECTORY_OWNERSHIP),\n+            reference: \"issue #37872 <https://github.com/rust-lang/rust/issues/37872>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "105155d75aba6c5228f592fc4670bf0100ed4e15", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -207,6 +207,13 @@ impl<'a> Visitor for AstValidator<'a> {\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n+                if let Some(attr) =\n+                        item.attrs.iter().find(|attr| attr.name() == \"warn_directory_ownership\") {\n+                    let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n+                    let msg = \"cannot declare a new module at this location\";\n+                    self.session.add_lint(lint, item.id, item.span, msg.to_string());\n+                    attr::mark_used(attr);\n+                }\n             }\n             ItemKind::Union(ref vdata, _) => {\n                 if !vdata.is_struct() {"}, {"sha": "ddbca47429d1876298601836b0ed032e2d1ed1b7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -18,7 +18,7 @@ use errors::DiagnosticBuilder;\n use ext::expand::{self, Expansion};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n-use parse::{self, parser};\n+use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n use ptr::P;\n use symbol::Symbol;\n@@ -568,9 +568,7 @@ pub struct ExpansionData {\n     pub depth: usize,\n     pub backtrace: ExpnId,\n     pub module: Rc<ModuleData>,\n-\n-    // True if non-inline modules without a `#[path]` are forbidden at the root of this expansion.\n-    pub no_noninline_mod: bool,\n+    pub directory_ownership: DirectoryOwnership,\n }\n \n /// One of these is made during expansion and incrementally updated as we go;\n@@ -601,7 +599,7 @@ impl<'a> ExtCtxt<'a> {\n                 depth: 0,\n                 backtrace: NO_EXPANSION,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n-                no_noninline_mod: false,\n+                directory_ownership: DirectoryOwnership::Owned,\n             },\n         }\n     }"}, {"sha": "fd6cae1e1b6688bbfdea9b91da5935b06d5fad99", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -21,7 +21,7 @@ use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use parse::{ParseSess, PResult, lexer};\n+use parse::{ParseSess, DirectoryOwnership, PResult, lexer};\n use parse::parser::Parser;\n use parse::token;\n use print::pprust;\n@@ -727,9 +727,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let no_noninline_mod = mem::replace(&mut self.cx.current_expansion.no_noninline_mod, true);\n+        let old_directory_ownership = self.cx.current_expansion.directory_ownership;\n+        self.cx.current_expansion.directory_ownership = DirectoryOwnership::UnownedViaBlock;\n         let result = noop_fold_block(block, self);\n-        self.cx.current_expansion.no_noninline_mod = no_noninline_mod;\n+        self.cx.current_expansion.directory_ownership = old_directory_ownership;\n         result\n     }\n \n@@ -768,7 +769,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                     return noop_fold_item(item, self);\n                 }\n \n-                let orig_no_noninline_mod = self.cx.current_expansion.no_noninline_mod;\n+                let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n                 module.mod_path.push(item.ident);\n \n@@ -779,23 +780,28 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {\n-                        self.cx.current_expansion.no_noninline_mod = false;\n+                        self.cx.current_expansion.directory_ownership = DirectoryOwnership::Owned;\n                         module.directory.push(&*path.as_str());\n                     } else {\n                         module.directory.push(&*item.ident.name.as_str());\n                     }\n                 } else {\n-                    self.cx.current_expansion.no_noninline_mod = false;\n-                    module.directory =\n+                    let mut path =\n                         PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner));\n-                    module.directory.pop();\n+                    let directory_ownership = match path.file_name().unwrap().to_str() {\n+                        Some(\"mod.rs\") => DirectoryOwnership::Owned,\n+                        _ => DirectoryOwnership::UnownedViaMod(false),\n+                    };\n+                    path.pop();\n+                    module.directory = path;\n+                    self.cx.current_expansion.directory_ownership = directory_ownership;\n                 }\n \n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let result = noop_fold_item(item, self);\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.no_noninline_mod = orig_no_noninline_mod;\n+                self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n                 return result;\n             }\n             // Ensure that test functions are accessible from the test harness."}, {"sha": "39b92c7d007dec77b151fd23129b3b9b0e02fbfb", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -13,7 +13,7 @@ use syntax_pos::{self, Pos, Span};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n-use parse::token;\n+use parse::{token, DirectoryOwnership};\n use parse;\n use print::pprust;\n use ptr::P;\n@@ -90,7 +90,8 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n     };\n     // The file will be added to the code map by the parser\n     let path = res_rel_file(cx, sp, Path::new(&file));\n-    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, true, None, sp);\n+    let directory_ownership = DirectoryOwnership::Owned;\n+    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, directory_ownership, None, sp);\n \n     struct ExpandResult<'a> {\n         p: parse::parser::Parser<'a>,"}, {"sha": "4164b4a93ec91d4c91d65bcc65950730eff905e5", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -19,7 +19,7 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n use parse::ParseSess;\n use parse::lexer::new_tt_reader;\n-use parse::parser::{Parser, Restrictions};\n+use parse::parser::Parser;\n use parse::token::{self, NtTT, Token};\n use parse::token::Token::*;\n use print;\n@@ -117,11 +117,12 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 let trncbr =\n                     new_tt_reader(&cx.parse_sess.span_diagnostic, Some(named_matches), rhs);\n                 let mut p = Parser::new(cx.parse_sess(), Box::new(trncbr));\n-                p.directory = cx.current_expansion.module.directory.clone();\n-                p.restrictions = match cx.current_expansion.no_noninline_mod {\n-                    true => Restrictions::NO_NONINLINE_MOD,\n-                    false => Restrictions::empty(),\n-                };\n+                let module = &cx.current_expansion.module;\n+                p.directory.path = module.directory.clone();\n+                p.directory.ownership = cx.current_expansion.directory_ownership;\n+                p.root_module_name =\n+                    module.mod_path.last().map(|id| (*id.name.as_str()).to_owned());\n+\n                 p.check_unknown_macro_variable();\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros."}, {"sha": "bfaf00a3d3f0814ee319772f306d564a2fea5c73", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -76,6 +76,19 @@ impl ParseSess {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct Directory {\n+    pub path: PathBuf,\n+    pub ownership: DirectoryOwnership,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum DirectoryOwnership {\n+    Owned,\n+    UnownedViaBlock,\n+    UnownedViaMod(bool /* legacy warnings? */),\n+}\n+\n // a bunch of utility functions of the form parse_<thing>_from_<source>\n // where <thing> includes crate, expr, item, stmt, tts, and one that\n // uses a HOF to parse anything, and <source> includes file and\n@@ -152,11 +165,11 @@ pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path) -> Parser<'a>\n /// On an error, use the given span as the source of the problem.\n pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n                                     path: &Path,\n-                                    owns_directory: bool,\n+                                    directory_ownership: DirectoryOwnership,\n                                     module_name: Option<String>,\n                                     sp: Span) -> Parser<'a> {\n     let mut p = filemap_to_parser(sess, file_to_filemap(sess, path, Some(sp)));\n-    p.owns_directory = owns_directory;\n+    p.directory.ownership = directory_ownership;\n     p.root_module_name = module_name;\n     p\n }"}, {"sha": "b00e6b5d58f04011e6efcff9b87b70c9421079d6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 82, "deletions": 60, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -38,7 +38,7 @@ use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast::{BinOpKind, UnOp};\n-use ast;\n+use {ast, attr};\n use codemap::{self, CodeMap, Spanned, spanned, respan};\n use syntax_pos::{self, Span, BytePos, mk_sp};\n use errors::{self, DiagnosticBuilder};\n@@ -49,7 +49,7 @@ use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::ObsoleteSyntax;\n use parse::token::{self, MatchNt, SubstNt};\n-use parse::{new_sub_parser_from_file, ParseSess};\n+use parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n@@ -68,7 +68,6 @@ bitflags! {\n     flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n-        const NO_NONINLINE_MOD  = 1 << 2,\n     }\n }\n \n@@ -200,12 +199,9 @@ pub struct Parser<'a> {\n     /// extra detail when the same error is seen twice\n     pub obsolete_set: HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    pub directory: PathBuf,\n+    pub directory: Directory,\n     /// Stack of open delimiters and their spans. Used for error message.\n     pub open_braces: Vec<(token::DelimToken, Span)>,\n-    /// Flag if this parser \"owns\" the directory that it is currently parsing\n-    /// in. This will affect how nested files are looked up.\n-    pub owns_directory: bool,\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n@@ -245,8 +241,9 @@ pub struct ModulePath {\n }\n \n pub struct ModulePathSuccess {\n-    pub path: ::std::path::PathBuf,\n-    pub owns_directory: bool,\n+    pub path: PathBuf,\n+    pub directory_ownership: DirectoryOwnership,\n+    warn: bool,\n }\n \n pub struct ModulePathError {\n@@ -296,9 +293,8 @@ impl<'a> Parser<'a> {\n             quote_depth: 0,\n             parsing_token_tree: false,\n             obsolete_set: HashSet::new(),\n-            directory: PathBuf::new(),\n+            directory: Directory { path: PathBuf::new(), ownership: DirectoryOwnership::Owned },\n             open_braces: Vec::new(),\n-            owns_directory: true,\n             root_module_name: None,\n             expected_tokens: Vec::new(),\n             tts: Vec::new(),\n@@ -310,8 +306,8 @@ impl<'a> Parser<'a> {\n         parser.token = tok.tok;\n         parser.span = tok.sp;\n         if parser.span != syntax_pos::DUMMY_SP {\n-            parser.directory = PathBuf::from(sess.codemap().span_to_filename(parser.span));\n-            parser.directory.pop();\n+            parser.directory.path = PathBuf::from(sess.codemap().span_to_filename(parser.span));\n+            parser.directory.path.pop();\n         }\n         parser\n     }\n@@ -3966,9 +3962,11 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             // FIXME: Bad copy of attrs\n-            let restrictions = self.restrictions | Restrictions::NO_NONINLINE_MOD;\n-            match self.with_res(restrictions,\n-                                |this| this.parse_item_(attrs.clone(), false, true))? {\n+            let old_directory_ownership =\n+                mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+            let item = self.parse_item_(attrs.clone(), false, true)?;\n+            self.directory.ownership = old_directory_ownership;\n+            match item {\n                 Some(i) => Stmt {\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, i.span.hi),\n@@ -5271,38 +5269,53 @@ impl<'a> Parser<'a> {\n             self.bump();\n             if in_cfg {\n                 // This mod is in an external file. Let's go get it!\n-                let (m, attrs) = self.eval_src_mod(id, &outer_attrs, id_span)?;\n-                Ok((id, m, Some(attrs)))\n+                let ModulePathSuccess { path, directory_ownership, warn } =\n+                    self.submod_path(id, &outer_attrs, id_span)?;\n+                let (module, mut attrs) =\n+                    self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n+                if warn {\n+                    let attr = ast::Attribute {\n+                        id: attr::mk_attr_id(),\n+                        style: ast::AttrStyle::Outer,\n+                        value: ast::MetaItem {\n+                            name: Symbol::intern(\"warn_directory_ownership\"),\n+                            node: ast::MetaItemKind::Word,\n+                            span: syntax_pos::DUMMY_SP,\n+                        },\n+                        is_sugared_doc: false,\n+                        span: syntax_pos::DUMMY_SP,\n+                    };\n+                    attr::mark_known(&attr);\n+                    attrs.push(attr);\n+                }\n+                Ok((id, module, Some(attrs)))\n             } else {\n                 let placeholder = ast::Mod { inner: syntax_pos::DUMMY_SP, items: Vec::new() };\n                 Ok((id, ItemKind::Mod(placeholder), None))\n             }\n         } else {\n-            let directory = self.directory.clone();\n-            let restrictions = self.push_directory(id, &outer_attrs);\n+            let old_directory = self.directory.clone();\n+            self.push_directory(id, &outer_attrs);\n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mod_inner_lo = self.span.lo;\n             let attrs = self.parse_inner_attributes()?;\n-            let m = self.with_res(restrictions, |this| {\n-                this.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)\n-            })?;\n-            self.directory = directory;\n-            Ok((id, ItemKind::Mod(m), Some(attrs)))\n+            let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n+            self.directory = old_directory;\n+            Ok((id, ItemKind::Mod(module), Some(attrs)))\n         }\n     }\n \n-    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) -> Restrictions {\n-        if let Some(path) = ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            self.directory.push(&*path.as_str());\n-            self.restrictions - Restrictions::NO_NONINLINE_MOD\n+    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n+        if let Some(path) = attr::first_attr_value_str_by_name(attrs, \"path\") {\n+            self.directory.path.push(&*path.as_str());\n+            self.directory.ownership = DirectoryOwnership::Owned;\n         } else {\n-            self.directory.push(&*id.name.as_str());\n-            self.restrictions\n+            self.directory.path.push(&*id.name.as_str());\n         }\n     }\n \n     pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        ::attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d.as_str()))\n+        attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d.as_str()))\n     }\n \n     /// Returns either a path to a module, or .\n@@ -5317,8 +5330,16 @@ impl<'a> Parser<'a> {\n         let secondary_exists = codemap.file_exists(&secondary_path);\n \n         let result = match (default_exists, secondary_exists) {\n-            (true, false) => Ok(ModulePathSuccess { path: default_path, owns_directory: false }),\n-            (false, true) => Ok(ModulePathSuccess { path: secondary_path, owns_directory: true }),\n+            (true, false) => Ok(ModulePathSuccess {\n+                path: default_path,\n+                directory_ownership: DirectoryOwnership::UnownedViaMod(false),\n+                warn: false,\n+            }),\n+            (false, true) => Ok(ModulePathSuccess {\n+                path: secondary_path,\n+                directory_ownership: DirectoryOwnership::Owned,\n+                warn: false,\n+            }),\n             (false, false) => Err(ModulePathError {\n                 err_msg: format!(\"file not found for module `{}`\", mod_name),\n                 help_msg: format!(\"name the file either {} or {} inside the directory {:?}\",\n@@ -5346,13 +5367,20 @@ impl<'a> Parser<'a> {\n                    id: ast::Ident,\n                    outer_attrs: &[ast::Attribute],\n                    id_sp: Span) -> PResult<'a, ModulePathSuccess> {\n-        if let Some(p) = Parser::submod_path_from_attr(outer_attrs, &self.directory) {\n-            return Ok(ModulePathSuccess { path: p, owns_directory: true });\n+        if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n+            return Ok(ModulePathSuccess {\n+                directory_ownership: match path.file_name().and_then(|s| s.to_str()) {\n+                    Some(\"mod.rs\") => DirectoryOwnership::Owned,\n+                    _ => DirectoryOwnership::UnownedViaMod(true),\n+                },\n+                path: path,\n+                warn: false,\n+            });\n         }\n \n-        let paths = Parser::default_submod_path(id, &self.directory, self.sess.codemap());\n+        let paths = Parser::default_submod_path(id, &self.directory.path, self.sess.codemap());\n \n-        if self.restrictions.contains(Restrictions::NO_NONINLINE_MOD) {\n+        if let DirectoryOwnership::UnownedViaBlock = self.directory.ownership {\n             let msg =\n                 \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n             let mut err = self.diagnostic().struct_span_err(id_sp, msg);\n@@ -5362,10 +5390,15 @@ impl<'a> Parser<'a> {\n                 err.span_note(id_sp, &msg);\n             }\n             return Err(err);\n-        } else if !self.owns_directory {\n+        } else if let DirectoryOwnership::UnownedViaMod(warn) = self.directory.ownership {\n+            if warn {\n+                if let Ok(result) = paths.result {\n+                    return Ok(ModulePathSuccess { warn: true, ..result });\n+                }\n+            }\n             let mut err = self.diagnostic().struct_span_err(id_sp,\n                 \"cannot declare a new module at this location\");\n-            let this_module = match self.directory.file_name() {\n+            let this_module = match self.directory.path.file_name() {\n                 Some(file_name) => file_name.to_str().unwrap().to_owned(),\n                 None => self.root_module_name.as_ref().unwrap().clone(),\n             };\n@@ -5378,8 +5411,10 @@ impl<'a> Parser<'a> {\n                               &format!(\"... or maybe `use` the module `{}` instead \\\n                                         of possibly redeclaring it\",\n                                        paths.name));\n-            }\n-            return Err(err);\n+                return Err(err);\n+            } else {\n+                return Err(err);\n+            };\n         }\n \n         match paths.result {\n@@ -5390,25 +5425,11 @@ impl<'a> Parser<'a> {\n \n     /// Read a module from a source file.\n     fn eval_src_mod(&mut self,\n-                    id: ast::Ident,\n-                    outer_attrs: &[ast::Attribute],\n+                    path: PathBuf,\n+                    directory_ownership: DirectoryOwnership,\n+                    name: String,\n                     id_sp: Span)\n                     -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n-        let ModulePathSuccess { path, owns_directory } = self.submod_path(id,\n-                                                                          outer_attrs,\n-                                                                          id_sp)?;\n-\n-        self.eval_src_mod_from_path(path,\n-                                    owns_directory,\n-                                    id.to_string(),\n-                                    id_sp)\n-    }\n-\n-    fn eval_src_mod_from_path(&mut self,\n-                              path: PathBuf,\n-                              owns_directory: bool,\n-                              name: String,\n-                              id_sp: Span) -> PResult<'a, (ast::ItemKind, Vec<ast::Attribute> )> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n             let mut err = String::from(\"circular modules: \");\n@@ -5423,7 +5444,8 @@ impl<'a> Parser<'a> {\n         included_mod_stack.push(path.clone());\n         drop(included_mod_stack);\n \n-        let mut p0 = new_sub_parser_from_file(self.sess, &path, owns_directory, Some(name), id_sp);\n+        let mut p0 =\n+            new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n         let mod_inner_lo = p0.span.lo;\n         let mod_attrs = p0.parse_inner_attributes()?;\n         let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;"}, {"sha": "75e3426a399359ff32c9d5f4748bb9d5c5cc7973", "filename": "src/test/compile-fail/directory_ownership/backcompat-warnings.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fbackcompat-warnings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fbackcompat-warnings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fbackcompat-warnings.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: cannot declare a new module at this location\n+// error-pattern: will become a hard error\n+// error-pattern: compilation successful\n+\n+#![feature(rustc_attrs)]\n+\n+#[path=\"mod_file_not_owning_aux3.rs\"]\n+mod foo;\n+\n+#[rustc_error]\n+fn main() {}"}, {"sha": "8e631a64f7a27c0978fb35e18cb11ca88bcd4526", "filename": "src/test/compile-fail/directory_ownership/macro-expanded-mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "previous_filename": "src/test/compile-fail/macro-expanded-mod.rs"}, {"sha": "3ec34362da559d6c99ec9cfe801fbc1837ad2630", "filename": "src/test/compile-fail/directory_ownership/macro_expanded_mod_helper/foo/bar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fbar.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "previous_filename": "src/test/compile-fail/macro_expanded_mod_helper/foo/bar.rs"}, {"sha": "25fcf11ce175b3637aac9654d86f89721a20e84d", "filename": "src/test/compile-fail/directory_ownership/macro_expanded_mod_helper/foo/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmacro_expanded_mod_helper%2Ffoo%2Fmod.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "previous_filename": "src/test/compile-fail/macro_expanded_mod_helper/foo/mod.rs"}, {"sha": "adbcedd91f205ffe69d7f57099540a4a76cadb8a", "filename": "src/test/compile-fail/directory_ownership/mod_file_not_owning.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n // error-pattern: cannot declare a new module at this location\n \n mod mod_file_not_owning_aux1;", "previous_filename": "src/test/compile-fail/mod_file_not_owning.rs"}, {"sha": "4ac94a92e376c52e8e1487197d8fc73f087f41d2", "filename": "src/test/compile-fail/directory_ownership/mod_file_not_owning_aux1.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux1.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -10,4 +10,7 @@\n \n // ignore-test this is not a test\n \n-mod mod_file_not_owning_aux2;\n+macro_rules! m {\n+    () => { mod mod_file_not_owning_aux2; }\n+}\n+m!();", "previous_filename": "src/test/compile-fail/mod_file_not_owning_aux1.rs"}, {"sha": "41401d640f6242aa2ae5dd985a3d2a5236b79774", "filename": "src/test/compile-fail/directory_ownership/mod_file_not_owning_aux2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux2.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "previous_filename": "src/test/compile-fail/mod_file_not_owning_aux2.rs"}, {"sha": "3a164fd55d92702a01dbe8c6d7befdd3ca823b17", "filename": "src/test/compile-fail/directory_ownership/mod_file_not_owning_aux3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fmod_file_not_owning_aux3.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test this is not a test\n+\n+mod mod_file_not_owning_aux2;"}, {"sha": "c4ede12e8208277d5a7dd272442ac3fa4ca774cd", "filename": "src/test/compile-fail/directory_ownership/non-inline-mod-restriction.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "previous_filename": "src/test/compile-fail/non-inline-mod-restriction.rs"}, {"sha": "854f790befcf7b5917d19f5f931840f717777928", "filename": "src/test/compile-fail/directory_ownership/unowned_mod_with_path.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Funowned_mod_with_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Funowned_mod_with_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirectory_ownership%2Funowned_mod_with_path.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern: cannot declare a new module at this location\n+\n+// This is not a directory owner since the file name is not \"mod.rs\".\n+#[path = \"mod_file_not_owning_aux1.rs\"]\n+mod foo;"}, {"sha": "94770aa875b4258b04cc336e54fdcf11ad688d8e", "filename": "src/test/parse-fail/circular_modules_hello.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fparse-fail%2Fcircular_modules_hello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c11ea3aedebac562f5125e1cf22ac56a3a8993c/src%2Ftest%2Fparse-fail%2Fcircular_modules_hello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fcircular_modules_hello.rs?ref=1c11ea3aedebac562f5125e1cf22ac56a3a8993c", "patch": "@@ -12,6 +12,7 @@\n \n // ignore-test: this is an auxiliary file for circular-modules-main.rs\n \n+#[path = \"circular_modules_main.rs\"]\n mod circular_modules_main;\n \n pub fn say_hello() {"}]}