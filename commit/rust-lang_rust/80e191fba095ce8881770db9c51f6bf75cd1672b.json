{"sha": "80e191fba095ce8881770db9c51f6bf75cd1672b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZTE5MWZiYTA5NWNlODg4MTc3MGRiOWM1MWY2YmY3NWNkMTY3MmI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-12-06T18:21:23Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-12-07T17:36:28Z"}, "message": "introduce a region unification table and use it in dropck\n\nFixes #29844", "tree": {"sha": "1f3cb8d7f1fac0f4cfe06b39a8efc04c130af4f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f3cb8d7f1fac0f4cfe06b39a8efc04c130af4f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80e191fba095ce8881770db9c51f6bf75cd1672b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80e191fba095ce8881770db9c51f6bf75cd1672b", "html_url": "https://github.com/rust-lang/rust/commit/80e191fba095ce8881770db9c51f6bf75cd1672b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80e191fba095ce8881770db9c51f6bf75cd1672b/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dbdfb493357427a0f94ce09badef581f5d62bbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dbdfb493357427a0f94ce09badef581f5d62bbd", "html_url": "https://github.com/rust-lang/rust/commit/4dbdfb493357427a0f94ce09badef581f5d62bbd"}], "stats": {"total": 134, "additions": 123, "deletions": 11}, "files": [{"sha": "d677328e415a8a0085bd58b8dcbb2f7794711e1f", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=80e191fba095ce8881770db9c51f6bf75cd1672b", "patch": "@@ -1225,6 +1225,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n+    pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n+        where T: TypeFoldable<'tcx>\n+    {\n+        let mut r = resolve::OpportunisticTypeAndRegionResolver::new(self);\n+        value.fold_with(&mut r)\n+    }\n+\n     /// Resolves all type variables in `t` and then, if any were left\n     /// unresolved, substitutes an error type. This is used after the\n     /// main checking when doing a second pass before writeback. The"}, {"sha": "30cf6344e2332dd6a1fb65990232897eb18f5f2d", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=80e191fba095ce8881770db9c51f6bf75cd1672b", "patch": "@@ -20,6 +20,7 @@ pub use self::VarValue::*;\n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n+use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n@@ -234,15 +235,16 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     // bound on a variable and so forth, which can never be rolled\n     // back.\n     undo_log: RefCell<Vec<UndoLogEntry>>,\n+    unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n \n     // This contains the results of inference.  It begins as an empty\n     // option and only acquires a value after inference is complete.\n     values: RefCell<Option<Vec<VarValue>>>,\n }\n \n-#[derive(Debug)]\n pub struct RegionSnapshot {\n     length: usize,\n+    region_snapshot: unify::Snapshot<ty::RegionVid>,\n     skolemization_count: u32,\n }\n \n@@ -260,6 +262,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             skolemization_count: Cell::new(0),\n             bound_count: Cell::new(0),\n             undo_log: RefCell::new(Vec::new()),\n+            unification_table: RefCell::new(UnificationTable::new()),\n         }\n     }\n \n@@ -273,6 +276,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.undo_log.borrow_mut().push(OpenSnapshot);\n         RegionSnapshot {\n             length: length,\n+            region_snapshot: self.unification_table.borrow_mut().snapshot(),\n             skolemization_count: self.skolemization_count.get(),\n         }\n     }\n@@ -289,6 +293,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (*undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n         self.skolemization_count.set(snapshot.skolemization_count);\n+        self.unification_table.borrow_mut().commit(snapshot.region_snapshot);\n     }\n \n     pub fn rollback_to(&self, snapshot: RegionSnapshot) {\n@@ -328,6 +333,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let c = undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n         self.skolemization_count.set(snapshot.skolemization_count);\n+        self.unification_table.borrow_mut()\n+            .rollback_to(snapshot.region_snapshot);\n     }\n \n     pub fn num_vars(&self) -> u32 {\n@@ -340,7 +347,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n         self.var_origins.borrow_mut().push(origin.clone());\n-        let vid = RegionVid { index: id };\n+        let vid = self.unification_table.borrow_mut().new_key(());\n+        assert_eq!(vid.index, id);\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n@@ -460,6 +468,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             // equating regions.\n             self.make_subregion(origin.clone(), sub, sup);\n             self.make_subregion(origin, sup, sub);\n+\n+            if let (ty::ReVar(sub), ty::ReVar(sup)) = (sub, sup) {\n+                self.unification_table.borrow_mut().union(sub, sup);\n+            }\n         }\n     }\n \n@@ -568,6 +580,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n+    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region {\n+        ty::ReVar(self.unification_table.borrow_mut().find(rid))\n+    }\n+\n     fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap> {\n         match t {\n             Glb => &self.glbs,\n@@ -1312,6 +1328,13 @@ impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n     }\n }\n \n+impl fmt::Debug for RegionSnapshot {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"RegionSnapshot(length={},skolemization={})\",\n+               self.length, self.skolemization_count)\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for GenericKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "5190c658194f723da547c83803acce5ecde8e221", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=80e191fba095ce8881770db9c51f6bf75cd1672b", "patch": "@@ -45,6 +45,41 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx\n     }\n }\n \n+/// The opportunistic type and region resolver is similar to the\n+/// opportunistic type resolver, but also opportunistly resolves\n+/// regions. It is useful for canonicalization.\n+pub struct OpportunisticTypeAndRegionResolver<'a, 'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+        OpportunisticTypeAndRegionResolver { infcx: infcx }\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if !t.needs_infer() {\n+            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+        } else {\n+            let t0 = self.infcx.shallow_resolve(t);\n+            ty::fold::super_fold_ty(self, t0)\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+          ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n+          _ => r,\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // FULL TYPE RESOLUTION\n "}, {"sha": "85d7d67a0e3ca0bd480dc11599a07ac0a3ac87b4", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=80e191fba095ce8881770db9c51f6bf75cd1672b", "patch": "@@ -23,6 +23,13 @@ impl UnifyKey for ty::IntVid {\n     fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n }\n \n+impl UnifyKey for ty::RegionVid {\n+    type Value = ();\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::RegionVid { ty::RegionVid { index: i } }\n+    fn tag(_: Option<ty::RegionVid>) -> &'static str { \"RegionVid\" }\n+}\n+\n impl<'tcx> ToType<'tcx> for IntVarValue {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {"}, {"sha": "0fbe83674931c2bbf89be4ba3107840afcb4b1b9", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=80e191fba095ce8881770db9c51f6bf75cd1672b", "patch": "@@ -17,7 +17,6 @@ use middle::region;\n use middle::subst::{self, Subst};\n use middle::traits;\n use middle::ty::{self, Ty};\n-use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n use syntax::codemap::{self, Span};\n@@ -280,7 +279,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n             rcx: rcx,\n             span: span,\n             parent_scope: parent_scope,\n-            breadcrumbs: FnvHashSet()\n+            breadcrumbs: Vec::new(),\n         },\n         TypeContext::Root,\n         typ,\n@@ -341,7 +340,7 @@ enum TypeContext {\n struct DropckContext<'a, 'b: 'a, 'tcx: 'b> {\n     rcx: &'a mut Rcx<'b, 'tcx>,\n     /// types that have already been traversed\n-    breadcrumbs: FnvHashSet<Ty<'tcx>>,\n+    breadcrumbs: Vec<Ty<'tcx>>,\n     /// span for error reporting\n     span: Span,\n     /// the scope reachable dtorck types must outlive\n@@ -356,6 +355,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     depth: usize) -> Result<(), Error<'tcx>>\n {\n     let tcx = cx.rcx.tcx();\n+    let ty = cx.rcx.infcx().resolve_type_and_region_vars_if_possible(&ty);\n+\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems.\n     let recursion_limit = tcx.sess.recursion_limit.get();\n@@ -366,13 +367,19 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         return Err(Error::Overflow(context, ty))\n     }\n \n-    if !cx.breadcrumbs.insert(ty) {\n-        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-               {}ty: {} scope: {:?} - cached\",\n-               (0..depth).map(|_| ' ').collect::<String>(),\n-               ty, cx.parent_scope);\n-        return Ok(()); // we already visited this type\n+    for breadcrumb in &mut cx.breadcrumbs {\n+        *breadcrumb =\n+            cx.rcx.infcx().resolve_type_and_region_vars_if_possible(breadcrumb);\n+        if *breadcrumb == ty {\n+            debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+                   {}ty: {} scope: {:?} - cached\",\n+                   (0..depth).map(|_| ' ').collect::<String>(),\n+                   ty, cx.parent_scope);\n+            return Ok(()); // we already visited this type\n+        }\n     }\n+    cx.breadcrumbs.push(ty);\n+\n     debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n            {}ty: {} scope: {:?}\",\n            (0..depth).map(|_| ' ').collect::<String>(),"}, {"sha": "51df4d60f0459359bce4ebdd67092342060a8bf6", "filename": "src/test/run-pass/issue-29844.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Ftest%2Frun-pass%2Fissue-29844.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e191fba095ce8881770db9c51f6bf75cd1672b/src%2Ftest%2Frun-pass%2Fissue-29844.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29844.rs?ref=80e191fba095ce8881770db9c51f6bf75cd1672b", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::Arc;\n+\n+pub struct DescriptorSet<'a> {\n+    pub slots: Vec<AttachInfo<'a, Resources>>\n+}\n+\n+pub trait ResourcesTrait<'r>: Sized {\n+    type DescriptorSet: 'r;\n+}\n+\n+pub struct Resources;\n+\n+impl<'a> ResourcesTrait<'a> for Resources {\n+    type DescriptorSet = DescriptorSet<'a>;\n+}\n+\n+pub enum AttachInfo<'a, R: ResourcesTrait<'a>> {\n+    NextDescriptorSet(Arc<R::DescriptorSet>)\n+}\n+\n+fn main() {\n+    let _x = DescriptorSet {slots: Vec::new()};\n+}"}]}