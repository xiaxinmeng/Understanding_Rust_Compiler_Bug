{"sha": "99913c5ead4d4f82ecda525b5d6f25dfaf541517", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5OTEzYzVlYWQ0ZDRmODJlY2RhNTI1YjVkNmYyNWRmYWY1NDE1MTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-23T09:09:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-23T09:09:26Z"}, "message": "Auto merge of #38401 - redox-os:redox_cross, r=brson\n\nRedox Cross Compilation\n\nI will admit - there are things here that I wish I did not have to do. This completes the ability to create a cross compiler from the rust repository for `x86_64-unknown-redox`. I will document this PR with inline comments explaining some things.\n\n[View this gist to see how a cross compiler is built](https://gist.github.com/jackpot51/6680ad973986e84d69c79854249f2b7e)\n\nPrior discussion of a smaller change is here: https://github.com/rust-lang/rust/pull/38366", "tree": {"sha": "7aed01c2e7d415dd69eb76fd862b1a4f1e392d63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aed01c2e7d415dd69eb76fd862b1a4f1e392d63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99913c5ead4d4f82ecda525b5d6f25dfaf541517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99913c5ead4d4f82ecda525b5d6f25dfaf541517", "html_url": "https://github.com/rust-lang/rust/commit/99913c5ead4d4f82ecda525b5d6f25dfaf541517", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99913c5ead4d4f82ecda525b5d6f25dfaf541517/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82611a022468bb54476f149a0e77901ed48bcb9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/82611a022468bb54476f149a0e77901ed48bcb9a", "html_url": "https://github.com/rust-lang/rust/commit/82611a022468bb54476f149a0e77901ed48bcb9a"}, {"sha": "4dcb86767111149bcd233d6ac5c782d345d1e10b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dcb86767111149bcd233d6ac5c782d345d1e10b", "html_url": "https://github.com/rust-lang/rust/commit/4dcb86767111149bcd233d6ac5c782d345d1e10b"}], "stats": {"total": 1481, "additions": 1439, "deletions": 42}, "files": [{"sha": "34aee77ae2107fbe45fcb960d74d2ffdd5c57bf1", "filename": "mk/cfg/x86_64-unknown-redox.mk", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/mk%2Fcfg%2Fx86_64-unknown-redox.mk", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/mk%2Fcfg%2Fx86_64-unknown-redox.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-redox.mk?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1 @@\n+# rustbuild-only target"}, {"sha": "2bbec9e5fc2250aa222d754896487ddd6e949234", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -36,7 +36,8 @@ fn main() {\n     // targets, which means we have to build the alloc_jemalloc crate\n     // for targets like emscripten, even if we don't use it.\n     if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n-       target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") {\n+       target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") ||\n+       target.contains(\"redox\") {\n         println!(\"cargo:rustc-cfg=dummy_jemalloc\");\n         return;\n     }"}, {"sha": "4daa6cbb8465e58e7d939ef68617c46e0fc0b122", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -19,7 +19,7 @@\n             issue = \"27783\")]\n #![feature(allocator)]\n #![feature(staged_api)]\n-#![cfg_attr(unix, feature(libc))]\n+#![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values. In practice, the alignment is a\n@@ -71,7 +71,7 @@ pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n     imp::usable_size(size, align)\n }\n \n-#[cfg(unix)]\n+#[cfg(any(unix, target_os = \"redox\"))]\n mod imp {\n     extern crate libc;\n \n@@ -87,7 +87,7 @@ mod imp {\n         }\n     }\n \n-    #[cfg(target_os = \"android\")]\n+    #[cfg(any(target_os = \"android\", target_os = \"redox\"))]\n     unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n@@ -109,7 +109,7 @@ mod imp {\n         libc::memalign(align as libc::size_t, size as libc::size_t) as *mut u8\n     }\n \n-    #[cfg(not(target_os = \"android\"))]\n+    #[cfg(not(any(target_os = \"android\", target_os = \"redox\")))]\n     unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n         let mut out = ptr::null_mut();\n         let ret = libc::posix_memalign(&mut out, align as libc::size_t, size as libc::size_t);"}, {"sha": "44aa08e245873511bcc1d86302df813d9f2a8374", "filename": "src/libcompiler_builtins/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -242,7 +242,7 @@ fn main() {\n                          \"atomic_thread_fence.c\"]);\n     }\n \n-    if !target.contains(\"windows\") {\n+    if !target.contains(\"redox\") && !target.contains(\"windows\") {\n         sources.extend(&[\"emutls.c\"]);\n     }\n "}, {"sha": "e49e9bb7c3d9c7f2fd893f0ee0db81617b8db21f", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -1 +1 @@\n-Subproject commit 0ac39c5ccf6a04395b7c40dd62321cb91f63f160\n+Subproject commit e49e9bb7c3d9c7f2fd893f0ee0db81617b8db21f"}, {"sha": "ecc8042e9404f20d1fd777d51fbfc1b2fe76bd87", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -945,26 +945,20 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let vendor = &sess.target.target.target_vendor;\n     let max_atomic_width = sess.target.target.max_atomic_width();\n \n-    let fam = if let Some(ref fam) = sess.target.target.options.target_family {\n-        Symbol::intern(fam)\n-    } else if sess.target.target.options.is_like_windows {\n-        Symbol::intern(\"windows\")\n-    } else {\n-        Symbol::intern(\"unix\")\n-    };\n-\n     let mut ret = HashSet::new();\n     // Target bindings.\n     ret.insert((Symbol::intern(\"target_os\"), Some(Symbol::intern(os))));\n-    ret.insert((Symbol::intern(\"target_family\"), Some(fam)));\n+    if let Some(ref fam) = sess.target.target.options.target_family {\n+        ret.insert((Symbol::intern(\"target_family\"), Some(Symbol::intern(fam))));\n+        if fam == \"windows\" || fam == \"unix\" {\n+            ret.insert((Symbol::intern(fam), None));\n+        }\n+    }\n     ret.insert((Symbol::intern(\"target_arch\"), Some(Symbol::intern(arch))));\n     ret.insert((Symbol::intern(\"target_endian\"), Some(Symbol::intern(end))));\n     ret.insert((Symbol::intern(\"target_pointer_width\"), Some(Symbol::intern(wordsz))));\n     ret.insert((Symbol::intern(\"target_env\"), Some(Symbol::intern(env))));\n     ret.insert((Symbol::intern(\"target_vendor\"), Some(Symbol::intern(vendor))));\n-    if fam == \"windows\" || fam == \"unix\" {\n-        ret.insert((fam, None));\n-    }\n     if sess.target.target.options.has_elf_tls {\n         ret.insert((Symbol::intern(\"target_thread_local\"), None));\n     }"}, {"sha": "21a2d4293df77025700e162354fa90aeadb954b2", "filename": "src/librustc_back/target/apple_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -37,6 +37,7 @@ pub fn opts() -> TargetOptions {\n         function_sections: false,\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         is_like_osx: true,\n         has_rpath: true,\n         dll_prefix: \"lib\".to_string(),"}, {"sha": "62418e68d43415fe020671e30759bcf075d076ac", "filename": "src/librustc_back/target/bitrig_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         position_independent_executables: true,"}, {"sha": "dca33e45af7c7ffc656b02609dedf9dc537b4fa5", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "dca33e45af7c7ffc656b02609dedf9dc537b4fa5", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "8c517224201b2fe7b2e44b5a7812055c9a5cbfb0", "filename": "src/librustc_back/target/fuchsia_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "bfdc9faaa8a736b37addb6b2c67868ca5cf37c63", "filename": "src/librustc_back/target/haiku_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -17,6 +17,7 @@ pub fn opts() -> TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n         has_rpath: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         .. Default::default()\n     }"}, {"sha": "4b2ae9c8e699c1e23ca0f056afff69d02faf1ea1", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "8c37eb6986a7cd77a6887dcd75eaeaef4482de64", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -69,6 +69,7 @@ mod windows_base;\n mod windows_msvc_base;\n mod thumb_base;\n mod fuchsia_base;\n+mod redox_base;\n \n pub type TargetResult = Result<Target, String>;\n \n@@ -184,6 +185,8 @@ supported_targets! {\n     (\"aarch64-unknown-fuchsia\", aarch64_unknown_fuchsia),\n     (\"x86_64-unknown-fuchsia\", x86_64_unknown_fuchsia),\n \n+    (\"x86_64-unknown-redox\", x86_64_unknown_redox),\n+\n     (\"i386-apple-ios\", i386_apple_ios),\n     (\"x86_64-apple-ios\", x86_64_apple_ios),\n     (\"aarch64-apple-ios\", aarch64_apple_ios),"}, {"sha": "57179a68afd8e9ccdc79bb1f459296277bca6339", "filename": "src/librustc_back/target/netbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "12b8e8bdc88fd931e776664af40136cacf0afd81", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -15,6 +15,7 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n+        target_family: Some(\"unix\".to_string()),\n         linker_is_gnu: true,\n         has_rpath: true,\n         is_like_openbsd: true,"}, {"sha": "1dffff598096b9c8e4b310cff69f452a7a9665e5", "filename": "src/librustc_back/target/redox_base.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use PanicStrategy;\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        pre_link_args: vec![\n+            // We want to be able to strip as much executable code as possible\n+            // from the linker command line, and this flag indicates to the\n+            // linker that it can avoid linking in dynamic libraries that don't\n+            // actually satisfy any symbols up to that point (as with many other\n+            // resolutions the linker does). This option only applies to all\n+            // following libraries so we're sure to pass it as one of the first\n+            // arguments.\n+            \"-Wl,--as-needed\".to_string(),\n+\n+            // Always enable NX protection when it is available\n+            \"-Wl,-z,noexecstack\".to_string(),\n+\n+            // Static link\n+            \"-static\".to_string()\n+        ],\n+        late_link_args: vec![\n+            \"-lc\".to_string(),\n+            \"-lm\".to_string()\n+        ],\n+        executables: true,\n+        relocation_model: \"static\".to_string(),\n+        disable_redzone: true,\n+        eliminate_frame_pointer: false,\n+        target_family: None,\n+        linker_is_gnu: true,\n+        no_default_libraries: true,\n+        lib_allocation_crate: \"alloc_system\".to_string(),\n+        exe_allocation_crate: \"alloc_system\".to_string(),\n+        has_elf_tls: true,\n+        panic_strategy: PanicStrategy::Abort,\n+        .. Default::default()\n+    }\n+}"}, {"sha": "41323c9c26ba7290fc0b7216d68a477e17a3d7f5", "filename": "src/librustc_back/target/solaris_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fsolaris_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fsolaris_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fsolaris_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -16,6 +16,7 @@ pub fn opts() -> TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n         has_rpath: true,\n+        target_family: Some(\"unix\".to_string()),\n         is_like_solaris: true,\n         exe_allocation_crate: super::maybe_jemalloc(),\n "}, {"sha": "db02e142fcc8efac34aca9480845a87696be1cdf", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -24,6 +24,7 @@ pub fn opts() -> TargetOptions {\n         staticlib_prefix: \"\".to_string(),\n         staticlib_suffix: \".lib\".to_string(),\n         no_default_libraries: true,\n+        target_family: Some(\"windows\".to_string()),\n         is_like_windows: true,\n         allows_weak_linkage: false,\n         pre_link_args: vec!["}, {"sha": "efa215b419d7044fed385b8b176d2f664a6e3bc1", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -53,6 +53,7 @@ pub fn opts() -> TargetOptions {\n         exe_suffix: \".exe\".to_string(),\n         staticlib_prefix: \"\".to_string(),\n         staticlib_suffix: \".lib\".to_string(),\n+        target_family: Some(\"windows\".to_string()),\n         is_like_windows: true,\n         is_like_msvc: true,\n         pre_link_args: vec!["}, {"sha": "cecac06b235275a6b18162e7b532c9168ff983c3", "filename": "src/librustc_back/target/x86_64_unknown_redox.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_redox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_redox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_redox.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::redox_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.push(\"-m64\".to_string());\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-redox\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"redox\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "5e1c3a2851568aef8c15caf46f19488375fa9893", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -26,7 +26,7 @@ fn main() {\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n     if cfg!(feature = \"backtrace\") && !target.contains(\"apple\") && !target.contains(\"msvc\") &&\n-        !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") {\n+        !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") && !target.contains(\"redox\") {\n         build_libbacktrace(&host, &target);\n     }\n "}, {"sha": "8e7cc593dbdeddea4426fe3162724ab56bdde7b2", "filename": "src/libstd/sys/redox/ext/io.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -13,8 +13,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use fs;\n+use net;\n use sys;\n-use sys_common::{AsInner, FromInner, IntoInner};\n+use sys_common::{self, AsInner, FromInner, IntoInner};\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -89,58 +90,62 @@ impl IntoRawFd for fs::File {\n     }\n }\n \n-/*\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().as_inner().fd().raw()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().as_inner().fd().raw()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().as_inner().fd().raw()\n+    }\n }\n \n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::TcpStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n+        let file = sys::fs::File::from_inner(fd);\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(file))\n     }\n }\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::TcpListener {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n+        let file = sys::fs::File::from_inner(fd);\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(file))\n     }\n }\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::UdpSocket {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n+        let file = sys::fs::File::from_inner(fd);\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(file))\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawFd for net::TcpStream {\n     fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n+        self.into_inner().into_inner().into_fd().into_raw()\n     }\n }\n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawFd for net::TcpListener {\n     fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n+        self.into_inner().into_inner().into_fd().into_raw()\n     }\n }\n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawFd for net::UdpSocket {\n     fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n+        self.into_inner().into_inner().into_fd().into_raw()\n     }\n }\n-*/"}, {"sha": "5982bdd6549ca46a131810c60a4305851bc9a493", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -10,11 +10,10 @@\n \n #![allow(dead_code, missing_docs, bad_style)]\n \n-pub extern crate syscall;\n-\n use io::{self, ErrorKind};\n \n pub mod args;\n+#[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n pub mod backtrace;\n pub mod condvar;\n pub mod env;\n@@ -34,6 +33,7 @@ pub mod rand;\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod stdio;\n+pub mod syscall;\n pub mod thread;\n pub mod thread_local;\n pub mod time;"}, {"sha": "3fdf61cfed83c22cfd24c77f9d0b2109e4fd1c49", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -20,10 +20,11 @@ use vec::{IntoIter, Vec};\n \n use self::dns::{Dns, DnsQuery};\n \n-pub extern crate libc as netc;\n pub use self::tcp::{TcpStream, TcpListener};\n pub use self::udp::UdpSocket;\n \n+pub mod netc;\n+\n mod dns;\n mod tcp;\n mod udp;"}, {"sha": "03e1c9fffa4d0abdf78de2b08f4569bd197cf958", "filename": "src/libstd/sys/redox/net/netc.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fnetc.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub type in_addr_t = u32;\n+pub type in_port_t = u16;\n+\n+pub type socklen_t = u32;\n+pub type sa_family_t = u16;\n+\n+pub const AF_INET: sa_family_t = 1;\n+pub const AF_INET6: sa_family_t = 2;\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct in_addr {\n+    pub s_addr: in_addr_t,\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct in6_addr {\n+    pub s6_addr: [u8; 16],\n+    __align: [u32; 0],\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct sockaddr {\n+    pub sa_family: sa_family_t,\n+    pub sa_data: [u8; 14],\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct sockaddr_in {\n+    pub sin_family: sa_family_t,\n+    pub sin_port: in_port_t,\n+    pub sin_addr: in_addr,\n+    pub sin_zero: [u8; 8],\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub struct sockaddr_in6 {\n+    pub sin6_family: sa_family_t,\n+    pub sin6_port: in_port_t,\n+    pub sin6_flowinfo: u32,\n+    pub sin6_addr: in6_addr,\n+    pub sin6_scope_id: u32,\n+}"}, {"sha": "d5362c9f131f6b8149ec330f4cdcf69c920930fb", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -12,6 +12,7 @@ use io::{Error, ErrorKind, Result};\n use net::{SocketAddr, Shutdown};\n use path::Path;\n use sys::fs::{File, OpenOptions};\n+use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n use vec::Vec;\n \n@@ -112,6 +113,20 @@ impl TcpStream {\n     }\n }\n \n+impl AsInner<File> for TcpStream {\n+    fn as_inner(&self) -> &File { &self.0 }\n+}\n+\n+impl FromInner<File> for TcpStream {\n+    fn from_inner(file: File) -> TcpStream {\n+        TcpStream(file)\n+    }\n+}\n+\n+impl IntoInner<File> for TcpStream {\n+    fn into_inner(self) -> File { self.0 }\n+}\n+\n #[derive(Debug)]\n pub struct TcpListener(File);\n \n@@ -168,3 +183,17 @@ impl TcpListener {\n         Err(Error::new(ErrorKind::Other, \"TcpListener::set_ttl not implemented\"))\n     }\n }\n+\n+impl AsInner<File> for TcpListener {\n+    fn as_inner(&self) -> &File { &self.0 }\n+}\n+\n+impl FromInner<File> for TcpListener {\n+    fn from_inner(file: File) -> TcpListener {\n+        TcpListener(file)\n+    }\n+}\n+\n+impl IntoInner<File> for TcpListener {\n+    fn into_inner(self) -> File { self.0 }\n+}"}, {"sha": "607c66c2ba70e3bf54023e631d921b8b471cf784", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -13,6 +13,7 @@ use io::{Error, ErrorKind, Result};\n use net::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use path::Path;\n use sys::fs::{File, OpenOptions};\n+use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n \n use super::{path_to_peer_addr, path_to_local_addr};\n@@ -171,3 +172,17 @@ impl UdpSocket {\n         Err(Error::new(ErrorKind::Other, \"UdpSocket::leave_multicast_v6 not implemented\"))\n     }\n }\n+\n+impl AsInner<File> for UdpSocket {\n+    fn as_inner(&self) -> &File { &self.0 }\n+}\n+\n+impl FromInner<File> for UdpSocket {\n+    fn from_inner(file: File) -> UdpSocket {\n+        UdpSocket(file, UnsafeCell::new(None))\n+    }\n+}\n+\n+impl IntoInner<File> for UdpSocket {\n+    fn into_inner(self) -> File { self.0 }\n+}"}, {"sha": "eb28eca38bcd94a51015d281553d63d75f3b440f", "filename": "src/libstd/sys/redox/rand.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frand.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -9,15 +9,19 @@\n // except according to those terms.\n \n use io;\n-use libc;\n use rand::Rng;\n \n-pub struct OsRng;\n+// FIXME: Use rand:\n+pub struct OsRng {\n+    state: [u64; 2]\n+}\n \n impl OsRng {\n     /// Create a new `OsRng`.\n     pub fn new() -> io::Result<OsRng> {\n-        Ok(OsRng)\n+        Ok(OsRng {\n+            state: [0xBADF00D1, 0xDEADBEEF]\n+        })\n     }\n }\n \n@@ -26,7 +30,20 @@ impl Rng for OsRng {\n         self.next_u64() as u32\n     }\n     fn next_u64(&mut self) -> u64 {\n-        unsafe { libc::random() }\n+        // Store the first and second part.\n+        let mut x = self.state[0];\n+        let y = self.state[1];\n+\n+        // Put the second part into the first slot.\n+        self.state[0] = y;\n+        // Twist the first slot.\n+        x ^= x << 23;\n+        // Update the second slot.\n+        self.state[1] = x ^ y ^ (x >> 17) ^ (y >> 26);\n+\n+        // Generate the final integer.\n+        self.state[1].wrapping_add(y)\n+\n     }\n     fn fill_bytes(&mut self, buf: &mut [u8]) {\n         for chunk in buf.chunks_mut(8) {"}, {"sha": "9fb3961486df23c3b39eb41d4876acebe09a55d4", "filename": "src/libstd/sys/redox/syscall/arch/arm.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Farm.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::error::{Error, Result};\n+\n+pub unsafe fn syscall0(mut a: usize) -> Result<usize> {\n+    asm!(\"swi $$0\"\n+        : \"={r0}\"(a)\n+        : \"{r7}\"(a)\n+        : \"memory\"\n+        : \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall1(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"swi $$0\"\n+        : \"={r0}\"(a)\n+        : \"{r7}\"(a), \"{r0}\"(b)\n+        : \"memory\"\n+        : \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+// Clobbers all registers - special for clone\n+pub unsafe fn syscall1_clobber(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"swi $$0\"\n+        : \"={r0}\"(a)\n+        : \"{r7}\"(a), \"{r0}\"(b)\n+        : \"memory\", \"r0\", \"r1\", \"r2\", \"r3\", \"r4\"\n+        : \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> Result<usize> {\n+    asm!(\"swi $$0\"\n+        : \"={r0}\"(a)\n+        : \"{r7}\"(a), \"{r0}\"(b), \"{r1}\"(c)\n+        : \"memory\"\n+        : \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> Result<usize> {\n+    asm!(\"swi $$0\"\n+        : \"={r0}\"(a)\n+        : \"{r7}\"(a), \"{r0}\"(b), \"{r1}\"(c), \"{r2}\"(d)\n+        : \"memory\"\n+        : \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall4(mut a: usize, b: usize, c: usize, d: usize, e: usize) -> Result<usize> {\n+    asm!(\"swi $$0\"\n+        : \"={r0}\"(a)\n+        : \"{r7}\"(a), \"{r0}\"(b), \"{r1}\"(c), \"{r2}\"(d), \"{r3}\"(e)\n+        : \"memory\"\n+        : \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall5(mut a: usize, b: usize, c: usize, d: usize, e: usize, f: usize)\n+                       -> Result<usize> {\n+    asm!(\"swi $$0\"\n+        : \"={r0}\"(a)\n+        : \"{r7}\"(a), \"{r0}\"(b), \"{r1}\"(c), \"{r2}\"(d), \"{r3}\"(e), \"{r4}\"(f)\n+        : \"memory\"\n+        : \"volatile\");\n+\n+    Error::demux(a)\n+}"}, {"sha": "724a6b927f43a66df8dfaca1f33406264ee1fa6d", "filename": "src/libstd/sys/redox/syscall/arch/x86.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::error::{Error, Result};\n+\n+pub unsafe fn syscall0(mut a: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall1(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+// Clobbers all registers - special for clone\n+pub unsafe fn syscall1_clobber(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b)\n+        : \"memory\", \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall4(mut a: usize, b: usize, c: usize, d: usize, e: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d), \"{esi}\"(e)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall5(mut a: usize, b: usize, c: usize, d: usize, e: usize, f: usize)\n+                       -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={eax}\"(a)\n+        : \"{eax}\"(a), \"{ebx}\"(b), \"{ecx}\"(c), \"{edx}\"(d), \"{esi}\"(e), \"{edi}\"(f)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}"}, {"sha": "a321c31f207d0c2d2829249efa61c47a5babb5d7", "filename": "src/libstd/sys/redox/syscall/arch/x86_64.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Farch%2Fx86_64.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::error::{Error, Result};\n+\n+pub unsafe fn syscall0(mut a: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall1(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+// Clobbers all registers - special for clone\n+pub unsafe fn syscall1_clobber(mut a: usize, b: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b)\n+        : \"memory\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\",\n+          \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall2(mut a: usize, b: usize, c: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall3(mut a: usize, b: usize, c: usize, d: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall4(mut a: usize, b: usize, c: usize, d: usize, e: usize) -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d), \"{rsi}\"(e)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}\n+\n+pub unsafe fn syscall5(mut a: usize, b: usize, c: usize, d: usize, e: usize, f: usize)\n+                       -> Result<usize> {\n+    asm!(\"int 0x80\"\n+        : \"={rax}\"(a)\n+        : \"{rax}\"(a), \"{rbx}\"(b), \"{rcx}\"(c), \"{rdx}\"(d), \"{rsi}\"(e), \"{rdi}\"(f)\n+        : \"memory\"\n+        : \"intel\", \"volatile\");\n+\n+    Error::demux(a)\n+}"}, {"sha": "f58c240f31e65909c781d6890d5b26fd1bdb0cad", "filename": "src/libstd/sys/redox/syscall/call.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,300 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::arch::*;\n+use super::data::{Stat, StatVfs, TimeSpec};\n+use super::error::Result;\n+use super::number::*;\n+\n+use core::mem;\n+\n+/// Set the end of the process's heap\n+///\n+/// When `addr` is `0`, this function will return the current break.\n+///\n+/// When `addr` is nonzero, this function will attempt to set the end of the process's\n+/// heap to `addr` and return the new program break. The new program break should be\n+/// checked by the allocator, it may not be exactly `addr`, as it may be aligned to a page\n+/// boundary.\n+///\n+/// On error, `Err(ENOMEM)` will be returned indicating that no memory is available\n+pub unsafe fn brk(addr: usize) -> Result<usize> {\n+    syscall1(SYS_BRK, addr)\n+}\n+\n+/// Change the process's working directory\n+///\n+/// This function will attempt to set the process's working directory to `path`, which can be\n+/// either a relative, scheme relative, or absolute path.\n+///\n+/// On success, `Ok(0)` will be returned. On error, one of the following errors will be returned.\n+///\n+/// # Errors\n+///\n+/// * `EACCES` - permission is denied for one of the components of `path`, or `path`\n+/// * `EFAULT` - `path` does not point to the process's addressible memory\n+/// * `EIO` - an I/O error occured\n+/// * `ENOENT` - `path` does not exit\n+/// * `ENOTDIR` - `path` is not a directory\n+pub fn chdir(path: &str) -> Result<usize> {\n+    unsafe { syscall2(SYS_CHDIR, path.as_ptr() as usize, path.len()) }\n+}\n+\n+pub fn chmod(path: &str, mode: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_CHMOD, path.as_ptr() as usize, path.len(), mode) }\n+}\n+\n+/// Produce a fork of the current process, or a new process thread\n+pub unsafe fn clone(flags: usize) -> Result<usize> {\n+    syscall1_clobber(SYS_CLONE, flags)\n+}\n+\n+/// Close a file\n+pub fn close(fd: usize) -> Result<usize> {\n+    unsafe { syscall1(SYS_CLOSE, fd) }\n+}\n+\n+/// Get the current system time\n+pub fn clock_gettime(clock: usize, tp: &mut TimeSpec) -> Result<usize> {\n+    unsafe { syscall2(SYS_CLOCK_GETTIME, clock, tp as *mut TimeSpec as usize) }\n+}\n+\n+/// Copy and transform a file descriptor\n+pub fn dup(fd: usize, buf: &[u8]) -> Result<usize> {\n+    unsafe { syscall3(SYS_DUP, fd, buf.as_ptr() as usize, buf.len()) }\n+}\n+\n+/// Replace the current process with a new executable\n+pub fn execve(path: &str, args: &[[usize; 2]]) -> Result<usize> {\n+    unsafe { syscall4(SYS_EXECVE, path.as_ptr() as usize, path.len(),\n+                                  args.as_ptr() as usize, args.len()) }\n+}\n+\n+/// Exit the current process\n+pub fn exit(status: usize) -> Result<usize> {\n+    unsafe { syscall1(SYS_EXIT, status) }\n+}\n+\n+/// Register a file for event-based I/O\n+pub fn fcntl(fd: usize, cmd: usize, arg: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_FCNTL, fd, cmd, arg) }\n+}\n+\n+/// Register a file for event-based I/O\n+pub fn fevent(fd: usize, flags: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_FEVENT, fd, flags) }\n+}\n+\n+/// Map a file into memory\n+pub unsafe fn fmap(fd: usize, offset: usize, size: usize) -> Result<usize> {\n+    syscall3(SYS_FMAP, fd, offset, size)\n+}\n+\n+/// Unmap a memory-mapped file\n+pub unsafe fn funmap(addr: usize) -> Result<usize> {\n+    syscall1(SYS_FUNMAP, addr)\n+}\n+\n+/// Retrieve the canonical path of a file\n+pub fn fpath(fd: usize, buf: &mut [u8]) -> Result<usize> {\n+    unsafe { syscall3(SYS_FPATH, fd, buf.as_mut_ptr() as usize, buf.len()) }\n+}\n+\n+/// Get metadata about a file\n+pub fn fstat(fd: usize, stat: &mut Stat) -> Result<usize> {\n+    unsafe { syscall3(SYS_FSTAT, fd, stat as *mut Stat as usize, mem::size_of::<Stat>()) }\n+}\n+\n+/// Get metadata about a filesystem\n+pub fn fstatvfs(fd: usize, stat: &mut StatVfs) -> Result<usize> {\n+    unsafe { syscall3(SYS_FSTATVFS, fd, stat as *mut StatVfs as usize, mem::size_of::<StatVfs>()) }\n+}\n+\n+/// Sync a file descriptor to its underlying medium\n+pub fn fsync(fd: usize) -> Result<usize> {\n+    unsafe { syscall1(SYS_FSYNC, fd) }\n+}\n+\n+/// Truncate or extend a file to a specified length\n+pub fn ftruncate(fd: usize, len: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_FTRUNCATE, fd, len) }\n+}\n+\n+/// Fast userspace mutex\n+pub unsafe fn futex(addr: *mut i32, op: usize, val: i32, val2: usize, addr2: *mut i32)\n+                    -> Result<usize> {\n+    syscall5(SYS_FUTEX, addr as usize, op, (val as isize) as usize, val2, addr2 as usize)\n+}\n+\n+/// Get the current working directory\n+pub fn getcwd(buf: &mut [u8]) -> Result<usize> {\n+    unsafe { syscall2(SYS_GETCWD, buf.as_mut_ptr() as usize, buf.len()) }\n+}\n+\n+/// Get the effective group ID\n+pub fn getegid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETEGID) }\n+}\n+\n+/// Get the effective namespace\n+pub fn getens() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETENS) }\n+}\n+\n+/// Get the effective user ID\n+pub fn geteuid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETEUID) }\n+}\n+\n+/// Get the current group ID\n+pub fn getgid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETGID) }\n+}\n+\n+/// Get the current namespace\n+pub fn getns() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETNS) }\n+}\n+\n+/// Get the current process ID\n+pub fn getpid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETPID) }\n+}\n+\n+/// Get the current user ID\n+pub fn getuid() -> Result<usize> {\n+    unsafe { syscall0(SYS_GETUID) }\n+}\n+\n+/// Set the I/O privilege level\n+pub unsafe fn iopl(level: usize) -> Result<usize> {\n+    syscall1(SYS_IOPL, level)\n+}\n+\n+/// Send a signal `sig` to the process identified by `pid`\n+pub fn kill(pid: usize, sig: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_KILL, pid, sig) }\n+}\n+\n+/// Create a link to a file\n+pub unsafe fn link(old: *const u8, new: *const u8) -> Result<usize> {\n+    syscall2(SYS_LINK, old as usize, new as usize)\n+}\n+\n+/// Seek to `offset` bytes in a file descriptor\n+pub fn lseek(fd: usize, offset: isize, whence: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_LSEEK, fd, offset as usize, whence) }\n+}\n+\n+/// Make a new scheme namespace\n+pub fn mkns(schemes: &[[usize; 2]]) -> Result<usize> {\n+    unsafe { syscall2(SYS_MKNS, schemes.as_ptr() as usize, schemes.len()) }\n+}\n+\n+/// Sleep for the time specified in `req`\n+pub fn nanosleep(req: &TimeSpec, rem: &mut TimeSpec) -> Result<usize> {\n+    unsafe { syscall2(SYS_NANOSLEEP, req as *const TimeSpec as usize,\n+                                     rem as *mut TimeSpec as usize) }\n+}\n+\n+/// Open a file\n+pub fn open(path: &str, flags: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_OPEN, path.as_ptr() as usize, path.len(), flags) }\n+}\n+\n+/// Allocate pages, linearly in physical memory\n+pub unsafe fn physalloc(size: usize) -> Result<usize> {\n+    syscall1(SYS_PHYSALLOC, size)\n+}\n+\n+/// Free physically allocated pages\n+pub unsafe fn physfree(physical_address: usize, size: usize) -> Result<usize> {\n+    syscall2(SYS_PHYSFREE, physical_address, size)\n+}\n+\n+/// Map physical memory to virtual memory\n+pub unsafe fn physmap(physical_address: usize, size: usize, flags: usize) -> Result<usize> {\n+    syscall3(SYS_PHYSMAP, physical_address, size, flags)\n+}\n+\n+/// Unmap previously mapped physical memory\n+pub unsafe fn physunmap(virtual_address: usize) -> Result<usize> {\n+    syscall1(SYS_PHYSUNMAP, virtual_address)\n+}\n+\n+/// Create a pair of file descriptors referencing the read and write ends of a pipe\n+pub fn pipe2(fds: &mut [usize; 2], flags: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_PIPE2, fds.as_ptr() as usize, flags) }\n+}\n+\n+/// Read from a file descriptor into a buffer\n+pub fn read(fd: usize, buf: &mut [u8]) -> Result<usize> {\n+    unsafe { syscall3(SYS_READ, fd, buf.as_mut_ptr() as usize, buf.len()) }\n+}\n+\n+/// Remove a directory\n+pub fn rmdir(path: &str) -> Result<usize> {\n+    unsafe { syscall2(SYS_RMDIR, path.as_ptr() as usize, path.len()) }\n+}\n+\n+/// Set the current process group IDs\n+pub fn setregid(rgid: usize, egid: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_SETREGID, rgid, egid) }\n+}\n+\n+/// Make a new scheme namespace\n+pub fn setrens(rns: usize, ens: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_SETRENS, rns, ens) }\n+}\n+\n+/// Set the current process user IDs\n+pub fn setreuid(ruid: usize, euid: usize) -> Result<usize> {\n+    unsafe { syscall2(SYS_SETREUID, ruid, euid) }\n+}\n+\n+/// Remove a file\n+pub fn unlink(path: &str) -> Result<usize> {\n+    unsafe { syscall2(SYS_UNLINK, path.as_ptr() as usize, path.len()) }\n+}\n+\n+/// Convert a virtual address to a physical one\n+pub unsafe fn virttophys(virtual_address: usize) -> Result<usize> {\n+    syscall1(SYS_VIRTTOPHYS, virtual_address)\n+}\n+\n+/// Check if a child process has exited or received a signal\n+pub fn waitpid(pid: usize, status: &mut usize, options: usize) -> Result<usize> {\n+    unsafe { syscall3(SYS_WAITPID, pid, status as *mut usize as usize, options) }\n+}\n+\n+/// Write a buffer to a file descriptor\n+///\n+/// The kernel will attempt to write the bytes in `buf` to the file descriptor `fd`, returning\n+/// either an `Err`, explained below, or `Ok(count)` where `count` is the number of bytes which\n+/// were written.\n+///\n+/// # Errors\n+///\n+/// * `EAGAIN` - the file descriptor was opened with `O_NONBLOCK` and writing would block\n+/// * `EBADF` - the file descriptor is not valid or is not open for writing\n+/// * `EFAULT` - `buf` does not point to the process's addressible memory\n+/// * `EIO` - an I/O error occured\n+/// * `ENOSPC` - the device containing the file descriptor has no room for data\n+/// * `EPIPE` - the file descriptor refers to a pipe or socket whose reading end is closed\n+pub fn write(fd: usize, buf: &[u8]) -> Result<usize> {\n+    unsafe { syscall3(SYS_WRITE, fd, buf.as_ptr() as usize, buf.len()) }\n+}\n+\n+/// Yield the process's time slice to the kernel\n+///\n+/// This function will return Ok(0) on success\n+pub fn sched_yield() -> Result<usize> {\n+    unsafe { syscall0(SYS_YIELD) }\n+}"}, {"sha": "ac3946672a3dd19a2db88346ed7d297281d4afb8", "filename": "src/libstd/sys/redox/syscall/data.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::ops::{Deref, DerefMut};\n+use core::{mem, slice};\n+\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct Stat {\n+    pub st_dev: u64,\n+    pub st_ino: u64,\n+    pub st_mode: u16,\n+    pub st_nlink: u32,\n+    pub st_uid: u32,\n+    pub st_gid: u32,\n+    pub st_size: u64,\n+    pub st_blksize: u32,\n+    pub st_blocks: u64,\n+    pub st_mtime: u64,\n+    pub st_mtime_nsec: u32,\n+    pub st_atime: u64,\n+    pub st_atime_nsec: u32,\n+    pub st_ctime: u64,\n+    pub st_ctime_nsec: u32,\n+}\n+\n+impl Deref for Stat {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self as *const Stat as *const u8,\n+                                  mem::size_of::<Stat>()) as &[u8]\n+        }\n+    }\n+}\n+\n+impl DerefMut for Stat {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self as *mut Stat as *mut u8,\n+                                      mem::size_of::<Stat>()) as &mut [u8]\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct StatVfs {\n+    pub f_bsize: u32,\n+    pub f_blocks: u64,\n+    pub f_bfree: u64,\n+    pub f_bavail: u64,\n+}\n+\n+impl Deref for StatVfs {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self as *const StatVfs as *const u8,\n+                                  mem::size_of::<StatVfs>()) as &[u8]\n+        }\n+    }\n+}\n+\n+impl DerefMut for StatVfs {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self as *mut StatVfs as *mut u8,\n+                                      mem::size_of::<StatVfs>()) as &mut [u8]\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Default)]\n+#[repr(packed)]\n+pub struct TimeSpec {\n+    pub tv_sec: i64,\n+    pub tv_nsec: i32,\n+}"}, {"sha": "d8d78d550162ae3ef0f6750b8b82d39b3095bec1", "filename": "src/libstd/sys/redox/syscall/error.rs", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Ferror.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,325 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::{fmt, result};\n+\n+#[derive(Eq, PartialEq)]\n+pub struct Error {\n+    pub errno: i32,\n+}\n+\n+pub type Result<T> = result::Result<T, Error>;\n+\n+impl Error {\n+    pub fn new(errno: i32) -> Error {\n+        Error { errno: errno }\n+    }\n+\n+    pub fn mux(result: Result<usize>) -> usize {\n+        match result {\n+            Ok(value) => value,\n+            Err(error) => -error.errno as usize,\n+        }\n+    }\n+\n+    pub fn demux(value: usize) -> Result<usize> {\n+        let errno = -(value as i32);\n+        if errno >= 1 && errno < STR_ERROR.len() as i32 {\n+            Err(Error::new(errno))\n+        } else {\n+            Ok(value)\n+        }\n+    }\n+\n+    pub fn text(&self) -> &str {\n+        if let Some(description) = STR_ERROR.get(self.errno as usize) {\n+            description\n+        } else {\n+            \"Unknown Error\"\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> result::Result<(), fmt::Error> {\n+        f.write_str(self.text())\n+    }\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> result::Result<(), fmt::Error> {\n+        f.write_str(self.text())\n+    }\n+}\n+\n+pub const EPERM: i32 = 1;  /* Operation not permitted */\n+pub const ENOENT: i32 = 2;  /* No such file or directory */\n+pub const ESRCH: i32 = 3;  /* No such process */\n+pub const EINTR: i32 = 4;  /* Interrupted system call */\n+pub const EIO: i32 = 5;  /* I/O error */\n+pub const ENXIO: i32 = 6;  /* No such device or address */\n+pub const E2BIG: i32 = 7;  /* Argument list too long */\n+pub const ENOEXEC: i32 = 8;  /* Exec format error */\n+pub const EBADF: i32 = 9;  /* Bad file number */\n+pub const ECHILD: i32 = 10;  /* No child processes */\n+pub const EAGAIN: i32 = 11;  /* Try again */\n+pub const ENOMEM: i32 = 12;  /* Out of memory */\n+pub const EACCES: i32 = 13;  /* Permission denied */\n+pub const EFAULT: i32 = 14;  /* Bad address */\n+pub const ENOTBLK: i32 = 15;  /* Block device required */\n+pub const EBUSY: i32 = 16;  /* Device or resource busy */\n+pub const EEXIST: i32 = 17;  /* File exists */\n+pub const EXDEV: i32 = 18;  /* Cross-device link */\n+pub const ENODEV: i32 = 19;  /* No such device */\n+pub const ENOTDIR: i32 = 20;  /* Not a directory */\n+pub const EISDIR: i32 = 21;  /* Is a directory */\n+pub const EINVAL: i32 = 22;  /* Invalid argument */\n+pub const ENFILE: i32 = 23;  /* File table overflow */\n+pub const EMFILE: i32 = 24;  /* Too many open files */\n+pub const ENOTTY: i32 = 25;  /* Not a typewriter */\n+pub const ETXTBSY: i32 = 26;  /* Text file busy */\n+pub const EFBIG: i32 = 27;  /* File too large */\n+pub const ENOSPC: i32 = 28;  /* No space left on device */\n+pub const ESPIPE: i32 = 29;  /* Illegal seek */\n+pub const EROFS: i32 = 30;  /* Read-only file system */\n+pub const EMLINK: i32 = 31;  /* Too many links */\n+pub const EPIPE: i32 = 32;  /* Broken pipe */\n+pub const EDOM: i32 = 33;  /* Math argument out of domain of func */\n+pub const ERANGE: i32 = 34;  /* Math result not representable */\n+pub const EDEADLK: i32 = 35;  /* Resource deadlock would occur */\n+pub const ENAMETOOLONG: i32 = 36;  /* File name too long */\n+pub const ENOLCK: i32 = 37;  /* No record locks available */\n+pub const ENOSYS: i32 = 38;  /* Function not implemented */\n+pub const ENOTEMPTY: i32 = 39;  /* Directory not empty */\n+pub const ELOOP: i32 = 40;  /* Too many symbolic links encountered */\n+pub const EWOULDBLOCK: i32 = 41;  /* Operation would block */\n+pub const ENOMSG: i32 = 42;  /* No message of desired type */\n+pub const EIDRM: i32 = 43;  /* Identifier removed */\n+pub const ECHRNG: i32 = 44;  /* Channel number out of range */\n+pub const EL2NSYNC: i32 = 45;  /* Level 2 not synchronized */\n+pub const EL3HLT: i32 = 46;  /* Level 3 halted */\n+pub const EL3RST: i32 = 47;  /* Level 3 reset */\n+pub const ELNRNG: i32 = 48;  /* Link number out of range */\n+pub const EUNATCH: i32 = 49;  /* Protocol driver not attached */\n+pub const ENOCSI: i32 = 50;  /* No CSI structure available */\n+pub const EL2HLT: i32 = 51;  /* Level 2 halted */\n+pub const EBADE: i32 = 52;  /* Invalid exchange */\n+pub const EBADR: i32 = 53;  /* Invalid request descriptor */\n+pub const EXFULL: i32 = 54;  /* Exchange full */\n+pub const ENOANO: i32 = 55;  /* No anode */\n+pub const EBADRQC: i32 = 56;  /* Invalid request code */\n+pub const EBADSLT: i32 = 57;  /* Invalid slot */\n+pub const EDEADLOCK: i32 = 58; /* Resource deadlock would occur */\n+pub const EBFONT: i32 = 59;  /* Bad font file format */\n+pub const ENOSTR: i32 = 60;  /* Device not a stream */\n+pub const ENODATA: i32 = 61;  /* No data available */\n+pub const ETIME: i32 = 62;  /* Timer expired */\n+pub const ENOSR: i32 = 63;  /* Out of streams resources */\n+pub const ENONET: i32 = 64;  /* Machine is not on the network */\n+pub const ENOPKG: i32 = 65;  /* Package not installed */\n+pub const EREMOTE: i32 = 66;  /* Object is remote */\n+pub const ENOLINK: i32 = 67;  /* Link has been severed */\n+pub const EADV: i32 = 68;  /* Advertise error */\n+pub const ESRMNT: i32 = 69;  /* Srmount error */\n+pub const ECOMM: i32 = 70;  /* Communication error on send */\n+pub const EPROTO: i32 = 71;  /* Protocol error */\n+pub const EMULTIHOP: i32 = 72;  /* Multihop attempted */\n+pub const EDOTDOT: i32 = 73;  /* RFS specific error */\n+pub const EBADMSG: i32 = 74;  /* Not a data message */\n+pub const EOVERFLOW: i32 = 75;  /* Value too large for defined data type */\n+pub const ENOTUNIQ: i32 = 76;  /* Name not unique on network */\n+pub const EBADFD: i32 = 77;  /* File descriptor in bad state */\n+pub const EREMCHG: i32 = 78;  /* Remote address changed */\n+pub const ELIBACC: i32 = 79;  /* Can not access a needed shared library */\n+pub const ELIBBAD: i32 = 80;  /* Accessing a corrupted shared library */\n+pub const ELIBSCN: i32 = 81;  /* .lib section in a.out corrupted */\n+pub const ELIBMAX: i32 = 82;  /* Attempting to link in too many shared libraries */\n+pub const ELIBEXEC: i32 = 83;  /* Cannot exec a shared library directly */\n+pub const EILSEQ: i32 = 84;  /* Illegal byte sequence */\n+pub const ERESTART: i32 = 85;  /* Interrupted system call should be restarted */\n+pub const ESTRPIPE: i32 = 86;  /* Streams pipe error */\n+pub const EUSERS: i32 = 87;  /* Too many users */\n+pub const ENOTSOCK: i32 = 88;  /* Socket operation on non-socket */\n+pub const EDESTADDRREQ: i32 = 89;  /* Destination address required */\n+pub const EMSGSIZE: i32 = 90;  /* Message too long */\n+pub const EPROTOTYPE: i32 = 91;  /* Protocol wrong type for socket */\n+pub const ENOPROTOOPT: i32 = 92;  /* Protocol not available */\n+pub const EPROTONOSUPPORT: i32 = 93;  /* Protocol not supported */\n+pub const ESOCKTNOSUPPORT: i32 = 94;  /* Socket type not supported */\n+pub const EOPNOTSUPP: i32 = 95;  /* Operation not supported on transport endpoint */\n+pub const EPFNOSUPPORT: i32 = 96;  /* Protocol family not supported */\n+pub const EAFNOSUPPORT: i32 = 97;  /* Address family not supported by protocol */\n+pub const EADDRINUSE: i32 = 98;  /* Address already in use */\n+pub const EADDRNOTAVAIL: i32 = 99;  /* Cannot assign requested address */\n+pub const ENETDOWN: i32 = 100; /* Network is down */\n+pub const ENETUNREACH: i32 = 101; /* Network is unreachable */\n+pub const ENETRESET: i32 = 102; /* Network dropped connection because of reset */\n+pub const ECONNABORTED: i32 = 103; /* Software caused connection abort */\n+pub const ECONNRESET: i32 = 104; /* Connection reset by peer */\n+pub const ENOBUFS: i32 = 105; /* No buffer space available */\n+pub const EISCONN: i32 = 106; /* Transport endpoint is already connected */\n+pub const ENOTCONN: i32 = 107; /* Transport endpoint is not connected */\n+pub const ESHUTDOWN: i32 = 108; /* Cannot send after transport endpoint shutdown */\n+pub const ETOOMANYREFS: i32 = 109; /* Too many references: cannot splice */\n+pub const ETIMEDOUT: i32 = 110; /* Connection timed out */\n+pub const ECONNREFUSED: i32 = 111; /* Connection refused */\n+pub const EHOSTDOWN: i32 = 112; /* Host is down */\n+pub const EHOSTUNREACH: i32 = 113; /* No route to host */\n+pub const EALREADY: i32 = 114; /* Operation already in progress */\n+pub const EINPROGRESS: i32 = 115; /* Operation now in progress */\n+pub const ESTALE: i32 = 116; /* Stale NFS file handle */\n+pub const EUCLEAN: i32 = 117; /* Structure needs cleaning */\n+pub const ENOTNAM: i32 = 118; /* Not a XENIX named type file */\n+pub const ENAVAIL: i32 = 119; /* No XENIX semaphores available */\n+pub const EISNAM: i32 = 120; /* Is a named type file */\n+pub const EREMOTEIO: i32 = 121; /* Remote I/O error */\n+pub const EDQUOT: i32 = 122; /* Quota exceeded */\n+pub const ENOMEDIUM: i32 = 123; /* No medium found */\n+pub const EMEDIUMTYPE: i32 = 124; /* Wrong medium type */\n+pub const ECANCELED: i32 = 125; /* Operation Canceled */\n+pub const ENOKEY: i32 = 126; /* Required key not available */\n+pub const EKEYEXPIRED: i32 = 127; /* Key has expired */\n+pub const EKEYREVOKED: i32 = 128; /* Key has been revoked */\n+pub const EKEYREJECTED: i32 = 129; /* Key was rejected by service */\n+pub const EOWNERDEAD: i32 = 130; /* Owner died */\n+pub const ENOTRECOVERABLE: i32 = 131; /* State not recoverable */\n+\n+pub static STR_ERROR: [&'static str; 132] = [\"Success\",\n+                                             \"Operation not permitted\",\n+                                             \"No such file or directory\",\n+                                             \"No such process\",\n+                                             \"Interrupted system call\",\n+                                             \"I/O error\",\n+                                             \"No such device or address\",\n+                                             \"Argument list too long\",\n+                                             \"Exec format error\",\n+                                             \"Bad file number\",\n+                                             \"No child processes\",\n+                                             \"Try again\",\n+                                             \"Out of memory\",\n+                                             \"Permission denied\",\n+                                             \"Bad address\",\n+                                             \"Block device required\",\n+                                             \"Device or resource busy\",\n+                                             \"File exists\",\n+                                             \"Cross-device link\",\n+                                             \"No such device\",\n+                                             \"Not a directory\",\n+                                             \"Is a directory\",\n+                                             \"Invalid argument\",\n+                                             \"File table overflow\",\n+                                             \"Too many open files\",\n+                                             \"Not a typewriter\",\n+                                             \"Text file busy\",\n+                                             \"File too large\",\n+                                             \"No space left on device\",\n+                                             \"Illegal seek\",\n+                                             \"Read-only file system\",\n+                                             \"Too many links\",\n+                                             \"Broken pipe\",\n+                                             \"Math argument out of domain of func\",\n+                                             \"Math result not representable\",\n+                                             \"Resource deadlock would occur\",\n+                                             \"File name too long\",\n+                                             \"No record locks available\",\n+                                             \"Function not implemented\",\n+                                             \"Directory not empty\",\n+                                             \"Too many symbolic links encountered\",\n+                                             \"Operation would block\",\n+                                             \"No message of desired type\",\n+                                             \"Identifier removed\",\n+                                             \"Channel number out of range\",\n+                                             \"Level 2 not synchronized\",\n+                                             \"Level 3 halted\",\n+                                             \"Level 3 reset\",\n+                                             \"Link number out of range\",\n+                                             \"Protocol driver not attached\",\n+                                             \"No CSI structure available\",\n+                                             \"Level 2 halted\",\n+                                             \"Invalid exchange\",\n+                                             \"Invalid request descriptor\",\n+                                             \"Exchange full\",\n+                                             \"No anode\",\n+                                             \"Invalid request code\",\n+                                             \"Invalid slot\",\n+                                             \"Resource deadlock would occur\",\n+                                             \"Bad font file format\",\n+                                             \"Device not a stream\",\n+                                             \"No data available\",\n+                                             \"Timer expired\",\n+                                             \"Out of streams resources\",\n+                                             \"Machine is not on the network\",\n+                                             \"Package not installed\",\n+                                             \"Object is remote\",\n+                                             \"Link has been severed\",\n+                                             \"Advertise error\",\n+                                             \"Srmount error\",\n+                                             \"Communication error on send\",\n+                                             \"Protocol error\",\n+                                             \"Multihop attempted\",\n+                                             \"RFS specific error\",\n+                                             \"Not a data message\",\n+                                             \"Value too large for defined data type\",\n+                                             \"Name not unique on network\",\n+                                             \"File descriptor in bad state\",\n+                                             \"Remote address changed\",\n+                                             \"Can not access a needed shared library\",\n+                                             \"Accessing a corrupted shared library\",\n+                                             \".lib section in a.out corrupted\",\n+                                             \"Attempting to link in too many shared libraries\",\n+                                             \"Cannot exec a shared library directly\",\n+                                             \"Illegal byte sequence\",\n+                                             \"Interrupted system call should be restarted\",\n+                                             \"Streams pipe error\",\n+                                             \"Too many users\",\n+                                             \"Socket operation on non-socket\",\n+                                             \"Destination address required\",\n+                                             \"Message too long\",\n+                                             \"Protocol wrong type for socket\",\n+                                             \"Protocol not available\",\n+                                             \"Protocol not supported\",\n+                                             \"Socket type not supported\",\n+                                             \"Operation not supported on transport endpoint\",\n+                                             \"Protocol family not supported\",\n+                                             \"Address family not supported by protocol\",\n+                                             \"Address already in use\",\n+                                             \"Cannot assign requested address\",\n+                                             \"Network is down\",\n+                                             \"Network is unreachable\",\n+                                             \"Network dropped connection because of reset\",\n+                                             \"Software caused connection abort\",\n+                                             \"Connection reset by peer\",\n+                                             \"No buffer space available\",\n+                                             \"Transport endpoint is already connected\",\n+                                             \"Transport endpoint is not connected\",\n+                                             \"Cannot send after transport endpoint shutdown\",\n+                                             \"Too many references: cannot splice\",\n+                                             \"Connection timed out\",\n+                                             \"Connection refused\",\n+                                             \"Host is down\",\n+                                             \"No route to host\",\n+                                             \"Operation already in progress\",\n+                                             \"Operation now in progress\",\n+                                             \"Stale NFS file handle\",\n+                                             \"Structure needs cleaning\",\n+                                             \"Not a XENIX named type file\",\n+                                             \"No XENIX semaphores available\",\n+                                             \"Is a named type file\",\n+                                             \"Remote I/O error\",\n+                                             \"Quota exceeded\",\n+                                             \"No medium found\",\n+                                             \"Wrong medium type\",\n+                                             \"Operation Canceled\",\n+                                             \"Required key not available\",\n+                                             \"Key has expired\",\n+                                             \"Key has been revoked\",\n+                                             \"Key was rejected by service\",\n+                                             \"Owner died\",\n+                                             \"State not recoverable\"];"}, {"sha": "9f0d3e6f77955ec25de81e27a66dd77bc7101c08", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub const CLONE_VM: usize = 0x100;\n+pub const CLONE_FS: usize = 0x200;\n+pub const CLONE_FILES: usize = 0x400;\n+pub const CLONE_VFORK: usize = 0x4000;\n+\n+pub const CLOCK_REALTIME: usize = 1;\n+pub const CLOCK_MONOTONIC: usize = 4;\n+\n+pub const EVENT_NONE: usize = 0;\n+pub const EVENT_READ: usize = 1;\n+pub const EVENT_WRITE: usize = 2;\n+\n+pub const F_GETFL: usize = 1;\n+pub const F_SETFL: usize = 2;\n+\n+pub const FUTEX_WAIT: usize = 0;\n+pub const FUTEX_WAKE: usize = 1;\n+pub const FUTEX_REQUEUE: usize = 2;\n+\n+pub const MAP_WRITE: usize = 1;\n+pub const MAP_WRITE_COMBINE: usize = 2;\n+\n+pub const MODE_TYPE: u16 = 0xF000;\n+pub const MODE_DIR: u16 = 0x4000;\n+pub const MODE_FILE: u16 = 0x8000;\n+\n+pub const MODE_PERM: u16 = 0x0FFF;\n+pub const MODE_SETUID: u16 = 0o4000;\n+pub const MODE_SETGID: u16 = 0o2000;\n+\n+pub const O_RDONLY: usize =     0x0001_0000;\n+pub const O_WRONLY: usize =     0x0002_0000;\n+pub const O_RDWR: usize =       0x0003_0000;\n+pub const O_NONBLOCK: usize =   0x0004_0000;\n+pub const O_APPEND: usize =     0x0008_0000;\n+pub const O_SHLOCK: usize =     0x0010_0000;\n+pub const O_EXLOCK: usize =     0x0020_0000;\n+pub const O_ASYNC: usize =      0x0040_0000;\n+pub const O_FSYNC: usize =      0x0080_0000;\n+pub const O_CLOEXEC: usize =    0x0100_0000;\n+pub const O_CREAT: usize =      0x0200_0000;\n+pub const O_TRUNC: usize =      0x0400_0000;\n+pub const O_EXCL: usize =       0x0800_0000;\n+pub const O_DIRECTORY: usize =  0x1000_0000;\n+pub const O_STAT: usize =       0x2000_0000;\n+pub const O_ACCMODE: usize =    O_RDONLY | O_WRONLY | O_RDWR;\n+\n+pub const SEEK_SET: usize = 0;\n+pub const SEEK_CUR: usize = 1;\n+pub const SEEK_END: usize = 2;\n+\n+pub const SIGHUP: usize =   1;\n+pub const SIGINT: usize =   2;\n+pub const SIGQUIT: usize =  3;\n+pub const SIGILL: usize =   4;\n+pub const SIGTRAP: usize =  5;\n+pub const SIGABRT: usize =  6;\n+pub const SIGBUS: usize =   7;\n+pub const SIGFPE: usize =   8;\n+pub const SIGKILL: usize =  9;\n+pub const SIGUSR1: usize =  10;\n+pub const SIGSEGV: usize =  11;\n+pub const SIGUSR2: usize =  12;\n+pub const SIGPIPE: usize =  13;\n+pub const SIGALRM: usize =  14;\n+pub const SIGTERM: usize =  15;\n+pub const SIGSTKFLT: usize= 16;\n+pub const SIGCHLD: usize =  17;\n+pub const SIGCONT: usize =  18;\n+pub const SIGSTOP: usize =  19;\n+pub const SIGTSTP: usize =  20;\n+pub const SIGTTIN: usize =  21;\n+pub const SIGTTOU: usize =  22;\n+pub const SIGURG: usize =   23;\n+pub const SIGXCPU: usize =  24;\n+pub const SIGXFSZ: usize =  25;\n+pub const SIGVTALRM: usize= 26;\n+pub const SIGPROF: usize =  27;\n+pub const SIGWINCH: usize = 28;\n+pub const SIGIO: usize =    29;\n+pub const SIGPWR: usize =   30;\n+pub const SIGSYS: usize =   31;\n+\n+pub const WNOHANG: usize = 1;"}, {"sha": "ce789c269a7e0ab3bc5d0f88967101afc7c033bc", "filename": "src/libstd/sys/redox/syscall/mod.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fmod.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::arch::*;\n+pub use self::call::*;\n+pub use self::data::*;\n+pub use self::error::*;\n+pub use self::flag::*;\n+pub use self::number::*;\n+\n+#[cfg(target_arch = \"arm\")]\n+#[path=\"arch/arm.rs\"]\n+mod arch;\n+\n+#[cfg(target_arch = \"x86\")]\n+#[path=\"arch/x86.rs\"]\n+mod arch;\n+\n+#[cfg(target_arch = \"x86_64\")]\n+#[path=\"arch/x86_64.rs\"]\n+mod arch;\n+\n+/// Function definitions\n+pub mod call;\n+\n+/// Complex structures that are used for some system calls\n+pub mod data;\n+\n+/// All errors that can be generated by a system call\n+pub mod error;\n+\n+/// Flags used as an argument to many system calls\n+pub mod flag;\n+\n+/// Call numbers used by each system call\n+pub mod number;"}, {"sha": "358746cd20a2385c3351730bcad74bc8b8692c77", "filename": "src/libstd/sys/redox/syscall/number.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fnumber.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub const SYS_CLASS: usize =    0xF000_0000;\n+pub const SYS_CLASS_PATH: usize=0x1000_0000;\n+pub const SYS_CLASS_FILE: usize=0x2000_0000;\n+\n+pub const SYS_ARG: usize =      0x0F00_0000;\n+pub const SYS_ARG_SLICE: usize =0x0100_0000;\n+pub const SYS_ARG_MSLICE: usize=0x0200_0000;\n+pub const SYS_ARG_PATH: usize = 0x0300_0000;\n+\n+pub const SYS_RET: usize =      0x00F0_0000;\n+pub const SYS_RET_FILE: usize = 0x0010_0000;\n+\n+pub const SYS_LINK: usize =     SYS_CLASS_PATH | SYS_ARG_PATH | 9;\n+pub const SYS_OPEN: usize =     SYS_CLASS_PATH | SYS_RET_FILE | 5;\n+pub const SYS_CHMOD: usize =    SYS_CLASS_PATH | 15;\n+pub const SYS_RMDIR: usize =    SYS_CLASS_PATH | 84;\n+pub const SYS_UNLINK: usize =   SYS_CLASS_PATH | 10;\n+\n+pub const SYS_CLOSE: usize =    SYS_CLASS_FILE | 6;\n+pub const SYS_DUP: usize =      SYS_CLASS_FILE | SYS_RET_FILE | 41;\n+pub const SYS_READ: usize =     SYS_CLASS_FILE | SYS_ARG_MSLICE | 3;\n+pub const SYS_WRITE: usize =    SYS_CLASS_FILE | SYS_ARG_SLICE | 4;\n+pub const SYS_LSEEK: usize =    SYS_CLASS_FILE | 19;\n+pub const SYS_FCNTL: usize =    SYS_CLASS_FILE | 55;\n+pub const SYS_FEVENT: usize =   SYS_CLASS_FILE | 927;\n+pub const SYS_FMAP: usize =     SYS_CLASS_FILE | 90;\n+pub const SYS_FUNMAP: usize =   SYS_CLASS_FILE | 91;\n+pub const SYS_FPATH: usize =    SYS_CLASS_FILE | SYS_ARG_MSLICE | 928;\n+pub const SYS_FSTAT: usize =    SYS_CLASS_FILE | SYS_ARG_MSLICE | 28;\n+pub const SYS_FSTATVFS: usize = SYS_CLASS_FILE | SYS_ARG_MSLICE | 100;\n+pub const SYS_FSYNC: usize =    SYS_CLASS_FILE | 118;\n+pub const SYS_FTRUNCATE: usize =SYS_CLASS_FILE | 93;\n+\n+pub const SYS_BRK: usize =      45;\n+pub const SYS_CHDIR: usize =    12;\n+pub const SYS_CLOCK_GETTIME: usize = 265;\n+pub const SYS_CLONE: usize =    120;\n+pub const SYS_EXECVE: usize =   11;\n+pub const SYS_EXIT: usize =     1;\n+pub const SYS_FUTEX: usize =    240;\n+pub const SYS_GETCWD: usize =   183;\n+pub const SYS_GETEGID: usize =  202;\n+pub const SYS_GETENS: usize =   951;\n+pub const SYS_GETEUID: usize =  201;\n+pub const SYS_GETGID: usize =   200;\n+pub const SYS_GETNS: usize =    950;\n+pub const SYS_GETPID: usize =   20;\n+pub const SYS_GETUID: usize =   199;\n+pub const SYS_IOPL: usize =     110;\n+pub const SYS_KILL: usize =     37;\n+pub const SYS_MKNS: usize =     984;\n+pub const SYS_NANOSLEEP: usize =162;\n+pub const SYS_PHYSALLOC: usize =945;\n+pub const SYS_PHYSFREE: usize = 946;\n+pub const SYS_PHYSMAP: usize =  947;\n+pub const SYS_PHYSUNMAP: usize =948;\n+pub const SYS_VIRTTOPHYS: usize=949;\n+pub const SYS_PIPE2: usize =    331;\n+pub const SYS_SETREGID: usize = 204;\n+pub const SYS_SETRENS: usize =  952;\n+pub const SYS_SETREUID: usize = 203;\n+pub const SYS_WAITPID: usize =  7;\n+pub const SYS_YIELD: usize =    158;"}, {"sha": "82acbf934881dc1048dd98a151d15b900b170d22", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99913c5ead4d4f82ecda525b5d6f25dfaf541517/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=99913c5ead4d4f82ecda525b5d6f25dfaf541517", "patch": "@@ -914,6 +914,11 @@ fn use_color(opts: &TestOpts) -> bool {\n     }\n }\n \n+#[cfg(target_os = \"redox\")]\n+fn stdout_isatty() -> bool {\n+    // FIXME: Implement isatty on Redox\n+    false\n+}\n #[cfg(unix)]\n fn stdout_isatty() -> bool {\n     unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n@@ -1103,6 +1108,12 @@ fn get_concurrency() -> usize {\n         }\n     }\n \n+    #[cfg(target_os = \"redox\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: Implement num_cpus on Redox\n+        1\n+    }\n+\n     #[cfg(any(target_os = \"linux\",\n               target_os = \"macos\",\n               target_os = \"ios\","}]}