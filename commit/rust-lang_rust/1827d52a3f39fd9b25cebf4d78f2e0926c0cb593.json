{"sha": "1827d52a3f39fd9b25cebf4d78f2e0926c0cb593", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MjdkNTJhM2YzOWZkOWIyNWNlYmY0ZDc4ZjJlMDkyNmMwY2I1OTM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2018-11-04T10:23:45Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2018-12-30T13:47:11Z"}, "message": "rustc_typeck: Implement resolution advised in issue 45510.\n\nWhen resolving Fn traits, the compiler failed to take into account\noverloaded implementations.  To resolve this, we inform the trait dispatch\ncode that the arguments will becoming as a tuple of correct arity.", "tree": {"sha": "dbd72ae86be3ea9fb636204f5ac053bb5978f551", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbd72ae86be3ea9fb636204f5ac053bb5978f551"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1827d52a3f39fd9b25cebf4d78f2e0926c0cb593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1827d52a3f39fd9b25cebf4d78f2e0926c0cb593", "html_url": "https://github.com/rust-lang/rust/commit/1827d52a3f39fd9b25cebf4d78f2e0926c0cb593", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1827d52a3f39fd9b25cebf4d78f2e0926c0cb593/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6de9c13830c74551632f2a1b299778d9e62381ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/6de9c13830c74551632f2a1b299778d9e62381ff", "html_url": "https://github.com/rust-lang/rust/commit/6de9c13830c74551632f2a1b299778d9e62381ff"}], "stats": {"total": 20, "additions": 16, "deletions": 4}, "files": [{"sha": "5a79bec4dd72d4e80fd4e8a2ccedc77467f92484", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1827d52a3f39fd9b25cebf4d78f2e0926c0cb593/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1827d52a3f39fd9b25cebf4d78f2e0926c0cb593/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=1827d52a3f39fd9b25cebf4d78f2e0926c0cb593", "patch": "@@ -8,6 +8,7 @@ use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::{infer, traits};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_target::spec::abi;\n use syntax::ast::Ident;\n use syntax_pos::Span;\n@@ -46,7 +47,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut autoderef = self.autoderef(callee_expr.span, expr_ty);\n         let mut result = None;\n         while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_overloaded_call_step(call_expr, callee_expr, &autoderef);\n+            result = self.try_overloaded_call_step(call_expr, callee_expr, arg_exprs, &autoderef);\n         }\n         autoderef.finalize(self);\n \n@@ -79,6 +80,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         call_expr: &'gcx hir::Expr,\n         callee_expr: &'gcx hir::Expr,\n+        arg_exprs: &'gcx [hir::Expr],\n         autoderef: &Autoderef<'a, 'gcx, 'tcx>,\n     ) -> Option<CallStep<'tcx>> {\n         let adjusted_ty = autoderef.unambiguous_final_ty(self);\n@@ -142,7 +144,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        self.try_overloaded_call_traits(call_expr, adjusted_ty)\n+        self.try_overloaded_call_traits(call_expr, adjusted_ty, Some(arg_exprs))\n             .map(|(autoref, method)| {\n                 let mut adjustments = autoderef.adjust_steps(self, Needs::None);\n                 adjustments.extend(autoref);\n@@ -155,6 +157,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         call_expr: &hir::Expr,\n         adjusted_ty: Ty<'tcx>,\n+        opt_arg_exprs: Option<&'gcx [hir::Expr]>,\n     ) -> Option<(Option<Adjustment<'tcx>>, MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in &[\n@@ -179,12 +182,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => continue,\n             };\n \n+            let opt_input_types = opt_arg_exprs.map(|arg_exprs| [self.tcx.mk_tup(\n+                arg_exprs\n+                .iter()\n+                .map(|e| self.next_ty_var(\n+                    TypeVariableOrigin::TypeInference(e.span)\n+                ))\n+            )]);\n+            let opt_input_types = opt_input_types.as_ref().map(AsRef::as_ref);\n+\n             if let Some(ok) = self.lookup_method_in_trait(\n                 call_expr.span,\n                 method_name,\n                 trait_def_id,\n                 adjusted_ty,\n-                None,\n+                opt_input_types,\n             ) {\n                 let method = self.register_infer_ok_obligations(ok);\n                 let mut autoref = None;\n@@ -445,7 +457,7 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n             .is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n-        match fcx.try_overloaded_call_traits(self.call_expr, self.adjusted_ty) {\n+        match fcx.try_overloaded_call_traits(self.call_expr, self.adjusted_ty, None) {\n             Some((autoref, method_callee)) => {\n                 // One problem is that when we get here, we are going\n                 // to have a newly instantiated function signature"}]}