{"sha": "216bcfd66b63a9f60e41e4b736145f62edda4150", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNmJjZmQ2NmI2M2E5ZjYwZTQxZTRiNzM2MTQ1ZjYyZWRkYTQxNTA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-03T20:51:47Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:45Z"}, "message": "libcore: use unboxed closures in the fields of `Unfold`", "tree": {"sha": "4e69ecdb5b3a148831f9615d23a851fc87bff163", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e69ecdb5b3a148831f9615d23a851fc87bff163"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/216bcfd66b63a9f60e41e4b736145f62edda4150", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/216bcfd66b63a9f60e41e4b736145f62edda4150", "html_url": "https://github.com/rust-lang/rust/commit/216bcfd66b63a9f60e41e4b736145f62edda4150", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/216bcfd66b63a9f60e41e4b736145f62edda4150/comments", "author": null, "committer": null, "parents": [{"sha": "a50c587242903f5c3d69e3684c8a79d3dcd849b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a50c587242903f5c3d69e3684c8a79d3dcd849b7", "html_url": "https://github.com/rust-lang/rust/commit/a50c587242903f5c3d69e3684c8a79d3dcd849b7"}], "stats": {"total": 29, "additions": 18, "deletions": 11}, "files": [{"sha": "51ae0f4702966da86c21daec192022dde0a18041", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/216bcfd66b63a9f60e41e4b736145f62edda4150/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216bcfd66b63a9f60e41e4b736145f62edda4150/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=216bcfd66b63a9f60e41e4b736145f62edda4150", "patch": "@@ -2108,19 +2108,18 @@ impl<A, I, F> RandomAccessIterator<A> for Inspect<A, I, F> where\n /// }\n /// ```\n #[experimental]\n-pub struct Unfold<'a, A, St> {\n-    f: |&mut St|: 'a -> Option<A>,\n+pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+    f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n #[experimental]\n-impl<'a, A, St> Unfold<'a, A, St> {\n+impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n     #[inline]\n-    pub fn new<'a>(initial_state: St, f: |&mut St|: 'a -> Option<A>)\n-               -> Unfold<'a, A, St> {\n+    pub fn new(initial_state: St, f: F) -> Unfold<A, St, F> {\n         Unfold {\n             f: f,\n             state: initial_state\n@@ -2129,7 +2128,7 @@ impl<'a, A, St> Unfold<'a, A, St> {\n }\n \n #[experimental]\n-impl<'a, A, St> Iterator<A> for Unfold<'a, A, St> {\n+impl<A, St, F> Iterator<A> for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         (self.f)(&mut self.state)\n@@ -2456,18 +2455,24 @@ impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n     fn idx(&mut self, _: uint) -> Option<A> { Some(self.element.clone()) }\n }\n \n-type IterateState<'a, T> = (|T|: 'a -> T, Option<T>, bool);\n+type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n #[experimental]\n-pub type Iterate<'a, T> = Unfold<'a, T, IterateState<'a, T>>;\n+pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n #[experimental]\n-pub fn iterate<'a, T: Clone>(seed: T, f: |T|: 'a -> T) -> Iterate<'a, T> {\n-    Unfold::new((f, Some(seed), true), |st| {\n+pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n+    T: Clone,\n+    F: FnMut(T) -> T,\n+{\n+    fn next<T, F>(st: &mut IterateState<T, F>) -> Option<T> where\n+        T: Clone,\n+        F: FnMut(T) -> T,\n+    {\n         let &(ref mut f, ref mut val, ref mut first) = st;\n         if *first {\n             *first = false;\n@@ -2480,7 +2485,9 @@ pub fn iterate<'a, T: Clone>(seed: T, f: |T|: 'a -> T) -> Iterate<'a, T> {\n             }\n         }\n         val.clone()\n-    })\n+    }\n+\n+    Unfold::new((f, Some(seed), true), next)\n }\n \n /// Create a new iterator that endlessly repeats the element `elt`."}]}