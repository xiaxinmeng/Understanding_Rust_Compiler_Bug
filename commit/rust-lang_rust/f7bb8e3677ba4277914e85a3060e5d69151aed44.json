{"sha": "f7bb8e3677ba4277914e85a3060e5d69151aed44", "node_id": "C_kwDOAAsO6NoAKGY3YmI4ZTM2NzdiYTQyNzc5MTRlODVhMzA2MGU1ZDY5MTUxYWVkNDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-09T12:43:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-09T12:43:37Z"}, "message": "Auto merge of #92690 - matthiaskrgr:rollup-rw0oz05, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #92055 (Add release notes for 1.58)\n - #92490 (Move crate drop-down to search results page)\n - #92510 (Don't resolve blocks in foreign functions)\n - #92573 (expand: Refactor InvocationCollector visitor for better code reuse)\n - #92608 (rustdoc: Introduce a resolver cache for sharing data between early doc link resolution and later passes)\n - #92657 (Implemented const casts of raw pointers)\n - #92671 (Make `Atomic*::from_mut` return `&mut Atomic*`)\n - #92673 (Remove useless collapse toggle on \"all items\" page)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "47846c6f667683a6e5736242239cd4f686fa6ecd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47846c6f667683a6e5736242239cd4f686fa6ecd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7bb8e3677ba4277914e85a3060e5d69151aed44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7bb8e3677ba4277914e85a3060e5d69151aed44", "html_url": "https://github.com/rust-lang/rust/commit/f7bb8e3677ba4277914e85a3060e5d69151aed44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7bb8e3677ba4277914e85a3060e5d69151aed44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e19ca1d946269f7b7eb13171531caf2e16f42076", "url": "https://api.github.com/repos/rust-lang/rust/commits/e19ca1d946269f7b7eb13171531caf2e16f42076", "html_url": "https://github.com/rust-lang/rust/commit/e19ca1d946269f7b7eb13171531caf2e16f42076"}, {"sha": "e6aa48d3a7984ca928b8de65e544eab18b1605c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6aa48d3a7984ca928b8de65e544eab18b1605c2", "html_url": "https://github.com/rust-lang/rust/commit/e6aa48d3a7984ca928b8de65e544eab18b1605c2"}], "stats": {"total": 2195, "additions": 1339, "deletions": 856}, "files": [{"sha": "d6f5909a2ebc016eaf1fb4c354468843207fb3a3", "filename": "RELEASES.md", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1,3 +1,169 @@\n+Version 1.58.0 (2022-01-13)\n+==========================\n+\n+Language\n+--------\n+\n+- [Format strings can now capture arguments simply by writing `{ident}` in the string.][90473] This works in all macros accepting format strings. Support for this in `panic!` (`panic!(\"{ident}\")`) requires the 2021 edition; panic invocations in previous editions that appear to be trying to use this will result in a warning lint about not having the intended effect.\n+- [`*const T` pointers can now be dereferenced in const contexts.][89551]\n+- [The rules for when a generic struct implements `Unsize` have been relaxed.][90417]\n+\n+Compiler\n+--------\n+\n+- [Add LLVM CFI support to the Rust compiler][89652]\n+- [Stabilize -Z strip as -C strip][90058]. Note that while release builds already don't add debug symbols for the code you compile, the compiled standard library that ships with Rust includes debug symbols, so you may want to use the `strip` option to remove these symbols to produce smaller release binaries. Note that this release only includes support in rustc, not directly in cargo.\n+- [Add support for LLVM coverage mapping format versions 5 and 6][91207]\n+- [Emit LLVM optimization remarks when enabled with `-Cremark`][90833]\n+- [Update the minimum external LLVM to 12][90175]\n+- [Add `x86_64-unknown-none` at Tier 3*][89062]\n+- [Build musl dist artifacts with debuginfo enabled][90733]. When building release binaries using musl, you may want to use the newly stabilized strip option to remove these debug symbols, reducing the size of your binaries.\n+- [Don't abort compilation after giving a lint error][87337]\n+- [Error messages point at the source of trait bound obligations in more places][89580]\n+\n+\\* Refer to Rust's [platform support page][platform-support-doc] for more\n+   information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+\n+- [All remaining functions in the standard library have `#[must_use]` annotations where appropriate][89692], producing a warning when ignoring their return value. This helps catch mistakes such as expecting a function to mutate a value in place rather than return a new value.\n+- [Paths are automatically canonicalized on Windows for operations that support it][89174]\n+- [Re-enable debug checks for `copy` and `copy_nonoverlapping`][90041]\n+- [Implement `RefUnwindSafe` for `Rc<T>`][87467]\n+- [Make RSplit<T, P>: Clone not require T: Clone][90117]\n+- [Implement `Termination` for `Result<Infallible, E>`][88601]. This allows writing `fn main() -> Result<Infallible, ErrorType>`, for a program whose successful exits never involve returning from `main` (for instance, a program that calls `exit`, or that uses `exec` to run another program).\n+\n+Stabilized APIs\n+---------------\n+\n+- [`Metadata::is_symlink`]\n+- [`Path::is_symlink`]\n+- [`{integer}::saturating_div`]\n+- [`Option::unwrap_unchecked`]\n+- [`NonZero{unsigned}::is_power_of_two`]\n+\n+These APIs are now usable in const contexts:\n+\n+- [`Duration::new`]\n+- [`Duration::checked_add`]\n+- [`Duration::saturating_add`]\n+- [`Duration::checked_sub`]\n+- [`Duration::saturating_sub`]\n+- [`Duration::checked_mul`]\n+- [`Duration::saturating_mul`]\n+- [`Duration::checked_div`]\n+- [`MaybeUninit::as_ptr`]\n+- [`MaybeUninit::as_mut_ptr`]\n+- [`MaybeUninit::assume_init`]\n+- [`MaybeUninit::assume_init_ref`]\n+\n+Cargo\n+-----\n+\n+- [Add --message-format for install command][cargo/10107]\n+- [Warn when alias shadows external subcommand][cargo/10082]\n+\n+Rustdoc\n+-------\n+\n+- [Show all Deref implementations recursively in rustdoc][90183]\n+- [Use computed visibility in rustdoc][88447]\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Try all stable method candidates first before trying unstable ones][90329]. This change ensures that adding new nightly-only methods to the Rust standard library will not break code invoking methods of the same name from traits outside the standard library.\n+- Windows: [`std::process::Command` will no longer search the current directory for executables.][87704]\n+- [All proc-macro backward-compatibility lints are now deny-by-default.][88041]\n+- [proc_macro: Append .0 to unsuffixed float if it would otherwise become int token][90297]\n+- [Refactor weak symbols in std::sys::unix][90846]. This optimizes accesses to glibc functions, by avoiding the use of dlopen. This does not increase the [minimum expected version of glibc](https://doc.rust-lang.org/nightly/rustc/platform-support.html). However, software distributions that use symbol versions to detect library dependencies, and which take weak symbols into account in that analysis, may detect rust binaries as requiring newer versions of glibc.\n+- [rustdoc now rejects some unexpected semicolons in doctests][91026]\n+\n+Internal Changes\n+----------------\n+\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc\n+and related tools.\n+\n+- [Implement coherence checks for negative trait impls][90104]\n+- [Add rustc lint, warning when iterating over hashmaps][89558]\n+- [Optimize live point computation][90491]\n+- [Enable verification for 1/32nd of queries loaded from disk][90361]\n+- [Implement version of normalize_erasing_regions that allows for normalization failure][91255]\n+\n+[87337]: https://github.com/rust-lang/rust/pull/87337/\n+[87467]: https://github.com/rust-lang/rust/pull/87467/\n+[87704]: https://github.com/rust-lang/rust/pull/87704/\n+[88041]: https://github.com/rust-lang/rust/pull/88041/\n+[88300]: https://github.com/rust-lang/rust/pull/88300/\n+[88447]: https://github.com/rust-lang/rust/pull/88447/\n+[88601]: https://github.com/rust-lang/rust/pull/88601/\n+[88624]: https://github.com/rust-lang/rust/pull/88624/\n+[89062]: https://github.com/rust-lang/rust/pull/89062/\n+[89174]: https://github.com/rust-lang/rust/pull/89174/\n+[89542]: https://github.com/rust-lang/rust/pull/89542/\n+[89551]: https://github.com/rust-lang/rust/pull/89551/\n+[89558]: https://github.com/rust-lang/rust/pull/89558/\n+[89580]: https://github.com/rust-lang/rust/pull/89580/\n+[89652]: https://github.com/rust-lang/rust/pull/89652/\n+[89677]: https://github.com/rust-lang/rust/pull/89677/\n+[89951]: https://github.com/rust-lang/rust/pull/89951/\n+[90041]: https://github.com/rust-lang/rust/pull/90041/\n+[90058]: https://github.com/rust-lang/rust/pull/90058/\n+[90104]: https://github.com/rust-lang/rust/pull/90104/\n+[90117]: https://github.com/rust-lang/rust/pull/90117/\n+[90175]: https://github.com/rust-lang/rust/pull/90175/\n+[90183]: https://github.com/rust-lang/rust/pull/90183/\n+[90297]: https://github.com/rust-lang/rust/pull/90297/\n+[90329]: https://github.com/rust-lang/rust/pull/90329/\n+[90361]: https://github.com/rust-lang/rust/pull/90361/\n+[90417]: https://github.com/rust-lang/rust/pull/90417/\n+[90473]: https://github.com/rust-lang/rust/pull/90473/\n+[90491]: https://github.com/rust-lang/rust/pull/90491/\n+[90733]: https://github.com/rust-lang/rust/pull/90733/\n+[90833]: https://github.com/rust-lang/rust/pull/90833/\n+[90846]: https://github.com/rust-lang/rust/pull/90846/\n+[90896]: https://github.com/rust-lang/rust/pull/90896/\n+[91026]: https://github.com/rust-lang/rust/pull/91026/\n+[91207]: https://github.com/rust-lang/rust/pull/91207/\n+[91255]: https://github.com/rust-lang/rust/pull/91255/\n+[91301]: https://github.com/rust-lang/rust/pull/91301/\n+[cargo/10082]: https://github.com/rust-lang/cargo/pull/10082/\n+[cargo/10107]: https://github.com/rust-lang/cargo/pull/10107/\n+[`Metadata::is_symlink`]: https://doc.rust-lang.org/stable/std/fs/struct.Metadata.html#method.is_symlink\n+[`Path::is_symlink`]: https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.is_symlink\n+[`{integer}::saturating_div`]: https://doc.rust-lang.org/stable/std/primitive.i8.html#method.saturating_div\n+[`Option::unwrap_unchecked`]: https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_unchecked\n+[`NonZero{unsigned}::is_power_of_two`]: https://doc.rust-lang.org/stable/std/num/struct.NonZeroU8.html#method.is_power_of_two\n+[`unix::process::ExitStatusExt::core_dumped`]: https://doc.rust-lang.org/stable/std/os/unix/process/trait.ExitStatusExt.html#tymethod.core_dumped\n+[`unix::process::ExitStatusExt::stopped_signal`]: https://doc.rust-lang.org/stable/std/os/unix/process/trait.ExitStatusExt.html#tymethod.stopped_signal\n+[`unix::process::ExitStatusExt::continued`]: https://doc.rust-lang.org/stable/std/os/unix/process/trait.ExitStatusExt.html#tymethod.continued\n+[`unix::process::ExitStatusExt::into_raw`]: https://doc.rust-lang.org/stable/std/os/unix/process/trait.ExitStatusExt.html#tymethod.into_raw\n+[`Duration::new`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.new\n+[`Duration::checked_add`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_add\n+[`Duration::saturating_add`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_add\n+[`Duration::checked_sub`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_sub\n+[`Duration::saturating_sub`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_sub\n+[`Duration::checked_mul`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_mul\n+[`Duration::saturating_mul`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_mul\n+[`Duration::checked_div`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_div\n+[`Duration::as_secs_f64`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.as_secs_f64\n+[`Duration::as_secs_f32`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.as_secs_f32\n+[`Duration::from_secs_f64`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.from_secs_f64\n+[`Duration::from_secs_f32`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.from_secs_f32\n+[`Duration::mul_f64`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.mul_f64\n+[`Duration::mul_f32`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.mul_f32\n+[`Duration::div_f64`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_f64\n+[`Duration::div_f32`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_f32\n+[`Duration::div_duration_f64`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_duration_f64\n+[`Duration::div_duration_f32`]: https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.div_duration_f32\n+[`MaybeUninit::as_ptr`]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.as_ptr\n+[`MaybeUninit::as_mut_ptr`]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.as_mut_ptr\n+[`MaybeUninit::assume_init`]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init\n+[`MaybeUninit::assume_init_ref`]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_ref\n+\n Version 1.57.0 (2021-12-02)\n ==========================\n \n@@ -388,6 +554,10 @@ Compatibility Notes\n   `Command` would cause them to be ASCII-uppercased.\n - [Rustdoc will now warn on using rustdoc lints that aren't prefixed\n   with `rustdoc::`][86849]\n+- `RUSTFLAGS` is no longer set for build scripts. Build scripts\n+  should use `CARGO_ENCODED_RUSTFLAGS` instead. See the\n+  [documentation](https://doc.rust-lang.org/nightly/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts)\n+  for more details.\n \n [86849]: https://github.com/rust-lang/rust/pull/86849\n [86513]: https://github.com/rust-lang/rust/pull/86513"}, {"sha": "9a24158ba35d9e76a8c0e700cfb914737eb440eb", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -6,12 +6,13 @@ use super::{AssocItem, Expr, ForeignItem, Item, Local, MacCallStmt};\n use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n use super::{AttrVec, Attribute, Stmt, StmtKind};\n \n-use std::fmt::Debug;\n+use std::fmt;\n+use std::marker::PhantomData;\n \n /// An `AstLike` represents an AST node (or some wrapper around\n /// and AST node) which stores some combination of attributes\n /// and tokens.\n-pub trait AstLike: Sized + Debug {\n+pub trait AstLike: Sized + fmt::Debug {\n     /// This is `true` if this `AstLike` might support 'custom' (proc-macro) inner\n     /// attributes. Attributes like `#![cfg]` and `#![cfg_attr]` are not\n     /// considered 'custom' attributes\n@@ -285,3 +286,37 @@ derive_has_attrs_no_tokens! {\n derive_has_tokens_no_attrs! {\n     Ty, Block, AttrItem, Pat, Path, Visibility\n }\n+\n+/// A newtype around an `AstLike` node that implements `AstLike` itself.\n+pub struct AstLikeWrapper<Wrapped, Tag> {\n+    pub wrapped: Wrapped,\n+    pub tag: PhantomData<Tag>,\n+}\n+\n+impl<Wrapped, Tag> AstLikeWrapper<Wrapped, Tag> {\n+    pub fn new(wrapped: Wrapped, _tag: Tag) -> AstLikeWrapper<Wrapped, Tag> {\n+        AstLikeWrapper { wrapped, tag: Default::default() }\n+    }\n+}\n+\n+impl<Wrapped: fmt::Debug, Tag> fmt::Debug for AstLikeWrapper<Wrapped, Tag> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"AstLikeWrapper\")\n+            .field(\"wrapped\", &self.wrapped)\n+            .field(\"tag\", &self.tag)\n+            .finish()\n+    }\n+}\n+\n+impl<Wrapped: AstLike, Tag> AstLike for AstLikeWrapper<Wrapped, Tag> {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = Wrapped::SUPPORTS_CUSTOM_INNER_ATTRS;\n+    fn attrs(&self) -> &[Attribute] {\n+        self.wrapped.attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.wrapped.visit_attrs(f)\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.wrapped.tokens_mut()\n+    }\n+}"}, {"sha": "84fe9ad26720ee9ad459fe725cdebf46735833e8", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -41,7 +41,7 @@ pub mod tokenstream;\n pub mod visit;\n \n pub use self::ast::*;\n-pub use self::ast_like::AstLike;\n+pub use self::ast_like::{AstLike, AstLikeWrapper};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "e0bdeb30dc84bcfe70436b7bf9007fb4242db1e0", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -238,7 +238,7 @@ macro_rules! configure {\n }\n \n impl<'a> StripUnconfigured<'a> {\n-    pub fn configure<T: AstLike>(&mut self, mut node: T) -> Option<T> {\n+    pub fn configure<T: AstLike>(&self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n         if self.in_cfg(node.attrs()) {\n             self.try_configure_tokens(&mut node);\n@@ -248,7 +248,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn try_configure_tokens<T: AstLike>(&mut self, node: &mut T) {\n+    fn try_configure_tokens<T: AstLike>(&self, node: &mut T) {\n         if self.config_tokens {\n             if let Some(Some(tokens)) = node.tokens_mut() {\n                 let attr_annotated_tokens = tokens.create_token_stream();\n@@ -257,10 +257,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn configure_krate_attrs(\n-        &mut self,\n-        mut attrs: Vec<ast::Attribute>,\n-    ) -> Option<Vec<ast::Attribute>> {\n+    fn configure_krate_attrs(&self, mut attrs: Vec<ast::Attribute>) -> Option<Vec<ast::Attribute>> {\n         attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         if self.in_cfg(&attrs) { Some(attrs) } else { None }\n     }\n@@ -269,7 +266,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// This is only used during the invocation of `derive` proc-macros,\n     /// which require that we cfg-expand their entire input.\n     /// Normal cfg-expansion operates on parsed AST nodes via the `configure` method\n-    fn configure_tokens(&mut self, stream: &AttrAnnotatedTokenStream) -> AttrAnnotatedTokenStream {\n+    fn configure_tokens(&self, stream: &AttrAnnotatedTokenStream) -> AttrAnnotatedTokenStream {\n         fn can_skip(stream: &AttrAnnotatedTokenStream) -> bool {\n             stream.0.iter().all(|(tree, _spacing)| match tree {\n                 AttrAnnotatedTokenTree::Attributes(_) => false,\n@@ -325,7 +322,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives compiler warnings if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n+    fn process_cfg_attrs<T: AstLike>(&self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n             attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         });\n@@ -338,7 +335,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n-    fn process_cfg_attr(&mut self, attr: Attribute) -> Vec<Attribute> {\n+    fn process_cfg_attr(&self, attr: Attribute) -> Vec<Attribute> {\n         if !attr.has_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n@@ -461,7 +458,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_expr(&mut self, expr: &mut P<ast::Expr>) {\n+    pub fn configure_expr(&self, expr: &mut P<ast::Expr>) {\n         for attr in expr.attrs.iter() {\n             self.maybe_emit_expr_attr_err(attr);\n         }"}, {"sha": "07ce901fb417aa2b1c1fe47da35c4d9123c14622", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 711, "deletions": 524, "changes": 1235, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1,6 +1,5 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n-use crate::configure;\n use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n@@ -12,13 +11,12 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AstLike, Block, Inline, ItemKind, MacArgs, MacCall};\n-use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n-use rustc_ast::{NodeId, PatKind, Path, StmtKind};\n+use rustc_ast::{AssocItemKind, AstLike, AstLikeWrapper, AttrStyle, ExprKind, ForeignItemKind};\n+use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n+use rustc_ast::{NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_attr::is_builtin_attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n-use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n@@ -34,7 +32,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::{FileName, LocalExpnId, Span};\n \n use smallvec::SmallVec;\n-use std::ops::DerefMut;\n+use std::ops::Deref;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::{iter, mem};\n@@ -109,6 +107,10 @@ macro_rules! ast_fragments {\n                 }\n             })*\n \n+            fn make_ast<T: InvocationCollectorNode>(self) -> T::OutputTy {\n+                T::fragment_to_output(self)\n+            }\n+\n             pub fn mut_visit_with<F: MutVisitor>(&mut self, vis: &mut F) {\n                 match self {\n                     AstFragment::OptExpr(opt_expr) => {\n@@ -178,10 +180,10 @@ ast_fragments! {\n     Arms(SmallVec<[ast::Arm; 1]>) {\n         \"match arm\"; many fn flat_map_arm; fn visit_arm(); fn make_arms;\n     }\n-    Fields(SmallVec<[ast::ExprField; 1]>) {\n+    ExprFields(SmallVec<[ast::ExprField; 1]>) {\n         \"field expression\"; many fn flat_map_expr_field; fn visit_expr_field(); fn make_expr_fields;\n     }\n-    FieldPats(SmallVec<[ast::PatField; 1]>) {\n+    PatFields(SmallVec<[ast::PatField; 1]>) {\n         \"field pattern\";\n         many fn flat_map_pat_field;\n         fn visit_pat_field();\n@@ -196,7 +198,7 @@ ast_fragments! {\n     Params(SmallVec<[ast::Param; 1]>) {\n         \"function parameter\"; many fn flat_map_param; fn visit_param(); fn make_params;\n     }\n-    StructFields(SmallVec<[ast::FieldDef; 1]>) {\n+    FieldDefs(SmallVec<[ast::FieldDef; 1]>) {\n         \"field\";\n         many fn flat_map_field_def;\n         fn visit_field_def();\n@@ -231,11 +233,11 @@ impl AstFragmentKind {\n             | AstFragmentKind::ForeignItems\n             | AstFragmentKind::Crate => SupportsMacroExpansion::Yes { supports_inner_attrs: true },\n             AstFragmentKind::Arms\n-            | AstFragmentKind::Fields\n-            | AstFragmentKind::FieldPats\n+            | AstFragmentKind::ExprFields\n+            | AstFragmentKind::PatFields\n             | AstFragmentKind::GenericParams\n             | AstFragmentKind::Params\n-            | AstFragmentKind::StructFields\n+            | AstFragmentKind::FieldDefs\n             | AstFragmentKind::Variants => SupportsMacroExpansion::No,\n         }\n     }\n@@ -249,20 +251,20 @@ impl AstFragmentKind {\n             AstFragmentKind::Arms => {\n                 AstFragment::Arms(items.map(Annotatable::expect_arm).collect())\n             }\n-            AstFragmentKind::Fields => {\n-                AstFragment::Fields(items.map(Annotatable::expect_expr_field).collect())\n+            AstFragmentKind::ExprFields => {\n+                AstFragment::ExprFields(items.map(Annotatable::expect_expr_field).collect())\n             }\n-            AstFragmentKind::FieldPats => {\n-                AstFragment::FieldPats(items.map(Annotatable::expect_pat_field).collect())\n+            AstFragmentKind::PatFields => {\n+                AstFragment::PatFields(items.map(Annotatable::expect_pat_field).collect())\n             }\n             AstFragmentKind::GenericParams => {\n                 AstFragment::GenericParams(items.map(Annotatable::expect_generic_param).collect())\n             }\n             AstFragmentKind::Params => {\n                 AstFragment::Params(items.map(Annotatable::expect_param).collect())\n             }\n-            AstFragmentKind::StructFields => {\n-                AstFragment::StructFields(items.map(Annotatable::expect_field_def).collect())\n+            AstFragmentKind::FieldDefs => {\n+                AstFragment::FieldDefs(items.map(Annotatable::expect_field_def).collect())\n             }\n             AstFragmentKind::Variants => {\n                 AstFragment::Variants(items.map(Annotatable::expect_variant).collect())\n@@ -315,10 +317,10 @@ pub enum InvocationKind {\n         pos: usize,\n         item: Annotatable,\n         // Required for resolving derive helper attributes.\n-        derives: Vec<Path>,\n+        derives: Vec<ast::Path>,\n     },\n     Derive {\n-        path: Path,\n+        path: ast::Path,\n         item: Annotatable,\n     },\n }\n@@ -676,7 +678,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             krate,\n                         ),\n                         Annotatable::Item(item_inner)\n-                            if matches!(attr.style, ast::AttrStyle::Inner)\n+                            if matches!(attr.style, AttrStyle::Inner)\n                                 && matches!(\n                                     item_inner.kind,\n                                     ItemKind::Mod(\n@@ -744,7 +746,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n-                    let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n+                    let meta = ast::MetaItem { kind: MetaItemKind::Word, span, path };\n                     let items = match expander.expand(self.cx, span, &meta, item) {\n                         ExpandResult::Ready(items) => items,\n                         ExpandResult::Retry(item) => {\n@@ -806,7 +808,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         impl<'ast, 'a> Visitor<'ast> for GateProcMacroInput<'a> {\n             fn visit_item(&mut self, item: &'ast ast::Item) {\n                 match &item.kind {\n-                    ast::ItemKind::Mod(_, mod_kind)\n+                    ItemKind::Mod(_, mod_kind)\n                         if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _)) =>\n                     {\n                         feature_err(\n@@ -834,7 +836,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         &mut self,\n         toks: TokenStream,\n         kind: AstFragmentKind,\n-        path: &Path,\n+        path: &ast::Path,\n         span: Span,\n     ) -> AstFragment {\n         let mut parser = self.cx.new_parser_from_tts(toks);\n@@ -915,18 +917,18 @@ pub fn parse_ast_fragment<'a>(\n         )?),\n         AstFragmentKind::Crate => AstFragment::Crate(this.parse_crate_mod()?),\n         AstFragmentKind::Arms\n-        | AstFragmentKind::Fields\n-        | AstFragmentKind::FieldPats\n+        | AstFragmentKind::ExprFields\n+        | AstFragmentKind::PatFields\n         | AstFragmentKind::GenericParams\n         | AstFragmentKind::Params\n-        | AstFragmentKind::StructFields\n+        | AstFragmentKind::FieldDefs\n         | AstFragmentKind::Variants => panic!(\"unexpected AST fragment kind\"),\n     })\n }\n \n pub fn ensure_complete_parse<'a>(\n     this: &mut Parser<'a>,\n-    macro_path: &Path,\n+    macro_path: &ast::Path,\n     kind_name: &str,\n     span: Span,\n ) {\n@@ -961,6 +963,568 @@ pub fn ensure_complete_parse<'a>(\n     }\n }\n \n+/// Wraps a call to `noop_visit_*` / `noop_flat_map_*`\n+/// for an AST node that supports attributes\n+/// (see the `Annotatable` enum)\n+/// This method assigns a `NodeId`, and sets that `NodeId`\n+/// as our current 'lint node id'. If a macro call is found\n+/// inside this AST node, we will use this AST node's `NodeId`\n+/// to emit lints associated with that macro (allowing\n+/// `#[allow]` / `#[deny]` to be applied close to\n+/// the macro invocation).\n+///\n+/// Do *not* call this for a macro AST node\n+/// (e.g. `ExprKind::MacCall`) - we cannot emit lints\n+/// at these AST nodes, since they are removed and\n+/// replaced with the result of macro expansion.\n+///\n+/// All other `NodeId`s are assigned by `visit_id`.\n+/// * `self` is the 'self' parameter for the current method,\n+/// * `id` is a mutable reference to the `NodeId` field\n+///    of the current AST node.\n+/// * `closure` is a closure that executes the\n+///   `noop_visit_*` / `noop_flat_map_*` method\n+///   for the current AST node.\n+macro_rules! assign_id {\n+    ($self:ident, $id:expr, $closure:expr) => {{\n+        let old_id = $self.cx.current_expansion.lint_node_id;\n+        if $self.monotonic {\n+            debug_assert_eq!(*$id, ast::DUMMY_NODE_ID);\n+            let new_id = $self.cx.resolver.next_node_id();\n+            *$id = new_id;\n+            $self.cx.current_expansion.lint_node_id = new_id;\n+        }\n+        let ret = ($closure)();\n+        $self.cx.current_expansion.lint_node_id = old_id;\n+        ret\n+    }};\n+}\n+\n+enum AddSemicolon {\n+    Yes,\n+    No,\n+}\n+\n+/// A trait implemented for all `AstFragment` nodes and providing all pieces\n+/// of functionality used by `InvocationCollector`.\n+trait InvocationCollectorNode: AstLike {\n+    type OutputTy = SmallVec<[Self; 1]>;\n+    type AttrsTy: Deref<Target = [ast::Attribute]> = Vec<ast::Attribute>;\n+    const KIND: AstFragmentKind;\n+    fn to_annotatable(self) -> Annotatable;\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy;\n+    fn id(&mut self) -> &mut NodeId;\n+    fn noop_flat_map<V: MutVisitor>(self, _visitor: &mut V) -> Self::OutputTy {\n+        unreachable!()\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, _visitor: &mut V) {\n+        unreachable!()\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        false\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        unreachable!()\n+    }\n+    fn pre_flat_map_node_collect_attr(_cfg: &StripUnconfigured<'_>, _attr: &ast::Attribute) {}\n+    fn post_flat_map_node_collect_bang(_output: &mut Self::OutputTy, _add_semicolon: AddSemicolon) {\n+    }\n+    fn wrap_flat_map_node_noop_flat_map(\n+        node: Self,\n+        collector: &mut InvocationCollector<'_, '_>,\n+        noop_flat_map: impl FnOnce(Self, &mut InvocationCollector<'_, '_>) -> Self::OutputTy,\n+    ) -> Result<Self::OutputTy, Self> {\n+        Ok(noop_flat_map(node, collector))\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Item> {\n+    const KIND: AstFragmentKind = AstFragmentKind::Items;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Item(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_item(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+    fn wrap_flat_map_node_noop_flat_map(\n+        mut node: Self,\n+        collector: &mut InvocationCollector<'_, '_>,\n+        noop_flat_map: impl FnOnce(Self, &mut InvocationCollector<'_, '_>) -> Self::OutputTy,\n+    ) -> Result<Self::OutputTy, Self> {\n+        if !matches!(node.kind, ItemKind::Mod(..)) {\n+            return Ok(noop_flat_map(node, collector));\n+        }\n+\n+        // Work around borrow checker not seeing through `P`'s deref.\n+        let (ident, span, mut attrs) = (node.ident, node.span, mem::take(&mut node.attrs));\n+        let ItemKind::Mod(_, mod_kind) = &mut node.kind else {\n+            unreachable!()\n+        };\n+\n+        let ecx = &mut collector.cx;\n+        let (file_path, dir_path, dir_ownership) = match mod_kind {\n+            ModKind::Loaded(_, inline, _) => {\n+                // Inline `mod foo { ... }`, but we still need to push directories.\n+                let (dir_path, dir_ownership) = mod_dir_path(\n+                    &ecx.sess,\n+                    ident,\n+                    &attrs,\n+                    &ecx.current_expansion.module,\n+                    ecx.current_expansion.dir_ownership,\n+                    *inline,\n+                );\n+                node.attrs = attrs;\n+                (None, dir_path, dir_ownership)\n+            }\n+            ModKind::Unloaded => {\n+                // We have an outline `mod foo;` so we need to parse the file.\n+                let old_attrs_len = attrs.len();\n+                let ParsedExternalMod { mut items, inner_span, file_path, dir_path, dir_ownership } =\n+                    parse_external_mod(\n+                        &ecx.sess,\n+                        ident,\n+                        span,\n+                        &ecx.current_expansion.module,\n+                        ecx.current_expansion.dir_ownership,\n+                        &mut attrs,\n+                    );\n+\n+                if let Some(extern_mod_loaded) = ecx.extern_mod_loaded {\n+                    (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n+                }\n+\n+                *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n+                node.attrs = attrs;\n+                if node.attrs.len() > old_attrs_len {\n+                    // If we loaded an out-of-line module and added some inner attributes,\n+                    // then we need to re-configure it and re-collect attributes for\n+                    // resolution and expansion.\n+                    return Err(node);\n+                }\n+                (Some(file_path), dir_path, dir_ownership)\n+            }\n+        };\n+\n+        // Set the module info before we flat map.\n+        let mut module = ecx.current_expansion.module.with_dir_path(dir_path);\n+        module.mod_path.push(ident);\n+        if let Some(file_path) = file_path {\n+            module.file_path_stack.push(file_path);\n+        }\n+\n+        let orig_module = mem::replace(&mut ecx.current_expansion.module, Rc::new(module));\n+        let orig_dir_ownership =\n+            mem::replace(&mut ecx.current_expansion.dir_ownership, dir_ownership);\n+\n+        let res = Ok(noop_flat_map(node, collector));\n+\n+        collector.cx.current_expansion.dir_ownership = orig_dir_ownership;\n+        collector.cx.current_expansion.module = orig_module;\n+        res\n+    }\n+}\n+\n+struct TraitItemTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, TraitItemTag> {\n+    type OutputTy = SmallVec<[P<ast::AssocItem>; 1]>;\n+    const KIND: AstFragmentKind = AstFragmentKind::TraitItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::TraitItem(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_trait_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_assoc_item(self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, AssocItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let item = self.wrapped.into_inner();\n+        match item.kind {\n+            AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+struct ImplItemTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, ImplItemTag> {\n+    type OutputTy = SmallVec<[P<ast::AssocItem>; 1]>;\n+    const KIND: AstFragmentKind = AstFragmentKind::ImplItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ImplItem(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_impl_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_assoc_item(self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, AssocItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let item = self.wrapped.into_inner();\n+        match item.kind {\n+            AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::ForeignItem> {\n+    const KIND: AstFragmentKind = AstFragmentKind::ForeignItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ForeignItem(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_foreign_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_foreign_item(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ForeignItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ForeignItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Variant {\n+    const KIND: AstFragmentKind = AstFragmentKind::Variants;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Variant(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_variants()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_variant(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::FieldDef {\n+    const KIND: AstFragmentKind = AstFragmentKind::FieldDefs;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::FieldDef(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_field_defs()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_field_def(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::PatField {\n+    const KIND: AstFragmentKind = AstFragmentKind::PatFields;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::PatField(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_pat_fields()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_pat_field(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::ExprField {\n+    const KIND: AstFragmentKind = AstFragmentKind::ExprFields;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ExprField(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_expr_fields()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_expr_field(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Param {\n+    const KIND: AstFragmentKind = AstFragmentKind::Params;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Param(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_params()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_param(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::GenericParam {\n+    const KIND: AstFragmentKind = AstFragmentKind::GenericParams;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::GenericParam(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_generic_params()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_generic_param(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Arm {\n+    const KIND: AstFragmentKind = AstFragmentKind::Arms;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Arm(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_arms()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_arm(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Stmt {\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::Stmts;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Stmt(P(self))\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_stmts()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_stmt(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        match &self.kind {\n+            StmtKind::MacCall(..) => true,\n+            StmtKind::Item(item) => matches!(item.kind, ItemKind::MacCall(..)),\n+            StmtKind::Semi(expr) => matches!(expr.kind, ExprKind::MacCall(..)),\n+            StmtKind::Expr(..) => unreachable!(),\n+            StmtKind::Local(..) | StmtKind::Empty => false,\n+        }\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        // We pull macro invocations (both attributes and fn-like macro calls) out of their\n+        // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n+        let (add_semicolon, mac, attrs) = match self.kind {\n+            StmtKind::MacCall(mac) => {\n+                let ast::MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n+                (style == MacStmtStyle::Semicolon, mac, attrs)\n+            }\n+            StmtKind::Item(item) => match item.into_inner() {\n+                ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n+                    (mac.args.need_semicolon(), mac, attrs.into())\n+                }\n+                _ => unreachable!(),\n+            },\n+            StmtKind::Semi(expr) => match expr.into_inner() {\n+                ast::Expr { kind: ExprKind::MacCall(mac), attrs, .. } => {\n+                    (mac.args.need_semicolon(), mac, attrs)\n+                }\n+                _ => unreachable!(),\n+            },\n+            _ => unreachable!(),\n+        };\n+        (mac, attrs, if add_semicolon { AddSemicolon::Yes } else { AddSemicolon::No })\n+    }\n+    fn post_flat_map_node_collect_bang(stmts: &mut Self::OutputTy, add_semicolon: AddSemicolon) {\n+        // If this is a macro invocation with a semicolon, then apply that\n+        // semicolon to the final statement produced by expansion.\n+        if matches!(add_semicolon, AddSemicolon::Yes) {\n+            if let Some(stmt) = stmts.pop() {\n+                stmts.push(stmt.add_trailing_semicolon());\n+            }\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Crate {\n+    type OutputTy = ast::Crate;\n+    const KIND: AstFragmentKind = AstFragmentKind::Crate;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Crate(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_crate()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_crate(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Ty> {\n+    type OutputTy = P<ast::Ty>;\n+    const KIND: AstFragmentKind = AstFragmentKind::Ty;\n+    fn to_annotatable(self) -> Annotatable {\n+        unreachable!()\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_ty()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_ty(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ast::TyKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            TyKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Pat> {\n+    type OutputTy = P<ast::Pat>;\n+    const KIND: AstFragmentKind = AstFragmentKind::Pat;\n+    fn to_annotatable(self) -> Annotatable {\n+        unreachable!()\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_pat()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_pat(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, PatKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            PatKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Expr> {\n+    type OutputTy = P<ast::Expr>;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::Expr;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_expr()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_expr(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+struct OptExprTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::Expr>, OptExprTag> {\n+    type OutputTy = Option<P<ast::Expr>>;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::OptExpr;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_opt_expr()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(mut self, visitor: &mut V) -> Self::OutputTy {\n+        noop_visit_expr(&mut self.wrapped, visitor);\n+        Some(self.wrapped)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, ast::ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.wrapped.into_inner();\n+        match node.kind {\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+    fn pre_flat_map_node_collect_attr(cfg: &StripUnconfigured<'_>, attr: &ast::Attribute) {\n+        cfg.maybe_emit_expr_attr_err(&attr);\n+    }\n+}\n+\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n@@ -996,7 +1560,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(\n         &mut self,\n-        (attr, pos, derives): (ast::Attribute, usize, Vec<Path>),\n+        (attr, pos, derives): (ast::Attribute, usize, Vec<ast::Path>),\n         item: Annotatable,\n         kind: AstFragmentKind,\n     ) -> AstFragment {\n@@ -1007,9 +1571,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     /// its position and derives following it. We have to collect the derives in order to resolve\n     /// legacy derive helpers (helpers written before derives that introduce them).\n     fn take_first_attr(\n-        &mut self,\n+        &self,\n         item: &mut impl AstLike,\n-    ) -> Option<(ast::Attribute, usize, Vec<Path>)> {\n+    ) -> Option<(ast::Attribute, usize, Vec<ast::Path>)> {\n         let mut attr = None;\n \n         item.visit_attrs(|attrs| {\n@@ -1039,45 +1603,13 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         attr\n     }\n \n-    fn take_stmt_bang(\n-        &mut self,\n-        stmt: ast::Stmt,\n-    ) -> Result<(bool, MacCall, Vec<ast::Attribute>), ast::Stmt> {\n-        match stmt.kind {\n-            StmtKind::MacCall(mac) => {\n-                let MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n-                Ok((style == MacStmtStyle::Semicolon, mac, attrs.into()))\n-            }\n-            StmtKind::Item(item) if matches!(item.kind, ItemKind::MacCall(..)) => {\n-                match item.into_inner() {\n-                    ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n-                        Ok((mac.args.need_semicolon(), mac, attrs))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            StmtKind::Semi(expr) if matches!(expr.kind, ast::ExprKind::MacCall(..)) => {\n-                match expr.into_inner() {\n-                    ast::Expr { kind: ast::ExprKind::MacCall(mac), attrs, .. } => {\n-                        Ok((mac.args.need_semicolon(), mac, attrs.into()))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            StmtKind::Local(..) | StmtKind::Empty | StmtKind::Item(..) | StmtKind::Semi(..) => {\n-                Err(stmt)\n-            }\n-            StmtKind::Expr(..) => unreachable!(),\n-        }\n-    }\n-\n     fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n \n     // Detect use of feature-gated or invalid attributes on macro invocations\n     // since they will not be detected after macro expansion.\n-    fn check_attributes(&self, attrs: &[ast::Attribute], call: &MacCall) {\n+    fn check_attributes(&self, attrs: &[ast::Attribute], call: &ast::MacCall) {\n         let features = self.cx.ecfg.features.unwrap();\n         let mut attrs = attrs.iter().peekable();\n         let mut span: Option<Span> = None;\n@@ -1120,510 +1652,165 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             }\n         }\n     }\n-}\n \n-/// Wraps a call to `noop_visit_*` / `noop_flat_map_*`\n-/// for an AST node that supports attributes\n-/// (see the `Annotatable` enum)\n-/// This method assigns a `NodeId`, and sets that `NodeId`\n-/// as our current 'lint node id'. If a macro call is found\n-/// inside this AST node, we will use this AST node's `NodeId`\n-/// to emit lints associated with that macro (allowing\n-/// `#[allow]` / `#[deny]` to be applied close to\n-/// the macro invocation).\n-///\n-/// Do *not* call this for a macro AST node\n-/// (e.g. `ExprKind::MacCall`) - we cannot emit lints\n-/// at these AST nodes, since they are removed and\n-/// replaced with the result of macro expansion.\n-///\n-/// All other `NodeId`s are assigned by `visit_id`.\n-/// * `self` is the 'self' parameter for the current method,\n-/// * `id` is a mutable reference to the `NodeId` field\n-///    of the current AST node.\n-/// * `closure` is a closure that executes the\n-///   `noop_visit_*` / `noop_flat_map_*` method\n-///   for the current AST node.\n-macro_rules! assign_id {\n-    ($self:ident, $id:expr, $closure:expr) => {{\n-        let old_id = $self.cx.current_expansion.lint_node_id;\n-        if $self.monotonic {\n-            debug_assert_eq!(*$id, ast::DUMMY_NODE_ID);\n-            let new_id = $self.cx.resolver.next_node_id();\n-            *$id = new_id;\n-            $self.cx.current_expansion.lint_node_id = new_id;\n+    fn flat_map_node<Node: InvocationCollectorNode<OutputTy: Default>>(\n+        &mut self,\n+        node: Node,\n+    ) -> Node::OutputTy {\n+        let mut node = configure!(self, node);\n+\n+        if let Some(attr) = self.take_first_attr(&mut node) {\n+            Node::pre_flat_map_node_collect_attr(&self.cfg, &attr.0);\n+            self.collect_attr(attr, node.to_annotatable(), Node::KIND).make_ast::<Node>()\n+        } else if node.is_mac_call() {\n+            let (mac, attrs, add_semicolon) = node.take_mac_call();\n+            self.check_attributes(&attrs, &mac);\n+            let mut res = self.collect_bang(mac, Node::KIND).make_ast::<Node>();\n+            Node::post_flat_map_node_collect_bang(&mut res, add_semicolon);\n+            res\n+        } else {\n+            match Node::wrap_flat_map_node_noop_flat_map(node, self, |mut node, this| {\n+                assign_id!(this, node.id(), || node.noop_flat_map(this))\n+            }) {\n+                Ok(output) => output,\n+                Err(node) => self.flat_map_node(node),\n+            }\n         }\n-        let ret = ($closure)();\n-        $self.cx.current_expansion.lint_node_id = old_id;\n-        ret\n-    }};\n+    }\n+\n+    fn visit_node<Node: InvocationCollectorNode<OutputTy = Node> + DummyAstNode>(\n+        &mut self,\n+        node: &mut Node,\n+    ) {\n+        if let Some(attr) = self.take_first_attr(node) {\n+            visit_clobber(node, |node| {\n+                self.collect_attr(attr, node.to_annotatable(), Node::KIND).make_ast::<Node>()\n+            })\n+        } else if node.is_mac_call() {\n+            visit_clobber(node, |node| {\n+                // Do not clobber unless it's actually a macro (uncommon case).\n+                let (mac, attrs, _) = node.take_mac_call();\n+                self.check_attributes(&attrs, &mac);\n+                self.collect_bang(mac, Node::KIND).make_ast::<Node>()\n+            })\n+        } else {\n+            assign_id!(self, node.id(), || node.noop_visit(self))\n+        }\n+    }\n }\n \n impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n-    fn visit_crate(&mut self, krate: &mut ast::Crate) {\n-        visit_clobber(krate, |krate| {\n-            let span = krate.span;\n-            let mut krate = match self.configure(krate) {\n-                Some(krate) => krate,\n-                None => {\n-                    return ast::Crate {\n-                        attrs: Vec::new(),\n-                        items: Vec::new(),\n-                        span,\n-                        id: self.cx.resolver.next_node_id(),\n-                        is_placeholder: false,\n-                    };\n-                }\n-            };\n-\n-            if let Some(attr) = self.take_first_attr(&mut krate) {\n-                return self\n-                    .collect_attr(attr, Annotatable::Crate(krate), AstFragmentKind::Crate)\n-                    .make_crate();\n-            }\n-\n-            assign_id!(self, &mut krate.id, || noop_visit_crate(&mut krate, self));\n-            krate\n-        })\n+    fn flat_map_item(&mut self, node: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.cfg.configure_expr(expr);\n-        visit_clobber(expr.deref_mut(), |mut expr| {\n-            if let Some(attr) = self.take_first_attr(&mut expr) {\n-                // Collect the invoc regardless of whether or not attributes are permitted here\n-                // expansion will eat the attribute so it won't error later.\n-                self.cfg.maybe_emit_expr_attr_err(&attr.0);\n-\n-                // AstFragmentKind::Expr requires the macro to emit an expression.\n-                return self\n-                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::Expr)\n-                    .make_expr()\n-                    .into_inner();\n-            }\n-\n-            if let ast::ExprKind::MacCall(mac) = expr.kind {\n-                self.check_attributes(&expr.attrs, &mac);\n-                self.collect_bang(mac, AstFragmentKind::Expr).make_expr().into_inner()\n-            } else {\n-                assign_id!(self, &mut expr.id, || {\n-                    ensure_sufficient_stack(|| noop_visit_expr(&mut expr, self));\n-                });\n-                expr\n-            }\n-        });\n+    fn flat_map_trait_item(&mut self, node: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        self.flat_map_node(AstLikeWrapper::new(node, TraitItemTag))\n     }\n \n-    fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n-        let mut arm = configure!(self, arm);\n-\n-        if let Some(attr) = self.take_first_attr(&mut arm) {\n-            return self\n-                .collect_attr(attr, Annotatable::Arm(arm), AstFragmentKind::Arms)\n-                .make_arms();\n-        }\n-\n-        assign_id!(self, &mut arm.id, || noop_flat_map_arm(arm, self))\n+    fn flat_map_impl_item(&mut self, node: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        self.flat_map_node(AstLikeWrapper::new(node, ImplItemTag))\n     }\n \n-    fn flat_map_expr_field(&mut self, field: ast::ExprField) -> SmallVec<[ast::ExprField; 1]> {\n-        let mut field = configure!(self, field);\n-\n-        if let Some(attr) = self.take_first_attr(&mut field) {\n-            return self\n-                .collect_attr(attr, Annotatable::ExprField(field), AstFragmentKind::Fields)\n-                .make_expr_fields();\n-        }\n-\n-        assign_id!(self, &mut field.id, || noop_flat_map_expr_field(field, self))\n+    fn flat_map_foreign_item(\n+        &mut self,\n+        node: P<ast::ForeignItem>,\n+    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_pat_field(&mut self, fp: ast::PatField) -> SmallVec<[ast::PatField; 1]> {\n-        let mut fp = configure!(self, fp);\n-\n-        if let Some(attr) = self.take_first_attr(&mut fp) {\n-            return self\n-                .collect_attr(attr, Annotatable::PatField(fp), AstFragmentKind::FieldPats)\n-                .make_pat_fields();\n-        }\n-\n-        assign_id!(self, &mut fp.id, || noop_flat_map_pat_field(fp, self))\n+    fn flat_map_variant(&mut self, node: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n-        let mut p = configure!(self, p);\n-\n-        if let Some(attr) = self.take_first_attr(&mut p) {\n-            return self\n-                .collect_attr(attr, Annotatable::Param(p), AstFragmentKind::Params)\n-                .make_params();\n-        }\n-\n-        assign_id!(self, &mut p.id, || noop_flat_map_param(p, self))\n+    fn flat_map_field_def(&mut self, node: ast::FieldDef) -> SmallVec<[ast::FieldDef; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_field_def(&mut self, sf: ast::FieldDef) -> SmallVec<[ast::FieldDef; 1]> {\n-        let mut sf = configure!(self, sf);\n-\n-        if let Some(attr) = self.take_first_attr(&mut sf) {\n-            return self\n-                .collect_attr(attr, Annotatable::FieldDef(sf), AstFragmentKind::StructFields)\n-                .make_field_defs();\n-        }\n-\n-        assign_id!(self, &mut sf.id, || noop_flat_map_field_def(sf, self))\n+    fn flat_map_pat_field(&mut self, node: ast::PatField) -> SmallVec<[ast::PatField; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n-        let mut variant = configure!(self, variant);\n-\n-        if let Some(attr) = self.take_first_attr(&mut variant) {\n-            return self\n-                .collect_attr(attr, Annotatable::Variant(variant), AstFragmentKind::Variants)\n-                .make_variants();\n-        }\n-\n-        assign_id!(self, &mut variant.id, || noop_flat_map_variant(variant, self))\n+    fn flat_map_expr_field(&mut self, node: ast::ExprField) -> SmallVec<[ast::ExprField; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let expr = configure!(self, expr);\n-        expr.filter_map(|mut expr| {\n-            if let Some(attr) = self.take_first_attr(&mut expr) {\n-                self.cfg.maybe_emit_expr_attr_err(&attr.0);\n-\n-                return self\n-                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::OptExpr)\n-                    .make_opt_expr()\n-                    .map(|expr| expr.into_inner());\n-            }\n-\n-            if let ast::ExprKind::MacCall(mac) = expr.kind {\n-                self.check_attributes(&expr.attrs, &mac);\n-                self.collect_bang(mac, AstFragmentKind::OptExpr)\n-                    .make_opt_expr()\n-                    .map(|expr| expr.into_inner())\n-            } else {\n-                assign_id!(self, &mut expr.id, || {\n-                    Some({\n-                        noop_visit_expr(&mut expr, self);\n-                        expr\n-                    })\n-                })\n-            }\n-        })\n+    fn flat_map_param(&mut self, node: ast::Param) -> SmallVec<[ast::Param; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        match pat.kind {\n-            PatKind::MacCall(_) => {}\n-            _ => return noop_visit_pat(pat, self),\n-        }\n-\n-        visit_clobber(pat, |mut pat| match mem::replace(&mut pat.kind, PatKind::Wild) {\n-            PatKind::MacCall(mac) => self.collect_bang(mac, AstFragmentKind::Pat).make_pat(),\n-            _ => unreachable!(),\n-        });\n+    fn flat_map_generic_param(\n+        &mut self,\n+        node: ast::GenericParam,\n+    ) -> SmallVec<[ast::GenericParam; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        let mut stmt = configure!(self, stmt);\n+    fn flat_map_arm(&mut self, node: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n+        self.flat_map_node(node)\n+    }\n \n-        // We pull macro invocations (both attributes and fn-like macro calls) out of their\n-        // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n+    fn flat_map_stmt(&mut self, node: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         // FIXME: invocations in semicolon-less expressions positions are expanded as expressions,\n         // changing that requires some compatibility measures.\n-        let mut stmt = if !stmt.is_expr() {\n-            if let Some(attr) = self.take_first_attr(&mut stmt) {\n-                return self\n-                    .collect_attr(attr, Annotatable::Stmt(P(stmt)), AstFragmentKind::Stmts)\n-                    .make_stmts();\n-            }\n-\n-            match self.take_stmt_bang(stmt) {\n-                Ok((add_semicolon, mac, attrs)) => {\n-                    self.check_attributes(&attrs, &mac);\n-                    let mut stmts = self.collect_bang(mac, AstFragmentKind::Stmts).make_stmts();\n-\n-                    // If this is a macro invocation with a semicolon, then apply that\n-                    // semicolon to the final statement produced by expansion.\n-                    if add_semicolon {\n-                        if let Some(stmt) = stmts.pop() {\n-                            stmts.push(stmt.add_trailing_semicolon());\n-                        }\n-                    }\n-\n-                    return stmts;\n+        if node.is_expr() {\n+            // The only way that we can end up with a `MacCall` expression statement,\n+            // (as opposed to a `StmtKind::MacCall`) is if we have a macro as the\n+            // traiing expression in a block (e.g. `fn foo() { my_macro!() }`).\n+            // Record this information, so that we can report a more specific\n+            // `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint if needed.\n+            // See #78991 for an investigation of treating macros in this position\n+            // as statements, rather than expressions, during parsing.\n+            let mut node = configure!(self, node);\n+            return match &node.kind {\n+                StmtKind::Expr(expr)\n+                    if matches!(**expr, ast::Expr { kind: ExprKind::MacCall(..), .. }) =>\n+                {\n+                    self.cx.current_expansion.is_trailing_mac = true;\n+                    // Don't use `assign_id` for this statement - it may get removed\n+                    // entirely due to a `#[cfg]` on the contained expression\n+                    let res = noop_flat_map_stmt(node, self);\n+                    self.cx.current_expansion.is_trailing_mac = false;\n+                    res\n                 }\n-                Err(stmt) => stmt,\n-            }\n-        } else {\n-            stmt\n-        };\n-\n-        // The only way that we can end up with a `MacCall` expression statement,\n-        // (as opposed to a `StmtKind::MacCall`) is if we have a macro as the\n-        // traiing expression in a block (e.g. `fn foo() { my_macro!() }`).\n-        // Record this information, so that we can report a more specific\n-        // `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint if needed.\n-        // See #78991 for an investigation of treating macros in this position\n-        // as statements, rather than expressions, during parsing.\n-        let res = match &stmt.kind {\n-            StmtKind::Expr(expr)\n-                if matches!(**expr, ast::Expr { kind: ast::ExprKind::MacCall(..), .. }) =>\n-            {\n-                self.cx.current_expansion.is_trailing_mac = true;\n-                // Don't use `assign_id` for this statement - it may get removed\n-                // entirely due to a `#[cfg]` on the contained expression\n-                noop_flat_map_stmt(stmt, self)\n-            }\n-            _ => assign_id!(self, &mut stmt.id, || noop_flat_map_stmt(stmt, self)),\n-        };\n-        self.cx.current_expansion.is_trailing_mac = false;\n-        res\n-    }\n-\n-    fn visit_block(&mut self, block: &mut P<Block>) {\n-        let orig_dir_ownership = mem::replace(\n-            &mut self.cx.current_expansion.dir_ownership,\n-            DirOwnership::UnownedViaBlock,\n-        );\n-        noop_visit_block(block, self);\n-        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n-    }\n-\n-    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::Item(item), AstFragmentKind::Items)\n-                .make_items();\n+                _ => assign_id!(self, &mut node.id, || noop_flat_map_stmt(node, self)),\n+            };\n         }\n \n-        let mut attrs = mem::take(&mut item.attrs); // We do this to please borrowck.\n-        let ident = item.ident;\n-        let span = item.span;\n-\n-        match item.kind {\n-            ast::ItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&attrs, &mac);\n-                item.attrs = attrs;\n-                item.and_then(|item| match item.kind {\n-                    ItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::Items).make_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::empty() => {\n-                let (file_path, dir_path, dir_ownership) = match mod_kind {\n-                    ModKind::Loaded(_, inline, _) => {\n-                        // Inline `mod foo { ... }`, but we still need to push directories.\n-                        let (dir_path, dir_ownership) = mod_dir_path(\n-                            &self.cx.sess,\n-                            ident,\n-                            &attrs,\n-                            &self.cx.current_expansion.module,\n-                            self.cx.current_expansion.dir_ownership,\n-                            *inline,\n-                        );\n-                        item.attrs = attrs;\n-                        (None, dir_path, dir_ownership)\n-                    }\n-                    ModKind::Unloaded => {\n-                        // We have an outline `mod foo;` so we need to parse the file.\n-                        let old_attrs_len = attrs.len();\n-                        let ParsedExternalMod {\n-                            mut items,\n-                            inner_span,\n-                            file_path,\n-                            dir_path,\n-                            dir_ownership,\n-                        } = parse_external_mod(\n-                            &self.cx.sess,\n-                            ident,\n-                            span,\n-                            &self.cx.current_expansion.module,\n-                            self.cx.current_expansion.dir_ownership,\n-                            &mut attrs,\n-                        );\n-\n-                        if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                            (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n-                        }\n-\n-                        *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n-                        item.attrs = attrs;\n-                        if item.attrs.len() > old_attrs_len {\n-                            // If we loaded an out-of-line module and added some inner attributes,\n-                            // then we need to re-configure it and re-collect attributes for\n-                            // resolution and expansion.\n-                            item = configure!(self, item);\n-\n-                            if let Some(attr) = self.take_first_attr(&mut item) {\n-                                return self\n-                                    .collect_attr(\n-                                        attr,\n-                                        Annotatable::Item(item),\n-                                        AstFragmentKind::Items,\n-                                    )\n-                                    .make_items();\n-                            }\n-                        }\n-                        (Some(file_path), dir_path, dir_ownership)\n-                    }\n-                };\n-\n-                // Set the module info before we flat map.\n-                let mut module = self.cx.current_expansion.module.with_dir_path(dir_path);\n-                module.mod_path.push(ident);\n-                if let Some(file_path) = file_path {\n-                    module.file_path_stack.push(file_path);\n-                }\n-\n-                let orig_module =\n-                    mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n-                let orig_dir_ownership =\n-                    mem::replace(&mut self.cx.current_expansion.dir_ownership, dir_ownership);\n-\n-                let result = assign_id!(self, &mut item.id, || noop_flat_map_item(item, self));\n-\n-                // Restore the module info.\n-                self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n-                self.cx.current_expansion.module = orig_module;\n-\n-                result\n-            }\n-            _ => {\n-                item.attrs = attrs;\n-                // The crate root is special - don't assign an ID to it.\n-                if !(matches!(item.kind, ast::ItemKind::Mod(..)) && ident == Ident::empty()) {\n-                    assign_id!(self, &mut item.id, || noop_flat_map_item(item, self))\n-                } else {\n-                    noop_flat_map_item(item, self)\n-                }\n-            }\n-        }\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::TraitItem(item), AstFragmentKind::TraitItems)\n-                .make_trait_items();\n-        }\n-\n-        match item.kind {\n-            ast::AssocItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&item.attrs, &mac);\n-                item.and_then(|item| match item.kind {\n-                    ast::AssocItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::TraitItems).make_trait_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut item.id, || noop_flat_map_assoc_item(item, self))\n-            }\n-        }\n+    fn visit_crate(&mut self, node: &mut ast::Crate) {\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::ImplItem(item), AstFragmentKind::ImplItems)\n-                .make_impl_items();\n-        }\n-\n-        match item.kind {\n-            ast::AssocItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&item.attrs, &mac);\n-                item.and_then(|item| match item.kind {\n-                    ast::AssocItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::ImplItems).make_impl_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut item.id, || noop_flat_map_assoc_item(item, self))\n-            }\n-        }\n+    fn visit_ty(&mut self, node: &mut P<ast::Ty>) {\n+        self.visit_node(node)\n     }\n \n-    fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n-        match ty.kind {\n-            ast::TyKind::MacCall(_) => {}\n-            _ => return noop_visit_ty(ty, self),\n-        };\n-\n-        visit_clobber(ty, |mut ty| match mem::replace(&mut ty.kind, ast::TyKind::Err) {\n-            ast::TyKind::MacCall(mac) => self.collect_bang(mac, AstFragmentKind::Ty).make_ty(),\n-            _ => unreachable!(),\n-        });\n+    fn visit_pat(&mut self, node: &mut P<ast::Pat>) {\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_foreign_item(\n-        &mut self,\n-        foreign_item: P<ast::ForeignItem>,\n-    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n-        let mut foreign_item = configure!(self, foreign_item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut foreign_item) {\n-            return self\n-                .collect_attr(\n-                    attr,\n-                    Annotatable::ForeignItem(foreign_item),\n-                    AstFragmentKind::ForeignItems,\n-                )\n-                .make_foreign_items();\n-        }\n-\n-        match foreign_item.kind {\n-            ast::ForeignItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&foreign_item.attrs, &mac);\n-                foreign_item.and_then(|item| match item.kind {\n-                    ast::ForeignItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::ForeignItems).make_foreign_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut foreign_item.id, || noop_flat_map_foreign_item(\n-                    foreign_item,\n-                    self\n-                ))\n-            }\n-        }\n+    fn visit_expr(&mut self, node: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(node);\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_generic_param(\n-        &mut self,\n-        param: ast::GenericParam,\n-    ) -> SmallVec<[ast::GenericParam; 1]> {\n-        let mut param = configure!(self, param);\n-\n-        if let Some(attr) = self.take_first_attr(&mut param) {\n-            return self\n-                .collect_attr(\n-                    attr,\n-                    Annotatable::GenericParam(param),\n-                    AstFragmentKind::GenericParams,\n-                )\n-                .make_generic_params();\n-        }\n+    fn filter_map_expr(&mut self, node: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        self.flat_map_node(AstLikeWrapper::new(node, OptExprTag))\n+    }\n \n-        assign_id!(self, &mut param.id, || noop_flat_map_generic_param(param, self))\n+    fn visit_block(&mut self, node: &mut P<ast::Block>) {\n+        let orig_dir_ownership = mem::replace(\n+            &mut self.cx.current_expansion.dir_ownership,\n+            DirOwnership::UnownedViaBlock,\n+        );\n+        noop_visit_block(node, self);\n+        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n     }\n \n-    fn visit_id(&mut self, id: &mut ast::NodeId) {\n+    fn visit_id(&mut self, id: &mut NodeId) {\n         // We may have already assigned a `NodeId`\n         // by calling `assign_id`\n         if self.monotonic && *id == ast::DUMMY_NODE_ID {"}, {"sha": "5599c1df6d9de3c0011d353075a39d8b4f252412", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1,3 +1,5 @@\n+#![feature(associated_type_bounds)]\n+#![feature(associated_type_defaults)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![cfg_attr(bootstrap, feature(destructuring_assignment))]"}, {"sha": "af593e92634b034be962b944d9038b036bf2568c", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -123,7 +123,7 @@ pub fn placeholder(\n             span,\n             is_placeholder: true,\n         }]),\n-        AstFragmentKind::Fields => AstFragment::Fields(smallvec![ast::ExprField {\n+        AstFragmentKind::ExprFields => AstFragment::ExprFields(smallvec![ast::ExprField {\n             attrs: Default::default(),\n             expr: expr_placeholder(),\n             id,\n@@ -132,7 +132,7 @@ pub fn placeholder(\n             span,\n             is_placeholder: true,\n         }]),\n-        AstFragmentKind::FieldPats => AstFragment::FieldPats(smallvec![ast::PatField {\n+        AstFragmentKind::PatFields => AstFragment::PatFields(smallvec![ast::PatField {\n             attrs: Default::default(),\n             id,\n             ident,\n@@ -159,7 +159,7 @@ pub fn placeholder(\n             ty: ty(),\n             is_placeholder: true,\n         }]),\n-        AstFragmentKind::StructFields => AstFragment::StructFields(smallvec![ast::FieldDef {\n+        AstFragmentKind::FieldDefs => AstFragment::FieldDefs(smallvec![ast::FieldDef {\n             attrs: Default::default(),\n             id,\n             ident: None,"}, {"sha": "51b3cc7e4fa54bc32e9d4dec4cde5d733c3ec266", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::ExportedSymbol;\n use rustc_middle::middle::stability::DeprecationEntry;\n+use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n use rustc_session::cstore::{CrateSource, CrateStore, ForeignModule};\n@@ -187,8 +188,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     extra_filename => { cdata.root.extra_filename.clone() }\n \n     traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n-    all_trait_implementations => { tcx.arena.alloc_from_iter(cdata.get_trait_impls()) }\n-\n     implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n \n     visibility => { cdata.get_visibility(def_id.index) }\n@@ -473,6 +472,17 @@ impl CStore {\n     ) -> Span {\n         self.get_crate_data(cnum).get_proc_macro_quoted_span(id, sess)\n     }\n+\n+    pub fn traits_in_crate_untracked(&self, cnum: CrateNum) -> Vec<DefId> {\n+        self.get_crate_data(cnum).get_traits().collect()\n+    }\n+\n+    pub fn trait_impls_in_crate_untracked(\n+        &self,\n+        cnum: CrateNum,\n+    ) -> Vec<(DefId, Option<SimplifiedType>)> {\n+        self.get_crate_data(cnum).get_trait_impls().collect()\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "3aca7a90194ee7cd348453f24c7b1dfa76e34dbe", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1442,13 +1442,6 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    /// Given a crate, look up all trait impls in that crate.\n-    /// Return `(impl_id, self_ty)`.\n-    query all_trait_implementations(_: CrateNum) -> &'tcx [(DefId, Option<SimplifiedType>)] {\n-        desc { \"looking up all (?) trait implementations\" }\n-        separate_provide_extern\n-    }\n-\n     query is_dllimport_foreign_item(def_id: DefId) -> bool {\n         desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n     }"}, {"sha": "1b02511fd7c2f29934c626631aad5aa259ad6886", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -520,9 +520,16 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'ast>, sp: Span, _: NodeId) {\n         let rib_kind = match fn_kind {\n-            // Bail if there's no body.\n-            FnKind::Fn(.., None) => return visit::walk_fn(self, fn_kind, sp),\n-            FnKind::Fn(FnCtxt::Free | FnCtxt::Foreign, ..) => FnItemRibKind,\n+            // Bail if the function is foreign, and thus cannot validly have\n+            // a body, or if there's no body for some other reason.\n+            FnKind::Fn(FnCtxt::Foreign, _, sig, ..) | FnKind::Fn(_, _, sig, .., None) => {\n+                // We don't need to deal with patterns in parameters, because\n+                // they are not possible for foreign or bodiless functions.\n+                self.visit_fn_header(&sig.header);\n+                visit::walk_fn_decl(self, &sig.decl);\n+                return;\n+            }\n+            FnKind::Fn(FnCtxt::Free, ..) => FnItemRibKind,\n             FnKind::Fn(FnCtxt::Assoc(_), ..) => NormalRibKind,\n             FnKind::Closure(..) => ClosureOrAsyncRibKind,\n         };"}, {"sha": "7b826f921ca87b1eef0a8a7a8a3683e3b944baec", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -48,6 +48,16 @@ impl<T: ?Sized> *const T {\n         self as _\n     }\n \n+    /// Changes constness without changing the type.\n+    ///\n+    /// This is a bit safer than `as` because it wouldn't silently change the type if the code is\n+    /// refactored.\n+    #[unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n+    #[rustc_const_unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n+    pub const fn as_mut(self) -> *mut T {\n+        self as _\n+    }\n+\n     /// Casts a pointer to its raw bits.\n     ///\n     /// This is equivalent to `as usize`, but is more specific to enhance readability."}, {"sha": "6c50d4052976f01e8672a943e56562eddffe75ef", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -47,6 +47,20 @@ impl<T: ?Sized> *mut T {\n         self as _\n     }\n \n+    /// Changes constness without changing the type.\n+    ///\n+    /// This is a bit safer than `as` because it wouldn't silently change the type if the code is\n+    /// refactored.\n+    ///\n+    /// While not strictly required (`*mut T` coerces to `*const T`), this is provided for symmetry\n+    /// with `as_mut()` on `*const T` and may have documentation value if used instead of implicit\n+    /// coercion.\n+    #[unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n+    #[rustc_const_unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n+    pub const fn as_const(self) -> *const T {\n+        self as _\n+    }\n+\n     /// Casts a pointer to its raw bits.\n     ///\n     /// This is equivalent to `as usize`, but is more specific to enhance readability."}, {"sha": "27243d8ca703060aea8362fd75fc301a02150200", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -333,10 +333,10 @@ impl AtomicBool {\n     #[inline]\n     #[cfg(target_has_atomic_equal_alignment = \"8\")]\n     #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n-    pub fn from_mut(v: &mut bool) -> &Self {\n+    pub fn from_mut(v: &mut bool) -> &mut Self {\n         // SAFETY: the mutable reference guarantees unique ownership, and\n         // alignment of both `bool` and `Self` is 1.\n-        unsafe { &*(v as *mut bool as *mut Self) }\n+        unsafe { &mut *(v as *mut bool as *mut Self) }\n     }\n \n     /// Consumes the atomic and returns the contained value.\n@@ -934,14 +934,14 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[cfg(target_has_atomic_equal_alignment = \"ptr\")]\n     #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n-    pub fn from_mut(v: &mut *mut T) -> &Self {\n+    pub fn from_mut(v: &mut *mut T) -> &mut Self {\n         use crate::mem::align_of;\n         let [] = [(); align_of::<AtomicPtr<()>>() - align_of::<*mut ()>()];\n         // SAFETY:\n         //  - the mutable reference guarantees unique ownership.\n         //  - the alignment of `*mut T` and `Self` is the same on all platforms\n         //    supported by rust, as verified above.\n-        unsafe { &*(v as *mut *mut T as *mut Self) }\n+        unsafe { &mut *(v as *mut *mut T as *mut Self) }\n     }\n \n     /// Consumes the atomic and returns the contained value.\n@@ -1447,14 +1447,14 @@ macro_rules! atomic_int {\n             #[inline]\n             #[$cfg_align]\n             #[unstable(feature = \"atomic_from_mut\", issue = \"76314\")]\n-            pub fn from_mut(v: &mut $int_type) -> &Self {\n+            pub fn from_mut(v: &mut $int_type) -> &mut Self {\n                 use crate::mem::align_of;\n                 let [] = [(); align_of::<Self>() - align_of::<$int_type>()];\n                 // SAFETY:\n                 //  - the mutable reference guarantees unique ownership.\n                 //  - the alignment of `$int_type` and `Self` is the\n                 //    same, as promised by $cfg_align and verified above.\n-                unsafe { &*(v as *mut $int_type as *mut Self) }\n+                unsafe { &mut *(v as *mut $int_type as *mut Self) }\n             }\n \n             /// Consumes the atomic and returns the contained value."}, {"sha": "66333e2b99214a3e9ab794afce703b991ba6ba0c", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -17,12 +17,12 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config \\\n   mingw-w64\n \n-RUN curl -sL https://nodejs.org/dist/v14.4.0/node-v14.4.0-linux-x64.tar.xz | tar -xJ\n-ENV PATH=\"/node-v14.4.0-linux-x64/bin:${PATH}\"\n+RUN curl -sL https://nodejs.org/dist/v16.9.0/node-v16.9.0-linux-x64.tar.xz | tar -xJ\n+ENV PATH=\"/node-v16.9.0-linux-x64/bin:${PATH}\"\n # Install es-check\n # Pin its version to prevent unrelated CI failures due to future es-check versions.\n-RUN npm install es-check@5.2.3 -g\n-RUN npm install eslint@7.20.0 -g\n+RUN npm install es-check@6.1.1 -g\n+RUN npm install eslint@8.6.0 -g\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n@@ -40,5 +40,5 @@ ENV SCRIPT python3 ../x.py --stage 2 test src/tools/expand-yaml-anchors && \\\n            /scripts/validate-toolstate.sh && \\\n            /scripts/validate-error-codes.sh && \\\n            # Runs checks to ensure that there are no ES5 issues in our JS code.\n-           es-check es5 ../src/librustdoc/html/static/js/*.js && \\\n+           es-check es6 ../src/librustdoc/html/static/js/*.js && \\\n            eslint ../src/librustdoc/html/static/js/*.js"}, {"sha": "eafc74b9945baf21b485c226eb36cd738213643f", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 101, "deletions": 100, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -19,118 +19,119 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n-        for trait_def_id in self.cx.tcx.all_traits() {\n-            if !self.cx.cache.access_levels.is_public(trait_def_id)\n-                || self.cx.generated_synthetics.get(&(ty, trait_def_id)).is_some()\n-            {\n-                continue;\n-            }\n-            // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n-            let trait_impls = self.cx.tcx.trait_impls_of(trait_def_id);\n-            for &impl_def_id in trait_impls.blanket_impls() {\n-                trace!(\n-                    \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n-                    trait_def_id,\n-                    impl_def_id\n-                );\n-                let trait_ref = self.cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n-                let is_param = matches!(trait_ref.self_ty().kind(), ty::Param(_));\n-                let may_apply = is_param && self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n-                    let ty = ty.subst(infcx.tcx, substs);\n-                    let param_env = param_env.subst(infcx.tcx, substs);\n+        self.cx.with_all_traits(|cx, all_traits| {\n+            for &trait_def_id in all_traits {\n+                if !cx.cache.access_levels.is_public(trait_def_id)\n+                    || cx.generated_synthetics.get(&(ty, trait_def_id)).is_some()\n+                {\n+                    continue;\n+                }\n+                // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n+                let trait_impls = cx.tcx.trait_impls_of(trait_def_id);\n+                for &impl_def_id in trait_impls.blanket_impls() {\n+                    trace!(\n+                        \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n+                        trait_def_id,\n+                        impl_def_id\n+                    );\n+                    let trait_ref = cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n+                    let is_param = matches!(trait_ref.self_ty().kind(), ty::Param(_));\n+                    let may_apply = is_param && cx.tcx.infer_ctxt().enter(|infcx| {\n+                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n+                        let ty = ty.subst(infcx.tcx, substs);\n+                        let param_env = param_env.subst(infcx.tcx, substs);\n \n-                    let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                    let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n \n-                    // Require the type the impl is implemented on to match\n-                    // our type, and ignore the impl if there was a mismatch.\n-                    let cause = traits::ObligationCause::dummy();\n-                    let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty);\n-                    if let Ok(InferOk { value: (), obligations }) = eq_result {\n-                        // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                        drop(obligations);\n+                        // Require the type the impl is implemented on to match\n+                        // our type, and ignore the impl if there was a mismatch.\n+                        let cause = traits::ObligationCause::dummy();\n+                        let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty);\n+                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n+                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                            drop(obligations);\n \n-                        trace!(\n-                            \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n-                            param_env,\n-                            trait_ref,\n-                            ty\n-                        );\n-                        let predicates = self\n-                            .cx\n-                            .tcx\n-                            .predicates_of(impl_def_id)\n-                            .instantiate(self.cx.tcx, impl_substs)\n-                            .predicates\n-                            .into_iter()\n-                            .chain(Some(\n-                                ty::Binder::dummy(trait_ref)\n-                                    .to_poly_trait_predicate()\n-                                    .map_bound(ty::PredicateKind::Trait)\n-                                    .to_predicate(infcx.tcx),\n-                            ));\n-                        for predicate in predicates {\n-                            debug!(\"testing predicate {:?}\", predicate);\n-                            let obligation = traits::Obligation::new(\n-                                traits::ObligationCause::dummy(),\n+                            trace!(\n+                                \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n                                 param_env,\n-                                predicate,\n+                                trait_ref,\n+                                ty\n                             );\n-                            match infcx.evaluate_obligation(&obligation) {\n-                                Ok(eval_result) if eval_result.may_apply() => {}\n-                                Err(traits::OverflowError::Canonical) => {}\n-                                Err(traits::OverflowError::ErrorReporting) => {}\n-                                _ => {\n-                                    return false;\n+                            let predicates = cx\n+                                .tcx\n+                                .predicates_of(impl_def_id)\n+                                .instantiate(cx.tcx, impl_substs)\n+                                .predicates\n+                                .into_iter()\n+                                .chain(Some(\n+                                    ty::Binder::dummy(trait_ref)\n+                                        .to_poly_trait_predicate()\n+                                        .map_bound(ty::PredicateKind::Trait)\n+                                        .to_predicate(infcx.tcx),\n+                                ));\n+                            for predicate in predicates {\n+                                debug!(\"testing predicate {:?}\", predicate);\n+                                let obligation = traits::Obligation::new(\n+                                    traits::ObligationCause::dummy(),\n+                                    param_env,\n+                                    predicate,\n+                                );\n+                                match infcx.evaluate_obligation(&obligation) {\n+                                    Ok(eval_result) if eval_result.may_apply() => {}\n+                                    Err(traits::OverflowError::Canonical) => {}\n+                                    Err(traits::OverflowError::ErrorReporting) => {}\n+                                    _ => {\n+                                        return false;\n+                                    }\n                                 }\n                             }\n+                            true\n+                        } else {\n+                            false\n                         }\n-                        true\n-                    } else {\n-                        false\n+                    });\n+                    debug!(\n+                        \"get_blanket_impls: found applicable impl: {} for trait_ref={:?}, ty={:?}\",\n+                        may_apply, trait_ref, ty\n+                    );\n+                    if !may_apply {\n+                        continue;\n                     }\n-                });\n-                debug!(\n-                    \"get_blanket_impls: found applicable impl: {} for trait_ref={:?}, ty={:?}\",\n-                    may_apply, trait_ref, ty\n-                );\n-                if !may_apply {\n-                    continue;\n-                }\n \n-                self.cx.generated_synthetics.insert((ty, trait_def_id));\n+                    cx.generated_synthetics.insert((ty, trait_def_id));\n \n-                impls.push(Item {\n-                    name: None,\n-                    attrs: Default::default(),\n-                    visibility: Inherited,\n-                    def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n-                    kind: box ImplItem(Impl {\n-                        unsafety: hir::Unsafety::Normal,\n-                        generics: clean_ty_generics(\n-                            self.cx,\n-                            self.cx.tcx.generics_of(impl_def_id),\n-                            self.cx.tcx.explicit_predicates_of(impl_def_id),\n-                        ),\n-                        // FIXME(eddyb) compute both `trait_` and `for_` from\n-                        // the post-inference `trait_ref`, as it's more accurate.\n-                        trait_: Some(trait_ref.clean(self.cx)),\n-                        for_: ty.clean(self.cx),\n-                        items: self\n-                            .cx\n-                            .tcx\n-                            .associated_items(impl_def_id)\n-                            .in_definition_order()\n-                            .map(|x| x.clean(self.cx))\n-                            .collect::<Vec<_>>(),\n-                        polarity: ty::ImplPolarity::Positive,\n-                        kind: ImplKind::Blanket(box trait_ref.self_ty().clean(self.cx)),\n-                    }),\n-                    cfg: None,\n-                });\n+                    impls.push(Item {\n+                        name: None,\n+                        attrs: Default::default(),\n+                        visibility: Inherited,\n+                        def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n+                        kind: box ImplItem(Impl {\n+                            unsafety: hir::Unsafety::Normal,\n+                            generics: clean_ty_generics(\n+                                cx,\n+                                cx.tcx.generics_of(impl_def_id),\n+                                cx.tcx.explicit_predicates_of(impl_def_id),\n+                            ),\n+                            // FIXME(eddyb) compute both `trait_` and `for_` from\n+                            // the post-inference `trait_ref`, as it's more accurate.\n+                            trait_: Some(trait_ref.clean(cx)),\n+                            for_: ty.clean(cx),\n+                            items: cx\n+                                .tcx\n+                                .associated_items(impl_def_id)\n+                                .in_definition_order()\n+                                .map(|x| x.clean(cx))\n+                                .collect::<Vec<_>>(),\n+                            polarity: ty::ImplPolarity::Positive,\n+                            kind: ImplKind::Blanket(box trait_ref.self_ty().clean(cx)),\n+                        }),\n+                        cfg: None,\n+                    });\n+                }\n             }\n-        }\n+        });\n+\n         impls\n     }\n }"}, {"sha": "b91ba5523e0741bf950fbfc341147c135a481d21", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -291,6 +291,7 @@ crate fn build_impls(\n     attrs: Option<Attrs<'_>>,\n     ret: &mut Vec<clean::Item>,\n ) {\n+    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_inherent_impls\");\n     let tcx = cx.tcx;\n \n     // for each implementation of an item represented by `did`, build the clean::Item for that impl\n@@ -338,7 +339,7 @@ crate fn build_impl(\n         return;\n     }\n \n-    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impl\");\n+    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_impl\");\n \n     let tcx = cx.tcx;\n     let associated_trait = tcx.impl_trait_ref(did);"}, {"sha": "f0e9b716081ac7b31a7246060ecbe0f1d96d1ca9", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -179,6 +179,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n         };\n \n         if let Some(prim) = target.primitive_type() {\n+            let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n             for &did in prim.impls(tcx).iter().filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, None, did, None, ret);\n             }"}, {"sha": "22f59d39799c4fbb56353affc95856af16f2ea47", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1,30 +1,23 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n-use rustc_driver::abort_on_err;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::HirId;\n-use rustc_hir::{\n-    intravisit::{self, NestedVisitorMap, Visitor},\n-    Path,\n-};\n-use rustc_interface::{interface, Queries};\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{HirId, Path};\n+use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_resolve as resolve;\n-use rustc_resolve::Namespace::TypeNS;\n use rustc_session::config::{self, CrateType, ErrorOutputType};\n use rustc_session::lint;\n use rustc_session::DiagnosticOutput;\n use rustc_session::Session;\n-use rustc_span::def_id::CRATE_DEF_INDEX;\n-use rustc_span::source_map;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{source_map, Span};\n \n use std::cell::RefCell;\n use std::lazy::SyncLazy;\n@@ -39,14 +32,20 @@ use crate::passes::{self, Condition::*};\n \n crate use rustc_session::config::{DebuggingOptions, Input, Options};\n \n+crate struct ResolverCaches {\n+    pub all_traits: Option<Vec<DefId>>,\n+    pub all_trait_impls: Option<Vec<DefId>>,\n+}\n+\n crate struct DocContext<'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     /// Name resolver. Used for intra-doc links.\n     ///\n     /// The `Rc<RefCell<...>>` wrapping is needed because that is what's returned by\n-    /// [`Queries::expansion()`].\n+    /// [`rustc_interface::Queries::expansion()`].\n     // FIXME: see if we can get rid of this RefCell somehow\n     crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    crate resolver_caches: ResolverCaches,\n     /// Used for normalization.\n     ///\n     /// Most of this logic is copied from rustc_lint::late.\n@@ -123,6 +122,18 @@ impl<'tcx> DocContext<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    crate fn with_all_traits(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n+        let all_traits = self.resolver_caches.all_traits.take();\n+        f(self, all_traits.as_ref().expect(\"`all_traits` are already borrowed\"));\n+        self.resolver_caches.all_traits = all_traits;\n+    }\n+\n+    crate fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n+        let all_trait_impls = self.resolver_caches.all_trait_impls.take();\n+        f(self, all_trait_impls.as_ref().expect(\"`all_trait_impls` are already borrowed\"));\n+        self.resolver_caches.all_trait_impls = all_trait_impls;\n+    }\n }\n \n /// Creates a new diagnostic `Handler` that can be used to emit warnings and errors.\n@@ -284,49 +295,10 @@ crate fn create_config(\n     }\n }\n \n-crate fn create_resolver<'a>(\n-    externs: config::Externs,\n-    queries: &Queries<'a>,\n-    sess: &Session,\n-) -> Rc<RefCell<interface::BoxedResolver>> {\n-    let (krate, resolver, _) = &*abort_on_err(queries.expansion(), sess).peek();\n-    let resolver = resolver.clone();\n-\n-    let resolver = crate::passes::collect_intra_doc_links::load_intra_link_crates(resolver, krate);\n-\n-    // FIXME: somehow rustdoc is still missing crates even though we loaded all\n-    // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n-    // DO NOT REMOVE THIS without first testing on the reproducer in\n-    // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n-    let extern_names: Vec<String> = externs\n-        .iter()\n-        .filter(|(_, entry)| entry.add_prelude)\n-        .map(|(name, _)| name)\n-        .cloned()\n-        .collect();\n-    resolver.borrow_mut().access(|resolver| {\n-        sess.time(\"load_extern_crates\", || {\n-            for extern_name in &extern_names {\n-                debug!(\"loading extern crate {}\", extern_name);\n-                if let Err(()) = resolver\n-                    .resolve_str_path_error(\n-                        DUMMY_SP,\n-                        extern_name,\n-                        TypeNS,\n-                        LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n-                  ) {\n-                    warn!(\"unable to resolve external crate {} (do you have an unused `--extern` crate?)\", extern_name)\n-                  }\n-            }\n-        });\n-    });\n-\n-    resolver\n-}\n-\n crate fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n     resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    resolver_caches: ResolverCaches,\n     show_coverage: bool,\n     render_options: RenderOptions,\n     output_format: OutputFormat,\n@@ -355,23 +327,29 @@ crate fn run_global_ctxt(\n     });\n     rustc_passes::stability::check_unused_or_stable_features(tcx);\n \n+    let auto_traits = resolver_caches\n+        .all_traits\n+        .as_ref()\n+        .expect(\"`all_traits` are already borrowed\")\n+        .iter()\n+        .copied()\n+        .filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id))\n+        .collect();\n     let access_levels = AccessLevels {\n         map: tcx.privacy_access_levels(()).map.iter().map(|(k, v)| (k.to_def_id(), *v)).collect(),\n     };\n \n     let mut ctxt = DocContext {\n         tcx,\n         resolver,\n+        resolver_caches,\n         param_env: ParamEnv::empty(),\n         external_traits: Default::default(),\n         active_extern_traits: Default::default(),\n         substs: Default::default(),\n         impl_trait_bounds: Default::default(),\n         generated_synthetics: Default::default(),\n-        auto_traits: tcx\n-            .all_traits()\n-            .filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id))\n-            .collect(),\n+        auto_traits,\n         module_trait_cache: FxHashMap::default(),\n         cache: Cache::new(access_levels, render_options.document_private),\n         inlined: FxHashSet::default(),"}, {"sha": "7adf63f26f6025bc9201da9147eceafbb3fba424", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -312,14 +312,6 @@ impl AllTypes {\n         f.write_str(\n             \"<h1 class=\\\"fqn\\\">\\\n                  <span class=\\\"in-band\\\">List of all items</span>\\\n-                 <span class=\\\"out-of-band\\\">\\\n-                     <span id=\\\"render-detail\\\">\\\n-                         <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n-                            title=\\\"collapse all docs\\\">\\\n-                             [<span class=\\\"inner\\\">&#x2212;</span>]\\\n-                         </a>\\\n-                     </span>\n-                 </span>\n              </h1>\",\n         );\n         // Note: print_entries does not escape the title, because we know the current set of titles"}, {"sha": "fab64abc3e1493c2eab1a9e6b3952522d16a7cd9", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -866,18 +866,24 @@ h2.small-section-header > .anchor {\n \tdisplay: inline-flex;\n \twidth: calc(100% - 63px);\n }\n+.search-results-title {\n+\tdisplay: inline;\n+}\n+#search-settings {\n+\tfont-size: 1.5rem;\n+\tfont-weight: 500;\n+\tmargin-bottom: 20px;\n+}\n #crate-search {\n \tmin-width: 115px;\n \tmargin-top: 5px;\n-\tpadding: 6px;\n-\tpadding-right: 19px;\n-\tflex: none;\n+\tmargin-left: 0.2em;\n+\tpadding-left: 0.3em;\n+\tpadding-right: 23px;\n \tborder: 0;\n-\tborder-right: 0;\n-\tborder-radius: 4px 0 0 4px;\n+\tborder-radius: 4px;\n \toutline: none;\n \tcursor: pointer;\n-\tborder-right: 1px solid;\n \t-moz-appearance: none;\n \t-webkit-appearance: none;\n \t/* Removes default arrow from firefox */"}, {"sha": "e859431e1f189e68a7b761d85374b89df4a929a4", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1085,7 +1085,7 @@ window.initSearch = function(rawSearchIndex) {\n         return \"<button>\" + text + \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n     }\n \n-    function showResults(results, go_to_first) {\n+    function showResults(results, go_to_first, filterCrates) {\n         var search = searchState.outputElement();\n         if (go_to_first || (results.others.length === 1\n             && getSettingValue(\"go-to-only-result\") === \"true\"\n@@ -1126,9 +1126,16 @@ window.initSearch = function(rawSearchIndex) {\n             }\n         }\n \n-        var output = \"<h1>Results for \" + escape(query.query) +\n+        let crates = `<select id=\"crate-search\"><option value=\"All crates\">All crates</option>`;\n+        for (let c of window.ALL_CRATES) {\n+            crates += `<option value=\"${c}\" ${c == filterCrates && \"selected\"}>${c}</option>`;\n+        }\n+        crates += `</select>`;\n+        var output = `<div id=\"search-settings\">\n+            <h1 class=\"search-results-title\">Results for ${escape(query.query)} ` +\n             (query.type ? \" (type: \" + escape(query.type) + \")\" : \"\") + \"</h1>\" +\n-            \"<div id=\\\"titles\\\">\" +\n+            ` in ${crates} ` +\n+            `</div><div id=\"titles\">` +\n             makeTabHeader(0, \"In Names\", ret_others[1]) +\n             makeTabHeader(1, \"In Parameters\", ret_in_args[1]) +\n             makeTabHeader(2, \"In Return Types\", ret_returned[1]) +\n@@ -1141,6 +1148,7 @@ window.initSearch = function(rawSearchIndex) {\n         resultsElem.appendChild(ret_returned[0]);\n \n         search.innerHTML = output;\n+        document.getElementById(\"crate-search\").addEventListener(\"input\", updateCrate);\n         search.appendChild(resultsElem);\n         // Reset focused elements.\n         searchState.focusedByTab = [null, null, null];\n@@ -1316,7 +1324,8 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         var filterCrates = getFilterCrates();\n-        showResults(execSearch(query, searchWords, filterCrates), params[\"go_to_first\"]);\n+        showResults(execSearch(query, searchWords, filterCrates),\n+            params[\"go_to_first\"], filterCrates);\n     }\n \n     function buildIndex(rawSearchIndex) {\n@@ -1552,19 +1561,6 @@ window.initSearch = function(rawSearchIndex) {\n             }\n         });\n \n-\n-        var selectCrate = document.getElementById(\"crate-search\");\n-        if (selectCrate) {\n-            selectCrate.onchange = function() {\n-                updateLocalStorage(\"rustdoc-saved-filter-crate\", selectCrate.value);\n-                // In case you \"cut\" the entry from the search input, then change the crate filter\n-                // before paste back the previous search, you get the old search results without\n-                // the filter. To prevent this, we need to remove the previous results.\n-                currentResults = null;\n-                search(undefined, true);\n-            };\n-        }\n-\n         // Push and pop states are used to add search results to the browser\n         // history.\n         if (searchState.browserSupportsHistoryApi()) {\n@@ -1616,6 +1612,15 @@ window.initSearch = function(rawSearchIndex) {\n         };\n     }\n \n+    function updateCrate(ev) {\n+        updateLocalStorage(\"rustdoc-saved-filter-crate\", ev.target.value);\n+        // In case you \"cut\" the entry from the search input, then change the crate filter\n+        // before paste back the previous search, you get the old search results without\n+        // the filter. To prevent this, we need to remove the previous results.\n+        currentResults = null;\n+        search(undefined, true);\n+    }\n+\n     searchWords = buildIndex(rawSearchIndex);\n     registerSearchEvents();\n     // If there's a search term in the URL, execute the search now."}, {"sha": "5cade1b1a4c73d370929ef831f7eb2eeca368913", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -105,11 +105,7 @@\n                     </div> {#- -#}\n                     <form class=\"search-form\"> {#- -#}\n                         <div class=\"search-container\"> {#- -#}\n-                            <div>{%- if layout.generate_search_filter -%}\n-                                <select id=\"crate-search\"> {#- -#}\n-                                    <option value=\"All crates\">All crates</option> {#- -#}\n-                                </select> {#- -#}\n-                                {%- endif -%}\n+                            <div>\n                                 <input {# -#}\n                                     class=\"search-input\" {# -#}\n                                     name=\"search\" {# -#}"}, {"sha": "d7741c4fde2391a0cb75c3e8c44d3c71f13b2cce", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -82,6 +82,7 @@ use rustc_session::getopts;\n use rustc_session::{early_error, early_warn};\n \n use crate::clean::utils::DOC_RUST_LANG_ORG_CHANNEL;\n+use crate::passes::collect_intra_doc_links;\n \n /// A macro to create a FxHashMap.\n ///\n@@ -798,7 +799,15 @@ fn main_options(options: config::Options) -> MainResult {\n             // We need to hold on to the complete resolver, so we cause everything to be\n             // cloned for the analysis passes to use. Suboptimal, but necessary in the\n             // current architecture.\n-            let resolver = core::create_resolver(externs, queries, sess);\n+            // FIXME(#83761): Resolver cloning can lead to inconsistencies between data in the\n+            // two copies because one of the copies can be modified after `TyCtxt` construction.\n+            let (resolver, resolver_caches) = {\n+                let (krate, resolver, _) = &*abort_on_err(queries.expansion(), sess).peek();\n+                let resolver_caches = resolver.borrow_mut().access(|resolver| {\n+                    collect_intra_doc_links::early_resolve_intra_doc_links(resolver, krate, externs)\n+                });\n+                (resolver.clone(), resolver_caches)\n+            };\n \n             if sess.diagnostic().has_errors_or_lint_errors() {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n@@ -811,6 +820,7 @@ fn main_options(options: config::Options) -> MainResult {\n                     core::run_global_ctxt(\n                         tcx,\n                         resolver,\n+                        resolver_caches,\n                         show_coverage,\n                         render_options,\n                         output_format,"}, {"sha": "49ff4517a4eb01d4f6b3ab8f48b95b9940d55b17", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -38,7 +38,7 @@ use crate::passes::Pass;\n use crate::visit::DocVisitor;\n \n mod early;\n-crate use early::load_intra_link_crates;\n+crate use early::early_resolve_intra_doc_links;\n \n crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\","}, {"sha": "31d6ac44a9460c732ee288d4750c8915dc363d13", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 91, "deletions": 53, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1,98 +1,136 @@\n-use ast::visit;\n-use rustc_ast as ast;\n+use crate::clean;\n+use crate::core::ResolverCaches;\n+use crate::html::markdown::markdown_links;\n+use crate::passes::collect_intra_doc_links::preprocess_link;\n+\n+use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_ast::{self as ast, ItemKind};\n+use rustc_ast_lowering::ResolverAstLowering;\n use rustc_hir::def::Namespace::TypeNS;\n-use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n-use rustc_interface::interface;\n-use rustc_span::Span;\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n+use rustc_resolve::Resolver;\n+use rustc_session::config::Externs;\n+use rustc_span::{Span, DUMMY_SP};\n \n-use std::cell::RefCell;\n use std::mem;\n-use std::rc::Rc;\n-\n-type Resolver = Rc<RefCell<interface::BoxedResolver>>;\n-// Letting the resolver escape at the end of the function leads to inconsistencies between the\n-// crates the TyCtxt sees and the resolver sees (because the resolver could load more crates\n-// after escaping). Hopefully `IntraLinkCrateLoader` gets all the crates we need ...\n-crate fn load_intra_link_crates(resolver: Resolver, krate: &ast::Crate) -> Resolver {\n-    let mut loader = IntraLinkCrateLoader { current_mod: CRATE_DEF_ID, resolver };\n-    // `walk_crate` doesn't visit the crate itself for some reason.\n+\n+crate fn early_resolve_intra_doc_links(\n+    resolver: &mut Resolver<'_>,\n+    krate: &ast::Crate,\n+    externs: Externs,\n+) -> ResolverCaches {\n+    let mut loader = IntraLinkCrateLoader {\n+        resolver,\n+        current_mod: CRATE_DEF_ID,\n+        all_traits: Default::default(),\n+        all_trait_impls: Default::default(),\n+    };\n+\n+    // Overridden `visit_item` below doesn't apply to the crate root,\n+    // so we have to visit its attributes and exports separately.\n     loader.load_links_in_attrs(&krate.attrs, krate.span);\n     visit::walk_crate(&mut loader, krate);\n-    loader.resolver\n+    loader.fill_resolver_caches();\n+\n+    // FIXME: somehow rustdoc is still missing crates even though we loaded all\n+    // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n+    // DO NOT REMOVE THIS without first testing on the reproducer in\n+    // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n+    for (extern_name, _) in externs.iter().filter(|(_, entry)| entry.add_prelude) {\n+        let _ = loader.resolver.resolve_str_path_error(\n+            DUMMY_SP,\n+            extern_name,\n+            TypeNS,\n+            CRATE_DEF_ID.to_def_id(),\n+        );\n+    }\n+\n+    ResolverCaches {\n+        all_traits: Some(loader.all_traits),\n+        all_trait_impls: Some(loader.all_trait_impls),\n+    }\n }\n \n-struct IntraLinkCrateLoader {\n+struct IntraLinkCrateLoader<'r, 'ra> {\n+    resolver: &'r mut Resolver<'ra>,\n     current_mod: LocalDefId,\n-    resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    all_traits: Vec<DefId>,\n+    all_trait_impls: Vec<DefId>,\n }\n \n-impl IntraLinkCrateLoader {\n-    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute], span: Span) {\n-        use crate::html::markdown::markdown_links;\n-        use crate::passes::collect_intra_doc_links::preprocess_link;\n+impl IntraLinkCrateLoader<'_, '_> {\n+    fn fill_resolver_caches(&mut self) {\n+        for cnum in self.resolver.cstore().crates_untracked() {\n+            let all_traits = self.resolver.cstore().traits_in_crate_untracked(cnum);\n+            let all_trait_impls = self.resolver.cstore().trait_impls_in_crate_untracked(cnum);\n \n-        // FIXME: this probably needs to consider inlining\n-        let attrs = crate::clean::Attributes::from_ast(attrs, None);\n+            self.all_traits.extend(all_traits);\n+            self.all_trait_impls.extend(all_trait_impls.into_iter().map(|(def_id, _)| def_id));\n+        }\n+    }\n+\n+    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute], span: Span) {\n+        // FIXME: this needs to consider export inlining.\n+        let attrs = clean::Attributes::from_ast(attrs, None);\n         for (parent_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n-            debug!(?doc);\n-            for link in markdown_links(doc.as_str()) {\n-                debug!(?link.link);\n+            let module_id = parent_module.unwrap_or(self.current_mod.to_def_id());\n+\n+            for link in markdown_links(&doc.as_str()) {\n                 let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n                     x.path_str\n                 } else {\n                     continue;\n                 };\n-                self.resolver.borrow_mut().access(|resolver| {\n-                    let _ = resolver.resolve_str_path_error(\n-                        span,\n-                        &path_str,\n-                        TypeNS,\n-                        parent_module.unwrap_or_else(|| self.current_mod.to_def_id()),\n-                    );\n-                });\n+                let _ = self.resolver.resolve_str_path_error(span, &path_str, TypeNS, module_id);\n             }\n         }\n     }\n }\n \n-impl visit::Visitor<'_> for IntraLinkCrateLoader {\n-    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        self.load_links_in_attrs(&item.attrs, item.span);\n-        visit::walk_foreign_item(self, item)\n-    }\n-\n+impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        use rustc_ast_lowering::ResolverAstLowering;\n-\n-        if let ast::ItemKind::Mod(..) = item.kind {\n-            let new_mod =\n-                self.resolver.borrow_mut().access(|resolver| resolver.local_def_id(item.id));\n-            let old_mod = mem::replace(&mut self.current_mod, new_mod);\n+        if let ItemKind::Mod(..) = item.kind {\n+            let old_mod = mem::replace(&mut self.current_mod, self.resolver.local_def_id(item.id));\n \n             self.load_links_in_attrs(&item.attrs, item.span);\n             visit::walk_item(self, item);\n \n             self.current_mod = old_mod;\n         } else {\n+            match item.kind {\n+                ItemKind::Trait(..) => {\n+                    self.all_traits.push(self.resolver.local_def_id(item.id).to_def_id());\n+                }\n+                ItemKind::Impl(box ast::Impl { of_trait: Some(..), .. }) => {\n+                    self.all_trait_impls.push(self.resolver.local_def_id(item.id).to_def_id());\n+                }\n+                _ => {}\n+            }\n             self.load_links_in_attrs(&item.attrs, item.span);\n             visit::walk_item(self, item);\n         }\n     }\n \n-    // NOTE: if doc-comments are ever allowed on function parameters, this will have to implement `visit_param` too.\n-\n-    fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: visit::AssocCtxt) {\n+    fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: AssocCtxt) {\n         self.load_links_in_attrs(&item.attrs, item.span);\n         visit::walk_assoc_item(self, item, ctxt)\n     }\n \n-    fn visit_field_def(&mut self, field: &ast::FieldDef) {\n-        self.load_links_in_attrs(&field.attrs, field.span);\n-        visit::walk_field_def(self, field)\n+    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n+        self.load_links_in_attrs(&item.attrs, item.span);\n+        visit::walk_foreign_item(self, item)\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant) {\n         self.load_links_in_attrs(&v.attrs, v.span);\n         visit::walk_variant(self, v)\n     }\n+\n+    fn visit_field_def(&mut self, field: &ast::FieldDef) {\n+        self.load_links_in_attrs(&field.attrs, field.span);\n+        visit::walk_field_def(self, field)\n+    }\n+\n+    // NOTE: if doc-comments are ever allowed on other nodes (e.g. function parameters),\n+    // then this will have to implement other visitor methods too.\n }"}, {"sha": "66ac612ea37c40d0011d8ca00598fb31c6f300c0", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -34,26 +34,28 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n \n     let mut new_items = Vec::new();\n \n-    for &cnum in cx.tcx.crates(()).iter() {\n-        for &(did, _) in cx.tcx.all_trait_implementations(cnum).iter() {\n-            inline::build_impl(cx, None, did, None, &mut new_items);\n+    // External trait impls.\n+    cx.with_all_trait_impls(|cx, all_trait_impls| {\n+        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n+        for &impl_def_id in all_trait_impls.iter().skip_while(|def_id| def_id.is_local()) {\n+            inline::build_impl(cx, None, impl_def_id, None, &mut new_items);\n         }\n-    }\n+    });\n \n     // Also try to inline primitive impls from other crates.\n-    for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n-        if !def_id.is_local() {\n-            cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n+    cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n+        for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n+            if !def_id.is_local() {\n                 inline::build_impl(cx, None, def_id, None, &mut new_items);\n \n                 // FIXME(eddyb) is this `doc(hidden)` check needed?\n                 if !cx.tcx.is_doc_hidden(def_id) {\n                     let impls = get_auto_trait_and_blanket_impls(cx, def_id);\n                     new_items.extend(impls.filter(|i| cx.inlined.insert(i.def_id)));\n                 }\n-            });\n+            }\n         }\n-    }\n+    });\n \n     let mut cleaner = BadImplStripper { prims, items: crate_items };\n     let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n@@ -126,36 +128,33 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         }\n     });\n \n-    // `tcx.crates(())` doesn't include the local crate, and `tcx.all_trait_implementations`\n-    // doesn't work with it anyway, so pull them from the HIR map instead\n-    let mut extra_attrs = Vec::new();\n-    for trait_did in cx.tcx.all_traits() {\n-        for &impl_did in cx.tcx.hir().trait_impls(trait_did) {\n-            let impl_did = impl_did.to_def_id();\n-            cx.tcx.sess.prof.generic_activity(\"build_local_trait_impl\").run(|| {\n-                let mut parent = cx.tcx.parent(impl_did);\n-                while let Some(did) = parent {\n-                    extra_attrs.extend(\n-                        cx.tcx\n-                            .get_attrs(did)\n-                            .iter()\n-                            .filter(|attr| attr.has_name(sym::doc))\n-                            .filter(|attr| {\n-                                if let Some([attr]) = attr.meta_item_list().as_deref() {\n-                                    attr.has_name(sym::cfg)\n-                                } else {\n-                                    false\n-                                }\n-                            })\n-                            .cloned(),\n-                    );\n-                    parent = cx.tcx.parent(did);\n-                }\n-                inline::build_impl(cx, None, impl_did, Some(&extra_attrs), &mut new_items);\n-                extra_attrs.clear();\n-            });\n+    // Local trait impls.\n+    cx.with_all_trait_impls(|cx, all_trait_impls| {\n+        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n+        let mut attr_buf = Vec::new();\n+        for &impl_def_id in all_trait_impls.iter().take_while(|def_id| def_id.is_local()) {\n+            let mut parent = cx.tcx.parent(impl_def_id);\n+            while let Some(did) = parent {\n+                attr_buf.extend(\n+                    cx.tcx\n+                        .get_attrs(did)\n+                        .iter()\n+                        .filter(|attr| attr.has_name(sym::doc))\n+                        .filter(|attr| {\n+                            if let Some([attr]) = attr.meta_item_list().as_deref() {\n+                                attr.has_name(sym::cfg)\n+                            } else {\n+                                false\n+                            }\n+                        })\n+                        .cloned(),\n+                );\n+                parent = cx.tcx.parent(did);\n+            }\n+            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items);\n+            attr_buf.clear();\n         }\n-    }\n+    });\n \n     if let ModuleItem(Module { items, .. }) = &mut *krate.module.kind {\n         items.extend(synth_impls);"}, {"sha": "712920b16a91babf02b44faa00719b5ec5bf0b5a", "filename": "src/test/rustdoc-gui/escape-key.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Frustdoc-gui%2Fescape-key.goml", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Frustdoc-gui%2Fescape-key.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fescape-key.goml?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1,7 +1,7 @@\n goto: file://|DOC_PATH|/test_docs/index.html\n // First, we check that the search results are hidden when the Escape key is pressed.\n write: (\".search-input\", \"test\")\n-wait-for: \"#search > h1\" // The search element is empty before the first search \n+wait-for: \"#search h1\" // The search element is empty before the first search \n assert-attribute: (\"#search\", {\"class\": \"content\"})\n assert-attribute: (\"#main-content\", {\"class\": \"content hidden\"})\n press-key: \"Escape\""}, {"sha": "e5cdf3ea7a1699c3636e58c675bdb50f93122291", "filename": "src/test/rustdoc-gui/search-filter.goml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Frustdoc-gui%2Fsearch-filter.goml", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Frustdoc-gui%2Fsearch-filter.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-filter.goml?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -5,14 +5,12 @@ write: (\".search-input\", \"test\")\n wait-for: \"#titles\"\n assert-text: (\"#results .externcrate\", \"test_docs\")\n \n-goto: file://|DOC_PATH|/test_docs/index.html\n+wait-for: \"#crate-search\"\n // We now want to change the crate filter.\n click: \"#crate-search\"\n // We select \"lib2\" option then press enter to change the filter.\n press-key: \"ArrowDown\"\n press-key: \"Enter\"\n-// We now make the search again.\n-write: (\".search-input\", \"test\")\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n // We check that there is no more \"test_docs\" appearing."}, {"sha": "6e0ad8e0fa7fbcc48020e4bea2b82ae8ac393137", "filename": "src/test/rustdoc-gui/toggle-docs-mobile.goml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -1,12 +1,12 @@\n goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n size: (433, 600)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 280) // This is the position of the top doc comment toggle\n+click: (4, 240) // This is the position of the top doc comment toggle\n assert-attribute-false: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 280)\n+click: (4, 240)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n // To ensure that the toggle isn't over the text, we check that the toggle isn't clicked.\n-click: (3, 280)\n+click: (3, 240)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n \n // Assert the position of the toggle on the top doc block."}, {"sha": "2ac3ca29355d849da230edb65f22277810446c52", "filename": "src/test/ui/foreign/issue-91370-foreign-fn-block-impl.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Fui%2Fforeign%2Fissue-91370-foreign-fn-block-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Fui%2Fforeign%2Fissue-91370-foreign-fn-block-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign%2Fissue-91370-foreign-fn-block-impl.rs?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -0,0 +1,12 @@\n+// Regression test for issue #91370.\n+\n+extern {\n+    //~^ `extern` blocks define existing foreign functions\n+    fn f() {\n+        //~^ incorrect function inside `extern` block\n+        //~| cannot have a body\n+        impl Copy for u8 {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4fb2f8c659c53786ddfd4db2d95485ca125b16b3", "filename": "src/test/ui/foreign/issue-91370-foreign-fn-block-impl.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Fui%2Fforeign%2Fissue-91370-foreign-fn-block-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7bb8e3677ba4277914e85a3060e5d69151aed44/src%2Ftest%2Fui%2Fforeign%2Fissue-91370-foreign-fn-block-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign%2Fissue-91370-foreign-fn-block-impl.stderr?ref=f7bb8e3677ba4277914e85a3060e5d69151aed44", "patch": "@@ -0,0 +1,21 @@\n+error: incorrect function inside `extern` block\n+  --> $DIR/issue-91370-foreign-fn-block-impl.rs:5:8\n+   |\n+LL |   extern {\n+   |   ------ `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+LL |\n+LL |       fn f() {\n+   |  ________^___-\n+   | |        |\n+   | |        cannot have a body\n+LL | |\n+LL | |\n+LL | |         impl Copy for u8 {}\n+LL | |     }\n+   | |_____- help: remove the invalid body: `;`\n+   |\n+   = help: you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to previous error\n+"}]}