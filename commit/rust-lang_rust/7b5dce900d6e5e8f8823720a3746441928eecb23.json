{"sha": "7b5dce900d6e5e8f8823720a3746441928eecb23", "node_id": "C_kwDOAAsO6NoAKDdiNWRjZTkwMGQ2ZTVlOGY4ODIzNzIwYTM3NDY0NDE5MjhlZWNiMjM", "commit": {"author": {"name": "Jane Lusby", "email": "jlusby@yaah.dev", "date": "2022-05-06T22:03:25Z"}, "committer": {"name": "Jane Lusby", "email": "jlusby@yaah.dev", "date": "2022-05-06T22:03:25Z"}, "message": "This is a pretty good start if you ask me", "tree": {"sha": "5ca7db8925003ff37d983e7b01ec7e48b47a2e63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ca7db8925003ff37d983e7b01ec7e48b47a2e63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b5dce900d6e5e8f8823720a3746441928eecb23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5dce900d6e5e8f8823720a3746441928eecb23", "html_url": "https://github.com/rust-lang/rust/commit/7b5dce900d6e5e8f8823720a3746441928eecb23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b5dce900d6e5e8f8823720a3746441928eecb23/comments", "author": {"login": "yaahc", "id": 1993852, "node_id": "MDQ6VXNlcjE5OTM4NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1993852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaahc", "html_url": "https://github.com/yaahc", "followers_url": "https://api.github.com/users/yaahc/followers", "following_url": "https://api.github.com/users/yaahc/following{/other_user}", "gists_url": "https://api.github.com/users/yaahc/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaahc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaahc/subscriptions", "organizations_url": "https://api.github.com/users/yaahc/orgs", "repos_url": "https://api.github.com/users/yaahc/repos", "events_url": "https://api.github.com/users/yaahc/events{/privacy}", "received_events_url": "https://api.github.com/users/yaahc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yaahc", "id": 1993852, "node_id": "MDQ6VXNlcjE5OTM4NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1993852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaahc", "html_url": "https://github.com/yaahc", "followers_url": "https://api.github.com/users/yaahc/followers", "following_url": "https://api.github.com/users/yaahc/following{/other_user}", "gists_url": "https://api.github.com/users/yaahc/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaahc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaahc/subscriptions", "organizations_url": "https://api.github.com/users/yaahc/orgs", "repos_url": "https://api.github.com/users/yaahc/repos", "events_url": "https://api.github.com/users/yaahc/events{/privacy}", "received_events_url": "https://api.github.com/users/yaahc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72898acdba32e2ccc3fd1bc6deced97a8e1ad001", "url": "https://api.github.com/repos/rust-lang/rust/commits/72898acdba32e2ccc3fd1bc6deced97a8e1ad001", "html_url": "https://github.com/rust-lang/rust/commit/72898acdba32e2ccc3fd1bc6deced97a8e1ad001"}], "stats": {"total": 205, "additions": 138, "deletions": 67}, "files": [{"sha": "342acea29dc5b838eb54897cd9d39031ab011693", "filename": "library/core/src/result.rs", "status": "modified", "additions": 6, "deletions": 66, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7b5dce900d6e5e8f8823720a3746441928eecb23/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5dce900d6e5e8f8823720a3746441928eecb23/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=7b5dce900d6e5e8f8823720a3746441928eecb23", "patch": "@@ -1024,79 +1024,19 @@ impl<T, E> Result<T, E> {\n     /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n     /// ```\n     ///\n-    /// # Common Message Styles\n+    /// # Recommended Message Style\n     ///\n-    /// There are two common styles for how people word `expect` messages. Using\n-    /// the message to present information to users encountering a panic\n-    /// (\"expect as error message\") or using the message to present information\n-    /// to developers debugging the panic (\"expect as precondition\").\n-    ///\n-    /// In the former case the expect message is used to describe the error that\n-    /// has occurred which is considered a bug. Consider the following example:\n-    ///\n-    /// ```should_panic\n-    /// // Read environment variable, panic if it is not present\n-    /// let path = std::env::var(\"IMPORTANT_PATH\").unwrap();\n-    /// ```\n-    ///\n-    /// In the \"expect as error message\" style we would use expect to describe\n-    /// that the environment variable was not set when it should have been:\n-    ///\n-    /// ```should_panic\n-    /// let path = std::env::var(\"IMPORTANT_PATH\")\n-    ///     .expect(\"env variable `IMPORTANT_PATH` is not set\");\n-    /// ```\n-    ///\n-    /// In the \"expect as precondition\" style, we would instead describe the\n-    /// reason we _expect_ the `Result` should be `Ok`. With this style we would\n-    /// prefer to write:\n+    /// We recommend that `expect` messages are used to describe the reason you\n+    /// _expect_ the `Result` should be `Ok`.\n     ///\n     /// ```should_panic\n     /// let path = std::env::var(\"IMPORTANT_PATH\")\n     ///     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n     /// ```\n     ///\n-    /// The \"expect as error message\" style does not work as well with the\n-    /// default output of the std panic hooks, and often ends up repeating\n-    /// information that is already communicated by the source error being\n-    /// unwrapped:\n-    ///\n-    /// ```text\n-    /// thread 'main' panicked at 'env variable `IMPORTANT_PATH` is not set: NotPresent', src/main.rs:4:6\n-    /// ```\n-    ///\n-    /// In this example we end up mentioning that an env variable is not set,\n-    /// followed by our source message that says the env is not present, the\n-    /// only additional information we're communicating is the name of the\n-    /// environment variable being checked.\n-    ///\n-    /// The \"expect as precondition\" style instead focuses on source code\n-    /// readability, making it easier to understand what must have gone wrong in\n-    /// situations where panics are being used to represent bugs exclusively.\n-    /// Also, by framing our expect in terms of what \"SHOULD\" have happened to\n-    /// prevent the source error, we end up introducing new information that is\n-    /// independent from our source error.\n-    ///\n-    /// ```text\n-    /// thread 'main' panicked at 'env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`: NotPresent', src/main.rs:4:6\n-    /// ```\n-    ///\n-    /// In this example we are communicating not only the name of the\n-    /// environment variable that should have been set, but also an explanation\n-    /// for why it should have been set, and we let the source error display as\n-    /// a clear contradiction to our expectation.\n-    ///\n-    /// For programs where panics may be user facing, either style works best\n-    /// when paired with a custom [panic hook] like the one provided by the CLI\n-    /// working group library, [`human-panic`]. This panic hook dumps the panic\n-    /// messages to a crash report file while showing users a more friendly\n-    /// \"Oops, something went wrong!\" message with a suggestion to send the\n-    /// crash report file back to the developers. Panic messages should be used\n-    /// to represent bugs, and the information provided back is context intended\n-    /// for the developer, not the user.\n-    ///\n-    /// [panic hook]: https://doc.rust-lang.org/stable/std/panic/fn.set_hook.html\n-    /// [`human-panic`]: https://docs.rs/human-panic\n+    /// For more detail on expect message styles and the reasoning behind our\n+    /// recommendation please refer to the section on [\"Common Message\n+    /// Styles\"]() in the [`std::error`]() module docs.\n     #[inline]\n     #[track_caller]\n     #[stable(feature = \"result_expect\", since = \"1.4.0\")]"}, {"sha": "84089075f24a76971335492d20739125bcec18f0", "filename": "library/std/src/error.rs", "status": "modified", "additions": 132, "deletions": 1, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7b5dce900d6e5e8f8823720a3746441928eecb23/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5dce900d6e5e8f8823720a3746441928eecb23/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=7b5dce900d6e5e8f8823720a3746441928eecb23", "patch": "@@ -1,4 +1,135 @@\n-//! Traits for working with Errors.\n+//! Interfaces for working with Errors.\n+//!\n+//! # Error Handling In Rust\n+//!\n+//! The Rust language provides two complementary systems for constructing /\n+//! representing, reporting, propagating, reacting to, and discarding errors.\n+//! These responsibilities are collectively known as \"error handling.\" The\n+//! components of the first system, the panic runtime and interfaces, are most\n+//! commonly used to represent bugs that have been detected in your program. The\n+//! components of the second system, `Result`, the error traits, and user\n+//! defined types, are used to represent anticipated runtime failure modes of\n+//! your program.\n+//!\n+//! ## The Panic Interfaces\n+//!\n+//! The following are the primary interfaces of the panic system and the\n+//! responsibilities they cover:\n+//!\n+//! * [`panic!`] and [`panic_any`] (Constructing, Propagated automatically)\n+//! * [`PanicInfo`] (Reporting)\n+//! * [`set_hook`], [`take_hook`], and [`#[panic_handler]`] (Reporting)\n+//! * [`catch_unwind`] and [`resume_unwind`] (Discarding, Propagating)\n+//!\n+//! The following are the primary interfaces of the error system and the\n+//! responsibilities they cover:\n+//!\n+//! * [`Result`] (Propagating, Reacting)\n+//! * The [`Error`] trait (Reporting)\n+//! * User defined types (Constructing / Representing)\n+//! * `match` and [`downcast`] (Reacting)\n+//! * The propagation operator (`?`) (Propagating)\n+//! * The partially stable [`Try`] traits (Propagating, Constructing)\n+//! * [`Termination`] (Reporting)\n+//!\n+//! ## Converting Errors into Panics\n+//!\n+//! The panic and error systems are not entirely distinct. Often times errors\n+//! that are anticipated runtime failures in an API might instead represent bugs\n+//! to a caller. For these situations the standard library provides APIs for\n+//! constructing panics with an `Error` as it's source.\n+//!\n+//! * `Result::unwrap`\n+//! * `Result::expect`\n+//!\n+//! TODO: how do I bridge these two sections?\n+//!\n+//! * unwrap is used in prototyping\n+//! * expect is used in !prototyping (????)\n+//!\n+//! # Common Message Styles\n+//!\n+//! There are two common styles for how people word `expect` messages. Using\n+//! the message to present information to users encountering a panic\n+//! (\"expect as error message\") or using the message to present information\n+//! to developers debugging the panic (\"expect as precondition\").\n+//!\n+//! In the former case the expect message is used to describe the error that\n+//! has occurred which is considered a bug. Consider the following example:\n+//!\n+//! ```should_panic\n+//! // Read environment variable, panic if it is not present\n+//! let path = std::env::var(\"IMPORTANT_PATH\").unwrap();\n+//! ```\n+//!\n+//! In the \"expect as error message\" style we would use expect to describe\n+//! that the environment variable was not set when it should have been:\n+//!\n+//! ```should_panic\n+//! let path = std::env::var(\"IMPORTANT_PATH\")\n+//!     .expect(\"env variable `IMPORTANT_PATH` is not set\");\n+//! ```\n+//!\n+//! In the \"expect as precondition\" style, we would instead describe the\n+//! reason we _expect_ the `Result` should be `Ok`. With this style we would\n+//! prefer to write:\n+//!\n+//! ```should_panic\n+//! let path = std::env::var(\"IMPORTANT_PATH\")\n+//!     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n+//! ```\n+//!\n+//! The \"expect as error message\" style does not work as well with the\n+//! default output of the std panic hooks, and often ends up repeating\n+//! information that is already communicated by the source error being\n+//! unwrapped:\n+//!\n+//! ```text\n+//! thread 'main' panicked at 'env variable `IMPORTANT_PATH` is not set: NotPresent', src/main.rs:4:6\n+//! ```\n+//!\n+//! In this example we end up mentioning that an env variable is not set,\n+//! followed by our source message that says the env is not present, the\n+//! only additional information we're communicating is the name of the\n+//! environment variable being checked.\n+//!\n+//! The \"expect as precondition\" style instead focuses on source code\n+//! readability, making it easier to understand what must have gone wrong in\n+//! situations where panics are being used to represent bugs exclusively.\n+//! Also, by framing our expect in terms of what \"SHOULD\" have happened to\n+//! prevent the source error, we end up introducing new information that is\n+//! independent from our source error.\n+//!\n+//! ```text\n+//! thread 'main' panicked at 'env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`: NotPresent', src/main.rs:4:6\n+//! ```\n+//!\n+//! In this example we are communicating not only the name of the\n+//! environment variable that should have been set, but also an explanation\n+//! for why it should have been set, and we let the source error display as\n+//! a clear contradiction to our expectation.\n+//!\n+//! For programs where panics may be user facing, either style works best\n+//! when paired with a custom [panic hook] like the one provided by the CLI\n+//! working group library, [`human-panic`]. This panic hook dumps the panic\n+//! messages to a crash report file while showing users a more friendly\n+//! \"Oops, something went wrong!\" message with a suggestion to send the\n+//! crash report file back to the developers. Panic messages should be used\n+//! to represent bugs, and the information provided back is context intended\n+//! for the developer, not the user.\n+//!\n+//! [panic hook]: crate::panic::set_hook\n+//! [`set_hook`]: crate::panic::set_hook\n+//! [`take_hook`]: crate::panic::take_hook\n+//! [`PanicInfo`]: crate::panic::PanicInfo\n+//! [`panic_any`]: crate::panic::panic_any\n+//! [`#[panic_handler]`]: https://doc.rust-lang.org/nomicon/panic-handler.html\n+//! [`catch_unwind`]: crate::panic::catch_unwind\n+//! [`resume_unwind`]: crate::panic::resume_unwind\n+//! [`Termination`]: crate::process::Termination\n+//! [`Try`]: crate::ops::Try\n+//! [`downcast`]: crate::error::Error\n+//! [`human-panic`]: https://docs.rs/human-panic\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}