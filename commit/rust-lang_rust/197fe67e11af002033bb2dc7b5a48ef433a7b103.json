{"sha": "197fe67e11af002033bb2dc7b5a48ef433a7b103", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5N2ZlNjdlMTFhZjAwMjAzM2JiMmRjN2I1YTQ4ZWY0MzNhN2IxMDM=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-15T12:18:40Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-15T13:22:56Z"}, "message": "register snapshots", "tree": {"sha": "833ef111494ac6a79338642aa69c251a3cb02e87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/833ef111494ac6a79338642aa69c251a3cb02e87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/197fe67e11af002033bb2dc7b5a48ef433a7b103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/197fe67e11af002033bb2dc7b5a48ef433a7b103", "html_url": "https://github.com/rust-lang/rust/commit/197fe67e11af002033bb2dc7b5a48ef433a7b103", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/197fe67e11af002033bb2dc7b5a48ef433a7b103/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29070c3bee8846d22030305179fdd3f95cb320d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/29070c3bee8846d22030305179fdd3f95cb320d7", "html_url": "https://github.com/rust-lang/rust/commit/29070c3bee8846d22030305179fdd3f95cb320d7"}], "stats": {"total": 255, "additions": 9, "deletions": 246}, "files": [{"sha": "584314ca04a90ce19c995f6b7c39d1de089f11f1", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=197fe67e11af002033bb2dc7b5a48ef433a7b103", "patch": "@@ -39,30 +39,6 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n #[cfg(unix, not(android))]\n static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n \n-\n-// XXX: this should not exist here\n-#[cfg(stage0, nativestart)]\n-#[lang = \"start\"]\n-pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n-    use std::cast;\n-    use std::task;\n-\n-    do start(argc, argv) {\n-        // Instead of invoking main directly on this thread, invoke it on\n-        // another spawned thread that we are guaranteed to know the size of the\n-        // stack of. Currently, we do not have a method of figuring out the size\n-        // of the main thread's stack, so for stack overflow detection to work\n-        // we must spawn the task in a subtask which we know the stack size of.\n-        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n-        let mut task = task::task();\n-        task.name(\"<main>\");\n-        match do task.try { main() } {\n-            Ok(()) => { os::set_exit_status(0); }\n-            Err(..) => { os::set_exit_status(rt::DEFAULT_ERROR_CODE); }\n-        }\n-    }\n-}\n-\n /// Executes the given procedure after initializing the runtime with the given\n /// argc/argv.\n ///"}, {"sha": "e619e404dac86050c5128fd8ddbf5aaba7253c98", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=197fe67e11af002033bb2dc7b5a48ef433a7b103", "patch": "@@ -227,14 +227,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n@@ -276,14 +268,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[@u8]>();\n-        if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n-        self.bump_past::<~[@u8]>();\n-        true\n-    }\n-\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }"}, {"sha": "641ac0f049da77d998bd064a21dbc64193339532", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=197fe67e11af002033bb2dc7b5a48ef433a7b103", "patch": "@@ -310,15 +310,6 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_uniq_managed(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write(['~' as u8]);\n-        self.get::<&raw::Box<()>>(|this, b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            this.visit_ptr_inner(p, inner);\n-        })\n-    }\n-\n     fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n         self.get::<*c_void>(|this, p| {\n             write!(this.writer, \"({} as *\", *p);\n@@ -359,14 +350,6 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n-            this.writer.write(['~' as u8]);\n-            this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n-        })\n-    }\n-\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<raw::Slice<()>>(|this, s| {\n             this.writer.write(['&' as u8]);"}, {"sha": "2649ca897e5646b2f8ad42979f8c51d15b594313", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=197fe67e11af002033bb2dc7b5a48ef433a7b103", "patch": "@@ -47,41 +47,8 @@ pub use realstd::unstable::intrinsics::{TyDesc, Opaque, TyVisitor, TypeId};\n \n pub type GlueFn = extern \"Rust\" fn(*i8);\n \n-// NOTE remove after next snapshot\n #[lang=\"ty_desc\"]\n-#[cfg(not(test), stage0)]\n-pub struct TyDesc {\n-    // sizeof(T)\n-    size: uint,\n-\n-    // alignof(T)\n-    align: uint,\n-\n-    // Called on a copy of a value of type `T` *after* memcpy\n-    take_glue: GlueFn,\n-\n-    // Called when a value of type `T` is no longer needed\n-    drop_glue: GlueFn,\n-\n-    // Called by drop glue when a value of type `T` can be freed\n-    free_glue: GlueFn,\n-\n-    // Called by reflection visitor to visit a value of type `T`\n-    visit_glue: GlueFn,\n-\n-    // If T represents a box pointer (`@U` or `~U`), then\n-    // `borrow_offset` is the amount that the pointer must be adjusted\n-    // to find the payload.  This is always derivable from the type\n-    // `U`, but in the case of `@Trait` or `~Trait` objects, the type\n-    // `U` is unknown.\n-    borrow_offset: uint,\n-\n-    // Name corresponding to the type\n-    name: &'static str\n-}\n-\n-#[lang=\"ty_desc\"]\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n pub struct TyDesc {\n     // sizeof(T)\n     size: uint,\n@@ -139,17 +106,13 @@ pub trait TyVisitor {\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    #[cfg(stage0)]\n-    fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n \n     fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    #[cfg(stage0)]\n-    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool;"}, {"sha": "20684bf4c49b918f3d2306437107317551f13085", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=197fe67e11af002033bb2dc7b5a48ef433a7b103", "patch": "@@ -116,18 +116,12 @@ use ptr::to_unsafe_ptr;\n use ptr;\n use ptr::RawPtr;\n use rt::global_heap::{malloc_raw, realloc_raw, exchange_free};\n-#[cfg(stage0)]\n-use rt::local_heap::local_free;\n use mem;\n use mem::size_of;\n use uint;\n use unstable::finally::Finally;\n use unstable::intrinsics;\n-#[cfg(stage0)]\n-use unstable::intrinsics::{get_tydesc, owns_managed};\n use unstable::raw::{Repr, Slice, Vec};\n-#[cfg(stage0)]\n-use unstable::raw::Box;\n use util;\n \n /**\n@@ -182,30 +176,6 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n \n /// Creates a new vector with a capacity of `capacity`\n #[inline]\n-#[cfg(stage0)]\n-pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n-    unsafe {\n-        if owns_managed::<T>() {\n-            let mut vec = ~[];\n-            vec.reserve(capacity);\n-            vec\n-        } else {\n-            let alloc = capacity * mem::nonzero_size_of::<T>();\n-            let size = alloc + mem::size_of::<Vec<()>>();\n-            if alloc / mem::nonzero_size_of::<T>() != capacity || size < alloc {\n-                fail!(\"vector size is too large: {}\", capacity);\n-            }\n-            let ptr = malloc_raw(size) as *mut Vec<()>;\n-            (*ptr).alloc = alloc;\n-            (*ptr).fill = 0;\n-            cast::transmute(ptr)\n-        }\n-    }\n-}\n-\n-/// Creates a new vector with a capacity of `capacity`\n-#[inline]\n-#[cfg(not(stage0))]\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     unsafe {\n         let alloc = capacity * mem::nonzero_size_of::<T>();\n@@ -1503,31 +1473,6 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.move_iter().invert()\n     }\n \n-    #[cfg(stage0)]\n-    fn reserve(&mut self, n: uint) {\n-        // Only make the (slow) call into the runtime if we have to\n-        if self.capacity() < n {\n-            unsafe {\n-                let td = get_tydesc::<T>();\n-                if owns_managed::<T>() {\n-                    let ptr: *mut *mut Box<Vec<()>> = cast::transmute(self);\n-                    ::at_vec::raw::reserve_raw(td, ptr, n);\n-                } else {\n-                    let ptr: *mut *mut Vec<()> = cast::transmute(self);\n-                    let alloc = n * mem::nonzero_size_of::<T>();\n-                    let size = alloc + mem::size_of::<Vec<()>>();\n-                    if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n-                        fail!(\"vector size is too large: {}\", n);\n-                    }\n-                    *ptr = realloc_raw(*ptr as *mut c_void, size)\n-                           as *mut Vec<()>;\n-                    (**ptr).alloc = alloc;\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if self.capacity() < n {\n@@ -1561,21 +1506,6 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    #[cfg(stage0)]\n-    fn capacity(&self) -> uint {\n-        unsafe {\n-            if owns_managed::<T>() {\n-                let repr: **Box<Vec<()>> = cast::transmute(self);\n-                (**repr).data.alloc / mem::nonzero_size_of::<T>()\n-            } else {\n-                let repr: **Vec<()> = cast::transmute(self);\n-                (**repr).alloc / mem::nonzero_size_of::<T>()\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn capacity(&self) -> uint {\n         unsafe {\n             let repr: **Vec<()> = cast::transmute(self);\n@@ -1594,51 +1524,6 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    #[cfg(stage0)]\n-    fn push(&mut self, t: T) {\n-        unsafe {\n-            if owns_managed::<T>() {\n-                let repr: **Box<Vec<()>> = cast::transmute(&mut *self);\n-                let fill = (**repr).data.fill;\n-                if (**repr).data.alloc <= fill {\n-                    self.reserve_additional(1);\n-                }\n-\n-                push_fast(self, t);\n-            } else {\n-                let repr: **Vec<()> = cast::transmute(&mut *self);\n-                let fill = (**repr).fill;\n-                if (**repr).alloc <= fill {\n-                    self.reserve_additional(1);\n-                }\n-\n-                push_fast(self, t);\n-            }\n-        }\n-\n-        // This doesn't bother to make sure we have space.\n-        #[inline] // really pretty please\n-        unsafe fn push_fast<T>(this: &mut ~[T], t: T) {\n-            if owns_managed::<T>() {\n-                let repr: **mut Box<Vec<u8>> = cast::transmute(this);\n-                let fill = (**repr).data.fill;\n-                (**repr).data.fill += mem::nonzero_size_of::<T>();\n-                let p = to_unsafe_ptr(&((**repr).data.data));\n-                let p = ptr::offset(p, fill as int) as *mut T;\n-                intrinsics::move_val_init(&mut(*p), t);\n-            } else {\n-                let repr: **mut Vec<u8> = cast::transmute(this);\n-                let fill = (**repr).fill;\n-                (**repr).fill += mem::nonzero_size_of::<T>();\n-                let p = to_unsafe_ptr(&((**repr).data));\n-                let p = ptr::offset(p, fill as int) as *mut T;\n-                intrinsics::move_val_init(&mut(*p), t);\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn push(&mut self, t: T) {\n         unsafe {\n             let repr: **Vec<()> = cast::transmute(&mut *self);\n@@ -1821,20 +1706,8 @@ impl<T> OwnedVector<T> for ~[T] {\n             i += 1u;\n         }\n     }\n-    #[inline]\n-    #[cfg(stage0)]\n-    unsafe fn set_len(&mut self, new_len: uint) {\n-        if owns_managed::<T>() {\n-            let repr: **mut Box<Vec<()>> = cast::transmute(self);\n-            (**repr).data.fill = new_len * mem::nonzero_size_of::<T>();\n-        } else {\n-            let repr: **mut Vec<()> = cast::transmute(self);\n-            (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n-        }\n-    }\n \n     #[inline]\n-    #[cfg(not(stage0))]\n     unsafe fn set_len(&mut self, new_len: uint) {\n         let repr: **mut Vec<()> = cast::transmute(self);\n         (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n@@ -3010,23 +2883,6 @@ impl<T> DoubleEndedIterator<T> for MoveIterator<T> {\n }\n \n #[unsafe_destructor]\n-#[cfg(stage0)]\n-impl<T> Drop for MoveIterator<T> {\n-    fn drop(&mut self) {\n-        // destroy the remaining elements\n-        for _x in *self {}\n-        unsafe {\n-            if owns_managed::<T>() {\n-                local_free(self.allocation as *u8 as *c_char)\n-            } else {\n-                exchange_free(self.allocation as *u8 as *c_char)\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-#[cfg(not(stage0))]\n impl<T> Drop for MoveIterator<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements"}, {"sha": "889a67333a0817602c8d68fc7182e8ec2d442617", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=197fe67e11af002033bb2dc7b5a48ef433a7b103", "patch": "@@ -638,13 +638,6 @@ pub enum TokenTree {\n     TTNonterminal(Span, Ident)\n }\n \n-// NOTE remove after next snapshot\n-// Required for ext::quote macros.\n-#[cfg(stage0)]\n-pub fn tt_tok(span: Span, tok: ::parse::token::Token) -> TokenTree {\n-    TTTok(span, tok)\n-}\n-\n //\n // Matchers are nodes defined-by and recognized-by the main rust parser and\n // language, but they're only ever found inside syntax-extension invocations;"}, {"sha": "368b2a0fd38a737024d2e2a85f33fc65152e2b9f", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/197fe67e11af002033bb2dc7b5a48ef433a7b103/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=197fe67e11af002033bb2dc7b5a48ef433a7b103", "patch": "@@ -1,3 +1,11 @@\n+S 2014-01-14 29070c3\n+  freebsd-x86_64 c2fb6e6313a9f1d41df810fcf1ae354858a8bf76\n+  linux-i386 6437656b81cf9f3d1377523c1e36d5cf06b2d645\n+  linux-x86_64 f3ca80c146f3a6495c19fc77dba13f9c0abece49\n+  macos-i386 3f1f9925fe1ddca94f2727194bd5763b0705016e\n+  macos-x86_64 0c10e160e3a754f2cdc89aea037c458fefe03d30\n+  winnt-i386 5cb277524157a8a883a8641b829f8aa6f53cdcf8\n+\n S 2014-01-08 f3a8baa\n   freebsd-x86_64 9f2491ebe48ff77774c73c111acdd951973d7e47\n   linux-i386 e2ba50e6a7d0cf6a7d65393f0c6416a2af58f8d4"}]}