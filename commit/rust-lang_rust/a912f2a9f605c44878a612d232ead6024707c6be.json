{"sha": "a912f2a9f605c44878a612d232ead6024707c6be", "node_id": "C_kwDOAAsO6NoAKGE5MTJmMmE5ZjYwNWM0NDg3OGE2MTJkMjMyZWFkNjAyNDcwN2M2YmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T17:43:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T17:43:24Z"}, "message": "Auto merge of #12001 - Veykril:refs, r=Veykril\n\nfix: Do reference search on all downmapped tokens with the same kind only\n\ncc https://github.com/rust-lang/rust-analyzer/issues/11668", "tree": {"sha": "75c87ef73c16045523b79a1f0813af0cbb5d1f91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75c87ef73c16045523b79a1f0813af0cbb5d1f91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a912f2a9f605c44878a612d232ead6024707c6be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a912f2a9f605c44878a612d232ead6024707c6be", "html_url": "https://github.com/rust-lang/rust/commit/a912f2a9f605c44878a612d232ead6024707c6be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a912f2a9f605c44878a612d232ead6024707c6be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e41205e9c02de62652171fdd7b679f65b7f3c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e41205e9c02de62652171fdd7b679f65b7f3c2e", "html_url": "https://github.com/rust-lang/rust/commit/5e41205e9c02de62652171fdd7b679f65b7f3c2e"}, {"sha": "58660dee2a166e28c50b2d8f4a2292838bff3192", "url": "https://api.github.com/repos/rust-lang/rust/commits/58660dee2a166e28c50b2d8f4a2292838bff3192", "html_url": "https://github.com/rust-lang/rust/commit/58660dee2a166e28c50b2d8f4a2292838bff3192"}], "stats": {"total": 159, "additions": 100, "deletions": 59}, "files": [{"sha": "8b565ef1fa5c99bec97ac069728a1850be4edcbd", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 50, "deletions": 31, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a912f2a9f605c44878a612d232ead6024707c6be/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a912f2a9f605c44878a612d232ead6024707c6be/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=a912f2a9f605c44878a612d232ead6024707c6be", "patch": "@@ -208,6 +208,16 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.descend_into_macros(token)\n     }\n \n+    /// Descend the token into macrocalls to all its mapped counterparts.\n+    ///\n+    /// Returns the original non descended token if none of the mapped counterparts have the same syntax kind.\n+    pub fn descend_into_macros_with_same_kind(\n+        &self,\n+        token: SyntaxToken,\n+    ) -> SmallVec<[SyntaxToken; 1]> {\n+        self.imp.descend_into_macros_with_same_kind(token)\n+    }\n+\n     /// Maps a node down by mapping its first and last token down.\n     pub fn descend_node_into_attributes<N: AstNode>(&self, node: N) -> SmallVec<[N; 1]> {\n         self.imp.descend_node_into_attributes(node)\n@@ -599,25 +609,19 @@ impl<'db> SemanticsImpl<'db> {\n         };\n \n         if first == last {\n-            self.descend_into_macros_impl(\n-                first,\n-                &mut |InFile { value, .. }| {\n-                    if let Some(node) = value.ancestors().find_map(N::cast) {\n-                        res.push(node)\n-                    }\n-                },\n-                false,\n-            );\n+            self.descend_into_macros_impl(first, &mut |InFile { value, .. }| {\n+                if let Some(node) = value.ancestors().find_map(N::cast) {\n+                    res.push(node)\n+                }\n+                false\n+            });\n         } else {\n             // Descend first and last token, then zip them to look for the node they belong to\n             let mut scratch: SmallVec<[_; 1]> = smallvec![];\n-            self.descend_into_macros_impl(\n-                first,\n-                &mut |token| {\n-                    scratch.push(token);\n-                },\n-                false,\n-            );\n+            self.descend_into_macros_impl(first, &mut |token| {\n+                scratch.push(token);\n+                false\n+            });\n \n             let mut scratch = scratch.into_iter();\n             self.descend_into_macros_impl(\n@@ -638,30 +642,50 @@ impl<'db> SemanticsImpl<'db> {\n                             }\n                         }\n                     }\n+                    false\n                 },\n-                false,\n             );\n         }\n         res\n     }\n \n     fn descend_into_macros(&self, token: SyntaxToken) -> SmallVec<[SyntaxToken; 1]> {\n         let mut res = smallvec![];\n-        self.descend_into_macros_impl(token, &mut |InFile { value, .. }| res.push(value), false);\n+        self.descend_into_macros_impl(token, &mut |InFile { value, .. }| {\n+            res.push(value);\n+            false\n+        });\n+        res\n+    }\n+\n+    fn descend_into_macros_with_same_kind(&self, token: SyntaxToken) -> SmallVec<[SyntaxToken; 1]> {\n+        let kind = token.kind();\n+        let mut res = smallvec![];\n+        self.descend_into_macros_impl(token.clone(), &mut |InFile { value, .. }| {\n+            if value.kind() == kind {\n+                res.push(value);\n+            }\n+            false\n+        });\n+        if res.is_empty() {\n+            res.push(token);\n+        }\n         res\n     }\n \n     fn descend_into_macros_single(&self, token: SyntaxToken) -> SyntaxToken {\n         let mut res = token.clone();\n-        self.descend_into_macros_impl(token, &mut |InFile { value, .. }| res = value, true);\n+        self.descend_into_macros_impl(token, &mut |InFile { value, .. }| {\n+            res = value;\n+            true\n+        });\n         res\n     }\n \n     fn descend_into_macros_impl(\n         &self,\n         token: SyntaxToken,\n-        f: &mut dyn FnMut(InFile<SyntaxToken>),\n-        single: bool,\n+        f: &mut dyn FnMut(InFile<SyntaxToken>) -> bool,\n     ) {\n         let _p = profile::span(\"descend_into_macros\");\n         let parent = match token.parent() {\n@@ -688,16 +712,11 @@ impl<'db> SemanticsImpl<'db> {\n                     self.cache(value, file_id);\n                 }\n \n-                let mut mapped_tokens =\n-                    expansion_info.map_token_down(self.db.upcast(), item, token)?;\n-\n+                let mapped_tokens = expansion_info.map_token_down(self.db.upcast(), item, token)?;\n                 let len = stack.len();\n+\n                 // requeue the tokens we got from mapping our current token down\n-                if single {\n-                    stack.extend(mapped_tokens.next());\n-                } else {\n-                    stack.extend(mapped_tokens);\n-                }\n+                stack.extend(mapped_tokens);\n                 // if the length changed we have found a mapping for the token\n                 (stack.len() != len).then(|| ())\n             };\n@@ -787,8 +806,8 @@ impl<'db> SemanticsImpl<'db> {\n             })()\n             .is_none();\n \n-            if was_not_remapped {\n-                f(token)\n+            if was_not_remapped && f(token) {\n+                break;\n             }\n         }\n     }"}, {"sha": "fe9c5bd7855c3369b7e067a86275050771e34cd4", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a912f2a9f605c44878a612d232ead6024707c6be/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a912f2a9f605c44878a612d232ead6024707c6be/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=a912f2a9f605c44878a612d232ead6024707c6be", "patch": "@@ -20,7 +20,9 @@ use rustc_hash::FxHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, HasName},\n-    match_ast, AstNode, SyntaxNode, TextRange, TextSize, T,\n+    match_ast, AstNode,\n+    SyntaxKind::*,\n+    SyntaxNode, TextRange, TextSize, T,\n };\n \n use crate::{FilePosition, NavigationTarget, TryToNav};\n@@ -104,7 +106,7 @@ pub(crate) fn find_all_refs(\n         }\n         None => {\n             let search = make_searcher(false);\n-            Some(find_defs(sema, &syntax, position.offset).into_iter().map(search).collect())\n+            Some(find_defs(sema, &syntax, position.offset)?.into_iter().map(search).collect())\n         }\n     }\n }\n@@ -113,31 +115,47 @@ pub(crate) fn find_defs<'a>(\n     sema: &'a Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     offset: TextSize,\n-) -> impl Iterator<Item = Definition> + 'a {\n-    sema.find_nodes_at_offset_with_descend(syntax, offset).filter_map(move |name_like| {\n-        let def = match name_like {\n-            ast::NameLike::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n-                NameRefClass::Definition(def) => def,\n-                NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n-                    Definition::Local(local_ref)\n-                }\n-            },\n-            ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n-                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n-                    Definition::Local(local_def)\n-                }\n-            },\n-            ast::NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, &lifetime)\n-                .and_then(|class| match class {\n-                    NameRefClass::Definition(it) => Some(it),\n-                    _ => None,\n-                })\n-                .or_else(|| {\n-                    NameClass::classify_lifetime(sema, &lifetime).and_then(NameClass::defined)\n-                })?,\n-        };\n-        Some(def)\n+) -> Option<impl Iterator<Item = Definition> + 'a> {\n+    let token = syntax.token_at_offset(offset).find(|t| {\n+        matches!(\n+            t.kind(),\n+            IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self]\n+        )\n+    });\n+    token.map(|token| {\n+        sema.descend_into_macros_with_same_kind(token)\n+            .into_iter()\n+            .filter_map(|it| ast::NameLike::cast(it.parent()?))\n+            .filter_map(move |name_like| {\n+                let def = match name_like {\n+                    ast::NameLike::NameRef(name_ref) => {\n+                        match NameRefClass::classify(sema, &name_ref)? {\n+                            NameRefClass::Definition(def) => def,\n+                            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                                Definition::Local(local_ref)\n+                            }\n+                        }\n+                    }\n+                    ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n+                        NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                        NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                            Definition::Local(local_def)\n+                        }\n+                    },\n+                    ast::NameLike::Lifetime(lifetime) => {\n+                        NameRefClass::classify_lifetime(sema, &lifetime)\n+                            .and_then(|class| match class {\n+                                NameRefClass::Definition(it) => Some(it),\n+                                _ => None,\n+                            })\n+                            .or_else(|| {\n+                                NameClass::classify_lifetime(sema, &lifetime)\n+                                    .and_then(NameClass::defined)\n+                            })?\n+                    }\n+                };\n+                Some(def)\n+            })\n     })\n }\n "}, {"sha": "88e17fadac03f107b45809008f9fc98a6d6f8213", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a912f2a9f605c44878a612d232ead6024707c6be/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a912f2a9f605c44878a612d232ead6024707c6be/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=a912f2a9f605c44878a612d232ead6024707c6be", "patch": "@@ -226,7 +226,11 @@ fn find_related_tests(\n     search_scope: Option<SearchScope>,\n     tests: &mut FxHashSet<Runnable>,\n ) {\n-    let defs = references::find_defs(sema, syntax, position.offset);\n+    // FIXME: why is this using references::find_defs, this should use ide_db::search\n+    let defs = match references::find_defs(sema, syntax, position.offset) {\n+        Some(defs) => defs,\n+        None => return,\n+    };\n     for def in defs {\n         let defs = def\n             .usages(sema)"}]}