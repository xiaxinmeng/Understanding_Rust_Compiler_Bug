{"sha": "fd293dfb0f97962697a967b2fae12b54225d7a11", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMjkzZGZiMGY5Nzk2MjY5N2E5NjdiMmZhZTEyYjU0MjI1ZDdhMTE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-06-30T01:45:54Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-04T20:32:41Z"}, "message": "std: rewrite run::with_{argv,envp,dirp} to copy C strings", "tree": {"sha": "3a236a0db49003316b13cc2a6329677f88a91a59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a236a0db49003316b13cc2a6329677f88a91a59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd293dfb0f97962697a967b2fae12b54225d7a11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd293dfb0f97962697a967b2fae12b54225d7a11", "html_url": "https://github.com/rust-lang/rust/commit/fd293dfb0f97962697a967b2fae12b54225d7a11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd293dfb0f97962697a967b2fae12b54225d7a11/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08b6cb46c6c5cc583ceccb2c29e65fc72c13f480", "url": "https://api.github.com/repos/rust-lang/rust/commits/08b6cb46c6c5cc583ceccb2c29e65fc72c13f480", "html_url": "https://github.com/rust-lang/rust/commit/08b6cb46c6c5cc583ceccb2c29e65fc72c13f480"}], "stats": {"total": 103, "additions": 59, "deletions": 44}, "files": [{"sha": "9114c4879b2452b2761c6d13ab827a3abebfeae1", "filename": "src/libstd/run.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/fd293dfb0f97962697a967b2fae12b54225d7a11/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd293dfb0f97962697a967b2fae12b54225d7a11/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=fd293dfb0f97962697a967b2fae12b54225d7a11", "patch": "@@ -24,6 +24,7 @@ use prelude::*;\n use ptr;\n use task;\n use vec::ImmutableVector;\n+use vec;\n \n /**\n  * A value representing a child process.\n@@ -690,46 +691,58 @@ fn spawn_process_os(prog: &str, args: &[~str],\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str],\n-                cb: &fn(**libc::c_char) -> T) -> T {\n-    let mut argptrs = ~[prog.as_c_str(|b| b)];\n-    let mut tmps = ~[];\n+fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n+    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n+    // a reference to the intermediary byte buffers. So first build an array to\n+    // hold all the ~[u8] byte strings.\n+    let mut tmps = vec::with_capacity(args.len() + 1);\n+\n+    tmps.push(prog.to_owned().to_c_str());\n+\n     foreach arg in args.iter() {\n-        let t = @(*arg).clone();\n-        tmps.push(t);\n-        argptrs.push(t.as_c_str(|b| b));\n+        tmps.push(arg.to_owned().to_c_str());\n     }\n-    argptrs.push(ptr::null());\n-    argptrs.as_imm_buf(|buf, _len| cb(buf))\n+\n+    // Next, convert each of the byte strings into a pointer. This is\n+    // technically unsafe as the caller could leak these pointers out of our\n+    // scope.\n+    let mut ptrs = do tmps.map |tmp| {\n+        tmp.as_imm_buf(|buf, _| buf as *libc::c_char)\n+    };\n+\n+    // Finally, make sure we add a null pointer.\n+    ptrs.push(ptr::null());\n+\n+    ptrs.as_imm_buf(|buf, _| cb(buf))\n }\n \n #[cfg(unix)]\n fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n-    // On posixy systems we can pass a char** for envp, which is\n-    // a null-terminated array of \"k=v\\n\" strings.\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n+    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n     match env {\n-      Some(es) => {\n-        let mut tmps = ~[];\n-        let mut ptrs = ~[];\n-\n-        foreach pair in es.iter() {\n-            // Use of match here is just to workaround limitations\n-            // in the stage0 irrefutable pattern impl.\n-            match pair {\n-                &(ref k, ref v) => {\n-                    let kv = @fmt!(\"%s=%s\", *k, *v);\n-                    tmps.push(kv);\n-                    ptrs.push(kv.as_c_str(|b| b));\n-                }\n+        Some(env) => {\n+            let mut tmps = vec::with_capacity(env.len());\n+\n+            foreach pair in env.iter() {\n+                // Use of match here is just to workaround limitations\n+                // in the stage0 irrefutable pattern impl.\n+                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n+                tmps.push(kv.to_c_str());\n             }\n-        }\n \n-        ptrs.push(ptr::null());\n-        ptrs.as_imm_buf(|p, _len|\n-            unsafe { cb(::cast::transmute(p)) }\n-        )\n-      }\n-      _ => cb(ptr::null())\n+            // Once again, this is unsafe.\n+            let mut ptrs = do tmps.map |tmp| {\n+                tmp.as_imm_buf(|buf, _| buf as *libc::c_char)\n+            };\n+            ptrs.push(ptr::null());\n+\n+            do ptrs.as_imm_buf |buf, _| {\n+                unsafe { cb(cast::transmute(buf)) }\n+            }\n+        }\n+        _ => cb(ptr::null())\n     }\n }\n \n@@ -739,23 +752,25 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n     match env {\n-      Some(es) => {\n-        let mut blk = ~[];\n-        foreach pair in es.iter() {\n-            let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n-            blk.push_all(kv.to_bytes_with_null());\n+        Some(env) => {\n+            let mut blk = ~[];\n+\n+            foreach pair in env.iter() {\n+                let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n+                blk.push_all(kv.to_c_str());\n+            }\n+\n+            blk.push(0);\n+\n+            do blk.as_imm_buf |p, _len| {\n+                unsafe { cb(cast::transmute(p)) }\n+            }\n         }\n-        blk.push(0);\n-        blk.as_imm_buf(|p, _len|\n-            unsafe { cb(::cast::transmute(p)) }\n-        )\n-      }\n-      _ => cb(ptr::mut_null())\n+        _ => cb(ptr::mut_null())\n     }\n }\n \n-fn with_dirp<T>(d: Option<&Path>,\n-                cb: &fn(*libc::c_char) -> T) -> T {\n+fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n     match d {\n       Some(dir) => dir.to_str().as_c_str(cb),\n       None => cb(ptr::null())"}]}