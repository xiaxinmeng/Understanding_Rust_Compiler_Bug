{"sha": "177c70128cccdef410a38faf098745e1406ee281", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3N2M3MDEyOGNjY2RlZjQxMGEzOGZhZjA5ODc0NWUxNDA2ZWUyODE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-21T16:06:03Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-21T16:13:41Z"}, "message": "Map attribute input tokens correctly", "tree": {"sha": "9f9e442012300424fe92771d6c4efacd7c39002f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f9e442012300424fe92771d6c4efacd7c39002f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/177c70128cccdef410a38faf098745e1406ee281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/177c70128cccdef410a38faf098745e1406ee281", "html_url": "https://github.com/rust-lang/rust/commit/177c70128cccdef410a38faf098745e1406ee281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/177c70128cccdef410a38faf098745e1406ee281/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cee02673d1128f837d580b72f60a991ea521da1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cee02673d1128f837d580b72f60a991ea521da1b", "html_url": "https://github.com/rust-lang/rust/commit/cee02673d1128f837d580b72f60a991ea521da1b"}], "stats": {"total": 221, "additions": 159, "deletions": 62}, "files": [{"sha": "efe9fdec577eac081b5adec4294abebc4897d313", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=177c70128cccdef410a38faf098745e1406ee281", "patch": "@@ -441,7 +441,7 @@ impl<'db> SemanticsImpl<'db> {\n                                 .entry(file_id)\n                                 .or_insert_with(|| file_id.expansion_info(self.db.upcast()))\n                                 .as_ref()?\n-                                .map_token_down(token.as_ref())?;\n+                                .map_token_down(self.db.upcast(), None, token.as_ref())?;\n \n                             if let Some(parent) = token.value.parent() {\n                                 self.cache(find_root(&parent), token.file_id);\n@@ -450,24 +450,21 @@ impl<'db> SemanticsImpl<'db> {\n                             return Some(token);\n                         },\n                         ast::Item(item) => {\n-                            match self.with_ctx(|ctx| ctx.item_to_macro_call(token.with_value(item))) {\n-                                Some(call_id) => {\n-                                    let file_id = call_id.as_file();\n-                                    let token = self\n-                                        .expansion_info_cache\n-                                        .borrow_mut()\n-                                        .entry(file_id)\n-                                        .or_insert_with(|| file_id.expansion_info(self.db.upcast()))\n-                                        .as_ref()?\n-                                        .map_token_down(token.as_ref())?;\n-\n-                                    if let Some(parent) = token.value.parent() {\n-                                        self.cache(find_root(&parent), token.file_id);\n-                                    }\n-\n-                                    return Some(token);\n+                            if let Some(call_id) = self.with_ctx(|ctx| ctx.item_to_macro_call(token.with_value(item.clone()))) {\n+                                let file_id = call_id.as_file();\n+                                let token = self\n+                                    .expansion_info_cache\n+                                    .borrow_mut()\n+                                    .entry(file_id)\n+                                    .or_insert_with(|| file_id.expansion_info(self.db.upcast()))\n+                                    .as_ref()?\n+                                    .map_token_down(self.db.upcast(), Some(item), token.as_ref())?;\n+\n+                                if let Some(parent) = token.value.parent() {\n+                                    self.cache(find_root(&parent), token.file_id);\n                                 }\n-                                None => {}\n+\n+                                return Some(token);\n                             }\n                         },\n                         _ => {}\n@@ -479,7 +476,6 @@ impl<'db> SemanticsImpl<'db> {\n         })\n         .last()\n         .unwrap();\n-\n         token.value\n     }\n "}, {"sha": "64b09d61638d12561cd82e8d34a2a576219f6248", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=177c70128cccdef410a38faf098745e1406ee281", "patch": "@@ -2,7 +2,9 @@\n \n use std::{\n     convert::{TryFrom, TryInto},\n-    fmt, ops,\n+    fmt,\n+    hash::Hash,\n+    ops,\n     sync::Arc,\n };\n \n@@ -12,7 +14,7 @@ use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName, AstId, InFile};\n use itertools::Itertools;\n use la_arena::ArenaMap;\n-use mbe::{syntax_node_to_token_tree, DelimiterKind};\n+use mbe::{syntax_node_to_token_tree, DelimiterKind, MappedSubTree};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n@@ -165,11 +167,11 @@ impl RawAttrs {\n                 // Input subtree is: `(cfg, $(attr),+)`\n                 // Split it up into a `cfg` subtree and the `attr` subtrees.\n                 // FIXME: There should be a common API for this.\n-                let mut parts = subtree.token_trees.split(\n+                let mut parts = subtree.tree.token_trees.split(\n                     |tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(p)) if p.char == ','),\n                 );\n                 let cfg = parts.next().unwrap();\n-                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n+                let cfg = Subtree { delimiter: subtree.tree.delimiter, token_trees: cfg.to_vec() };\n                 let cfg = CfgExpr::parse(&cfg);\n                 let index = attr.id;\n                 let attrs = parts.filter(|a| !a.is_empty()).filter_map(|attr| {\n@@ -652,14 +654,14 @@ pub enum AttrInput {\n     /// `#[attr = \"string\"]`\n     Literal(SmolStr),\n     /// `#[attr(subtree)]`\n-    TokenTree(Subtree),\n+    TokenTree(mbe::MappedSubTree),\n }\n \n impl fmt::Display for AttrInput {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             AttrInput::Literal(lit) => write!(f, \" = \\\"{}\\\"\", lit.escape_debug()),\n-            AttrInput::TokenTree(subtree) => subtree.fmt(f),\n+            AttrInput::TokenTree(subtree) => subtree.tree.fmt(f),\n         }\n     }\n }\n@@ -679,7 +681,8 @@ impl Attr {\n             };\n             Some(Interned::new(AttrInput::Literal(value)))\n         } else if let Some(tt) = ast.token_tree() {\n-            Some(Interned::new(AttrInput::TokenTree(syntax_node_to_token_tree(tt.syntax()).0)))\n+            let (tree, map) = syntax_node_to_token_tree(tt.syntax());\n+            Some(Interned::new(AttrInput::TokenTree(MappedSubTree { tree, map })))\n         } else {\n             None\n         };\n@@ -712,6 +715,7 @@ impl Attr {\n             Some(AttrInput::TokenTree(args)) => {\n                 let mut counter = 0;\n                 let paths = args\n+                    .tree\n                     .token_trees\n                     .iter()\n                     .group_by(move |tt| {\n@@ -756,7 +760,7 @@ pub struct AttrQuery<'a> {\n impl<'a> AttrQuery<'a> {\n     pub fn tt_values(self) -> impl Iterator<Item = &'a Subtree> {\n         self.attrs().filter_map(|attr| match attr.input.as_deref()? {\n-            AttrInput::TokenTree(it) => Some(it),\n+            AttrInput::TokenTree(it) => Some(&it.tree),\n             _ => None,\n         })\n     }"}, {"sha": "3c9cf0e38dca8b254ce43bcd081d0dce04ef6ce7", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=177c70128cccdef410a38faf098745e1406ee281", "patch": "@@ -786,13 +786,13 @@ fn attr_macro_as_call_id(\n         .ok_or_else(|| UnresolvedMacro { path: item_attr.path.clone() })?;\n     let mut arg = match &macro_attr.input {\n         Some(input) => match &**input {\n-            attr::AttrInput::Literal(_) => tt::Subtree::default(),\n+            attr::AttrInput::Literal(_) => Default::default(),\n             attr::AttrInput::TokenTree(tt) => tt.clone(),\n         },\n-        None => tt::Subtree::default(),\n+        None => Default::default(),\n     };\n     // The parentheses are always disposed here.\n-    arg.delimiter = None;\n+    arg.tree.delimiter = None;\n \n     let res = def.as_lazy_macro(\n         db.upcast(),"}, {"sha": "246bba9a11ee963a83a831be1c09a161362d635f", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=177c70128cccdef410a38faf098745e1406ee281", "patch": "@@ -289,7 +289,7 @@ impl DefCollector<'_> {\n                     || *attr_name == hir_expand::name![register_tool]\n                 {\n                     match attr.input.as_deref() {\n-                        Some(AttrInput::TokenTree(subtree)) => match &*subtree.token_trees {\n+                        Some(AttrInput::TokenTree(subtree)) => match &*subtree.tree.token_trees {\n                             [tt::TokenTree::Leaf(tt::Leaf::Ident(name))] => name.as_name(),\n                             _ => continue,\n                         },"}, {"sha": "b7951cc282d730af3c4502b2b3545c75328ca648", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=177c70128cccdef410a38faf098745e1406ee281", "patch": "@@ -223,7 +223,7 @@ fn parse_macro_expansion(\n         Ok(it) => it,\n         Err(err) => {\n             log::debug!(\n-                \"failed to parse expanstion to {:?} = {}\",\n+                \"failed to parse expansion to {:?} = {}\",\n                 fragment_kind,\n                 tt.as_debug_string()\n             );\n@@ -386,11 +386,15 @@ fn expand_proc_macro(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<tt::\n     };\n \n     let attr_arg = match &loc.kind {\n-        MacroCallKind::Attr { attr_args, .. } => Some(attr_args),\n+        MacroCallKind::Attr { attr_args, .. } => {\n+            let mut attr_args = attr_args.tree.clone();\n+            mbe::Shift::new(&macro_arg.0).shift_all(&mut attr_args);\n+            Some(attr_args)\n+        }\n         _ => None,\n     };\n \n-    expander.expand(db, loc.krate, &macro_arg.0, attr_arg)\n+    expander.expand(db, loc.krate, &macro_arg.0, attr_arg.as_ref())\n }\n \n fn is_self_replicating(from: &SyntaxNode, to: &SyntaxNode) -> bool {"}, {"sha": "86af19626e744dc938fefa7d391bdf4e5b8e9473", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 93, "deletions": 21, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177c70128cccdef410a38faf098745e1406ee281/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=177c70128cccdef410a38faf098745e1406ee281", "patch": "@@ -27,7 +27,7 @@ use std::{hash::Hash, iter, sync::Arc};\n use base_db::{impl_intern_key, salsa, CrateId, FileId, FileRange};\n use syntax::{\n     algo::skip_trivia_token,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, AttrsOwner},\n     Direction, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n@@ -36,6 +36,7 @@ use crate::{\n     builtin_attr::BuiltinAttrExpander,\n     builtin_derive::BuiltinDeriveExpander,\n     builtin_macro::{BuiltinFnLikeExpander, EagerExpander},\n+    db::TokenExpander,\n     proc_macro::ProcMacroExpander,\n };\n \n@@ -132,6 +133,17 @@ impl HirFileId {\n                     };\n                     Some(InFile::new(id.file_id, def_tt))\n                 });\n+                let def_or_attr_input = def.or_else(|| match loc.kind {\n+                    MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n+                        let tt = ast_id\n+                            .to_node(db)\n+                            .attrs()\n+                            .nth(invoc_attr_index as usize)\n+                            .and_then(|attr| attr.token_tree())?;\n+                        Some(InFile::new(ast_id.file_id, tt))\n+                    }\n+                    _ => None,\n+                });\n \n                 let macro_def = db.macro_def(loc.def)?;\n                 let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n@@ -140,7 +152,8 @@ impl HirFileId {\n                 Some(ExpansionInfo {\n                     expanded: InFile::new(self, parse.syntax_node()),\n                     arg: InFile::new(loc.kind.file_id(), arg_tt),\n-                    def,\n+                    attr_input_or_mac_def: def_or_attr_input,\n+                    macro_arg_shift: mbe::Shift::new(&macro_arg.0),\n                     macro_arg,\n                     macro_def,\n                     exp_map,\n@@ -270,7 +283,7 @@ pub enum MacroCallKind {\n     Attr {\n         ast_id: AstId<ast::Item>,\n         attr_name: String,\n-        attr_args: tt::Subtree,\n+        attr_args: mbe::MappedSubTree,\n         /// Syntactical index of the invoking `#[attribute]`.\n         ///\n         /// Outer attributes are counted first, then inner attributes. This does not support\n@@ -335,11 +348,12 @@ impl MacroCallId {\n pub struct ExpansionInfo {\n     expanded: InFile<SyntaxNode>,\n     arg: InFile<SyntaxNode>,\n-    /// The `macro_rules!` arguments.\n-    def: Option<InFile<ast::TokenTree>>,\n+    /// The `macro_rules!` arguments or attribute input.\n+    attr_input_or_mac_def: Option<InFile<ast::TokenTree>>,\n \n-    macro_def: Arc<db::TokenExpander>,\n+    macro_def: Arc<TokenExpander>,\n     macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    macro_arg_shift: mbe::Shift,\n     exp_map: Arc<mbe::TokenMap>,\n }\n \n@@ -350,11 +364,53 @@ impl ExpansionInfo {\n         Some(self.arg.with_value(self.arg.value.parent()?))\n     }\n \n-    pub fn map_token_down(&self, token: InFile<&SyntaxToken>) -> Option<InFile<SyntaxToken>> {\n+    pub fn map_token_down(\n+        &self,\n+        db: &dyn db::AstDatabase,\n+        item: Option<ast::Item>,\n+        token: InFile<&SyntaxToken>,\n+    ) -> Option<InFile<SyntaxToken>> {\n         assert_eq!(token.file_id, self.arg.file_id);\n-        let range = token.value.text_range().checked_sub(self.arg.value.text_range().start())?;\n-        let token_id = self.macro_arg.1.token_by_range(range)?;\n-        let token_id = self.macro_def.map_id_down(token_id);\n+        let token_id = if let Some(item) = item {\n+            let call_id = match self.expanded.file_id.0 {\n+                HirFileIdRepr::FileId(_) => return None,\n+                HirFileIdRepr::MacroFile(macro_file) => macro_file.macro_call_id,\n+            };\n+            let loc = db.lookup_intern_macro(call_id);\n+\n+            let token_range = token.value.text_range();\n+            match &loc.kind {\n+                MacroCallKind::Attr { attr_args, invoc_attr_index, .. } => {\n+                    let attr = item.attrs().nth(*invoc_attr_index as usize)?;\n+                    match attr.token_tree() {\n+                        Some(token_tree)\n+                            if token_tree.syntax().text_range().contains_range(token_range) =>\n+                        {\n+                            let attr_input_start =\n+                                token_tree.left_delimiter_token()?.text_range().start();\n+                            let range = token.value.text_range().checked_sub(attr_input_start)?;\n+                            let token_id =\n+                                self.macro_arg_shift.shift(attr_args.map.token_by_range(range)?);\n+                            Some(token_id)\n+                        }\n+                        _ => None,\n+                    }\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        };\n+\n+        let token_id = match token_id {\n+            Some(token_id) => token_id,\n+            None => {\n+                let range =\n+                    token.value.text_range().checked_sub(self.arg.value.text_range().start())?;\n+                let token_id = self.macro_arg.1.token_by_range(range)?;\n+                self.macro_def.map_id_down(token_id)\n+            }\n+        };\n \n         let range = self.exp_map.range_by_token(token_id, token.value.kind())?;\n \n@@ -365,20 +421,36 @@ impl ExpansionInfo {\n \n     pub fn map_token_up(\n         &self,\n+        db: &dyn db::AstDatabase,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<(InFile<SyntaxToken>, Origin)> {\n         let token_id = self.exp_map.token_by_range(token.value.text_range())?;\n+        let (mut token_id, origin) = self.macro_def.map_id_up(token_id);\n \n-        let (token_id, origin) = self.macro_def.map_id_up(token_id);\n-        let (token_map, tt) = match origin {\n-            mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone()),\n-            mbe::Origin::Def => match (&*self.macro_def, self.def.as_ref()) {\n-                (\n-                    db::TokenExpander::MacroRules { def_site_token_map, .. }\n-                    | db::TokenExpander::MacroDef { def_site_token_map, .. },\n-                    Some(tt),\n-                ) => (def_site_token_map, tt.syntax().cloned()),\n-                _ => panic!(\"`Origin::Def` used with non-`macro_rules!` macro\"),\n+        let call_id = match self.expanded.file_id.0 {\n+            HirFileIdRepr::FileId(_) => return None,\n+            HirFileIdRepr::MacroFile(macro_file) => macro_file.macro_call_id,\n+        };\n+        let loc = db.lookup_intern_macro(call_id);\n+\n+        let (token_map, tt) = match &loc.kind {\n+            MacroCallKind::Attr { attr_args, .. } => match self.macro_arg_shift.unshift(token_id) {\n+                Some(unshifted) => {\n+                    token_id = unshifted;\n+                    (&attr_args.map, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                }\n+                None => (&self.macro_arg.1, self.arg.clone()),\n+            },\n+            _ => match origin {\n+                mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone()),\n+                mbe::Origin::Def => match (&*self.macro_def, self.attr_input_or_mac_def.as_ref()) {\n+                    (\n+                        TokenExpander::MacroRules { def_site_token_map, .. }\n+                        | TokenExpander::MacroDef { def_site_token_map, .. },\n+                        Some(tt),\n+                    ) => (def_site_token_map, tt.syntax().cloned()),\n+                    _ => panic!(\"`Origin::Def` used with non-`macro_rules!` macro\"),\n+                },\n             },\n         };\n \n@@ -532,7 +604,7 @@ fn ascend_call_token(\n     expansion: &ExpansionInfo,\n     token: InFile<SyntaxToken>,\n ) -> Option<InFile<SyntaxToken>> {\n-    let (mapped, origin) = expansion.map_token_up(token.as_ref())?;\n+    let (mapped, origin) = expansion.map_token_up(db, token.as_ref())?;\n     if origin != Origin::Call {\n         return None;\n     }"}, {"sha": "a2a6d02b8a2cffd67be42cf01f52a3139ce806a4", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/177c70128cccdef410a38faf098745e1406ee281/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177c70128cccdef410a38faf098745e1406ee281/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=177c70128cccdef410a38faf098745e1406ee281", "patch": "@@ -69,7 +69,7 @@ pub use crate::{\n         parse_exprs_with_sep, parse_to_token_tree, syntax_node_to_token_tree,\n         token_tree_to_syntax_node,\n     },\n-    token_map::TokenMap,\n+    token_map::{MappedSubTree, TokenMap},\n };\n \n /// This struct contains AST for a single `macro_rules` definition. What might\n@@ -97,11 +97,11 @@ struct Rule {\n     rhs: MetaTemplate,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-struct Shift(u32);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct Shift(u32);\n \n impl Shift {\n-    fn new(tt: &tt::Subtree) -> Shift {\n+    pub fn new(tt: &tt::Subtree) -> Shift {\n         // Note that TokenId is started from zero,\n         // We have to add 1 to prevent duplication.\n         let value = max_id(tt).map_or(0, |it| it + 1);\n@@ -134,7 +134,7 @@ impl Shift {\n     }\n \n     /// Shift given TokenTree token id\n-    fn shift_all(self, tt: &mut tt::Subtree) {\n+    pub fn shift_all(self, tt: &mut tt::Subtree) {\n         for t in &mut tt.token_trees {\n             match t {\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n@@ -152,14 +152,14 @@ impl Shift {\n         }\n     }\n \n-    fn shift(self, id: tt::TokenId) -> tt::TokenId {\n+    pub fn shift(self, id: tt::TokenId) -> tt::TokenId {\n         if id == tt::TokenId::unspecified() {\n             return id;\n         }\n         tt::TokenId(id.0 + self.0)\n     }\n \n-    fn unshift(self, id: tt::TokenId) -> Option<tt::TokenId> {\n+    pub fn unshift(self, id: tt::TokenId) -> Option<tt::TokenId> {\n         id.0.checked_sub(self.0).map(tt::TokenId)\n     }\n }"}, {"sha": "3e8c4b2d6dacfaa03cf7c06884d8bfe8c4dc15d7", "filename": "crates/mbe/src/token_map.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/177c70128cccdef410a38faf098745e1406ee281/crates%2Fmbe%2Fsrc%2Ftoken_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/177c70128cccdef410a38faf098745e1406ee281/crates%2Fmbe%2Fsrc%2Ftoken_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftoken_map.rs?ref=177c70128cccdef410a38faf098745e1406ee281", "patch": "@@ -1,5 +1,7 @@\n //! Mapping between `TokenId`s and the token's position in macro definitions or inputs.\n \n+use std::hash::Hash;\n+\n use parser::{SyntaxKind, T};\n use syntax::{TextRange, TextSize};\n \n@@ -24,6 +26,25 @@ impl TokenTextRange {\n     }\n }\n \n+#[derive(Debug, Clone, Default)]\n+pub struct MappedSubTree {\n+    pub tree: tt::Subtree,\n+    pub map: TokenMap,\n+}\n+\n+impl Eq for MappedSubTree {}\n+impl PartialEq for MappedSubTree {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.tree == other.tree && self.map == other.map\n+    }\n+}\n+\n+impl Hash for MappedSubTree {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.tree.hash(state);\n+    }\n+}\n+\n /// Maps `tt::TokenId` to the relative range of the original token.\n #[derive(Debug, PartialEq, Eq, Clone, Default)]\n pub struct TokenMap {"}]}