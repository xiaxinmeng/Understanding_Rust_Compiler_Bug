{"sha": "07a34df18b437319a7ff510077bbab95cf7ec6bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YTM0ZGYxOGI0MzczMTlhN2ZmNTEwMDc3YmJhYjk1Y2Y3ZWM2YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-08T18:10:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-08T18:10:48Z"}, "message": "Auto merge of #68452 - msizanoen1:riscv-abi, r=nagisa,eddyb\n\nImplement proper C ABI lowering for RISC-V\n\nThis is necessary for full RISC-V psABI compliance when passing argument across C FFI boundary.\n\ncc @lenary", "tree": {"sha": "f9a68f91c8697d8b3949635a027ddd6870e1a664", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9a68f91c8697d8b3949635a027ddd6870e1a664"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07a34df18b437319a7ff510077bbab95cf7ec6bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07a34df18b437319a7ff510077bbab95cf7ec6bc", "html_url": "https://github.com/rust-lang/rust/commit/07a34df18b437319a7ff510077bbab95cf7ec6bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07a34df18b437319a7ff510077bbab95cf7ec6bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ffd44d3d86214fc06be4add039e26f85261a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ffd44d3d86214fc06be4add039e26f85261a2b", "html_url": "https://github.com/rust-lang/rust/commit/85ffd44d3d86214fc06be4add039e26f85261a2b"}, {"sha": "39633874ae7d0150669004a80740ff3b0708d08d", "url": "https://api.github.com/repos/rust-lang/rust/commits/39633874ae7d0150669004a80740ff3b0708d08d", "html_url": "https://github.com/rust-lang/rust/commit/39633874ae7d0150669004a80740ff3b0708d08d"}], "stats": {"total": 1178, "additions": 1162, "deletions": 16}, "files": [{"sha": "dbf421d26cbfa62377d99595c531975fb7a7e12b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=07a34df18b437319a7ff510077bbab95cf7ec6bc", "patch": "@@ -2651,6 +2651,7 @@ where\n                 .map(|(i, ty)| arg_of(ty, Some(i)))\n                 .collect(),\n             c_variadic: sig.c_variadic,\n+            fixed_count: inputs.len(),\n             conv,\n         };\n         fn_abi.adjust_for_abi(cx, sig.abi);"}, {"sha": "8c7108229bd80b86b60cb93a4d93bfe6c0e3a21e", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=07a34df18b437319a7ff510077bbab95cf7ec6bc", "patch": "@@ -120,6 +120,7 @@ impl Reg {\n     reg_ctor!(i16, Integer, 16);\n     reg_ctor!(i32, Integer, 32);\n     reg_ctor!(i64, Integer, 64);\n+    reg_ctor!(i128, Integer, 128);\n \n     reg_ctor!(f32, Float, 32);\n     reg_ctor!(f64, Float, 64);\n@@ -538,6 +539,12 @@ pub struct FnAbi<'a, Ty> {\n \n     pub c_variadic: bool,\n \n+    /// The count of non-variadic arguments.\n+    ///\n+    /// Should only be different from args.len() when c_variadic is true.\n+    /// This can be used to know wether an argument is variadic or not.\n+    pub fixed_count: usize,\n+\n     pub conv: Conv,\n }\n \n@@ -579,8 +586,7 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"nvptx\" => nvptx::compute_abi_info(self),\n             \"nvptx64\" => nvptx64::compute_abi_info(self),\n             \"hexagon\" => hexagon::compute_abi_info(self),\n-            \"riscv32\" => riscv::compute_abi_info(self, 32),\n-            \"riscv64\" => riscv::compute_abi_info(self, 64),\n+            \"riscv32\" | \"riscv64\" => riscv::compute_abi_info(cx, self),\n             \"wasm32\" if cx.target_spec().target_os != \"emscripten\" => {\n                 wasm32_bindgen_compat::compute_abi_info(self)\n             }"}, {"sha": "11d6c4d8191071870ab8755b9d72ab7a1cc5ff3f", "filename": "src/librustc_target/abi/call/riscv.rs", "status": "modified", "additions": 322, "deletions": 13, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs?ref=07a34df18b437319a7ff510077bbab95cf7ec6bc", "patch": "@@ -1,49 +1,358 @@\n // Reference: RISC-V ELF psABI specification\n // https://github.com/riscv/riscv-elf-psabi-doc\n+//\n+// Reference: Clang RISC-V ELF psABI lowering code\n+// https://github.com/llvm/llvm-project/blob/8e780252a7284be45cf1ba224cabd884847e8e92/clang/lib/CodeGen/TargetInfo.cpp#L9311-L9773\n \n-use crate::abi::call::{ArgAbi, FnAbi};\n+use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::{\n+    self, Abi, FieldPlacement, HasDataLayout, LayoutOf, Size, TyLayout, TyLayoutMethods,\n+};\n+use crate::spec::HasTargetSpec;\n+\n+#[derive(Copy, Clone)]\n+enum RegPassKind {\n+    Float(Reg),\n+    Integer(Reg),\n+    Unknown,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum FloatConv {\n+    FloatPair(Reg, Reg),\n+    Float(Reg),\n+    MixedPair(Reg, Reg),\n+}\n+\n+#[derive(Copy, Clone)]\n+struct CannotUseFpConv;\n+\n+fn is_riscv_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {\n+    match arg.layout.abi {\n+        Abi::Vector { .. } => true,\n+        _ => arg.layout.is_aggregate(),\n+    }\n+}\n+\n+fn should_use_fp_conv_helper<'a, Ty, C>(\n+    cx: &C,\n+    arg_layout: &TyLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    field1_kind: &mut RegPassKind,\n+    field2_kind: &mut RegPassKind,\n+) -> Result<(), CannotUseFpConv>\n+where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+{\n+    match arg_layout.abi {\n+        Abi::Scalar(ref scalar) => match scalar.value {\n+            abi::Int(..) | abi::Pointer => {\n+                if arg_layout.size.bits() > xlen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    (RegPassKind::Float(_), RegPassKind::Unknown) => {\n+                        *field2_kind = RegPassKind::Integer(Reg {\n+                            kind: RegKind::Integer,\n+                            size: arg_layout.size,\n+                        });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+            abi::F32 | abi::F64 => {\n+                if arg_layout.size.bits() > flen {\n+                    return Err(CannotUseFpConv);\n+                }\n+                match (*field1_kind, *field2_kind) {\n+                    (RegPassKind::Unknown, _) => {\n+                        *field1_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    (_, RegPassKind::Unknown) => {\n+                        *field2_kind =\n+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });\n+                    }\n+                    _ => return Err(CannotUseFpConv),\n+                }\n+            }\n+        },\n+        Abi::Vector { .. } | Abi::Uninhabited => return Err(CannotUseFpConv),\n+        Abi::ScalarPair(..) | Abi::Aggregate { .. } => match arg_layout.fields {\n+            FieldPlacement::Union(_) => {\n+                if !arg_layout.is_zst() {\n+                    return Err(CannotUseFpConv);\n+                }\n+            }\n+            FieldPlacement::Array { count, .. } => {\n+                for _ in 0..count {\n+                    let elem_layout = arg_layout.field(cx, 0);\n+                    should_use_fp_conv_helper(\n+                        cx,\n+                        &elem_layout,\n+                        xlen,\n+                        flen,\n+                        field1_kind,\n+                        field2_kind,\n+                    )?;\n+                }\n+            }\n+            FieldPlacement::Arbitrary { .. } => {\n+                match arg_layout.variants {\n+                    abi::Variants::Multiple { .. } => return Err(CannotUseFpConv),\n+                    abi::Variants::Single { .. } => (),\n+                }\n+                for i in arg_layout.fields.index_by_increasing_offset() {\n+                    let field = arg_layout.field(cx, i);\n+                    should_use_fp_conv_helper(cx, &field, xlen, flen, field1_kind, field2_kind)?;\n+                }\n+            }\n+        },\n+    }\n+    Ok(())\n+}\n+\n+fn should_use_fp_conv<'a, Ty, C>(\n+    cx: &C,\n+    arg: &TyLayout<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+) -> Option<FloatConv>\n+where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+{\n+    let mut field1_kind = RegPassKind::Unknown;\n+    let mut field2_kind = RegPassKind::Unknown;\n+    if should_use_fp_conv_helper(cx, arg, xlen, flen, &mut field1_kind, &mut field2_kind).is_err() {\n+        return None;\n+    }\n+    match (field1_kind, field2_kind) {\n+        (RegPassKind::Integer(l), RegPassKind::Float(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Integer(r)) => Some(FloatConv::MixedPair(l, r)),\n+        (RegPassKind::Float(l), RegPassKind::Float(r)) => Some(FloatConv::FloatPair(l, r)),\n+        (RegPassKind::Float(f), RegPassKind::Unknown) => Some(FloatConv::Float(f)),\n+        _ => None,\n+    }\n+}\n+\n+fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool\n+where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+{\n+    if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+        match conv {\n+            FloatConv::Float(f) => {\n+                arg.cast_to(f);\n+            }\n+            FloatConv::FloatPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+            FloatConv::MixedPair(l, r) => {\n+                arg.cast_to(CastTarget::pair(l, r));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    let total = arg.layout.size;\n \n-fn classify_ret<Ty>(arg: &mut ArgAbi<'_, Ty>, xlen: u64) {\n     // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n     // the argument list with the address.\"\n     // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n     // replaced in the argument list with the address, as are C++ aggregates\n     // with nontrivial copy constructors, destructors, or vtables.\"\n-    if arg.layout.size.bits() > 2 * xlen {\n-        arg.make_indirect();\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_riscv_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        return true;\n+    }\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+    if is_riscv_aggregate(arg) {\n+        if total.bits() <= xlen {\n+            arg.cast_to(xlen_reg);\n+        } else {\n+            arg.cast_to(Uniform { unit: xlen_reg, total: Size::from_bits(xlen * 2) });\n+        }\n+        return false;\n     }\n \n     // \"When passed in registers, scalars narrower than XLEN bits are widened\n     // according to the sign of their type up to 32 bits, then sign-extended to\n     // XLEN bits.\"\n-    arg.extend_integer_width_to(xlen); // this method only affects integer scalars\n+    extend_integer_width(arg, xlen);\n+    false\n }\n \n-fn classify_arg<Ty>(arg: &mut ArgAbi<'_, Ty>, xlen: u64) {\n+fn classify_arg<'a, Ty, C>(\n+    cx: &C,\n+    arg: &mut ArgAbi<'a, Ty>,\n+    xlen: u64,\n+    flen: u64,\n+    is_vararg: bool,\n+    avail_gprs: &mut u64,\n+    avail_fprs: &mut u64,\n+) where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>>,\n+{\n+    if !is_vararg {\n+        match should_use_fp_conv(cx, &arg.layout, xlen, flen) {\n+            Some(FloatConv::Float(f)) if *avail_fprs >= 1 => {\n+                *avail_fprs -= 1;\n+                arg.cast_to(f);\n+                return;\n+            }\n+            Some(FloatConv::FloatPair(l, r)) if *avail_fprs >= 2 => {\n+                *avail_fprs -= 2;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            Some(FloatConv::MixedPair(l, r)) if *avail_fprs >= 1 && *avail_gprs >= 1 => {\n+                *avail_gprs -= 1;\n+                *avail_fprs -= 1;\n+                arg.cast_to(CastTarget::pair(l, r));\n+                return;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    let total = arg.layout.size;\n+    let align = arg.layout.align.abi.bits();\n+\n     // \"Scalars wider than 2\u2715XLEN are passed by reference and are replaced in\n     // the argument list with the address.\"\n     // \"Aggregates larger than 2\u2715XLEN bits are passed by reference and are\n     // replaced in the argument list with the address, as are C++ aggregates\n     // with nontrivial copy constructors, destructors, or vtables.\"\n-    if arg.layout.size.bits() > 2 * xlen {\n-        arg.make_indirect();\n+    if total.bits() > 2 * xlen {\n+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.\n+        if is_riscv_aggregate(arg) {\n+            arg.make_indirect();\n+        }\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n+    }\n+\n+    let double_xlen_reg = match xlen {\n+        32 => Reg::i64(),\n+        64 => Reg::i128(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    let xlen_reg = match xlen {\n+        32 => Reg::i32(),\n+        64 => Reg::i64(),\n+        _ => unreachable!(\"Unsupported XLEN: {}\", xlen),\n+    };\n+\n+    if total.bits() > xlen {\n+        let align_regs = align > xlen;\n+        if is_riscv_aggregate(arg) {\n+            arg.cast_to(Uniform {\n+                unit: if align_regs { double_xlen_reg } else { xlen_reg },\n+                total: Size::from_bits(xlen * 2),\n+            });\n+        }\n+        if align_regs && is_vararg {\n+            *avail_gprs -= *avail_gprs % 2;\n+        }\n+        if *avail_gprs >= 2 {\n+            *avail_gprs -= 2;\n+        } else {\n+            *avail_gprs = 0;\n+        }\n+        return;\n+    } else if is_riscv_aggregate(arg) {\n+        arg.cast_to(xlen_reg);\n+        if *avail_gprs >= 1 {\n+            *avail_gprs -= 1;\n+        }\n+        return;\n     }\n \n     // \"When passed in registers, scalars narrower than XLEN bits are widened\n     // according to the sign of their type up to 32 bits, then sign-extended to\n     // XLEN bits.\"\n-    arg.extend_integer_width_to(xlen); // this method only affects integer scalars\n+    if *avail_gprs >= 1 {\n+        extend_integer_width(arg, xlen);\n+        *avail_gprs -= 1;\n+    }\n }\n \n-pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>, xlen: u64) {\n+fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n+    match arg.layout.abi {\n+        Abi::Scalar(ref scalar) => {\n+            match scalar.value {\n+                abi::Int(i, _) => {\n+                    // 32-bit integers are always sign-extended\n+                    if i.size().bits() == 32 && xlen > 32 {\n+                        if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                            attrs.set(ArgAttribute::SExt);\n+                            return;\n+                        }\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n+        _ => (),\n+    }\n+    arg.extend_integer_width_to(xlen);\n+}\n+\n+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)\n+where\n+    Ty: TyLayoutMethods<'a, C> + Copy,\n+    C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec,\n+{\n+    let flen = match &cx.target_spec().options.llvm_abiname[..] {\n+        \"ilp32f\" | \"lp64f\" => 32,\n+        \"ilp32d\" | \"lp64d\" => 64,\n+        _ => 0,\n+    };\n+    let xlen = cx.data_layout().pointer_size.bits();\n+\n+    let mut avail_gprs = 8;\n+    let mut avail_fprs = 8;\n+\n     if !fn_abi.ret.is_ignore() {\n-        classify_ret(&mut fn_abi.ret, xlen);\n+        if classify_ret(cx, &mut fn_abi.ret, xlen, flen) {\n+            avail_gprs -= 1;\n+        }\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for (i, arg) in fn_abi.args.iter_mut().enumerate() {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg(arg, xlen);\n+        classify_arg(\n+            cx,\n+            arg,\n+            xlen,\n+            flen,\n+            i >= fn_abi.fixed_count,\n+            &mut avail_gprs,\n+            &mut avail_fprs,\n+        );\n     }\n }"}, {"sha": "897c940149b0a1c0513bb20cb7163e78407620e1", "filename": "src/test/auxiliary/rust_test_helpers.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frust_test_helpers.c?ref=07a34df18b437319a7ff510077bbab95cf7ec6bc", "patch": "@@ -168,6 +168,18 @@ struct floats {\n     double c;\n };\n \n+struct char_char_double {\n+    uint8_t a;\n+    uint8_t b;\n+    double c;\n+};\n+\n+struct char_char_float {\n+    uint8_t a;\n+    uint8_t b;\n+    float c;\n+};\n+\n struct quad\n rust_dbg_abi_1(struct quad q) {\n     struct quad qq = { q.c + 1,\n@@ -185,6 +197,23 @@ rust_dbg_abi_2(struct floats f) {\n     return ff;\n }\n \n+struct char_char_double\n+rust_dbg_abi_3(struct char_char_double a) {\n+    struct char_char_double ccd = { a.a + 1,\n+                                    a.b - 1,\n+                                    a.c + 1.0 };\n+    return ccd;\n+}\n+\n+struct char_char_float\n+rust_dbg_abi_4(struct char_char_float a) {\n+    struct char_char_float ccd = { a.a + 1,\n+                                   a.b - 1,\n+                                   a.c + 1.0 };\n+    return ccd;\n+}\n+\n+\n int\n rust_dbg_static_mut = 3;\n "}, {"sha": "f0f052fe5c557ab4e93dcdaa65af81a1a9369efd", "filename": "src/test/codegen/riscv-abi/riscv64-lp64-lp64f-lp64d-abi.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64-lp64f-lp64d-abi.rs?ref=07a34df18b437319a7ff510077bbab95cf7ec6bc", "patch": "@@ -0,0 +1,181 @@\n+// ignore-tidy-linelength\n+// compile-flags: -C no-prepopulate-passes\n+// only-riscv64\n+// only-linux\n+#![crate_type = \"lib\"]\n+#![allow(improper_ctypes)]\n+\n+// CHECK: define void @f_void()\n+#[no_mangle]\n+pub extern \"C\" fn f_void() {}\n+\n+// CHECK: define zeroext i1 @f_scalar_0(i1 zeroext %a)\n+#[no_mangle]\n+pub extern \"C\" fn f_scalar_0(a: bool) -> bool {\n+    a\n+}\n+\n+// CHECK: define signext i8 @f_scalar_1(i8 signext %x)\n+#[no_mangle]\n+pub extern \"C\" fn f_scalar_1(x: i8) -> i8 {\n+    x\n+}\n+\n+// CHECK: define zeroext i8 @f_scalar_2(i8 zeroext %x)\n+#[no_mangle]\n+pub extern \"C\" fn f_scalar_2(x: u8) -> u8 {\n+    x\n+}\n+\n+// CHECK: define signext i32 @f_scalar_3(i32 signext %x)\n+#[no_mangle]\n+pub extern \"C\" fn f_scalar_3(x: i32) -> u32 {\n+    x as u32\n+}\n+\n+// CHECK: define i64 @f_scalar_4(i64 %x)\n+#[no_mangle]\n+pub extern \"C\" fn f_scalar_4(x: i64) -> i64 {\n+    x\n+}\n+\n+// CHECK: define float @f_fp_scalar_1(float)\n+#[no_mangle]\n+pub extern \"C\" fn f_fp_scalar_1(x: f32) -> f32 {\n+    x\n+}\n+// CHECK: define double @f_fp_scalar_2(double)\n+#[no_mangle]\n+pub extern \"C\" fn f_fp_scalar_2(x: f64) -> f64 {\n+    x\n+}\n+\n+#[repr(C)]\n+pub struct Empty {}\n+\n+// CHECK: define void @f_agg_empty_struct()\n+#[no_mangle]\n+pub extern \"C\" fn f_agg_empty_struct(e: Empty) -> Empty {\n+    e\n+}\n+\n+#[repr(C)]\n+pub struct Tiny {\n+    a: u16,\n+    b: u16,\n+    c: u16,\n+    d: u16,\n+}\n+\n+// CHECK: define void @f_agg_tiny(i64)\n+#[no_mangle]\n+pub extern \"C\" fn f_agg_tiny(mut e: Tiny) {\n+    e.a += e.b;\n+    e.c += e.d;\n+}\n+\n+// CHECK: define i64 @f_agg_tiny_ret()\n+#[no_mangle]\n+pub extern \"C\" fn f_agg_tiny_ret() -> Tiny {\n+    Tiny { a: 1, b: 2, c: 3, d: 4 }\n+}\n+\n+#[repr(C)]\n+pub struct Small {\n+    a: i64,\n+    b: *mut i64,\n+}\n+\n+// CHECK: define void @f_agg_small([2 x i64])\n+#[no_mangle]\n+pub extern \"C\" fn f_agg_small(mut x: Small) {\n+    x.a += unsafe { *x.b };\n+    x.b = &mut x.a;\n+}\n+\n+// CHECK: define [2 x i64] @f_agg_small_ret()\n+#[no_mangle]\n+pub extern \"C\" fn f_agg_small_ret() -> Small {\n+    Small { a: 1, b: core::ptr::null_mut() }\n+}\n+\n+#[repr(C)]\n+pub struct SmallAligned {\n+    a: i128,\n+}\n+\n+// CHECK: define void @f_agg_small_aligned(i128)\n+#[no_mangle]\n+pub extern \"C\" fn f_agg_small_aligned(mut x: SmallAligned) {\n+    x.a += x.a;\n+}\n+\n+#[repr(C)]\n+pub struct Large {\n+    a: i64,\n+    b: i64,\n+    c: i64,\n+    d: i64,\n+}\n+\n+// CHECK: define void @f_agg_large(%Large* {{.*}}%x)\n+#[no_mangle]\n+pub extern \"C\" fn f_agg_large(mut x: Large) {\n+    x.a = x.b + x.c + x.d;\n+}\n+\n+// CHECK: define void @f_agg_large_ret(%Large* {{.*}}sret{{.*}}, i32 signext %i, i8 signext %j)\n+#[no_mangle]\n+pub extern \"C\" fn f_agg_large_ret(i: i32, j: i8) -> Large {\n+    Large { a: 1, b: 2, c: 3, d: 4 }\n+}\n+\n+// CHECK: define void @f_scalar_stack_1(i64, [2 x i64], i128, %Large* {{.*}}%d, i8 zeroext %e, i8 signext %f, i8 %g, i8 %h)\n+#[no_mangle]\n+pub extern \"C\" fn f_scalar_stack_1(\n+    a: Tiny,\n+    b: Small,\n+    c: SmallAligned,\n+    d: Large,\n+    e: u8,\n+    f: i8,\n+    g: u8,\n+    h: i8,\n+) {\n+}\n+\n+// CHECK: define void @f_scalar_stack_2(%Large* {{.*}}sret{{.*}}, i64 %a, i128, i128, i64 %d, i8 zeroext %e, i8 %f, i8 %g)\n+#[no_mangle]\n+pub extern \"C\" fn f_scalar_stack_2(\n+    a: u64,\n+    b: SmallAligned,\n+    c: SmallAligned,\n+    d: u64,\n+    e: u8,\n+    f: i8,\n+    g: u8,\n+) -> Large {\n+    Large { a: a as i64, b: e as i64, c: f as i64, d: g as i64 }\n+}\n+\n+extern \"C\" {\n+    fn f_va_callee(_: i32, ...) -> i32;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn f_va_caller() {\n+    // CHECK: call signext i32 (i32, ...) @f_va_callee(i32 signext 1, i32 signext 2, i64 3, double {{.*}}, double {{.*}}, i64 {{.*}}, [2 x i64] {{.*}}, i128 {{.*}}, %Large* {{.*}})\n+    f_va_callee(\n+        1,\n+        2i32,\n+        3i64,\n+        4.0f64,\n+        5.0f64,\n+        Tiny { a: 1, b: 2, c: 3, d: 4 },\n+        Small { a: 10, b: core::ptr::null_mut() },\n+        SmallAligned { a: 11 },\n+        Large { a: 12, b: 13, c: 14, d: 15 },\n+    );\n+    // CHECK: call signext i32 (i32, ...) @f_va_callee(i32 signext 1, i32 signext 2, i32 signext 3, i32 signext 4, i128 {{.*}}, i32 signext 6, i32 signext 7, i32 8, i32 9)\n+    f_va_callee(1, 2i32, 3i32, 4i32, SmallAligned { a: 5 }, 6i32, 7i32, 8i32, 9i32);\n+}"}, {"sha": "66a3b9e4952a9bad071e0df2621bf47830921976", "filename": "src/test/codegen/riscv-abi/riscv64-lp64d-abi.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64d-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64d-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64d-abi.rs?ref=07a34df18b437319a7ff510077bbab95cf7ec6bc", "patch": "@@ -0,0 +1,293 @@\n+// ignore-tidy-linelength\n+// compile-flags: -C no-prepopulate-passes\n+// only-riscv64\n+// only-linux\n+#![crate_type = \"lib\"]\n+\n+// CHECK: define void @f_fpr_tracking(double, double, double, double, double, double, double, double, i8 zeroext %i)\n+#[no_mangle]\n+pub extern \"C\" fn f_fpr_tracking(\n+    a: f64,\n+    b: f64,\n+    c: f64,\n+    d: f64,\n+    e: f64,\n+    f: f64,\n+    g: f64,\n+    h: f64,\n+    i: u8,\n+) {\n+}\n+\n+#[repr(C)]\n+pub struct Double {\n+    f: f64,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleDouble {\n+    f: f64,\n+    g: f64,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleFloat {\n+    f: f64,\n+    g: f32,\n+}\n+\n+// CHECK: define void @f_double_s_arg(double)\n+#[no_mangle]\n+pub extern \"C\" fn f_double_s_arg(a: Double) {}\n+\n+// CHECK: define double @f_ret_double_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_double_s() -> Double {\n+    Double { f: 1. }\n+}\n+\n+// CHECK: define void @f_double_double_s_arg({ double, double })\n+#[no_mangle]\n+pub extern \"C\" fn f_double_double_s_arg(a: DoubleDouble) {}\n+\n+// CHECK: define { double, double } @f_ret_double_double_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_double_double_s() -> DoubleDouble {\n+    DoubleDouble { f: 1., g: 2. }\n+}\n+\n+// CHECK: define void @f_double_float_s_arg({ double, float })\n+#[no_mangle]\n+pub extern \"C\" fn f_double_float_s_arg(a: DoubleFloat) {}\n+\n+// CHECK: define { double, float } @f_ret_double_float_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_double_float_s() -> DoubleFloat {\n+    DoubleFloat { f: 1., g: 2. }\n+}\n+\n+// CHECK: define void @f_double_double_s_arg_insufficient_fprs(double, double, double, double, double, double, double, [2 x i64])\n+#[no_mangle]\n+pub extern \"C\" fn f_double_double_s_arg_insufficient_fprs(\n+    a: f64,\n+    b: f64,\n+    c: f64,\n+    d: f64,\n+    e: f64,\n+    f: f64,\n+    g: f64,\n+    h: DoubleDouble,\n+) {\n+}\n+\n+#[repr(C)]\n+pub struct DoubleInt8 {\n+    f: f64,\n+    i: i8,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleUInt8 {\n+    f: f64,\n+    i: u8,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleInt32 {\n+    f: f64,\n+    i: i32,\n+}\n+\n+#[repr(C)]\n+pub struct DoubleInt64 {\n+    f: f64,\n+    i: i64,\n+}\n+\n+// CHECK: define void @f_double_int8_s_arg({ double, i8 })\n+#[no_mangle]\n+pub extern \"C\" fn f_double_int8_s_arg(a: DoubleInt8) {}\n+\n+// CHECK: define { double, i8 } @f_ret_double_int8_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_double_int8_s() -> DoubleInt8 {\n+    DoubleInt8 { f: 1., i: 2 }\n+}\n+\n+// CHECK: define void @f_double_int32_s_arg({ double, i32 })\n+#[no_mangle]\n+pub extern \"C\" fn f_double_int32_s_arg(a: DoubleInt32) {}\n+\n+// CHECK: define { double, i32 } @f_ret_double_int32_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_double_int32_s() -> DoubleInt32 {\n+    DoubleInt32 { f: 1., i: 2 }\n+}\n+\n+// CHECK: define void @f_double_uint8_s_arg({ double, i8 })\n+#[no_mangle]\n+pub extern \"C\" fn f_double_uint8_s_arg(a: DoubleUInt8) {}\n+\n+// CHECK: define { double, i8 } @f_ret_double_uint8_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_double_uint8_s() -> DoubleUInt8 {\n+    DoubleUInt8 { f: 1., i: 2 }\n+}\n+\n+// CHECK: define void @f_double_int64_s_arg({ double, i64 })\n+#[no_mangle]\n+pub extern \"C\" fn f_double_int64_s_arg(a: DoubleInt64) {}\n+\n+// CHECK: define { double, i64 } @f_ret_double_int64_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_double_int64_s() -> DoubleInt64 {\n+    DoubleInt64 { f: 1., i: 2 }\n+}\n+\n+// CHECK: define void @f_double_int8_s_arg_insufficient_gprs(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %f, i32 signext %g, i32 signext %h, [2 x i64])\n+#[no_mangle]\n+pub extern \"C\" fn f_double_int8_s_arg_insufficient_gprs(\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+    d: i32,\n+    e: i32,\n+    f: i32,\n+    g: i32,\n+    h: i32,\n+    i: DoubleInt8,\n+) {\n+}\n+\n+// CHECK: define void @f_struct_double_int8_insufficient_fprs(float, double, double, double, double, double, double, double, [2 x i64])\n+#[no_mangle]\n+pub extern \"C\" fn f_struct_double_int8_insufficient_fprs(\n+    a: f32,\n+    b: f64,\n+    c: f64,\n+    d: f64,\n+    e: f64,\n+    f: f64,\n+    g: f64,\n+    h: f64,\n+    i: DoubleInt8,\n+) {\n+}\n+\n+#[repr(C)]\n+pub struct DoubleArr1 {\n+    a: [f64; 1],\n+}\n+\n+// CHECK: define void @f_doublearr1_s_arg(double)\n+#[no_mangle]\n+pub extern \"C\" fn f_doublearr1_s_arg(a: DoubleArr1) {}\n+\n+// CHECK: define double @f_ret_doublearr1_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_doublearr1_s() -> DoubleArr1 {\n+    DoubleArr1 { a: [1.] }\n+}\n+\n+#[repr(C)]\n+pub struct DoubleArr2 {\n+    a: [f64; 2],\n+}\n+\n+// CHECK: define void @f_doublearr2_s_arg({ double, double })\n+#[no_mangle]\n+pub extern \"C\" fn f_doublearr2_s_arg(a: DoubleArr2) {}\n+\n+// CHECK: define { double, double } @f_ret_doublearr2_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_doublearr2_s() -> DoubleArr2 {\n+    DoubleArr2 { a: [1., 2.] }\n+}\n+\n+#[repr(C)]\n+pub struct Tricky1 {\n+    f: [f64; 1],\n+}\n+\n+#[repr(C)]\n+pub struct DoubleArr2Tricky1 {\n+    g: [Tricky1; 2],\n+}\n+\n+// CHECK: define void @f_doublearr2_tricky1_s_arg({ double, double })\n+#[no_mangle]\n+pub extern \"C\" fn f_doublearr2_tricky1_s_arg(a: DoubleArr2Tricky1) {}\n+\n+// CHECK: define { double, double } @f_ret_doublearr2_tricky1_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_doublearr2_tricky1_s() -> DoubleArr2Tricky1 {\n+    DoubleArr2Tricky1 { g: [Tricky1 { f: [1.] }, Tricky1 { f: [2.] }] }\n+}\n+\n+#[repr(C)]\n+pub struct EmptyStruct {}\n+\n+#[repr(C)]\n+pub struct DoubleArr2Tricky2 {\n+    s: EmptyStruct,\n+    g: [Tricky1; 2],\n+}\n+\n+// CHECK: define void @f_doublearr2_tricky2_s_arg({ double, double })\n+#[no_mangle]\n+pub extern \"C\" fn f_doublearr2_tricky2_s_arg(a: DoubleArr2Tricky2) {}\n+\n+// CHECK: define { double, double } @f_ret_doublearr2_tricky2_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_doublearr2_tricky2_s() -> DoubleArr2Tricky2 {\n+    DoubleArr2Tricky2 { s: EmptyStruct {}, g: [Tricky1 { f: [1.] }, Tricky1 { f: [2.] }] }\n+}\n+\n+#[repr(C)]\n+pub struct IntDoubleInt {\n+    a: i32,\n+    b: f64,\n+    c: i32,\n+}\n+\n+// CHECK: define void @f_int_double_int_s_arg(%IntDoubleInt* {{.*}}%a)\n+#[no_mangle]\n+pub extern \"C\" fn f_int_double_int_s_arg(a: IntDoubleInt) {}\n+\n+// CHECK: define void @f_ret_int_double_int_s(%IntDoubleInt* {{.*}}sret\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_int_double_int_s() -> IntDoubleInt {\n+    IntDoubleInt { a: 1, b: 2., c: 3 }\n+}\n+\n+#[repr(C)]\n+pub struct CharCharDouble {\n+    a: u8,\n+    b: u8,\n+    c: f64,\n+}\n+\n+// CHECK: define void @f_char_char_double_s_arg([2 x i64])\n+#[no_mangle]\n+pub extern \"C\" fn f_char_char_double_s_arg(a: CharCharDouble) {}\n+\n+// CHECK: define [2 x i64] @f_ret_char_char_double_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_char_char_double_s() -> CharCharDouble {\n+    CharCharDouble { a: 1, b: 2, c: 3. }\n+}\n+\n+#[repr(C)]\n+pub union DoubleU {\n+    a: f64,\n+}\n+\n+// CHECK: define void @f_double_u_arg(i64)\n+#[no_mangle]\n+pub extern \"C\" fn f_double_u_arg(a: DoubleU) {}\n+\n+// CHECK: define i64 @f_ret_double_u()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_double_u() -> DoubleU {\n+    unsafe { DoubleU { a: 1. } }\n+}"}, {"sha": "d843331f425dec92b4b03db4a554ce4640902d66", "filename": "src/test/codegen/riscv-abi/riscv64-lp64f-lp64d-abi.rs", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64f-lp64d-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64f-lp64d-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Friscv-abi%2Friscv64-lp64f-lp64d-abi.rs?ref=07a34df18b437319a7ff510077bbab95cf7ec6bc", "patch": "@@ -0,0 +1,277 @@\n+// ignore-tidy-linelength\n+// compile-flags: -C no-prepopulate-passes\n+// only-riscv64\n+// only-linux\n+#![crate_type = \"lib\"]\n+\n+// CHECK: define void @f_fpr_tracking(float, float, float, float, float, float, float, float, i8 zeroext %i)\n+#[no_mangle]\n+pub extern \"C\" fn f_fpr_tracking(\n+    a: f32,\n+    b: f32,\n+    c: f32,\n+    d: f32,\n+    e: f32,\n+    f: f32,\n+    g: f32,\n+    h: f32,\n+    i: u8,\n+) {\n+}\n+\n+#[repr(C)]\n+pub struct Float {\n+    f: f32,\n+}\n+\n+#[repr(C)]\n+pub struct FloatFloat {\n+    f: f32,\n+    g: f32,\n+}\n+\n+// CHECK: define void @f_float_s_arg(float)\n+#[no_mangle]\n+pub extern \"C\" fn f_float_s_arg(a: Float) {}\n+\n+// CHECK: define float @f_ret_float_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_float_s() -> Float {\n+    Float { f: 1. }\n+}\n+\n+// CHECK: define void @f_float_float_s_arg({ float, float })\n+#[no_mangle]\n+pub extern \"C\" fn f_float_float_s_arg(a: FloatFloat) {}\n+\n+// CHECK: define { float, float } @f_ret_float_float_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_float_float_s() -> FloatFloat {\n+    FloatFloat { f: 1., g: 2. }\n+}\n+\n+// CHECK: define void @f_float_float_s_arg_insufficient_fprs(float, float, float, float, float, float, float, i64)\n+#[no_mangle]\n+pub extern \"C\" fn f_float_float_s_arg_insufficient_fprs(\n+    a: f32,\n+    b: f32,\n+    c: f32,\n+    d: f32,\n+    e: f32,\n+    f: f32,\n+    g: f32,\n+    h: FloatFloat,\n+) {\n+}\n+\n+#[repr(C)]\n+pub struct FloatInt8 {\n+    f: f32,\n+    i: i8,\n+}\n+\n+#[repr(C)]\n+pub struct FloatUInt8 {\n+    f: f32,\n+    i: u8,\n+}\n+\n+#[repr(C)]\n+pub struct FloatInt32 {\n+    f: f32,\n+    i: i32,\n+}\n+\n+#[repr(C)]\n+pub struct FloatInt64 {\n+    f: f32,\n+    i: i64,\n+}\n+\n+// CHECK: define void @f_float_int8_s_arg({ float, i8 })\n+#[no_mangle]\n+pub extern \"C\" fn f_float_int8_s_arg(a: FloatInt8) {}\n+\n+// CHECK: define { float, i8 } @f_ret_float_int8_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_float_int8_s() -> FloatInt8 {\n+    FloatInt8 { f: 1., i: 2 }\n+}\n+\n+// CHECK: define void @f_float_int32_s_arg({ float, i32 })\n+#[no_mangle]\n+pub extern \"C\" fn f_float_int32_s_arg(a: FloatInt32) {}\n+\n+// CHECK: define { float, i32 } @f_ret_float_int32_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_float_int32_s() -> FloatInt32 {\n+    FloatInt32 { f: 1., i: 2 }\n+}\n+\n+// CHECK: define void @f_float_uint8_s_arg({ float, i8 })\n+#[no_mangle]\n+pub extern \"C\" fn f_float_uint8_s_arg(a: FloatUInt8) {}\n+\n+// CHECK: define { float, i8 } @f_ret_float_uint8_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_float_uint8_s() -> FloatUInt8 {\n+    FloatUInt8 { f: 1., i: 2 }\n+}\n+\n+// CHECK: define void @f_float_int64_s_arg({ float, i64 })\n+#[no_mangle]\n+pub extern \"C\" fn f_float_int64_s_arg(a: FloatInt64) {}\n+\n+// CHECK: define { float, i64 } @f_ret_float_int64_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_float_int64_s() -> FloatInt64 {\n+    FloatInt64 { f: 1., i: 2 }\n+}\n+\n+// CHECK: define void @f_float_int8_s_arg_insufficient_gprs(i32 signext %a, i32 signext %b, i32 signext %c, i32 signext %d, i32 signext %e, i32 signext %f, i32 signext %g, i32 signext %h, i64)\n+#[no_mangle]\n+pub extern \"C\" fn f_float_int8_s_arg_insufficient_gprs(\n+    a: i32,\n+    b: i32,\n+    c: i32,\n+    d: i32,\n+    e: i32,\n+    f: i32,\n+    g: i32,\n+    h: i32,\n+    i: FloatInt8,\n+) {\n+}\n+\n+// CHECK: define void @f_struct_float_int8_insufficient_fprs(float, float, float, float, float, float, float, float, i64)\n+#[no_mangle]\n+pub extern \"C\" fn f_struct_float_int8_insufficient_fprs(\n+    a: f32,\n+    b: f32,\n+    c: f32,\n+    d: f32,\n+    e: f32,\n+    f: f32,\n+    g: f32,\n+    h: f32,\n+    i: FloatInt8,\n+) {\n+}\n+\n+#[repr(C)]\n+pub struct FloatArr1 {\n+    a: [f32; 1],\n+}\n+\n+// CHECK: define void @f_floatarr1_s_arg(float)\n+#[no_mangle]\n+pub extern \"C\" fn f_floatarr1_s_arg(a: FloatArr1) {}\n+\n+// CHECK: define float @f_ret_floatarr1_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_floatarr1_s() -> FloatArr1 {\n+    FloatArr1 { a: [1.] }\n+}\n+\n+#[repr(C)]\n+pub struct FloatArr2 {\n+    a: [f32; 2],\n+}\n+\n+// CHECK: define void @f_floatarr2_s_arg({ float, float })\n+#[no_mangle]\n+pub extern \"C\" fn f_floatarr2_s_arg(a: FloatArr2) {}\n+\n+// CHECK: define { float, float } @f_ret_floatarr2_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_floatarr2_s() -> FloatArr2 {\n+    FloatArr2 { a: [1., 2.] }\n+}\n+\n+#[repr(C)]\n+pub struct Tricky1 {\n+    f: [f32; 1],\n+}\n+\n+#[repr(C)]\n+pub struct FloatArr2Tricky1 {\n+    g: [Tricky1; 2],\n+}\n+\n+// CHECK: define void @f_floatarr2_tricky1_s_arg({ float, float })\n+#[no_mangle]\n+pub extern \"C\" fn f_floatarr2_tricky1_s_arg(a: FloatArr2Tricky1) {}\n+\n+// CHECK: define { float, float } @f_ret_floatarr2_tricky1_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_floatarr2_tricky1_s() -> FloatArr2Tricky1 {\n+    FloatArr2Tricky1 { g: [Tricky1 { f: [1.] }, Tricky1 { f: [2.] }] }\n+}\n+\n+#[repr(C)]\n+pub struct EmptyStruct {}\n+\n+#[repr(C)]\n+pub struct FloatArr2Tricky2 {\n+    s: EmptyStruct,\n+    g: [Tricky1; 2],\n+}\n+\n+// CHECK: define void @f_floatarr2_tricky2_s_arg({ float, float })\n+#[no_mangle]\n+pub extern \"C\" fn f_floatarr2_tricky2_s_arg(a: FloatArr2Tricky2) {}\n+\n+// CHECK: define { float, float } @f_ret_floatarr2_tricky2_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_floatarr2_tricky2_s() -> FloatArr2Tricky2 {\n+    FloatArr2Tricky2 { s: EmptyStruct {}, g: [Tricky1 { f: [1.] }, Tricky1 { f: [2.] }] }\n+}\n+\n+#[repr(C)]\n+pub struct IntFloatInt {\n+    a: i32,\n+    b: f32,\n+    c: i32,\n+}\n+\n+// CHECK: define void @f_int_float_int_s_arg([2 x i64])\n+#[no_mangle]\n+pub extern \"C\" fn f_int_float_int_s_arg(a: IntFloatInt) {}\n+\n+// CHECK: define [2 x i64] @f_ret_int_float_int_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_int_float_int_s() -> IntFloatInt {\n+    IntFloatInt { a: 1, b: 2., c: 3 }\n+}\n+\n+#[repr(C)]\n+pub struct CharCharFloat {\n+    a: u8,\n+    b: u8,\n+    c: f32,\n+}\n+\n+// CHECK: define void @f_char_char_float_s_arg(i64)\n+#[no_mangle]\n+pub extern \"C\" fn f_char_char_float_s_arg(a: CharCharFloat) {}\n+\n+// CHECK: define i64 @f_ret_char_char_float_s()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_char_char_float_s() -> CharCharFloat {\n+    CharCharFloat { a: 1, b: 2, c: 3. }\n+}\n+\n+#[repr(C)]\n+pub union FloatU {\n+    a: f32,\n+}\n+\n+// CHECK: define void @f_float_u_arg(i64)\n+#[no_mangle]\n+pub extern \"C\" fn f_float_u_arg(a: FloatU) {}\n+\n+// CHECK: define i64 @f_ret_float_u()\n+#[no_mangle]\n+pub extern \"C\" fn f_ret_float_u() -> FloatU {\n+    unsafe { FloatU { a: 1. } }\n+}"}, {"sha": "a3e70bbdb08091485ca5133af8ed45ce8950d3c5", "filename": "src/test/ui/abi/struct-enums/struct-return.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fui%2Fabi%2Fstruct-enums%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34df18b437319a7ff510077bbab95cf7ec6bc/src%2Ftest%2Fui%2Fabi%2Fstruct-enums%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fstruct-enums%2Fstruct-return.rs?ref=07a34df18b437319a7ff510077bbab95cf7ec6bc", "patch": "@@ -10,13 +10,23 @@ pub struct Quad { a: u64, b: u64, c: u64, d: u64 }\n #[derive(Copy, Clone)]\n pub struct Floats { a: f64, b: u8, c: f64 }\n \n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct CharCharDouble { a: u8, b: u8, c: f64 }\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct CharCharFloat { a: u8, b: u8, c: f32 }\n+\n mod rustrt {\n-    use super::{Floats, Quad};\n+    use super::{Floats, Quad, CharCharDouble, CharCharFloat};\n \n     #[link(name = \"rust_test_helpers\", kind = \"static\")]\n     extern {\n         pub fn rust_dbg_abi_1(q: Quad) -> Quad;\n         pub fn rust_dbg_abi_2(f: Floats) -> Floats;\n+        pub fn rust_dbg_abi_3(a: CharCharDouble) -> CharCharDouble;\n+        pub fn rust_dbg_abi_4(a: CharCharFloat) -> CharCharFloat;\n     }\n }\n \n@@ -58,7 +68,47 @@ fn test2() {\n fn test2() {\n }\n \n+#[cfg(target_pointer_width = \"64\")]\n+fn test3() {\n+    unsafe {\n+        let a = CharCharDouble {\n+            a: 1,\n+            b: 2,\n+            c: 3.,\n+        };\n+        let b = rustrt::rust_dbg_abi_3(a);\n+        println!(\"a: {}\", b.a);\n+        println!(\"b: {}\", b.b);\n+        println!(\"c: {}\", b.c);\n+        assert_eq!(b.a, a.a + 1);\n+        assert_eq!(b.b, a.b - 1);\n+        assert_eq!(b.c, a.c + 1.0);\n+    }\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+fn test3() {}\n+\n+fn test4() {\n+    unsafe {\n+        let a = CharCharFloat {\n+            a: 1,\n+            b: 2,\n+            c: 3.,\n+        };\n+        let b = rustrt::rust_dbg_abi_4(a);\n+        println!(\"a: {}\", b.a);\n+        println!(\"b: {}\", b.b);\n+        println!(\"c: {}\", b.c);\n+        assert_eq!(b.a, a.a + 1);\n+        assert_eq!(b.b, a.b - 1);\n+        assert_eq!(b.c, a.c + 1.0);\n+    }\n+}\n+\n pub fn main() {\n     test1();\n     test2();\n+    test3();\n+    test4();\n }"}]}