{"sha": "5367c32c7ddb873babec89f739a936409d45476a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNjdjMzJjN2RkYjg3M2JhYmVjODlmNzM5YTkzNjQwOWQ0NTQ3NmE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-07T19:16:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-08T07:03:11Z"}, "message": "rustc: Never register syntax crates in CStore\n\nWhen linking, all crates in the local CStore are used to link the final product.\nWith #[phase(syntax)], crates want to be omitted from this linkage phase, and\nthis was achieved by dumping the entire CStore after loading crates. This causes\ncrates like the standard library to get loaded twice. This loading process is a\nfairly expensive operation when dealing with decompressing metadata.\n\nThis commit alters the loading process to never register syntax crates in\nCStore. Instead, only phase(link) crates ever make their way into the map of\ncrates. The CrateLoader trait was altered to return everything in one method\ninstead of having separate methods for finding information.", "tree": {"sha": "4982c94e31e8a77123c9f9de26aefb86c372ef3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4982c94e31e8a77123c9f9de26aefb86c372ef3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5367c32c7ddb873babec89f739a936409d45476a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5367c32c7ddb873babec89f739a936409d45476a", "html_url": "https://github.com/rust-lang/rust/commit/5367c32c7ddb873babec89f739a936409d45476a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5367c32c7ddb873babec89f739a936409d45476a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31755e2452b280fe4038140012dcd19560b6f03d", "url": "https://api.github.com/repos/rust-lang/rust/commits/31755e2452b280fe4038140012dcd19560b6f03d", "html_url": "https://github.com/rust-lang/rust/commit/31755e2452b280fe4038140012dcd19560b6f03d"}], "stats": {"total": 94, "additions": 51, "deletions": 43}, "files": [{"sha": "8a593d5f92a2add5a7ba6a3bae490598f8b76be6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5367c32c7ddb873babec89f739a936409d45476a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5367c32c7ddb873babec89f739a936409d45476a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=5367c32c7ddb873babec89f739a936409d45476a", "patch": "@@ -241,8 +241,6 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                           cfg,\n                                           krate)\n     });\n-    // dump the syntax-time crates\n-    sess.cstore.reset();\n \n     // strip again, in case expansion added anything with a #[cfg].\n     krate = time(time_passes, \"configuration 2\", krate, |krate|"}, {"sha": "50c22f6bf1bba6985bb1ec82e0f7ecff32bd08c8", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5367c32c7ddb873babec89f739a936409d45476a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5367c32c7ddb873babec89f739a936409d45476a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5367c32c7ddb873babec89f739a936409d45476a", "patch": "@@ -114,22 +114,25 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n     }\n }\n \n-fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n-    let should_load = i.attrs.iter().all(|attr| {\n+fn should_link(i: &ast::ViewItem) -> bool {\n+    i.attrs.iter().all(|attr| {\n         attr.name().get() != \"phase\" ||\n             attr.meta_item_list().map_or(false, |phases| {\n                 attr::contains_name(phases.as_slice(), \"link\")\n             })\n-    });\n+    })\n+}\n \n-    if !should_load {\n+fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n+    if !should_link(i) {\n         return;\n     }\n \n     match extract_crate_info(e, i) {\n         Some(info) => {\n-            let cnum = resolve_crate(e, &None, info.ident, &info.crate_id, None,\n-                                     i.span);\n+            let (cnum, _, _) = resolve_crate(e, &None, info.ident,\n+                                             &info.crate_id, None, true,\n+                                             i.span);\n             e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n         }\n         None => ()\n@@ -140,6 +143,7 @@ struct CrateInfo {\n     ident: ~str,\n     crate_id: CrateId,\n     id: ast::NodeId,\n+    should_link: bool,\n }\n \n fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n@@ -165,6 +169,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n                 ident: ident.get().to_str(),\n                 crate_id: crate_id,\n                 id: id,\n+                should_link: should_link(i),\n             })\n         }\n         _ => None\n@@ -274,8 +279,10 @@ fn resolve_crate<'a>(e: &mut Env,\n                      ident: &str,\n                      crate_id: &CrateId,\n                      hash: Option<&Svh>,\n+                     should_link: bool,\n                      span: Span)\n-                     -> ast::CrateNum {\n+                     -> (ast::CrateNum, @cstore::crate_metadata,\n+                         cstore::CrateSource) {\n     match existing_match(e, crate_id, hash) {\n         None => {\n             let id_hash = link::crate_id_hash(crate_id);\n@@ -312,8 +319,11 @@ fn resolve_crate<'a>(e: &mut Env,\n             let root = if root.is_some() { root } else { &crate_paths };\n \n             // Now resolve the crates referenced by this crate\n-            let cnum_map = resolve_crate_deps(e, root, metadata.as_slice(),\n-                                              span);\n+            let cnum_map = if should_link {\n+                resolve_crate_deps(e, root, metadata.as_slice(), span)\n+            } else {\n+                @RefCell::new(HashMap::new())\n+            };\n \n             let cmeta = @cstore::crate_metadata {\n                 name: load_ctxt.crate_id.name.to_owned(),\n@@ -323,15 +333,21 @@ fn resolve_crate<'a>(e: &mut Env,\n                 span: span,\n             };\n \n-            e.sess.cstore.set_crate_data(cnum, cmeta);\n-            e.sess.cstore.add_used_crate_source(cstore::CrateSource {\n+            let source = cstore::CrateSource {\n                 dylib: dylib,\n                 rlib: rlib,\n                 cnum: cnum,\n-            });\n-            cnum\n+            };\n+\n+            if should_link {\n+                e.sess.cstore.set_crate_data(cnum, cmeta);\n+                e.sess.cstore.add_used_crate_source(source.clone());\n+            }\n+            (cnum, cmeta, source)\n         }\n-        Some(cnum) => cnum\n+        Some(cnum) => (cnum,\n+                       e.sess.cstore.get_crate_data(cnum),\n+                       e.sess.cstore.get_used_crate_source(cnum).unwrap())\n     }\n }\n \n@@ -348,11 +364,12 @@ fn resolve_crate_deps(e: &mut Env,\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n         debug!(\"resolving dep crate {} hash: `{}`\", dep.crate_id, dep.hash);\n-        let local_cnum = resolve_crate(e, root,\n-                                       dep.crate_id.name.as_slice(),\n-                                       &dep.crate_id,\n-                                       Some(&dep.hash),\n-                                       span);\n+        let (local_cnum, _, _) = resolve_crate(e, root,\n+                                               dep.crate_id.name.as_slice(),\n+                                               &dep.crate_id,\n+                                               Some(&dep.hash),\n+                                               true,\n+                                               span);\n         cnum_map.insert(extrn_cnum, local_cnum);\n     }\n     return @RefCell::new(cnum_map);\n@@ -380,23 +397,17 @@ impl<'a> Loader<'a> {\n impl<'a> CrateLoader for Loader<'a> {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n-        let cnum = resolve_crate(&mut self.env, &None, info.ident,\n-                                 &info.crate_id, None, krate.span);\n-        let library = self.env.sess.cstore.get_used_crate_source(cnum).unwrap();\n+        let (cnum, data, library) = resolve_crate(&mut self.env, &None,\n+                                                  info.ident, &info.crate_id,\n+                                                  None, true, krate.span);\n+        let macros = decoder::get_exported_macros(data);\n+        let cstore = &self.env.sess.cstore;\n+        let registrar = csearch::get_macro_registrar_fn(cstore, cnum)\n+                            .map(|did| csearch::get_symbol(cstore, did));\n         MacroCrate {\n             lib: library.dylib,\n-            cnum: cnum,\n+            macros: macros.move_iter().collect(),\n+            registrar_symbol: registrar,\n         }\n     }\n-\n-    fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> Vec<~str> {\n-        csearch::get_exported_macros(&self.env.sess.cstore, cnum).move_iter()\n-                                                                 .collect()\n-    }\n-\n-    fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {\n-        let cstore = &self.env.sess.cstore;\n-        csearch::get_macro_registrar_fn(cstore, cnum)\n-            .map(|did| csearch::get_symbol(cstore, did))\n-    }\n }"}, {"sha": "3bf1ed95f380ef1f95df75bca0b9b55c77c8b4aa", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5367c32c7ddb873babec89f739a936409d45476a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5367c32c7ddb873babec89f739a936409d45476a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5367c32c7ddb873babec89f739a936409d45476a", "patch": "@@ -293,13 +293,12 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n \n pub struct MacroCrate {\n     pub lib: Option<Path>,\n-    pub cnum: ast::CrateNum,\n+    pub macros: Vec<~str>,\n+    pub registrar_symbol: Option<~str>,\n }\n \n pub trait CrateLoader {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate;\n-    fn get_exported_macros(&mut self, crate_num: ast::CrateNum) -> Vec<~str> ;\n-    fn get_registrar_symbol(&mut self, crate_num: ast::CrateNum) -> Option<~str>;\n }\n \n // One of these is made during expansion and incrementally updated as we go;"}, {"sha": "5c3c7d995d67a56b8ab2e2cb3e351dc2e953bacf", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5367c32c7ddb873babec89f739a936409d45476a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5367c32c7ddb873babec89f739a936409d45476a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5367c32c7ddb873babec89f739a936409d45476a", "patch": "@@ -487,16 +487,16 @@ pub fn expand_view_item(vi: &ast::ViewItem,\n }\n \n fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n-    let MacroCrate { lib, cnum } = fld.cx.ecfg.loader.load_crate(krate);\n+    let MacroCrate { lib, macros, registrar_symbol } =\n+        fld.cx.ecfg.loader.load_crate(krate);\n \n     let crate_name = match krate.node {\n         ast::ViewItemExternCrate(name, _, _) => name,\n         _ => unreachable!()\n     };\n     let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n \n-    let exported_macros = fld.cx.ecfg.loader.get_exported_macros(cnum);\n-    for source in exported_macros.iter() {\n+    for source in macros.iter() {\n         let item = parse::parse_item_from_source_str(name.clone(),\n                                                      (*source).clone(),\n                                                      fld.cx.cfg(),\n@@ -512,7 +512,7 @@ fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n     // Make sure the path contains a / or the linker will search for it.\n     let path = os::make_absolute(&path);\n \n-    let registrar = match fld.cx.ecfg.loader.get_registrar_symbol(cnum) {\n+    let registrar = match registrar_symbol {\n         Some(registrar) => registrar,\n         None => return\n     };"}]}