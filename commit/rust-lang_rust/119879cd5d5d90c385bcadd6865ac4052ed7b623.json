{"sha": "119879cd5d5d90c385bcadd6865ac4052ed7b623", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTg3OWNkNWQ1ZDkwYzM4NWJjYWRkNjg2NWFjNDA1MmVkN2I2MjM=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-12-20T09:29:02Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-12-20T09:29:26Z"}, "message": "Cache result of", "tree": {"sha": "d132178b3c183abd4e918fbe4117318b27c34fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d132178b3c183abd4e918fbe4117318b27c34fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/119879cd5d5d90c385bcadd6865ac4052ed7b623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/119879cd5d5d90c385bcadd6865ac4052ed7b623", "html_url": "https://github.com/rust-lang/rust/commit/119879cd5d5d90c385bcadd6865ac4052ed7b623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/119879cd5d5d90c385bcadd6865ac4052ed7b623/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd2f1cb2785f87177249e2bdb628ed782fcd8def", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd2f1cb2785f87177249e2bdb628ed782fcd8def", "html_url": "https://github.com/rust-lang/rust/commit/bd2f1cb2785f87177249e2bdb628ed782fcd8def"}], "stats": {"total": 76, "additions": 73, "deletions": 3}, "files": [{"sha": "5f028975bd0e31ad0d67197ec0d3f79441014b01", "filename": "compiler/rustc_middle/src/mir/graph_cyclic_cache.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/119879cd5d5d90c385bcadd6865ac4052ed7b623/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119879cd5d5d90c385bcadd6865ac4052ed7b623/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs?ref=119879cd5d5d90c385bcadd6865ac4052ed7b623", "patch": "@@ -0,0 +1,62 @@\n+use rustc_data_structures::graph::{\n+    self, DirectedGraph, WithNumNodes, WithStartNode, WithSuccessors,\n+};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::OnceCell;\n+use rustc_serialize as serialize;\n+\n+/// Helper type to cache the result of `graph::is_cyclic`.\n+#[derive(Clone, Debug)]\n+pub(super) struct GraphIsCyclicCache {\n+    cache: OnceCell<bool>,\n+}\n+\n+impl GraphIsCyclicCache {\n+    #[inline]\n+    pub(super) fn new() -> Self {\n+        GraphIsCyclicCache { cache: OnceCell::new() }\n+    }\n+\n+    pub(super) fn is_cyclic<G>(&self, graph: &G) -> bool\n+    where\n+        G: ?Sized + DirectedGraph + WithStartNode + WithSuccessors + WithNumNodes,\n+    {\n+        *self.cache.get_or_init(|| graph::is_cyclic(graph))\n+    }\n+\n+    /// Invalidates the cache.\n+    #[inline]\n+    pub(super) fn invalidate(&mut self) {\n+        // Invalidating the cache requires mutating the MIR, which in turn requires a unique\n+        // reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n+        // callers of `invalidate` have a unique reference to the MIR and thus to the\n+        // cache. This means we never need to do synchronization when `invalidate` is called,\n+        // we can simply reinitialize the `OnceCell`.\n+        self.cache = OnceCell::new();\n+    }\n+}\n+\n+impl<S: serialize::Encoder> serialize::Encodable<S> for GraphIsCyclicCache {\n+    #[inline]\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&(), s)\n+    }\n+}\n+\n+impl<D: serialize::Decoder> serialize::Decodable<D> for GraphIsCyclicCache {\n+    #[inline]\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for GraphIsCyclicCache {\n+    #[inline]\n+    fn hash_stable(&self, _: &mut CTX, _: &mut StableHasher) {\n+        // do nothing\n+    }\n+}\n+\n+TrivialTypeFoldableAndLiftImpls! {\n+    GraphIsCyclicCache,\n+}"}, {"sha": "a69555fd1a8cec34ceb0cfb2a534511aaa45bd9e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/119879cd5d5d90c385bcadd6865ac4052ed7b623/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119879cd5d5d90c385bcadd6865ac4052ed7b623/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=119879cd5d5d90c385bcadd6865ac4052ed7b623", "patch": "@@ -35,11 +35,13 @@ use std::ops::{ControlFlow, Index, IndexMut};\n use std::slice;\n use std::{iter, mem, option};\n \n+use self::graph_cyclic_cache::GraphIsCyclicCache;\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n pub mod abstract_const;\n pub mod coverage;\n+mod graph_cyclic_cache;\n pub mod interpret;\n pub mod mono;\n mod predecessors;\n@@ -227,6 +229,7 @@ pub struct Body<'tcx> {\n     pub is_polymorphic: bool,\n \n     predecessor_cache: PredecessorCache,\n+    is_cyclic: GraphIsCyclicCache,\n }\n \n impl<'tcx> Body<'tcx> {\n@@ -267,6 +270,7 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n+            is_cyclic: GraphIsCyclicCache::new(),\n         };\n         body.is_polymorphic = body.has_param_types_or_consts();\n         body\n@@ -296,6 +300,7 @@ impl<'tcx> Body<'tcx> {\n             var_debug_info: Vec::new(),\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n+            is_cyclic: GraphIsCyclicCache::new(),\n         };\n         body.is_polymorphic = body.has_param_types_or_consts();\n         body\n@@ -309,11 +314,12 @@ impl<'tcx> Body<'tcx> {\n     #[inline]\n     pub fn basic_blocks_mut(&mut self) -> &mut IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n         // Because the user could mutate basic block terminators via this reference, we need to\n-        // invalidate the predecessor cache.\n+        // invalidate the caches.\n         //\n         // FIXME: Use a finer-grained API for this, so only transformations that alter terminators\n-        // invalidate the predecessor cache.\n+        // invalidate the caches.\n         self.predecessor_cache.invalidate();\n+        self.is_cyclic.invalidate();\n         &mut self.basic_blocks\n     }\n \n@@ -322,6 +328,7 @@ impl<'tcx> Body<'tcx> {\n         &mut self,\n     ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n         self.predecessor_cache.invalidate();\n+        self.is_cyclic.invalidate();\n         (&mut self.basic_blocks, &mut self.local_decls)\n     }\n \n@@ -334,13 +341,14 @@ impl<'tcx> Body<'tcx> {\n         &mut Vec<VarDebugInfo<'tcx>>,\n     ) {\n         self.predecessor_cache.invalidate();\n+        self.is_cyclic.invalidate();\n         (&mut self.basic_blocks, &mut self.local_decls, &mut self.var_debug_info)\n     }\n \n     /// Returns `true` if a cycle exists in the control-flow graph that is reachable from the\n     /// `START_BLOCK`.\n     pub fn is_cfg_cyclic(&self) -> bool {\n-        graph::is_cyclic(self)\n+        self.is_cyclic.is_cyclic(self)\n     }\n \n     #[inline]"}]}