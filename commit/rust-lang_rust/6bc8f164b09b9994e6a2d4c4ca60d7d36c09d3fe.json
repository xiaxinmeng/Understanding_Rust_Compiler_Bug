{"sha": "6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYzhmMTY0YjA5Yjk5OTRlNmEyZDRjNGNhNjBkN2QzNmMwOWQzZmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-11-01T19:32:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-11-09T04:41:17Z"}, "message": "std: Remove `rand` crate and module\n\nThis commit removes the `rand` crate from the standard library facade as\nwell as the `__rand` module in the standard library. Neither of these\nwere used in any meaningful way in the standard library itself. The only\nneed for randomness in libstd is to initialize the thread-local keys of\na `HashMap`, and that unconditionally used `OsRng` defined in the\nstandard library anyway.\n\nThe cruft of the `rand` crate and the extra `rand` support in the\nstandard library makes libstd slightly more difficult to port to new\nplatforms, namely WebAssembly which doesn't have any randomness at all\n(without interfacing with JS). The purpose of this commit is to clarify\nand streamline randomness in libstd, focusing on how it's only required\nin one location, hashmap seeds.\n\nNote that the `rand` crate out of tree has almost always been a drop-in\nreplacement for the `rand` crate in-tree, so any usage (accidental or\npurposeful) of the crate in-tree should switch to the `rand` crate on\ncrates.io. This then also has the further benefit of avoiding\nduplication (mostly) between the two crates!", "tree": {"sha": "29cb9e3ac618cf4696aef88153c6fb2d48da3ee4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29cb9e3ac618cf4696aef88153c6fb2d48da3ee4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "html_url": "https://github.com/rust-lang/rust/commit/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc77b623d3072005f35e320e652f2b31695d493c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc77b623d3072005f35e320e652f2b31695d493c", "html_url": "https://github.com/rust-lang/rust/commit/fc77b623d3072005f35e320e652f2b31695d493c"}], "stats": {"total": 4541, "additions": 161, "deletions": 4380}, "files": [{"sha": "79aea99a5a98a8d3c804915dd36e9f7d9daa18c8", "filename": "src/Cargo.lock", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -28,6 +28,7 @@ name = \"alloc\"\n version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n+ \"rand 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"std_unicode 0.0.0\",\n ]\n \n@@ -367,7 +368,7 @@ version = \"0.1.0\"\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.0.0\",\n+ \"rand 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1366,13 +1367,6 @@ dependencies = [\n  \"typed-arena 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rand\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"core 0.0.0\",\n-]\n-\n [[package]]\n name = \"rand\"\n version = \"0.3.17\"\n@@ -1596,6 +1590,7 @@ name = \"rustc_back\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n@@ -1703,6 +1698,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -2125,7 +2121,7 @@ dependencies = [\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n  \"profiler_builtins 0.0.0\",\n- \"rand 0.0.0\",\n+ \"rand 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_asan 0.0.0\",\n  \"rustc_lsan 0.0.0\",\n  \"rustc_msan 0.0.0\","}, {"sha": "db013691bb1b8ca1aec7db48feb30e5a4a9951d4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -107,8 +107,8 @@ impl Step for Std {\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         std_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n-                &mut cargo,\n-                &libstd_stamp(build, compiler, target));\n+                  &mut cargo,\n+                  &libstd_stamp(build, compiler, target));\n \n         builder.ensure(StdLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -359,8 +359,8 @@ impl Step for Test {\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n         test_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n-                &mut cargo,\n-                &libtest_stamp(build, compiler, target));\n+                  &mut cargo,\n+                  &libtest_stamp(build, compiler, target));\n \n         builder.ensure(TestLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -866,12 +866,13 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n             // `std-<hash>.dll.lib` on Windows. The aforementioned methods only\n             // split the file name by the last extension (`.lib`) while we need\n             // to split by all extensions (`.dll.lib`).\n+            let expected_len = t!(filename.metadata()).len();\n             let filename = filename.file_name().unwrap().to_str().unwrap();\n             let mut parts = filename.splitn(2, '.');\n             let file_stem = parts.next().unwrap().to_owned();\n             let extension = parts.next().unwrap().to_owned();\n \n-            toplevel.push((file_stem, extension));\n+            toplevel.push((file_stem, extension, expected_len));\n         }\n     }\n \n@@ -891,11 +892,12 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n         .map(|e| t!(e))\n         .map(|e| (e.path(), e.file_name().into_string().unwrap(), t!(e.metadata())))\n         .collect::<Vec<_>>();\n-    for (prefix, extension) in toplevel {\n-        let candidates = contents.iter().filter(|&&(_, ref filename, _)| {\n+    for (prefix, extension, expected_len) in toplevel {\n+        let candidates = contents.iter().filter(|&&(_, ref filename, ref meta)| {\n             filename.starts_with(&prefix[..]) &&\n                 filename[prefix.len()..].starts_with(\"-\") &&\n-                filename.ends_with(&extension[..])\n+                filename.ends_with(&extension[..]) &&\n+                meta.len() == expected_len\n         });\n         let max = candidates.max_by_key(|&&(_, _, ref metadata)| {\n             FileTime::from_last_modification_time(metadata)"}, {"sha": "090fb6c778c8631e3fc69ed6d7326611214620ad", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -743,7 +743,6 @@ impl Step for Src {\n             \"src/liblibc\",\n             \"src/libpanic_abort\",\n             \"src/libpanic_unwind\",\n-            \"src/librand\",\n             \"src/librustc_asan\",\n             \"src/librustc_lsan\",\n             \"src/librustc_msan\","}, {"sha": "d0229d94c20bfab71f398fad760c5d2a1d2ceb40", "filename": "src/doc/unstable-book/src/library-features/rand.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frand.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frand.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Frand.md?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,5 +0,0 @@\n-# `rand`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "0a265ee1376a0acf48d83c3463d61eaca97bd891", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -11,6 +11,9 @@ path = \"lib.rs\"\n core = { path = \"../libcore\" }\n std_unicode = { path = \"../libstd_unicode\" }\n \n+[dev-dependencies]\n+rand = \"0.3\"\n+\n [[test]]\n name = \"collectionstests\"\n path = \"../liballoc/tests/lib.rs\""}, {"sha": "3cc3ea467966be5a11dc56d4c6b429c00a450e0d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -135,6 +135,8 @@\n extern crate std;\n #[cfg(test)]\n extern crate test;\n+#[cfg(test)]\n+extern crate rand;\n \n extern crate std_unicode;\n "}, {"sha": "fac6acaca6125aa80b3882ac450a826b90646980", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -1269,10 +1269,11 @@ unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n \n #[cfg(test)]\n mod tests {\n-    use std::__rand::{thread_rng, Rng};\n     use std::thread;\n     use std::vec::Vec;\n \n+    use rand::{thread_rng, Rng};\n+\n     use super::{LinkedList, Node};\n \n     #[cfg(test)]"}, {"sha": "00ebd88d464ec418da2f9a3be77b95ed719215ef", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -30,6 +30,7 @@\n #![feature(unicode)]\n \n extern crate std_unicode;\n+extern crate rand;\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;"}, {"sha": "85d5ce304b88de2c27556a8414d61e93bb681173", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -10,9 +10,10 @@\n \n use std::cmp::Ordering::{Equal, Greater, Less};\n use std::mem;\n-use std::__rand::{Rng, thread_rng};\n use std::rc::Rc;\n \n+use rand::{Rng, thread_rng};\n+\n fn square(n: usize) -> usize {\n     n * n\n }"}, {"sha": "d1a0a5f09e0d5d83cac2c6149f2dc61d1d665053", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -10,7 +10,7 @@ test = false\n bench = false\n \n [dev-dependencies]\n-rand = { path = \"../librand\" }\n+rand = \"0.3\"\n \n [[test]]\n name = \"coretests\""}, {"sha": "2720c5c8677af8a6ec67464d05e0d50b0b46cd96", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -10,8 +10,7 @@\n \n use std::prelude::v1::*;\n use std::{str, mem, i16, f32, f64, fmt};\n-use std::__rand as rand;\n-use rand::{Rand, XorShiftRng};\n+use rand::{self, Rand, XorShiftRng};\n use rand::distributions::{IndependentSample, Range};\n \n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};"}, {"sha": "eda5f217565de80a1876fc146ff4d925fa63a159", "filename": "src/librand/Cargo.toml", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2FCargo.toml?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,12 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rand\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rand\"\n-path = \"lib.rs\"\n-doc = false\n-\n-[dependencies]\n-core = { path = \"../libcore\" }"}, {"sha": "e355eb44e4667f292e4265e9393e09c07d13b5a4", "filename": "src/librand/chacha.rs", "status": "removed", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,309 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The ChaCha random number generator.\n-\n-use core::fmt;\n-use {Rand, Rng, SeedableRng};\n-\n-const KEY_WORDS: usize = 8; // 8 words for the 256-bit key\n-const STATE_WORDS: usize = 16;\n-const CHACHA_ROUNDS: usize = 20; // Cryptographically secure from 8 upwards as of this writing\n-\n-/// A random number generator that uses the ChaCha20 algorithm [1].\n-///\n-/// The ChaCha algorithm is widely accepted as suitable for\n-/// cryptographic purposes, but this implementation has not been\n-/// verified as such. Prefer a generator like `OsRng` that defers to\n-/// the operating system for cases that need high security.\n-///\n-/// [1]: D. J. Bernstein, [*ChaCha, a variant of\n-/// Salsa20*](http://cr.yp.to/chacha.html)\n-#[derive(Copy, Clone)]\n-pub struct ChaChaRng {\n-    buffer: [u32; STATE_WORDS], // Internal buffer of output\n-    state: [u32; STATE_WORDS], // Initial state\n-    index: usize, // Index into state\n-}\n-\n-impl fmt::Debug for ChaChaRng {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ChaChaRng\")\n-         .field(\"buffer\", &self.buffer.iter())\n-         .field(\"state\", &self.state.iter())\n-         .field(\"index\", &self.index)\n-         .finish()\n-    }\n-}\n-\n-static EMPTY: ChaChaRng = ChaChaRng {\n-    buffer: [0; STATE_WORDS],\n-    state: [0; STATE_WORDS],\n-    index: STATE_WORDS,\n-};\n-\n-\n-macro_rules! quarter_round{\n-    ($a: expr, $b: expr, $c: expr, $d: expr) => {{\n-        $a = $a.wrapping_add($b); $d = $d ^ $a; $d = $d.rotate_left(16);\n-        $c = $c.wrapping_add($d); $b = $b ^ $c; $b = $b.rotate_left(12);\n-        $a = $a.wrapping_add($b); $d = $d ^ $a; $d = $d.rotate_left( 8);\n-        $c = $c.wrapping_add($d); $b = $b ^ $c; $b = $b.rotate_left( 7);\n-    }}\n-}\n-\n-macro_rules! double_round{\n-    ($x: expr) => {{\n-        // Column round\n-        quarter_round!($x[ 0], $x[ 4], $x[ 8], $x[12]);\n-        quarter_round!($x[ 1], $x[ 5], $x[ 9], $x[13]);\n-        quarter_round!($x[ 2], $x[ 6], $x[10], $x[14]);\n-        quarter_round!($x[ 3], $x[ 7], $x[11], $x[15]);\n-        // Diagonal round\n-        quarter_round!($x[ 0], $x[ 5], $x[10], $x[15]);\n-        quarter_round!($x[ 1], $x[ 6], $x[11], $x[12]);\n-        quarter_round!($x[ 2], $x[ 7], $x[ 8], $x[13]);\n-        quarter_round!($x[ 3], $x[ 4], $x[ 9], $x[14]);\n-    }}\n-}\n-\n-#[inline]\n-fn core(output: &mut [u32; STATE_WORDS], input: &[u32; STATE_WORDS]) {\n-    *output = *input;\n-\n-    for _ in 0..CHACHA_ROUNDS / 2 {\n-        double_round!(output);\n-    }\n-\n-    for i in 0..STATE_WORDS {\n-        output[i] = output[i].wrapping_add(input[i]);\n-    }\n-}\n-\n-impl ChaChaRng {\n-    /// Create an ChaCha random number generator using the default\n-    /// fixed key of 8 zero words.\n-    pub fn new_unseeded() -> ChaChaRng {\n-        let mut rng = EMPTY;\n-        rng.init(&[0; KEY_WORDS]);\n-        rng\n-    }\n-\n-    /// Sets the internal 128-bit ChaCha counter to\n-    /// a user-provided value. This permits jumping\n-    /// arbitrarily ahead (or backwards) in the pseudorandom stream.\n-    ///\n-    /// Since the nonce words are used to extend the counter to 128 bits,\n-    /// users wishing to obtain the conventional ChaCha pseudorandom stream\n-    /// associated with a particular nonce can call this function with\n-    /// arguments `0, desired_nonce`.\n-    pub fn set_counter(&mut self, counter_low: u64, counter_high: u64) {\n-        self.state[12] = (counter_low >> 0) as u32;\n-        self.state[13] = (counter_low >> 32) as u32;\n-        self.state[14] = (counter_high >> 0) as u32;\n-        self.state[15] = (counter_high >> 32) as u32;\n-        self.index = STATE_WORDS; // force recomputation\n-    }\n-\n-    /// Initializes `self.state` with the appropriate key and constants\n-    ///\n-    /// We deviate slightly from the ChaCha specification regarding\n-    /// the nonce, which is used to extend the counter to 128 bits.\n-    /// This is provably as strong as the original cipher, though,\n-    /// since any distinguishing attack on our variant also works\n-    /// against ChaCha with a chosen-nonce. See the XSalsa20 [1]\n-    /// security proof for a more involved example of this.\n-    ///\n-    /// The modified word layout is:\n-    /// ```text\n-    /// constant constant constant constant\n-    /// key      key      key      key\n-    /// key      key      key      key\n-    /// counter  counter  counter  counter\n-    /// ```\n-    /// [1]: Daniel J. Bernstein. [*Extending the Salsa20\n-    /// nonce.*](http://cr.yp.to/papers.html#xsalsa)\n-    fn init(&mut self, key: &[u32; KEY_WORDS]) {\n-        self.state[0] = 0x61707865;\n-        self.state[1] = 0x3320646E;\n-        self.state[2] = 0x79622D32;\n-        self.state[3] = 0x6B206574;\n-\n-        for i in 0..KEY_WORDS {\n-            self.state[4 + i] = key[i];\n-        }\n-\n-        self.state[12] = 0;\n-        self.state[13] = 0;\n-        self.state[14] = 0;\n-        self.state[15] = 0;\n-\n-        self.index = STATE_WORDS;\n-    }\n-\n-    /// Refill the internal output buffer (`self.buffer`)\n-    fn update(&mut self) {\n-        core(&mut self.buffer, &self.state);\n-        self.index = 0;\n-        // update 128-bit counter\n-        self.state[12] += 1;\n-        if self.state[12] != 0 {\n-            return;\n-        }\n-        self.state[13] += 1;\n-        if self.state[13] != 0 {\n-            return;\n-        }\n-        self.state[14] += 1;\n-        if self.state[14] != 0 {\n-            return;\n-        }\n-        self.state[15] += 1;\n-    }\n-}\n-\n-impl Rng for ChaChaRng {\n-    #[inline]\n-    fn next_u32(&mut self) -> u32 {\n-        if self.index == STATE_WORDS {\n-            self.update();\n-        }\n-\n-        let value = self.buffer[self.index % STATE_WORDS];\n-        self.index += 1;\n-        value\n-    }\n-}\n-\n-impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n-    fn reseed(&mut self, seed: &'a [u32]) {\n-        // reset state\n-        self.init(&[0; KEY_WORDS]);\n-        // set key in place\n-        let key = &mut self.state[4..4 + KEY_WORDS];\n-        for (k, s) in key.iter_mut().zip(seed) {\n-            *k = *s;\n-        }\n-    }\n-\n-    /// Create a ChaCha generator from a seed,\n-    /// obtained from a variable-length u32 array.\n-    /// Only up to 8 words are used; if less than 8\n-    /// words are used, the remaining are set to zero.\n-    fn from_seed(seed: &'a [u32]) -> ChaChaRng {\n-        let mut rng = EMPTY;\n-        rng.reseed(seed);\n-        rng\n-    }\n-}\n-\n-impl Rand for ChaChaRng {\n-    fn rand<R: Rng>(other: &mut R) -> ChaChaRng {\n-        let mut key: [u32; KEY_WORDS] = [0; KEY_WORDS];\n-        for word in &mut key {\n-            *word = other.gen();\n-        }\n-        SeedableRng::from_seed(&key[..])\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::prelude::v1::*;\n-\n-    use {Rng, SeedableRng};\n-    use super::ChaChaRng;\n-\n-    #[test]\n-    fn test_rng_rand_seeded() {\n-        let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(&*s);\n-        let mut rb: ChaChaRng = SeedableRng::from_seed(&*s);\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-\n-    #[test]\n-    fn test_rng_seeded() {\n-        let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n-        let mut rb: ChaChaRng = SeedableRng::from_seed(seed);\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-\n-    #[test]\n-    fn test_rng_reseed() {\n-        let s = ::test::rng().gen_iter::<u32>().take(8).collect::<Vec<u32>>();\n-        let mut r: ChaChaRng = SeedableRng::from_seed(&*s);\n-        let string1: String = r.gen_ascii_chars().take(100).collect();\n-\n-        r.reseed(&s);\n-\n-        let string2: String = r.gen_ascii_chars().take(100).collect();\n-        assert_eq!(string1, string2);\n-    }\n-\n-    #[test]\n-    #[rustfmt_skip]\n-    fn test_rng_true_values() {\n-        // Test vectors 1 and 2 from\n-        // http://tools.ietf.org/html/draft-nir-cfrg-chacha20-poly1305-04\n-        let seed: &[_] = &[0; 8];\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n-\n-        let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n-        assert_eq!(v,\n-                   vec![0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n-                        0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n-                        0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n-                        0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2]);\n-\n-        let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n-        assert_eq!(v,\n-                   vec![0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n-                        0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,\n-                        0x7621b729, 0x434ee69c, 0xb03371d5, 0xd539d874,\n-                        0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b]);\n-\n-\n-        let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n-\n-        // Store the 17*i-th 32-bit word,\n-        // i.e., the i-th word of the i-th 16-word block\n-        let mut v: Vec<u32> = Vec::new();\n-        for _ in 0..16 {\n-            v.push(ra.next_u32());\n-            for _ in 0..16 {\n-                ra.next_u32();\n-            }\n-        }\n-\n-        assert_eq!(v,\n-                   vec![0xf225c81a, 0x6ab1be57, 0x04d42951, 0x70858036,\n-                        0x49884684, 0x64efec72, 0x4be2d186, 0x3615b384,\n-                        0x11cfa18e, 0xd3c50049, 0x75c775f6, 0x434c6530,\n-                        0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4]);\n-    }\n-\n-    #[test]\n-    fn test_rng_clone() {\n-        let seed: &[_] = &[0; 8];\n-        let mut rng: ChaChaRng = SeedableRng::from_seed(seed);\n-        let mut clone = rng.clone();\n-        for _ in 0..16 {\n-            assert_eq!(rng.next_u64(), clone.next_u64());\n-        }\n-    }\n-}"}, {"sha": "3337cc2a6273cf78731a7ad12b3f2ef46e91b543", "filename": "src/librand/distributions/exponential.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,155 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The exponential distribution.\n-\n-use core::fmt;\n-\n-#[cfg(not(test))] // only necessary for no_std\n-use FloatMath;\n-\n-use {Rand, Rng};\n-use distributions::{IndependentSample, Sample, ziggurat, ziggurat_tables};\n-\n-/// A wrapper around an `f64` to generate Exp(1) random numbers.\n-///\n-/// See `Exp` for the general exponential distribution. Note that this has to\n-/// be unwrapped before use as an `f64` (using either `*` or `mem::transmute`\n-/// is safe).\n-///\n-/// Implemented via the ZIGNOR variant[1] of the Ziggurat method. The\n-/// exact description in the paper was adjusted to use tables for the\n-/// exponential distribution rather than normal.\n-///\n-/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n-/// Generate Normal Random\n-/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n-/// College, Oxford\n-#[derive(Copy, Clone)]\n-pub struct Exp1(pub f64);\n-\n-// This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n-impl Rand for Exp1 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> Exp1 {\n-        #[inline]\n-        fn pdf(x: f64) -> f64 {\n-            (-x).exp()\n-        }\n-        #[inline]\n-        fn zero_case<R: Rng>(rng: &mut R, _u: f64) -> f64 {\n-            ziggurat_tables::ZIG_EXP_R - rng.gen::<f64>().ln()\n-        }\n-\n-        Exp1(ziggurat(rng,\n-                      false,\n-                      &ziggurat_tables::ZIG_EXP_X,\n-                      &ziggurat_tables::ZIG_EXP_F,\n-                      pdf,\n-                      zero_case))\n-    }\n-}\n-\n-impl fmt::Debug for Exp1 {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Exp1\")\n-         .field(&self.0)\n-         .finish()\n-    }\n-}\n-\n-/// The exponential distribution `Exp(lambda)`.\n-///\n-/// This distribution has density function: `f(x) = lambda *\n-/// exp(-lambda * x)` for `x > 0`.\n-#[derive(Copy, Clone)]\n-pub struct Exp {\n-    /// `lambda` stored as `1/lambda`, since this is what we scale by.\n-    lambda_inverse: f64,\n-}\n-\n-impl Exp {\n-    /// Construct a new `Exp` with the given shape parameter\n-    /// `lambda`. Panics if `lambda <= 0`.\n-    pub fn new(lambda: f64) -> Exp {\n-        assert!(lambda > 0.0, \"Exp::new called with `lambda` <= 0\");\n-        Exp { lambda_inverse: 1.0 / lambda }\n-    }\n-}\n-\n-impl Sample<f64> for Exp {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for Exp {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let Exp1(n) = rng.gen::<Exp1>();\n-        n * self.lambda_inverse\n-    }\n-}\n-\n-impl fmt::Debug for Exp {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Exp\")\n-         .field(\"lambda_inverse\", &self.lambda_inverse)\n-         .finish()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use distributions::{IndependentSample, Sample};\n-    use super::Exp;\n-\n-    #[test]\n-    fn test_exp() {\n-        let mut exp = Exp::new(10.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            assert!(exp.sample(&mut rng) >= 0.0);\n-            assert!(exp.ind_sample(&mut rng) >= 0.0);\n-        }\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_exp_invalid_lambda_zero() {\n-        Exp::new(0.0);\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_exp_invalid_lambda_neg() {\n-        Exp::new(-10.0);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    use self::test::Bencher;\n-    use std::mem::size_of;\n-    use super::Exp;\n-    use distributions::Sample;\n-\n-    #[bench]\n-    fn rand_exp(b: &mut Bencher) {\n-        let mut rng = ::test::weak_rng();\n-        let mut exp = Exp::new(2.71828 * 3.14159);\n-\n-        b.iter(|| {\n-            for _ in 0..::RAND_BENCH_N {\n-                exp.sample(&mut rng);\n-            }\n-        });\n-        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n-    }\n-}"}, {"sha": "e796197ab5bf24e16ae23416cd17c66b7fb9d758", "filename": "src/librand/distributions/gamma.rs", "status": "removed", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,439 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The Gamma and derived distributions.\n-\n-use core::fmt;\n-\n-use self::GammaRepr::*;\n-use self::ChiSquaredRepr::*;\n-\n-#[cfg(not(test))] // only necessary for no_std\n-use FloatMath;\n-\n-use {Open01, Rng};\n-use super::normal::StandardNormal;\n-use super::{Exp, IndependentSample, Sample};\n-\n-/// The Gamma distribution `Gamma(shape, scale)` distribution.\n-///\n-/// The density function of this distribution is\n-///\n-/// ```text\n-/// f(x) =  x^(k - 1) * exp(-x / \u03b8) / (\u0393(k) * \u03b8^k)\n-/// ```\n-///\n-/// where `\u0393` is the Gamma function, `k` is the shape and `\u03b8` is the\n-/// scale and both `k` and `\u03b8` are strictly positive.\n-///\n-/// The algorithm used is that described by Marsaglia & Tsang 2000[1],\n-/// falling back to directly sampling from an Exponential for `shape\n-/// == 1`, and using the boosting technique described in [1] for\n-/// `shape < 1`.\n-///\n-/// [1]: George Marsaglia and Wai Wan Tsang. 2000. \"A Simple Method\n-/// for Generating Gamma Variables\" *ACM Trans. Math. Softw.* 26, 3\n-/// (September 2000),\n-/// 363-372. DOI:[10.1145/358407.358414](http://doi.acm.org/10.1145/358407.358414)\n-pub struct Gamma {\n-    repr: GammaRepr,\n-}\n-\n-impl fmt::Debug for Gamma {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Gamma\")\n-         .field(\"repr\",\n-                &match self.repr {\n-                    GammaRepr::Large(_) => \"Large\",\n-                    GammaRepr::One(_) => \"Exp\",\n-                    GammaRepr::Small(_) => \"Small\"\n-                })\n-          .finish()\n-    }\n-}\n-\n-enum GammaRepr {\n-    Large(GammaLargeShape),\n-    One(Exp),\n-    Small(GammaSmallShape),\n-}\n-\n-// These two helpers could be made public, but saving the\n-// match-on-Gamma-enum branch from using them directly (e.g. if one\n-// knows that the shape is always > 1) doesn't appear to be much\n-// faster.\n-\n-/// Gamma distribution where the shape parameter is less than 1.\n-///\n-/// Note, samples from this require a compulsory floating-point `pow`\n-/// call, which makes it significantly slower than sampling from a\n-/// gamma distribution where the shape parameter is greater than or\n-/// equal to 1.\n-///\n-/// See `Gamma` for sampling from a Gamma distribution with general\n-/// shape parameters.\n-struct GammaSmallShape {\n-    inv_shape: f64,\n-    large_shape: GammaLargeShape,\n-}\n-\n-/// Gamma distribution where the shape parameter is larger than 1.\n-///\n-/// See `Gamma` for sampling from a Gamma distribution with general\n-/// shape parameters.\n-struct GammaLargeShape {\n-    scale: f64,\n-    c: f64,\n-    d: f64,\n-}\n-\n-impl Gamma {\n-    /// Construct an object representing the `Gamma(shape, scale)`\n-    /// distribution.\n-    ///\n-    /// Panics if `shape <= 0` or `scale <= 0`.\n-    pub fn new(shape: f64, scale: f64) -> Gamma {\n-        assert!(shape > 0.0, \"Gamma::new called with shape <= 0\");\n-        assert!(scale > 0.0, \"Gamma::new called with scale <= 0\");\n-\n-        let repr = if shape == 1.0 {\n-            One(Exp::new(1.0 / scale))\n-        } else if 0.0 <= shape && shape < 1.0 {\n-            Small(GammaSmallShape::new_raw(shape, scale))\n-        } else {\n-            Large(GammaLargeShape::new_raw(shape, scale))\n-        };\n-        Gamma { repr }\n-    }\n-}\n-\n-impl GammaSmallShape {\n-    fn new_raw(shape: f64, scale: f64) -> GammaSmallShape {\n-        GammaSmallShape {\n-            inv_shape: 1. / shape,\n-            large_shape: GammaLargeShape::new_raw(shape + 1.0, scale),\n-        }\n-    }\n-}\n-\n-impl GammaLargeShape {\n-    fn new_raw(shape: f64, scale: f64) -> GammaLargeShape {\n-        let d = shape - 1. / 3.;\n-        GammaLargeShape {\n-            scale,\n-            c: 1. / (9. * d).sqrt(),\n-            d,\n-        }\n-    }\n-}\n-\n-impl Sample<f64> for Gamma {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-impl Sample<f64> for GammaSmallShape {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-impl Sample<f64> for GammaLargeShape {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for Gamma {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        match self.repr {\n-            Small(ref g) => g.ind_sample(rng),\n-            One(ref g) => g.ind_sample(rng),\n-            Large(ref g) => g.ind_sample(rng),\n-        }\n-    }\n-}\n-impl IndependentSample<f64> for GammaSmallShape {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let Open01(u) = rng.gen::<Open01<f64>>();\n-\n-        self.large_shape.ind_sample(rng) * u.powf(self.inv_shape)\n-    }\n-}\n-impl IndependentSample<f64> for GammaLargeShape {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        loop {\n-            let StandardNormal(x) = rng.gen::<StandardNormal>();\n-            let v_cbrt = 1.0 + self.c * x;\n-            if v_cbrt <= 0.0 {\n-                // a^3 <= 0 iff a <= 0\n-                continue;\n-            }\n-\n-            let v = v_cbrt * v_cbrt * v_cbrt;\n-            let Open01(u) = rng.gen::<Open01<f64>>();\n-\n-            let x_sqr = x * x;\n-            if u < 1.0 - 0.0331 * x_sqr * x_sqr ||\n-               u.ln() < 0.5 * x_sqr + self.d * (1.0 - v + v.ln()) {\n-                return self.d * v * self.scale;\n-            }\n-        }\n-    }\n-}\n-\n-/// The chi-squared distribution `\u03c7\u00b2(k)`, where `k` is the degrees of\n-/// freedom.\n-///\n-/// For `k > 0` integral, this distribution is the sum of the squares\n-/// of `k` independent standard normal random variables. For other\n-/// `k`, this uses the equivalent characterization `\u03c7\u00b2(k) = Gamma(k/2,\n-/// 2)`.\n-pub struct ChiSquared {\n-    repr: ChiSquaredRepr,\n-}\n-\n-impl fmt::Debug for ChiSquared {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ChiSquared\")\n-         .field(\"repr\",\n-                &match self.repr {\n-                    ChiSquaredRepr::DoFExactlyOne => \"DoFExactlyOne\",\n-                    ChiSquaredRepr::DoFAnythingElse(_) => \"DoFAnythingElse\",\n-                })\n-         .finish()\n-    }\n-}\n-\n-enum ChiSquaredRepr {\n-    // k == 1, Gamma(alpha, ..) is particularly slow for alpha < 1,\n-    // e.g. when alpha = 1/2 as it would be for this case, so special-\n-    // casing and using the definition of N(0,1)^2 is faster.\n-    DoFExactlyOne,\n-    DoFAnythingElse(Gamma),\n-}\n-\n-impl ChiSquared {\n-    /// Create a new chi-squared distribution with degrees-of-freedom\n-    /// `k`. Panics if `k < 0`.\n-    pub fn new(k: f64) -> ChiSquared {\n-        let repr = if k == 1.0 {\n-            DoFExactlyOne\n-        } else {\n-            assert!(k > 0.0, \"ChiSquared::new called with `k` < 0\");\n-            DoFAnythingElse(Gamma::new(0.5 * k, 2.0))\n-        };\n-        ChiSquared { repr: repr }\n-    }\n-}\n-\n-impl Sample<f64> for ChiSquared {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for ChiSquared {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        match self.repr {\n-            DoFExactlyOne => {\n-                // k == 1 => N(0,1)^2\n-                let StandardNormal(norm) = rng.gen::<StandardNormal>();\n-                norm * norm\n-            }\n-            DoFAnythingElse(ref g) => g.ind_sample(rng),\n-        }\n-    }\n-}\n-\n-/// The Fisher F distribution `F(m, n)`.\n-///\n-/// This distribution is equivalent to the ratio of two normalized\n-/// chi-squared distributions, that is, `F(m,n) = (\u03c7\u00b2(m)/m) /\n-/// (\u03c7\u00b2(n)/n)`.\n-pub struct FisherF {\n-    numer: ChiSquared,\n-    denom: ChiSquared,\n-    // denom_dof / numer_dof so that this can just be a straight\n-    // multiplication, rather than a division.\n-    dof_ratio: f64,\n-}\n-\n-impl FisherF {\n-    /// Create a new `FisherF` distribution, with the given\n-    /// parameter. Panics if either `m` or `n` are not positive.\n-    pub fn new(m: f64, n: f64) -> FisherF {\n-        assert!(m > 0.0, \"FisherF::new called with `m < 0`\");\n-        assert!(n > 0.0, \"FisherF::new called with `n < 0`\");\n-\n-        FisherF {\n-            numer: ChiSquared::new(m),\n-            denom: ChiSquared::new(n),\n-            dof_ratio: n / m,\n-        }\n-    }\n-}\n-\n-impl Sample<f64> for FisherF {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for FisherF {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        self.numer.ind_sample(rng) / self.denom.ind_sample(rng) * self.dof_ratio\n-    }\n-}\n-\n-impl fmt::Debug for FisherF {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FisherF\")\n-         .field(\"numer\", &self.numer)\n-         .field(\"denom\", &self.denom)\n-         .field(\"dof_ratio\", &self.dof_ratio)\n-         .finish()\n-    }\n-}\n-\n-/// The Student t distribution, `t(nu)`, where `nu` is the degrees of\n-/// freedom.\n-pub struct StudentT {\n-    chi: ChiSquared,\n-    dof: f64,\n-}\n-\n-impl StudentT {\n-    /// Create a new Student t distribution with `n` degrees of\n-    /// freedom. Panics if `n <= 0`.\n-    pub fn new(n: f64) -> StudentT {\n-        assert!(n > 0.0, \"StudentT::new called with `n <= 0`\");\n-        StudentT {\n-            chi: ChiSquared::new(n),\n-            dof: n,\n-        }\n-    }\n-}\n-\n-impl Sample<f64> for StudentT {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for StudentT {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let StandardNormal(norm) = rng.gen::<StandardNormal>();\n-        norm * (self.dof / self.chi.ind_sample(rng)).sqrt()\n-    }\n-}\n-\n-impl fmt::Debug for StudentT {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"StudentT\")\n-         .field(\"chi\", &self.chi)\n-         .field(\"dof\", &self.dof)\n-         .finish()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use distributions::{IndependentSample, Sample};\n-    use super::{ChiSquared, FisherF, StudentT};\n-\n-    #[test]\n-    fn test_chi_squared_one() {\n-        let mut chi = ChiSquared::new(1.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            chi.sample(&mut rng);\n-            chi.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    fn test_chi_squared_small() {\n-        let mut chi = ChiSquared::new(0.5);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            chi.sample(&mut rng);\n-            chi.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    fn test_chi_squared_large() {\n-        let mut chi = ChiSquared::new(30.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            chi.sample(&mut rng);\n-            chi.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_chi_squared_invalid_dof() {\n-        ChiSquared::new(-1.0);\n-    }\n-\n-    #[test]\n-    fn test_f() {\n-        let mut f = FisherF::new(2.0, 32.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            f.sample(&mut rng);\n-            f.ind_sample(&mut rng);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_t() {\n-        let mut t = StudentT::new(11.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            t.sample(&mut rng);\n-            t.ind_sample(&mut rng);\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use std::mem::size_of;\n-    use distributions::IndependentSample;\n-    use super::Gamma;\n-\n-\n-    #[bench]\n-    fn bench_gamma_large_shape(b: &mut Bencher) {\n-        let gamma = Gamma::new(10., 1.0);\n-        let mut rng = ::test::weak_rng();\n-\n-        b.iter(|| {\n-            for _ in 0..::RAND_BENCH_N {\n-                gamma.ind_sample(&mut rng);\n-            }\n-        });\n-        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n-    }\n-\n-    #[bench]\n-    fn bench_gamma_small_shape(b: &mut Bencher) {\n-        let gamma = Gamma::new(0.1, 1.0);\n-        let mut rng = ::test::weak_rng();\n-\n-        b.iter(|| {\n-            for _ in 0..::RAND_BENCH_N {\n-                gamma.ind_sample(&mut rng);\n-            }\n-        });\n-        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n-    }\n-}"}, {"sha": "47967a719d397a8972d39bf4e90ac356721af550", "filename": "src/librand/distributions/mod.rs", "status": "removed", "additions": 0, "deletions": 397, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,397 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Sampling from random distributions.\n-//!\n-//! This is a generalization of `Rand` to allow parameters to control the\n-//! exact properties of the generated values, e.g. the mean and standard\n-//! deviation of a normal distribution. The `Sample` trait is the most\n-//! general, and allows for generating values that change some state\n-//! internally. The `IndependentSample` trait is for generating values\n-//! that do not need to record state.\n-\n-use core::fmt;\n-\n-#[cfg(not(test))] // only necessary for no_std\n-use core::num::Float;\n-\n-use core::marker::PhantomData;\n-\n-use {Rand, Rng};\n-\n-pub use self::range::Range;\n-pub use self::gamma::{ChiSquared, FisherF, Gamma, StudentT};\n-pub use self::normal::{LogNormal, Normal};\n-pub use self::exponential::Exp;\n-\n-pub mod range;\n-pub mod gamma;\n-pub mod normal;\n-pub mod exponential;\n-\n-/// Types that can be used to create a random instance of `Support`.\n-pub trait Sample<Support> {\n-    /// Generate a random value of `Support`, using `rng` as the\n-    /// source of randomness.\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> Support;\n-}\n-\n-/// `Sample`s that do not require keeping track of state.\n-///\n-/// Since no state is recorded, each sample is (statistically)\n-/// independent of all others, assuming the `Rng` used has this\n-/// property.\n-// FIXME maybe having this separate is overkill (the only reason is to\n-// take &self rather than &mut self)? or maybe this should be the\n-// trait called `Sample` and the other should be `DependentSample`.\n-pub trait IndependentSample<Support>: Sample<Support> {\n-    /// Generate a random value.\n-    fn ind_sample<R: Rng>(&self, _: &mut R) -> Support;\n-}\n-\n-/// A wrapper for generating types that implement `Rand` via the\n-/// `Sample` & `IndependentSample` traits.\n-pub struct RandSample<Sup> {\n-    _marker: PhantomData<Sup>,\n-}\n-\n-impl<Sup> RandSample<Sup> {\n-    pub fn new() -> RandSample<Sup> {\n-        RandSample { _marker: PhantomData }\n-    }\n-}\n-\n-impl<Sup: Rand> Sample<Sup> for RandSample<Sup> {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl<Sup: Rand> IndependentSample<Sup> for RandSample<Sup> {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n-        rng.gen()\n-    }\n-}\n-\n-impl<Sup> fmt::Debug for RandSample<Sup> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"RandSample { .. }\")\n-    }\n-}\n-\n-/// A value with a particular weight for use with `WeightedChoice`.\n-pub struct Weighted<T> {\n-    /// The numerical weight of this item\n-    pub weight: usize,\n-    /// The actual item which is being weighted\n-    pub item: T,\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for Weighted<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Weighted\")\n-         .field(\"weight\", &self.weight)\n-         .field(\"item\", &self.item)\n-         .finish()\n-    }\n-}\n-\n-/// A distribution that selects from a finite collection of weighted items.\n-///\n-/// Each item has an associated weight that influences how likely it\n-/// is to be chosen: higher weight is more likely.\n-///\n-/// The `Clone` restriction is a limitation of the `Sample` and\n-/// `IndependentSample` traits. Note that `&T` is (cheaply) `Clone` for\n-/// all `T`, as is `usize`, so one can store references or indices into\n-/// another vector.\n-pub struct WeightedChoice<'a, T: 'a> {\n-    items: &'a mut [Weighted<T>],\n-    weight_range: Range<usize>,\n-}\n-\n-impl<'a, T: Clone> WeightedChoice<'a, T> {\n-    /// Create a new `WeightedChoice`.\n-    ///\n-    /// Panics if:\n-    /// - `v` is empty\n-    /// - the total weight is 0\n-    /// - the total weight is larger than a `usize` can contain.\n-    pub fn new(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n-        // strictly speaking, this is subsumed by the total weight == 0 case\n-        assert!(!items.is_empty(),\n-                \"WeightedChoice::new called with no items\");\n-\n-        let mut running_total = 0_usize;\n-\n-        // we convert the list from individual weights to cumulative\n-        // weights so we can binary search. This *could* drop elements\n-        // with weight == 0 as an optimisation.\n-        for item in &mut *items {\n-            running_total = match running_total.checked_add(item.weight) {\n-                Some(n) => n,\n-                None => {\n-                    panic!(\"WeightedChoice::new called with a total weight larger than a usize \\\n-                            can contain\")\n-                }\n-            };\n-\n-            item.weight = running_total;\n-        }\n-        assert!(running_total != 0,\n-                \"WeightedChoice::new called with a total weight of 0\");\n-\n-        WeightedChoice {\n-            items,\n-            // we're likely to be generating numbers in this range\n-            // relatively often, so might as well cache it\n-            weight_range: Range::new(0, running_total),\n-        }\n-    }\n-}\n-\n-impl<'a, T: Clone> Sample<T> for WeightedChoice<'a, T> {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> T {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl<'a, T: Clone> IndependentSample<T> for WeightedChoice<'a, T> {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> T {\n-        // we want to find the first element that has cumulative\n-        // weight > sample_weight, which we do by binary since the\n-        // cumulative weights of self.items are sorted.\n-\n-        // choose a weight in [0, total_weight)\n-        let sample_weight = self.weight_range.ind_sample(rng);\n-\n-        // short circuit when it's the first item\n-        if sample_weight < self.items[0].weight {\n-            return self.items[0].item.clone();\n-        }\n-\n-        let mut idx = 0;\n-        let mut modifier = self.items.len();\n-\n-        // now we know that every possibility has an element to the\n-        // left, so we can just search for the last element that has\n-        // cumulative weight <= sample_weight, then the next one will\n-        // be \"it\". (Note that this greatest element will never be the\n-        // last element of the vector, since sample_weight is chosen\n-        // in [0, total_weight) and the cumulative weight of the last\n-        // one is exactly the total weight.)\n-        while modifier > 1 {\n-            let i = idx + modifier / 2;\n-            if self.items[i].weight <= sample_weight {\n-                // we're small, so look to the right, but allow this\n-                // exact element still.\n-                idx = i;\n-                // we need the `/ 2` to round up otherwise we'll drop\n-                // the trailing elements when `modifier` is odd.\n-                modifier += 1;\n-            } else {\n-                // otherwise we're too big, so go left. (i.e. do\n-                // nothing)\n-            }\n-            modifier /= 2;\n-        }\n-        return self.items[idx + 1].item.clone();\n-    }\n-}\n-\n-impl<'a, T: fmt::Debug> fmt::Debug for WeightedChoice<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"WeightedChoice\")\n-         .field(\"items\", &self.items)\n-         .field(\"weight_range\", &self.weight_range)\n-         .finish()\n-    }\n-}\n-\n-mod ziggurat_tables;\n-\n-/// Sample a random number using the Ziggurat method (specifically the\n-/// ZIGNOR variant from Doornik 2005). Most of the arguments are\n-/// directly from the paper:\n-///\n-/// * `rng`: source of randomness\n-/// * `symmetric`: whether this is a symmetric distribution, or one-sided with P(x < 0) = 0.\n-/// * `X`: the $x_i$ abscissae.\n-/// * `F`: precomputed values of the PDF at the $x_i$, (i.e. $f(x_i)$)\n-/// * `F_DIFF`: precomputed values of $f(x_i) - f(x_{i+1})$\n-/// * `pdf`: the probability density function\n-/// * `zero_case`: manual sampling from the tail when we chose the\n-///    bottom box (i.e. i == 0)\n-// the perf improvement (25-50%) is definitely worth the extra code\n-// size from force-inlining.\n-#[inline(always)]\n-fn ziggurat<R: Rng, P, Z>(rng: &mut R,\n-                          symmetric: bool,\n-                          x_tab: ziggurat_tables::ZigTable,\n-                          f_tab: ziggurat_tables::ZigTable,\n-                          mut pdf: P,\n-                          mut zero_case: Z)\n-                          -> f64\n-    where P: FnMut(f64) -> f64,\n-          Z: FnMut(&mut R, f64) -> f64\n-{\n-    const SCALE: f64 = (1u64 << 53) as f64;\n-    loop {\n-        // reimplement the f64 generation as an optimisation suggested\n-        // by the Doornik paper: we have a lot of precision-space\n-        // (i.e. there are 11 bits of the 64 of a u64 to use after\n-        // creating a f64), so we might as well reuse some to save\n-        // generating a whole extra random number. (Seems to be 15%\n-        // faster.)\n-        //\n-        // This unfortunately misses out on the benefits of direct\n-        // floating point generation if an RNG like dSMFT is\n-        // used. (That is, such RNGs create floats directly, highly\n-        // efficiently and overload next_f32/f64, so by not calling it\n-        // this may be slower than it would be otherwise.)\n-        // FIXME: investigate/optimise for the above.\n-        let bits: u64 = rng.gen();\n-        let i = (bits & 0xff) as usize;\n-        let f = (bits >> 11) as f64 / SCALE;\n-\n-        // u is either U(-1, 1) or U(0, 1) depending on if this is a\n-        // symmetric distribution or not.\n-        let u = if symmetric { 2.0 * f - 1.0 } else { f };\n-        let x = u * x_tab[i];\n-\n-        let test_x = if symmetric { x.abs() } else { x };\n-\n-        // algebraically equivalent to |u| < x_tab[i+1]/x_tab[i] (or u < x_tab[i+1]/x_tab[i])\n-        if test_x < x_tab[i + 1] {\n-            return x;\n-        }\n-        if i == 0 {\n-            return zero_case(rng, u);\n-        }\n-        // algebraically equivalent to f1 + DRanU()*(f0 - f1) < 1\n-        if f_tab[i + 1] + (f_tab[i] - f_tab[i + 1]) * rng.gen::<f64>() < pdf(x) {\n-            return x;\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use {Rand, Rng};\n-    use super::{IndependentSample, RandSample, Sample, Weighted, WeightedChoice};\n-\n-    #[derive(PartialEq, Debug)]\n-    struct ConstRand(usize);\n-    impl Rand for ConstRand {\n-        fn rand<R: Rng>(_: &mut R) -> ConstRand {\n-            ConstRand(0)\n-        }\n-    }\n-\n-    // 0, 1, 2, 3, ...\n-    struct CountingRng {\n-        i: u32,\n-    }\n-    impl Rng for CountingRng {\n-        fn next_u32(&mut self) -> u32 {\n-            self.i += 1;\n-            self.i - 1\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            self.next_u32() as u64\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rand_sample() {\n-        let mut rand_sample = RandSample::<ConstRand>::new();\n-\n-        assert_eq!(rand_sample.sample(&mut ::test::rng()), ConstRand(0));\n-        assert_eq!(rand_sample.ind_sample(&mut ::test::rng()), ConstRand(0));\n-    }\n-    #[test]\n-    #[rustfmt_skip]\n-    fn test_weighted_choice() {\n-        // this makes assumptions about the internal implementation of\n-        // WeightedChoice, specifically: it doesn't reorder the items,\n-        // it doesn't do weird things to the RNG (so 0 maps to 0, 1 to\n-        // 1, internally; modulo a modulo operation).\n-\n-        macro_rules! t {\n-            ($items:expr, $expected:expr) => {{\n-                let mut items = $items;\n-                let wc = WeightedChoice::new(&mut items);\n-                let expected = $expected;\n-\n-                let mut rng = CountingRng { i: 0 };\n-\n-                for &val in &expected {\n-                    assert_eq!(wc.ind_sample(&mut rng), val)\n-                }\n-            }}\n-        }\n-\n-        t!(vec![Weighted { weight: 1, item: 10 }],\n-           [10]);\n-\n-        // skip some\n-        t!(vec![Weighted { weight: 0, item: 20 },\n-                Weighted { weight: 2, item: 21 },\n-                Weighted { weight: 0, item: 22 },\n-                Weighted { weight: 1, item: 23 }],\n-           [21, 21, 23]);\n-\n-        // different weights\n-        t!(vec![Weighted { weight: 4, item: 30 },\n-                Weighted { weight: 3, item: 31 }],\n-           [30, 30, 30, 30, 31, 31, 31]);\n-\n-        // check that we're binary searching\n-        // correctly with some vectors of odd\n-        // length.\n-        t!(vec![Weighted { weight: 1, item: 40 },\n-                Weighted { weight: 1, item: 41 },\n-                Weighted { weight: 1, item: 42 },\n-                Weighted { weight: 1, item: 43 },\n-                Weighted { weight: 1, item: 44 }],\n-           [40, 41, 42, 43, 44]);\n-        t!(vec![Weighted { weight: 1, item: 50 },\n-                Weighted { weight: 1, item: 51 },\n-                Weighted { weight: 1, item: 52 },\n-                Weighted { weight: 1, item: 53 },\n-                Weighted { weight: 1, item: 54 },\n-                Weighted { weight: 1, item: 55 },\n-                Weighted { weight: 1, item: 56 }],\n-           [50, 51, 52, 53, 54, 55, 56]);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_weighted_choice_no_items() {\n-        WeightedChoice::<isize>::new(&mut []);\n-    }\n-    #[test]\n-    #[should_panic]\n-    #[rustfmt_skip]\n-    fn test_weighted_choice_zero_weight() {\n-        WeightedChoice::new(&mut [Weighted { weight: 0, item: 0 },\n-                                  Weighted { weight: 0, item: 1 }]);\n-    }\n-    #[test]\n-    #[should_panic]\n-    #[rustfmt_skip]\n-    fn test_weighted_choice_weight_overflows() {\n-        let x = (!0) as usize / 2; // x + x + 2 is the overflow\n-        WeightedChoice::new(&mut [Weighted { weight: x, item: 0 },\n-                                  Weighted { weight: 1, item: 1 },\n-                                  Weighted { weight: x, item: 2 },\n-                                  Weighted { weight: 1, item: 3 }]);\n-    }\n-}"}, {"sha": "e1518dab21c2b9bb3215f6fa805547d39d44d40f", "filename": "src/librand/distributions/normal.rs", "status": "removed", "additions": 0, "deletions": 234, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,234 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The normal and derived distributions.\n-\n-use core::fmt;\n-\n-#[cfg(not(test))] // only necessary for no_std\n-use FloatMath;\n-\n-use {Open01, Rand, Rng};\n-use distributions::{IndependentSample, Sample, ziggurat, ziggurat_tables};\n-\n-/// A wrapper around an `f64` to generate N(0, 1) random numbers\n-/// (a.k.a.  a standard normal, or Gaussian).\n-///\n-/// See `Normal` for the general normal distribution. That this has to\n-/// be unwrapped before use as an `f64` (using either `*` or\n-/// `mem::transmute` is safe).\n-///\n-/// Implemented via the ZIGNOR variant[1] of the Ziggurat method.\n-///\n-/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n-/// Generate Normal Random\n-/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n-/// College, Oxford\n-#[derive(Copy, Clone)]\n-pub struct StandardNormal(pub f64);\n-\n-impl Rand for StandardNormal {\n-    fn rand<R: Rng>(rng: &mut R) -> StandardNormal {\n-        #[inline]\n-        fn pdf(x: f64) -> f64 {\n-            (-x * x / 2.0).exp()\n-        }\n-        #[inline]\n-        fn zero_case<R: Rng>(rng: &mut R, u: f64) -> f64 {\n-            // compute a random number in the tail by hand\n-\n-            // strange initial conditions, because the loop is not\n-            // do-while, so the condition should be true on the first\n-            // run, they get overwritten anyway (0 < 1, so these are\n-            // good).\n-            let mut x = 1.0f64;\n-            let mut y = 0.0f64;\n-\n-            while -2.0 * y < x * x {\n-                let Open01(x_) = rng.gen::<Open01<f64>>();\n-                let Open01(y_) = rng.gen::<Open01<f64>>();\n-\n-                x = x_.ln() / ziggurat_tables::ZIG_NORM_R;\n-                y = y_.ln();\n-            }\n-\n-            if u < 0.0 {\n-                x - ziggurat_tables::ZIG_NORM_R\n-            } else {\n-                ziggurat_tables::ZIG_NORM_R - x\n-            }\n-        }\n-\n-        StandardNormal(ziggurat(rng,\n-                                true, // this is symmetric\n-                                &ziggurat_tables::ZIG_NORM_X,\n-                                &ziggurat_tables::ZIG_NORM_F,\n-                                pdf,\n-                                zero_case))\n-    }\n-}\n-\n-impl fmt::Debug for StandardNormal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"StandardNormal\")\n-         .field(&self.0)\n-         .finish()\n-    }\n-}\n-\n-/// The normal distribution `N(mean, std_dev**2)`.\n-///\n-/// This uses the ZIGNOR variant of the Ziggurat method, see\n-/// `StandardNormal` for more details.\n-#[derive(Copy, Clone)]\n-pub struct Normal {\n-    mean: f64,\n-    std_dev: f64,\n-}\n-\n-impl Normal {\n-    /// Construct a new `Normal` distribution with the given mean and\n-    /// standard deviation.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `std_dev < 0`.\n-    pub fn new(mean: f64, std_dev: f64) -> Normal {\n-        assert!(std_dev >= 0.0, \"Normal::new called with `std_dev` < 0\");\n-        Normal {\n-            mean,\n-            std_dev,\n-        }\n-    }\n-}\n-\n-impl Sample<f64> for Normal {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for Normal {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let StandardNormal(n) = rng.gen::<StandardNormal>();\n-        self.mean + self.std_dev * n\n-    }\n-}\n-\n-impl fmt::Debug for Normal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Normal\")\n-         .field(\"mean\", &self.mean)\n-         .field(\"std_dev\", &self.std_dev)\n-         .finish()\n-    }\n-}\n-\n-\n-/// The log-normal distribution `ln N(mean, std_dev**2)`.\n-///\n-/// If `X` is log-normal distributed, then `ln(X)` is `N(mean,\n-/// std_dev**2)` distributed.\n-#[derive(Copy, Clone)]\n-pub struct LogNormal {\n-    norm: Normal,\n-}\n-\n-impl LogNormal {\n-    /// Construct a new `LogNormal` distribution with the given mean\n-    /// and standard deviation.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `std_dev < 0`.\n-    pub fn new(mean: f64, std_dev: f64) -> LogNormal {\n-        assert!(std_dev >= 0.0, \"LogNormal::new called with `std_dev` < 0\");\n-        LogNormal { norm: Normal::new(mean, std_dev) }\n-    }\n-}\n-\n-impl Sample<f64> for LogNormal {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl IndependentSample<f64> for LogNormal {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        self.norm.ind_sample(rng).exp()\n-    }\n-}\n-\n-impl fmt::Debug for LogNormal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LogNormal\")\n-         .field(\"norm\", &self.norm)\n-         .finish()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use distributions::{IndependentSample, Sample};\n-    use super::{LogNormal, Normal};\n-\n-    #[test]\n-    fn test_normal() {\n-        let mut norm = Normal::new(10.0, 10.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            norm.sample(&mut rng);\n-            norm.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_normal_invalid_sd() {\n-        Normal::new(10.0, -1.0);\n-    }\n-\n-\n-    #[test]\n-    fn test_log_normal() {\n-        let mut lnorm = LogNormal::new(10.0, 10.0);\n-        let mut rng = ::test::rng();\n-        for _ in 0..1000 {\n-            lnorm.sample(&mut rng);\n-            lnorm.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    #[should_panic]\n-    fn test_log_normal_invalid_sd() {\n-        LogNormal::new(10.0, -1.0);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use std::mem::size_of;\n-    use distributions::Sample;\n-    use super::Normal;\n-\n-    #[bench]\n-    fn rand_normal(b: &mut Bencher) {\n-        let mut rng = ::test::weak_rng();\n-        let mut normal = Normal::new(-2.71828, 3.14159);\n-\n-        b.iter(|| {\n-            for _ in 0..::RAND_BENCH_N {\n-                normal.sample(&mut rng);\n-            }\n-        });\n-        b.bytes = size_of::<f64>() as u64 * ::RAND_BENCH_N;\n-    }\n-}"}, {"sha": "f2f8132e5b47ba18fa6910bb06abc7bf972728cc", "filename": "src/librand/distributions/range.rs", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,227 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Generating numbers between two others.\n-\n-// this is surprisingly complicated to be both generic & correct\n-\n-use core::fmt;\n-use core::marker::Sized;\n-use Rng;\n-use distributions::{IndependentSample, Sample};\n-\n-/// Sample values uniformly between two bounds.\n-///\n-/// This gives a uniform distribution (assuming the RNG used to sample\n-/// it is itself uniform & the `SampleRange` implementation for the\n-/// given type is correct), even for edge cases like `low = 0`,\n-/// `high = 170`, for which a naive modulo operation would return\n-/// numbers less than 85 with double the probability to those greater\n-/// than 85.\n-///\n-/// Types should attempt to sample in `[low, high)`, i.e., not\n-/// including `high`, but this may be very difficult. All the\n-/// primitive integer types satisfy this property, and the float types\n-/// normally satisfy it, but rounding may mean `high` can occur.\n-pub struct Range<X> {\n-    low: X,\n-    range: X,\n-    accept_zone: X,\n-}\n-\n-impl<X: SampleRange + PartialOrd> Range<X> {\n-    /// Create a new `Range` instance that samples uniformly from\n-    /// `[low, high)`. Panics if `low >= high`.\n-    pub fn new(low: X, high: X) -> Range<X> {\n-        assert!(low < high, \"Range::new called with `low >= high`\");\n-        SampleRange::construct_range(low, high)\n-    }\n-}\n-\n-impl<Sup: SampleRange> Sample<Sup> for Range<Sup> {\n-    #[inline]\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> Sup {\n-        self.ind_sample(rng)\n-    }\n-}\n-\n-impl<Sup: SampleRange> IndependentSample<Sup> for Range<Sup> {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> Sup {\n-        SampleRange::sample_range(self, rng)\n-    }\n-}\n-\n-impl<X: fmt::Debug> fmt::Debug for Range<X> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Range\")\n-         .field(\"low\", &self.low)\n-         .field(\"range\", &self.range)\n-         .field(\"accept_zone\", &self.accept_zone)\n-         .finish()\n-    }\n-}\n-\n-/// The helper trait for types that have a sensible way to sample\n-/// uniformly between two values. This should not be used directly,\n-/// and is only to facilitate `Range`.\n-#[doc(hidden)]\n-pub trait SampleRange: Sized {\n-    /// Construct the `Range` object that `sample_range`\n-    /// requires. This should not ever be called directly, only via\n-    /// `Range::new`, which will check that `low < high`, so this\n-    /// function doesn't have to repeat the check.\n-    fn construct_range(low: Self, high: Self) -> Range<Self>;\n-\n-    /// Sample a value from the given `Range` with the given `Rng` as\n-    /// a source of randomness.\n-    fn sample_range<R: Rng>(r: &Range<Self>, rng: &mut R) -> Self;\n-}\n-\n-macro_rules! integer_impl {\n-    ($ty:ident, $unsigned:ident) => {\n-        impl SampleRange for $ty {\n-            // we play free and fast with unsigned vs signed here\n-            // (when $ty is signed), but that's fine, since the\n-            // contract of this macro is for $ty and $unsigned to be\n-            // \"bit-equal\", so casting between them is a no-op & a\n-            // bijection.\n-\n-            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n-                let range = (high as $unsigned).wrapping_sub(low as $unsigned);\n-                let unsigned_max: $unsigned = $unsigned::max_value();\n-\n-                // this is the largest number that fits into $unsigned\n-                // that `range` divides evenly, so, if we've sampled\n-                // `n` uniformly from this region, then `n % range` is\n-                // uniform in [0, range)\n-                let zone = unsigned_max - unsigned_max % range;\n-\n-                Range {\n-                    low,\n-                    range: range as $ty,\n-                    accept_zone: zone as $ty\n-                }\n-            }\n-            #[inline]\n-            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n-                loop {\n-                    // rejection sample\n-                    let v = rng.gen::<$unsigned>();\n-                    // until we find something that fits into the\n-                    // region which r.range evenly divides (this will\n-                    // be uniformly distributed)\n-                    if v < r.accept_zone as $unsigned {\n-                        // and return it, with some adjustments\n-                        return r.low.wrapping_add((v % r.range as $unsigned) as $ty);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-integer_impl! { i8, u8 }\n-integer_impl! { i16, u16 }\n-integer_impl! { i32, u32 }\n-integer_impl! { i64, u64 }\n-integer_impl! { isize, usize }\n-integer_impl! { u8, u8 }\n-integer_impl! { u16, u16 }\n-integer_impl! { u32, u32 }\n-integer_impl! { u64, u64 }\n-integer_impl! { usize, usize }\n-\n-macro_rules! float_impl {\n-    ($ty:ty) => {\n-        impl SampleRange for $ty {\n-            fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n-                Range {\n-                    low,\n-                    range: high - low,\n-                    accept_zone: 0.0 // unused\n-                }\n-            }\n-            fn sample_range<R: Rng>(r: &Range<$ty>, rng: &mut R) -> $ty {\n-                r.low + r.range * rng.gen::<$ty>()\n-            }\n-        }\n-    }\n-}\n-\n-float_impl! { f32 }\n-float_impl! { f64 }\n-\n-#[cfg(test)]\n-mod tests {\n-    use distributions::{IndependentSample, Sample};\n-    use super::Range;\n-\n-    #[should_panic]\n-    #[test]\n-    fn test_range_bad_limits_equal() {\n-        Range::new(10, 10);\n-    }\n-    #[should_panic]\n-    #[test]\n-    fn test_range_bad_limits_flipped() {\n-        Range::new(10, 5);\n-    }\n-\n-    #[test]\n-    fn test_integers() {\n-        let mut rng = ::test::rng();\n-        macro_rules! t {\n-            ($($ty:ident),*) => {{\n-                $(\n-                   let v: &[($ty, $ty)] = &[(0, 10),\n-                                            (10, 127),\n-                                            ($ty::min_value(), $ty::max_value())];\n-                   for &(low, high) in v {\n-                        let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in 0..1000 {\n-                            let v = sampler.sample(&mut rng);\n-                            assert!(low <= v && v < high);\n-                            let v = sampler.ind_sample(&mut rng);\n-                            assert!(low <= v && v < high);\n-                        }\n-                    }\n-                 )*\n-            }}\n-        }\n-        t!(i8, i16, i32, i64, isize, u8, u16, u32, u64, usize)\n-    }\n-\n-    #[test]\n-    fn test_floats() {\n-        let mut rng = ::test::rng();\n-        macro_rules! t {\n-            ($($ty:ty),*) => {{\n-                $(\n-                   let v: &[($ty, $ty)] = &[(0.0, 100.0),\n-                                            (-1e35, -1e25),\n-                                            (1e-35, 1e-25),\n-                                            (-1e35, 1e35)];\n-                   for &(low, high) in v {\n-                        let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in 0..1000 {\n-                            let v = sampler.sample(&mut rng);\n-                            assert!(low <= v && v < high);\n-                            let v = sampler.ind_sample(&mut rng);\n-                            assert!(low <= v && v < high);\n-                        }\n-                    }\n-                 )*\n-            }}\n-        }\n-\n-        t!(f32, f64)\n-    }\n-\n-}"}, {"sha": "7dfb0f131a2c50bde150dbc0ebcee01859b49c53", "filename": "src/librand/distributions/ziggurat_tables.rs", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fziggurat_tables.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,284 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tables for distributions which are sampled using the ziggurat\n-// algorithm. Autogenerated by `ziggurat_tables.py`.\n-\n-pub type ZigTable = &'static [f64; 257];\n-pub const ZIG_NORM_R: f64 = 3.654152885361008796;\n-#[rustfmt_skip]\n-pub static ZIG_NORM_X: [f64; 257] =\n-    [3.910757959537090045, 3.654152885361008796, 3.449278298560964462, 3.320244733839166074,\n-     3.224575052047029100, 3.147889289517149969, 3.083526132001233044, 3.027837791768635434,\n-     2.978603279880844834, 2.934366867207854224, 2.894121053612348060, 2.857138730872132548,\n-     2.822877396825325125, 2.790921174000785765, 2.760944005278822555, 2.732685359042827056,\n-     2.705933656121858100, 2.680514643284522158, 2.656283037575502437, 2.633116393630324570,\n-     2.610910518487548515, 2.589575986706995181, 2.569035452680536569, 2.549221550323460761,\n-     2.530075232158516929, 2.511544441625342294, 2.493583041269680667, 2.476149939669143318,\n-     2.459208374333311298, 2.442725318198956774, 2.426670984935725972, 2.411018413899685520,\n-     2.395743119780480601, 2.380822795170626005, 2.366237056715818632, 2.351967227377659952,\n-     2.337996148795031370, 2.324308018869623016, 2.310888250599850036, 2.297723348901329565,\n-     2.284800802722946056, 2.272108990226823888, 2.259637095172217780, 2.247375032945807760,\n-     2.235313384928327984, 2.223443340090905718, 2.211756642882544366, 2.200245546609647995,\n-     2.188902771624720689, 2.177721467738641614, 2.166695180352645966, 2.155817819875063268,\n-     2.145083634046203613, 2.134487182844320152, 2.124023315687815661, 2.113687150684933957,\n-     2.103474055713146829, 2.093379631137050279, 2.083399693996551783, 2.073530263516978778,\n-     2.063767547809956415, 2.054107931648864849, 2.044547965215732788, 2.035084353727808715,\n-     2.025713947862032960, 2.016433734904371722, 2.007240830558684852, 1.998132471356564244,\n-     1.989106007615571325, 1.980158896898598364, 1.971288697931769640, 1.962493064942461896,\n-     1.953769742382734043, 1.945116560006753925, 1.936531428273758904, 1.928012334050718257,\n-     1.919557336591228847, 1.911164563769282232, 1.902832208548446369, 1.894558525668710081,\n-     1.886341828534776388, 1.878180486290977669, 1.870072921069236838, 1.862017605397632281,\n-     1.854013059758148119, 1.846057850283119750, 1.838150586580728607, 1.830289919680666566,\n-     1.822474540091783224, 1.814703175964167636, 1.806974591348693426, 1.799287584547580199,\n-     1.791640986550010028, 1.784033659547276329, 1.776464495522344977, 1.768932414909077933,\n-     1.761436365316706665, 1.753975320315455111, 1.746548278279492994, 1.739154261283669012,\n-     1.731792314050707216, 1.724461502945775715, 1.717160915015540690, 1.709889657069006086,\n-     1.702646854797613907, 1.695431651932238548, 1.688243209434858727, 1.681080704722823338,\n-     1.673943330923760353, 1.666830296159286684, 1.659740822855789499, 1.652674147080648526,\n-     1.645629517902360339, 1.638606196773111146, 1.631603456932422036, 1.624620582830568427,\n-     1.617656869570534228, 1.610711622367333673, 1.603784156023583041, 1.596873794420261339,\n-     1.589979870021648534, 1.583101723393471438, 1.576238702733332886, 1.569390163412534456,\n-     1.562555467528439657, 1.555733983466554893, 1.548925085471535512, 1.542128153226347553,\n-     1.535342571438843118, 1.528567729435024614, 1.521803020758293101, 1.515047842773992404,\n-     1.508301596278571965, 1.501563685112706548, 1.494833515777718391, 1.488110497054654369,\n-     1.481394039625375747, 1.474683555695025516, 1.467978458615230908, 1.461278162507407830,\n-     1.454582081885523293, 1.447889631277669675, 1.441200224845798017, 1.434513276002946425,\n-     1.427828197027290358, 1.421144398672323117, 1.414461289772464658, 1.407778276843371534,\n-     1.401094763676202559, 1.394410150925071257, 1.387723835686884621, 1.381035211072741964,\n-     1.374343665770030531, 1.367648583594317957, 1.360949343030101844, 1.354245316759430606,\n-     1.347535871177359290, 1.340820365893152122, 1.334098153216083604, 1.327368577624624679,\n-     1.320630975217730096, 1.313884673146868964, 1.307128989027353860, 1.300363230327433728,\n-     1.293586693733517645, 1.286798664489786415, 1.279998415710333237, 1.273185207661843732,\n-     1.266358287014688333, 1.259516886060144225, 1.252660221891297887, 1.245787495544997903,\n-     1.238897891102027415, 1.231990574742445110, 1.225064693752808020, 1.218119375481726552,\n-     1.211153726239911244, 1.204166830140560140, 1.197157747875585931, 1.190125515422801650,\n-     1.183069142678760732, 1.175987612011489825, 1.168879876726833800, 1.161744859441574240,\n-     1.154581450355851802, 1.147388505416733873, 1.140164844363995789, 1.132909248648336975,\n-     1.125620459211294389, 1.118297174115062909, 1.110938046009249502, 1.103541679420268151,\n-     1.096106627847603487, 1.088631390649514197, 1.081114409698889389, 1.073554065787871714,\n-     1.065948674757506653, 1.058296483326006454, 1.050595664586207123, 1.042844313139370538,\n-     1.035040439828605274, 1.027181966030751292, 1.019266717460529215, 1.011292417434978441,\n-     1.003256679539591412, 0.995156999629943084, 0.986990747093846266, 0.978755155288937750,\n-     0.970447311058864615, 0.962064143217605250, 0.953602409875572654, 0.945058684462571130,\n-     0.936429340280896860, 0.927710533396234771, 0.918898183643734989, 0.909987953490768997,\n-     0.900975224455174528, 0.891855070726792376, 0.882622229578910122, 0.873271068082494550,\n-     0.863795545546826915, 0.854189171001560554, 0.844444954902423661, 0.834555354079518752,\n-     0.824512208745288633, 0.814306670128064347, 0.803929116982664893, 0.793369058833152785,\n-     0.782615023299588763, 0.771654424216739354, 0.760473406422083165, 0.749056662009581653,\n-     0.737387211425838629, 0.725446140901303549, 0.713212285182022732, 0.700661841097584448,\n-     0.687767892786257717, 0.674499822827436479, 0.660822574234205984, 0.646695714884388928,\n-     0.632072236375024632, 0.616896989996235545, 0.601104617743940417, 0.584616766093722262,\n-     0.567338257040473026, 0.549151702313026790, 0.529909720646495108, 0.509423329585933393,\n-     0.487443966121754335, 0.463634336771763245, 0.437518402186662658, 0.408389134588000746,\n-     0.375121332850465727, 0.335737519180459465, 0.286174591747260509, 0.215241895913273806,\n-     0.000000000000000000];\n-#[rustfmt_skip]\n-pub static ZIG_NORM_F: [f64; 257] =\n-    [0.000477467764586655, 0.001260285930498598, 0.002609072746106363, 0.004037972593371872,\n-     0.005522403299264754, 0.007050875471392110, 0.008616582769422917, 0.010214971439731100,\n-     0.011842757857943104, 0.013497450601780807, 0.015177088307982072, 0.016880083152595839,\n-     0.018605121275783350, 0.020351096230109354, 0.022117062707379922, 0.023902203305873237,\n-     0.025705804008632656, 0.027527235669693315, 0.029365939758230111, 0.031221417192023690,\n-     0.033093219458688698, 0.034980941461833073, 0.036884215688691151, 0.038802707404656918,\n-     0.040736110656078753, 0.042684144916619378, 0.044646552251446536, 0.046623094902089664,\n-     0.048613553216035145, 0.050617723861121788, 0.052635418276973649, 0.054666461325077916,\n-     0.056710690106399467, 0.058767952921137984, 0.060838108349751806, 0.062921024437977854,\n-     0.065016577971470438, 0.067124653828023989, 0.069245144397250269, 0.071377949059141965,\n-     0.073522973714240991, 0.075680130359194964, 0.077849336702372207, 0.080030515814947509,\n-     0.082223595813495684, 0.084428509570654661, 0.086645194450867782, 0.088873592068594229,\n-     0.091113648066700734, 0.093365311913026619, 0.095628536713353335, 0.097903279039215627,\n-     0.100189498769172020, 0.102487158942306270, 0.104796225622867056, 0.107116667775072880,\n-     0.109448457147210021, 0.111791568164245583, 0.114145977828255210, 0.116511665626037014,\n-     0.118888613443345698, 0.121276805485235437, 0.123676228202051403, 0.126086870220650349,\n-     0.128508722280473636, 0.130941777174128166, 0.133386029692162844, 0.135841476571757352,\n-     0.138308116449064322, 0.140785949814968309, 0.143274978974047118, 0.145775208006537926,\n-     0.148286642733128721, 0.150809290682410169, 0.153343161060837674, 0.155888264725064563,\n-     0.158444614156520225, 0.161012223438117663, 0.163591108232982951, 0.166181285765110071,\n-     0.168782774801850333, 0.171395595638155623, 0.174019770082499359, 0.176655321444406654,\n-     0.179302274523530397, 0.181960655600216487, 0.184630492427504539, 0.187311814224516926,\n-     0.190004651671193070, 0.192709036904328807, 0.195425003514885592, 0.198152586546538112,\n-     0.200891822495431333, 0.203642749311121501, 0.206405406398679298, 0.209179834621935651,\n-     0.211966076307852941, 0.214764175252008499, 0.217574176725178370, 0.220396127481011589,\n-     0.223230075764789593, 0.226076071323264877, 0.228934165415577484, 0.231804410825248525,\n-     0.234686861873252689, 0.237581574432173676, 0.240488605941449107, 0.243408015423711988,\n-     0.246339863502238771, 0.249284212419516704, 0.252241126056943765, 0.255210669955677150,\n-     0.258192911338648023, 0.261187919133763713, 0.264195763998317568, 0.267216518344631837,\n-     0.270250256366959984, 0.273297054069675804, 0.276356989296781264, 0.279430141762765316,\n-     0.282516593084849388, 0.285616426816658109, 0.288729728483353931, 0.291856585618280984,\n-     0.294997087801162572, 0.298151326697901342, 0.301319396102034120, 0.304501391977896274,\n-     0.307697412505553769, 0.310907558127563710, 0.314131931597630143, 0.317370638031222396,\n-     0.320623784958230129, 0.323891482377732021, 0.327173842814958593, 0.330470981380537099,\n-     0.333783015832108509, 0.337110066638412809, 0.340452257045945450, 0.343809713148291340,\n-     0.347182563958251478, 0.350570941482881204, 0.353974980801569250, 0.357394820147290515,\n-     0.360830600991175754, 0.364282468130549597, 0.367750569780596226, 0.371235057669821344,\n-     0.374736087139491414, 0.378253817247238111, 0.381788410875031348, 0.385340034841733958,\n-     0.388908860020464597, 0.392495061461010764, 0.396098818517547080, 0.399720314981931668,\n-     0.403359739222868885, 0.407017284331247953, 0.410693148271983222, 0.414387534042706784,\n-     0.418100649839684591, 0.421832709231353298, 0.425583931339900579, 0.429354541031341519,\n-     0.433144769114574058, 0.436954852549929273, 0.440785034667769915, 0.444635565397727750,\n-     0.448506701509214067, 0.452398706863882505, 0.456311852680773566, 0.460246417814923481,\n-     0.464202689050278838, 0.468180961407822172, 0.472181538469883255, 0.476204732721683788,\n-     0.480250865911249714, 0.484320269428911598, 0.488413284707712059, 0.492530263646148658,\n-     0.496671569054796314, 0.500837575128482149, 0.505028667945828791, 0.509245245998136142,\n-     0.513487720749743026, 0.517756517232200619, 0.522052074674794864, 0.526374847174186700,\n-     0.530725304406193921, 0.535103932383019565, 0.539511234259544614, 0.543947731192649941,\n-     0.548413963257921133, 0.552910490428519918, 0.557437893621486324, 0.561996775817277916,\n-     0.566587763258951771, 0.571211506738074970, 0.575868682975210544, 0.580559996103683473,\n-     0.585286179266300333, 0.590047996335791969, 0.594846243770991268, 0.599681752622167719,\n-     0.604555390700549533, 0.609468064928895381, 0.614420723892076803, 0.619414360609039205,\n-     0.624450015550274240, 0.629528779928128279, 0.634651799290960050, 0.639820277456438991,\n-     0.645035480824251883, 0.650298743114294586, 0.655611470583224665, 0.660975147780241357,\n-     0.666391343912380640, 0.671861719900766374, 0.677388036222513090, 0.682972161648791376,\n-     0.688616083008527058, 0.694321916130032579, 0.700091918140490099, 0.705928501336797409,\n-     0.711834248882358467, 0.717811932634901395, 0.723864533472881599, 0.729995264565802437,\n-     0.736207598131266683, 0.742505296344636245, 0.748892447223726720, 0.755373506511754500,\n-     0.761953346841546475, 0.768637315803334831, 0.775431304986138326, 0.782341832659861902,\n-     0.789376143571198563, 0.796542330428254619, 0.803849483176389490, 0.811307874318219935,\n-     0.818929191609414797, 0.826726833952094231, 0.834716292992930375, 0.842915653118441077,\n-     0.851346258465123684, 0.860033621203008636, 0.869008688043793165, 0.878309655816146839,\n-     0.887984660763399880, 0.898095921906304051, 0.908726440060562912, 0.919991505048360247,\n-     0.932060075968990209, 0.945198953453078028, 0.959879091812415930, 0.977101701282731328,\n-     1.000000000000000000];\n-pub const ZIG_EXP_R: f64 = 7.697117470131050077;\n-#[rustfmt_skip]\n-pub static ZIG_EXP_X: [f64; 257] =\n-    [8.697117470131052741, 7.697117470131050077, 6.941033629377212577, 6.478378493832569696,\n-     6.144164665772472667, 5.882144315795399869, 5.666410167454033697, 5.482890627526062488,\n-     5.323090505754398016, 5.181487281301500047, 5.054288489981304089, 4.938777085901250530,\n-     4.832939741025112035, 4.735242996601741083, 4.644491885420085175, 4.559737061707351380,\n-     4.480211746528421912, 4.405287693473573185, 4.334443680317273007, 4.267242480277365857,\n-     4.203313713735184365, 4.142340865664051464, 4.084051310408297830, 4.028208544647936762,\n-     3.974606066673788796, 3.923062500135489739, 3.873417670399509127, 3.825529418522336744,\n-     3.779270992411667862, 3.734528894039797375, 3.691201090237418825, 3.649195515760853770,\n-     3.608428813128909507, 3.568825265648337020, 3.530315889129343354, 3.492837654774059608,\n-     3.456332821132760191, 3.420748357251119920, 3.386035442460300970, 3.352149030900109405,\n-     3.319047470970748037, 3.286692171599068679, 3.255047308570449882, 3.224079565286264160,\n-     3.193757903212240290, 3.164053358025972873, 3.134938858084440394, 3.106389062339824481,\n-     3.078380215254090224, 3.050890016615455114, 3.023897504455676621, 2.997382949516130601,\n-     2.971327759921089662, 2.945714394895045718, 2.920526286512740821, 2.895747768600141825,\n-     2.871364012015536371, 2.847360965635188812, 2.823725302450035279, 2.800444370250737780,\n-     2.777506146439756574, 2.754899196562344610, 2.732612636194700073, 2.710636095867928752,\n-     2.688959688741803689, 2.667573980773266573, 2.646469963151809157, 2.625639026797788489,\n-     2.605072938740835564, 2.584763820214140750, 2.564704126316905253, 2.544886627111869970,\n-     2.525304390037828028, 2.505950763528594027, 2.486819361740209455, 2.467904050297364815,\n-     2.449198932978249754, 2.430698339264419694, 2.412396812688870629, 2.394289099921457886,\n-     2.376370140536140596, 2.358635057409337321, 2.341079147703034380, 2.323697874390196372,\n-     2.306486858283579799, 2.289441870532269441, 2.272558825553154804, 2.255833774367219213,\n-     2.239262898312909034, 2.222842503111036816, 2.206569013257663858, 2.190438966723220027,\n-     2.174449009937774679, 2.158595893043885994, 2.142876465399842001, 2.127287671317368289,\n-     2.111826546019042183, 2.096490211801715020, 2.081275874393225145, 2.066180819490575526,\n-     2.051202409468584786, 2.036338080248769611, 2.021585338318926173, 2.006941757894518563,\n-     1.992404978213576650, 1.977972700957360441, 1.963642687789548313, 1.949412758007184943,\n-     1.935280786297051359, 1.921244700591528076, 1.907302480018387536, 1.893452152939308242,\n-     1.879691795072211180, 1.866019527692827973, 1.852433515911175554, 1.838931967018879954,\n-     1.825513128903519799, 1.812175288526390649, 1.798916770460290859, 1.785735935484126014,\n-     1.772631179231305643, 1.759600930889074766, 1.746643651946074405, 1.733757834985571566,\n-     1.720942002521935299, 1.708194705878057773, 1.695514524101537912, 1.682900062917553896,\n-     1.670349953716452118, 1.657862852574172763, 1.645437439303723659, 1.633072416535991334,\n-     1.620766508828257901, 1.608518461798858379, 1.596327041286483395, 1.584191032532688892,\n-     1.572109239386229707, 1.560080483527888084, 1.548103603714513499, 1.536177455041032092,\n-     1.524300908219226258, 1.512472848872117082, 1.500692176842816750, 1.488957805516746058,\n-     1.477268661156133867, 1.465623682245745352, 1.454021818848793446, 1.442462031972012504,\n-     1.430943292938879674, 1.419464582769983219, 1.408024891569535697, 1.396623217917042137,\n-     1.385258568263121992, 1.373929956328490576, 1.362636402505086775, 1.351376933258335189,\n-     1.340150580529504643, 1.328956381137116560, 1.317793376176324749, 1.306660610415174117,\n-     1.295557131686601027, 1.284481990275012642, 1.273434238296241139, 1.262412929069615330,\n-     1.251417116480852521, 1.240445854334406572, 1.229498195693849105, 1.218573192208790124,\n-     1.207669893426761121, 1.196787346088403092, 1.185924593404202199, 1.175080674310911677,\n-     1.164254622705678921, 1.153445466655774743, 1.142652227581672841, 1.131873919411078511,\n-     1.121109547701330200, 1.110358108727411031, 1.099618588532597308, 1.088889961938546813,\n-     1.078171191511372307, 1.067461226479967662, 1.056759001602551429, 1.046063435977044209,\n-     1.035373431790528542, 1.024687873002617211, 1.014005623957096480, 1.003325527915696735,\n-     0.992646405507275897, 0.981967053085062602, 0.971286240983903260, 0.960602711668666509,\n-     0.949915177764075969, 0.939222319955262286, 0.928522784747210395, 0.917815182070044311,\n-     0.907098082715690257, 0.896370015589889935, 0.885629464761751528, 0.874874866291025066,\n-     0.864104604811004484, 0.853317009842373353, 0.842510351810368485, 0.831682837734273206,\n-     0.820832606554411814, 0.809957724057418282, 0.799056177355487174, 0.788125868869492430,\n-     0.777164609759129710, 0.766170112735434672, 0.755139984181982249, 0.744071715500508102,\n-     0.732962673584365398, 0.721810090308756203, 0.710611050909655040, 0.699362481103231959,\n-     0.688061132773747808, 0.676703568029522584, 0.665286141392677943, 0.653804979847664947,\n-     0.642255960424536365, 0.630634684933490286, 0.618936451394876075, 0.607156221620300030,\n-     0.595288584291502887, 0.583327712748769489, 0.571267316532588332, 0.559100585511540626,\n-     0.546820125163310577, 0.534417881237165604, 0.521885051592135052, 0.509211982443654398,\n-     0.496388045518671162, 0.483401491653461857, 0.470239275082169006, 0.456886840931420235,\n-     0.443327866073552401, 0.429543940225410703, 0.415514169600356364, 0.401214678896277765,\n-     0.386617977941119573, 0.371692145329917234, 0.356399760258393816, 0.340696481064849122,\n-     0.324529117016909452, 0.307832954674932158, 0.290527955491230394, 0.272513185478464703,\n-     0.253658363385912022, 0.233790483059674731, 0.212671510630966620, 0.189958689622431842,\n-     0.165127622564187282, 0.137304980940012589, 0.104838507565818778, 0.063852163815001570,\n-     0.000000000000000000];\n-#[rustfmt_skip]\n-pub static ZIG_EXP_F: [f64; 257] =\n-    [0.000167066692307963, 0.000454134353841497, 0.000967269282327174, 0.001536299780301573,\n-     0.002145967743718907, 0.002788798793574076, 0.003460264777836904, 0.004157295120833797,\n-     0.004877655983542396, 0.005619642207205489, 0.006381905937319183, 0.007163353183634991,\n-     0.007963077438017043, 0.008780314985808977, 0.009614413642502212, 0.010464810181029981,\n-     0.011331013597834600, 0.012212592426255378, 0.013109164931254991, 0.014020391403181943,\n-     0.014945968011691148, 0.015885621839973156, 0.016839106826039941, 0.017806200410911355,\n-     0.018786700744696024, 0.019780424338009740, 0.020787204072578114, 0.021806887504283581,\n-     0.022839335406385240, 0.023884420511558174, 0.024942026419731787, 0.026012046645134221,\n-     0.027094383780955803, 0.028188948763978646, 0.029295660224637411, 0.030414443910466622,\n-     0.031545232172893622, 0.032687963508959555, 0.033842582150874358, 0.035009037697397431,\n-     0.036187284781931443, 0.037377282772959382, 0.038578995503074871, 0.039792391023374139,\n-     0.041017441380414840, 0.042254122413316254, 0.043502413568888197, 0.044762297732943289,\n-     0.046033761076175184, 0.047316792913181561, 0.048611385573379504, 0.049917534282706379,\n-     0.051235237055126281, 0.052564494593071685, 0.053905310196046080, 0.055257689676697030,\n-     0.056621641283742870, 0.057997175631200659, 0.059384305633420280, 0.060783046445479660,\n-     0.062193415408541036, 0.063615431999807376, 0.065049117786753805, 0.066494496385339816,\n-     0.067951593421936643, 0.069420436498728783, 0.070901055162371843, 0.072393480875708752,\n-     0.073897746992364746, 0.075413888734058410, 0.076941943170480517, 0.078481949201606435,\n-     0.080033947542319905, 0.081597980709237419, 0.083174093009632397, 0.084762330532368146,\n-     0.086362741140756927, 0.087975374467270231, 0.089600281910032886, 0.091237516631040197,\n-     0.092887133556043569, 0.094549189376055873, 0.096223742550432825, 0.097910853311492213,\n-     0.099610583670637132, 0.101322997425953631, 0.103048160171257702, 0.104786139306570145,\n-     0.106537004050001632, 0.108300825451033755, 0.110077676405185357, 0.111867631670056283,\n-     0.113670767882744286, 0.115487163578633506, 0.117316899211555525, 0.119160057175327641,\n-     0.121016721826674792, 0.122886979509545108, 0.124770918580830933, 0.126668629437510671,\n-     0.128580204545228199, 0.130505738468330773, 0.132445327901387494, 0.134399071702213602,\n-     0.136367070926428829, 0.138349428863580176, 0.140346251074862399, 0.142357645432472146,\n-     0.144383722160634720, 0.146424593878344889, 0.148480375643866735, 0.150551185001039839,\n-     0.152637142027442801, 0.154738369384468027, 0.156854992369365148, 0.158987138969314129,\n-     0.161134939917591952, 0.163298528751901734, 0.165478041874935922, 0.167673618617250081,\n-     0.169885401302527550, 0.172113535315319977, 0.174358169171353411, 0.176619454590494829,\n-     0.178897546572478278, 0.181192603475496261, 0.183504787097767436, 0.185834262762197083,\n-     0.188181199404254262, 0.190545769663195363, 0.192928149976771296, 0.195328520679563189,\n-     0.197747066105098818, 0.200183974691911210, 0.202639439093708962, 0.205113656293837654,\n-     0.207606827724221982, 0.210119159388988230, 0.212650861992978224, 0.215202151075378628,\n-     0.217773247148700472, 0.220364375843359439, 0.222975768058120111, 0.225607660116683956,\n-     0.228260293930716618, 0.230933917169627356, 0.233628783437433291, 0.236345152457059560,\n-     0.239083290262449094, 0.241843469398877131, 0.244625969131892024, 0.247431075665327543,\n-     0.250259082368862240, 0.253110290015629402, 0.255985007030415324, 0.258883549749016173,\n-     0.261806242689362922, 0.264753418835062149, 0.267725419932044739, 0.270722596799059967,\n-     0.273745309652802915, 0.276793928448517301, 0.279868833236972869, 0.282970414538780746,\n-     0.286099073737076826, 0.289255223489677693, 0.292439288161892630, 0.295651704281261252,\n-     0.298892921015581847, 0.302163400675693528, 0.305463619244590256, 0.308794066934560185,\n-     0.312155248774179606, 0.315547685227128949, 0.318971912844957239, 0.322428484956089223,\n-     0.325917972393556354, 0.329440964264136438, 0.332998068761809096, 0.336589914028677717,\n-     0.340217149066780189, 0.343880444704502575, 0.347580494621637148, 0.351318016437483449,\n-     0.355093752866787626, 0.358908472948750001, 0.362762973354817997, 0.366658079781514379,\n-     0.370594648435146223, 0.374573567615902381, 0.378595759409581067, 0.382662181496010056,\n-     0.386773829084137932, 0.390931736984797384, 0.395136981833290435, 0.399390684475231350,\n-     0.403694012530530555, 0.408048183152032673, 0.412454465997161457, 0.416914186433003209,\n-     0.421428728997616908, 0.425999541143034677, 0.430628137288459167, 0.435316103215636907,\n-     0.440065100842354173, 0.444876873414548846, 0.449753251162755330, 0.454696157474615836,\n-     0.459707615642138023, 0.464789756250426511, 0.469944825283960310, 0.475175193037377708,\n-     0.480483363930454543, 0.485871987341885248, 0.491343869594032867, 0.496901987241549881,\n-     0.502549501841348056, 0.508289776410643213, 0.514126393814748894, 0.520063177368233931,\n-     0.526104213983620062, 0.532253880263043655, 0.538516872002862246, 0.544898237672440056,\n-     0.551403416540641733, 0.558038282262587892, 0.564809192912400615, 0.571723048664826150,\n-     0.578787358602845359, 0.586010318477268366, 0.593400901691733762, 0.600968966365232560,\n-     0.608725382079622346, 0.616682180915207878, 0.624852738703666200, 0.633251994214366398,\n-     0.641896716427266423, 0.650805833414571433, 0.660000841079000145, 0.669506316731925177,\n-     0.679350572264765806, 0.689566496117078431, 0.700192655082788606, 0.711274760805076456,\n-     0.722867659593572465, 0.735038092431424039, 0.747868621985195658, 0.761463388849896838,\n-     0.775956852040116218, 0.791527636972496285, 0.808421651523009044, 0.826993296643051101,\n-     0.847785500623990496, 0.871704332381204705, 0.900469929925747703, 0.938143680862176477,\n-     1.000000000000000000];"}, {"sha": "17ecf79daeebdc4925f9ccb0a790cdcadbfe8ba1", "filename": "src/librand/isaac.rs", "status": "removed", "additions": 0, "deletions": 746, "changes": 746, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,746 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The ISAAC random number generator.\n-\n-#![allow(non_camel_case_types)]\n-\n-use core::fmt;\n-use core::slice;\n-use core::iter::repeat;\n-use core::num::Wrapping as w;\n-\n-use {Rand, Rng, SeedableRng};\n-\n-type w32 = w<u32>;\n-type w64 = w<u64>;\n-\n-const RAND_SIZE_LEN: usize = 8;\n-const RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n-const RAND_SIZE_USIZE: usize = 1 << RAND_SIZE_LEN;\n-\n-/// A random number generator that uses the ISAAC algorithm[1].\n-///\n-/// The ISAAC algorithm is generally accepted as suitable for\n-/// cryptographic purposes, but this implementation has not be\n-/// verified as such. Prefer a generator like `OsRng` that defers to\n-/// the operating system for cases that need high security.\n-///\n-/// [1]: Bob Jenkins, [*ISAAC: A fast cryptographic random number\n-/// generator*](http://www.burtleburtle.net/bob/rand/isaacafa.html)\n-#[derive(Copy)]\n-pub struct IsaacRng {\n-    cnt: u32,\n-    rsl: [w32; RAND_SIZE_USIZE],\n-    mem: [w32; RAND_SIZE_USIZE],\n-    a: w32,\n-    b: w32,\n-    c: w32,\n-}\n-\n-impl fmt::Debug for IsaacRng {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"IsaacRng\")\n-         .field(\"cnt\", &self.cnt)\n-         .field(\"rsl\", &self.rsl.iter())\n-         .field(\"mem\", &self.mem.iter())\n-         .field(\"a\", &self.a)\n-         .field(\"b\", &self.b)\n-         .field(\"c\", &self.c)\n-         .finish()\n-    }\n-}\n-\n-static EMPTY: IsaacRng = IsaacRng {\n-    cnt: 0,\n-    rsl: [w(0); RAND_SIZE_USIZE],\n-    mem: [w(0); RAND_SIZE_USIZE],\n-    a: w(0),\n-    b: w(0),\n-    c: w(0),\n-};\n-\n-impl IsaacRng {\n-    /// Create an ISAAC random number generator using the default\n-    /// fixed seed.\n-    pub fn new_unseeded() -> IsaacRng {\n-        let mut rng = EMPTY;\n-        rng.init(false);\n-        rng\n-    }\n-\n-    /// Initializes `self`. If `use_rsl` is true, then use the current value\n-    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n-    /// randomly).\n-    fn init(&mut self, use_rsl: bool) {\n-        let mut a = w(0x9e3779b9);\n-        let mut b = a;\n-        let mut c = a;\n-        let mut d = a;\n-        let mut e = a;\n-        let mut f = a;\n-        let mut g = a;\n-        let mut h = a;\n-\n-        macro_rules! mix {\n-            () => {{\n-                a = a ^ (b << 11);\n-                d = d + a;\n-                b = b + c;\n-\n-                b = b ^ (c >> 2);\n-                e = e + b;\n-                c = c + d;\n-\n-                c = c ^ (d << 8);\n-                f = f + c;\n-                d = d + e;\n-\n-                d = d ^ (e >> 16);\n-                g = g + d;\n-                e = e + f;\n-\n-                e = e ^ (f << 10);\n-                h = h + e;\n-                f = f + g;\n-\n-                f = f ^ (g >> 4);\n-                a = a + f;\n-                g = g + h;\n-\n-                g = g ^ (h << 8);\n-                b = b + g;\n-                h = h + a;\n-\n-                h = h ^ (a >> 9);\n-                c = c + h;\n-                a = a + b;\n-            }}\n-        }\n-\n-        for _ in 0..4 {\n-            mix!();\n-        }\n-\n-        if use_rsl {\n-            macro_rules! memloop {\n-                ($arr:expr) => {{\n-                    for i in (0..RAND_SIZE_USIZE).step_by(8) {\n-                        a = a + $arr[i];\n-                        b = b + $arr[i + 1];\n-                        c = c + $arr[i + 2];\n-                        d = d + $arr[i + 3];\n-                        e = e + $arr[i + 4];\n-                        f = f + $arr[i + 5];\n-                        g = g + $arr[i + 6];\n-                        h = h + $arr[i + 7];\n-                        mix!();\n-                        self.mem[i] = a;\n-                        self.mem[i + 1] = b;\n-                        self.mem[i + 2] = c;\n-                        self.mem[i + 3] = d;\n-                        self.mem[i + 4] = e;\n-                        self.mem[i + 5] = f;\n-                        self.mem[i + 6] = g;\n-                        self.mem[i + 7] = h;\n-                    }\n-                }}\n-            }\n-\n-            memloop!(self.rsl);\n-            memloop!(self.mem);\n-        } else {\n-            for i in (0..RAND_SIZE_USIZE).step_by(8) {\n-                mix!();\n-                self.mem[i] = a;\n-                self.mem[i + 1] = b;\n-                self.mem[i + 2] = c;\n-                self.mem[i + 3] = d;\n-                self.mem[i + 4] = e;\n-                self.mem[i + 5] = f;\n-                self.mem[i + 6] = g;\n-                self.mem[i + 7] = h;\n-            }\n-        }\n-\n-        self.isaac();\n-    }\n-\n-    /// Refills the output buffer (`self.rsl`)\n-    #[inline]\n-    fn isaac(&mut self) {\n-        self.c = self.c + w(1);\n-        // abbreviations\n-        let mut a = self.a;\n-        let mut b = self.b + self.c;\n-\n-        const MIDPOINT: usize = RAND_SIZE_USIZE / 2;\n-\n-        macro_rules! ind {\n-            ($x:expr) => (self.mem[($x >> 2).0 as usize & (RAND_SIZE_USIZE - 1)] )\n-        }\n-\n-        let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        for &(mr_offset, m2_offset) in &r {\n-\n-            macro_rules! rngstepp {\n-                ($j:expr, $shift:expr) => {{\n-                    let base = $j;\n-                    let mix = a << $shift;\n-\n-                    let x = self.mem[base  + mr_offset];\n-                    a = (a ^ mix) + self.mem[base + m2_offset];\n-                    let y = ind!(x) + a + b;\n-                    self.mem[base + mr_offset] = y;\n-\n-                    b = ind!(y >> RAND_SIZE_LEN) + x;\n-                    self.rsl[base + mr_offset] = b;\n-                }}\n-            }\n-\n-            macro_rules! rngstepn {\n-                ($j:expr, $shift:expr) => {{\n-                    let base = $j;\n-                    let mix = a >> $shift;\n-\n-                    let x = self.mem[base  + mr_offset];\n-                    a = (a ^ mix) + self.mem[base + m2_offset];\n-                    let y = ind!(x) + a + b;\n-                    self.mem[base + mr_offset] = y;\n-\n-                    b = ind!(y >> RAND_SIZE_LEN) + x;\n-                    self.rsl[base + mr_offset] = b;\n-                }}\n-            }\n-\n-            for i in (0..MIDPOINT).step_by(4) {\n-                rngstepp!(i + 0, 13);\n-                rngstepn!(i + 1, 6);\n-                rngstepp!(i + 2, 2);\n-                rngstepn!(i + 3, 16);\n-            }\n-        }\n-\n-        self.a = a;\n-        self.b = b;\n-        self.cnt = RAND_SIZE;\n-    }\n-}\n-\n-// Cannot be derived because [u32; 256] does not implement Clone\n-impl Clone for IsaacRng {\n-    fn clone(&self) -> IsaacRng {\n-        *self\n-    }\n-}\n-\n-impl Rng for IsaacRng {\n-    #[inline]\n-    fn next_u32(&mut self) -> u32 {\n-        if self.cnt == 0 {\n-            // make some more numbers\n-            self.isaac();\n-        }\n-        self.cnt -= 1;\n-\n-        // self.cnt is at most RAND_SIZE, but that is before the\n-        // subtraction above. We want to index without bounds\n-        // checking, but this could lead to incorrect code if someone\n-        // misrefactors, so we check, sometimes.\n-        //\n-        // (Changes here should be reflected in Isaac64Rng.next_u64.)\n-        debug_assert!(self.cnt < RAND_SIZE);\n-\n-        // (the % is cheaply telling the optimiser that we're always\n-        // in bounds, without unsafe. NB. this is a power of two, so\n-        // it optimises to a bitwise mask).\n-        self.rsl[(self.cnt % RAND_SIZE) as usize].0\n-    }\n-}\n-\n-impl<'a> SeedableRng<&'a [u32]> for IsaacRng {\n-    fn reseed(&mut self, seed: &'a [u32]) {\n-        // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n-        // - 1], 0, 0, ...], to fill rng.rsl.\n-        let seed_iter = seed.iter().cloned().chain(repeat(0));\n-\n-        for (rsl_elem, seed_elem) in self.rsl.iter_mut().zip(seed_iter) {\n-            *rsl_elem = w(seed_elem);\n-        }\n-        self.cnt = 0;\n-        self.a = w(0);\n-        self.b = w(0);\n-        self.c = w(0);\n-\n-        self.init(true);\n-    }\n-\n-    /// Create an ISAAC random number generator with a seed. This can\n-    /// be any length, although the maximum number of elements used is\n-    /// 256 and any more will be silently ignored. A generator\n-    /// constructed with a given seed will generate the same sequence\n-    /// of values as all other generators constructed with that seed.\n-    fn from_seed(seed: &'a [u32]) -> IsaacRng {\n-        let mut rng = EMPTY;\n-        rng.reseed(seed);\n-        rng\n-    }\n-}\n-\n-impl Rand for IsaacRng {\n-    fn rand<R: Rng>(other: &mut R) -> IsaacRng {\n-        let mut ret = EMPTY;\n-        unsafe {\n-            let ptr = ret.rsl.as_mut_ptr() as *mut u8;\n-\n-            let slice = slice::from_raw_parts_mut(ptr, RAND_SIZE_USIZE * 4);\n-            other.fill_bytes(slice);\n-        }\n-        ret.cnt = 0;\n-        ret.a = w(0);\n-        ret.b = w(0);\n-        ret.c = w(0);\n-\n-        ret.init(true);\n-        return ret;\n-    }\n-}\n-\n-const RAND_SIZE_64_LEN: usize = 8;\n-const RAND_SIZE_64: usize = 1 << RAND_SIZE_64_LEN;\n-\n-/// A random number generator that uses ISAAC-64[1], the 64-bit\n-/// variant of the ISAAC algorithm.\n-///\n-/// The ISAAC algorithm is generally accepted as suitable for\n-/// cryptographic purposes, but this implementation has not be\n-/// verified as such. Prefer a generator like `OsRng` that defers to\n-/// the operating system for cases that need high security.\n-///\n-/// [1]: Bob Jenkins, [*ISAAC: A fast cryptographic random number\n-/// generator*](http://www.burtleburtle.net/bob/rand/isaacafa.html)\n-#[derive(Copy)]\n-pub struct Isaac64Rng {\n-    cnt: usize,\n-    rsl: [w64; RAND_SIZE_64],\n-    mem: [w64; RAND_SIZE_64],\n-    a: w64,\n-    b: w64,\n-    c: w64,\n-}\n-\n-impl fmt::Debug for Isaac64Rng {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Isaac64Rng\")\n-         .field(\"cnt\", &self.cnt)\n-         .field(\"rsl\", &self.rsl.iter())\n-         .field(\"mem\", &self.mem.iter())\n-         .field(\"a\", &self.a)\n-         .field(\"b\", &self.b)\n-         .field(\"c\", &self.c)\n-         .finish()\n-    }\n-}\n-\n-static EMPTY_64: Isaac64Rng = Isaac64Rng {\n-    cnt: 0,\n-    rsl: [w(0); RAND_SIZE_64],\n-    mem: [w(0); RAND_SIZE_64],\n-    a: w(0),\n-    b: w(0),\n-    c: w(0),\n-};\n-\n-impl Isaac64Rng {\n-    /// Create a 64-bit ISAAC random number generator using the\n-    /// default fixed seed.\n-    pub fn new_unseeded() -> Isaac64Rng {\n-        let mut rng = EMPTY_64;\n-        rng.init(false);\n-        rng\n-    }\n-\n-    /// Initializes `self`. If `use_rsl` is true, then use the current value\n-    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n-    /// randomly).\n-    fn init(&mut self, use_rsl: bool) {\n-        macro_rules! init {\n-            ($var:ident) => (\n-                let mut $var = w(0x9e3779b97f4a7c13);\n-            )\n-        }\n-        init!(a);\n-        init!(b);\n-        init!(c);\n-        init!(d);\n-        init!(e);\n-        init!(f);\n-        init!(g);\n-        init!(h);\n-\n-        macro_rules! mix {\n-            () => {{\n-                a = a - e;\n-                f = f ^ (h >> 9);\n-                h = h + a;\n-\n-                b = b - f;\n-                g = g ^ (a << 9);\n-                a = a + b;\n-\n-                c = c - g;\n-                h = h ^ (b >> 23);\n-                b = b + c;\n-\n-                d = d - h;\n-                a = a ^ (c << 15);\n-                c = c + d;\n-\n-                e = e - a;\n-                b = b ^ (d >> 14);\n-                d = d + e;\n-\n-                f = f - b;\n-                c = c ^ (e << 20);\n-                e = e + f;\n-\n-                g = g - c;\n-                d = d ^ (f >> 17);\n-                f = f + g;\n-\n-                h = h - d;\n-                e = e ^ (g << 14);\n-                g = g + h;\n-            }}\n-        }\n-\n-        for _ in 0..4 {\n-            mix!();\n-        }\n-\n-        if use_rsl {\n-            macro_rules! memloop {\n-                ($arr:expr) => {{\n-                    for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n-                        a = a + $arr[i];\n-                        b = b + $arr[i + 1];\n-                        c = c + $arr[i + 2];\n-                        d = d + $arr[i + 3];\n-                        e = e + $arr[i + 4];\n-                        f = f + $arr[i + 5];\n-                        g = g + $arr[i + 6];\n-                        h = h + $arr[i + 7];\n-                        mix!();\n-                        self.mem[i] = a;\n-                        self.mem[i + 1] = b;\n-                        self.mem[i + 2] = c;\n-                        self.mem[i + 3] = d;\n-                        self.mem[i + 4] = e;\n-                        self.mem[i + 5] = f;\n-                        self.mem[i + 6] = g;\n-                        self.mem[i + 7] = h;\n-                    }\n-                }}\n-            }\n-\n-            memloop!(self.rsl);\n-            memloop!(self.mem);\n-        } else {\n-            for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n-                mix!();\n-                self.mem[i] = a;\n-                self.mem[i + 1] = b;\n-                self.mem[i + 2] = c;\n-                self.mem[i + 3] = d;\n-                self.mem[i + 4] = e;\n-                self.mem[i + 5] = f;\n-                self.mem[i + 6] = g;\n-                self.mem[i + 7] = h;\n-            }\n-        }\n-\n-        self.isaac64();\n-    }\n-\n-    /// Refills the output buffer (`self.rsl`)\n-    fn isaac64(&mut self) {\n-        self.c = self.c + w(1);\n-        // abbreviations\n-        let mut a = self.a;\n-        let mut b = self.b + self.c;\n-        const MIDPOINT: usize = RAND_SIZE_64 / 2;\n-        const MP_VEC: [(usize, usize); 2] = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        macro_rules! ind {\n-            ($x:expr) => {\n-                *self.mem.get_unchecked((($x >> 3).0 as usize) & (RAND_SIZE_64 - 1))\n-            }\n-        }\n-\n-        for &(mr_offset, m2_offset) in &MP_VEC {\n-            for base in (0..MIDPOINT / 4).map(|i| i * 4) {\n-\n-                macro_rules! rngstepp {\n-                    ($j:expr, $shift:expr) => {{\n-                        let base = base + $j;\n-                        let mix = a ^ (a << $shift);\n-                        let mix = if $j == 0 {!mix} else {mix};\n-\n-                        unsafe {\n-                            let x = *self.mem.get_unchecked(base + mr_offset);\n-                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                            let y = ind!(x) + a + b;\n-                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n-\n-                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n-                        }\n-                    }}\n-                }\n-\n-                macro_rules! rngstepn {\n-                    ($j:expr, $shift:expr) => {{\n-                        let base = base + $j;\n-                        let mix = a ^ (a >> $shift);\n-                        let mix = if $j == 0 {!mix} else {mix};\n-\n-                        unsafe {\n-                            let x = *self.mem.get_unchecked(base + mr_offset);\n-                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                            let y = ind!(x) + a + b;\n-                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n-\n-                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n-                        }\n-                    }}\n-                }\n-\n-                rngstepp!(0, 21);\n-                rngstepn!(1, 5);\n-                rngstepp!(2, 12);\n-                rngstepn!(3, 33);\n-            }\n-        }\n-\n-        self.a = a;\n-        self.b = b;\n-        self.cnt = RAND_SIZE_64;\n-    }\n-}\n-\n-// Cannot be derived because [u32; 256] does not implement Clone\n-impl Clone for Isaac64Rng {\n-    fn clone(&self) -> Isaac64Rng {\n-        *self\n-    }\n-}\n-\n-impl Rng for Isaac64Rng {\n-    // FIXME(https://github.com/rust-lang/rfcs/issues/628)\n-    // having next_u32 like this should be unnecessary\n-    #[inline]\n-    fn next_u32(&mut self) -> u32 {\n-        self.next_u64() as u32\n-    }\n-\n-    #[inline]\n-    fn next_u64(&mut self) -> u64 {\n-        if self.cnt == 0 {\n-            // make some more numbers\n-            self.isaac64();\n-        }\n-        self.cnt -= 1;\n-\n-        // See corresponding location in IsaacRng.next_u32 for\n-        // explanation.\n-        debug_assert!(self.cnt < RAND_SIZE_64);\n-        self.rsl[(self.cnt % RAND_SIZE_64) as usize].0\n-    }\n-}\n-\n-impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n-    fn reseed(&mut self, seed: &'a [u64]) {\n-        // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n-        // - 1], 0, 0, ...], to fill rng.rsl.\n-        let seed_iter = seed.iter().cloned().chain(repeat(0));\n-\n-        for (rsl_elem, seed_elem) in self.rsl.iter_mut().zip(seed_iter) {\n-            *rsl_elem = w(seed_elem);\n-        }\n-        self.cnt = 0;\n-        self.a = w(0);\n-        self.b = w(0);\n-        self.c = w(0);\n-\n-        self.init(true);\n-    }\n-\n-    /// Create an ISAAC random number generator with a seed. This can\n-    /// be any length, although the maximum number of elements used is\n-    /// 256 and any more will be silently ignored. A generator\n-    /// constructed with a given seed will generate the same sequence\n-    /// of values as all other generators constructed with that seed.\n-    fn from_seed(seed: &'a [u64]) -> Isaac64Rng {\n-        let mut rng = EMPTY_64;\n-        rng.reseed(seed);\n-        rng\n-    }\n-}\n-\n-impl Rand for Isaac64Rng {\n-    fn rand<R: Rng>(other: &mut R) -> Isaac64Rng {\n-        let mut ret = EMPTY_64;\n-        unsafe {\n-            let ptr = ret.rsl.as_mut_ptr() as *mut u8;\n-\n-            let slice = slice::from_raw_parts_mut(ptr, RAND_SIZE_64 * 8);\n-            other.fill_bytes(slice);\n-        }\n-        ret.cnt = 0;\n-        ret.a = w(0);\n-        ret.b = w(0);\n-        ret.c = w(0);\n-\n-        ret.init(true);\n-        return ret;\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::prelude::v1::*;\n-\n-    use {Rng, SeedableRng};\n-    use super::{Isaac64Rng, IsaacRng};\n-\n-    #[test]\n-    fn test_rng_32_rand_seeded() {\n-        let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n-        let mut ra: IsaacRng = SeedableRng::from_seed(&s[..]);\n-        let mut rb: IsaacRng = SeedableRng::from_seed(&s[..]);\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-    #[test]\n-    fn test_rng_64_rand_seeded() {\n-        let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n-        let mut ra: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n-        let mut rb: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-\n-    #[test]\n-    fn test_rng_32_seeded() {\n-        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n-        let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n-        let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-    #[test]\n-    fn test_rng_64_seeded() {\n-        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n-        let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n-        let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-\n-    #[test]\n-    fn test_rng_32_reseed() {\n-        let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n-        let mut r: IsaacRng = SeedableRng::from_seed(&s[..]);\n-        let string1: String = r.gen_ascii_chars().take(100).collect();\n-\n-        r.reseed(&s);\n-\n-        let string2: String = r.gen_ascii_chars().take(100).collect();\n-        assert_eq!(string1, string2);\n-    }\n-    #[test]\n-    fn test_rng_64_reseed() {\n-        let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n-        let mut r: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n-        let string1: String = r.gen_ascii_chars().take(100).collect();\n-\n-        r.reseed(&s);\n-\n-        let string2: String = r.gen_ascii_chars().take(100).collect();\n-        assert_eq!(string1, string2);\n-    }\n-\n-    #[test]\n-    #[rustfmt_skip]\n-    fn test_rng_32_true_values() {\n-        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n-        let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n-        // Regression test that isaac is actually using the above vector\n-        let v = (0..10).map(|_| ra.next_u32()).collect::<Vec<_>>();\n-        assert_eq!(v,\n-                   vec![2558573138, 873787463, 263499565, 2103644246, 3595684709,\n-                        4203127393, 264982119, 2765226902, 2737944514, 3900253796]);\n-\n-        let seed: &[_] = &[12345, 67890, 54321, 9876];\n-        let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n-        // skip forward to the 10000th number\n-        for _ in 0..10000 {\n-            rb.next_u32();\n-        }\n-\n-        let v = (0..10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n-        assert_eq!(v,\n-                   vec![3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n-                        1576568959, 3507990155, 179069555, 141456972, 2478885421]);\n-    }\n-    #[test]\n-    #[rustfmt_skip]\n-    fn test_rng_64_true_values() {\n-        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n-        let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n-        // Regression test that isaac is actually using the above vector\n-        let v = (0..10).map(|_| ra.next_u64()).collect::<Vec<_>>();\n-        assert_eq!(v,\n-                   vec![547121783600835980, 14377643087320773276, 17351601304698403469,\n-                        1238879483818134882, 11952566807690396487, 13970131091560099343,\n-                        4469761996653280935, 15552757044682284409, 6860251611068737823,\n-                        13722198873481261842]);\n-\n-        let seed: &[_] = &[12345, 67890, 54321, 9876];\n-        let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n-        // skip forward to the 10000th number\n-        for _ in 0..10000 {\n-            rb.next_u64();\n-        }\n-\n-        let v = (0..10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n-        assert_eq!(v,\n-                   vec![18143823860592706164, 8491801882678285927, 2699425367717515619,\n-                        17196852593171130876, 2606123525235546165, 15790932315217671084,\n-                        596345674630742204, 9947027391921273664, 11788097613744130851,\n-                        10391409374914919106]);\n-\n-    }\n-\n-    #[test]\n-    fn test_rng_clone() {\n-        let seed: &[_] = &[1, 23, 456, 7890, 12345];\n-        let mut rng: Isaac64Rng = SeedableRng::from_seed(seed);\n-        let mut clone = rng.clone();\n-        for _ in 0..16 {\n-            assert_eq!(rng.next_u64(), clone.next_u64());\n-        }\n-    }\n-}"}, {"sha": "82344f0ec09c6ebbff5defbf7f99e197580f4791", "filename": "src/librand/lib.rs", "status": "removed", "additions": 0, "deletions": 481, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,481 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Interface to random number generators in Rust.\n-//!\n-//! This is an experimental library which lives underneath the standard library\n-//! in its dependency chain. This library is intended to define the interface\n-//! for random number generation and also provide utilities around doing so. It\n-//! is not recommended to use this library directly, but rather the official\n-//! interface through `std::rand`.\n-\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-#![deny(warnings)]\n-#![deny(missing_debug_implementations)]\n-#![no_std]\n-#![unstable(feature = \"rand\",\n-            reason = \"use `rand` from crates.io\",\n-            issue = \"27703\")]\n-#![feature(core_intrinsics)]\n-#![feature(staged_api)]\n-#![feature(iterator_step_by)]\n-#![feature(custom_attribute)]\n-#![feature(specialization)]\n-#![allow(unused_attributes)]\n-\n-#![cfg_attr(not(test), feature(core_float))] // only necessary for no_std\n-#![cfg_attr(test, feature(test, rand))]\n-\n-#![allow(deprecated)]\n-\n-#[cfg(test)]\n-#[macro_use]\n-extern crate std;\n-\n-use core::fmt;\n-use core::f64;\n-use core::intrinsics;\n-use core::marker::PhantomData;\n-\n-pub use isaac::{Isaac64Rng, IsaacRng};\n-pub use chacha::ChaChaRng;\n-\n-use distributions::{IndependentSample, Range};\n-use distributions::range::SampleRange;\n-\n-#[cfg(test)]\n-const RAND_BENCH_N: u64 = 100;\n-\n-pub mod distributions;\n-pub mod isaac;\n-pub mod chacha;\n-pub mod reseeding;\n-mod rand_impls;\n-\n-// Temporary trait to implement a few floating-point routines\n-// needed by librand; this is necessary because librand doesn't\n-// depend on libstd.  This will go away when librand is integrated\n-// into libstd.\n-#[doc(hidden)]\n-trait FloatMath: Sized {\n-    fn exp(self) -> Self;\n-    fn ln(self) -> Self;\n-    fn sqrt(self) -> Self;\n-    fn powf(self, n: Self) -> Self;\n-}\n-\n-impl FloatMath for f64 {\n-    #[inline]\n-    fn exp(self) -> f64 {\n-        unsafe { intrinsics::expf64(self) }\n-    }\n-\n-    #[inline]\n-    fn ln(self) -> f64 {\n-        unsafe { intrinsics::logf64(self) }\n-    }\n-\n-    #[inline]\n-    fn powf(self, n: f64) -> f64 {\n-        unsafe { intrinsics::powf64(self, n) }\n-    }\n-\n-    #[inline]\n-    fn sqrt(self) -> f64 {\n-        if self < 0.0 {\n-            f64::NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf64(self) }\n-        }\n-    }\n-}\n-\n-/// A type that can be randomly generated using an `Rng`.\n-#[doc(hidden)]\n-pub trait Rand: Sized {\n-    /// Generates a random instance of this type using the specified source of\n-    /// randomness.\n-    fn rand<R: Rng>(rng: &mut R) -> Self;\n-}\n-\n-/// A random number generator.\n-pub trait Rng: Sized {\n-    /// Return the next random u32.\n-    ///\n-    /// This rarely needs to be called directly, prefer `r.gen()` to\n-    /// `r.next_u32()`.\n-    // FIXME(https://github.com/rust-lang/rfcs/issues/628)\n-    // Should be implemented in terms of next_u64\n-    fn next_u32(&mut self) -> u32;\n-\n-    /// Return the next random u64.\n-    ///\n-    /// By default this is implemented in terms of `next_u32`. An\n-    /// implementation of this trait must provide at least one of\n-    /// these two methods. Similarly to `next_u32`, this rarely needs\n-    /// to be called directly, prefer `r.gen()` to `r.next_u64()`.\n-    fn next_u64(&mut self) -> u64 {\n-        ((self.next_u32() as u64) << 32) | (self.next_u32() as u64)\n-    }\n-\n-    /// Return the next random f32 selected from the half-open\n-    /// interval `[0, 1)`.\n-    ///\n-    /// By default this is implemented in terms of `next_u32`, but a\n-    /// random number generator which can generate numbers satisfying\n-    /// the requirements directly can overload this for performance.\n-    /// It is required that the return value lies in `[0, 1)`.\n-    ///\n-    /// See `Closed01` for the closed interval `[0,1]`, and\n-    /// `Open01` for the open interval `(0,1)`.\n-    fn next_f32(&mut self) -> f32 {\n-        const MANTISSA_BITS: usize = 24;\n-        const IGNORED_BITS: usize = 8;\n-        const SCALE: f32 = (1u64 << MANTISSA_BITS) as f32;\n-\n-        // using any more than `MANTISSA_BITS` bits will\n-        // cause (e.g.) 0xffff_ffff to correspond to 1\n-        // exactly, so we need to drop some (8 for f32, 11\n-        // for f64) to guarantee the open end.\n-        (self.next_u32() >> IGNORED_BITS) as f32 / SCALE\n-    }\n-\n-    /// Return the next random f64 selected from the half-open\n-    /// interval `[0, 1)`.\n-    ///\n-    /// By default this is implemented in terms of `next_u64`, but a\n-    /// random number generator which can generate numbers satisfying\n-    /// the requirements directly can overload this for performance.\n-    /// It is required that the return value lies in `[0, 1)`.\n-    ///\n-    /// See `Closed01` for the closed interval `[0,1]`, and\n-    /// `Open01` for the open interval `(0,1)`.\n-    fn next_f64(&mut self) -> f64 {\n-        const MANTISSA_BITS: usize = 53;\n-        const IGNORED_BITS: usize = 11;\n-        const SCALE: f64 = (1u64 << MANTISSA_BITS) as f64;\n-\n-        (self.next_u64() >> IGNORED_BITS) as f64 / SCALE\n-    }\n-\n-    /// Fill `dest` with random data.\n-    ///\n-    /// This has a default implementation in terms of `next_u64` and\n-    /// `next_u32`, but should be overridden by implementations that\n-    /// offer a more efficient solution than just calling those\n-    /// methods repeatedly.\n-    ///\n-    /// This method does *not* have a requirement to bear any fixed\n-    /// relationship to the other methods, for example, it does *not*\n-    /// have to result in the same output as progressively filling\n-    /// `dest` with `self.gen::<u8>()`, and any such behavior should\n-    /// not be relied upon.\n-    ///\n-    /// This method should guarantee that `dest` is entirely filled\n-    /// with new data, and may panic if this is impossible\n-    /// (e.g. reading past the end of a file that is being used as the\n-    /// source of randomness).\n-    fn fill_bytes(&mut self, dest: &mut [u8]) {\n-        // this could, in theory, be done by transmuting dest to a\n-        // [u64], but this is (1) likely to be undefined behaviour for\n-        // LLVM, (2) has to be very careful about alignment concerns,\n-        // (3) adds more `unsafe` that needs to be checked, (4)\n-        // probably doesn't give much performance gain if\n-        // optimisations are on.\n-        let mut count = 0;\n-        let mut num = 0;\n-        for byte in dest {\n-            if count == 0 {\n-                // we could micro-optimise here by generating a u32 if\n-                // we only need a few more bytes to fill the vector\n-                // (i.e. at most 4).\n-                num = self.next_u64();\n-                count = 8;\n-            }\n-\n-            *byte = (num & 0xff) as u8;\n-            num >>= 8;\n-            count -= 1;\n-        }\n-    }\n-\n-    /// Return a random value of a `Rand` type.\n-    #[inline(always)]\n-    fn gen<T: Rand>(&mut self) -> T {\n-        Rand::rand(self)\n-    }\n-\n-    /// Return an iterator that will yield an infinite number of randomly\n-    /// generated items.\n-    fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self> {\n-        Generator {\n-            rng: self,\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    /// Generate a random value in the range [`low`, `high`).\n-    ///\n-    /// This is a convenience wrapper around\n-    /// `distributions::Range`. If this function will be called\n-    /// repeatedly with the same arguments, one should use `Range`, as\n-    /// that will amortize the computations that allow for perfect\n-    /// uniformity, as they only happen on initialization.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `low >= high`.\n-    fn gen_range<T: PartialOrd + SampleRange>(&mut self, low: T, high: T) -> T {\n-        assert!(low < high, \"Rng.gen_range called with low >= high\");\n-        Range::new(low, high).ind_sample(self)\n-    }\n-\n-    /// Return a bool with a 1 in n chance of true\n-    fn gen_weighted_bool(&mut self, n: usize) -> bool {\n-        n <= 1 || self.gen_range(0, n) == 0\n-    }\n-\n-    /// Return an iterator of random characters from the set A-Z,a-z,0-9.\n-    fn gen_ascii_chars<'a>(&'a mut self) -> AsciiGenerator<'a, Self> {\n-        AsciiGenerator { rng: self }\n-    }\n-\n-    /// Return a random element from `values`.\n-    ///\n-    /// Return `None` if `values` is empty.\n-    fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n-        if values.is_empty() {\n-            None\n-        } else {\n-            Some(&values[self.gen_range(0, values.len())])\n-        }\n-    }\n-\n-    /// Shuffle a mutable slice in place.\n-    fn shuffle<T>(&mut self, values: &mut [T]) {\n-        let mut i = values.len();\n-        while i >= 2 {\n-            // invariant: elements with index >= i have been locked in place.\n-            i -= 1;\n-            // lock element i in place.\n-            values.swap(i, self.gen_range(0, i + 1));\n-        }\n-    }\n-}\n-\n-/// Iterator which will generate a stream of random items.\n-///\n-/// This iterator is created via the `gen_iter` method on `Rng`.\n-pub struct Generator<'a, T, R: 'a> {\n-    rng: &'a mut R,\n-    _marker: PhantomData<T>,\n-}\n-\n-impl<'a, T: Rand, R: Rng> Iterator for Generator<'a, T, R> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        Some(self.rng.gen())\n-    }\n-}\n-\n-impl<'a, T, R: fmt::Debug> fmt::Debug for Generator<'a, T, R> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Generator\")\n-         .field(\"rng\", &self.rng)\n-         .finish()\n-    }\n-}\n-\n-/// Iterator which will continuously generate random ascii characters.\n-///\n-/// This iterator is created via the `gen_ascii_chars` method on `Rng`.\n-pub struct AsciiGenerator<'a, R: 'a> {\n-    rng: &'a mut R,\n-}\n-\n-impl<'a, R: Rng> Iterator for AsciiGenerator<'a, R> {\n-    type Item = char;\n-\n-    fn next(&mut self) -> Option<char> {\n-        const GEN_ASCII_STR_CHARSET: &'static [u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-                                                       abcdefghijklmnopqrstuvwxyz\\\n-                                                       0123456789\";\n-        Some(*self.rng.choose(GEN_ASCII_STR_CHARSET).unwrap() as char)\n-    }\n-}\n-\n-impl<'a, R: fmt::Debug> fmt::Debug for AsciiGenerator<'a, R> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"AsciiGenerator\")\n-         .field(\"rng\", &self.rng)\n-         .finish()\n-    }\n-}\n-\n-/// A random number generator that can be explicitly seeded to produce\n-/// the same stream of randomness multiple times.\n-pub trait SeedableRng<Seed>: Rng {\n-    /// Reseed an RNG with the given seed.\n-    fn reseed(&mut self, _: Seed);\n-\n-    /// Create a new RNG with the given seed.\n-    fn from_seed(seed: Seed) -> Self;\n-}\n-\n-/// An Xorshift[1] random number\n-/// generator.\n-///\n-/// The Xorshift algorithm is not suitable for cryptographic purposes\n-/// but is very fast. If you do not know for sure that it fits your\n-/// requirements, use a more secure one such as `IsaacRng` or `OsRng`.\n-///\n-/// [1]: Marsaglia, George (July 2003). [\"Xorshift\n-/// RNGs\"](http://www.jstatsoft.org/v08/i14/paper). *Journal of\n-/// Statistical Software*. Vol. 8 (Issue 14).\n-#[derive(Clone, Debug)]\n-pub struct XorShiftRng {\n-    x: u32,\n-    y: u32,\n-    z: u32,\n-    w: u32,\n-}\n-\n-impl XorShiftRng {\n-    /// Creates a new XorShiftRng instance which is not seeded.\n-    ///\n-    /// The initial values of this RNG are constants, so all generators created\n-    /// by this function will yield the same stream of random numbers. It is\n-    /// highly recommended that this is created through `SeedableRng` instead of\n-    /// this function\n-    pub fn new_unseeded() -> XorShiftRng {\n-        XorShiftRng {\n-            x: 0x193a6754,\n-            y: 0xa8a7d469,\n-            z: 0x97830e05,\n-            w: 0x113ba7bb,\n-        }\n-    }\n-}\n-\n-impl Rng for XorShiftRng {\n-    #[inline]\n-    fn next_u32(&mut self) -> u32 {\n-        let x = self.x;\n-        let t = x ^ (x << 11);\n-        self.x = self.y;\n-        self.y = self.z;\n-        self.z = self.w;\n-        let w = self.w;\n-        self.w = w ^ (w >> 19) ^ (t ^ (t >> 8));\n-        self.w\n-    }\n-}\n-\n-impl SeedableRng<[u32; 4]> for XorShiftRng {\n-    /// Reseed an XorShiftRng. This will panic if `seed` is entirely 0.\n-    fn reseed(&mut self, seed: [u32; 4]) {\n-        assert!(!seed.iter().all(|&x| x == 0),\n-                \"XorShiftRng.reseed called with an all zero seed.\");\n-\n-        self.x = seed[0];\n-        self.y = seed[1];\n-        self.z = seed[2];\n-        self.w = seed[3];\n-    }\n-\n-    /// Create a new XorShiftRng. This will panic if `seed` is entirely 0.\n-    fn from_seed(seed: [u32; 4]) -> XorShiftRng {\n-        assert!(!seed.iter().all(|&x| x == 0),\n-                \"XorShiftRng::from_seed called with an all zero seed.\");\n-\n-        XorShiftRng {\n-            x: seed[0],\n-            y: seed[1],\n-            z: seed[2],\n-            w: seed[3],\n-        }\n-    }\n-}\n-\n-impl Rand for XorShiftRng {\n-    fn rand<R: Rng>(rng: &mut R) -> XorShiftRng {\n-        let mut tuple: (u32, u32, u32, u32) = rng.gen();\n-        while tuple == (0, 0, 0, 0) {\n-            tuple = rng.gen();\n-        }\n-        let (x, y, z, w) = tuple;\n-        XorShiftRng {\n-            x,\n-            y,\n-            z,\n-            w,\n-        }\n-    }\n-}\n-\n-/// A wrapper for generating floating point numbers uniformly in the\n-/// open interval `(0,1)` (not including either endpoint).\n-///\n-/// Use `Closed01` for the closed interval `[0,1]`, and the default\n-/// `Rand` implementation for `f32` and `f64` for the half-open\n-/// `[0,1)`.\n-pub struct Open01<F>(pub F);\n-\n-impl<F: fmt::Debug> fmt::Debug for Open01<F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Open01\")\n-         .field(&self.0)\n-         .finish()\n-    }\n-}\n-\n-/// A wrapper for generating floating point numbers uniformly in the\n-/// closed interval `[0,1]` (including both endpoints).\n-///\n-/// Use `Open01` for the closed interval `(0,1)`, and the default\n-/// `Rand` implementation of `f32` and `f64` for the half-open\n-/// `[0,1)`.\n-pub struct Closed01<F>(pub F);\n-\n-impl<F: fmt::Debug> fmt::Debug for Closed01<F> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"Closed01\")\n-         .field(&self.0)\n-         .finish()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::__rand as rand;\n-\n-    pub struct MyRng<R> {\n-        inner: R,\n-    }\n-\n-    impl<R: rand::Rng> ::Rng for MyRng<R> {\n-        fn next_u32(&mut self) -> u32 {\n-            rand::Rng::next_u32(&mut self.inner)\n-        }\n-    }\n-\n-    pub fn rng() -> MyRng<rand::ThreadRng> {\n-        MyRng { inner: rand::thread_rng() }\n-    }\n-\n-    pub fn weak_rng() -> MyRng<rand::ThreadRng> {\n-        MyRng { inner: rand::thread_rng() }\n-    }\n-}"}, {"sha": "b0d824da3ab4795a45b39b449300eed1c3a5f1ae", "filename": "src/librand/rand_impls.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,208 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The implementations of `Rand` for the built-in types.\n-\n-use core::char;\n-use core::mem;\n-\n-use {Rand, Rng};\n-\n-impl Rand for isize {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> isize {\n-        if mem::size_of::<isize>() == 4 {\n-            rng.gen::<i32>() as isize\n-        } else {\n-            rng.gen::<i64>() as isize\n-        }\n-    }\n-}\n-\n-impl Rand for i8 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i8 {\n-        rng.next_u32() as i8\n-    }\n-}\n-\n-impl Rand for i16 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i16 {\n-        rng.next_u32() as i16\n-    }\n-}\n-\n-impl Rand for i32 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i32 {\n-        rng.next_u32() as i32\n-    }\n-}\n-\n-impl Rand for i64 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> i64 {\n-        rng.next_u64() as i64\n-    }\n-}\n-\n-impl Rand for usize {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> usize {\n-        if mem::size_of::<usize>() == 4 {\n-            rng.gen::<u32>() as usize\n-        } else {\n-            rng.gen::<u64>() as usize\n-        }\n-    }\n-}\n-\n-impl Rand for u8 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u8 {\n-        rng.next_u32() as u8\n-    }\n-}\n-\n-impl Rand for u16 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u16 {\n-        rng.next_u32() as u16\n-    }\n-}\n-\n-impl Rand for u32 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u32 {\n-        rng.next_u32()\n-    }\n-}\n-\n-impl Rand for u64 {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> u64 {\n-        rng.next_u64()\n-    }\n-}\n-\n-macro_rules! float_impls {\n-    ($mod_name:ident, $ty:ty, $mantissa_bits:expr, $method_name:ident) => {\n-        mod $mod_name {\n-            use {Rand, Rng, Open01, Closed01};\n-\n-            const SCALE: $ty = (1u64 << $mantissa_bits) as $ty;\n-\n-            impl Rand for $ty {\n-                /// Generate a floating point number in the half-open\n-                /// interval `[0,1)`.\n-                ///\n-                /// See `Closed01` for the closed interval `[0,1]`,\n-                /// and `Open01` for the open interval `(0,1)`.\n-                #[inline]\n-                fn rand<R: Rng>(rng: &mut R) -> $ty {\n-                    rng.$method_name()\n-                }\n-            }\n-            impl Rand for Open01<$ty> {\n-                #[inline]\n-                fn rand<R: Rng>(rng: &mut R) -> Open01<$ty> {\n-                    // add a small amount (specifically 2 bits below\n-                    // the precision of f64/f32 at 1.0), so that small\n-                    // numbers are larger than 0, but large numbers\n-                    // aren't pushed to/above 1.\n-                    Open01(rng.$method_name() + 0.25 / SCALE)\n-                }\n-            }\n-            impl Rand for Closed01<$ty> {\n-                #[inline]\n-                fn rand<R: Rng>(rng: &mut R) -> Closed01<$ty> {\n-                    // rescale so that 1.0 - epsilon becomes 1.0\n-                    // precisely.\n-                    Closed01(rng.$method_name() * SCALE / (SCALE - 1.0))\n-                }\n-            }\n-        }\n-    }\n-}\n-float_impls! { f64_rand_impls, f64, 53, next_f64 }\n-float_impls! { f32_rand_impls, f32, 24, next_f32 }\n-\n-impl Rand for char {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> char {\n-        // a char is 21 bits\n-        const CHAR_MASK: u32 = 0x001f_ffff;\n-        loop {\n-            // Rejection sampling. About 0.2% of numbers with at most\n-            // 21-bits are invalid codepoints (surrogates), so this\n-            // will succeed first go almost every time.\n-            if let Some(c) = char::from_u32(rng.next_u32() & CHAR_MASK) {\n-                return c;\n-            }\n-        }\n-    }\n-}\n-\n-impl Rand for bool {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> bool {\n-        rng.gen::<u8>() & 1 == 1\n-    }\n-}\n-\n-macro_rules! tuple_impl {\n-    // use variables to indicate the arity of the tuple\n-    ($($tyvar:ident),* ) => {\n-        // the trailing commas are for the 1 tuple\n-        impl<\n-            $( $tyvar : Rand ),*\n-            > Rand for ( $( $tyvar ),* , ) {\n-\n-            #[inline]\n-            fn rand<R: Rng>(_rng: &mut R) -> ( $( $tyvar ),* , ) {\n-                (\n-                    // use the $tyvar's to get the appropriate number of\n-                    // repeats (they're not actually needed)\n-                    $(\n-                        _rng.gen::<$tyvar>()\n-                    ),*\n-                    ,\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-impl Rand for () {\n-    #[inline]\n-    fn rand<R: Rng>(_: &mut R) -> () {\n-        ()\n-    }\n-}\n-tuple_impl!{A}\n-tuple_impl!{A, B}\n-tuple_impl!{A, B, C}\n-tuple_impl!{A, B, C, D}\n-tuple_impl!{A, B, C, D, E}\n-tuple_impl!{A, B, C, D, E, F}\n-tuple_impl!{A, B, C, D, E, F, G}\n-tuple_impl!{A, B, C, D, E, F, G, H}\n-tuple_impl!{A, B, C, D, E, F, G, H, I}\n-tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n-tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n-tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n-\n-impl<T: Rand> Rand for Option<T> {\n-    #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n-        if rng.gen() { Some(rng.gen()) } else { None }\n-    }\n-}"}, {"sha": "2821b7a8232df4622e4a12df47c49115c22aaff1", "filename": "src/librand/reseeding.rs", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,216 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A wrapper around another RNG that reseeds it after it\n-//! generates a certain number of random bytes.\n-\n-use core::fmt;\n-use {Rng, SeedableRng};\n-\n-/// How many bytes of entropy the underling RNG is allowed to generate\n-/// before it is reseeded.\n-const DEFAULT_GENERATION_THRESHOLD: usize = 32 * 1024;\n-\n-/// A wrapper around any RNG which reseeds the underlying RNG after it\n-/// has generated a certain number of random bytes.\n-pub struct ReseedingRng<R, Rsdr> {\n-    rng: R,\n-    generation_threshold: usize,\n-    bytes_generated: usize,\n-    /// Controls the behavior when reseeding the RNG.\n-    pub reseeder: Rsdr,\n-}\n-\n-impl<R: Rng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {\n-    /// Create a new `ReseedingRng` with the given parameters.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `rng`: the random number generator to use.\n-    /// * `generation_threshold`: the number of bytes of entropy at which to reseed the RNG.\n-    /// * `reseeder`: the reseeding object to use.\n-    pub fn new(rng: R, generation_threshold: usize, reseeder: Rsdr) -> ReseedingRng<R, Rsdr> {\n-        ReseedingRng {\n-            rng,\n-            generation_threshold,\n-            bytes_generated: 0,\n-            reseeder,\n-        }\n-    }\n-\n-    /// Reseed the internal RNG if the number of bytes that have been\n-    /// generated exceed the threshold.\n-    pub fn reseed_if_necessary(&mut self) {\n-        if self.bytes_generated >= self.generation_threshold {\n-            self.reseeder.reseed(&mut self.rng);\n-            self.bytes_generated = 0;\n-        }\n-    }\n-}\n-\n-impl<R: Rng, Rsdr: Reseeder<R>> Rng for ReseedingRng<R, Rsdr> {\n-    fn next_u32(&mut self) -> u32 {\n-        self.reseed_if_necessary();\n-        self.bytes_generated += 4;\n-        self.rng.next_u32()\n-    }\n-\n-    fn next_u64(&mut self) -> u64 {\n-        self.reseed_if_necessary();\n-        self.bytes_generated += 8;\n-        self.rng.next_u64()\n-    }\n-\n-    fn fill_bytes(&mut self, dest: &mut [u8]) {\n-        self.reseed_if_necessary();\n-        self.bytes_generated += dest.len();\n-        self.rng.fill_bytes(dest)\n-    }\n-}\n-\n-impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R> + Default>\n-     SeedableRng<(Rsdr, S)> for ReseedingRng<R, Rsdr> {\n-    fn reseed(&mut self, (rsdr, seed): (Rsdr, S)) {\n-        self.rng.reseed(seed);\n-        self.reseeder = rsdr;\n-        self.bytes_generated = 0;\n-    }\n-\n-/// Create a new `ReseedingRng` from the given reseeder and\n-/// seed. This uses a default value for `generation_threshold`.\n-    fn from_seed((rsdr, seed): (Rsdr, S)) -> ReseedingRng<R, Rsdr> {\n-        ReseedingRng {\n-            rng: SeedableRng::from_seed(seed),\n-            generation_threshold: DEFAULT_GENERATION_THRESHOLD,\n-            bytes_generated: 0,\n-            reseeder: rsdr,\n-        }\n-    }\n-}\n-\n-impl<R: fmt::Debug, Rsdr: fmt::Debug> fmt::Debug for ReseedingRng<R, Rsdr> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"ReseedingRng\")\n-         .field(\"rng\", &self.rng)\n-         .field(\"generation_threshold\", &self.generation_threshold)\n-         .field(\"bytes_generated\", &self.bytes_generated)\n-         .field(\"reseeder\", &self.reseeder)\n-         .finish()\n-    }\n-}\n-\n-/// Something that can be used to reseed an RNG via `ReseedingRng`.\n-pub trait Reseeder<R> {\n-    /// Reseed the given RNG.\n-    fn reseed(&mut self, rng: &mut R);\n-}\n-\n-/// Reseed an RNG using a `Default` instance. This reseeds by\n-/// replacing the RNG with the result of a `Default::default` call.\n-#[derive(Copy, Clone, Debug)]\n-pub struct ReseedWithDefault;\n-\n-impl<R: Rng + Default> Reseeder<R> for ReseedWithDefault {\n-    fn reseed(&mut self, rng: &mut R) {\n-        *rng = Default::default();\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for ReseedWithDefault {\n-    /// Creates an instance of `ReseedWithDefault`.\n-    fn default() -> ReseedWithDefault {\n-        ReseedWithDefault\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::prelude::v1::*;\n-\n-    use super::{ReseedWithDefault, ReseedingRng};\n-    use {Rng, SeedableRng};\n-\n-    struct Counter {\n-        i: u32,\n-    }\n-\n-    impl Rng for Counter {\n-        fn next_u32(&mut self) -> u32 {\n-            self.i += 1;\n-            // very random\n-            self.i - 1\n-        }\n-    }\n-    impl Default for Counter {\n-        /// Constructs a `Counter` with initial value zero.\n-        fn default() -> Counter {\n-            Counter { i: 0 }\n-        }\n-    }\n-    impl SeedableRng<u32> for Counter {\n-        fn reseed(&mut self, seed: u32) {\n-            self.i = seed;\n-        }\n-        fn from_seed(seed: u32) -> Counter {\n-            Counter { i: seed }\n-        }\n-    }\n-    type MyRng = ReseedingRng<Counter, ReseedWithDefault>;\n-\n-    #[test]\n-    fn test_reseeding() {\n-        let mut rs = ReseedingRng::new(Counter { i: 0 }, 400, ReseedWithDefault);\n-\n-        let mut i = 0;\n-        for _ in 0..1000 {\n-            assert_eq!(rs.next_u32(), i % 100);\n-            i += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_rng_seeded() {\n-        let mut ra: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n-        let mut rb: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n-        assert!(ra.gen_ascii_chars()\n-            .take(100)\n-            .eq(rb.gen_ascii_chars().take(100)));\n-    }\n-\n-    #[test]\n-    fn test_rng_reseed() {\n-        let mut r: MyRng = SeedableRng::from_seed((ReseedWithDefault, 3));\n-        let string1: String = r.gen_ascii_chars().take(100).collect();\n-\n-        r.reseed((ReseedWithDefault, 3));\n-\n-        let string2: String = r.gen_ascii_chars().take(100).collect();\n-        assert_eq!(string1, string2);\n-    }\n-\n-    const FILL_BYTES_V_LEN: usize = 13579;\n-    #[test]\n-    fn test_rng_fill_bytes() {\n-        let mut v = vec![0; FILL_BYTES_V_LEN];\n-        ::test::rng().fill_bytes(&mut v);\n-\n-        // Sanity test: if we've gotten here, `fill_bytes` has not infinitely\n-        // recursed.\n-        assert_eq!(v.len(), FILL_BYTES_V_LEN);\n-\n-        // To test that `fill_bytes` actually did something, check that the\n-        // average of `v` is not 0.\n-        let mut sum = 0.0;\n-        for &x in &v {\n-            sum += x as f64;\n-        }\n-        assert!(sum / v.len() as f64 != 0.0);\n-    }\n-}"}, {"sha": "92b024b67d4cc3227d8e15e24fc5c2f2aa577a28", "filename": "src/librustc_back/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_back%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_back%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FCargo.toml?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -12,6 +12,7 @@ crate-type = [\"dylib\"]\n syntax = { path = \"../libsyntax\" }\n serialize = { path = \"../libserialize\" }\n log = \"0.3\"\n+rand = \"0.3\"\n \n [features]\n jemalloc = []"}, {"sha": "d67de123415f2ddfd2a8d1c7cbe7cb2551b2fc6b", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -29,11 +29,10 @@\n #![feature(box_syntax)]\n #![feature(const_fn)]\n #![feature(libc)]\n-#![feature(rand)]\n-#![cfg_attr(test, feature(rand))]\n \n extern crate syntax;\n extern crate libc;\n+extern crate rand;\n extern crate serialize;\n #[macro_use] extern crate log;\n "}, {"sha": "1a2515366224c04cb585884fc110c90e1dd40073", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -12,7 +12,7 @@ use std::env;\n use std::io::{self, Error, ErrorKind};\n use std::fs;\n use std::path::{self, PathBuf, Path};\n-use std::__rand::{thread_rng, Rng};\n+use rand::{thread_rng, Rng};\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-based deletion."}, {"sha": "b40a1b7c0cb7d7daff9a2c440133a886122e118c", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -10,9 +10,10 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n graphviz = { path = \"../libgraphviz\" }\n+log = \"0.3\"\n+rand = \"0.3\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n serialize = { path = \"../libserialize\" }\n-log = \"0.3\"\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "5eaf8553ee3d391882af3663c7603375268dd359", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -15,7 +15,6 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n-#![feature(rand)]\n #![feature(conservative_impl_trait)]\n #![feature(i128_type)]\n #![feature(inclusive_range_syntax)]\n@@ -25,6 +24,7 @@ extern crate graphviz;\n #[macro_use] extern crate rustc;\n extern crate rustc_data_structures;\n extern crate serialize as rustc_serialize;\n+extern crate rand;\n \n #[macro_use] extern crate log;\n extern crate syntax;"}, {"sha": "4141137a7db963aaef97ccc459c7876f5c0bfc2c", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -125,7 +125,8 @@ use std::io;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::time::{UNIX_EPOCH, SystemTime, Duration};\n-use std::__rand::{thread_rng, Rng};\n+\n+use rand::{thread_rng, Rng};\n \n const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";"}, {"sha": "3430ecabcbeaea079874ef3406e77c19491ac5aa", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -20,12 +20,14 @@ panic_unwind = { path = \"../libpanic_unwind\", optional = true }\n panic_abort = { path = \"../libpanic_abort\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n-rand = { path = \"../librand\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n std_unicode = { path = \"../libstd_unicode\" }\n unwind = { path = \"../libunwind\" }\n \n+[dev-dependencies]\n+rand = \"0.3\"\n+\n [target.x86_64-apple-darwin.dependencies]\n rustc_asan = { path = \"../librustc_asan\" }\n rustc_tsan = { path = \"../librustc_tsan\" }"}, {"sha": "1771e9244143b8521c69ae3f05dab030646ff466", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -20,8 +20,8 @@ use hash::{Hash, Hasher, BuildHasher, SipHasher13};\n use iter::{FromIterator, FusedIterator};\n use mem::{self, replace};\n use ops::{Deref, Index, InPlace, Place, Placer};\n-use rand::{self, Rng};\n use ptr;\n+use sys;\n \n use super::table::{self, Bucket, EmptyBucket, FullBucket, FullBucketMut, RawTable, SafeHash};\n use super::table::BucketState::{Empty, Full};\n@@ -2461,9 +2461,7 @@ impl RandomState {\n         // increment one of the seeds on every RandomState creation, giving\n         // every corresponding HashMap a different iteration order.\n         thread_local!(static KEYS: Cell<(u64, u64)> = {\n-            let r = rand::OsRng::new();\n-            let mut r = r.expect(\"failed to create an OS RNG\");\n-            Cell::new((r.gen(), r.gen()))\n+            Cell::new(sys::hashmap_random_keys())\n         });\n \n         KEYS.with(|keys| {"}, {"sha": "37cc7a49b527116f8aa807d6ec85a6fb93ab4b0a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -356,6 +356,7 @@ use prelude::v1::*;\n \n // Access to Bencher, etc.\n #[cfg(test)] extern crate test;\n+#[cfg(test)] extern crate rand;\n \n // We want to reexport a few macros from core but libcore has already been\n // imported by the compiler (via our #[no_std] attribute) In this case we just\n@@ -364,9 +365,6 @@ use prelude::v1::*;\n                  debug_assert_ne, unreachable, unimplemented, write, writeln, try)]\n extern crate core as __core;\n \n-#[doc(masked)]\n-#[allow(deprecated)]\n-extern crate rand as core_rand;\n #[macro_use]\n #[macro_reexport(vec, format)]\n extern crate alloc;\n@@ -504,24 +502,12 @@ mod sys;\n \n // Private support modules\n mod panicking;\n-mod rand;\n mod memchr;\n \n // The runtime entry point and a few unstable public functions used by the\n // compiler\n pub mod rt;\n \n-// Some external utilities of the standard library rely on randomness (aka\n-// rustc_back::TempDir and tests) and need a way to get at the OS rng we've got\n-// here. This module is not at all intended for stabilization as-is, however,\n-// but it may be stabilized long-term. As a result we're exposing a hidden,\n-// unstable module so we can get our build working.\n-#[doc(hidden)]\n-#[unstable(feature = \"rand\", issue = \"27703\")]\n-pub mod __rand {\n-    pub use rand::{thread_rng, ThreadRng, Rng};\n-}\n-\n // Include a number of private modules that exist solely to provide\n // the rustdoc documentation for primitive types. Using `include!`\n // because rustdoc only looks for these modules at the crate level."}, {"sha": "8da070e7a497a49e8a8d7fb618b9a218eef93f64", "filename": "src/libstd/rand/mod.rs", "status": "removed", "additions": 0, "deletions": 286, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,286 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utilities for random number generation\n-//!\n-//! The key functions are `random()` and `Rng::gen()`. These are polymorphic\n-//! and so can be used to generate any type that implements `Rand`. Type inference\n-//! means that often a simple call to `rand::random()` or `rng.gen()` will\n-//! suffice, but sometimes an annotation is required, e.g. `rand::random::<f64>()`.\n-//!\n-//! See the `distributions` submodule for sampling random numbers from\n-//! distributions like normal and exponential.\n-//!\n-//! # Thread-local RNG\n-//!\n-//! There is built-in support for a RNG associated with each thread stored\n-//! in thread-local storage. This RNG can be accessed via `thread_rng`, or\n-//! used implicitly via `random`. This RNG is normally randomly seeded\n-//! from an operating-system source of randomness, e.g. `/dev/urandom` on\n-//! Unix systems, and will automatically reseed itself from this source\n-//! after generating 32 KiB of random data.\n-//!\n-//! # Cryptographic security\n-//!\n-//! An application that requires an entropy source for cryptographic purposes\n-//! must use `OsRng`, which reads randomness from the source that the operating\n-//! system provides (e.g. `/dev/urandom` on Unixes or `CryptGenRandom()` on Windows).\n-//! The other random number generators provided by this module are not suitable\n-//! for such purposes.\n-//!\n-//! *Note*: many Unix systems provide `/dev/random` as well as `/dev/urandom`.\n-//! This module uses `/dev/urandom` for the following reasons:\n-//!\n-//! -   On Linux, `/dev/random` may block if entropy pool is empty; `/dev/urandom` will not block.\n-//!     This does not mean that `/dev/random` provides better output than\n-//!     `/dev/urandom`; the kernel internally runs a cryptographically secure pseudorandom\n-//!     number generator (CSPRNG) based on entropy pool for random number generation,\n-//!     so the \"quality\" of `/dev/random` is not better than `/dev/urandom` in most cases.\n-//!     However, this means that `/dev/urandom` can yield somewhat predictable randomness\n-//!     if the entropy pool is very small, such as immediately after first booting.\n-//!     Linux 3.17 added the `getrandom(2)` system call which solves the issue: it blocks if entropy\n-//!     pool is not initialized yet, but it does not block once initialized.\n-//!     `getrandom(2)` was based on `getentropy(2)`, an existing system call in OpenBSD.\n-//!     `OsRng` tries to use `getrandom(2)` if available, and use `/dev/urandom` fallback if not.\n-//!     If an application does not have `getrandom` and likely to be run soon after first booting,\n-//!     or on a system with very few entropy sources, one should consider using `/dev/random` via\n-//!     `ReaderRng`.\n-//! -   On some systems (e.g. FreeBSD, OpenBSD and macOS) there is no difference\n-//!     between the two sources. (Also note that, on some systems e.g. FreeBSD, both `/dev/random`\n-//!     and `/dev/urandom` may block once if the CSPRNG has not seeded yet.)\n-\n-#![unstable(feature = \"rand\", issue = \"27703\")]\n-\n-use cell::RefCell;\n-use fmt;\n-use io;\n-use mem;\n-use rc::Rc;\n-use sys;\n-\n-#[cfg(target_pointer_width = \"32\")]\n-use core_rand::IsaacRng as IsaacWordRng;\n-#[cfg(target_pointer_width = \"64\")]\n-use core_rand::Isaac64Rng as IsaacWordRng;\n-\n-pub use core_rand::{Rand, Rng, SeedableRng};\n-pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng};\n-pub use core_rand::reseeding;\n-\n-pub mod reader;\n-\n-/// The standard RNG. This is designed to be efficient on the current\n-/// platform.\n-#[derive(Copy, Clone)]\n-pub struct StdRng {\n-    rng: IsaacWordRng,\n-}\n-\n-impl StdRng {\n-    /// Create a randomly seeded instance of `StdRng`.\n-    ///\n-    /// This is a very expensive operation as it has to read\n-    /// randomness from the operating system and use this in an\n-    /// expensive seeding operation. If one is only generating a small\n-    /// number of random numbers, or doesn't need the utmost speed for\n-    /// generating each number, `thread_rng` and/or `random` may be more\n-    /// appropriate.\n-    ///\n-    /// Reading the randomness from the OS may fail, and any error is\n-    /// propagated via the `io::Result` return value.\n-    pub fn new() -> io::Result<StdRng> {\n-        OsRng::new().map(|mut r| StdRng { rng: r.gen() })\n-    }\n-}\n-\n-impl Rng for StdRng {\n-    #[inline]\n-    fn next_u32(&mut self) -> u32 {\n-        self.rng.next_u32()\n-    }\n-\n-    #[inline]\n-    fn next_u64(&mut self) -> u64 {\n-        self.rng.next_u64()\n-    }\n-}\n-\n-impl<'a> SeedableRng<&'a [usize]> for StdRng {\n-    fn reseed(&mut self, seed: &'a [usize]) {\n-        // the internal RNG can just be seeded from the above\n-        // randomness.\n-        self.rng.reseed(unsafe {mem::transmute(seed)})\n-    }\n-\n-    fn from_seed(seed: &'a [usize]) -> StdRng {\n-        StdRng { rng: SeedableRng::from_seed(unsafe {mem::transmute(seed)}) }\n-    }\n-}\n-\n-/// Controls how the thread-local RNG is reseeded.\n-struct ThreadRngReseeder;\n-\n-impl reseeding::Reseeder<StdRng> for ThreadRngReseeder {\n-    fn reseed(&mut self, rng: &mut StdRng) {\n-        *rng = match StdRng::new() {\n-            Ok(r) => r,\n-            Err(e) => panic!(\"could not reseed thread_rng: {}\", e)\n-        }\n-    }\n-}\n-const THREAD_RNG_RESEED_THRESHOLD: usize = 32_768;\n-type ThreadRngInner = reseeding::ReseedingRng<StdRng, ThreadRngReseeder>;\n-\n-/// The thread-local RNG.\n-#[derive(Clone)]\n-pub struct ThreadRng {\n-    rng: Rc<RefCell<ThreadRngInner>>,\n-}\n-\n-impl fmt::Debug for ThreadRng {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"ThreadRng { .. }\")\n-    }\n-}\n-\n-/// Retrieve the lazily-initialized thread-local random number\n-/// generator, seeded by the system. Intended to be used in method\n-/// chaining style, e.g. `thread_rng().gen::<isize>()`.\n-///\n-/// The RNG provided will reseed itself from the operating system\n-/// after generating a certain amount of randomness.\n-///\n-/// The internal RNG used is platform and architecture dependent, even\n-/// if the operating system random number generator is rigged to give\n-/// the same sequence always. If absolute consistency is required,\n-/// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n-pub fn thread_rng() -> ThreadRng {\n-    // used to make space in TLS for a random number generator\n-    thread_local!(static THREAD_RNG_KEY: Rc<RefCell<ThreadRngInner>> = {\n-        let r = match StdRng::new() {\n-            Ok(r) => r,\n-            Err(e) => panic!(\"could not initialize thread_rng: {}\", e)\n-        };\n-        let rng = reseeding::ReseedingRng::new(r,\n-                                               THREAD_RNG_RESEED_THRESHOLD,\n-                                               ThreadRngReseeder);\n-        Rc::new(RefCell::new(rng))\n-    });\n-\n-    ThreadRng { rng: THREAD_RNG_KEY.with(|t| t.clone()) }\n-}\n-\n-impl Rng for ThreadRng {\n-    fn next_u32(&mut self) -> u32 {\n-        self.rng.borrow_mut().next_u32()\n-    }\n-\n-    fn next_u64(&mut self) -> u64 {\n-        self.rng.borrow_mut().next_u64()\n-    }\n-\n-    #[inline]\n-    fn fill_bytes(&mut self, bytes: &mut [u8]) {\n-        self.rng.borrow_mut().fill_bytes(bytes)\n-    }\n-}\n-\n-/// A random number generator that retrieves randomness straight from\n-/// the operating system. Platform sources:\n-///\n-/// - Unix-like systems (Linux, Android, macOS): read directly from\n-///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n-/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-///   service provider with the `PROV_RSA_FULL` type.\n-/// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed.\n-/// - OpenBSD: uses the `getentropy(2)` system call.\n-///\n-/// This does not block.\n-pub struct OsRng(sys::rand::OsRng);\n-\n-impl OsRng {\n-    /// Create a new `OsRng`.\n-    pub fn new() -> io::Result<OsRng> {\n-        sys::rand::OsRng::new().map(OsRng)\n-    }\n-}\n-\n-impl Rng for OsRng {\n-    #[inline]\n-    fn next_u32(&mut self) -> u32 {\n-        self.0.next_u32()\n-    }\n-\n-    #[inline]\n-    fn next_u64(&mut self) -> u64 {\n-        self.0.next_u64()\n-    }\n-\n-    #[inline]\n-    fn fill_bytes(&mut self, bytes: &mut [u8]) {\n-        self.0.fill_bytes(bytes)\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use sync::mpsc::channel;\n-    use rand::Rng;\n-    use super::OsRng;\n-    use thread;\n-\n-    #[test]\n-    fn test_os_rng() {\n-        let mut r = OsRng::new().unwrap();\n-\n-        r.next_u32();\n-        r.next_u64();\n-\n-        let mut v = [0; 1000];\n-        r.fill_bytes(&mut v);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn test_os_rng_tasks() {\n-\n-        let mut txs = vec![];\n-        for _ in 0..20 {\n-            let (tx, rx) = channel();\n-            txs.push(tx);\n-\n-            thread::spawn(move|| {\n-                // wait until all the threads are ready to go.\n-                rx.recv().unwrap();\n-\n-                // deschedule to attempt to interleave things as much\n-                // as possible (XXX: is this a good test?)\n-                let mut r = OsRng::new().unwrap();\n-                thread::yield_now();\n-                let mut v = [0; 1000];\n-\n-                for _ in 0..100 {\n-                    r.next_u32();\n-                    thread::yield_now();\n-                    r.next_u64();\n-                    thread::yield_now();\n-                    r.fill_bytes(&mut v);\n-                    thread::yield_now();\n-                }\n-            });\n-        }\n-\n-        // start all the threads\n-        for tx in &txs {\n-            tx.send(()).unwrap();\n-        }\n-    }\n-}"}, {"sha": "40b24cedcdcf587cca804b81fb41c9971ea859c7", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -23,7 +23,6 @@\n #![doc(hidden)]\n \n \n-\n // Reexport some of our utilities which are expected by other crates.\n pub use panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n "}, {"sha": "6216d78528dbb779bbfc9ad2841e978456fb3502", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -554,8 +554,6 @@ impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> {\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n-    #![allow(deprecated)] // rand\n-\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n@@ -576,7 +574,7 @@ mod tests {\n \n     #[test]\n     fn frob() {\n-        const N: usize = 10;\n+        const N: u32 = 10;\n         const M: usize = 1000;\n \n         let r = Arc::new(RwLock::new(()));"}, {"sha": "7137a5067438fc5474bae798fd2d1a34cb63d509", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -12,6 +12,8 @@\n \n use io::{self, ErrorKind};\n \n+pub use self::rand::hashmap_random_keys;\n+\n pub mod args;\n #[cfg(feature = \"backtrace\")]\n pub mod backtrace;"}, {"sha": "3b378f53429ed7e914216209c912deb8b0f2408e", "filename": "src/libstd/sys/redox/rand.rs", "status": "modified", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fredox%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Frand.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -8,50 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io;\n-use rand::Rng;\n-\n-// FIXME: Use rand:\n-pub struct OsRng {\n-    state: [u64; 2]\n-}\n-\n-impl OsRng {\n-    /// Create a new `OsRng`.\n-    pub fn new() -> io::Result<OsRng> {\n-        Ok(OsRng {\n-            state: [0xBADF00D1, 0xDEADBEEF]\n-        })\n-    }\n-}\n-\n-impl Rng for OsRng {\n-    fn next_u32(&mut self) -> u32 {\n-        self.next_u64() as u32\n-    }\n-    fn next_u64(&mut self) -> u64 {\n-        // Store the first and second part.\n-        let mut x = self.state[0];\n-        let y = self.state[1];\n-\n-        // Put the second part into the first slot.\n-        self.state[0] = y;\n-        // Twist the first slot.\n-        x ^= x << 23;\n-        // Update the second slot.\n-        self.state[1] = x ^ y ^ (x >> 17) ^ (y >> 26);\n-\n-        // Generate the final integer.\n-        self.state[1].wrapping_add(y)\n-\n-    }\n-    fn fill_bytes(&mut self, buf: &mut [u8]) {\n-        for chunk in buf.chunks_mut(8) {\n-            let mut rand: u64 = self.next_u64();\n-            for b in chunk.iter_mut() {\n-                *b = rand as u8;\n-                rand = rand >> 8;\n-            }\n-        }\n-    }\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    (0, 0)\n }"}, {"sha": "4669b2a636cdd0fa0594f3287f41260202987384", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -29,6 +29,8 @@ use libc;\n #[cfg(all(not(dox), target_os = \"fuchsia\"))]   pub use os::fuchsia as platform;\n #[cfg(all(not(dox), target_os = \"l4re\"))]      pub use os::linux as platform;\n \n+pub use self::rand::hashmap_random_keys;\n+\n #[macro_use]\n pub mod weak;\n "}, {"sha": "bbffe0f0ffe604b435df9afdf4aeb3cac510a98b", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 74, "deletions": 215, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -8,20 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::imp::OsRng;\n-\n use mem;\n-\n-fn next_u32(fill_buf: &mut FnMut(&mut [u8])) -> u32 {\n-    let mut buf: [u8; 4] = [0; 4];\n-    fill_buf(&mut buf);\n-    unsafe { mem::transmute::<[u8; 4], u32>(buf) }\n-}\n-\n-fn next_u64(fill_buf: &mut FnMut(&mut [u8])) -> u64 {\n-    let mut buf: [u8; 8] = [0; 8];\n-    fill_buf(&mut buf);\n-    unsafe { mem::transmute::<[u8; 8], u64>(buf) }\n+use slice;\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    let mut v = (0, 0);\n+    unsafe {\n+        let view = slice::from_raw_parts_mut(&mut v as *mut _ as *mut u8,\n+                                             mem::size_of_val(&v));\n+        imp::fill_bytes(view);\n+    }\n+    return v\n }\n \n #[cfg(all(unix,\n@@ -30,14 +27,9 @@ fn next_u64(fill_buf: &mut FnMut(&mut [u8])) -> u64 {\n           not(target_os = \"freebsd\"),\n           not(target_os = \"fuchsia\")))]\n mod imp {\n-    use self::OsRngInner::*;\n-    use super::{next_u32, next_u64};\n-\n     use fs::File;\n-    use io;\n+    use io::Read;\n     use libc;\n-    use rand::Rng;\n-    use rand::reader::ReaderRng;\n     use sys::os::errno;\n \n     #[cfg(all(target_os = \"linux\",\n@@ -81,7 +73,7 @@ mod imp {\n                       target_arch = \"s390x\"))))]\n     fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }\n \n-    fn getrandom_fill_bytes(v: &mut [u8]) {\n+    fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n         let mut read = 0;\n         while read < v.len() {\n             let result = getrandom(&mut v[read..]);\n@@ -90,25 +82,16 @@ mod imp {\n                 if err == libc::EINTR {\n                     continue;\n                 } else if err == libc::EAGAIN {\n-                    // if getrandom() returns EAGAIN it would have blocked\n-                    // because the non-blocking pool (urandom) has not\n-                    // initialized in the kernel yet due to a lack of entropy\n-                    // the fallback we do here is to avoid blocking applications\n-                    // which could depend on this call without ever knowing\n-                    // they do and don't have a work around. The PRNG of\n-                    // /dev/urandom will still be used but not over a completely\n-                    // full entropy pool\n-                    let reader = File::open(\"/dev/urandom\").expect(\"Unable to open /dev/urandom\");\n-                    let mut reader_rng = ReaderRng::new(reader);\n-                    reader_rng.fill_bytes(&mut v[read..]);\n-                    read += v.len();\n+                    return false\n                 } else {\n                     panic!(\"unexpected getrandom error: {}\", err);\n                 }\n             } else {\n                 read += result as usize;\n             }\n         }\n+\n+        return true\n     }\n \n     #[cfg(all(target_os = \"linux\",\n@@ -120,6 +103,7 @@ mod imp {\n                   target_arch = \"powerpc64\",\n                   target_arch = \"s390x\")))]\n     fn is_getrandom_available() -> bool {\n+        use io;\n         use sync::atomic::{AtomicBool, Ordering};\n         use sync::Once;\n \n@@ -151,108 +135,47 @@ mod imp {\n                       target_arch = \"s390x\"))))]\n     fn is_getrandom_available() -> bool { false }\n \n-    pub struct OsRng {\n-        inner: OsRngInner,\n-    }\n-\n-    enum OsRngInner {\n-        OsGetrandomRng,\n-        OsReaderRng(ReaderRng<File>),\n-    }\n-\n-    impl OsRng {\n-        /// Create a new `OsRng`.\n-        pub fn new() -> io::Result<OsRng> {\n-            if is_getrandom_available() {\n-                return Ok(OsRng { inner: OsGetrandomRng });\n-            }\n-\n-            let reader = File::open(\"/dev/urandom\")?;\n-            let reader_rng = ReaderRng::new(reader);\n-\n-            Ok(OsRng { inner: OsReaderRng(reader_rng) })\n+    pub fn fill_bytes(v: &mut [u8]) {\n+        // getrandom_fill_bytes here can fail if getrandom() returns EAGAIN,\n+        // meaning it would have blocked because the non-blocking pool (urandom)\n+        // has not initialized in the kernel yet due to a lack of entropy the\n+        // fallback we do here is to avoid blocking applications which could\n+        // depend on this call without ever knowing they do and don't have a\n+        // work around.  The PRNG of /dev/urandom will still be used but not\n+        // over a completely full entropy pool\n+        if is_getrandom_available() && getrandom_fill_bytes(v) {\n+            return\n         }\n-    }\n \n-    impl Rng for OsRng {\n-        fn next_u32(&mut self) -> u32 {\n-            match self.inner {\n-                OsGetrandomRng => next_u32(&mut getrandom_fill_bytes),\n-                OsReaderRng(ref mut rng) => rng.next_u32(),\n-            }\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            match self.inner {\n-                OsGetrandomRng => next_u64(&mut getrandom_fill_bytes),\n-                OsReaderRng(ref mut rng) => rng.next_u64(),\n-            }\n-        }\n-        fn fill_bytes(&mut self, v: &mut [u8]) {\n-            match self.inner {\n-                OsGetrandomRng => getrandom_fill_bytes(v),\n-                OsReaderRng(ref mut rng) => rng.fill_bytes(v)\n-            }\n-        }\n+        let mut file = File::open(\"/dev/urandom\")\n+            .expect(\"failed to open /dev/urandom\");\n+        file.read_exact(v).expect(\"failed to read /dev/urandom\");\n     }\n }\n \n #[cfg(target_os = \"openbsd\")]\n mod imp {\n-    use super::{next_u32, next_u64};\n-\n-    use io;\n     use libc;\n     use sys::os::errno;\n-    use rand::Rng;\n-\n-    pub struct OsRng {\n-        // dummy field to ensure that this struct cannot be constructed outside\n-        // of this module\n-        _dummy: (),\n-    }\n-\n-    impl OsRng {\n-        /// Create a new `OsRng`.\n-        pub fn new() -> io::Result<OsRng> {\n-            Ok(OsRng { _dummy: () })\n-        }\n-    }\n \n-    impl Rng for OsRng {\n-        fn next_u32(&mut self) -> u32 {\n-            next_u32(&mut |v| self.fill_bytes(v))\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            next_u64(&mut |v| self.fill_bytes(v))\n-        }\n-        fn fill_bytes(&mut self, v: &mut [u8]) {\n-            // getentropy(2) permits a maximum buffer size of 256 bytes\n-            for s in v.chunks_mut(256) {\n-                let ret = unsafe {\n-                    libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len())\n-                };\n-                if ret == -1 {\n-                    panic!(\"unexpected getentropy error: {}\", errno());\n-                }\n+    pub fn fill_bytes(v: &mut [u8]) {\n+        // getentropy(2) permits a maximum buffer size of 256 bytes\n+        for s in v.chunks_mut(256) {\n+            let ret = unsafe {\n+                libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len())\n+            };\n+            if ret == -1 {\n+                panic!(\"unexpected getentropy error: {}\", errno());\n             }\n         }\n     }\n }\n \n #[cfg(target_os = \"ios\")]\n mod imp {\n-    use super::{next_u32, next_u64};\n-\n     use io;\n-    use ptr;\n-    use rand::Rng;\n     use libc::{c_int, size_t};\n-\n-    pub struct OsRng {\n-        // dummy field to ensure that this struct cannot be constructed outside\n-        // of this module\n-        _dummy: (),\n-    }\n+    use ptr;\n \n     enum SecRandom {}\n \n@@ -261,91 +184,48 @@ mod imp {\n \n     extern {\n         fn SecRandomCopyBytes(rnd: *const SecRandom,\n-                              count: size_t, bytes: *mut u8) -> c_int;\n+                              count: size_t,\n+                              bytes: *mut u8) -> c_int;\n     }\n \n-    impl OsRng {\n-        /// Create a new `OsRng`.\n-        pub fn new() -> io::Result<OsRng> {\n-            Ok(OsRng { _dummy: () })\n-        }\n-    }\n-\n-    impl Rng for OsRng {\n-        fn next_u32(&mut self) -> u32 {\n-            next_u32(&mut |v| self.fill_bytes(v))\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            next_u64(&mut |v| self.fill_bytes(v))\n-        }\n-        fn fill_bytes(&mut self, v: &mut [u8]) {\n-            let ret = unsafe {\n-                SecRandomCopyBytes(kSecRandomDefault, v.len(),\n-                                   v.as_mut_ptr())\n-            };\n-            if ret == -1 {\n-                panic!(\"couldn't generate random bytes: {}\",\n-                       io::Error::last_os_error());\n-            }\n+    pub fn fill_bytes(v: &mut [u8]) {\n+        let ret = unsafe {\n+            SecRandomCopyBytes(kSecRandomDefault,\n+                               v.len(),\n+                               v.as_mut_ptr())\n+        };\n+        if ret == -1 {\n+            panic!(\"couldn't generate random bytes: {}\",\n+                   io::Error::last_os_error());\n         }\n     }\n }\n \n #[cfg(target_os = \"freebsd\")]\n mod imp {\n-    use super::{next_u32, next_u64};\n-\n-    use io;\n     use libc;\n-    use rand::Rng;\n     use ptr;\n \n-    pub struct OsRng {\n-        // dummy field to ensure that this struct cannot be constructed outside\n-        // of this module\n-        _dummy: (),\n-    }\n-\n-    impl OsRng {\n-        /// Create a new `OsRng`.\n-        pub fn new() -> io::Result<OsRng> {\n-            Ok(OsRng { _dummy: () })\n-        }\n-    }\n-\n-    impl Rng for OsRng {\n-        fn next_u32(&mut self) -> u32 {\n-            next_u32(&mut |v| self.fill_bytes(v))\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            next_u64(&mut |v| self.fill_bytes(v))\n-        }\n-        fn fill_bytes(&mut self, v: &mut [u8]) {\n-            let mib = [libc::CTL_KERN, libc::KERN_ARND];\n-            // kern.arandom permits a maximum buffer size of 256 bytes\n-            for s in v.chunks_mut(256) {\n-                let mut s_len = s.len();\n-                let ret = unsafe {\n-                    libc::sysctl(mib.as_ptr(), mib.len() as libc::c_uint,\n-                                 s.as_mut_ptr() as *mut _, &mut s_len,\n-                                 ptr::null(), 0)\n-                };\n-                if ret == -1 || s_len != s.len() {\n-                    panic!(\"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n-                           ret, s.len(), s_len);\n-                }\n+    pub fn fill_bytes(v: &mut [u8]) {\n+        let mib = [libc::CTL_KERN, libc::KERN_ARND];\n+        // kern.arandom permits a maximum buffer size of 256 bytes\n+        for s in v.chunks_mut(256) {\n+            let mut s_len = s.len();\n+            let ret = unsafe {\n+                libc::sysctl(mib.as_ptr(), mib.len() as libc::c_uint,\n+                             s.as_mut_ptr() as *mut _, &mut s_len,\n+                             ptr::null(), 0)\n+            };\n+            if ret == -1 || s_len != s.len() {\n+                panic!(\"kern.arandom sysctl failed! (returned {}, s.len() {}, oldlenp {})\",\n+                       ret, s.len(), s_len);\n             }\n         }\n     }\n }\n \n #[cfg(target_os = \"fuchsia\")]\n mod imp {\n-    use super::{next_u32, next_u64};\n-\n-    use io;\n-    use rand::Rng;\n-\n     #[link(name = \"zircon\")]\n     extern {\n         fn zx_cprng_draw(buffer: *mut u8, len: usize, actual: *mut usize) -> i32;\n@@ -363,39 +243,18 @@ mod imp {\n         }\n     }\n \n-    pub struct OsRng {\n-        // dummy field to ensure that this struct cannot be constructed outside\n-        // of this module\n-        _dummy: (),\n-    }\n-\n-    impl OsRng {\n-        /// Create a new `OsRng`.\n-        pub fn new() -> io::Result<OsRng> {\n-            Ok(OsRng { _dummy: () })\n-        }\n-    }\n-\n-    impl Rng for OsRng {\n-        fn next_u32(&mut self) -> u32 {\n-            next_u32(&mut |v| self.fill_bytes(v))\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            next_u64(&mut |v| self.fill_bytes(v))\n-        }\n-        fn fill_bytes(&mut self, v: &mut [u8]) {\n-            let mut buf = v;\n-            while !buf.is_empty() {\n-                let ret = getrandom(buf);\n-                match ret {\n-                    Err(err) => {\n-                        panic!(\"kernel zx_cprng_draw call failed! (returned {}, buf.len() {})\",\n-                            err, buf.len())\n-                    }\n-                    Ok(actual) => {\n-                        let move_buf = buf;\n-                        buf = &mut move_buf[(actual as usize)..];\n-                    }\n+    pub fn fill_bytes(v: &mut [u8]) {\n+        let mut buf = v;\n+        while !buf.is_empty() {\n+            let ret = getrandom(buf);\n+            match ret {\n+                Err(err) => {\n+                    panic!(\"kernel zx_cprng_draw call failed! (returned {}, buf.len() {})\",\n+                        err, buf.len())\n+                }\n+                Ok(actual) => {\n+                    let move_buf = buf;\n+                    buf = &mut move_buf[(actual as usize)..];\n                 }\n             }\n         }"}, {"sha": "ab8e155331e84c743318c3084ebb32928a6c563a", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -17,6 +17,8 @@ use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n \n+pub use self::rand::hashmap_random_keys;\n+\n #[macro_use] pub mod compat;\n \n pub mod args;"}, {"sha": "f3b1185c6ea91d2532b3f88c32257d4afb85ccb5", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -15,11 +15,13 @@ use io;\n use mem;\n use path::Path;\n use ptr;\n-use rand::{self, Rng};\n use slice;\n+use sync::atomic::Ordering::SeqCst;\n+use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n use sys::c;\n use sys::fs::{File, OpenOptions};\n use sys::handle::Handle;\n+use sys::hashmap_random_keys;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Anonymous pipes\n@@ -71,10 +73,9 @@ pub fn anon_pipe(ours_readable: bool) -> io::Result<Pipes> {\n         let mut reject_remote_clients_flag = c::PIPE_REJECT_REMOTE_CLIENTS;\n         loop {\n             tries += 1;\n-            let key: u64 = rand::thread_rng().gen();\n             name = format!(r\"\\\\.\\pipe\\__rust_anonymous_pipe1__.{}.{}\",\n                            c::GetCurrentProcessId(),\n-                           key);\n+                           random_number());\n             let wide_name = OsStr::new(&name)\n                                   .encode_wide()\n                                   .chain(Some(0))\n@@ -156,6 +157,17 @@ pub fn anon_pipe(ours_readable: bool) -> io::Result<Pipes> {\n     }\n }\n \n+fn random_number() -> usize {\n+    static N: AtomicUsize = ATOMIC_USIZE_INIT;\n+    loop {\n+        if N.load(SeqCst) != 0 {\n+            return N.fetch_add(1, SeqCst)\n+        }\n+\n+        N.store(hashmap_random_keys().0 as usize, SeqCst);\n+    }\n+}\n+\n impl AnonPipe {\n     pub fn handle(&self) -> &Handle { &self.inner }\n     pub fn into_handle(self) -> Handle { self.inner }"}, {"sha": "262323656aa8ca01170ac7a7856cf38e7a37e898", "filename": "src/libstd/sys/windows/rand.rs", "status": "modified", "additions": 10, "deletions": 36, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frand.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -8,45 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use io;\n use mem;\n-use rand::Rng;\n use sys::c;\n \n-pub struct OsRng;\n-\n-impl OsRng {\n-    /// Create a new `OsRng`.\n-    pub fn new() -> io::Result<OsRng> {\n-        Ok(OsRng)\n-    }\n-}\n-\n-impl Rng for OsRng {\n-    fn next_u32(&mut self) -> u32 {\n-        let mut v = [0; 4];\n-        self.fill_bytes(&mut v);\n-        unsafe { mem::transmute(v) }\n-    }\n-\n-    fn next_u64(&mut self) -> u64 {\n-        let mut v = [0; 8];\n-        self.fill_bytes(&mut v);\n-        unsafe { mem::transmute(v) }\n-    }\n-\n-    fn fill_bytes(&mut self, v: &mut [u8]) {\n-        // RtlGenRandom takes an ULONG (u32) for the length so we need to\n-        // split up the buffer.\n-        for slice in v.chunks_mut(<c::ULONG>::max_value() as usize) {\n-            let ret = unsafe {\n-                c::RtlGenRandom(slice.as_mut_ptr(), slice.len() as c::ULONG)\n-            };\n-            if ret == 0 {\n-                panic!(\"couldn't generate random bytes: {}\",\n-                       io::Error::last_os_error());\n-            }\n-        }\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    let mut v = (0, 0);\n+    let ret = unsafe {\n+        c::RtlGenRandom(&mut v as *mut _ as *mut u8,\n+                        mem::size_of_val(&v) as c::ULONG)\n+    };\n+    if ret == 0 {\n+        panic!(\"couldn't generate random bytes: {}\",\n+               io::Error::last_os_error());\n     }\n+    return v\n }"}, {"sha": "d85717f8ce55e104419a2dd5543005b502bfc377", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc77b623d3072005f35e320e652f2b31695d493c/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc77b623d3072005f35e320e652f2b31695d493c/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=fc77b623d3072005f35e320e652f2b31695d493c", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rand)]\n-\n-// ensure that the ThreadRng isn't/doesn't become accidentally sendable.\n-\n-use std::__rand::ThreadRng;\n-\n-fn test_send<S: Send>() {}\n-\n-pub fn main() {\n-    test_send::<ThreadRng>(); //~ ERROR std::marker::Send` is not satisfied\n-}"}, {"sha": "6139a7d3201c5193d46e5381b6525b47349846d0", "filename": "src/test/run-pass-fulldeps/binary-heap-panic-safe.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Ftest%2Frun-pass-fulldeps%2Fbinary-heap-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Ftest%2Frun-pass-fulldeps%2Fbinary-heap-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fbinary-heap-panic-safe.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rand, std_panic)]\n+#![feature(rustc_private, std_panic)]\n \n-use std::__rand::{thread_rng, Rng};\n+extern crate rand;\n+\n+use rand::{thread_rng, Rng};\n use std::panic::{self, AssertUnwindSafe};\n \n use std::collections::BinaryHeap;", "previous_filename": "src/test/run-pass/binary-heap-panic-safe.rs"}, {"sha": "cf2ea732ee1b8a864f6ea39f14245ce661251c22", "filename": "src/test/run-pass-fulldeps/env.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Ftest%2Frun-pass-fulldeps%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Ftest%2Frun-pass-fulldeps%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fenv.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -10,14 +10,15 @@\n \n // compile-flags: --test\n \n-#![feature(rand, std_panic)]\n+#![feature(rustc_private, std_panic)]\n+\n+extern crate rand;\n \n use std::env::*;\n-use std::__rand as rand;\n-use std::__rand::Rng;\n use std::iter::repeat;\n use std::ffi::{OsString, OsStr};\n \n+use rand::Rng;\n \n fn make_rand_name() -> OsString {\n     let mut rng = rand::thread_rng();", "previous_filename": "src/test/run-pass/env.rs"}, {"sha": "82305045f801fbd2ad48e5a9690bc852e6b20bc7", "filename": "src/test/run-pass-fulldeps/vector-sort-panic-safe.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs?ref=6bc8f164b09b9994e6a2d4c4ca60d7d36c09d3fe", "patch": "@@ -10,11 +10,13 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(rand)]\n+#![feature(rustc_private)]\n #![feature(sort_unstable)]\n #![feature(const_atomic_usize_new)]\n \n-use std::__rand::{thread_rng, Rng};\n+extern crate rand;\n+\n+use rand::{thread_rng, Rng};\n use std::cell::Cell;\n use std::cmp::Ordering;\n use std::panic;", "previous_filename": "src/test/run-pass/vector-sort-panic-safe.rs"}]}