{"sha": "fbb9d69758b71b6eb1f9e039c968d9ad9f11370b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYjlkNjk3NThiNzFiNmViMWY5ZTAzOWM5NjhkOWFkOWYxMTM3MGI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-04T13:50:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-04T13:50:02Z"}, "message": "feat: always prefer postfix snippets if there's exact textual match\n\nNote that, while we don't currently have a fuzzy-matching score, it\nmakes sense to special-case postfix templates -- it's very annoying when\n`.not()` gets sorted before `.not`. We might want to move this infra to\nfuzzy matching, once we have that!", "tree": {"sha": "971783f78cf013986d5c467c4d51323ed467e962", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/971783f78cf013986d5c467c4d51323ed467e962"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b", "html_url": "https://github.com/rust-lang/rust/commit/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030217d573691f36c34fb3664e13a441e23aafa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/030217d573691f36c34fb3664e13a441e23aafa0", "html_url": "https://github.com/rust-lang/rust/commit/030217d573691f36c34fb3664e13a441e23aafa0"}], "stats": {"total": 128, "additions": 105, "deletions": 23}, "files": [{"sha": "aaa346eeae9aa0d5cf807130ca7706308fff88b0", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=fbb9d69758b71b6eb1f9e039c968d9ad9f11370b", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     context::CompletionContext,\n     item::{Builder, CompletionKind},\n     patterns::ImmediateLocation,\n-    CompletionItem, CompletionItemKind, Completions,\n+    CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n \n pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -299,6 +299,12 @@ fn postfix_snippet(\n     };\n     let mut item = CompletionItem::new(CompletionKind::Postfix, ctx.source_range(), label);\n     item.detail(detail).kind(CompletionItemKind::Snippet).snippet_edit(cap, edit);\n+    if ctx.original_token.text() == label {\n+        let mut relevance = CompletionRelevance::default();\n+        relevance.exact_postfix_snippet_match = true;\n+        item.set_relevance(relevance);\n+    }\n+\n     item\n }\n "}, {"sha": "96d3fcf5916bf39a72f4b42cbf946fcd5389f0df", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=fbb9d69758b71b6eb1f9e039c968d9ad9f11370b", "patch": "@@ -144,6 +144,15 @@ pub struct CompletionRelevance {\n     /// }\n     /// ```\n     pub is_local: bool,\n+    /// This is set in cases like these:\n+    ///\n+    /// ```\n+    /// (a > b).not$0\n+    /// ```\n+    ///\n+    /// Basically, we want to guarantee that postfix snippets always takes\n+    /// precedence over everything else.\n+    pub exact_postfix_snippet_match: bool,\n }\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq)]\n@@ -194,7 +203,9 @@ impl CompletionRelevance {\n         if self.is_local {\n             score += 1;\n         }\n-\n+        if self.exact_postfix_snippet_match {\n+            score += 100;\n+        }\n         score\n     }\n \n@@ -598,6 +609,13 @@ mod tests {\n                 exact_name_match: true,\n                 type_match: Some(CompletionRelevanceTypeMatch::Exact),\n                 is_local: true,\n+                ..CompletionRelevance::default()\n+            }],\n+            vec![CompletionRelevance {\n+                exact_name_match: false,\n+                type_match: None,\n+                is_local: false,\n+                exact_postfix_snippet_match: true,\n             }],\n         ];\n "}, {"sha": "3ee6831dc8b8e149eb949bbf8f261cc7f9b9f2f7", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=fbb9d69758b71b6eb1f9e039c968d9ad9f11370b", "patch": "@@ -339,32 +339,22 @@ mod tests {\n         CompletionKind, CompletionRelevance,\n     };\n \n+    #[track_caller]\n     fn check(ra_fixture: &str, expect: Expect) {\n         let actual = do_completion(ra_fixture, CompletionKind::Reference);\n         expect.assert_debug_eq(&actual);\n     }\n \n+    #[track_caller]\n     fn check_relevance(ra_fixture: &str, expect: Expect) {\n-        fn display_relevance(relevance: CompletionRelevance) -> String {\n-            let relevance_factors = vec![\n-                (relevance.type_match == Some(CompletionRelevanceTypeMatch::Exact), \"type\"),\n-                (\n-                    relevance.type_match == Some(CompletionRelevanceTypeMatch::CouldUnify),\n-                    \"type_could_unify\",\n-                ),\n-                (relevance.exact_name_match, \"name\"),\n-                (relevance.is_local, \"local\"),\n-            ]\n-            .into_iter()\n-            .filter_map(|(cond, desc)| if cond { Some(desc) } else { None })\n-            .join(\"+\");\n-\n-            format!(\"[{}]\", relevance_factors)\n-        }\n+        check_relevance_for_kinds(&[CompletionKind::Reference], ra_fixture, expect)\n+    }\n \n+    #[track_caller]\n+    fn check_relevance_for_kinds(kinds: &[CompletionKind], ra_fixture: &str, expect: Expect) {\n         let actual = get_all_items(TEST_CONFIG, ra_fixture)\n             .into_iter()\n-            .filter(|it| it.completion_kind == CompletionKind::Reference)\n+            .filter(|it| kinds.contains(&it.completion_kind))\n             .flat_map(|it| {\n                 let mut items = vec![];\n \n@@ -384,6 +374,24 @@ mod tests {\n             .collect::<String>();\n \n         expect.assert_eq(&actual);\n+\n+        fn display_relevance(relevance: CompletionRelevance) -> String {\n+            let relevance_factors = vec![\n+                (relevance.type_match == Some(CompletionRelevanceTypeMatch::Exact), \"type\"),\n+                (\n+                    relevance.type_match == Some(CompletionRelevanceTypeMatch::CouldUnify),\n+                    \"type_could_unify\",\n+                ),\n+                (relevance.exact_name_match, \"name\"),\n+                (relevance.is_local, \"local\"),\n+                (relevance.exact_postfix_snippet_match, \"snippet\"),\n+            ]\n+            .into_iter()\n+            .filter_map(|(cond, desc)| if cond { Some(desc) } else { None })\n+            .join(\"+\");\n+\n+            format!(\"[{}]\", relevance_factors)\n+        }\n     }\n \n     #[test]\n@@ -528,6 +536,7 @@ fn main() { let _: m::Spam = S$0 }\n                                 Exact,\n                             ),\n                             is_local: false,\n+                            exact_postfix_snippet_match: false,\n                         },\n                         trigger_call_info: true,\n                     },\n@@ -556,6 +565,7 @@ fn main() { let _: m::Spam = S$0 }\n                                 Exact,\n                             ),\n                             is_local: false,\n+                            exact_postfix_snippet_match: false,\n                         },\n                     },\n                     CompletionItem {\n@@ -649,6 +659,7 @@ fn foo() { A { the$0 } }\n                                 CouldUnify,\n                             ),\n                             is_local: false,\n+                            exact_postfix_snippet_match: false,\n                         },\n                     },\n                 ]\n@@ -1339,4 +1350,44 @@ fn foo() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn postfix_completion_relevance() {\n+        check_relevance_for_kinds(\n+            &[CompletionKind::Postfix, CompletionKind::Magic],\n+            r#\"\n+mod ops {\n+    pub trait Not {\n+        type Output;\n+        fn not(self) -> Self::Output;\n+    }\n+\n+    impl Not for bool {\n+        type Output = bool;\n+        fn not(self) -> bool { if self { false } else { true }}\n+    }\n+}\n+\n+fn main() {\n+    let _: bool = (9 > 2).not$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                sn if []\n+                sn while []\n+                sn not [snippet]\n+                sn ref []\n+                sn refm []\n+                sn match []\n+                sn box []\n+                sn ok []\n+                sn err []\n+                sn some []\n+                sn dbg []\n+                sn dbgr []\n+                sn call []\n+                me not() (ops::Not) [type_could_unify]\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "7b951b4e93cd3c1fc97e9f6fcbbcf91fe6475fe3", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbb9d69758b71b6eb1f9e039c968d9ad9f11370b/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=fbb9d69758b71b6eb1f9e039c968d9ad9f11370b", "patch": "@@ -195,6 +195,7 @@ pub(crate) fn completion_items(\n     tdpp: lsp_types::TextDocumentPositionParams,\n     items: Vec<CompletionItem>,\n ) -> Vec<lsp_types::CompletionItem> {\n+    let max_relevance = items.iter().map(|it| it.relevance().score()).max().unwrap_or_default();\n     let mut res = Vec::with_capacity(items.len());\n     for item in items {\n         completion_item(\n@@ -203,6 +204,7 @@ pub(crate) fn completion_items(\n             enable_imports_on_the_fly,\n             line_index,\n             &tdpp,\n+            max_relevance,\n             item,\n         )\n     }\n@@ -215,6 +217,7 @@ fn completion_item(\n     enable_imports_on_the_fly: bool,\n     line_index: &LineIndex,\n     tdpp: &lsp_types::TextDocumentPositionParams,\n+    max_relevance: u32,\n     item: CompletionItem,\n ) {\n     let mut additional_text_edits = Vec::new();\n@@ -259,7 +262,7 @@ fn completion_item(\n         ..Default::default()\n     };\n \n-    set_score(&mut lsp_item, item.relevance());\n+    set_score(&mut lsp_item, max_relevance, item.relevance());\n \n     if item.deprecated() {\n         lsp_item.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n@@ -288,7 +291,7 @@ fn completion_item(\n \n     if let Some((mutability, relevance)) = item.ref_match() {\n         let mut lsp_item_with_ref = lsp_item.clone();\n-        set_score(&mut lsp_item_with_ref, relevance);\n+        set_score(&mut lsp_item_with_ref, max_relevance, relevance);\n         lsp_item_with_ref.label =\n             format!(\"&{}{}\", mutability.as_keyword_for_ref(), lsp_item_with_ref.label);\n         if let Some(it) = &mut lsp_item_with_ref.text_edit {\n@@ -304,8 +307,12 @@ fn completion_item(\n \n     acc.push(lsp_item);\n \n-    fn set_score(res: &mut lsp_types::CompletionItem, relevance: CompletionRelevance) {\n-        if relevance.is_relevant() {\n+    fn set_score(\n+        res: &mut lsp_types::CompletionItem,\n+        max_relevance: u32,\n+        relevance: CompletionRelevance,\n+    ) {\n+        if relevance.is_relevant() && relevance.score() == max_relevance {\n             res.preselect = Some(true);\n         }\n         // The relevance needs to be inverted to come up with a sort score"}]}