{"sha": "3a62f87b78b27f965fa7f158a49db553c2107c7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNjJmODdiNzhiMjdmOTY1ZmE3ZjE1OGE0OWRiNTUzYzIxMDdjN2U=", "commit": {"author": {"name": "ray glover", "email": "ray@rayglover.net", "date": "2015-05-05T23:15:04Z"}, "committer": {"name": "ray glover", "email": "ray@rayglover.net", "date": "2015-05-09T00:04:43Z"}, "message": "Perf improvements to `collections::BitSet`.", "tree": {"sha": "6432074dd36ec801783a8363b71227a42cc6e776", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6432074dd36ec801783a8363b71227a42cc6e776"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a62f87b78b27f965fa7f158a49db553c2107c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a62f87b78b27f965fa7f158a49db553c2107c7e", "html_url": "https://github.com/rust-lang/rust/commit/3a62f87b78b27f965fa7f158a49db553c2107c7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a62f87b78b27f965fa7f158a49db553c2107c7e/comments", "author": {"login": "rayglover-ibm", "id": 19191468, "node_id": "MDQ6VXNlcjE5MTkxNDY4", "avatar_url": "https://avatars.githubusercontent.com/u/19191468?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rayglover-ibm", "html_url": "https://github.com/rayglover-ibm", "followers_url": "https://api.github.com/users/rayglover-ibm/followers", "following_url": "https://api.github.com/users/rayglover-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rayglover-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rayglover-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rayglover-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rayglover-ibm/orgs", "repos_url": "https://api.github.com/users/rayglover-ibm/repos", "events_url": "https://api.github.com/users/rayglover-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rayglover-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rayglover-ibm", "id": 19191468, "node_id": "MDQ6VXNlcjE5MTkxNDY4", "avatar_url": "https://avatars.githubusercontent.com/u/19191468?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rayglover-ibm", "html_url": "https://github.com/rayglover-ibm", "followers_url": "https://api.github.com/users/rayglover-ibm/followers", "following_url": "https://api.github.com/users/rayglover-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rayglover-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rayglover-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rayglover-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rayglover-ibm/orgs", "repos_url": "https://api.github.com/users/rayglover-ibm/repos", "events_url": "https://api.github.com/users/rayglover-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rayglover-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "551a74dddd84cf01440ee84148ebd18bc68bd7c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/551a74dddd84cf01440ee84148ebd18bc68bd7c8", "html_url": "https://github.com/rust-lang/rust/commit/551a74dddd84cf01440ee84148ebd18bc68bd7c8"}], "stats": {"total": 152, "additions": 77, "deletions": 75}, "files": [{"sha": "05b7ca750c40fff6189f164c996b194ad041a311", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 77, "deletions": 75, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/3a62f87b78b27f965fa7f158a49db553c2107c7e/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a62f87b78b27f965fa7f158a49db553c2107c7e/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=3a62f87b78b27f965fa7f158a49db553c2107c7e", "patch": "@@ -1451,8 +1451,8 @@ impl BitSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> bit_set::Iter {\n-        SetIter {set: self, next_idx: 0}\n+    pub fn iter<'a>(&'a self) -> bit_set::Iter<'a> {\n+        SetIter(BlockIter::from_blocks(self.bit_vec.blocks()))\n     }\n \n     /// Iterator over each u32 stored in `self` union `other`.\n@@ -1477,13 +1477,11 @@ impl BitSet {\n     pub fn union<'a>(&'a self, other: &'a BitSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n-        Union(TwoBitPositions {\n-            set: self,\n-            other: other,\n+        Union(BlockIter::from_blocks(TwoBitPositions {\n+            set: self.bit_vec.blocks(),\n+            other: other.bit_vec.blocks(),\n             merge: or,\n-            current_word: 0,\n-            next_idx: 0\n-        })\n+        }))\n     }\n \n     /// Iterator over each usize stored in `self` intersect `other`.\n@@ -1508,13 +1506,12 @@ impl BitSet {\n     pub fn intersection<'a>(&'a self, other: &'a BitSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n         let min = cmp::min(self.bit_vec.len(), other.bit_vec.len());\n-        Intersection(TwoBitPositions {\n-            set: self,\n-            other: other,\n+\n+        Intersection(BlockIter::from_blocks(TwoBitPositions {\n+            set: self.bit_vec.blocks(),\n+            other: other.bit_vec.blocks(),\n             merge: bitand,\n-            current_word: 0,\n-            next_idx: 0\n-        }.take(min))\n+        }).take(min))\n     }\n \n     /// Iterator over each usize stored in the `self` setminus `other`.\n@@ -1546,13 +1543,11 @@ impl BitSet {\n     pub fn difference<'a>(&'a self, other: &'a BitSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n-        Difference(TwoBitPositions {\n-            set: self,\n-            other: other,\n+        Difference(BlockIter::from_blocks(TwoBitPositions {\n+            set: self.bit_vec.blocks(),\n+            other: other.bit_vec.blocks(),\n             merge: diff,\n-            current_word: 0,\n-            next_idx: 0\n-        })\n+        }))\n     }\n \n     /// Iterator over each u32 stored in the symmetric difference of `self` and `other`.\n@@ -1578,13 +1573,11 @@ impl BitSet {\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n-        SymmetricDifference(TwoBitPositions {\n-            set: self,\n-            other: other,\n+        SymmetricDifference(BlockIter::from_blocks(TwoBitPositions {\n+            set: self.bit_vec.blocks(),\n+            other: other.bit_vec.blocks(),\n             merge: bitxor,\n-            current_word: 0,\n-            next_idx: 0\n-        })\n+        }))\n     }\n \n     /// Unions in-place with the specified other bit vector.\n@@ -1808,98 +1801,107 @@ impl hash::Hash for BitSet {\n     }\n }\n \n-/// An iterator for `BitSet`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SetIter<'a> {\n-    set: &'a BitSet,\n-    next_idx: usize\n+struct BlockIter<T> where\n+    T: Iterator<Item=u32> {\n+    head: u32,\n+    head_offset: usize,\n+    tail: T\n+}\n+impl<'a, T> BlockIter<T> where\n+    T: Iterator<Item=u32> {\n+    fn from_blocks(mut blocks: T) -> BlockIter<T> {\n+        let h = blocks.next().unwrap_or(0);\n+        BlockIter {tail: blocks, head: h, head_offset: 0}\n+    }\n }\n \n /// An iterator combining two `BitSet` iterators.\n #[derive(Clone)]\n struct TwoBitPositions<'a> {\n-    set: &'a BitSet,\n-    other: &'a BitSet,\n+    set: Blocks<'a>,\n+    other: Blocks<'a>,\n     merge: fn(u32, u32) -> u32,\n-    current_word: u32,\n-    next_idx: usize\n }\n \n+/// An iterator for `BitSet`.\n+#[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SetIter<'a>(BlockIter<Blocks<'a>>);\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a>(TwoBitPositions<'a>);\n+pub struct Union<'a>(BlockIter<TwoBitPositions<'a>>);\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);\n+pub struct Intersection<'a>(Take<BlockIter<TwoBitPositions<'a>>>);\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Difference<'a>(TwoBitPositions<'a>);\n+pub struct Difference<'a>(BlockIter<TwoBitPositions<'a>>);\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n+pub struct SymmetricDifference<'a>(BlockIter<TwoBitPositions<'a>>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for SetIter<'a> {\n+impl<'a, T> Iterator for BlockIter<T> where T: Iterator<Item=u32> {\n     type Item = usize;\n \n     fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bit_vec.len() {\n-            let idx = self.next_idx;\n-            self.next_idx += 1;\n-\n-            if self.set.contains(&idx) {\n-                return Some(idx);\n+        while self.head == 0 {\n+            match self.tail.next() {\n+                Some(w) => self.head = w,\n+                _ => return None\n             }\n+            self.head_offset += u32::BITS;\n         }\n \n-        return None;\n+        let t = self.head & !self.head + 1;\n+        // remove the least significant bit\n+        self.head &= self.head - 1;\n+        // return index of lsb\n+        Some(self.head_offset + (u32::count_ones(t-1) as usize))\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.set.bit_vec.len() - self.next_idx))\n+        match self.tail.size_hint() {\n+            (_, Some(h)) => (0, Some(1 + h * (u32::BITS as usize))),\n+            _ => (0, None)\n+        }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for TwoBitPositions<'a> {\n-    type Item = usize;\n-\n-    fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bit_vec.len() ||\n-              self.next_idx < self.other.bit_vec.len() {\n-            let bit_idx = self.next_idx % u32::BITS;\n-            if bit_idx == 0 {\n-                let s_bit_vec = &self.set.bit_vec;\n-                let o_bit_vec = &self.other.bit_vec;\n-                // Merging the two words is a bit of an awkward dance since\n-                // one BitVec might be longer than the other\n-                let word_idx = self.next_idx / u32::BITS;\n-                let w1 = if word_idx < s_bit_vec.storage.len() {\n-                             s_bit_vec.storage[word_idx]\n-                         } else { 0 };\n-                let w2 = if word_idx < o_bit_vec.storage.len() {\n-                             o_bit_vec.storage[word_idx]\n-                         } else { 0 };\n-                self.current_word = (self.merge)(w1, w2);\n-            }\n-\n-            self.next_idx += 1;\n-            if self.current_word & (1 << bit_idx) != 0 {\n-                return Some(self.next_idx - 1);\n-            }\n+    type Item = u32;\n+\n+    fn next(&mut self) -> Option<u32> {\n+        match (self.set.next(), self.other.next()) {\n+            (Some(a), Some(b)) => Some((self.merge)(a, b)),\n+            (Some(a), None) => Some((self.merge)(a, 0)),\n+            (None, Some(b)) => Some((self.merge)(0, b)),\n+            _ => return None\n         }\n-        return None;\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let cap = cmp::max(self.set.bit_vec.len(), self.other.bit_vec.len());\n-        (0, Some(cap - self.next_idx))\n+        let (a, al) = self.set.size_hint();\n+        let (b, bl) = self.set.size_hint();\n+\n+        assert_eq!(a, b);\n+        (a, cmp::max(al, bl))\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for SetIter<'a> {\n+    type Item = usize;\n+\n+    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Union<'a> {\n     type Item = usize;"}]}