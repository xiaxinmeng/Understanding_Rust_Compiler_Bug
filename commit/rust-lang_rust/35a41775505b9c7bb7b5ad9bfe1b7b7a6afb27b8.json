{"sha": "35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YTQxNzc1NTA1YjljN2JiN2I1YWQ5YmZlMWI3YjdhNmFmYjI3Yjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-27T19:44:55Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-27T19:45:19Z"}, "message": "Extend aliasability check to uncover `& &mut &mut` and the like", "tree": {"sha": "73cb65a1c09e9edf43055c4b5443173f869b8f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73cb65a1c09e9edf43055c4b5443173f869b8f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8", "html_url": "https://github.com/rust-lang/rust/commit/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b23d20452ef7c2d2eb79baf074bcda04fad9a66", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b23d20452ef7c2d2eb79baf074bcda04fad9a66", "html_url": "https://github.com/rust-lang/rust/commit/6b23d20452ef7c2d2eb79baf074bcda04fad9a66"}], "stats": {"total": 105, "additions": 87, "deletions": 18}, "files": [{"sha": "70a71f8ad9f3e4b23efd27f7b4d38d2c1c547d5b", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8", "patch": "@@ -391,15 +391,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                 mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n-                    match b.freely_aliasable() {\n-                        None => {}\n-                        Some(cause) => {\n-                            this.bccx.report_aliasability_violation(\n-                                expr.span,\n-                                MutabilityViolation,\n-                                cause);\n-                        }\n-                    }\n+                    check_for_aliasability_violation(this, expr, b);\n                 }\n \n                 mc::cat_deref(_, deref_count, mc::gc_ptr(ast::m_mutbl)) => {\n@@ -419,6 +411,52 @@ impl<'self> CheckLoanCtxt<'self> {\n             return true; // no errors reported\n         }\n \n+        fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n+                                            expr: @ast::expr,\n+                                            cmt: mc::cmt) -> bool {\n+            let mut cmt = cmt;\n+\n+            loop {\n+                match cmt.cat {\n+                    mc::cat_deref(b, _, mc::region_ptr(m_mutbl, _)) |\n+                    mc::cat_downcast(b) |\n+                    mc::cat_stack_upvar(b) |\n+                    mc::cat_deref(b, _, mc::uniq_ptr) |\n+                    mc::cat_interior(b, _) |\n+                    mc::cat_discr(b, _) => {\n+                        // Aliasability depends on base cmt\n+                        cmt = b;\n+                    }\n+\n+                    mc::cat_copied_upvar(_) |\n+                    mc::cat_rvalue(*) |\n+                    mc::cat_local(*) |\n+                    mc::cat_arg(_) |\n+                    mc::cat_self(*) |\n+                    mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n+                    mc::cat_static_item(*) |\n+                    mc::cat_implicit_self(*) |\n+                    mc::cat_deref(_, _, mc::gc_ptr(_)) |\n+                    mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n+                    mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) => {\n+                        // Aliasability is independent of base cmt\n+                        match cmt.freely_aliasable() {\n+                            None => {\n+                                return true;\n+                            }\n+                            Some(cause) => {\n+                                this.bccx.report_aliasability_violation(\n+                                    expr.span,\n+                                    MutabilityViolation,\n+                                    cause);\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         fn check_for_assignment_to_restricted_or_frozen_location(\n             this: &CheckLoanCtxt,\n             expr: @ast::expr,"}, {"sha": "c38677adfbfa5b34488ae97d8f8b1725417354b2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8", "patch": "@@ -1146,9 +1146,10 @@ impl cmt_ {\n     }\n \n     pub fn freely_aliasable(&self) -> Option<AliasableReason> {\n-        //! True if this lvalue resides in an area that is\n-        //! freely aliasable, meaning that rustc cannot track\n-        //! the alias//es with precision.\n+        /*!\n+         * Returns `Some(_)` if this lvalue represents a freely aliasable\n+         * pointer type.\n+         */\n \n         // Maybe non-obvious: copied upvars can only be considered\n         // non-aliasable in once closures, since any other kind can be\n@@ -1180,12 +1181,12 @@ impl cmt_ {\n                 Some(AliasableBorrowed(m))\n             }\n \n-            cat_downcast(b) |\n-            cat_stack_upvar(b) |\n-            cat_deref(b, _, uniq_ptr) |\n-            cat_interior(b, _) |\n-            cat_discr(b, _) => {\n-                b.freely_aliasable()\n+            cat_downcast(*) |\n+            cat_stack_upvar(*) |\n+            cat_deref(_, _, uniq_ptr) |\n+            cat_interior(*) |\n+            cat_discr(*) => {\n+                None\n             }\n         }\n     }"}, {"sha": "e4a23e74a12f2e2ada202eabff1d1828103eecc8", "filename": "src/test/compile-fail/borrowck-assign-to-andmut-in-aliasable-loc.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs?ref=35a41775505b9c7bb7b5ad9bfe1b7b7a6afb27b8", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that assignments to an `&mut` pointer which is found in a\n+// borrowed (but otherwise non-aliasable) location is illegal.\n+\n+struct S<'self> {\n+    pointer: &'self mut int\n+}\n+\n+fn a(s: &S) {\n+    *s.pointer += 1; //~ ERROR cannot assign\n+}\n+\n+fn b(s: &mut S) {\n+    *s.pointer += 1;\n+}\n+\n+fn c(s: & &mut S) {\n+    *s.pointer += 1; //~ ERROR cannot assign\n+}\n+\n+fn main() {}"}]}