{"sha": "d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0OGY0OGY2MWY5OTY0NzhlOTcyZTJkZDZmMzA3MGVhZjNlZDQ1ZDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-12-22T21:39:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-06T02:05:51Z"}, "message": "Refactor compiler to make use of dep-tracking-maps. Also, in cases where\nwe were using interior mutability (RefCells, TyIvar), add some reads/writes.", "tree": {"sha": "33447c9eddb5aeb46cc35a3fcd3e41f050eacfa8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33447c9eddb5aeb46cc35a3fcd3e41f050eacfa8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "html_url": "https://github.com/rust-lang/rust/commit/d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d9dd7cf33dc252b3b914125a2025435783df096", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9dd7cf33dc252b3b914125a2025435783df096", "html_url": "https://github.com/rust-lang/rust/commit/5d9dd7cf33dc252b3b914125a2025435783df096"}], "stats": {"total": 827, "additions": 511, "deletions": 316}, "files": [{"sha": "501c1aff320635bc87c8573c9ffa3d216a4dd78a", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -13,6 +13,7 @@ use std::cell::RefCell;\n use std::ops::Index;\n use std::hash::Hash;\n use std::marker::PhantomData;\n+use util::common::MemoizationMap;\n \n use super::{DepNode, DepGraph};\n \n@@ -70,6 +71,61 @@ impl<M: DepTrackingMapId> DepTrackingMap<M> {\n     }\n }\n \n+impl<M: DepTrackingMapId> MemoizationMap for RefCell<DepTrackingMap<M>> {\n+    type Key = M::Key;\n+    type Value = M::Value;\n+\n+    /// Memoizes an entry in the dep-tracking-map. If the entry is not\n+    /// already present, then `op` will be executed to compute its value.\n+    /// The resulting dependency graph looks like this:\n+    ///\n+    ///     [op] -> Map(key) -> CurrentTask\n+    ///\n+    /// Here, `[op]` represents whatever nodes `op` reads in the\n+    /// course of execution; `Map(key)` represents the node for this\n+    /// map; and `CurrentTask` represents the current task when\n+    /// `memoize` is invoked.\n+    ///\n+    /// **Important:* when `op` is invoked, the current task will be\n+    /// switched to `Map(key)`. Therefore, if `op` makes use of any\n+    /// HIR nodes or shared state accessed through its closure\n+    /// environment, it must explicitly read that state. As an\n+    /// example, see `type_scheme_of_item` in `collect`, which looks\n+    /// something like this:\n+    ///\n+    /// ```\n+    /// fn type_scheme_of_item(..., item: &hir::Item) -> ty::TypeScheme<'tcx> {\n+    ///     let item_def_id = ccx.tcx.map.local_def_id(it.id);\n+    ///     ccx.tcx.tcache.memoized(item_def_id, || {\n+    ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n+    ///         compute_type_scheme_of_item(ccx, item)\n+    ///     });\n+    /// }\n+    /// ```\n+    ///\n+    /// The key is the line marked `(*)`: the closure implicitly\n+    /// accesses the body of the item `item`, so we register a read\n+    /// from `Hir(item_def_id)`.\n+    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n+        where OP: FnOnce() -> M::Value\n+    {\n+        let graph;\n+        {\n+            let this = self.borrow();\n+            if let Some(result) = this.map.get(&key) {\n+                this.read(&key);\n+                return result.clone();\n+            }\n+            graph = this.graph.clone();\n+        }\n+\n+        let _task = graph.in_task(M::to_dep_node(&key));\n+        let result = op();\n+        self.borrow_mut().map.insert(key, result.clone());\n+        result\n+    }\n+}\n+\n impl<'k, M: DepTrackingMapId> Index<&'k M::Key> for DepTrackingMap<M> {\n     type Output = M::Value;\n "}, {"sha": "619201a4a9feb016742b05116520c29ca9974f7d", "filename": "src/librustc/middle/ty/contents.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -10,7 +10,7 @@\n \n use middle::def_id::{DefId};\n use middle::ty::{self, Ty};\n-use util::common::{memoized};\n+use util::common::MemoizationMap;\n use util::nodemap::FnvHashMap;\n \n use std::fmt;\n@@ -141,9 +141,7 @@ impl fmt::Debug for TypeContents {\n \n impl<'tcx> ty::TyS<'tcx> {\n     pub fn type_contents(&'tcx self, cx: &ty::ctxt<'tcx>) -> TypeContents {\n-        return memoized(&cx.tc_cache, self, |ty| {\n-            tc_ty(cx, ty, &mut FnvHashMap())\n-        });\n+        return cx.tc_cache.memoize(self, || tc_ty(cx, self, &mut FnvHashMap()));\n \n         fn tc_ty<'tcx>(cx: &ty::ctxt<'tcx>,\n                        ty: Ty<'tcx>,"}, {"sha": "8f313120c9de65dd4d2148f1b579eae169cd6c92", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 86, "deletions": 26, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -30,10 +30,12 @@ use middle::traits;\n use middle::ty::{self, TraitRef, Ty, TypeAndMut};\n use middle::ty::{TyS, TypeVariants};\n use middle::ty::{AdtDef, ClosureSubsts, ExistentialBounds, Region};\n-use middle::ty::{FreevarMap, GenericPredicates};\n+use middle::ty::{FreevarMap};\n use middle::ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n use middle::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use middle::ty::TypeVariants::*;\n+use middle::ty::maps;\n+use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::FnvHashMap;\n \n@@ -248,57 +250,78 @@ pub struct ctxt<'tcx> {\n     pub tables: RefCell<Tables<'tcx>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    pub impl_or_trait_items: RefCell<DefIdMap<ty::ImplOrTraitItem<'tcx>>>,\n+    pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n \n     /// Maps from a trait def-id to a list of the def-ids of its trait items\n-    pub trait_item_def_ids: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItemId>>>>,\n+    pub trait_item_def_ids: RefCell<DepTrackingMap<maps::TraitItemDefIds<'tcx>>>,\n \n-    /// A cache for the trait_items() routine\n-    pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItem<'tcx>>>>>,\n+    /// A cache for the trait_items() routine; note that the routine\n+    /// itself pushes the `TraitItems` dependency node. This cache is\n+    /// \"encapsulated\" and thus does not need to be itself tracked.\n+    trait_items_cache: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItem<'tcx>>>>>,\n \n-    pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n-    pub trait_defs: RefCell<DefIdMap<&'tcx ty::TraitDef<'tcx>>>,\n-    pub adt_defs: RefCell<DefIdMap<ty::AdtDefMaster<'tcx>>>,\n+    pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n+    pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n+    pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated predicates.\n-    pub predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+    pub predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    pub super_predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+    pub super_predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n     pub map: ast_map::Map<'tcx>,\n+\n+    // Records the free variables refrenced by every closure\n+    // expression. Do not track deps for this, just recompute it from\n+    // scratch every time.\n     pub freevars: RefCell<FreevarMap>,\n-    pub tcache: RefCell<DefIdMap<ty::TypeScheme<'tcx>>>,\n+\n+    // Records the type of every item.\n+    pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n+\n+    // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FnvHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+\n+    // Cache for the type-contents routine. FIXME -- track deps?\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n+\n+    // Cache for various types within a method body and so forth.\n+    //\n+    // FIXME this should be made local to typeck, but it is currently used by one lint\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n+\n+    // FIXME no dep tracking, but we should be able to remove this\n     pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n+\n+    // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+\n     pub lang_items: middle::lang_items::LanguageItems,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    pub item_variance_map: RefCell<DefIdMap<Rc<ty::ItemVariances>>>,\n+    pub item_variance_map: RefCell<DepTrackingMap<maps::ItemVariances<'tcx>>>,\n \n     /// True if the variance has been computed yet; false otherwise.\n     pub variance_computed: Cell<bool>,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n+    pub inherent_impls: RefCell<DepTrackingMap<maps::InherentImpls<'tcx>>>,\n \n     /// Maps a DefId of an impl to a list of its items.\n     /// Note that this contains all of the impls that we know about,\n     /// including ones in other crates. It's not clear that this is the best\n     /// way to do it.\n-    pub impl_items: RefCell<DefIdMap<Vec<ty::ImplOrTraitItemId>>>,\n+    pub impl_items: RefCell<DepTrackingMap<maps::ImplItems<'tcx>>>,\n \n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n@@ -312,6 +335,7 @@ pub struct ctxt<'tcx> {\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n+\n     /// The set of external primitive types whose implementations have been read.\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n@@ -347,7 +371,9 @@ pub struct ctxt<'tcx> {\n     pub fulfilled_predicates: RefCell<traits::FulfilledPredicates<'tcx>>,\n \n     /// Caches the representation hints for struct definitions.\n-    pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n+    ///\n+    /// This is encapsulated by the `ReprHints` task and hence is not tracked.\n+    repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n \n     /// Maps Expr NodeId's to their constant qualification.\n     pub const_qualif_map: RefCell<NodeMap<middle::check_const::ConstQualif>>,\n@@ -499,31 +525,31 @@ impl<'tcx> ctxt<'tcx> {\n             named_region_map: named_region_map,\n             region_maps: region_maps,\n             free_region_maps: RefCell::new(FnvHashMap()),\n-            item_variance_map: RefCell::new(DefIdMap()),\n+            item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n             def_map: def_map,\n             tables: RefCell::new(Tables::empty()),\n-            impl_trait_refs: RefCell::new(DefIdMap()),\n-            trait_defs: RefCell::new(DefIdMap()),\n-            adt_defs: RefCell::new(DefIdMap()),\n-            predicates: RefCell::new(DefIdMap()),\n-            super_predicates: RefCell::new(DefIdMap()),\n+            impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n             map: map,\n             freevars: RefCell::new(freevars),\n-            tcache: RefCell::new(DefIdMap()),\n+            tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n             ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n-            impl_or_trait_items: RefCell::new(DefIdMap()),\n-            trait_item_def_ids: RefCell::new(DefIdMap()),\n+            impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_items_cache: RefCell::new(DefIdMap()),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n-            inherent_impls: RefCell::new(DefIdMap()),\n-            impl_items: RefCell::new(DefIdMap()),\n+            inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            impl_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n             populated_external_types: RefCell::new(DefIdSet()),\n@@ -1004,4 +1030,38 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n         self.mk_param(def.space, def.index, def.name)\n     }\n+\n+    pub fn trait_items(&self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> {\n+        // since this is cached, pushing a dep-node for the\n+        // computation yields the correct dependencies.\n+        let _task = self.dep_graph.in_task(DepNode::TraitItems(trait_did));\n+\n+        let mut trait_items = self.trait_items_cache.borrow_mut();\n+        match trait_items.get(&trait_did).cloned() {\n+            Some(trait_items) => trait_items,\n+            None => {\n+                let def_ids = self.trait_item_def_ids(trait_did);\n+                let items: Rc<Vec<_>> =\n+                    Rc::new(def_ids.iter()\n+                                   .map(|d| self.impl_or_trait_item(d.def_id()))\n+                                   .collect());\n+                trait_items.insert(trait_did, items.clone());\n+                items\n+            }\n+        }\n+    }\n+\n+    /// Obtain the representation annotation for a struct definition.\n+    pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n+        let _task = self.dep_graph.in_task(DepNode::ReprHints(did));\n+        self.repr_hint_cache.memoize(did, || {\n+            Rc::new(if did.is_local() {\n+                self.get_attrs(did).iter().flat_map(|meta| {\n+                    attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n+                }).collect()\n+            } else {\n+                self.sess.cstore.repr_attrs(did)\n+            })\n+        })\n+    }\n }"}, {"sha": "ffc12aa5aea198e37dde94deefcd2b52df5de614", "filename": "src/librustc/middle/ty/ivar.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepNode;\n use middle::ty::{Ty, TyS};\n+use middle::ty::tls;\n \n use rustc_data_structures::ivar;\n \n@@ -27,6 +29,10 @@ use core::nonzero::NonZero;\n ///     (B) no aliases to this value with a 'tcx longer than this\n ///         value's 'lt exist\n ///\n+/// Dependency tracking: each ivar does not know what node in the\n+/// dependency graph it is associated with, so when you get/fulfill\n+/// you must supply a `DepNode` id. This should always be the same id!\n+///\n /// NonZero is used rather than Unique because Unique isn't Copy.\n pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n                                    PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n@@ -40,19 +46,28 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n     }\n \n     #[inline]\n-    pub fn get(&self) -> Option<Ty<'tcx>> {\n+    pub fn get(&self, dep_node: DepNode) -> Option<Ty<'tcx>> {\n+        tls::with(|tcx| tcx.dep_graph.read(dep_node));\n+        self.untracked_get()\n+    }\n+\n+    #[inline]\n+    fn untracked_get(&self) -> Option<Ty<'tcx>> {\n         match self.0.get() {\n             None => None,\n             // valid because of invariant (A)\n             Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n         }\n     }\n+\n     #[inline]\n-    pub fn unwrap(&self) -> Ty<'tcx> {\n-        self.get().unwrap()\n+    pub fn unwrap(&self, dep_node: DepNode) -> Ty<'tcx> {\n+        self.get(dep_node).unwrap()\n     }\n \n-    pub fn fulfill(&self, value: Ty<'lt>) {\n+    pub fn fulfill(&self, dep_node: DepNode, value: Ty<'lt>) {\n+        tls::with(|tcx| tcx.dep_graph.write(dep_node));\n+\n         // Invariant (A) is fulfilled, because by (B), every alias\n         // of this has a 'tcx longer than 'lt.\n         let value: *const TyS<'lt> = value;\n@@ -64,7 +79,7 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n \n impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.get() {\n+        match self.untracked_get() {\n             Some(val) => write!(f, \"TyIVar({:?})\", val),\n             None => f.write_str(\"TyIVar(<unfulfilled>)\")\n         }"}, {"sha": "e1fea5bba1df7edef9d7520cae9aef9ceaa8913c", "filename": "src/librustc/middle/ty/maps.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dep_graph::{DepNode, DepTrackingMapId};\n+use middle::def_id::DefId;\n+use middle::ty;\n+use std::marker::PhantomData;\n+use std::rc::Rc;\n+\n+macro_rules! dep_map_ty {\n+    ($ty_name:ident : $node_name:ident ($key:ty) -> $value:ty) => {\n+        pub struct $ty_name<'tcx> {\n+            data: PhantomData<&'tcx ()>\n+        }\n+\n+        impl<'tcx> DepTrackingMapId for $ty_name<'tcx> {\n+            type Key = $key;\n+            type Value = $value;\n+            fn to_dep_node(key: &$key) -> DepNode { DepNode::$node_name(*key) }\n+        }\n+    }\n+}\n+\n+dep_map_ty! { ImplOrTraitItems: ImplOrTraitItems(DefId) -> ty::ImplOrTraitItem<'tcx> }\n+dep_map_ty! { Tcache: ItemSignature(DefId) -> ty::TypeScheme<'tcx> }\n+dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n+dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n+dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitItemId>> }\n+dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n+dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n+dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n+dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<ty::ItemVariances> }\n+dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Rc<Vec<DefId>> }\n+dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }"}, {"sha": "10682655e63b878e066c58cf11f5df1c1190e96a", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 213, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -18,6 +18,7 @@ pub use self::ImplOrTraitItem::*;\n pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n \n+use dep_graph::{self, DepNode};\n use front::map as ast_map;\n use front::map::LinkedPath;\n use middle;\n@@ -31,13 +32,13 @@ use middle::traits;\n use middle::ty;\n use middle::ty::fold::TypeFolder;\n use middle::ty::walk::TypeWalker;\n-use util::common::memoized;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n+use util::common::MemoizationMap;\n+use util::nodemap::{NodeMap, NodeSet};\n use util::nodemap::FnvHashMap;\n \n use serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::borrow::{Borrow, Cow};\n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::rc::Rc;\n@@ -76,14 +77,18 @@ pub use self::contents::TypeContents;\n pub use self::context::{ctxt, tls};\n pub use self::context::{CtxtArenas, Lift, Tables};\n \n+pub use self::trait_def::{TraitDef, TraitFlags};\n+\n pub mod adjustment;\n pub mod cast;\n pub mod error;\n pub mod fast_reject;\n pub mod fold;\n pub mod _match;\n+pub mod maps;\n pub mod outlives;\n pub mod relate;\n+pub mod trait_def;\n pub mod walk;\n pub mod wf;\n pub mod util;\n@@ -1318,161 +1323,6 @@ pub struct TypeScheme<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-bitflags! {\n-    flags TraitFlags: u32 {\n-        const NO_TRAIT_FLAGS        = 0,\n-        const HAS_DEFAULT_IMPL      = 1 << 0,\n-        const IS_OBJECT_SAFE        = 1 << 1,\n-        const OBJECT_SAFETY_VALID   = 1 << 2,\n-        const IMPLS_VALID           = 1 << 3,\n-    }\n-}\n-\n-/// As `TypeScheme` but for a trait ref.\n-pub struct TraitDef<'tcx> {\n-    pub unsafety: hir::Unsafety,\n-\n-    /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n-    /// attribute, indicating that it should be used with `Foo()`\n-    /// sugar. This is a temporary thing -- eventually any trait wil\n-    /// be usable with the sugar (or without it).\n-    pub paren_sugar: bool,\n-\n-    /// Generic type definitions. Note that `Self` is listed in here\n-    /// as having a single bound, the trait itself (e.g., in the trait\n-    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n-    /// default methods get to assume that the `Self` parameters\n-    /// implements the trait.\n-    pub generics: Generics<'tcx>,\n-\n-    pub trait_ref: TraitRef<'tcx>,\n-\n-    /// A list of the associated types defined in this trait. Useful\n-    /// for resolving `X::Foo` type markers.\n-    pub associated_type_names: Vec<Name>,\n-\n-    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n-    // by a simplified version of their Self type: impls with a simplifiable\n-    // Self are stored in nonblanket_impls keyed by it, while all other impls\n-    // are stored in blanket_impls.\n-\n-    /// Impls of the trait.\n-    pub nonblanket_impls: RefCell<\n-        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n-    >,\n-\n-    /// Blanket impls associated with the trait.\n-    pub blanket_impls: RefCell<Vec<DefId>>,\n-\n-    /// Various flags\n-    pub flags: Cell<TraitFlags>\n-}\n-\n-impl<'tcx> TraitDef<'tcx> {\n-    // returns None if not yet calculated\n-    pub fn object_safety(&self) -> Option<bool> {\n-        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n-            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn set_object_safety(&self, is_safe: bool) {\n-        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n-        self.flags.set(\n-            self.flags.get() | if is_safe {\n-                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n-            } else {\n-                TraitFlags::OBJECT_SAFETY_VALID\n-            }\n-        );\n-    }\n-\n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_impl(&self,\n-                       tcx: &ctxt<'tcx>,\n-                       impl_def_id: DefId,\n-                       impl_trait_ref: TraitRef<'tcx>) {\n-        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n-               self, impl_trait_ref);\n-\n-        // We don't want to borrow_mut after we already populated all impls,\n-        // so check if an impl is present with an immutable borrow first.\n-        if let Some(sty) = fast_reject::simplify_type(tcx,\n-                                                      impl_trait_ref.self_ty(), false) {\n-            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n-                if is.contains(&impl_def_id) {\n-                    return // duplicate - skip\n-                }\n-            }\n-\n-            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n-        } else {\n-            if self.blanket_impls.borrow().contains(&impl_def_id) {\n-                return // duplicate - skip\n-            }\n-            self.blanket_impls.borrow_mut().push(impl_def_id)\n-        }\n-    }\n-\n-\n-    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &ctxt<'tcx>, mut f: F)  {\n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n-            f(impl_def_id);\n-        }\n-\n-        for v in self.nonblanket_impls.borrow().values() {\n-            for &impl_def_id in v {\n-                f(impl_def_id);\n-            }\n-        }\n-    }\n-\n-    /// Iterate over every impl that could possibly match the\n-    /// self-type `self_ty`.\n-    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n-                                                   tcx: &ctxt<'tcx>,\n-                                                   self_ty: Ty<'tcx>,\n-                                                   mut f: F)\n-    {\n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n-            f(impl_def_id);\n-        }\n-\n-        // simplify_type(.., false) basically replaces type parameters and\n-        // projections with infer-variables. This is, of course, done on\n-        // the impl trait-ref when it is instantiated, but not on the\n-        // predicate trait-ref which is passed here.\n-        //\n-        // for example, if we match `S: Copy` against an impl like\n-        // `impl<T:Copy> Copy for Option<T>`, we replace the type variable\n-        // in `Option<T>` with an infer variable, to `Option<_>` (this\n-        // doesn't actually change fast_reject output), but we don't\n-        // replace `S` with anything - this impl of course can't be\n-        // selected, and as there are hundreds of similar impls,\n-        // considering them would significantly harm performance.\n-        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, true) {\n-            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n-                for &impl_def_id in impls {\n-                    f(impl_def_id);\n-                }\n-            }\n-        } else {\n-            for v in self.nonblanket_impls.borrow().values() {\n-                for &impl_def_id in v {\n-                    f(impl_def_id);\n-                }\n-            }\n-        }\n-    }\n-\n-}\n-\n bitflags! {\n     flags AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0,\n@@ -1514,6 +1364,8 @@ pub struct FieldDefData<'tcx, 'container: 'tcx> {\n     pub vis: hir::Visibility,\n     /// TyIVar is used here to allow for variance (see the doc at\n     /// AdtDefData).\n+    ///\n+    /// Note: direct accesses to `ty` must also add dep edges.\n     ty: ivar::TyIVar<'tcx, 'container>\n }\n \n@@ -1804,11 +1656,11 @@ impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n     }\n \n     pub fn unsubst_ty(&self) -> Ty<'tcx> {\n-        self.ty.unwrap()\n+        self.ty.unwrap(DepNode::FieldTy(self.did))\n     }\n \n     pub fn fulfill_ty(&self, ty: Ty<'container>) {\n-        self.ty.fulfill(ty);\n+        self.ty.fulfill(DepNode::FieldTy(self.did), ty);\n     }\n }\n \n@@ -1931,31 +1783,20 @@ impl LvaluePreference {\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n /// the future).\n-fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n+fn lookup_locally_or_in_crate_store<M, F>(descr: &str,\n                                           def_id: DefId,\n-                                          map: &RefCell<DefIdMap<V>>,\n-                                          load_external: F) -> V where\n-    V: Clone,\n-    F: FnOnce() -> V,\n+                                          map: &M,\n+                                          load_external: F)\n+                                          -> M::Value where\n+    M: MemoizationMap<Key=DefId>,\n+    F: FnOnce() -> M::Value,\n {\n-    match map.borrow().get(&def_id).cloned() {\n-        Some(v) => { return v; }\n-        None => { }\n-    }\n-\n-    if def_id.is_local() {\n-        panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n-    }\n-    let v = load_external();\n-\n-    // Don't consider this a write from the current task, since we are\n-    // loading from another crate. (Note that the current task will\n-    // already have registered a read in the call to `get` above.)\n-    dep_graph.with_ignore(|| {\n-        map.borrow_mut().insert(def_id, v.clone());\n-    });\n-\n-    v\n+    map.memoize(def_id, || {\n+        if def_id.is_local() {\n+            panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n+        }\n+        load_external()\n+    })\n }\n \n impl BorrowKind {\n@@ -2231,22 +2072,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_items(&self, trait_did: DefId) -> Rc<Vec<ImplOrTraitItem<'tcx>>> {\n-        let mut trait_items = self.trait_items_cache.borrow_mut();\n-        match trait_items.get(&trait_did).cloned() {\n-            Some(trait_items) => trait_items,\n-            None => {\n-                let def_ids = self.trait_item_def_ids(trait_did);\n-                let items: Rc<Vec<ImplOrTraitItem>> =\n-                    Rc::new(def_ids.iter()\n-                                   .map(|d| self.impl_or_trait_item(d.def_id()))\n-                                   .collect());\n-                trait_items.insert(trait_did, items.clone());\n-                items\n-            }\n-        }\n-    }\n-\n     pub fn trait_impl_polarity(&self, id: DefId) -> Option<hir::ImplPolarity> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.find(id) {\n@@ -2264,7 +2089,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn custom_coerce_unsized_kind(&self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        memoized(&self.custom_coerce_unsized_kinds, did, |did: DefId| {\n+        self.custom_coerce_unsized_kinds.memoize(did, || {\n             let (kind, src) = if did.krate != LOCAL_CRATE {\n                 (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n             } else {\n@@ -2427,19 +2252,6 @@ impl<'tcx> ctxt<'tcx> {\n             || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n     }\n \n-    /// Obtain the representation annotation for a struct definition.\n-    pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-        memoized(&self.repr_hint_cache, did, |did: DefId| {\n-            Rc::new(if did.is_local() {\n-                self.get_attrs(did).iter().flat_map(|meta| {\n-                    attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n-                }).collect()\n-            } else {\n-                self.sess.cstore.repr_attrs(did)\n-            })\n-        })\n-    }\n-\n     pub fn item_variances(&self, item_id: DefId) -> Rc<ItemVariances> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,"}, {"sha": "db001ce2c446c8f1ce9ce60840c84def4e311b4b", "filename": "src/librustc/middle/ty/trait_def.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -0,0 +1,226 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dep_graph::DepNode;\n+use middle::def_id::DefId;\n+use middle::ty;\n+use middle::ty::fast_reject;\n+use middle::ty::Ty;\n+use std::borrow::{Borrow};\n+use std::cell::{Cell, Ref, RefCell};\n+use syntax::ast::Name;\n+use rustc_front::hir;\n+use util::nodemap::FnvHashMap;\n+\n+/// As `TypeScheme` but for a trait ref.\n+pub struct TraitDef<'tcx> {\n+    pub unsafety: hir::Unsafety,\n+\n+    /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n+    /// attribute, indicating that it should be used with `Foo()`\n+    /// sugar. This is a temporary thing -- eventually any trait wil\n+    /// be usable with the sugar (or without it).\n+    pub paren_sugar: bool,\n+\n+    /// Generic type definitions. Note that `Self` is listed in here\n+    /// as having a single bound, the trait itself (e.g., in the trait\n+    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n+    /// default methods get to assume that the `Self` parameters\n+    /// implements the trait.\n+    pub generics: ty::Generics<'tcx>,\n+\n+    pub trait_ref: ty::TraitRef<'tcx>,\n+\n+    /// A list of the associated types defined in this trait. Useful\n+    /// for resolving `X::Foo` type markers.\n+    pub associated_type_names: Vec<Name>,\n+\n+    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n+    // by a simplified version of their Self type: impls with a simplifiable\n+    // Self are stored in nonblanket_impls keyed by it, while all other impls\n+    // are stored in blanket_impls.\n+    //\n+    // These lists are tracked by `DepNode::TraitImpls`; we don't use\n+    // a DepTrackingMap but instead have the `TraitDef` insert the\n+    // required reads/writes.\n+\n+    /// Impls of the trait.\n+    nonblanket_impls: RefCell<\n+        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n+    >,\n+\n+    /// Blanket impls associated with the trait.\n+    blanket_impls: RefCell<Vec<DefId>>,\n+\n+    /// Various flags\n+    pub flags: Cell<TraitFlags>\n+}\n+\n+impl<'tcx> TraitDef<'tcx> {\n+    pub fn new(unsafety: hir::Unsafety,\n+               paren_sugar: bool,\n+               generics: ty::Generics<'tcx>,\n+               trait_ref: ty::TraitRef<'tcx>,\n+               associated_type_names: Vec<Name>)\n+               -> TraitDef<'tcx> {\n+        TraitDef {\n+            paren_sugar: paren_sugar,\n+            unsafety: unsafety,\n+            generics: generics,\n+            trait_ref: trait_ref,\n+            associated_type_names: associated_type_names,\n+            nonblanket_impls: RefCell::new(FnvHashMap()),\n+            blanket_impls: RefCell::new(vec![]),\n+            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n+        }\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        self.trait_ref.def_id\n+    }\n+\n+    // returns None if not yet calculated\n+    pub fn object_safety(&self) -> Option<bool> {\n+        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n+            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn set_object_safety(&self, is_safe: bool) {\n+        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n+        self.flags.set(\n+            self.flags.get() | if is_safe {\n+                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n+            } else {\n+                TraitFlags::OBJECT_SAFETY_VALID\n+            }\n+        );\n+    }\n+\n+    fn write_trait_impls(&self, tcx: &ty::ctxt<'tcx>) {\n+        tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n+    }\n+\n+    fn read_trait_impls(&self, tcx: &ty::ctxt<'tcx>) {\n+        tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n+    }\n+\n+    /// Records a trait-to-implementation mapping.\n+    pub fn record_impl(&self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       impl_def_id: DefId,\n+                       impl_trait_ref: ty::TraitRef<'tcx>) {\n+        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n+               self, impl_trait_ref);\n+\n+        // Record the write into the impl set, but only for local\n+        // impls: external impls are handled differently.\n+        if impl_def_id.is_local() {\n+            self.write_trait_impls(tcx);\n+        }\n+\n+        // We don't want to borrow_mut after we already populated all impls,\n+        // so check if an impl is present with an immutable borrow first.\n+        if let Some(sty) = fast_reject::simplify_type(tcx,\n+                                                      impl_trait_ref.self_ty(), false) {\n+            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n+                if is.contains(&impl_def_id) {\n+                    return // duplicate - skip\n+                }\n+            }\n+\n+            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n+        } else {\n+            if self.blanket_impls.borrow().contains(&impl_def_id) {\n+                return // duplicate - skip\n+            }\n+            self.blanket_impls.borrow_mut().push(impl_def_id)\n+        }\n+    }\n+\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &ty::ctxt<'tcx>, mut f: F)  {\n+        self.read_trait_impls(tcx);\n+\n+        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        for v in self.nonblanket_impls.borrow().values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n+    }\n+\n+    /// Iterate over every impl that could possibly match the\n+    /// self-type `self_ty`.\n+    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n+                                                   tcx: &ty::ctxt<'tcx>,\n+                                                   self_ty: Ty<'tcx>,\n+                                                   mut f: F)\n+    {\n+        self.read_trait_impls(tcx);\n+\n+        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        // simplify_type(.., false) basically replaces type parameters and\n+        // projections with infer-variables. This is, of course, done on\n+        // the impl trait-ref when it is instantiated, but not on the\n+        // predicate trait-ref which is passed here.\n+        //\n+        // for example, if we match `S: Copy` against an impl like\n+        // `impl<T:Copy> Copy for Option<T>`, we replace the type variable\n+        // in `Option<T>` with an infer variable, to `Option<_>` (this\n+        // doesn't actually change fast_reject output), but we don't\n+        // replace `S` with anything - this impl of course can't be\n+        // selected, and as there are hundreds of similar impls,\n+        // considering them would significantly harm performance.\n+        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, true) {\n+            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n+                for &impl_def_id in impls {\n+                    f(impl_def_id);\n+                }\n+            }\n+        } else {\n+            for v in self.nonblanket_impls.borrow().values() {\n+                for &impl_def_id in v {\n+                    f(impl_def_id);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn borrow_impl_lists<'s>(&'s self, tcx: &ty::ctxt<'tcx>)\n+                                 -> (Ref<'s, Vec<DefId>>,\n+                                     Ref<'s, FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>>) {\n+        self.read_trait_impls(tcx);\n+        (self.blanket_impls.borrow(), self.nonblanket_impls.borrow())\n+    }\n+\n+}\n+\n+bitflags! {\n+    flags TraitFlags: u32 {\n+        const NO_TRAIT_FLAGS        = 0,\n+        const HAS_DEFAULT_IMPL      = 1 << 0,\n+        const IS_OBJECT_SAFE        = 1 << 1,\n+        const OBJECT_SAFETY_VALID   = 1 << 2,\n+        const IMPLS_VALID           = 1 << 3,\n+    }\n+}\n+"}, {"sha": "2481cab78b4d6f15bdf37bf15d65c19a557cd38c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -201,46 +201,38 @@ pub fn block_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr) -\n     return v.flag;\n }\n \n-/// Memoizes a one-argument closure using the given RefCell containing\n-/// a type implementing MutableMap to serve as a cache.\n-///\n-/// In the future the signature of this function is expected to be:\n-/// ```\n-/// pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n-///    cache: &RefCell<M>,\n-///    f: &|T| -> U\n-/// ) -> impl |T| -> U {\n-/// ```\n-/// but currently it is not possible.\n-///\n-/// # Examples\n-/// ```\n-/// struct Context {\n-///    cache: RefCell<HashMap<usize, usize>>\n-/// }\n-///\n-/// fn factorial(ctxt: &Context, n: usize) -> usize {\n-///     memoized(&ctxt.cache, n, |n| match n {\n-///         0 | 1 => n,\n-///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)\n-///     })\n-/// }\n-/// ```\n-#[inline(always)]\n-pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n-    where T: Clone + Hash + Eq,\n-          U: Clone,\n-          S: HashState,\n-          F: FnOnce(T) -> U,\n+pub trait MemoizationMap {\n+    type Key: Clone;\n+    type Value: Clone;\n+\n+    /// If `key` is present in the map, return the valuee,\n+    /// otherwise invoke `op` and store the value in the map.\n+    ///\n+    /// NB: if the receiver is a `DepTrackingMap`, special care is\n+    /// needed in the `op` to ensure that the correct edges are\n+    /// added into the dep graph. See the `DepTrackingMap` impl for\n+    /// more details!\n+    fn memoize<OP>(&self, key: Self::Key, op: OP) -> Self::Value\n+        where OP: FnOnce() -> Self::Value;\n+}\n+\n+impl<K, V, S> MemoizationMap for RefCell<HashMap<K,V,S>>\n+    where K: Hash+Eq+Clone, V: Clone, S: HashState\n {\n-    let key = arg.clone();\n-    let result = cache.borrow().get(&key).cloned();\n-    match result {\n-        Some(result) => result,\n-        None => {\n-            let result = f(arg);\n-            cache.borrow_mut().insert(key, result.clone());\n-            result\n+    type Key = K;\n+    type Value = V;\n+\n+    fn memoize<OP>(&self, key: K, op: OP) -> V\n+        where OP: FnOnce() -> V\n+    {\n+        let result = self.borrow().get(&key).cloned();\n+        match result {\n+            Some(result) => result,\n+            None => {\n+                let result = op();\n+                self.borrow_mut().insert(key, result.clone());\n+                result\n+            }\n         }\n     }\n }"}, {"sha": "0b48cad36ba8fefddfc9e0f0b1dcb8423a58eb97", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -38,7 +38,7 @@ use middle::ty::{self, RegionEscape, Ty};\n use rustc::mir;\n use rustc::mir::visit::MutVisitor;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n@@ -353,16 +353,11 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     let associated_type_names = parse_associated_type_names(item_doc);\n     let paren_sugar = parse_paren_sugar(item_doc);\n \n-    ty::TraitDef {\n-        paren_sugar: paren_sugar,\n-        unsafety: unsafety,\n-        generics: generics,\n-        trait_ref: item_trait_ref(item_doc, tcx, cdata),\n-        associated_type_names: associated_type_names,\n-        nonblanket_impls: RefCell::new(FnvHashMap()),\n-        blanket_impls: RefCell::new(vec![]),\n-        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n-    }\n+    ty::TraitDef::new(unsafety,\n+                      paren_sugar,\n+                      generics,\n+                      item_trait_ref(item_doc, tcx, cdata),\n+                      associated_type_names)\n }\n \n pub fn get_adt_def<'tcx>(intr: &IdentInterner,"}, {"sha": "5a9b899175837c4259f546fce4b6eca6b7ee4b58", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d48f48f61f996478e972e2dd6f3070eaf3ed45d7/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d48f48f61f996478e972e2dd6f3070eaf3ed45d7", "patch": "@@ -75,11 +75,11 @@ use middle::ty::util::IntTypeExt;\n use rscope::*;\n use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n-use util::common::{ErrorReported, memoized};\n+use util::common::{ErrorReported, MemoizationMap};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use write_ty_to_tcx;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::RefCell;\n use std::collections::HashSet;\n use std::rc::Rc;\n \n@@ -1419,17 +1419,17 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                it: &hir::Item)\n+                                item: &hir::Item)\n                                 -> ty::TypeScheme<'tcx>\n {\n-    // Computing the type scheme of an item is a discrete task:\n-    let item_def_id = ccx.tcx.map.local_def_id(it.id);\n-    let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeScheme(item_def_id));\n-    ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // we have access to `it`\n-\n-    memoized(&ccx.tcx.tcache,\n-             ccx.tcx.map.local_def_id(it.id),\n-             |_| compute_type_scheme_of_item(ccx, it))\n+    let item_def_id = ccx.tcx.map.local_def_id(item.id);\n+    ccx.tcx.tcache.memoize(item_def_id, || {\n+        // NB. Since the `memoized` function enters a new task, and we\n+        // are giving this task access to the item `item`, we must\n+        // register a read.\n+        ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n+        compute_type_scheme_of_item(ccx, item)\n+    })\n }\n \n fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n@@ -1547,14 +1547,14 @@ fn type_scheme_of_foreign_item<'a, 'tcx>(\n     abi: abi::Abi)\n     -> ty::TypeScheme<'tcx>\n {\n-    // Computing the type scheme of a foreign item is a discrete task:\n     let item_def_id = ccx.tcx.map.local_def_id(item.id);\n-    let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeScheme(item_def_id));\n-    ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // we have access to `item`\n-\n-    memoized(&ccx.tcx.tcache,\n-             ccx.tcx.map.local_def_id(item.id),\n-             |_| compute_type_scheme_of_foreign_item(ccx, item, abi))\n+    ccx.tcx.tcache.memoize(item_def_id, || {\n+        // NB. Since the `memoized` function enters a new task, and we\n+        // are giving this task access to the item `item`, we must\n+        // register a read.\n+        ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n+        compute_type_scheme_of_foreign_item(ccx, item, abi)\n+    })\n }\n \n fn compute_type_scheme_of_foreign_item<'a, 'tcx>("}]}