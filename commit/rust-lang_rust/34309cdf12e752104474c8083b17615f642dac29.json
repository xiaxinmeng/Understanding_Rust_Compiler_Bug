{"sha": "34309cdf12e752104474c8083b17615f642dac29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MzA5Y2RmMTJlNzUyMTA0NDc0YzgwODNiMTc2MTVmNjQyZGFjMjk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-06T17:40:12Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-07-19T21:16:35Z"}, "message": "implement 'a:'static region bounds\n\nFixes #22863.", "tree": {"sha": "599a51f25a7dc874e2e5c92186f668c99c183d49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/599a51f25a7dc874e2e5c92186f668c99c183d49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34309cdf12e752104474c8083b17615f642dac29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34309cdf12e752104474c8083b17615f642dac29", "html_url": "https://github.com/rust-lang/rust/commit/34309cdf12e752104474c8083b17615f642dac29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34309cdf12e752104474c8083b17615f642dac29/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e05ac3938bcbdd616930bb010a3bbfa35f22850e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e05ac3938bcbdd616930bb010a3bbfa35f22850e", "html_url": "https://github.com/rust-lang/rust/commit/e05ac3938bcbdd616930bb010a3bbfa35f22850e"}], "stats": {"total": 85, "additions": 77, "deletions": 8}, "files": [{"sha": "d902cb07494e3a1f7c10a7433d3816dc5e2fef40", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/34309cdf12e752104474c8083b17615f642dac29/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34309cdf12e752104474c8083b17615f642dac29/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=34309cdf12e752104474c8083b17615f642dac29", "patch": "@@ -13,18 +13,21 @@\n use middle::implicator::Implication;\n use middle::ty::{self, FreeRegion};\n use util::common::can_reach;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n \n #[derive(Clone)]\n pub struct FreeRegionMap {\n-    /// `free_region_map` maps from a free region `a` to a list of\n+    /// `map` maps from a free region `a` to a list of\n     /// free regions `bs` such that `a <= b for all b in bs`\n     map: FnvHashMap<FreeRegion, Vec<FreeRegion>>,\n+    /// regions that are required to outlive (and therefore be\n+    /// equal to) 'static.\n+    statics: FnvHashSet<FreeRegion>\n }\n \n impl FreeRegionMap {\n     pub fn new() -> FreeRegionMap {\n-        FreeRegionMap { map: FnvHashMap() }\n+        FreeRegionMap { map: FnvHashMap(), statics: FnvHashSet() }\n     }\n \n     pub fn relate_free_regions_from_implications<'tcx>(&mut self,\n@@ -59,6 +62,8 @@ impl FreeRegionMap {\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n                     match (r_a, r_b) {\n+                        (ty::ReStatic, ty::ReFree(_)) => {},\n+                        (ty::ReFree(fr_a), ty::ReStatic) => self.relate_to_static(fr_a),\n                         (ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n                             // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n                             self.relate_free_regions(fr_b, fr_a);\n@@ -76,8 +81,12 @@ impl FreeRegionMap {\n         }\n     }\n \n-    pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n-        let mut sups = self.map.entry(sub).or_insert(Vec::new());\n+    fn relate_to_static(&mut self, sup: FreeRegion) {\n+        self.statics.insert(sup);\n+    }\n+\n+    fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n+       let mut sups = self.map.entry(sub).or_insert(Vec::new());\n         if !sups.contains(&sup) {\n             sups.push(sup);\n         }\n@@ -88,7 +97,7 @@ impl FreeRegionMap {\n     /// it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n     /// (that is, the user can give two different names to the same lifetime).\n     pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n-        can_reach(&self.map, sub, sup)\n+        can_reach(&self.map, sub, sup) || self.is_static(&sup)\n     }\n \n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n@@ -116,10 +125,17 @@ impl FreeRegionMap {\n                 (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n                     self.sub_free_region(sub_fr, super_fr),\n \n+                (ty::ReStatic, ty::ReFree(ref sup_fr)) => self.is_static(sup_fr),\n+\n                 _ =>\n                     false,\n             }\n         }\n     }\n-}\n \n+    /// Determines whether this free-region is required to be 'static\n+    pub fn is_static(&self, super_region: &ty::FreeRegion) -> bool {\n+        debug!(\"is_static(super_region={:?})\", super_region);\n+        self.statics.iter().any(|s| can_reach(&self.map, *s, *super_region))\n+    }\n+}"}, {"sha": "4b62c7beab00270b8352582addc8f1ceb59a330e", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34309cdf12e752104474c8083b17615f642dac29/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34309cdf12e752104474c8083b17615f642dac29/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=34309cdf12e752104474c8083b17615f642dac29", "patch": "@@ -869,7 +869,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n                 let fr_scope = fr.scope.to_code_extent();\n-                if self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) == fr_scope {\n+                if self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) == fr_scope ||\n+                        free_regions.is_static(fr) {\n                     Ok(s)\n                 } else {\n                     Err(TypeError::RegionsNoOverlap(b, a))"}, {"sha": "297b6a866da3a0b30b41ab5de2534fd6d96d5d9a", "filename": "src/test/compile-fail/regions-static-bound.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/34309cdf12e752104474c8083b17615f642dac29/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34309cdf12e752104474c8083b17615f642dac29/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs?ref=34309cdf12e752104474c8083b17615f642dac29", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn static_id<'a,'b>(t: &'a ()) -> &'static ()\n+    where 'a: 'static { t }\n+fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n+    where 'a: 'b, 'b: 'static { t }\n+fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n+    t //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn error(u: &(), v: &()) {\n+    static_id(&u); //~ ERROR cannot infer an appropriate lifetime\n+    static_id_indirect(&v); //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "1c6411e3b8f11dd18aea9dcf7667b90eafc352dc", "filename": "src/test/run-pass/regions-static-bound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/34309cdf12e752104474c8083b17615f642dac29/src%2Ftest%2Frun-pass%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34309cdf12e752104474c8083b17615f642dac29/src%2Ftest%2Frun-pass%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-static-bound.rs?ref=34309cdf12e752104474c8083b17615f642dac29", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn invariant_id<'a,'b>(t: &'b mut &'static ()) -> &'b mut &'a ()\n+    where 'a: 'static { t }\n+fn static_id<'a>(t: &'a ()) -> &'static ()\n+    where 'a: 'static { t }\n+fn static_id_indirect<'a,'b>(t: &'a ()) -> &'static ()\n+    where 'a: 'b, 'b: 'static { t }\n+fn ref_id<'a>(t: &'a ()) -> &'a () where 'static: 'a { t }\n+\n+static UNIT: () = ();\n+\n+fn main()\n+{\n+    let mut val : &'static () = &UNIT;\n+    invariant_id(&mut val);\n+    static_id(val);\n+    static_id_indirect(val);\n+    ref_id(val);\n+}"}]}