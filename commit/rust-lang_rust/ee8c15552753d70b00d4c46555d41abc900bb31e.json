{"sha": "ee8c15552753d70b00d4c46555d41abc900bb31e", "node_id": "C_kwDOAAsO6NoAKGVlOGMxNTU1Mjc1M2Q3MGIwMGQ0YzQ2NTU1ZDQxYWJjOTAwYmIzMWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-20T07:27:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-20T07:27:13Z"}, "message": "Auto merge of #7840 - dswij:question-mark-result, r=llogiq\n\nCover `Result` for `question_mark`\n\ncloses #7135\n\nchangelog: [`question_mark`] now covers `Result`", "tree": {"sha": "e7e1bb77ca5f0fced967514479868266f0b01cab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7e1bb77ca5f0fced967514479868266f0b01cab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee8c15552753d70b00d4c46555d41abc900bb31e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8c15552753d70b00d4c46555d41abc900bb31e", "html_url": "https://github.com/rust-lang/rust/commit/ee8c15552753d70b00d4c46555d41abc900bb31e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee8c15552753d70b00d4c46555d41abc900bb31e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bdd2cebe24455c7cffa056a4ce3497ab58ee8c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bdd2cebe24455c7cffa056a4ce3497ab58ee8c8", "html_url": "https://github.com/rust-lang/rust/commit/5bdd2cebe24455c7cffa056a4ce3497ab58ee8c8"}, {"sha": "083a4546f6a93be70da2538bf9bd73a0b88c8236", "url": "https://api.github.com/repos/rust-lang/rust/commits/083a4546f6a93be70da2538bf9bd73a0b88c8236", "html_url": "https://github.com/rust-lang/rust/commit/083a4546f6a93be70da2538bf9bd73a0b88c8236"}], "stats": {"total": 126, "additions": 104, "deletions": 22}, "files": [{"sha": "4d616e26bfc1da1dab23a26aaaf0dcbc3b009cf5", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 53, "deletions": 21, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c15552753d70b00d4c46555d41abc900bb31e/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c15552753d70b00d4c46555d41abc900bb31e/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=ee8c15552753d70b00d4c46555d41abc900bb31e", "patch": "@@ -4,10 +4,10 @@ use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, path_to_local_id};\n+use clippy_utils::{eq_expr_value, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultOk};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -48,16 +48,20 @@ impl QuestionMark {\n     /// }\n     /// ```\n     ///\n+    /// ```ignore\n+    /// if result.is_err() {\n+    ///     return result;\n+    /// }\n+    /// ```\n+    ///\n     /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn check_is_none_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n             if let ExprKind::MethodCall(segment, _, args, _) = &cond.kind;\n-            if segment.ident.name == sym!(is_none);\n-            if Self::expression_returns_none(cx, then);\n             if let Some(subject) = args.get(0);\n-            if Self::is_option(cx, subject);\n-\n+            if (Self::option_check_and_early_return(cx, subject, then) && segment.ident.name == sym!(is_none)) ||\n+                (Self::result_check_and_early_return(cx, subject, then) && segment.ident.name == sym!(is_err));\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n@@ -95,31 +99,24 @@ impl QuestionMark {\n         }\n     }\n \n-    fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn check_if_let_some_or_err_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n                 = higher::IfLet::hir(cx, expr);\n-            if Self::is_option(cx, let_expr);\n-\n             if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n-            if is_lang_ctor(cx, path1, OptionSome);\n+            if (Self::option_check_and_early_return(cx, let_expr, if_else) && is_lang_ctor(cx, path1, OptionSome)) ||\n+                (Self::result_check_and_early_return(cx, let_expr, if_else) && is_lang_ctor(cx, path1, ResultOk));\n+\n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-\n             if let ExprKind::Block(block, None) = if_then.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n             if path_to_local_id(trailing_expr, bind_id);\n-\n-            if Self::expression_returns_none(cx, if_else);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n-                let replacement = format!(\n-                    \"{}{}?\",\n-                    receiver_str,\n-                    if by_ref { \".as_ref()\" } else { \"\" },\n-                );\n+                let replacement = format!(\"{}{}?\", receiver_str, if by_ref { \".as_ref()\" } else { \"\" },);\n \n                 span_lint_and_sugg(\n                     cx,\n@@ -134,6 +131,14 @@ impl QuestionMark {\n         }\n     }\n \n+    fn result_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n+        Self::is_result(cx, expr) && Self::expression_returns_unmodified_err(cx, nested_expr, expr)\n+    }\n+\n+    fn option_check_and_early_return(cx: &LateContext<'_>, expr: &Expr<'_>, nested_expr: &Expr<'_>) -> bool {\n+        Self::is_option(cx, expr) && Self::expression_returns_none(cx, nested_expr)\n+    }\n+\n     fn moves_by_default(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.typeck_results().expr_ty(expression);\n \n@@ -146,6 +151,12 @@ impl QuestionMark {\n         is_type_diagnostic_item(cx, expr_ty, sym::Option)\n     }\n \n+    fn is_result(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n+        let expr_ty = cx.typeck_results().expr_ty(expression);\n+\n+        is_type_diagnostic_item(cx, expr_ty, sym::Result)\n+    }\n+\n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         match expression.kind {\n             ExprKind::Block(block, _) => {\n@@ -161,6 +172,27 @@ impl QuestionMark {\n         }\n     }\n \n+    fn expression_returns_unmodified_err(\n+        cx: &LateContext<'_>,\n+        expression: &Expr<'_>,\n+        origin_hir_id: &Expr<'_>,\n+    ) -> bool {\n+        match expression.kind {\n+            ExprKind::Block(block, _) => {\n+                if let Some(return_expression) = Self::return_expression(block) {\n+                    return Self::expression_returns_unmodified_err(cx, return_expression, origin_hir_id);\n+                }\n+\n+                false\n+            },\n+            ExprKind::Ret(Some(expr)) | ExprKind::Call(expr, _) => {\n+                Self::expression_returns_unmodified_err(cx, expr, origin_hir_id)\n+            },\n+            ExprKind::Path(_) => path_to_local(expression) == path_to_local(origin_hir_id),\n+            _ => false,\n+        }\n+    }\n+\n     fn return_expression<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         // Check if last expression is a return statement. Then, return the expression\n         if_chain! {\n@@ -189,7 +221,7 @@ impl QuestionMark {\n \n impl<'tcx> LateLintPass<'tcx> for QuestionMark {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        Self::check_is_none_and_early_return_none(cx, expr);\n-        Self::check_if_let_some_and_early_return_none(cx, expr);\n+        Self::check_is_none_or_err_and_early_return(cx, expr);\n+        Self::check_if_let_some_or_err_and_early_return(cx, expr);\n     }\n }"}, {"sha": "ccb2e5a302e91590feb0ba2af50ae467e00e8115", "filename": "tests/ui/question_mark.fixed", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c15552753d70b00d4c46555d41abc900bb31e/tests%2Fui%2Fquestion_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c15552753d70b00d4c46555d41abc900bb31e/tests%2Fui%2Fquestion_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.fixed?ref=ee8c15552753d70b00d4c46555d41abc900bb31e", "patch": "@@ -104,6 +104,21 @@ fn func() -> Option<i32> {\n     Some(0)\n }\n \n+fn result_func(x: Result<i32, &str>) -> Result<i32, &str> {\n+    let _ = x?;\n+\n+    x?;\n+\n+    // No warning\n+    let y = if let Ok(x) = x {\n+        x\n+    } else {\n+        return Err(\"some error\");\n+    };\n+\n+    Ok(y)\n+}\n+\n fn main() {\n     some_func(Some(42));\n     some_func(None);\n@@ -123,4 +138,6 @@ fn main() {\n     returns_something_similar_to_option(so);\n \n     func();\n+\n+    let _ = result_func(Ok(42));\n }"}, {"sha": "ca3722371f524b53b27ca94f15fd1a46e7d867ca", "filename": "tests/ui/question_mark.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c15552753d70b00d4c46555d41abc900bb31e/tests%2Fui%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c15552753d70b00d4c46555d41abc900bb31e/tests%2Fui%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.rs?ref=ee8c15552753d70b00d4c46555d41abc900bb31e", "patch": "@@ -134,6 +134,23 @@ fn func() -> Option<i32> {\n     Some(0)\n }\n \n+fn result_func(x: Result<i32, &str>) -> Result<i32, &str> {\n+    let _ = if let Ok(x) = x { x } else { return x };\n+\n+    if x.is_err() {\n+        return x;\n+    }\n+\n+    // No warning\n+    let y = if let Ok(x) = x {\n+        x\n+    } else {\n+        return Err(\"some error\");\n+    };\n+\n+    Ok(y)\n+}\n+\n fn main() {\n     some_func(Some(42));\n     some_func(None);\n@@ -153,4 +170,6 @@ fn main() {\n     returns_something_similar_to_option(so);\n \n     func();\n+\n+    let _ = result_func(Ok(42));\n }"}, {"sha": "161588cb73cba06797561917e4ee5fe6fa3710d9", "filename": "tests/ui/question_mark.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee8c15552753d70b00d4c46555d41abc900bb31e/tests%2Fui%2Fquestion_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee8c15552753d70b00d4c46555d41abc900bb31e/tests%2Fui%2Fquestion_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.stderr?ref=ee8c15552753d70b00d4c46555d41abc900bb31e", "patch": "@@ -100,5 +100,19 @@ LL | |         return None;\n LL | |     }\n    | |_____^ help: replace it with: `f()?;`\n \n-error: aborting due to 11 previous errors\n+error: this if-let-else may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:138:13\n+   |\n+LL |     let _ = if let Ok(x) = x { x } else { return x };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x?`\n+\n+error: this block may be rewritten with the `?` operator\n+  --> $DIR/question_mark.rs:140:5\n+   |\n+LL | /     if x.is_err() {\n+LL | |         return x;\n+LL | |     }\n+   | |_____^ help: replace it with: `x?;`\n+\n+error: aborting due to 13 previous errors\n "}]}