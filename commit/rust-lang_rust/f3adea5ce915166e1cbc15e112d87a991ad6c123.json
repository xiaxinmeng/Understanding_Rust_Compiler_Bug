{"sha": "f3adea5ce915166e1cbc15e112d87a991ad6c123", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYWRlYTVjZTkxNTE2NmUxY2JjMTVlMTEyZDg3YTk5MWFkNmMxMjM=", "commit": {"author": {"name": "Pascal Hertleif", "email": "killercup@gmail.com", "date": "2015-05-18T19:10:00Z"}, "committer": {"name": "Pascal Hertleif", "email": "killercup@gmail.com", "date": "2015-05-18T19:10:00Z"}, "message": "TRPL: Normalize rust Code Block Markers\n\n`{rust,ignore}` -> `rust,ignore", "tree": {"sha": "a627a1876f77a41fc727aea79bc098257ecc9c88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a627a1876f77a41fc727aea79bc098257ecc9c88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3adea5ce915166e1cbc15e112d87a991ad6c123", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3adea5ce915166e1cbc15e112d87a991ad6c123", "html_url": "https://github.com/rust-lang/rust/commit/f3adea5ce915166e1cbc15e112d87a991ad6c123", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3adea5ce915166e1cbc15e112d87a991ad6c123/comments", "author": {"login": "killercup", "id": 20063, "node_id": "MDQ6VXNlcjIwMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/20063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killercup", "html_url": "https://github.com/killercup", "followers_url": "https://api.github.com/users/killercup/followers", "following_url": "https://api.github.com/users/killercup/following{/other_user}", "gists_url": "https://api.github.com/users/killercup/gists{/gist_id}", "starred_url": "https://api.github.com/users/killercup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killercup/subscriptions", "organizations_url": "https://api.github.com/users/killercup/orgs", "repos_url": "https://api.github.com/users/killercup/repos", "events_url": "https://api.github.com/users/killercup/events{/privacy}", "received_events_url": "https://api.github.com/users/killercup/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killercup", "id": 20063, "node_id": "MDQ6VXNlcjIwMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/20063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killercup", "html_url": "https://github.com/killercup", "followers_url": "https://api.github.com/users/killercup/followers", "following_url": "https://api.github.com/users/killercup/following{/other_user}", "gists_url": "https://api.github.com/users/killercup/gists{/gist_id}", "starred_url": "https://api.github.com/users/killercup/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killercup/subscriptions", "organizations_url": "https://api.github.com/users/killercup/orgs", "repos_url": "https://api.github.com/users/killercup/repos", "events_url": "https://api.github.com/users/killercup/events{/privacy}", "received_events_url": "https://api.github.com/users/killercup/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f69cd6387bf1975dfc760b939d607c49ff126cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f69cd6387bf1975dfc760b939d607c49ff126cb", "html_url": "https://github.com/rust-lang/rust/commit/6f69cd6387bf1975dfc760b939d607c49ff126cb"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "797ec94774d7d7c893f36313718959c6bcad4f48", "filename": "src/doc/trpl/benchmark-tests.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md?ref=f3adea5ce915166e1cbc15e112d87a991ad6c123", "patch": "@@ -3,7 +3,7 @@\n Rust supports benchmark tests, which can test the performance of your\n code. Let's make our `src/lib.rs` look like this (comments elided):\n \n-```{rust,ignore}\n+```rust,ignore\n #![feature(test)]\n \n extern crate test;\n@@ -77,7 +77,7 @@ the benchmark is no longer benchmarking what one expects. For example, the\n compiler might recognize that some calculation has no external effects and\n remove it entirely.\n \n-```{rust,ignore}\n+```rust,ignore\n #![feature(test)]\n \n extern crate test;"}, {"sha": "1cf84bfd658c04b9facbbbf9f5e63e6d76d4705a", "filename": "src/doc/trpl/box-syntax-and-patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md?ref=f3adea5ce915166e1cbc15e112d87a991ad6c123", "patch": "@@ -34,7 +34,7 @@ because the syntax may still change in the future.\n In many languages with pointers, you'd return a pointer from a function\n so as to avoid copying a large data structure. For example:\n \n-```{rust}\n+```rust\n struct BigStruct {\n     one: i32,\n     two: i32,"}, {"sha": "63fdef0760febf66cc5ef05a79341136b67ac3d1", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=f3adea5ce915166e1cbc15e112d87a991ad6c123", "patch": "@@ -126,15 +126,15 @@ ways.\n \n Instead of declaring a module like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english {\n     // contents of our module go here\n }\n ```\n \n We can instead declare our module like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english;\n ```\n \n@@ -173,7 +173,7 @@ $ tree .\n \n `src/lib.rs` is our crate root, and looks like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english;\n mod japanese;\n ```\n@@ -184,7 +184,7 @@ on our preference. In this case, because our modules have sub-modules, we\u2019ve\n chosen the second. Both `src/english/mod.rs` and `src/japanese/mod.rs` look\n like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod greetings;\n mod farewells;\n ```\n@@ -297,7 +297,7 @@ public, and so private is the default. To make things public, you use the `pub`\n keyword. Let\u2019s focus on the `english` module first, so let\u2019s reduce our `src/main.rs`\n to just this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n fn main() {\n@@ -308,29 +308,29 @@ fn main() {\n \n In our `src/lib.rs`, let\u2019s add `pub` to the `english` module declaration:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod english;\n mod japanese;\n ```\n \n And in our `src/english/mod.rs`, let\u2019s make both `pub`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod greetings;\n pub mod farewells;\n ```\n \n In our `src/english/greetings.rs`, let\u2019s add `pub` to our `fn` declaration:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn hello() -> String {\n     \"Hello!\".to_string()\n }\n ```\n \n And also in `src/english/farewells.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn goodbye() -> String {\n     \"Goodbye.\".to_string()\n }\n@@ -365,7 +365,7 @@ refer to them with shorter names. Let\u2019s talk about `use`.\n Rust has a `use` keyword, which allows us to import names into our local scope.\n Let\u2019s change our `src/main.rs` to look like this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings;\n@@ -382,7 +382,7 @@ the functions by a much shorter name. By convention, when importing functions, i\n considered best practice to import the module, rather than the function directly. In\n other words, you _can_ do this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings::hello;\n@@ -400,7 +400,7 @@ becomes a problem. If we have conflicting names, Rust will give a compilation\n error. For example, if we made the `japanese` functions public, and tried to do\n this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings::hello;\n@@ -426,14 +426,14 @@ Could not compile `phrases`.\n If we\u2019re importing multiple names from the same module, we don\u2019t have to type it out\n twice. Instead of this:\n \n-```{rust,ignore}\n+```rust,ignore\n use phrases::english::greetings;\n use phrases::english::farewells;\n ```\n \n We can use this shortcut:\n \n-```{rust,ignore}\n+```rust,ignore\n use phrases::english::{greetings, farewells};\n ```\n \n@@ -445,7 +445,7 @@ interface that may not directly map to your internal code organization.\n \n Let\u2019s look at an example. Modify your `src/main.rs` to read like this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::{greetings,farewells};\n@@ -462,30 +462,30 @@ fn main() {\n \n Then, modify your `src/lib.rs` to make the `japanese` mod public:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod english;\n pub mod japanese;\n ```\n \n Next, make the two functions public, first in `src/japanese/greetings.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn hello() -> String {\n     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n }\n ```\n \n And then in `src/japanese/farewells.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn goodbye() -> String {\n     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n }\n ```\n \n Finally, modify your `src/japanese/mod.rs` to read like this:\n \n-```{rust,ignore}\n+```rust,ignore\n pub use self::greetings::hello;\n pub use self::farewells::goodbye;\n "}, {"sha": "7b47559e0fce05f51b6dfd4d79bab2357d74843a", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=f3adea5ce915166e1cbc15e112d87a991ad6c123", "patch": "@@ -49,7 +49,7 @@ We use `assert!` to declare that something is true. If it's not true, something\n is very wrong. Wrong enough that we can't continue with things in the current\n state. Another example is using the `unreachable!()` macro:\n \n-```{rust,ignore}\n+```rust,ignore\n enum Event {\n     NewRelease,\n }\n@@ -188,7 +188,7 @@ The [`Debug`](../std/fmt/trait.Debug.html) trait is what lets us print the enum\n In the case of an error that is unexpected and not recoverable, the `panic!`\n macro will induce a panic. This will crash the current thread, and give an error:\n \n-```{rust,ignore}\n+```rust,ignore\n panic!(\"boom\");\n ```\n \n@@ -212,7 +212,7 @@ handle and possibly recover from error.\n If we don't want to handle this error, and would rather just abort the program,\n we can use the `unwrap()` method:\n \n-```{rust,ignore}\n+```rust,ignore\n io::stdin().read_line(&mut buffer).unwrap();\n ```\n \n@@ -223,7 +223,7 @@ shorter. Sometimes, just crashing is appropriate.\n \n There's another way of doing this that's a bit nicer than `unwrap()`:\n \n-```{rust,ignore}\n+```rust,ignore\n let mut buffer = String::new();\n let input = io::stdin().read_line(&mut buffer)\n                        .ok()"}, {"sha": "80c0def285ab534163150f1e09b30ac2c9795588", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=f3adea5ce915166e1cbc15e112d87a991ad6c123", "patch": "@@ -116,7 +116,7 @@ A *consumer* operates on an iterator, returning some kind of value or values.\n The most common consumer is `collect()`. This code doesn't quite compile,\n but it shows the intention:\n \n-```{rust,ignore}\n+```rust,ignore\n let one_to_one_hundred = (1..101).collect();\n ```\n \n@@ -253,7 +253,7 @@ we need to talk about with regards to iterators. Let's get to it!\n *Iterator adapters* take an iterator and modify it somehow, producing\n a new iterator. The simplest one is called `map`:\n \n-```{rust,ignore}\n+```rust,ignore\n (1..100).map(|x| x + 1);\n ```\n \n@@ -272,7 +272,7 @@ warning: unused result which must be used: iterator adaptors are lazy and\n Laziness strikes again! That closure will never execute. This example\n doesn't print any numbers:\n \n-```{rust,ignore}\n+```rust,ignore\n (1..100).map(|x| println!(\"{}\", x));\n ```\n "}, {"sha": "759543140b5769fd65925aa3785d1cc98ad49846", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=f3adea5ce915166e1cbc15e112d87a991ad6c123", "patch": "@@ -205,7 +205,7 @@ fn it_works() {\n \n That's all there is to the basics! Let's write one 'real' test:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -225,7 +225,7 @@ There is one way in which our existing example is not idiomatic: it's\n missing the `tests` module. The idiomatic way of writing our example\n looks like this:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -253,7 +253,7 @@ we need to bring our test function into scope. This can be annoying if you have\n a large module, and so this is a common use of the `glob` feature. Let's change\n our `src/lib.rs` to make use of it:\n \n-```{rust,ignore}\n+```rust,ignore\n \n pub fn add_two(a: i32) -> i32 {\n     a + 2\n@@ -302,7 +302,7 @@ the `tests` directory\n To write an integration test, let's make a `tests` directory, and\n put a `tests/lib.rs` file inside, with this as its contents:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate adder;\n \n #[test]\n@@ -359,7 +359,7 @@ documentation has been written. To this end, Rust supports automatically\n running examples in your documentation. Here's a fleshed-out `src/lib.rs`\n with examples:\n \n-```{rust,ignore}\n+```rust,ignore\n //! The `adder` crate provides functions that add numbers to other numbers.\n //!\n //! # Examples"}, {"sha": "0f5c3c64a4b17e1665b9b0a7d0941360e684785e", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3adea5ce915166e1cbc15e112d87a991ad6c123/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=f3adea5ce915166e1cbc15e112d87a991ad6c123", "patch": "@@ -2,7 +2,7 @@\n \n Rust also has a `while` loop. It looks like this:\n \n-```{rust}\n+```rust\n let mut x = 5; // mut x: i32\n let mut done = false; // mut done: bool\n "}]}