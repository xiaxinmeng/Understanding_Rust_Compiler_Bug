{"sha": "83351fa02e08caa8fb8017254cc6e7c99fc65d2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMzUxZmEwMmUwOGNhYThmYjgwMTcyNTRjYzZlN2M5OWZjNjVkMmI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-16T01:05:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-16T02:17:44Z"}, "message": "Remove usage of private enum variants\n\nThis replaces all uses of private enum variants with a struct that has\none private field pointing at a private enum.\n\nRFC: 0006-remove-priv", "tree": {"sha": "ba1d32ccf6dde845558040cd60ab3d2b177fb26a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba1d32ccf6dde845558040cd60ab3d2b177fb26a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83351fa02e08caa8fb8017254cc6e7c99fc65d2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83351fa02e08caa8fb8017254cc6e7c99fc65d2b", "html_url": "https://github.com/rust-lang/rust/commit/83351fa02e08caa8fb8017254cc6e7c99fc65d2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f94e3fe5859fe7fc001cf26f4fa401d9a2ee2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f94e3fe5859fe7fc001cf26f4fa401d9a2ee2e", "html_url": "https://github.com/rust-lang/rust/commit/10f94e3fe5859fe7fc001cf26f4fa401d9a2ee2e"}], "stats": {"total": 129, "additions": 76, "deletions": 53}, "files": [{"sha": "379d3cdc94e4f73e184f3e2bbf9d0eb82fdbd793", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=83351fa02e08caa8fb8017254cc6e7c99fc65d2b", "patch": "@@ -229,8 +229,8 @@ pub mod types {\n             */\n             #[repr(u8)]\n             pub enum c_void {\n-                priv variant1,\n-                priv variant2\n+                __variant1,\n+                __variant2,\n             }\n             pub enum FILE {}\n             pub enum fpos_t {}"}, {"sha": "dd249a1fbcac8eb5cd6936dbba1cb3da357f24f2", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=83351fa02e08caa8fb8017254cc6e7c99fc65d2b", "patch": "@@ -45,10 +45,14 @@ use super::{IndependentSample, Sample, Exp};\n /// for Generating Gamma Variables\" *ACM Trans. Math. Softw.* 26, 3\n /// (September 2000),\n /// 363-372. DOI:[10.1145/358407.358414](http://doi.acm.org/10.1145/358407.358414)\n-pub enum Gamma {\n-    priv Large(GammaLargeShape),\n-    priv One(Exp),\n-    priv Small(GammaSmallShape)\n+pub struct Gamma {\n+    repr: GammaRepr,\n+}\n+\n+enum GammaRepr {\n+    Large(GammaLargeShape),\n+    One(Exp),\n+    Small(GammaSmallShape)\n }\n \n // These two helpers could be made public, but saving the\n@@ -90,11 +94,12 @@ impl Gamma {\n         assert!(shape > 0.0, \"Gamma::new called with shape <= 0\");\n         assert!(scale > 0.0, \"Gamma::new called with scale <= 0\");\n \n-        match shape {\n+        let repr = match shape {\n             1.0        => One(Exp::new(1.0 / scale)),\n             0.0 .. 1.0 => Small(GammaSmallShape::new_raw(shape, scale)),\n             _          => Large(GammaLargeShape::new_raw(shape, scale))\n-        }\n+        };\n+        Gamma { repr: repr }\n     }\n }\n \n@@ -131,7 +136,7 @@ impl Sample<f64> for GammaLargeShape {\n \n impl IndependentSample<f64> for Gamma {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        match *self {\n+        match self.repr {\n             Small(ref g) => g.ind_sample(rng),\n             One(ref g) => g.ind_sample(rng),\n             Large(ref g) => g.ind_sample(rng),\n@@ -183,32 +188,37 @@ impl IndependentSample<f64> for GammaLargeShape {\n /// let v = chi.ind_sample(&mut rand::task_rng());\n /// println!(\"{} is from a \u03c7\u00b2(11) distribution\", v)\n /// ```\n-pub enum ChiSquared {\n+pub struct ChiSquared {\n+    repr: ChiSquaredRepr,\n+}\n+\n+enum ChiSquaredRepr {\n     // k == 1, Gamma(alpha, ..) is particularly slow for alpha < 1,\n     // e.g. when alpha = 1/2 as it would be for this case, so special-\n     // casing and using the definition of N(0,1)^2 is faster.\n-    priv DoFExactlyOne,\n-    priv DoFAnythingElse(Gamma)\n+    DoFExactlyOne,\n+    DoFAnythingElse(Gamma),\n }\n \n impl ChiSquared {\n     /// Create a new chi-squared distribution with degrees-of-freedom\n     /// `k`. Fails if `k < 0`.\n     pub fn new(k: f64) -> ChiSquared {\n-        if k == 1.0 {\n+        let repr = if k == 1.0 {\n             DoFExactlyOne\n         } else {\n             assert!(k > 0.0, \"ChiSquared::new called with `k` < 0\");\n             DoFAnythingElse(Gamma::new(0.5 * k, 2.0))\n-        }\n+        };\n+        ChiSquared { repr: repr }\n     }\n }\n impl Sample<f64> for ChiSquared {\n     fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n }\n impl IndependentSample<f64> for ChiSquared {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        match *self {\n+        match self.repr {\n             DoFExactlyOne => {\n                 // k == 1 => N(0,1)^2\n                 let StandardNormal(norm) = rng.gen::<StandardNormal>();"}, {"sha": "0514642c583908d5e65a8f184fe70b08d0b65ee0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=83351fa02e08caa8fb8017254cc6e7c99fc65d2b", "patch": "@@ -206,15 +206,19 @@ impl CrateDebugContext {\n     }\n }\n \n-pub enum FunctionDebugContext {\n-    priv FunctionDebugContext(~FunctionDebugContextData),\n-    priv DebugInfoDisabled,\n-    priv FunctionWithoutDebugInfo,\n+pub struct FunctionDebugContext {\n+    repr: FunctionDebugContextRepr,\n+}\n+\n+enum FunctionDebugContextRepr {\n+    FunctionDebugContext(~FunctionDebugContextData),\n+    DebugInfoDisabled,\n+    FunctionWithoutDebugInfo,\n }\n \n impl FunctionDebugContext {\n     fn get_ref<'a>(&'a self, cx: &CrateContext, span: Span) -> &'a FunctionDebugContextData {\n-        match *self {\n+        match self.repr {\n             FunctionDebugContext(~ref data) => data,\n             DebugInfoDisabled => {\n                 cx.sess().span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n@@ -544,7 +548,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    match fcx.debug_context {\n+    match fcx.debug_context.repr {\n         DebugInfoDisabled => return,\n         FunctionWithoutDebugInfo => {\n             set_debug_location(fcx.ccx, UnknownLocation);\n@@ -585,7 +589,7 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// and must therefore be called before the first real statement/expression of the function is\n /// translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context {\n+    match fcx.debug_context.repr {\n         FunctionDebugContext(~ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n@@ -603,15 +607,15 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                      param_substs: Option<@param_substs>,\n                                      llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n-        return DebugInfoDisabled;\n+        return FunctionDebugContext { repr: DebugInfoDisabled };\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude. Do this here\n     // already, in case we do an early exit from this function.\n     set_debug_location(cx, UnknownLocation);\n \n     if fn_ast_id == -1 {\n-        return FunctionWithoutDebugInfo;\n+        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n     let empty_generics = ast::Generics { lifetimes: Vec::new(), ty_params: OwnedSlice::empty() };\n@@ -678,15 +682,15 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         ast_map::NodeForeignItem(..) |\n         ast_map::NodeVariant(..) |\n         ast_map::NodeStructCtor(..) => {\n-            return FunctionWithoutDebugInfo;\n+            return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\", fnitem))\n     };\n \n     // This can be the case for functions inlined from another crate\n     if span == codemap::DUMMY_SP {\n-        return FunctionWithoutDebugInfo;\n+        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n     let loc = span_start(cx, span);\n@@ -761,7 +765,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                        fn_metadata,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n \n-    return FunctionDebugContext(fn_debug_context);\n+    return FunctionDebugContext { repr: FunctionDebugContext(fn_debug_context) };\n \n     fn get_function_signature(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n@@ -2335,7 +2339,7 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context {\n+    match fcx.debug_context.repr {\n         FunctionDebugContext(_) => false,\n         _ => true\n     }"}, {"sha": "792673e32981714b82e3b14f3ccfab39f2edd1c9", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83351fa02e08caa8fb8017254cc6e7c99fc65d2b/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=83351fa02e08caa8fb8017254cc6e7c99fc65d2b", "patch": "@@ -12,15 +12,19 @@ use std::mem;\n use std::vec;\n \n /// A vector type optimized for cases where the size is almost always 0 or 1\n-pub enum SmallVector<T> {\n-    priv Zero,\n-    priv One(T),\n-    priv Many(Vec<T> ),\n+pub struct SmallVector<T> {\n+    repr: SmallVectorRepr<T>,\n+}\n+\n+enum SmallVectorRepr<T> {\n+    Zero,\n+    One(T),\n+    Many(Vec<T> ),\n }\n \n impl<T> Container for SmallVector<T> {\n     fn len(&self) -> uint {\n-        match *self {\n+        match self.repr {\n             Zero => 0,\n             One(..) => 1,\n             Many(ref vals) => vals.len()\n@@ -30,7 +34,7 @@ impl<T> Container for SmallVector<T> {\n \n impl<T> FromIterator<T> for SmallVector<T> {\n     fn from_iter<I: Iterator<T>>(iter: I) -> SmallVector<T> {\n-        let mut v = Zero;\n+        let mut v = SmallVector::zero();\n         v.extend(iter);\n         v\n     }\n@@ -46,24 +50,24 @@ impl<T> Extendable<T> for SmallVector<T> {\n \n impl<T> SmallVector<T> {\n     pub fn zero() -> SmallVector<T> {\n-        Zero\n+        SmallVector { repr: Zero }\n     }\n \n     pub fn one(v: T) -> SmallVector<T> {\n-        One(v)\n+        SmallVector { repr: One(v) }\n     }\n \n-    pub fn many(vs: Vec<T> ) -> SmallVector<T> {\n-        Many(vs)\n+    pub fn many(vs: Vec<T>) -> SmallVector<T> {\n+        SmallVector { repr: Many(vs) }\n     }\n \n     pub fn push(&mut self, v: T) {\n-        match *self {\n-            Zero => *self = One(v),\n+        match self.repr {\n+            Zero => self.repr = One(v),\n             One(..) => {\n-                let one = mem::replace(self, Zero);\n+                let one = mem::replace(&mut self.repr, Zero);\n                 match one {\n-                    One(v1) => mem::replace(self, Many(vec!(v1, v))),\n+                    One(v1) => mem::replace(&mut self.repr, Many(vec!(v1, v))),\n                     _ => unreachable!()\n                 };\n             }\n@@ -78,15 +82,15 @@ impl<T> SmallVector<T> {\n     }\n \n     pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n-        match *self {\n+        match self.repr {\n             One(ref v) if idx == 0 => v,\n             Many(ref vs) => vs.get(idx),\n             _ => fail!(\"out of bounds access\")\n         }\n     }\n \n     pub fn expect_one(self, err: &'static str) -> T {\n-        match self {\n+        match self.repr {\n             One(v) => v,\n             Many(v) => {\n                 if v.len() == 1 {\n@@ -100,27 +104,32 @@ impl<T> SmallVector<T> {\n     }\n \n     pub fn move_iter(self) -> MoveItems<T> {\n-        match self {\n+        let repr = match self.repr {\n             Zero => ZeroIterator,\n             One(v) => OneIterator(v),\n             Many(vs) => ManyIterator(vs.move_iter())\n-        }\n+        };\n+        MoveItems { repr: repr }\n     }\n }\n \n-pub enum MoveItems<T> {\n-    priv ZeroIterator,\n-    priv OneIterator(T),\n-    priv ManyIterator(vec::MoveItems<T>),\n+pub struct MoveItems<T> {\n+    repr: MoveItemsRepr<T>,\n+}\n+\n+enum MoveItemsRepr<T> {\n+    ZeroIterator,\n+    OneIterator(T),\n+    ManyIterator(vec::MoveItems<T>),\n }\n \n impl<T> Iterator<T> for MoveItems<T> {\n     fn next(&mut self) -> Option<T> {\n-        match *self {\n+        match self.repr {\n             ZeroIterator => None,\n             OneIterator(..) => {\n                 let mut replacement = ZeroIterator;\n-                mem::swap(self, &mut replacement);\n+                mem::swap(&mut self.repr, &mut replacement);\n                 match replacement {\n                     OneIterator(v) => Some(v),\n                     _ => unreachable!()\n@@ -131,7 +140,7 @@ impl<T> Iterator<T> for MoveItems<T> {\n     }\n \n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        match *self {\n+        match self.repr {\n             ZeroIterator => (0, Some(0)),\n             OneIterator(..) => (1, Some(1)),\n             ManyIterator(ref inner) => inner.size_hint()"}]}