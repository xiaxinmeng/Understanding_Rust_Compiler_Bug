{"sha": "edeb826d0a6c157f389f94b8525794b52362e174", "node_id": "C_kwDOAAsO6NoAKGVkZWI4MjZkMGE2YzE1N2YzODlmOTRiODUyNTc5NGI1MjM2MmUxNzQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-10T19:23:42Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-10T23:45:18Z"}, "message": "Inline shallow_resolve_ty into ShallowResolver", "tree": {"sha": "613d482299c976997dd6d3d4115089ca855d6fc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/613d482299c976997dd6d3d4115089ca855d6fc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edeb826d0a6c157f389f94b8525794b52362e174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edeb826d0a6c157f389f94b8525794b52362e174", "html_url": "https://github.com/rust-lang/rust/commit/edeb826d0a6c157f389f94b8525794b52362e174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edeb826d0a6c157f389f94b8525794b52362e174/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f32b73bdb3833c18c73fe3062bde8e1721ccca", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f32b73bdb3833c18c73fe3062bde8e1721ccca", "html_url": "https://github.com/rust-lang/rust/commit/18f32b73bdb3833c18c73fe3062bde8e1721ccca"}], "stats": {"total": 83, "additions": 39, "deletions": 44}, "files": [{"sha": "e1cad1a4f6cefef406ef0cb7761ec1ef9abf2599", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/edeb826d0a6c157f389f94b8525794b52362e174/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb826d0a6c157f389f94b8525794b52362e174/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=edeb826d0a6c157f389f94b8525794b52362e174", "patch": "@@ -1659,49 +1659,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.const_eval_resolve(param_env_erased, unevaluated, span)\n     }\n \n-    /// If `typ` is a type variable of some kind, resolve it one level\n-    /// (but do not resolve types found in the result). If `typ` is\n-    /// not a type variable, just return it unmodified.\n-    // FIXME(eddyb) inline into `ShallowResolver::visit_ty`.\n-    fn shallow_resolve_ty(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match *typ.kind() {\n-            ty::Infer(ty::TyVar(v)) => {\n-                // Not entirely obvious: if `typ` is a type variable,\n-                // it can be resolved to an int/float variable, which\n-                // can then be recursively resolved, hence the\n-                // recursion. Note though that we prevent type\n-                // variables from unifying to other type variables\n-                // directly (though they may be embedded\n-                // structurally), and we prevent cycles in any case,\n-                // so this recursion should always be of very limited\n-                // depth.\n-                //\n-                // Note: if these two lines are combined into one we get\n-                // dynamic borrow errors on `self.inner`.\n-                let known = self.inner.borrow_mut().type_variables().probe(v).known();\n-                known.map_or(typ, |t| self.shallow_resolve_ty(t))\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => self\n-                .inner\n-                .borrow_mut()\n-                .int_unification_table()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            ty::Infer(ty::FloatVar(v)) => self\n-                .inner\n-                .borrow_mut()\n-                .float_unification_table()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            _ => typ,\n-        }\n-    }\n-\n     /// `ty_or_const_infer_var_changed` is equivalent to one of these two:\n     ///   * `shallow_resolve(ty) != ty` (where `ty.kind = ty::Infer(_)`)\n     ///   * `shallow_resolve(ct) != ct` (where `ct.kind = ty::ConstKind::Infer(_)`)\n@@ -1831,8 +1788,46 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    /// If `ty` is a type variable of some kind, resolve it one level\n+    /// (but do not resolve types found in the result). If `typ` is\n+    /// not a type variable, just return it unmodified.\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.shallow_resolve_ty(ty)\n+        match *ty.kind() {\n+            ty::Infer(ty::TyVar(v)) => {\n+                // Not entirely obvious: if `typ` is a type variable,\n+                // it can be resolved to an int/float variable, which\n+                // can then be recursively resolved, hence the\n+                // recursion. Note though that we prevent type\n+                // variables from unifying to other type variables\n+                // directly (though they may be embedded\n+                // structurally), and we prevent cycles in any case,\n+                // so this recursion should always be of very limited\n+                // depth.\n+                //\n+                // Note: if these two lines are combined into one we get\n+                // dynamic borrow errors on `self.inner`.\n+                let known = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n+                known.map_or(ty, |t| self.fold_ty(t))\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .int_unification_table()\n+                .probe_value(v)\n+                .map_or(ty, |v| v.to_type(self.infcx.tcx)),\n+\n+            ty::Infer(ty::FloatVar(v)) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .float_unification_table()\n+                .probe_value(v)\n+                .map_or(ty, |v| v.to_type(self.infcx.tcx)),\n+\n+            _ => ty,\n+        }\n     }\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {"}]}