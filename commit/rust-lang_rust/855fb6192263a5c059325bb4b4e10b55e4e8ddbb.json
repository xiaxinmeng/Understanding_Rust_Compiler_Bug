{"sha": "855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NWZiNjE5MjI2M2E1YzA1OTMyNWJiNGI0ZTEwYjU1ZTRlOGRkYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-02T01:28:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-02T01:28:24Z"}, "message": "Auto merge of #33296 - jseyfried:non_idempotent_lowering, r=nrc\n\nRemove the requirement that ast->hir lowering be reproducible\n\nThis PR changes the ast->hir lowerer to be non-reproducible, and it removes the lowering context's id cache.\n\nIf the `hir` of an `ast` node needs to be reproduced, we can use the hir map instead of the lowerer -- for example, `tcx.map.expect_expr(expr.id)` instead of `lower_expr(lcx, expr)`.\n\nr? @nrc", "tree": {"sha": "47cc5ccdbfa24041b35bd1fc71811a267613c4c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47cc5ccdbfa24041b35bd1fc71811a267613c4c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "html_url": "https://github.com/rust-lang/rust/commit/855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adda14a0339ff47c526d8fb6897d70fbd73a5768", "url": "https://api.github.com/repos/rust-lang/rust/commits/adda14a0339ff47c526d8fb6897d70fbd73a5768", "html_url": "https://github.com/rust-lang/rust/commit/adda14a0339ff47c526d8fb6897d70fbd73a5768"}, {"sha": "ef69ef81e31b248c0eb5ca6b95ab0f302f49e77c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef69ef81e31b248c0eb5ca6b95ab0f302f49e77c", "html_url": "https://github.com/rust-lang/rust/commit/ef69ef81e31b248c0eb5ca6b95ab0f302f49e77c"}], "stats": {"total": 948, "additions": 348, "deletions": 600}, "files": [{"sha": "0876e609396c5634fad841860e523c472332a0ec", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 336, "deletions": 569, "changes": 905, "blob_url": "https://github.com/rust-lang/rust/blob/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "patch": "@@ -29,27 +29,6 @@\n // are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n // If you do, you must then set the new node's id to a fresh one.\n //\n-// Lowering must be reproducable (the compiler only lowers once, but tools and\n-// custom lints may lower an AST node to a HIR node to interact with the\n-// compiler). The most interesting bit of this is ids - if you lower an AST node\n-// and create new HIR nodes with fresh ids, when re-lowering the same node, you\n-// must ensure you get the same ids! To do this, we keep track of the next id\n-// when we translate a node which requires new ids. By checking this cache and\n-// using node ids starting with the cached id, we ensure ids are reproducible.\n-// To use this system, you just need to hold on to a CachedIdSetter object\n-// whilst lowering. This is an RAII object that takes care of setting and\n-// restoring the cached id, etc.\n-//\n-// This whole system relies on node ids being incremented one at a time and\n-// all increments being for lowering. This means that you should not call any\n-// non-lowering function which will use new node ids.\n-//\n-// We must also cache gensym'ed Idents to ensure that we get the same Ident\n-// every time we lower a node with gensym'ed names. One consequence of this is\n-// that you can only gensym a name once in a lowering (you don't need to worry\n-// about nested lowering though). That's because we cache based on the name and\n-// the currently cached node id, which is unique per lowered node.\n-//\n // Spans are used for error messages and for tools to map semantics back to\n // source code. It is therefore not as important with spans as ids to be strict\n // about use (you can't break the compiler by screwing up a span). Obviously, a\n@@ -67,7 +46,6 @@ use hir::map::definitions::DefPathData;\n use hir::def_id::DefIndex;\n \n use std::collections::BTreeMap;\n-use std::collections::HashMap;\n use std::iter;\n use syntax::ast::*;\n use syntax::attr::{ThinAttributes, ThinAttributesExt};\n@@ -83,18 +61,8 @@ use std::cell::{Cell, RefCell};\n \n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n-    // Map AST ids to ids used for expanded nodes.\n-    id_cache: RefCell<HashMap<NodeId, NodeId>>,\n-    // Use if there are no cached ids for the current node.\n+    // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     id_assigner: &'a NodeIdAssigner,\n-    // 0 == no cached id. Must be incremented to align with previous id\n-    // incrementing.\n-    cached_id: Cell<u32>,\n-    // Keep track of gensym'ed idents.\n-    gensym_cache: RefCell<HashMap<(NodeId, &'static str), hir::Ident>>,\n-    // A copy of cached_id, but is also set to an id while a node is lowered for\n-    // the first time.\n-    gensym_key: Cell<u32>,\n     // We must keep the set of definitions up to date as we add nodes that\n     // weren't in the AST.\n     definitions: Option<&'a RefCell<Definitions>>,\n@@ -121,11 +89,7 @@ impl<'a, 'hir> LoweringContext<'a> {\n \n         LoweringContext {\n             crate_root: crate_root,\n-            id_cache: RefCell::new(HashMap::new()),\n             id_assigner: id_assigner,\n-            cached_id: Cell::new(0),\n-            gensym_cache: RefCell::new(HashMap::new()),\n-            gensym_key: Cell::new(0),\n             definitions: Some(defs),\n             parent_def: Cell::new(None),\n         }\n@@ -136,40 +100,18 @@ impl<'a, 'hir> LoweringContext<'a> {\n     pub fn testing_context(id_assigner: &'a NodeIdAssigner) -> LoweringContext<'a> {\n         LoweringContext {\n             crate_root: None,\n-            id_cache: RefCell::new(HashMap::new()),\n             id_assigner: id_assigner,\n-            cached_id: Cell::new(0),\n-            gensym_cache: RefCell::new(HashMap::new()),\n-            gensym_key: Cell::new(0),\n             definitions: None,\n             parent_def: Cell::new(None),\n         }\n     }\n \n     fn next_id(&self) -> NodeId {\n-        let cached_id = self.cached_id.get();\n-        if cached_id == 0 {\n-            return self.id_assigner.next_node_id();\n-        }\n-\n-        self.cached_id.set(cached_id + 1);\n-        cached_id\n+        self.id_assigner.next_node_id()\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> hir::Ident {\n-        let gensym_key = self.gensym_key.get();\n-        if gensym_key == 0 {\n-            return hir::Ident::from_name(token::gensym(s));\n-        }\n-\n-        let cached = self.gensym_cache.borrow().contains_key(&(gensym_key, s));\n-        if cached {\n-            self.gensym_cache.borrow()[&(gensym_key, s)]\n-        } else {\n-            let result = hir::Ident::from_name(token::gensym(s));\n-            self.gensym_cache.borrow_mut().insert((gensym_key, s), result);\n-            result\n-        }\n+        hir::Ident::from_name(token::gensym(s))\n     }\n \n     // Panics if this LoweringContext's NodeIdAssigner is not able to emit diagnostics.\n@@ -197,53 +139,6 @@ impl<'a, 'hir> LoweringContext<'a> {\n     }\n }\n \n-// Utility fn for setting and unsetting the cached id.\n-fn cache_ids<'a, OP, R>(lctx: &LoweringContext, expr_id: NodeId, op: OP) -> R\n-    where OP: FnOnce(&LoweringContext) -> R\n-{\n-    // Only reset the id if it was previously 0, i.e., was not cached.\n-    // If it was cached, we are in a nested node, but our id count will\n-    // still count towards the parent's count.\n-    let reset_cached_id = lctx.cached_id.get() == 0;\n-    // We always reset gensym_key so that if we use the same name in a nested\n-    // node and after that node, they get different values.\n-    let old_gensym_key = lctx.gensym_key.get();\n-\n-    {\n-        let id_cache: &mut HashMap<_, _> = &mut lctx.id_cache.borrow_mut();\n-\n-        if id_cache.contains_key(&expr_id) {\n-            let cached_id = lctx.cached_id.get();\n-            if cached_id == 0 {\n-                // We're entering a node where we need to track ids, but are not\n-                // yet tracking.\n-                lctx.cached_id.set(id_cache[&expr_id]);\n-            } else {\n-                // We're already tracking - check that the tracked id is the same\n-                // as the expected id.\n-                assert!(cached_id == id_cache[&expr_id], \"id mismatch\");\n-            }\n-            lctx.gensym_key.set(id_cache[&expr_id]);\n-        } else {\n-            // We've never lowered this node before, remember it for next time.\n-            let next_id = lctx.id_assigner.peek_node_id();\n-            id_cache.insert(expr_id, next_id);\n-            lctx.gensym_key.set(next_id);\n-            // self.cached_id is not set when we lower a node for the first time,\n-            // only on re-lowering.\n-        }\n-    }\n-\n-    let result = op(lctx);\n-\n-    if reset_cached_id {\n-        lctx.cached_id.set(0);\n-    }\n-    lctx.gensym_key.set(old_gensym_key);\n-\n-    result\n-}\n-\n pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n     hir::Ident {\n         name: mtwt::resolve(ident),\n@@ -1077,102 +972,100 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                 //     InPlace::finalize(place)\n                 // })\n-                return cache_ids(lctx, e.id, |lctx| {\n-                    let placer_expr = lower_expr(lctx, placer);\n-                    let value_expr = lower_expr(lctx, value_expr);\n-\n-                    let placer_ident = lctx.str_to_ident(\"placer\");\n-                    let place_ident = lctx.str_to_ident(\"place\");\n-                    let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n-\n-                    let make_place = [\"ops\", \"Placer\", \"make_place\"];\n-                    let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n-                    let move_val_init = [\"intrinsics\", \"move_val_init\"];\n-                    let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n-\n-                    let make_call = |lctx: &LoweringContext, p, args| {\n-                        let path = core_path(lctx, e.span, p);\n-                        let path = expr_path(lctx, path, None);\n-                        expr_call(lctx, e.span, path, args, None)\n-                    };\n-\n-                    let mk_stmt_let = |lctx: &LoweringContext, bind, expr| {\n-                        stmt_let(lctx, e.span, false, bind, expr, None)\n-                    };\n+                let placer_expr = lower_expr(lctx, placer);\n+                let value_expr = lower_expr(lctx, value_expr);\n+\n+                let placer_ident = lctx.str_to_ident(\"placer\");\n+                let place_ident = lctx.str_to_ident(\"place\");\n+                let p_ptr_ident = lctx.str_to_ident(\"p_ptr\");\n+\n+                let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+                let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+                let move_val_init = [\"intrinsics\", \"move_val_init\"];\n+                let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+                let make_call = |lctx: &LoweringContext, p, args| {\n+                    let path = core_path(lctx, e.span, p);\n+                    let path = expr_path(lctx, path, None);\n+                    expr_call(lctx, e.span, path, args, None)\n+                };\n \n-                    let mk_stmt_let_mut = |lctx: &LoweringContext, bind, expr| {\n-                        stmt_let(lctx, e.span, true, bind, expr, None)\n-                    };\n+                let mk_stmt_let = |lctx: &LoweringContext, bind, expr| {\n+                    stmt_let(lctx, e.span, false, bind, expr, None)\n+                };\n \n-                    // let placer = <placer_expr> ;\n-                    let s1 = {\n-                        let placer_expr = signal_block_expr(lctx,\n-                                                            hir_vec![],\n-                                                            placer_expr,\n-                                                            e.span,\n-                                                            hir::PopUnstableBlock,\n-                                                            None);\n-                        mk_stmt_let(lctx, placer_ident, placer_expr)\n-                    };\n+                let mk_stmt_let_mut = |lctx: &LoweringContext, bind, expr| {\n+                    stmt_let(lctx, e.span, true, bind, expr, None)\n+                };\n \n-                    // let mut place = Placer::make_place(placer);\n-                    let s2 = {\n-                        let placer = expr_ident(lctx, e.span, placer_ident, None);\n-                        let call = make_call(lctx, &make_place, hir_vec![placer]);\n-                        mk_stmt_let_mut(lctx, place_ident, call)\n-                    };\n+                // let placer = <placer_expr> ;\n+                let s1 = {\n+                    let placer_expr = signal_block_expr(lctx,\n+                                                        hir_vec![],\n+                                                        placer_expr,\n+                                                        e.span,\n+                                                        hir::PopUnstableBlock,\n+                                                        None);\n+                    mk_stmt_let(lctx, placer_ident, placer_expr)\n+                };\n \n-                    // let p_ptr = Place::pointer(&mut place);\n-                    let s3 = {\n-                        let agent = expr_ident(lctx, e.span, place_ident, None);\n-                        let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n-                        let call = make_call(lctx, &place_pointer, args);\n-                        mk_stmt_let(lctx, p_ptr_ident, call)\n-                    };\n+                // let mut place = Placer::make_place(placer);\n+                let s2 = {\n+                    let placer = expr_ident(lctx, e.span, placer_ident, None);\n+                    let call = make_call(lctx, &make_place, hir_vec![placer]);\n+                    mk_stmt_let_mut(lctx, place_ident, call)\n+                };\n \n-                    // pop_unsafe!(EXPR));\n-                    let pop_unsafe_expr = {\n-                        let value_expr = signal_block_expr(lctx,\n-                                                           hir_vec![],\n-                                                           value_expr,\n-                                                           e.span,\n-                                                           hir::PopUnstableBlock,\n-                                                           None);\n-                        signal_block_expr(lctx,\n-                                          hir_vec![],\n-                                          value_expr,\n-                                          e.span,\n-                                          hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n-                    };\n+                // let p_ptr = Place::pointer(&mut place);\n+                let s3 = {\n+                    let agent = expr_ident(lctx, e.span, place_ident, None);\n+                    let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n+                    let call = make_call(lctx, &place_pointer, args);\n+                    mk_stmt_let(lctx, p_ptr_ident, call)\n+                };\n \n-                    // push_unsafe!({\n-                    //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-                    //     InPlace::finalize(place)\n-                    // })\n-                    let expr = {\n-                        let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n-                        let call_move_val_init =\n-                            hir::StmtSemi(\n-                                make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n-                                lctx.next_id());\n-                        let call_move_val_init = respan(e.span, call_move_val_init);\n-\n-                        let place = expr_ident(lctx, e.span, place_ident, None);\n-                        let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n-                        signal_block_expr(lctx,\n-                                          hir_vec![call_move_val_init],\n-                                          call,\n-                                          e.span,\n-                                          hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n-                    };\n+                // pop_unsafe!(EXPR));\n+                let pop_unsafe_expr = {\n+                    let value_expr = signal_block_expr(lctx,\n+                                                       hir_vec![],\n+                                                       value_expr,\n+                                                       e.span,\n+                                                       hir::PopUnstableBlock,\n+                                                       None);\n+                    signal_block_expr(lctx,\n+                                      hir_vec![],\n+                                      value_expr,\n+                                      e.span,\n+                                      hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n+                };\n \n+                // push_unsafe!({\n+                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                //     InPlace::finalize(place)\n+                // })\n+                let expr = {\n+                    let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n+                    let call_move_val_init =\n+                        hir::StmtSemi(\n+                            make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n+                            lctx.next_id());\n+                    let call_move_val_init = respan(e.span, call_move_val_init);\n+\n+                    let place = expr_ident(lctx, e.span, place_ident, None);\n+                    let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n                     signal_block_expr(lctx,\n-                                      hir_vec![s1, s2, s3],\n-                                      expr,\n+                                      hir_vec![call_move_val_init],\n+                                      call,\n                                       e.span,\n-                                      hir::PushUnstableBlock,\n-                                      e.attrs.clone())\n-                });\n+                                      hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n+                };\n+\n+                return signal_block_expr(lctx,\n+                                         hir_vec![s1, s2, s3],\n+                                         expr,\n+                                         e.span,\n+                                         hir::PushUnstableBlock,\n+                                         e.attrs.clone());\n             }\n \n             ExprKind::Vec(ref exprs) => {\n@@ -1226,20 +1119,18 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let else_opt = else_opt.as_ref().map(|els| {\n                     match els.node {\n                         ExprKind::IfLet(..) => {\n-                            cache_ids(lctx, e.id, |lctx| {\n-                                // wrap the if-let expr in a block\n-                                let span = els.span;\n-                                let els = lower_expr(lctx, els);\n-                                let id = lctx.next_id();\n-                                let blk = P(hir::Block {\n-                                    stmts: hir_vec![],\n-                                    expr: Some(els),\n-                                    id: id,\n-                                    rules: hir::DefaultBlock,\n-                                    span: span,\n-                                });\n-                                expr_block(lctx, blk, None)\n-                            })\n+                            // wrap the if-let expr in a block\n+                            let span = els.span;\n+                            let els = lower_expr(lctx, els);\n+                            let id = lctx.next_id();\n+                            let blk = P(hir::Block {\n+                                stmts: hir_vec![],\n+                                expr: Some(els),\n+                                id: id,\n+                                rules: hir::DefaultBlock,\n+                                span: span,\n+                            });\n+                            expr_block(lctx, blk, None)\n                         }\n                         _ => lower_expr(lctx, els),\n                     }\n@@ -1328,38 +1219,36 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                       None)\n                 }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n-                    use syntax::ast::RangeLimits::*;\n+                use syntax::ast::RangeLimits::*;\n \n-                    match (e1, e2, lims) {\n-                        (&None,         &None,         HalfOpen) =>\n-                            make_struct(lctx, e, &[\"RangeFull\"],\n-                                                 &[]),\n+                return match (e1, e2, lims) {\n+                    (&None,         &None,         HalfOpen) =>\n+                        make_struct(lctx, e, &[\"RangeFull\"],\n+                                             &[]),\n \n-                        (&Some(ref e1), &None,         HalfOpen) =>\n-                            make_struct(lctx, e, &[\"RangeFrom\"],\n-                                                 &[(\"start\", e1)]),\n+                    (&Some(ref e1), &None,         HalfOpen) =>\n+                        make_struct(lctx, e, &[\"RangeFrom\"],\n+                                             &[(\"start\", e1)]),\n \n-                        (&None,         &Some(ref e2), HalfOpen) =>\n-                            make_struct(lctx, e, &[\"RangeTo\"],\n-                                                 &[(\"end\", e2)]),\n+                    (&None,         &Some(ref e2), HalfOpen) =>\n+                        make_struct(lctx, e, &[\"RangeTo\"],\n+                                             &[(\"end\", e2)]),\n \n-                        (&Some(ref e1), &Some(ref e2), HalfOpen) =>\n-                            make_struct(lctx, e, &[\"Range\"],\n-                                                 &[(\"start\", e1), (\"end\", e2)]),\n+                    (&Some(ref e1), &Some(ref e2), HalfOpen) =>\n+                        make_struct(lctx, e, &[\"Range\"],\n+                                             &[(\"start\", e1), (\"end\", e2)]),\n \n-                        (&None,         &Some(ref e2), Closed)   =>\n-                            make_struct(lctx, e, &[\"RangeToInclusive\"],\n-                                                 &[(\"end\", e2)]),\n+                    (&None,         &Some(ref e2), Closed)   =>\n+                        make_struct(lctx, e, &[\"RangeToInclusive\"],\n+                                             &[(\"end\", e2)]),\n \n-                        (&Some(ref e1), &Some(ref e2), Closed)   =>\n-                            make_struct(lctx, e, &[\"RangeInclusive\", \"NonEmpty\"],\n-                                                 &[(\"start\", e1), (\"end\", e2)]),\n+                    (&Some(ref e1), &Some(ref e2), Closed)   =>\n+                        make_struct(lctx, e, &[\"RangeInclusive\", \"NonEmpty\"],\n+                                             &[(\"start\", e1), (\"end\", e2)]),\n \n-                        _ => panic!(lctx.diagnostic().span_fatal(e.span,\n-                                                                 \"inclusive range with no end\"))\n-                    }\n-                });\n+                    _ => panic!(lctx.diagnostic().span_fatal(e.span,\n+                                                             \"inclusive range with no end\"))\n+                };\n             }\n             ExprKind::Path(ref qself, ref path) => {\n                 let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n@@ -1433,81 +1322,79 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     _ => [<else_opt> | ()]\n                 //   }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n-                    // `<pat> => <body>`\n-                    let pat_arm = {\n-                        let body = lower_block(lctx, body);\n-                        let body_expr = expr_block(lctx, body, None);\n-                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n-                    };\n+                // `<pat> => <body>`\n+                let pat_arm = {\n+                    let body = lower_block(lctx, body);\n+                    let body_expr = expr_block(lctx, body, None);\n+                    arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n+                };\n \n-                    // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n-                    let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n-                    let else_if_arms = {\n-                        let mut arms = vec![];\n-                        loop {\n-                            let else_opt_continue = else_opt.and_then(|els| {\n-                                els.and_then(|els| {\n-                                    match els.node {\n-                                        // else if\n-                                        hir::ExprIf(cond, then, else_opt) => {\n-                                            let pat_under = pat_wild(lctx, e.span);\n-                                            arms.push(hir::Arm {\n-                                                attrs: hir_vec![],\n-                                                pats: hir_vec![pat_under],\n-                                                guard: Some(cond),\n-                                                body: expr_block(lctx, then, None),\n-                                            });\n-                                            else_opt.map(|else_opt| (else_opt, true))\n-                                        }\n-                                        _ => Some((P(els), false)),\n+                // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n+                let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n+                let else_if_arms = {\n+                    let mut arms = vec![];\n+                    loop {\n+                        let else_opt_continue = else_opt.and_then(|els| {\n+                            els.and_then(|els| {\n+                                match els.node {\n+                                    // else if\n+                                    hir::ExprIf(cond, then, else_opt) => {\n+                                        let pat_under = pat_wild(lctx, e.span);\n+                                        arms.push(hir::Arm {\n+                                            attrs: hir_vec![],\n+                                            pats: hir_vec![pat_under],\n+                                            guard: Some(cond),\n+                                            body: expr_block(lctx, then, None),\n+                                        });\n+                                        else_opt.map(|else_opt| (else_opt, true))\n                                     }\n-                                })\n-                            });\n-                            match else_opt_continue {\n-                                Some((e, true)) => {\n-                                    else_opt = Some(e);\n-                                }\n-                                Some((e, false)) => {\n-                                    else_opt = Some(e);\n-                                    break;\n-                                }\n-                                None => {\n-                                    else_opt = None;\n-                                    break;\n+                                    _ => Some((P(els), false)),\n                                 }\n+                            })\n+                        });\n+                        match else_opt_continue {\n+                            Some((e, true)) => {\n+                                else_opt = Some(e);\n+                            }\n+                            Some((e, false)) => {\n+                                else_opt = Some(e);\n+                                break;\n+                            }\n+                            None => {\n+                                else_opt = None;\n+                                break;\n                             }\n                         }\n-                        arms\n-                    };\n-\n-                    let contains_else_clause = else_opt.is_some();\n+                    }\n+                    arms\n+                };\n \n-                    // `_ => [<else_opt> | ()]`\n-                    let else_arm = {\n-                        let pat_under = pat_wild(lctx, e.span);\n-                        let else_expr =\n-                            else_opt.unwrap_or_else(\n-                                || expr_tuple(lctx, e.span, hir_vec![], None));\n-                        arm(hir_vec![pat_under], else_expr)\n-                    };\n+                let contains_else_clause = else_opt.is_some();\n \n-                    let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n-                    arms.push(pat_arm);\n-                    arms.extend(else_if_arms);\n-                    arms.push(else_arm);\n+                // `_ => [<else_opt> | ()]`\n+                let else_arm = {\n+                    let pat_under = pat_wild(lctx, e.span);\n+                    let else_expr =\n+                        else_opt.unwrap_or_else(\n+                            || expr_tuple(lctx, e.span, hir_vec![], None));\n+                    arm(hir_vec![pat_under], else_expr)\n+                };\n \n-                    let sub_expr = lower_expr(lctx, sub_expr);\n-                    // add attributes to the outer returned expr node\n-                    expr(lctx,\n-                         e.span,\n-                         hir::ExprMatch(sub_expr,\n-                                        arms.into(),\n-                                        hir::MatchSource::IfLetDesugar {\n-                                            contains_else_clause: contains_else_clause,\n-                                        }),\n-                         e.attrs.clone())\n-                });\n+                let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n+                arms.push(pat_arm);\n+                arms.extend(else_if_arms);\n+                arms.push(else_arm);\n+\n+                let sub_expr = lower_expr(lctx, sub_expr);\n+                // add attributes to the outer returned expr node\n+                return expr(lctx,\n+                            e.span,\n+                            hir::ExprMatch(sub_expr,\n+                                           arms.into(),\n+                                           hir::MatchSource::IfLetDesugar {\n+                                               contains_else_clause: contains_else_clause,\n+                                           }),\n+                            e.attrs.clone());\n             }\n \n             // Desugar ExprWhileLet\n@@ -1522,38 +1409,36 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     }\n                 //   }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n-                    // `<pat> => <body>`\n-                    let pat_arm = {\n-                        let body = lower_block(lctx, body);\n-                        let body_expr = expr_block(lctx, body, None);\n-                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n-                    };\n+                // `<pat> => <body>`\n+                let pat_arm = {\n+                    let body = lower_block(lctx, body);\n+                    let body_expr = expr_block(lctx, body, None);\n+                    arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n+                };\n \n-                    // `_ => break`\n-                    let break_arm = {\n-                        let pat_under = pat_wild(lctx, e.span);\n-                        let break_expr = expr_break(lctx, e.span, None);\n-                        arm(hir_vec![pat_under], break_expr)\n-                    };\n+                // `_ => break`\n+                let break_arm = {\n+                    let pat_under = pat_wild(lctx, e.span);\n+                    let break_expr = expr_break(lctx, e.span, None);\n+                    arm(hir_vec![pat_under], break_expr)\n+                };\n \n-                    // `match <sub_expr> { ... }`\n-                    let arms = hir_vec![pat_arm, break_arm];\n-                    let sub_expr = lower_expr(lctx, sub_expr);\n-                    let match_expr = expr(lctx,\n-                                          e.span,\n-                                          hir::ExprMatch(sub_expr,\n-                                                         arms,\n-                                                         hir::MatchSource::WhileLetDesugar),\n-                                          None);\n-\n-                    // `[opt_ident]: loop { ... }`\n-                    let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block,\n-                                                  opt_ident.map(|ident| lower_ident(lctx, ident)));\n-                    // add attributes to the outer returned expr node\n-                    expr(lctx, e.span, loop_expr, e.attrs.clone())\n-                });\n+                // `match <sub_expr> { ... }`\n+                let arms = hir_vec![pat_arm, break_arm];\n+                let sub_expr = lower_expr(lctx, sub_expr);\n+                let match_expr = expr(lctx,\n+                                      e.span,\n+                                      hir::ExprMatch(sub_expr,\n+                                                     arms,\n+                                                     hir::MatchSource::WhileLetDesugar),\n+                                      None);\n+\n+                // `[opt_ident]: loop { ... }`\n+                let loop_block = block_expr(lctx, match_expr);\n+                let loop_expr = hir::ExprLoop(loop_block,\n+                                              opt_ident.map(|ident| lower_ident(lctx, ident)));\n+                // add attributes to the outer returned expr node\n+                return expr(lctx, e.span, loop_expr, e.attrs.clone());\n             }\n \n             // Desugar ExprForLoop\n@@ -1575,106 +1460,104 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     result\n                 //   }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n-                    // expand <head>\n-                    let head = lower_expr(lctx, head);\n-\n-                    let iter = lctx.str_to_ident(\"iter\");\n-\n-                    // `::std::option::Option::Some(<pat>) => <body>`\n-                    let pat_arm = {\n-                        let body_block = lower_block(lctx, body);\n-                        let body_span = body_block.span;\n-                        let body_expr = P(hir::Expr {\n-                            id: lctx.next_id(),\n-                            node: hir::ExprBlock(body_block),\n-                            span: body_span,\n-                            attrs: None,\n-                        });\n-                        let pat = lower_pat(lctx, pat);\n-                        let some_pat = pat_some(lctx, e.span, pat);\n+                // expand <head>\n+                let head = lower_expr(lctx, head);\n \n-                        arm(hir_vec![some_pat], body_expr)\n-                    };\n+                let iter = lctx.str_to_ident(\"iter\");\n+\n+                // `::std::option::Option::Some(<pat>) => <body>`\n+                let pat_arm = {\n+                    let body_block = lower_block(lctx, body);\n+                    let body_span = body_block.span;\n+                    let body_expr = P(hir::Expr {\n+                        id: lctx.next_id(),\n+                        node: hir::ExprBlock(body_block),\n+                        span: body_span,\n+                        attrs: None,\n+                    });\n+                    let pat = lower_pat(lctx, pat);\n+                    let some_pat = pat_some(lctx, e.span, pat);\n \n-                    // `::std::option::Option::None => break`\n-                    let break_arm = {\n-                        let break_expr = expr_break(lctx, e.span, None);\n+                    arm(hir_vec![some_pat], body_expr)\n+                };\n \n-                        arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n-                    };\n+                // `::std::option::Option::None => break`\n+                let break_arm = {\n+                    let break_expr = expr_break(lctx, e.span, None);\n \n-                    // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-                    let match_expr = {\n-                        let next_path = {\n-                            let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n-\n-                            path_global(e.span, strs)\n-                        };\n-                        let iter = expr_ident(lctx, e.span, iter, None);\n-                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter, None);\n-                        let next_path = expr_path(lctx, next_path, None);\n-                        let next_expr = expr_call(lctx,\n-                                                  e.span,\n-                                                  next_path,\n-                                                  hir_vec![ref_mut_iter],\n-                                                  None);\n-                        let arms = hir_vec![pat_arm, break_arm];\n-\n-                        expr(lctx,\n-                             e.span,\n-                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n-                             None)\n-                    };\n+                    arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n+                };\n+\n+                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+                let match_expr = {\n+                    let next_path = {\n+                        let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n \n-                    // `[opt_ident]: loop { ... }`\n-                    let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block,\n-                                                  opt_ident.map(|ident| lower_ident(lctx, ident)));\n-                    let loop_expr = expr(lctx, e.span, loop_expr, None);\n-\n-                    // `mut iter => { ... }`\n-                    let iter_arm = {\n-                        let iter_pat = pat_ident_binding_mode(lctx,\n-                                                              e.span,\n-                                                              iter,\n-                                                              hir::BindByValue(hir::MutMutable));\n-                        arm(hir_vec![iter_pat], loop_expr)\n+                        path_global(e.span, strs)\n                     };\n+                    let iter = expr_ident(lctx, e.span, iter, None);\n+                    let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter, None);\n+                    let next_path = expr_path(lctx, next_path, None);\n+                    let next_expr = expr_call(lctx,\n+                                              e.span,\n+                                              next_path,\n+                                              hir_vec![ref_mut_iter],\n+                                              None);\n+                    let arms = hir_vec![pat_arm, break_arm];\n \n-                    // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-                    let into_iter_expr = {\n-                        let into_iter_path = {\n-                            let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n+                    expr(lctx,\n+                         e.span,\n+                         hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n+                         None)\n+                };\n+\n+                // `[opt_ident]: loop { ... }`\n+                let loop_block = block_expr(lctx, match_expr);\n+                let loop_expr = hir::ExprLoop(loop_block,\n+                                              opt_ident.map(|ident| lower_ident(lctx, ident)));\n+                let loop_expr = expr(lctx, e.span, loop_expr, None);\n+\n+                // `mut iter => { ... }`\n+                let iter_arm = {\n+                    let iter_pat = pat_ident_binding_mode(lctx,\n+                                                          e.span,\n+                                                          iter,\n+                                                          hir::BindByValue(hir::MutMutable));\n+                    arm(hir_vec![iter_pat], loop_expr)\n+                };\n \n-                            path_global(e.span, strs)\n-                        };\n+                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+                let into_iter_expr = {\n+                    let into_iter_path = {\n+                        let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n-                        let into_iter = expr_path(lctx, into_iter_path, None);\n-                        expr_call(lctx, e.span, into_iter, hir_vec![head], None)\n+                        path_global(e.span, strs)\n                     };\n \n-                    let match_expr = expr_match(lctx,\n-                                                e.span,\n-                                                into_iter_expr,\n-                                                hir_vec![iter_arm],\n-                                                hir::MatchSource::ForLoopDesugar,\n-                                                None);\n-\n-                    // `{ let _result = ...; _result }`\n-                    // underscore prevents an unused_variables lint if the head diverges\n-                    let result_ident = lctx.str_to_ident(\"_result\");\n-                    let let_stmt = stmt_let(lctx,\n+                    let into_iter = expr_path(lctx, into_iter_path, None);\n+                    expr_call(lctx, e.span, into_iter, hir_vec![head], None)\n+                };\n+\n+                let match_expr = expr_match(lctx,\n                                             e.span,\n-                                            false,\n-                                            result_ident,\n-                                            match_expr,\n+                                            into_iter_expr,\n+                                            hir_vec![iter_arm],\n+                                            hir::MatchSource::ForLoopDesugar,\n                                             None);\n-                    let result = expr_ident(lctx, e.span, result_ident, None);\n-                    let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n-                    // add the attributes to the outer returned expr node\n-                    expr_block(lctx, block, e.attrs.clone())\n-                });\n+\n+                // `{ let _result = ...; _result }`\n+                // underscore prevents an unused_variables lint if the head diverges\n+                let result_ident = lctx.str_to_ident(\"_result\");\n+                let let_stmt = stmt_let(lctx,\n+                                        e.span,\n+                                        false,\n+                                        result_ident,\n+                                        match_expr,\n+                                        None);\n+                let result = expr_ident(lctx, e.span, result_ident, None);\n+                let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n+                // add the attributes to the outer returned expr node\n+                return expr_block(lctx, block, e.attrs.clone());\n             }\n \n             // Desugar ExprKind::Try\n@@ -1691,48 +1574,46 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     }\n                 // }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n-                    // expand <expr>\n-                    let sub_expr = lower_expr(lctx, sub_expr);\n+                // expand <expr>\n+                let sub_expr = lower_expr(lctx, sub_expr);\n \n-                    // Ok(val) => val\n-                    let ok_arm = {\n-                        let val_ident = lctx.str_to_ident(\"val\");\n-                        let val_pat = pat_ident(lctx, e.span, val_ident);\n-                        let val_expr = expr_ident(lctx, e.span, val_ident, None);\n-                        let ok_pat = pat_ok(lctx, e.span, val_pat);\n+                // Ok(val) => val\n+                let ok_arm = {\n+                    let val_ident = lctx.str_to_ident(\"val\");\n+                    let val_pat = pat_ident(lctx, e.span, val_ident);\n+                    let val_expr = expr_ident(lctx, e.span, val_ident, None);\n+                    let ok_pat = pat_ok(lctx, e.span, val_pat);\n \n-                        arm(hir_vec![ok_pat], val_expr)\n-                    };\n+                    arm(hir_vec![ok_pat], val_expr)\n+                };\n \n-                    // Err(err) => return Err(From::from(err))\n-                    let err_arm = {\n-                        let err_ident = lctx.str_to_ident(\"err\");\n-                        let from_expr = {\n-                            let path = std_path(lctx, &[\"convert\", \"From\", \"from\"]);\n-                            let path = path_global(e.span, path);\n-                            let from = expr_path(lctx, path, None);\n-                            let err_expr = expr_ident(lctx, e.span, err_ident, None);\n-\n-                            expr_call(lctx, e.span, from, hir_vec![err_expr], None)\n-                        };\n-                        let err_expr = {\n-                            let path = std_path(lctx, &[\"result\", \"Result\", \"Err\"]);\n-                            let path = path_global(e.span, path);\n-                            let err_ctor = expr_path(lctx, path, None);\n-                            expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n-                        };\n-                        let err_pat = pat_err(lctx, e.span,\n-                                              pat_ident(lctx, e.span, err_ident));\n-                        let ret_expr = expr(lctx, e.span,\n-                                            hir::Expr_::ExprRet(Some(err_expr)), None);\n-\n-                        arm(hir_vec![err_pat], ret_expr)\n+                // Err(err) => return Err(From::from(err))\n+                let err_arm = {\n+                    let err_ident = lctx.str_to_ident(\"err\");\n+                    let from_expr = {\n+                        let path = std_path(lctx, &[\"convert\", \"From\", \"from\"]);\n+                        let path = path_global(e.span, path);\n+                        let from = expr_path(lctx, path, None);\n+                        let err_expr = expr_ident(lctx, e.span, err_ident, None);\n+\n+                        expr_call(lctx, e.span, from, hir_vec![err_expr], None)\n+                    };\n+                    let err_expr = {\n+                        let path = std_path(lctx, &[\"result\", \"Result\", \"Err\"]);\n+                        let path = path_global(e.span, path);\n+                        let err_ctor = expr_path(lctx, path, None);\n+                        expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n                     };\n+                    let err_pat = pat_err(lctx, e.span,\n+                                          pat_ident(lctx, e.span, err_ident));\n+                    let ret_expr = expr(lctx, e.span,\n+                                        hir::Expr_::ExprRet(Some(err_expr)), None);\n \n-                    expr_match(lctx, e.span, sub_expr, hir_vec![err_arm, ok_arm],\n-                               hir::MatchSource::TryDesugar, None)\n-                })\n+                    arm(hir_vec![err_pat], ret_expr)\n+                };\n+\n+                return expr_match(lctx, e.span, sub_expr, hir_vec![err_arm, ok_arm],\n+                                  hir::MatchSource::TryDesugar, None);\n             }\n \n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n@@ -2113,117 +1994,3 @@ fn signal_block_expr(lctx: &LoweringContext,\n                }),\n                attrs)\n }\n-\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use syntax::ast::{self, NodeId, NodeIdAssigner};\n-    use syntax::{parse, codemap};\n-    use syntax::fold::Folder;\n-    use std::cell::Cell;\n-\n-    struct MockAssigner {\n-        next_id: Cell<NodeId>,\n-    }\n-\n-    impl MockAssigner {\n-        fn new() -> MockAssigner {\n-            MockAssigner { next_id: Cell::new(0) }\n-        }\n-    }\n-\n-    trait FakeExtCtxt {\n-        fn call_site(&self) -> codemap::Span;\n-        fn cfg(&self) -> ast::CrateConfig;\n-        fn ident_of(&self, st: &str) -> ast::Ident;\n-        fn name_of(&self, st: &str) -> ast::Name;\n-        fn parse_sess(&self) -> &parse::ParseSess;\n-    }\n-\n-    impl FakeExtCtxt for parse::ParseSess {\n-        fn call_site(&self) -> codemap::Span {\n-            codemap::Span {\n-                lo: codemap::BytePos(0),\n-                hi: codemap::BytePos(0),\n-                expn_id: codemap::NO_EXPANSION,\n-            }\n-        }\n-        fn cfg(&self) -> ast::CrateConfig {\n-            Vec::new()\n-        }\n-        fn ident_of(&self, st: &str) -> ast::Ident {\n-            parse::token::str_to_ident(st)\n-        }\n-        fn name_of(&self, st: &str) -> ast::Name {\n-            parse::token::intern(st)\n-        }\n-        fn parse_sess(&self) -> &parse::ParseSess {\n-            self\n-        }\n-    }\n-\n-    impl NodeIdAssigner for MockAssigner {\n-        fn next_node_id(&self) -> NodeId {\n-            let result = self.next_id.get();\n-            self.next_id.set(result + 1);\n-            result\n-        }\n-\n-        fn peek_node_id(&self) -> NodeId {\n-            self.next_id.get()\n-        }\n-    }\n-\n-    impl Folder for MockAssigner {\n-        fn new_id(&mut self, old_id: NodeId) -> NodeId {\n-            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-            self.next_node_id()\n-        }\n-    }\n-\n-    #[test]\n-    fn test_preserves_ids() {\n-        let cx = parse::ParseSess::new();\n-        let mut assigner = MockAssigner::new();\n-\n-        let ast_if_let = quote_expr!(&cx,\n-                                     if let Some(foo) = baz {\n-                                         bar(foo);\n-                                     });\n-        let ast_if_let = assigner.fold_expr(ast_if_let);\n-        let ast_while_let = quote_expr!(&cx,\n-                                        while let Some(foo) = baz {\n-                                            bar(foo);\n-                                        });\n-        let ast_while_let = assigner.fold_expr(ast_while_let);\n-        let ast_for = quote_expr!(&cx,\n-                                  for i in 0..10 {\n-                                      for j in 0..10 {\n-                                          foo(i, j);\n-                                      }\n-                                  });\n-        let ast_for = assigner.fold_expr(ast_for);\n-        let ast_in = quote_expr!(&cx, in HEAP { foo() });\n-        let ast_in = assigner.fold_expr(ast_in);\n-\n-        let lctx = LoweringContext::testing_context(&assigner);\n-\n-        let hir1 = lower_expr(&lctx, &ast_if_let);\n-        let hir2 = lower_expr(&lctx, &ast_if_let);\n-        assert!(hir1 == hir2);\n-\n-        let hir1 = lower_expr(&lctx, &ast_while_let);\n-        let hir2 = lower_expr(&lctx, &ast_while_let);\n-        assert!(hir1 == hir2);\n-\n-        let hir1 = lower_expr(&lctx, &ast_for);\n-        let hir2 = lower_expr(&lctx, &ast_for);\n-        assert!(hir1 == hir2);\n-\n-        let hir1 = lower_expr(&lctx, &ast_in);\n-        let hir2 = lower_expr(&lctx, &ast_in);\n-        assert!(hir1 == hir2);\n-    }\n-}"}, {"sha": "6e47ee8101d31ff3c2cd53bcbbd457c41ee31034", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "patch": "@@ -165,8 +165,7 @@ pub fn compile_input(sess: &Session,\n                                                                          &hir_map,\n                                                                          &expanded_crate,\n                                                                          &hir_map.krate(),\n-                                                                         &id[..],\n-                                                                         &lcx),\n+                                                                         &id[..]),\n                                     Ok(()));\n         }\n \n@@ -203,7 +202,6 @@ pub fn compile_input(sess: &Session,\n                                                                &analysis,\n                                                                mir_map.as_ref(),\n                                                                tcx,\n-                                                               &lcx,\n                                                                &id);\n                 (control.after_analysis.callback)(state);\n \n@@ -248,9 +246,7 @@ pub fn compile_input(sess: &Session,\n }\n \n fn keep_mtwt_tables(sess: &Session) -> bool {\n-    sess.opts.debugging_opts.keep_mtwt_tables ||\n-    sess.opts.debugging_opts.save_analysis ||\n-    sess.opts.debugging_opts.save_analysis_csv\n+    sess.opts.debugging_opts.keep_mtwt_tables\n }\n \n fn keep_ast(sess: &Session) -> bool {\n@@ -345,7 +341,6 @@ pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n     pub mir_map: Option<&'a MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n     pub tcx: Option<&'a TyCtxt<'tcx>>,\n-    pub lcx: Option<&'a LoweringContext<'a>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -368,7 +363,6 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n             analysis: None,\n             mir_map: None,\n             tcx: None,\n-            lcx: None,\n             trans: None,\n         }\n     }\n@@ -400,15 +394,13 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                               hir_map: &'a hir_map::Map<'ast>,\n                               krate: &'a ast::Crate,\n                               hir_crate: &'a hir::Crate,\n-                              crate_name: &'a str,\n-                              lcx: &'a LoweringContext<'a>)\n+                              crate_name: &'a str)\n                               -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n             ast_map: Some(hir_map),\n             krate: Some(krate),\n             hir_crate: Some(hir_crate),\n-            lcx: Some(lcx),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n@@ -421,7 +413,6 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                             analysis: &'a ty::CrateAnalysis,\n                             mir_map: Option<&'a MirMap<'tcx>>,\n                             tcx: &'a TyCtxt<'tcx>,\n-                            lcx: &'a LoweringContext<'a>,\n                             crate_name: &'a str)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n@@ -430,7 +421,6 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n             tcx: Some(tcx),\n             krate: krate,\n             hir_crate: Some(hir_crate),\n-            lcx: Some(lcx),\n             crate_name: Some(crate_name),\n             ..CompileState::empty(input, session, out_dir)\n         }"}, {"sha": "2d3363507d06c7d8fab51dcad498fb06ac1823d6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "patch": "@@ -499,7 +499,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             control.after_analysis.callback = box |state| {\n                 time(state.session.time_passes(), \"save analysis\", || {\n                     save::process_crate(state.tcx.unwrap(),\n-                                        state.lcx.unwrap(),\n                                         state.krate.unwrap(),\n                                         state.analysis.unwrap(),\n                                         state.crate_name.unwrap(),"}, {"sha": "d12d1c8aae0577f18142bef4bdeb9218e7931ace", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "patch": "@@ -42,8 +42,6 @@ use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n \n-use rustc::hir::lowering::lower_expr;\n-\n use super::{escape, generated_code, SaveContext, PathCollector};\n use super::data::*;\n use super::dump::Dump;\n@@ -1222,7 +1220,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 visit::walk_expr(self, ex);\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-                let hir_expr = lower_expr(self.save_ctxt.lcx, ex);\n+                let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n                 let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n                 let def = self.tcx.resolve_expr(&hir_expr);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n@@ -1241,7 +1239,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n             ast::ExprKind::TupField(ref sub_ex, idx) => {\n                 self.visit_expr(&sub_ex);\n \n-                let hir_node = lower_expr(self.save_ctxt.lcx, sub_ex);\n+                let hir_node = self.save_ctxt.tcx.map.expect_expr(sub_ex.id);\n                 let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {"}, {"sha": "85c8f1f8ec98c4cff11c1068be75c39f7eeac878", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/855fb6192263a5c059325bb4b4e10b55e4e8ddbb/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=855fb6192263a5c059325bb4b4e10b55e4e8ddbb", "patch": "@@ -28,7 +28,7 @@\n #[macro_use] extern crate syntax;\n extern crate serialize as rustc_serialize;\n \n-use rustc::hir::{self, lowering};\n+use rustc::hir;\n use rustc::hir::map::NodeItem;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n@@ -75,7 +75,6 @@ pub mod recorder {\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: &'l TyCtxt<'tcx>,\n-    lcx: &'l lowering::LoweringContext<'l>,\n     span_utils: SpanUtils<'tcx>,\n }\n \n@@ -84,20 +83,16 @@ macro_rules! option_try(\n );\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: &'l TyCtxt<'tcx>,\n-               lcx: &'l lowering::LoweringContext<'l>)\n-               -> SaveContext<'l, 'tcx> {\n+    pub fn new(tcx: &'l TyCtxt<'tcx>) -> SaveContext<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n-        SaveContext::from_span_utils(tcx, lcx, span_utils)\n+        SaveContext::from_span_utils(tcx, span_utils)\n     }\n \n     pub fn from_span_utils(tcx: &'l TyCtxt<'tcx>,\n-                           lcx: &'l lowering::LoweringContext<'l>,\n                            span_utils: SpanUtils<'tcx>)\n                            -> SaveContext<'l, 'tcx> {\n         SaveContext {\n             tcx: tcx,\n-            lcx: lcx,\n             span_utils: span_utils,\n         }\n     }\n@@ -378,14 +373,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n-        let hir_node = lowering::lower_expr(self.lcx, expr);\n+        let hir_node = self.tcx.map.expect_expr(expr.id);\n         let ty = self.tcx.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::TyError {\n             return None;\n         }\n         match expr.node {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n-                let hir_node = lowering::lower_expr(self.lcx, sub_ex);\n+                let hir_node = self.tcx.map.expect_expr(sub_ex.id);\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyStruct(def, _) => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n@@ -405,7 +400,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::Struct(ref path, _, _) => {\n-                let hir_node = lowering::lower_expr(self.lcx, expr);\n+                let hir_node = self.tcx.map.expect_expr(expr.id);\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyStruct(def, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n@@ -704,7 +699,6 @@ impl Format {\n }\n \n pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n-                               lcx: &'l lowering::LoweringContext<'l>,\n                                krate: &ast::Crate,\n                                analysis: &'l ty::CrateAnalysis<'l>,\n                                cratename: &str,\n@@ -755,7 +749,7 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     let output = &mut output_file;\n \n     let utils: SpanUtils<'tcx> = SpanUtils::new(&tcx.sess);\n-    let save_ctxt = SaveContext::new(tcx, lcx);\n+    let save_ctxt = SaveContext::new(tcx);\n \n     macro_rules! dump {\n         ($new_dumper: expr) => {{"}]}