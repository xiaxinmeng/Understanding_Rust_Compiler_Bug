{"sha": "2483d842fb0113a807bd304908e7a0d002e2a1fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ODNkODQyZmIwMTEzYTgwN2JkMzA0OTA4ZTdhMGQwMDJlMmExZmU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-24T16:55:51Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-24T20:48:01Z"}, "message": "Rollup merge of #48353 - michaelwoerister:monoitem-static-defid, r=eddyb\n\nAllow for instantiating statics from upstream crates\n\nThis PR makes the infrastructure around translating statics a bit more flexible so that it can also instantiate statics from upstream crates if the need arises. This is preparatory work for a MIR-only RLIBs prototype, where the instantiation of a `static` may be deferred until a leaf crate.\n\nr? @eddyb (feel free to assign to someone else if you're busy)", "tree": {"sha": "976c5e6da6e05315931a2ae968380dd8251b7d86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/976c5e6da6e05315931a2ae968380dd8251b7d86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2483d842fb0113a807bd304908e7a0d002e2a1fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2483d842fb0113a807bd304908e7a0d002e2a1fe", "html_url": "https://github.com/rust-lang/rust/commit/2483d842fb0113a807bd304908e7a0d002e2a1fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2483d842fb0113a807bd304908e7a0d002e2a1fe/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1a14096470fd96cc0ca25167623c940a1b96ce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a14096470fd96cc0ca25167623c940a1b96ce9", "html_url": "https://github.com/rust-lang/rust/commit/a1a14096470fd96cc0ca25167623c940a1b96ce9"}, {"sha": "89b3ef3e8eae1a9cf119888341509e10fd7e1b9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/89b3ef3e8eae1a9cf119888341509e10fd7e1b9a", "html_url": "https://github.com/rust-lang/rust/commit/89b3ef3e8eae1a9cf119888341509e10fd7e1b9a"}], "stats": {"total": 294, "additions": 204, "deletions": 90}, "files": [{"sha": "aa678ba788a5bb9e8d3220d13a4f039638c99beb", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -625,7 +625,7 @@ define_dep_nodes!( <'tcx>\n     [eval_always] CollectAndPartitionTranslationItems,\n     [] ExportName(DefId),\n     [] ContainsExternIndicator(DefId),\n-    [] IsTranslatedFunction(DefId),\n+    [] IsTranslatedItem(DefId),\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,"}, {"sha": "3799bdada888e84821e8c4a9a8a163cb8cf4a9a1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -22,6 +22,7 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n+use syntax::ext::base::MacroKind;\n use syntax_pos::Span;\n \n use hir::*;\n@@ -32,13 +33,15 @@ use util::nodemap::{DefIdMap, FxHashMap};\n use arena::TypedArena;\n use std::cell::RefCell;\n use std::io;\n+use ty::TyCtxt;\n \n pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n mod hir_id_validator;\n \n+\n pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n@@ -373,6 +376,92 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id.to_def_id()).unwrap()\n     }\n \n+    pub fn describe_def(&self, node_id: NodeId) -> Option<Def> {\n+        let node = if let Some(node) = self.find(node_id) {\n+            node\n+        } else {\n+            return None\n+        };\n+\n+        match node {\n+            NodeItem(item) => {\n+                let def_id = || {\n+                    self.local_def_id(item.id)\n+                };\n+\n+                match item.node {\n+                    ItemStatic(_, m, _) => Some(Def::Static(def_id(),\n+                                                            m == MutMutable)),\n+                    ItemConst(..) => Some(Def::Const(def_id())),\n+                    ItemFn(..) => Some(Def::Fn(def_id())),\n+                    ItemMod(..) => Some(Def::Mod(def_id())),\n+                    ItemGlobalAsm(..) => Some(Def::GlobalAsm(def_id())),\n+                    ItemTy(..) => Some(Def::TyAlias(def_id())),\n+                    ItemEnum(..) => Some(Def::Enum(def_id())),\n+                    ItemStruct(..) => Some(Def::Struct(def_id())),\n+                    ItemUnion(..) => Some(Def::Union(def_id())),\n+                    ItemTrait(..) => Some(Def::Trait(def_id())),\n+                    ItemTraitAlias(..) => {\n+                        bug!(\"trait aliases are not yet implemented (see issue #41517)\")\n+                    },\n+                    ItemExternCrate(_) |\n+                    ItemUse(..) |\n+                    ItemForeignMod(..) |\n+                    ItemImpl(..) => None,\n+                }\n+            }\n+            NodeForeignItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    ForeignItemFn(..) => Some(Def::Fn(def_id)),\n+                    ForeignItemStatic(_, m) => Some(Def::Static(def_id, m)),\n+                    ForeignItemType => Some(Def::TyForeign(def_id)),\n+                }\n+            }\n+            NodeTraitItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n+                    TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n+                    TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n+                }\n+            }\n+            NodeImplItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n+                    ImplItemKind::Method(..) => Some(Def::Method(def_id)),\n+                    ImplItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n+                }\n+            }\n+            NodeVariant(variant) => {\n+                let def_id = self.local_def_id(variant.node.data.id());\n+                Some(Def::Variant(def_id))\n+            }\n+            NodeField(_) |\n+            NodeExpr(_) |\n+            NodeStmt(_) |\n+            NodeTy(_) |\n+            NodeTraitRef(_) |\n+            NodePat(_) |\n+            NodeBinding(_) |\n+            NodeStructCtor(_) |\n+            NodeLifetime(_) |\n+            NodeVisibility(_) |\n+            NodeBlock(_) => None,\n+            NodeLocal(local) => {\n+                Some(Def::Local(local.id))\n+            }\n+            NodeMacroDef(macro_def) => {\n+                Some(Def::Macro(self.local_def_id(macro_def.id),\n+                                MacroKind::Bang))\n+            }\n+            NodeTyParam(param) => {\n+                Some(Def::TyParam(self.local_def_id(param.id)))\n+            }\n+        }\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }\n@@ -1275,3 +1364,12 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n     }\n }\n+\n+pub fn describe_def(tcx: TyCtxt, def_id: DefId) -> Option<Def> {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+        tcx.hir.describe_def(node_id)\n+    } else {\n+        bug!(\"Calling local describe_def query provider for upstream DefId: {:?}\",\n+             def_id)\n+    }\n+}"}, {"sha": "0fa1b95d8e7776955bd1923738ac8a2edf2b1b86", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -43,6 +43,7 @@ use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n use syntax::util::parser::ExprPrecedence;\n use ty::AdtKind;\n+use ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec;\n \n@@ -2204,3 +2205,8 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n // Map from the NodeId of a glob import to a list of items which are actually\n // imported.\n pub type GlobMap = NodeMap<FxHashSet<Name>>;\n+\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.describe_def = map::describe_def;\n+}"}, {"sha": "7f8f2e9b90603f4a339b91cc96bf74a2bedaed89", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::DefId;\n use syntax::ast::NodeId;\n use syntax::symbol::InternedString;\n use ty::{Instance, TyCtxt};\n@@ -21,7 +22,7 @@ use std::hash::Hash;\n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n-    Static(NodeId),\n+    Static(DefId),\n     GlobalAsm(NodeId),\n }\n \n@@ -50,7 +51,9 @@ impl<'tcx> HashStable<StableHashingContext<'tcx>> for MonoItem<'tcx> {\n             MonoItem::Fn(ref instance) => {\n                 instance.hash_stable(hcx, hasher);\n             }\n-            MonoItem::Static(node_id)    |\n+            MonoItem::Static(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n             MonoItem::GlobalAsm(node_id) => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                     node_id.hash_stable(hcx, hasher);"}, {"sha": "be1d255afa1913eb87513881e19a03422671b5f5", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -349,7 +349,7 @@ define_maps! { <'tcx>\n     [] fn export_name: ExportName(DefId) -> Option<Symbol>,\n     [] fn contains_extern_indicator: ContainsExternIndicator(DefId) -> bool,\n     [] fn symbol_export_level: GetSymbolExportLevel(DefId) -> SymbolExportLevel,\n-    [] fn is_translated_function: IsTranslatedFunction(DefId) -> bool,\n+    [] fn is_translated_item: IsTranslatedItem(DefId) -> bool,\n     [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n     [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,\n     [] fn output_filenames: output_filenames_node(CrateNum)"}, {"sha": "b654b6bc42a122896c018319b39efcaf5c0e07da", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -929,7 +929,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ContainsExternIndicator => {\n             force!(contains_extern_indicator, def_id!());\n         }\n-        DepKind::IsTranslatedFunction => { force!(is_translated_function, def_id!()); }\n+        DepKind::IsTranslatedItem => { force!(is_translated_item, def_id!()); }\n         DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n \n         DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }"}, {"sha": "b03108ed807da0060ecf67e8c37db32cf901ef0f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -932,6 +932,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n }\n \n pub fn default_provide(providers: &mut ty::maps::Providers) {\n+    hir::provide(providers);\n     borrowck::provide(providers);\n     mir::provide(providers);\n     reachable::provide(providers);"}, {"sha": "eb4ba21489c3dc310d66eeae8b7c00bfbaf0190d", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -368,8 +368,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let recursion_depth_reset;\n \n     match starting_point {\n-        MonoItem::Static(node_id) => {\n-            let def_id = tcx.hir.local_def_id(node_id);\n+        MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n@@ -652,8 +651,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         let tcx = self.tcx;\n         let instance = Instance::mono(tcx, static_.def_id);\n         if should_monomorphize_locally(tcx, &instance) {\n-            let node_id = tcx.hir.as_local_node_id(static_.def_id).unwrap();\n-            self.output.push(MonoItem::Static(node_id));\n+            self.output.push(MonoItem::Static(static_.def_id));\n         }\n \n         self.super_static(static_, context, location);\n@@ -946,10 +944,10 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 self.output.push(MonoItem::GlobalAsm(item.id));\n             }\n             hir::ItemStatic(..) => {\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n                 debug!(\"RootCollector: ItemStatic({})\",\n-                       def_id_to_string(self.tcx,\n-                                        self.tcx.hir.local_def_id(item.id)));\n-                self.output.push(MonoItem::Static(item.id));\n+                       def_id_to_string(self.tcx, def_id));\n+                self.output.push(MonoItem::Static(def_id));\n             }\n             hir::ItemConst(..) => {\n                 // const items only generate mono items if they are"}, {"sha": "549919a2c891925d620aae621f8a85ae2ed80a56", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -97,8 +97,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n         match *self.as_mono_item() {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n-            MonoItem::Static(node_id) => {\n-                let def_id = tcx.hir.local_def_id(node_id);\n+            MonoItem::Static(def_id) => {\n                 tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n             MonoItem::GlobalAsm(node_id) => {\n@@ -159,7 +158,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n         let def_id = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => instance.def_id(),\n-            MonoItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n+            MonoItem::Static(def_id) => def_id,\n             MonoItem::GlobalAsm(..) => return None,\n         };\n \n@@ -209,7 +208,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n-            MonoItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n+            MonoItem::Static(def_id) => (def_id, Substs::empty()),\n             // global asm never has predicates\n             MonoItem::GlobalAsm(..) => return true\n         };\n@@ -218,14 +217,11 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     }\n \n     fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.hir;\n-\n         return match *self.as_mono_item() {\n             MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance)\n             },\n-            MonoItem::Static(node_id) => {\n-                let def_id = hir_map.local_def_id(node_id);\n+            MonoItem::Static(def_id) => {\n                 let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n                 to_string_internal(tcx, \"static \", instance)\n             },\n@@ -251,7 +247,9 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir.as_local_node_id(def.def_id())\n             }\n-            MonoItem::Static(node_id) |\n+            MonoItem::Static(def_id) => {\n+                tcx.hir.as_local_node_id(def_id)\n+            }\n             MonoItem::GlobalAsm(node_id) => {\n                 Some(node_id)\n             }"}, {"sha": "2b558e71483c67e893317c7130ab220066ff0f62", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -180,7 +180,9 @@ pub trait CodegenUnitExt<'tcx> {\n                         }\n                     }\n                 }\n-                MonoItem::Static(node_id) |\n+                MonoItem::Static(def_id) => {\n+                    tcx.hir.as_local_node_id(def_id)\n+                }\n                 MonoItem::GlobalAsm(node_id) => {\n                     Some(node_id)\n                 }\n@@ -382,7 +384,15 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         };\n                         (Linkage::External, visibility)\n                     }\n-                    MonoItem::Static(node_id) |\n+                    MonoItem::Static(def_id) => {\n+                        let visibility = if tcx.is_exported_symbol(def_id) {\n+                            can_be_internalized = false;\n+                            default_visibility(def_id)\n+                        } else {\n+                            Visibility::Hidden\n+                        };\n+                        (Linkage::External, visibility)\n+                    }\n                     MonoItem::GlobalAsm(node_id) => {\n                         let def_id = tcx.hir.local_def_id(node_id);\n                         let visibility = if tcx.is_exported_symbol(def_id) {\n@@ -643,7 +653,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             Some(def_id)\n         }\n-        MonoItem::Static(node_id) |\n+        MonoItem::Static(def_id) => Some(def_id),\n         MonoItem::GlobalAsm(node_id) => Some(tcx.hir.local_def_id(node_id)),\n     }\n }"}, {"sha": "c0785f5393716a7d7b9e90b70a3f4f506b80a017", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -1004,6 +1004,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n     let translation_items: DefIdSet = items.iter().filter_map(|trans_item| {\n         match *trans_item {\n             MonoItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Static(def_id) => Some(def_id),\n             _ => None,\n         }\n     }).collect();\n@@ -1107,7 +1108,7 @@ impl CrateInfo {\n     }\n }\n \n-fn is_translated_function(tcx: TyCtxt, id: DefId) -> bool {\n+fn is_translated_item(tcx: TyCtxt, id: DefId) -> bool {\n     let (all_trans_items, _) =\n         tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n     all_trans_items.contains(&id)\n@@ -1222,7 +1223,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.collect_and_partition_translation_items =\n         collect_and_partition_translation_items;\n \n-    providers.is_translated_function = is_translated_function;\n+    providers.is_translated_item = is_translated_item;\n \n     providers.codegen_unit = |tcx, name| {\n         let (_, all) = tcx.collect_and_partition_translation_items(LOCAL_CRATE);"}, {"sha": "8c40aa6a2acba5d2e374ce86304ed7cac5b77930", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -149,7 +149,7 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            if cx.tcx.is_translated_function(instance_def_id) {\n+            if cx.tcx.is_translated_item(instance_def_id) {\n                 if instance_def_id.is_local() {\n                     if !cx.tcx.is_exported_symbol(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);"}, {"sha": "1608c4a87bf5c16ca3eab8df49129cb5b5685f56", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::map as hir_map;\n use rustc::middle::const_val::ConstEvalErr;\n use debuginfo;\n use base;\n-use monomorphize::{MonoItem, MonoItemExt};\n+use monomorphize::MonoItem;\n use common::{CodegenCx, val_ty};\n use declare;\n use monomorphize::Instance;\n@@ -110,21 +110,24 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n+    let defined_in_current_codegen_unit = cx.codegen_unit\n+                                            .items()\n+                                            .contains_key(&MonoItem::Static(def_id));\n+    assert!(!defined_in_current_codegen_unit,\n+            \"consts::get_static() should always hit the cache for \\\n+             statics defined in the same CGU, but did not for `{:?}`\",\n+             def_id);\n+\n     let ty = instance.ty(cx.tcx);\n+    let sym = cx.tcx.symbol_name(instance);\n+\n     let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n \n         let llty = cx.layout_of(ty).llvm_type(cx);\n         let (g, attrs) = match cx.tcx.hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = MonoItem::Static(id).symbol_name(cx.tcx);\n-\n-                let defined_in_current_codegen_unit = cx.codegen_unit\n-                                                         .items()\n-                                                         .contains_key(&MonoItem::Static(id));\n-                assert!(!defined_in_current_codegen_unit);\n-\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n                     span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n@@ -143,7 +146,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = cx.tcx.symbol_name(instance);\n+\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -203,8 +206,6 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = cx.tcx.symbol_name(instance);\n-\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n         let g = declare::declare_global(cx, &sym, cx.layout_of(ty).llvm_type(cx));\n@@ -225,8 +226,15 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             // statically in the final application, we always mark such symbols as 'dllimport'.\n             // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs to\n             // make things work.\n-            unsafe {\n-                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+            //\n+            // However, in some scenarios we defer emission of statics to downstream\n+            // crates, so there are cases where a static with an upstream DefId\n+            // is actually present in the current crate. We can find out via the\n+            // is_translated_item query.\n+            if !cx.tcx.is_translated_item(def_id) {\n+                unsafe {\n+                    llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+                }\n             }\n         }\n         g\n@@ -245,12 +253,11 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n }\n \n pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                              m: hir::Mutability,\n-                              id: ast::NodeId,\n+                              def_id: DefId,\n+                              is_mutable: bool,\n                               attrs: &[ast::Attribute])\n                               -> Result<ValueRef, ConstEvalErr<'tcx>> {\n     unsafe {\n-        let def_id = cx.tcx.hir.local_def_id(id);\n         let g = get_static(cx, def_id);\n \n         let v = ::mir::trans_static_initializer(cx, def_id)?;\n@@ -298,13 +305,13 @@ pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n-        if m != hir::MutMutable {\n+        if !is_mutable {\n             if cx.type_is_freeze(ty) {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }\n \n-        debuginfo::create_global_var_metadata(cx, id, g);\n+        debuginfo::create_global_var_metadata(cx, def_id, g);\n \n         if attr::contains_name(attrs, \"thread_local\") {\n             llvm::set_thread_local_mode(g, cx.tls_model);"}, {"sha": "2c430d03c968ec02d46b05ff75b5513c3dd06200", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -14,7 +14,7 @@ use self::EnumDiscriminantInfo::*;\n \n use super::utils::{debug_context, DIB, span_start,\n                    get_namespace_for_item, create_DIArray, is_node_local_to_unit};\n-use super::namespace::mangled_name_of_item;\n+use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use abi;\n@@ -1634,19 +1634,18 @@ fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_global_var_metadata(cx: &CodegenCx,\n-                                  node_id: ast::NodeId,\n+                                  def_id: DefId,\n                                   global: ValueRef) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n \n     let tcx = cx.tcx;\n-    let node_def_id = tcx.hir.local_def_id(node_id);\n-    let no_mangle = attr::contains_name(&tcx.get_attrs(node_def_id), \"no_mangle\");\n+    let no_mangle = attr::contains_name(&tcx.get_attrs(def_id), \"no_mangle\");\n     // We may want to remove the namespace scope if we're in an extern block, see:\n     // https://github.com/rust-lang/rust/pull/46457#issuecomment-351750952\n-    let var_scope = get_namespace_for_item(cx, node_def_id);\n-    let span = cx.tcx.def_span(node_def_id);\n+    let var_scope = get_namespace_for_item(cx, def_id);\n+    let span = cx.tcx.def_span(def_id);\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n         let loc = span_start(cx, span);\n@@ -1655,15 +1654,15 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n         (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER)\n     };\n \n-    let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = Instance::mono(cx.tcx, node_def_id).ty(cx.tcx);\n+    let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n+    let variable_type = Instance::mono(cx.tcx, def_id).ty(cx.tcx);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let var_name = tcx.item_name(node_def_id).to_string();\n+    let var_name = tcx.item_name(def_id).to_string();\n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = if no_mangle {\n         None\n     } else {\n-        let linkage_name = mangled_name_of_item(cx, node_id);\n+        let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id));\n         Some(CString::new(linkage_name.to_string()).unwrap())\n     };\n "}, {"sha": "16279f31836a984c2e6cd78ae7ff278310ea1b15", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -254,14 +254,14 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let linkage_name = mangled_name_of_instance(cx, instance);\n \n     let scope_line = span_start(cx, span).line;\n-\n-    let local_id = cx.tcx.hir.as_local_node_id(instance.def_id());\n-    let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n+    let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n \n     let function_name = CString::new(name).unwrap();\n     let linkage_name = CString::new(linkage_name.to_string()).unwrap();\n \n     let mut flags = DIFlags::FlagPrototyped;\n+\n+    let local_id = cx.tcx.hir.as_local_node_id(def_id);\n     match *cx.sess().entry_fn.borrow() {\n         Some((id, _)) => {\n             if local_id == Some(id) {"}, {"sha": "891bf649c388a02aa7a6549408cf0113f5817439", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -14,7 +14,6 @@ use super::metadata::{unknown_file_metadata, UNKNOWN_LINE_NUMBER};\n use super::utils::{DIB, debug_context};\n use monomorphize::Instance;\n use rustc::ty;\n-use syntax::ast;\n \n use llvm;\n use llvm::debuginfo::DIScope;\n@@ -33,16 +32,6 @@ pub fn mangled_name_of_instance<'a, 'tcx>(\n      tcx.symbol_name(instance)\n }\n \n-pub fn mangled_name_of_item<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n-    node_id: ast::NodeId,\n-) -> ty::SymbolName {\n-    let tcx = cx.tcx;\n-    let node_def_id = tcx.hir.local_def_id(node_id);\n-    let instance = Instance::mono(tcx, node_def_id);\n-    tcx.symbol_name(instance)\n-}\n-\n pub fn item_namespace(cx: &CodegenCx, def_id: DefId) -> DIScope {\n     if let Some(&scope) = debug_context(cx).namespace_map.borrow().get(&def_id) {\n         return scope;"}, {"sha": "9559cd4d9ea2d52e2088bc147eb27446cb0b65d9", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -21,9 +21,8 @@ use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n use common::{CodegenCx};\n \n use syntax_pos::{self, Span};\n-use syntax::ast;\n \n-pub fn is_node_local_to_unit(cx: &CodegenCx, node_id: ast::NodeId) -> bool\n+pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n     // current compilation unit (i.e. if it is *static* in the C-sense). The\n@@ -33,7 +32,6 @@ pub fn is_node_local_to_unit(cx: &CodegenCx, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    let def_id = cx.tcx.hir.local_def_id(node_id);\n     !cx.tcx.is_exported_symbol(def_id)\n }\n "}, {"sha": "91c1097fc7f8a5dc733384495effaf6c587440ca", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2483d842fb0113a807bd304908e7a0d002e2a1fe/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=2483d842fb0113a807bd304908e7a0d002e2a1fe", "patch": "@@ -24,10 +24,11 @@ use llvm;\n use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::TypeFoldable;\n use rustc::ty::layout::LayoutOf;\n-use syntax::ast;\n use syntax::attr;\n use std::fmt;\n \n@@ -44,19 +45,25 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                cx.codegen_unit.name());\n \n         match *self.as_mono_item() {\n-            MonoItem::Static(node_id) => {\n+            MonoItem::Static(def_id) => {\n                 let tcx = cx.tcx;\n-                let item = tcx.hir.expect_item(node_id);\n-                if let hir::ItemStatic(_, m, _) = item.node {\n-                    match consts::trans_static(&cx, m, item.id, &item.attrs) {\n-                        Ok(_) => { /* Cool, everything's alright. */ },\n-                        Err(err) => {\n-                            err.report(tcx, item.span, \"static\");\n-                        }\n-                    };\n-                } else {\n-                    span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n-                }\n+                let is_mutable = match tcx.describe_def(def_id) {\n+                    Some(Def::Static(_, is_mutable)) => is_mutable,\n+                    Some(other) => {\n+                        bug!(\"Expected Def::Static, found {:?}\", other)\n+                    }\n+                    None => {\n+                        bug!(\"Expected Def::Static for {:?}, found nothing\", def_id)\n+                    }\n+                };\n+                let attrs = tcx.get_attrs(def_id);\n+\n+                match consts::trans_static(&cx, def_id, is_mutable, &attrs) {\n+                    Ok(_) => { /* Cool, everything's alright. */ },\n+                    Err(err) => {\n+                        err.report(tcx, tcx.def_span(def_id), \"static\");\n+                    }\n+                };\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);\n@@ -91,8 +98,8 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         debug!(\"symbol {}\", &symbol_name);\n \n         match *self.as_mono_item() {\n-            MonoItem::Static(node_id) => {\n-                predefine_static(cx, node_id, linkage, visibility, &symbol_name);\n+            MonoItem::Static(def_id) => {\n+                predefine_static(cx, def_id, linkage, visibility, &symbol_name);\n             }\n             MonoItem::Fn(instance) => {\n                 predefine_fn(cx, instance, linkage, visibility, &symbol_name);\n@@ -126,17 +133,16 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n \n fn predefine_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                              node_id: ast::NodeId,\n+                              def_id: DefId,\n                               linkage: Linkage,\n                               visibility: Visibility,\n                               symbol_name: &str) {\n-    let def_id = cx.tcx.hir.local_def_id(node_id);\n     let instance = Instance::mono(cx.tcx, def_id);\n     let ty = instance.ty(cx.tcx);\n     let llty = cx.layout_of(ty).llvm_type(cx);\n \n     let g = declare::define_global(cx, symbol_name, llty).unwrap_or_else(|| {\n-        cx.sess().span_fatal(cx.tcx.hir.span(node_id),\n+        cx.sess().span_fatal(cx.tcx.def_span(def_id),\n             &format!(\"symbol `{}` is already defined\", symbol_name))\n     });\n "}]}