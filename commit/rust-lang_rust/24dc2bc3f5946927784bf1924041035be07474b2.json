{"sha": "24dc2bc3f5946927784bf1924041035be07474b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZGMyYmMzZjU5NDY5Mjc3ODRiZjE5MjQwNDEwMzViZTA3NDc0YjI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-11-11T04:42:59Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-11-11T04:42:59Z"}, "message": "use an 'imp' module to reduce the amount of cfgs", "tree": {"sha": "5eedb709a7d838a03c0f8650fe61fb29843be2e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5eedb709a7d838a03c0f8650fe61fb29843be2e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24dc2bc3f5946927784bf1924041035be07474b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24dc2bc3f5946927784bf1924041035be07474b2", "html_url": "https://github.com/rust-lang/rust/commit/24dc2bc3f5946927784bf1924041035be07474b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24dc2bc3f5946927784bf1924041035be07474b2/comments", "author": null, "committer": null, "parents": [{"sha": "907d2a1aeb26151cc81dfa148e874e4fe50d1a14", "url": "https://api.github.com/repos/rust-lang/rust/commits/907d2a1aeb26151cc81dfa148e874e4fe50d1a14", "html_url": "https://github.com/rust-lang/rust/commit/907d2a1aeb26151cc81dfa148e874e4fe50d1a14"}], "stats": {"total": 59, "additions": 32, "deletions": 27}, "files": [{"sha": "87ae16f6c53adc08ff6cea7b3a302deee2886541", "filename": "src/liballoc/oom.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/24dc2bc3f5946927784bf1924041035be07474b2/src%2Fliballoc%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24dc2bc3f5946927784bf1924041035be07474b2/src%2Fliballoc%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Foom.rs?ref=24dc2bc3f5946927784bf1924041035be07474b2", "patch": "@@ -9,49 +9,54 @@\n // except according to those terms.\n \n #[cfg(target_has_atomic = \"ptr\")]\n-use core::sync::atomic::{AtomicPtr, Ordering};\n-#[cfg(target_has_atomic = \"ptr\")]\n-use core::mem;\n+pub use self::imp::set_oom_handler;\n use core::intrinsics;\n \n-#[cfg(target_has_atomic = \"ptr\")]\n-static OOM_HANDLER: AtomicPtr<()> = AtomicPtr::new(default_oom_handler as *mut ());\n-\n fn default_oom_handler() -> ! {\n     // The default handler can't do much more since we can't assume the presence\n     // of libc or any way of printing an error message.\n     unsafe { intrinsics::abort() }\n }\n \n /// Common out-of-memory routine\n-#[cfg(target_has_atomic = \"ptr\")]\n #[cold]\n #[inline(never)]\n #[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n            issue = \"27700\")]\n pub fn oom() -> ! {\n-    let value = OOM_HANDLER.load(Ordering::SeqCst);\n-    let handler: fn() -> ! = unsafe { mem::transmute(value) };\n-    handler();\n+    self::imp::oom()\n }\n \n-/// Common out-of-memory routine\n-#[cfg(not(target_has_atomic = \"ptr\"))]\n-#[cold]\n-#[inline(never)]\n-#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n-           issue = \"27700\")]\n-pub fn oom() -> ! {\n-    default_oom_handler()\n+#[cfg(target_has_atomic = \"ptr\")]\n+mod imp {\n+    use core::mem;\n+    use core::sync::atomic::{AtomicPtr, Ordering};\n+\n+    static OOM_HANDLER: AtomicPtr<()> = AtomicPtr::new(super::default_oom_handler as *mut ());\n+\n+    #[inline(always)]\n+    pub fn oom() -> ! {\n+        let value = OOM_HANDLER.load(Ordering::SeqCst);\n+        let handler: fn() -> ! = unsafe { mem::transmute(value) };\n+        handler();\n+    }\n+\n+    /// Set a custom handler for out-of-memory conditions\n+    ///\n+    /// To avoid recursive OOM failures, it is critical that the OOM handler does\n+    /// not allocate any memory itself.\n+    #[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n+               issue = \"27700\")]\n+    pub fn set_oom_handler(handler: fn() -> !) {\n+        OOM_HANDLER.store(handler as *mut (), Ordering::SeqCst);\n+    }\n+\n }\n \n-/// Set a custom handler for out-of-memory conditions\n-///\n-/// To avoid recursive OOM failures, it is critical that the OOM handler does\n-/// not allocate any memory itself.\n-#[cfg(target_has_atomic = \"ptr\")]\n-#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n-           issue = \"27700\")]\n-pub fn set_oom_handler(handler: fn() -> !) {\n-    OOM_HANDLER.store(handler as *mut (), Ordering::SeqCst);\n+#[cfg(not(target_has_atomic = \"ptr\"))]\n+mod imp {\n+    #[inline(always)]\n+    pub fn oom() -> ! {\n+        super::default_oom_handler()\n+    }\n }"}]}