{"sha": "f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZmUyMDRkY2NlOGY2NTA5ZTUxYjNjNTE4ZmMwMmQ3ZTBlMjVlOTI=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-06-22T22:39:43Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-06-23T12:07:35Z"}, "message": "Consolidate codemap tests and fix more errors for travis", "tree": {"sha": "497ce51943e4dd162a664852b412212da4485c81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/497ce51943e4dd162a664852b412212da4485c81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "html_url": "https://github.com/rust-lang/rust/commit/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/comments", "author": null, "committer": null, "parents": [{"sha": "51deb4fedbdab4b9b5a7610985c0be54e89cae73", "url": "https://api.github.com/repos/rust-lang/rust/commits/51deb4fedbdab4b9b5a7610985c0be54e89cae73", "html_url": "https://github.com/rust-lang/rust/commit/51deb4fedbdab4b9b5a7610985c0be54e89cae73"}], "stats": {"total": 1691, "additions": 828, "deletions": 863}, "files": [{"sha": "a37990061920b6fa299a2de535010bb78a8490e7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "patch": "@@ -1421,12 +1421,11 @@ mod tests {\n     use middle::cstore::DummyCrateStore;\n     use session::config::{build_configuration, build_session_options};\n     use session::build_session;\n-\n+    use errors;\n     use std::rc::Rc;\n     use getopts::{getopts, OptGroup};\n     use syntax::attr;\n     use syntax::attr::AttrMetaMethods;\n-    use syntax::diagnostics;\n \n     fn optgroups() -> Vec<OptGroup> {\n         super::rustc_optgroups().into_iter()\n@@ -1443,7 +1442,7 @@ mod tests {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n-        let registry = diagnostics::registry::Registry::new(&[]);\n+        let registry = errors::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess);\n@@ -1463,7 +1462,7 @@ mod tests {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n               }\n             };\n-        let registry = diagnostics::registry::Registry::new(&[]);\n+        let registry = errors::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry,\n                                  Rc::new(DummyCrateStore));\n@@ -1480,7 +1479,7 @@ mod tests {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n             ], &optgroups()).unwrap();\n-            let registry = diagnostics::registry::Registry::new(&[]);\n+            let registry = errors::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n@@ -1492,7 +1491,7 @@ mod tests {\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n             ], &optgroups()).unwrap();\n-            let registry = diagnostics::registry::Registry::new(&[]);\n+            let registry = errors::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));\n@@ -1503,7 +1502,7 @@ mod tests {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n             ], &optgroups()).unwrap();\n-            let registry = diagnostics::registry::Registry::new(&[]);\n+            let registry = errors::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n                                      Rc::new(DummyCrateStore));"}, {"sha": "d46a8f3c453d6ba15fb05d066b5fdc35af11e65d", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 1, "deletions": 254, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "patch": "@@ -358,7 +358,7 @@ impl EmitterWriter {\n         Ok(())\n     }\n \n-    fn highlight_lines(&mut self,\n+    pub fn highlight_lines(&mut self,\n                        msp: &MultiSpan,\n                        lvl: Level)\n                        -> io::Result<()>\n@@ -619,256 +619,3 @@ impl Write for Destination {\n         }\n     }\n }\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use errors::{Level, CodeSuggestion};\n-    use super::EmitterWriter;\n-    use codemap::CodeMap;\n-    use syntax_pos::{mk_sp, Span, MultiSpan, BytePos, NO_EXPANSION};\n-    use std::sync::{Arc, Mutex};\n-    use std::io::{self, Write};\n-    use std::str::from_utf8;\n-    use std::rc::Rc;\n-\n-    struct Sink(Arc<Mutex<Vec<u8>>>);\n-    impl Write for Sink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            Write::write(&mut *self.0.lock().unwrap(), data)\n-        }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-    }\n-\n-    /// Given a string like \" ^~~~~~~~~~~~ \", produces a span\n-    /// coverting that range. The idea is that the string has the same\n-    /// length as the input, and we uncover the byte positions.  Note\n-    /// that this can span lines and so on.\n-    fn span_from_selection(input: &str, selection: &str) -> Span {\n-        assert_eq!(input.len(), selection.len());\n-        let left_index = selection.find('~').unwrap() as u32;\n-        let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n-    }\n-\n-    // Diagnostic doesn't align properly in span where line number increases by one digit\n-    #[test]\n-    fn test_hilight_suggestion_issue_11715() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n-        let content = \"abcdefg\n-        koksi\n-        line3\n-        line4\n-        cinq\n-        line6\n-        line7\n-        line8\n-        line9\n-        line10\n-        e-l\u00e4-v\u00e4n\n-        tolv\n-        dreizehn\n-        \";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, content);\n-        let start = file.lines.borrow()[10];\n-        let end = file.lines.borrow()[11];\n-        let sp = mk_sp(start, end);\n-        let lvl = Level::Error;\n-        println!(\"highlight_lines\");\n-        ew.highlight_lines(&sp.into(), lvl).unwrap();\n-        println!(\"done\");\n-        let vec = data.lock().unwrap().clone();\n-        let vec: &[u8] = &vec;\n-        let str = from_utf8(vec).unwrap();\n-        println!(\"r#\\\"\\n{}\\\"#\", str);\n-        assert_eq!(str, &r#\"\n-  --> dummy.txt:11:1\n-   |>\n-11 |>         e-l\u00e4-v\u00e4n\n-   |> ^\n-\"#[1..]);\n-    }\n-\n-    #[test]\n-    fn test_single_span_splice() {\n-        // Test that a `MultiSpan` containing a single span splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp = span_from_selection(inputtext, selection);\n-        let msp: MultiSpan = sp.into();\n-\n-        // check that we are extracting the text we thought we were extracting\n-        assert_eq!(&cm.span_to_snippet(sp).unwrap(), \"BB\\nCCC\\nDDDDD\");\n-\n-        let substitute = \"ZZZZZZ\".to_owned();\n-        let expected = \"bbbbZZZZZZddddd\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![substitute],\n-        };\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multi_span_splice() {\n-        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n-        let cm = CodeMap::new();\n-        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n-        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let sp1 = span_from_selection(inputtext, selection1);\n-        let sp2 = span_from_selection(inputtext, selection2);\n-        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n-\n-        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n-        let suggest = CodeSuggestion {\n-            msp: msp,\n-            substitutes: vec![\"ZZZZZZ\".to_owned(),\n-                              \"XYZ\".to_owned()]\n-        };\n-\n-        assert_eq!(suggest.splice_lines(&cm), expected);\n-    }\n-\n-    #[test]\n-    fn test_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n-\n-        let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n-        let sp1 =       \"     ~~~~~~                    \";\n-        let sp2 =       \"               ~~~~~~          \";\n-        let sp3 =       \"                       ~~~~~   \";\n-        let sp4 =       \"                          ~~~~ \";\n-        let sp34 =      \"                       ~~~~~~~ \";\n-\n-        let expect_start = &r#\"\n- --> dummy.txt:1:6\n-  |>\n-1 |> _____aaaaaa____bbbbbb__cccccdd_\n-  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n-\"#[1..];\n-\n-        let span = |sp, expected| {\n-            let sp = span_from_selection(inp, sp);\n-            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n-            sp\n-        };\n-        cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-        let sp1 = span(sp1, \"aaaaaa\");\n-        let sp2 = span(sp2, \"bbbbbb\");\n-        let sp3 = span(sp3, \"ccccc\");\n-        let sp4 = span(sp4, \"ccdd\");\n-        let sp34 = span(sp34, \"cccccdd\");\n-\n-        let spans = vec![sp1, sp2, sp3, sp4];\n-\n-        let test = |expected, highlight: &mut FnMut()| {\n-            data.lock().unwrap().clear();\n-            highlight();\n-            let vec = data.lock().unwrap().clone();\n-            let actual = from_utf8(&vec[..]).unwrap();\n-            println!(\"actual=\\n{}\", actual);\n-            assert_eq!(actual, expected);\n-        };\n-\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n-        test(expect_start, &mut || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-        test(expect_start, &mut || {\n-            let msp = MultiSpan::from_spans(spans.clone());\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-\n-    #[test]\n-    fn test_huge_multispan_highlight() {\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let cm = Rc::new(CodeMap::new());\n-        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n-\n-        let inp = \"aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   aaaaa\\n\\\n-                   bbbbb\\n\\\n-                   ccccc\\n\\\n-                   xxxxx\\n\\\n-                   yyyyy\\n\\\n-                   _____\\n\\\n-                   ddd__eee_\\n\\\n-                   elided\\n\\\n-                   __f_gg\";\n-        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n-\n-        let span = |lo, hi, (off_lo, off_hi)| {\n-            let lines = file.lines.borrow();\n-            let (mut lo, mut hi): (BytePos, BytePos) = (lines[lo], lines[hi]);\n-            lo.0 += off_lo;\n-            hi.0 += off_hi;\n-            mk_sp(lo, hi)\n-        };\n-        let sp0 = span(4, 6, (0, 5));\n-        let sp1 = span(0, 6, (0, 5));\n-        let sp2 = span(8, 8, (0, 3));\n-        let sp3 = span(8, 8, (5, 8));\n-        let sp4 = span(10, 10, (2, 3));\n-        let sp5 = span(10, 10, (4, 6));\n-\n-        let expect0 = &r#\"\n-   --> dummy.txt:5:1\n-    |>\n-5   |> ccccc\n-    |> ^\n-...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n-\"#[1..];\n-\n-        let expect = &r#\"\n-   --> dummy.txt:1:1\n-    |>\n-1   |> aaaaa\n-    |> ^\n-...\n-9   |> ddd__eee_\n-    |> ^^^  ^^^\n-10  |> elided\n-11  |> __f_gg\n-    |>   ^ ^^\n-\"#[1..];\n-\n-        macro_rules! test {\n-            ($expected: expr, $highlight: expr) => ({\n-                data.lock().unwrap().clear();\n-                $highlight();\n-                let vec = data.lock().unwrap().clone();\n-                let actual = from_utf8(&vec[..]).unwrap();\n-                println!(\"actual:\");\n-                println!(\"{}\", actual);\n-                println!(\"expected:\");\n-                println!(\"{}\", $expected);\n-                assert_eq!(&actual[..], &$expected[..]);\n-            });\n-        }\n-\n-        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n-        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n-\n-        test!(expect0, || {\n-            diag.highlight_lines(&msp0, Level::Error).unwrap();\n-        });\n-        test!(expect, || {\n-            diag.highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-    }\n-}"}, {"sha": "c472994599ccb40ee0dc659ec5fa5a0a2f12be55", "filename": "src/librustc_errors/snippet/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibrustc_errors%2Fsnippet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibrustc_errors%2Fsnippet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet%2Fmod.rs?ref=f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "patch": "@@ -17,8 +17,6 @@ use std::cmp;\n use std::rc::Rc;\n use std::mem;\n \n-mod test;\n-\n #[derive(Clone)]\n pub struct SnippetData {\n     codemap: Rc<CodeMapper>,"}, {"sha": "f5faccbe528f06b2617840d4df07bc9e6ccf3b91", "filename": "src/librustc_errors/snippet/test.rs", "status": "removed", "additions": 0, "deletions": 598, "changes": 598, "blob_url": "https://github.com/rust-lang/rust/blob/51deb4fedbdab4b9b5a7610985c0be54e89cae73/src%2Flibrustc_errors%2Fsnippet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51deb4fedbdab4b9b5a7610985c0be54e89cae73/src%2Flibrustc_errors%2Fsnippet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet%2Ftest.rs?ref=51deb4fedbdab4b9b5a7610985c0be54e89cae73", "patch": "@@ -1,598 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Code for testing annotated snippets.\n-\n-#![cfg(test)]\n-\n-use codemap::{CodeMap};\n-use syntax_pos::{NO_EXPANSION, Span, FileMap, BytePos};\n-use std::rc::Rc;\n-use super::{RenderedLine, SnippetData};\n-\n-/// Returns the span corresponding to the `n`th occurrence of\n-/// `substring` in `source_text`.\n-trait CodeMapExtension {\n-    fn span_substr(&self,\n-                   file: &Rc<FileMap>,\n-                   source_text: &str,\n-                   substring: &str,\n-                   n: usize)\n-                   -> Span;\n-}\n-\n-impl CodeMapExtension for CodeMap {\n-    fn span_substr(&self,\n-                   file: &Rc<FileMap>,\n-                   source_text: &str,\n-                   substring: &str,\n-                   n: usize)\n-                   -> Span\n-    {\n-        println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n-                 file.name, file.start_pos, substring, n);\n-        let mut i = 0;\n-        let mut hi = 0;\n-        loop {\n-            let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n-                panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n-                       source_text, n, substring, i);\n-            });\n-            let lo = hi + offset;\n-            hi = lo + substring.len();\n-            if i == n {\n-                let span = Span {\n-                    lo: BytePos(lo as u32 + file.start_pos.0),\n-                    hi: BytePos(hi as u32 + file.start_pos.0),\n-                    expn_id: NO_EXPANSION,\n-                };\n-                assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n-                           substring);\n-                return span;\n-            }\n-            i += 1;\n-        }\n-    }\n-}\n-\n-fn splice(start: Span, end: Span) -> Span {\n-    Span {\n-        lo: start.lo,\n-        hi: end.hi,\n-        expn_id: NO_EXPANSION,\n-    }\n-}\n-\n-fn make_string(lines: &[RenderedLine]) -> String {\n-    lines.iter()\n-         .flat_map(|rl| {\n-             rl.text.iter()\n-                    .map(|s| &s.text[..])\n-                    .chain(Some(\"\\n\"))\n-         })\n-         .collect()\n-}\n-\n-#[test]\n-fn tab() {\n-    let file_text = \"\n-fn foo() {\n-\\tbar;\n-}\n-\";\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, Some(span_bar));\n-    snippet.push(span_bar, true, None);\n-\n-    let lines = snippet.render_lines();\n-    let text = make_string(&lines);\n-    assert_eq!(&text[..], &\"\n- --> foo.rs:3:2\n-  |>\n-3 |> \\tbar;\n-  |> \\t^^^\n-\"[1..]);\n-}\n-\n-#[test]\n-fn one_line() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn two_files() {\n-    let file_text_foo = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let file_text_bar = r#\"\n-fn bar() {\n-    // these blank links here\n-    // serve to ensure that the line numbers\n-    // from bar.rs\n-    // require more digits\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-    vec.push();\n-\n-    // this line will get elided\n-\n-    vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n-    let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n-    let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n-    let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n-\n-    let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n-    let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n-    let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n-    let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, Some(span_foo_vec1));\n-    snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n-    snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n-    snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n-    snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n-    snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n-    snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-\n-    // Note that the `|>` remain aligned across both files:\n-    assert_eq!(&text[..], &r#\"\n-   --> foo.rs:3:14\n-    |>\n-3   |>     vec.push(vec.pop().unwrap());\n-    |>     ---      ^^^                - c\n-    |>     |        |\n-    |>     |        b\n-    |>     a\n-   ::: bar.rs\n-    |>\n-17  |>     vec.push();\n-    |>     ---       - f\n-    |>     |\n-    |>     d\n-...\n-21  |>     vec.pop().unwrap());\n-    |>     --- e\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn multi_line() {\n-    let file_text = r#\"\n-fn foo() {\n-    let name = find_id(&data, 22).unwrap();\n-\n-    // Add one more item we forgot to the vector. Silly us.\n-    data.push(Data { name: format!(\"Hera\"), id: 66 });\n-\n-    // Print everything out.\n-    println!(\"Name: {:?}\", name);\n-    println!(\"Data: {:?}\", data);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n-    let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n-    let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n-    snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n-    snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-    assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-3   |>     let name = find_id(&data, 22).unwrap();\n-    |>                         ---- immutable borrow begins here\n-...\n-6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n-    |>     ---- mutable borrow occurs here\n-...\n-11  |> }\n-    |> - immutable borrow ends here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn overlapping() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n-    let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n-    let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span0, false, Some(format!(\"A\")));\n-    snippet.push(span1, false, Some(format!(\"B\")));\n-    snippet.push(span2, false, Some(format!(\"C\")));\n-    snippet.push(span3, false, Some(format!(\"D\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     --------           ------ D\n-  |>     ||\n-  |>     |C\n-  |>     A\n-  |>     B\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn one_line_out_of_order() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-    // intentionally don't push the snippets left to right\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn elide_unnecessary_lines() {\n-    let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n-        has type `collections::vec::Vec<i32>`\")));\n-    snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-4   |>     let mut vec2 = vec;\n-    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n-...\n-9   |>     vec.push(7);\n-    |>     --- use of moved value: `vec`\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn spans_without_labels() {\n-    let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    for i in 0..4 {\n-        let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n-        snippet.push(span_veci, false, None);\n-    }\n-\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     let mut vec = vec![0, 1, 2];\n-  |>             ---   ---\n-4 |>     let mut vec2 = vec;\n-  |>             ---    ---\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_long_selection() {\n-    let file_text = r#\"\n-impl SomeTrait for () {\n-    fn foo(x: u32) {\n-        // impl 1\n-        // impl 2\n-        // impl 3\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n-    let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-    snippet.push(splice(fn_span, rbrace_span), false, None);\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     fn foo(x: u32) {\n-  |>     -\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it.\n-\n-    let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n-    let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n-    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-    snippet.push(x_span, false, Some(format!(\"x_span\")));\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label2() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it. In this\n-    // case, the overlap is only at the beginning, but it's still\n-    // better to show the beginning more clearly.\n-\n-    let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n-    let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n-    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-    snippet.push(x_span, false, Some(format!(\"x_span\")));\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label3() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it. In this\n-    // case, the overlap is only at the beginning, but it's still\n-    // better to show the beginning more clearly.\n-\n-    let file_text = r#\"\n-    fn foo() {\n-       let closure = || {\n-           inner\n-       };\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-\n-    let closure_span = {\n-        let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n-        let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-        splice(closure_start_span, closure_end_span)\n-    };\n-\n-    let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n-\n-    snippet.push(closure_span, false, Some(format!(\"foo\")));\n-    snippet.push(inner_span, false, Some(format!(\"bar\")));\n-\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>        let closure = || {\n-  |>                      - foo\n-4 |>            inner\n-  |>            ----- bar\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_empty() {\n-    // In one of the unit tests, we found that the parser sometimes\n-    // gives empty spans, and in particular it supplied an EOF span\n-    // like this one, which points at the very end. We want to\n-    // fallback gracefully in this case.\n-\n-    let file_text = r#\"\n-fn main() {\n-    struct Foo;\n-\n-    impl !Sync for Foo {}\n-\n-    unsafe impl Send for &'static Foo {\n-    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n-    //        can only be implemented for a struct/enum type, not\n-    //        `&'static Foo`\n-}\"#;\n-\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n-    rbrace_span.lo = rbrace_span.hi;\n-\n-    let mut snippet = SnippetData::new(cm.clone(), Some(rbrace_span));\n-    snippet.push(rbrace_span, false, None);\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n-  --> foo.rs:11:2\n-   |>\n-11 |> }\n-   |>  -\n-\"#[1..]);\n-}"}, {"sha": "cfa13f7f95ad2f8f486c6732717eace425155ea8", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "patch": "@@ -828,6 +828,12 @@ impl CodeMapper for CodeMap {\n mod tests {\n     use super::*;\n     use syntax_pos::*;\n+    use errors::{Level, CodeSuggestion};\n+    use errors::emitter::EmitterWriter;\n+    use std::sync::{Arc, Mutex};\n+    use std::io::{self, Write};\n+    use std::str::from_utf8;\n+    use std::rc::Rc;\n \n     #[test]\n     fn t1 () {\n@@ -1150,4 +1156,233 @@ r\"blork2.rs:2:1: 2:12\n \";\n         assert_eq!(sstr, res_str);\n     }\n+\n+    struct Sink(Arc<Mutex<Vec<u8>>>);\n+    impl Write for Sink {\n+        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+            Write::write(&mut *self.0.lock().unwrap(), data)\n+        }\n+        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    }\n+\n+    // Diagnostic doesn't align properly in span where line number increases by one digit\n+    #[test]\n+    fn test_hilight_suggestion_issue_11715() {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut ew = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n+        let content = \"abcdefg\n+        koksi\n+        line3\n+        line4\n+        cinq\n+        line6\n+        line7\n+        line8\n+        line9\n+        line10\n+        e-l\u00e4-v\u00e4n\n+        tolv\n+        dreizehn\n+        \";\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, content);\n+        let start = file.lines.borrow()[10];\n+        let end = file.lines.borrow()[11];\n+        let sp = mk_sp(start, end);\n+        let lvl = Level::Error;\n+        println!(\"highlight_lines\");\n+        ew.highlight_lines(&sp.into(), lvl).unwrap();\n+        println!(\"done\");\n+        let vec = data.lock().unwrap().clone();\n+        let vec: &[u8] = &vec;\n+        let str = from_utf8(vec).unwrap();\n+        println!(\"r#\\\"\\n{}\\\"#\", str);\n+        assert_eq!(str, &r#\"\n+  --> dummy.txt:11:1\n+   |>\n+11 |>         e-l\u00e4-v\u00e4n\n+   |> ^\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn test_single_span_splice() {\n+        // Test that a `MultiSpan` containing a single span splices a substition correctly\n+        let cm = CodeMap::new();\n+        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        let sp = span_from_selection(inputtext, selection);\n+        let msp: MultiSpan = sp.into();\n+\n+        // check that we are extracting the text we thought we were extracting\n+        assert_eq!(&cm.span_to_snippet(sp).unwrap(), \"BB\\nCCC\\nDDDDD\");\n+\n+        let substitute = \"ZZZZZZ\".to_owned();\n+        let expected = \"bbbbZZZZZZddddd\";\n+        let suggest = CodeSuggestion {\n+            msp: msp,\n+            substitutes: vec![substitute],\n+        };\n+        assert_eq!(suggest.splice_lines(&cm), expected);\n+    }\n+\n+    #[test]\n+    fn test_multi_span_splice() {\n+        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n+        let cm = CodeMap::new();\n+        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n+        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n+        let sp1 = span_from_selection(inputtext, selection1);\n+        let sp2 = span_from_selection(inputtext, selection2);\n+        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n+\n+        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n+        let suggest = CodeSuggestion {\n+            msp: msp,\n+            substitutes: vec![\"ZZZZZZ\".to_owned(),\n+                              \"XYZ\".to_owned()]\n+        };\n+\n+        assert_eq!(suggest.splice_lines(&cm), expected);\n+    }\n+\n+    #[test]\n+    fn test_multispan_highlight() {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n+\n+        let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n+        let sp1 =       \"     ~~~~~~                    \";\n+        let sp2 =       \"               ~~~~~~          \";\n+        let sp3 =       \"                       ~~~~~   \";\n+        let sp4 =       \"                          ~~~~ \";\n+        let sp34 =      \"                       ~~~~~~~ \";\n+\n+        let expect_start = &r#\"\n+ --> dummy.txt:1:6\n+  |>\n+1 |> _____aaaaaa____bbbbbb__cccccdd_\n+  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n+\"#[1..];\n+\n+        let span = |sp, expected| {\n+            let sp = span_from_selection(inp, sp);\n+            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n+            sp\n+        };\n+        cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n+        let sp1 = span(sp1, \"aaaaaa\");\n+        let sp2 = span(sp2, \"bbbbbb\");\n+        let sp3 = span(sp3, \"ccccc\");\n+        let sp4 = span(sp4, \"ccdd\");\n+        let sp34 = span(sp34, \"cccccdd\");\n+\n+        let spans = vec![sp1, sp2, sp3, sp4];\n+\n+        let test = |expected, highlight: &mut FnMut()| {\n+            data.lock().unwrap().clear();\n+            highlight();\n+            let vec = data.lock().unwrap().clone();\n+            let actual = from_utf8(&vec[..]).unwrap();\n+            println!(\"actual=\\n{}\", actual);\n+            assert_eq!(actual, expected);\n+        };\n+\n+        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n+        test(expect_start, &mut || {\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+        test(expect_start, &mut || {\n+            let msp = MultiSpan::from_spans(spans.clone());\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+    }\n+\n+    #[test]\n+    fn test_huge_multispan_highlight() {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let cm = Rc::new(CodeMap::new());\n+        let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n+\n+        let inp = \"aaaaa\\n\\\n+                   aaaaa\\n\\\n+                   aaaaa\\n\\\n+                   bbbbb\\n\\\n+                   ccccc\\n\\\n+                   xxxxx\\n\\\n+                   yyyyy\\n\\\n+                   _____\\n\\\n+                   ddd__eee_\\n\\\n+                   elided\\n\\\n+                   __f_gg\";\n+        let file = cm.new_filemap_and_lines(\"dummy.txt\", None, inp);\n+\n+        let span = |lo, hi, (off_lo, off_hi)| {\n+            let lines = file.lines.borrow();\n+            let (mut lo, mut hi): (BytePos, BytePos) = (lines[lo], lines[hi]);\n+            lo.0 += off_lo;\n+            hi.0 += off_hi;\n+            mk_sp(lo, hi)\n+        };\n+        let sp0 = span(4, 6, (0, 5));\n+        let sp1 = span(0, 6, (0, 5));\n+        let sp2 = span(8, 8, (0, 3));\n+        let sp3 = span(8, 8, (5, 8));\n+        let sp4 = span(10, 10, (2, 3));\n+        let sp5 = span(10, 10, (4, 6));\n+\n+        let expect0 = &r#\"\n+   --> dummy.txt:5:1\n+    |>\n+5   |> ccccc\n+    |> ^\n+...\n+9   |> ddd__eee_\n+    |> ^^^  ^^^\n+10  |> elided\n+11  |> __f_gg\n+    |>   ^ ^^\n+\"#[1..];\n+\n+        let expect = &r#\"\n+   --> dummy.txt:1:1\n+    |>\n+1   |> aaaaa\n+    |> ^\n+...\n+9   |> ddd__eee_\n+    |> ^^^  ^^^\n+10  |> elided\n+11  |> __f_gg\n+    |>   ^ ^^\n+\"#[1..];\n+\n+        macro_rules! test {\n+            ($expected: expr, $highlight: expr) => ({\n+                data.lock().unwrap().clear();\n+                $highlight();\n+                let vec = data.lock().unwrap().clone();\n+                let actual = from_utf8(&vec[..]).unwrap();\n+                println!(\"actual:\");\n+                println!(\"{}\", actual);\n+                println!(\"expected:\");\n+                println!(\"{}\", $expected);\n+                assert_eq!(&actual[..], &$expected[..]);\n+            });\n+        }\n+\n+        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n+        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n+\n+        test!(expect0, || {\n+            diag.highlight_lines(&msp0, Level::Error).unwrap();\n+        });\n+        test!(expect, || {\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n+        });\n+    }\n }"}, {"sha": "2572ac35e9861946673be55377283ed8ae389094", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 586, "deletions": 2, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2fe204dcce8f6509e51b3c518fc02d7e0e25e92/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f2fe204dcce8f6509e51b3c518fc02d7e0e25e92", "patch": "@@ -12,6 +12,7 @@\n \n #![allow(dead_code)]\n #![allow(unused_imports)]\n+\n use self::HasTestSignature::*;\n \n use std::iter;\n@@ -20,9 +21,12 @@ use std::mem;\n use std::vec;\n use attr::AttrMetaMethods;\n use attr;\n-use syntax_pos::{self, DUMMY_SP, Span};\n-use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n+use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, FileMap, BytePos};\n+use std::rc::Rc;\n+\n+use codemap::{self, CodeMap, ExpnInfo, NameAndSpan, MacroAttribute};\n use errors;\n+use errors::snippet::{RenderedLine, SnippetData};\n use config;\n use entry::{self, EntryPointType};\n use ext::base::{ExtCtxt, DummyMacroLoader};\n@@ -688,3 +692,583 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n                     vec![field(\"desc\", desc_expr),\n                          field(\"testfn\", testfn_expr)])\n }\n+\n+/// Returns the span corresponding to the `n`th occurrence of\n+/// `substring` in `source_text`.\n+trait CodeMapExtension {\n+    fn span_substr(&self,\n+                   file: &Rc<FileMap>,\n+                   source_text: &str,\n+                   substring: &str,\n+                   n: usize)\n+                   -> Span;\n+}\n+\n+impl CodeMapExtension for CodeMap {\n+    fn span_substr(&self,\n+                   file: &Rc<FileMap>,\n+                   source_text: &str,\n+                   substring: &str,\n+                   n: usize)\n+                   -> Span\n+    {\n+        println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n+                 file.name, file.start_pos, substring, n);\n+        let mut i = 0;\n+        let mut hi = 0;\n+        loop {\n+            let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n+                panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n+                       source_text, n, substring, i);\n+            });\n+            let lo = hi + offset;\n+            hi = lo + substring.len();\n+            if i == n {\n+                let span = Span {\n+                    lo: BytePos(lo as u32 + file.start_pos.0),\n+                    hi: BytePos(hi as u32 + file.start_pos.0),\n+                    expn_id: NO_EXPANSION,\n+                };\n+                assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n+                           substring);\n+                return span;\n+            }\n+            i += 1;\n+        }\n+    }\n+}\n+\n+fn splice(start: Span, end: Span) -> Span {\n+    Span {\n+        lo: start.lo,\n+        hi: end.hi,\n+        expn_id: NO_EXPANSION,\n+    }\n+}\n+\n+fn make_string(lines: &[RenderedLine]) -> String {\n+    lines.iter()\n+         .flat_map(|rl| {\n+             rl.text.iter()\n+                    .map(|s| &s.text[..])\n+                    .chain(Some(\"\\n\"))\n+         })\n+         .collect()\n+}\n+\n+#[test]\n+fn tab() {\n+    let file_text = \"\n+fn foo() {\n+\\tbar;\n+}\n+\";\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+    let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, Some(span_bar));\n+    snippet.push(span_bar, true, None);\n+\n+    let lines = snippet.render_lines();\n+    let text = make_string(&lines);\n+    assert_eq!(&text[..], &\"\n+ --> foo.rs:3:2\n+  |>\n+3 |> \\tbar;\n+  |> \\t^^^\n+\"[1..]);\n+}\n+\n+#[test]\n+fn one_line() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+    assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn two_files() {\n+    let file_text_foo = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let file_text_bar = r#\"\n+fn bar() {\n+    // these blank links here\n+    // serve to ensure that the line numbers\n+    // from bar.rs\n+    // require more digits\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    vec.push();\n+\n+    // this line will get elided\n+\n+    vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n+    let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n+    let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n+    let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n+\n+    let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n+    let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n+    let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n+    let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, Some(span_foo_vec1));\n+    snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n+    snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n+    snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n+    snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n+    snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n+    snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+\n+    // Note that the `|>` remain aligned across both files:\n+    assert_eq!(&text[..], &r#\"\n+   --> foo.rs:3:14\n+    |>\n+3   |>     vec.push(vec.pop().unwrap());\n+    |>     ---      ^^^                - c\n+    |>     |        |\n+    |>     |        b\n+    |>     a\n+   ::: bar.rs\n+    |>\n+17  |>     vec.push();\n+    |>     ---       - f\n+    |>     |\n+    |>     d\n+...\n+21  |>     vec.pop().unwrap());\n+    |>     --- e\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn multi_line() {\n+    let file_text = r#\"\n+fn foo() {\n+    let name = find_id(&data, 22).unwrap();\n+\n+    // Add one more item we forgot to the vector. Silly us.\n+    data.push(Data { name: format!(\"Hera\"), id: 66 });\n+\n+    // Print everything out.\n+    println!(\"Name: {:?}\", name);\n+    println!(\"Data: {:?}\", data);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+    let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n+    let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n+    let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n+    snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n+    snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=\\n{}\", text);\n+    assert_eq!(&text[..], &r#\"\n+   ::: foo.rs\n+    |>\n+3   |>     let name = find_id(&data, 22).unwrap();\n+    |>                         ---- immutable borrow begins here\n+...\n+6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n+    |>     ---- mutable borrow occurs here\n+...\n+11  |> }\n+    |> - immutable borrow ends here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn overlapping() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+    let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n+    let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n+    let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span0, false, Some(format!(\"A\")));\n+    snippet.push(span1, false, Some(format!(\"B\")));\n+    snippet.push(span2, false, Some(format!(\"C\")));\n+    snippet.push(span3, false, Some(format!(\"D\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     --------           ------ D\n+  |>     ||\n+  |>     |C\n+  |>     A\n+  |>     B\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn one_line_out_of_order() {\n+    let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+    // intentionally don't push the snippets left to right\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn elide_unnecessary_lines() {\n+    let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n+    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n+\n+    let mut snippet = SnippetData::new(cm, None);\n+    snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n+        has type `collections::vec::Vec<i32>`\")));\n+    snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n+\n+    let lines = snippet.render_lines();\n+    println!(\"{:#?}\", lines);\n+    let text: String = make_string(&lines);\n+    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+    assert_eq!(&text[..], &r#\"\n+   ::: foo.rs\n+    |>\n+4   |>     let mut vec2 = vec;\n+    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n+...\n+9   |>     vec.push(7);\n+    |>     --- use of moved value: `vec`\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn spans_without_labels() {\n+    let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    for i in 0..4 {\n+        let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n+        snippet.push(span_veci, false, None);\n+    }\n+\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     let mut vec = vec![0, 1, 2];\n+  |>             ---   ---\n+4 |>     let mut vec2 = vec;\n+  |>             ---    ---\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_long_selection() {\n+    let file_text = r#\"\n+impl SomeTrait for () {\n+    fn foo(x: u32) {\n+        // impl 1\n+        // impl 2\n+        // impl 3\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n+    let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+    snippet.push(splice(fn_span, rbrace_span), false, None);\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     fn foo(x: u32) {\n+  |>     -\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it.\n+\n+    let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n+    let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n+    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+    snippet.push(x_span, false, Some(format!(\"x_span\")));\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label2() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it. In this\n+    // case, the overlap is only at the beginning, but it's still\n+    // better to show the beginning more clearly.\n+\n+    let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n+    let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n+    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+    snippet.push(x_span, false, Some(format!(\"x_span\")));\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_overlap_label3() {\n+    // Test that we don't put `x_span` to the right of its highlight,\n+    // since there is another highlight that overlaps it. In this\n+    // case, the overlap is only at the beginning, but it's still\n+    // better to show the beginning more clearly.\n+\n+    let file_text = r#\"\n+    fn foo() {\n+       let closure = || {\n+           inner\n+       };\n+    }\n+}\n+\"#;\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+    let mut snippet = SnippetData::new(cm.clone(), None);\n+\n+    let closure_span = {\n+        let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n+        let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+        splice(closure_start_span, closure_end_span)\n+    };\n+\n+    let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n+\n+    snippet.push(closure_span, false, Some(format!(\"foo\")));\n+    snippet.push(inner_span, false, Some(format!(\"bar\")));\n+\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>        let closure = || {\n+  |>                      - foo\n+4 |>            inner\n+  |>            ----- bar\n+\"#[1..]);\n+}\n+\n+#[test]\n+fn span_empty() {\n+    // In one of the unit tests, we found that the parser sometimes\n+    // gives empty spans, and in particular it supplied an EOF span\n+    // like this one, which points at the very end. We want to\n+    // fallback gracefully in this case.\n+\n+    let file_text = r#\"\n+fn main() {\n+    struct Foo;\n+\n+    impl !Sync for Foo {}\n+\n+    unsafe impl Send for &'static Foo {\n+    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n+    //        can only be implemented for a struct/enum type, not\n+    //        `&'static Foo`\n+}\"#;\n+\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+    let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n+    rbrace_span.lo = rbrace_span.hi;\n+\n+    let mut snippet = SnippetData::new(cm.clone(), Some(rbrace_span));\n+    snippet.push(rbrace_span, false, None);\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+  --> foo.rs:11:2\n+   |>\n+11 |> }\n+   |>  -\n+\"#[1..]);\n+}"}]}