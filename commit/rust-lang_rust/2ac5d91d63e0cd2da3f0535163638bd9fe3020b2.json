{"sha": "2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "node_id": "C_kwDOAAsO6NoAKDJhYzVkOTFkNjNlMGNkMmRhM2YwNTM1MTYzNjM4YmQ5ZmUzMDIwYjI", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2022-11-24T11:09:15Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-11-25T09:28:44Z"}, "message": "Make `expand_abstract_consts` infallible", "tree": {"sha": "06bed1ceb9afd6f77d88122d527c99ca1fad4e1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06bed1ceb9afd6f77d88122d527c99ca1fad4e1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "html_url": "https://github.com/rust-lang/rust/commit/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4085e94ece1ca462a89aa28e3d38a5c8742fd2e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4085e94ece1ca462a89aa28e3d38a5c8742fd2e9", "html_url": "https://github.com/rust-lang/rust/commit/4085e94ece1ca462a89aa28e3d38a5c8742fd2e9"}], "stats": {"total": 157, "additions": 52, "deletions": 105}, "files": [{"sha": "67feb83faace6aff7357fad2323423934da28be8", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "patch": "@@ -1621,20 +1621,18 @@ impl<'tcx> InferCtxt<'tcx> {\n         // variables\n         let tcx = self.tcx;\n         if substs.has_non_region_infer() {\n-            let ac = tcx.expand_unevaluated_abstract_const(unevaluated.def, unevaluated.substs);\n-            match ac {\n-                Ok(None) => {\n-                    substs = InternalSubsts::identity_for_item(tcx, unevaluated.def.did);\n-                    param_env = tcx.param_env(unevaluated.def.did);\n+            if let Some(ct) = tcx.bound_abstract_const(unevaluated.def)? {\n+                let ct = tcx.expand_abstract_consts(ct.subst(tcx, substs));\n+                if let Err(e) = ct.error_reported() {\n+                    return Err(ErrorHandled::Reported(e));\n+                } else if ct.has_non_region_infer() || ct.has_non_region_param() {\n+                    return Err(ErrorHandled::TooGeneric);\n+                } else {\n+                    substs = replace_param_and_infer_substs_with_placeholder(tcx, substs);\n                 }\n-                Ok(Some(ct)) => {\n-                    if ct.has_non_region_infer() || ct.has_non_region_param() {\n-                        return Err(ErrorHandled::TooGeneric);\n-                    } else {\n-                        substs = replace_param_and_infer_substs_with_placeholder(tcx, substs);\n-                    }\n-                }\n-                Err(guar) => return Err(ErrorHandled::Reported(guar)),\n+            } else {\n+                substs = InternalSubsts::identity_for_item(tcx, unevaluated.def.did);\n+                param_env = tcx.param_env(unevaluated.def.did);\n             }\n         }\n "}, {"sha": "5de758ad9babd04d53a6da306b0bfbf001f01492", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 19, "deletions": 49, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "patch": "@@ -1,7 +1,7 @@\n //! A subset of a mir body used for const evaluatability checking.\n use crate::ty::{\n-    self, subst::SubstsRef, Const, EarlyBinder, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable,\n-    TypeSuperFoldable, TypeVisitable,\n+    self, Const, EarlyBinder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitable,\n };\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n@@ -36,7 +36,10 @@ pub type BoundAbstractConst<'tcx> = Result<Option<EarlyBinder<ty::Const<'tcx>>>,\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns a const without substs applied\n-    fn bound_abstract_const(self, uv: ty::WithOptConstParam<DefId>) -> BoundAbstractConst<'tcx> {\n+    pub fn bound_abstract_const(\n+        self,\n+        uv: ty::WithOptConstParam<DefId>,\n+    ) -> BoundAbstractConst<'tcx> {\n         let ac = if let Some((did, param_did)) = uv.as_const_arg() {\n             self.thir_abstract_const_of_const_arg((did, param_did))\n         } else {\n@@ -45,70 +48,37 @@ impl<'tcx> TyCtxt<'tcx> {\n         Ok(ac?.map(|ac| EarlyBinder(ac)))\n     }\n \n-    pub fn expand_abstract_consts<T: TypeFoldable<'tcx>>(\n-        self,\n-        ac: T,\n-    ) -> Result<Option<T>, ErrorGuaranteed> {\n-        self._expand_abstract_consts(ac, true)\n-    }\n-\n-    pub fn expand_unevaluated_abstract_const(\n-        self,\n-        did: ty::WithOptConstParam<DefId>,\n-        substs: SubstsRef<'tcx>,\n-    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n-        let Some(ac) = self.bound_abstract_const(did)? else {\n-            return Ok(None);\n-        };\n-        let substs = self.erase_regions(substs);\n-        let ac = ac.subst(self, substs);\n-        self._expand_abstract_consts(ac, false)\n-    }\n-\n-    fn _expand_abstract_consts<T: TypeFoldable<'tcx>>(\n-        self,\n-        ac: T,\n-        first: bool,\n-    ) -> Result<Option<T>, ErrorGuaranteed> {\n+    pub fn expand_abstract_consts<T: TypeFoldable<'tcx>>(self, ac: T) -> T {\n         struct Expander<'tcx> {\n             tcx: TyCtxt<'tcx>,\n-            first: bool,\n         }\n \n-        impl<'tcx> FallibleTypeFolder<'tcx> for Expander<'tcx> {\n-            type Error = Option<ErrorGuaranteed>;\n+        impl<'tcx> TypeFolder<'tcx> for Expander<'tcx> {\n             fn tcx(&self) -> TyCtxt<'tcx> {\n                 self.tcx\n             }\n-            fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if ty.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    ty.try_super_fold_with(self)\n+                    ty.super_fold_with(self)\n                 } else {\n-                    Ok(ty)\n+                    ty\n                 }\n             }\n-            fn try_fold_const(&mut self, c: Const<'tcx>) -> Result<Const<'tcx>, Self::Error> {\n+            fn fold_const(&mut self, c: Const<'tcx>) -> Const<'tcx> {\n                 let ct = match c.kind() {\n-                    ty::ConstKind::Unevaluated(uv) => {\n-                        if let Some(bac) = self.tcx.bound_abstract_const(uv.def)? {\n+                    ty::ConstKind::Unevaluated(uv) => match self.tcx.bound_abstract_const(uv.def) {\n+                        Err(e) => self.tcx.const_error_with_guaranteed(c.ty(), e),\n+                        Ok(Some(bac)) => {\n                             let substs = self.tcx.erase_regions(uv.substs);\n                             bac.subst(self.tcx, substs)\n-                        } else if self.first {\n-                            return Err(None);\n-                        } else {\n-                            c\n                         }\n-                    }\n+                        Ok(None) => c,\n+                    },\n                     _ => c,\n                 };\n-                self.first = false;\n-                ct.try_super_fold_with(self)\n+                ct.super_fold_with(self)\n             }\n         }\n-        match ac.try_fold_with(&mut Expander { tcx: self, first }) {\n-            Ok(c) => Ok(Some(c)),\n-            Err(None) => Ok(None),\n-            Err(Some(e)) => Err(e),\n-        }\n+        ac.fold_with(&mut Expander { tcx: self })\n     }\n }"}, {"sha": "e6340040e9c196f024131024d3b257c1ca290e85", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "patch": "@@ -632,12 +632,8 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     }\n \n     if tcx.features().generic_const_exprs {\n-        if let Ok(Some(a2)) = tcx.expand_abstract_consts(a) {\n-            a = a2;\n-        }\n-        if let Ok(Some(b2)) = tcx.expand_abstract_consts(b) {\n-            b = b2\n-        }\n+        a = tcx.expand_abstract_consts(a);\n+        b = tcx.expand_abstract_consts(b);\n     }\n \n     // Currently, the values that can be unified are primitive types,"}, {"sha": "3b41b9b830ed686addef08a59b3a86673079d40d", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "patch": "@@ -284,14 +284,8 @@ where\n     }\n \n     fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        self.visit_ty(c.ty())?;\n         let tcx = self.def_id_visitor.tcx();\n-        if let ty::ConstKind::Unevaluated(uv) = c.kind()\n-            && let Ok(Some(ct)) = tcx.expand_unevaluated_abstract_const(uv.def, uv.substs)\n-        {\n-            ct.super_visit_with(self)?;\n-        }\n-        ControlFlow::CONTINUE\n+        tcx.expand_abstract_consts(c).super_visit_with(self)\n     }\n }\n "}, {"sha": "a26653b3184b1f2f5c40ac26b4ae8e1d9fdcc52a", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "patch": "@@ -8,6 +8,7 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n+use rustc_hir::def::DefKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::interpret::ErrorHandled;\n \n@@ -42,7 +43,15 @@ pub fn is_const_evaluatable<'tcx>(\n     };\n \n     if tcx.features().generic_const_exprs {\n-        if let Some(ct) = tcx.expand_abstract_consts(ct)? {\n+        let ct = tcx.expand_abstract_consts(ct);\n+\n+        let is_anon_ct = if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n+            tcx.def_kind(uv.def.did) == DefKind::AnonConst\n+        } else {\n+            false\n+        };\n+\n+        if !is_anon_ct {\n             if satisfied_from_param_env(tcx, infcx, ct, param_env)? {\n                 return Ok(());\n             }\n@@ -52,6 +61,7 @@ pub fn is_const_evaluatable<'tcx>(\n                 return Err(NotConstEvaluatable::MentionsParam);\n             }\n         }\n+\n         let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n         match concrete {\n             Err(ErrorHandled::TooGeneric) => Err(NotConstEvaluatable::Error(\n@@ -78,8 +88,7 @@ pub fn is_const_evaluatable<'tcx>(\n             // the current crate does not enable `feature(generic_const_exprs)`, abort\n             // compilation with a useful error.\n             Err(_) if tcx.sess.is_nightly_build()\n-                && let Ok(Some(ac)) = tcx.expand_abstract_consts(ct)\n-                && let ty::ConstKind::Expr(_) = ac.kind() =>\n+                && let ty::ConstKind::Expr(_) = tcx.expand_abstract_consts(ct).kind() =>\n             {\n                 tcx.sess\n                     .struct_span_fatal(\n@@ -164,8 +173,7 @@ fn satisfied_from_param_env<'tcx>(\n     for pred in param_env.caller_bounds() {\n         match pred.kind().skip_binder() {\n             ty::PredicateKind::ConstEvaluatable(ce) => {\n-                let b_ct = tcx.expand_abstract_consts(ce)?.unwrap_or(ce);\n-\n+                let b_ct = tcx.expand_abstract_consts(ce);\n                 let mut v = Visitor { ct, infcx, param_env };\n                 let result = b_ct.visit_with(&mut v);\n "}, {"sha": "e58881710a5778d2e7355605fd8b58b2caf69732", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "patch": "@@ -462,10 +462,8 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                     //\n                     // Let's just see where this breaks :shrug:\n                     {\n-                        let c1 =\n-                            if let Ok(Some(a)) = tcx.expand_abstract_consts(c1) { a } else { c1 };\n-                        let c2 =\n-                            if let Ok(Some(b)) = tcx.expand_abstract_consts(c2) { b } else { c2 };\n+                        let c1 = tcx.expand_abstract_consts(c1);\n+                        let c2 = tcx.expand_abstract_consts(c2);\n                         debug!(\"equating consts:\\nc1= {:?}\\nc2= {:?}\", c1, c2);\n \n                         use rustc_hir::def::DefKind;"}, {"sha": "70e4ed29266dadd2a9817224ad173a8160734e7a", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "patch": "@@ -837,24 +837,9 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n         }\n \n         fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            // Constants can only influence object safety if they reference `Self`.\n+            // Constants can only influence object safety if they are generic and reference `Self`.\n             // This is only possible for unevaluated constants, so we walk these here.\n-            //\n-            // If `AbstractConst::from_const` returned an error we already failed compilation\n-            // so we don't have to emit an additional error here.\n-            //\n-            // We currently recurse into abstract consts here but do not recurse in\n-            // `is_const_evaluatable`. This means that the object safety check is more\n-            // liberal than the const eval check.\n-            //\n-            // This shouldn't really matter though as we can't really use any\n-            // constants which are not considered const evaluatable.\n-            if let ty::ConstKind::Unevaluated(_uv) = ct.kind() &&\n-                let Ok(Some(ct)) = self.tcx.expand_abstract_consts(ct){\n-                self.visit_const(ct)\n-            } else {\n-                ct.super_visit_with(self)\n-            }\n+            self.tcx.expand_abstract_consts(ct).super_visit_with(self)\n         }\n     }\n "}, {"sha": "c93b3fbf61b704e1c4e8fd90988837b2f1b5a00a", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac5d91d63e0cd2da3f0535163638bd9fe3020b2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2ac5d91d63e0cd2da3f0535163638bd9fe3020b2", "patch": "@@ -664,10 +664,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     );\n \n                     {\n-                        let c1 =\n-                            if let Ok(Some(a)) = tcx.expand_abstract_consts(c1) { a } else { c1 };\n-                        let c2 =\n-                            if let Ok(Some(b)) = tcx.expand_abstract_consts(c2) { b } else { c2 };\n+                        let c1 = tcx.expand_abstract_consts(c1);\n+                        let c2 = tcx.expand_abstract_consts(c2);\n                         debug!(\n                             \"evalaute_predicate_recursively: equating consts:\\nc1= {:?}\\nc2= {:?}\",\n                             c1, c2"}]}