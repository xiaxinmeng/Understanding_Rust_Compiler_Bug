{"sha": "c102312c2ba5f3f679a606ed8cfafd3aa811bd29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMDIzMTJjMmJhNWYzZjY3OWE2MDZlZDhjZmFmZDNhYTgxMWJkMjk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-19T19:12:59Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-22T16:38:20Z"}, "message": "Remove the parts of regionck referencing ReScope", "tree": {"sha": "babc4f70b220b14d318b139d2dfa239d48b5dc90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/babc4f70b220b14d318b139d2dfa239d48b5dc90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c102312c2ba5f3f679a606ed8cfafd3aa811bd29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c102312c2ba5f3f679a606ed8cfafd3aa811bd29", "html_url": "https://github.com/rust-lang/rust/commit/c102312c2ba5f3f679a606ed8cfafd3aa811bd29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c102312c2ba5f3f679a606ed8cfafd3aa811bd29/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "187bfb333b6c801eb2a89364b033e9303d88387f", "url": "https://api.github.com/repos/rust-lang/rust/commits/187bfb333b6c801eb2a89364b033e9303d88387f", "html_url": "https://github.com/rust-lang/rust/commit/187bfb333b6c801eb2a89364b033e9303d88387f"}], "stats": {"total": 509, "additions": 17, "deletions": 492}, "files": [{"sha": "90ba15aa089887d70283db8b1687c17e87cee56d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 492, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/c102312c2ba5f3f679a606ed8cfafd3aa811bd29/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c102312c2ba5f3f679a606ed8cfafd3aa811bd29/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c102312c2ba5f3f679a606ed8cfafd3aa811bd29", "patch": "@@ -83,12 +83,10 @@ use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, RegionObligation, RegionckMode};\n use rustc_middle::ty::adjustment;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::infer::OutlivesEnvironmentExt;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n-use std::mem;\n use std::ops::Deref;\n \n // a variation on try that just returns unit\n@@ -111,8 +109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn regionck_expr(&self, body: &'tcx hir::Body<'tcx>) {\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let id = body.value.hir_id;\n-        let mut rcx =\n-            RegionCtxt::new(self, RepeatingScope(id), id, Subject(subject), self.param_env);\n+        let mut rcx = RegionCtxt::new(self, id, Subject(subject), self.param_env);\n \n         // There are no add'l implied bounds when checking a\n         // standalone expr (e.g., the `E` in a type like `[u32; E]`).\n@@ -131,13 +128,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn regionck_item(&self, item_id: hir::HirId, span: Span, wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?})\", item_id, wf_tys);\n         let subject = self.tcx.hir().local_def_id(item_id);\n-        let mut rcx = RegionCtxt::new(\n-            self,\n-            RepeatingScope(item_id),\n-            item_id,\n-            Subject(subject),\n-            self.param_env,\n-        );\n+        let mut rcx = RegionCtxt::new(self, item_id, Subject(subject), self.param_env);\n         rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n         rcx.outlives_environment.save_implied_bounds(item_id);\n         rcx.visit_region_obligations(item_id);\n@@ -156,8 +147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let hir_id = body.value.hir_id;\n-        let mut rcx =\n-            RegionCtxt::new(self, RepeatingScope(hir_id), hir_id, Subject(subject), self.param_env);\n+        let mut rcx = RegionCtxt::new(self, hir_id, Subject(subject), self.param_env);\n \n         if !self.errors_reported_since_creation() {\n             // regionck assumes typeck succeeded\n@@ -182,12 +172,6 @@ pub struct RegionCtxt<'a, 'tcx> {\n     body_id: hir::HirId,\n     body_owner: LocalDefId,\n \n-    // call_site scope of innermost fn\n-    call_site_scope: Option<region::Scope>,\n-\n-    // id of innermost fn or loop\n-    repeating_scope: hir::HirId,\n-\n     // id of AST node being analyzed (the subject of the analysis).\n     subject_def_id: LocalDefId,\n }\n@@ -199,13 +183,11 @@ impl<'a, 'tcx> Deref for RegionCtxt<'a, 'tcx> {\n     }\n }\n \n-pub struct RepeatingScope(hir::HirId);\n pub struct Subject(LocalDefId);\n \n impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     pub fn new(\n         fcx: &'a FnCtxt<'a, 'tcx>,\n-        RepeatingScope(initial_repeating_scope): RepeatingScope,\n         initial_body_id: hir::HirId,\n         Subject(subject): Subject,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -215,19 +197,13 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         RegionCtxt {\n             fcx,\n             region_scope_tree,\n-            repeating_scope: initial_repeating_scope,\n             body_id: initial_body_id,\n             body_owner: subject,\n-            call_site_scope: None,\n             subject_def_id: subject,\n             outlives_environment,\n         }\n     }\n \n-    fn set_repeating_scope(&mut self, scope: hir::HirId) -> hir::HirId {\n-        mem::replace(&mut self.repeating_scope, scope)\n-    }\n-\n     /// Try to resolve the type for the given node, returning `t_err` if an error results. Note that\n     /// we never care about the details of the error, the same error will be detected and reported\n     /// in the writeback phase.\n@@ -261,16 +237,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.resolve_type(t)\n     }\n \n-    /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr<'_>) -> Ty<'tcx> {\n-        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n-        self.resolve_type(ty)\n-    }\n-\n-    /// This is the \"main\" function when region-checking a function item or a closure\n-    /// within a function item. It begins by updating various fields (e.g., `call_site_scope`\n-    /// and `outlives_environment`) to be appropriate to the function and then adds constraints\n-    /// derived from the function body.\n+    /// This is the \"main\" function when region-checking a function item or a\n+    /// closure within a function item. It begins by updating various fields\n+    /// (e.g., `outlives_environment`) to be appropriate to the function and\n+    /// then adds constraints derived from the function body.\n     ///\n     /// Note that it does **not** restore the state of the fields that\n     /// it updates! This is intentional, since -- for the main\n@@ -292,10 +262,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.body_id = body_id.hir_id;\n         self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n \n-        let call_site =\n-            region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::CallSite };\n-        self.call_site_scope = Some(call_site);\n-\n         let fn_sig = {\n             match self.tables.borrow().liberated_fn_sigs().get(id) {\n                 Some(f) => *f,\n@@ -324,12 +290,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n \n-        let call_site_scope = self.call_site_scope.unwrap();\n-        debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\", body.id(), call_site_scope);\n-        let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n-\n-        self.type_of_node_must_outlive(infer::CallReturn(span), body_id.hir_id, call_site_region);\n-\n         self.constrain_opaque_types(\n             &self.fcx.opaque_types.borrow(),\n             self.outlives_environment.free_region_map(),\n@@ -354,7 +314,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n         self.fcx.resolve_regions_and_report_errors(\n             self.subject_def_id.to_def_id(),\n-            &self.region_scope_tree,\n             &self.outlives_environment,\n             mode,\n         );\n@@ -363,34 +322,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat<'_>) {\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n         pat.each_binding(|_, hir_id, span, _| {\n-            // If we have a variable that contains region'd data, that\n-            // data will be accessible from anywhere that the variable is\n-            // accessed. We must be wary of loops like this:\n-            //\n-            //     // from src/test/compile-fail/borrowck-lend-flow.rs\n-            //     let mut v = box 3, w = box 4;\n-            //     let mut x = &mut w;\n-            //     loop {\n-            //         **x += 1;   // (2)\n-            //         borrow(v);  //~ ERROR cannot borrow\n-            //         x = &mut v; // (1)\n-            //     }\n-            //\n-            // Typically, we try to determine the region of a borrow from\n-            // those points where it is dereferenced. In this case, one\n-            // might imagine that the lifetime of `x` need only be the\n-            // body of the loop. But of course this is incorrect because\n-            // the pointer that is created at point (1) is consumed at\n-            // point (2), meaning that it must be live across the loop\n-            // iteration. The easiest way to guarantee this is to require\n-            // that the lifetime of any regions that appear in a\n-            // variable's type enclose at least the variable's scope.\n-            let var_scope = self.region_scope_tree.var_scope(hir_id.local_id);\n-            let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n-\n-            let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            self.type_of_node_must_outlive(origin, hir_id, var_region);\n-\n             let typ = self.resolve_node_type(hir_id);\n             let body_id = self.body_id;\n             let _ = dropck::check_drop_obligations(self, typ, span, body_id);\n@@ -433,15 +364,13 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n         // `visit_fn_body`.  We will restore afterwards.\n         let old_body_id = self.body_id;\n         let old_body_owner = self.body_owner;\n-        let old_call_site_scope = self.call_site_scope;\n         let env_snapshot = self.outlives_environment.push_snapshot_pre_closure();\n \n         let body = self.tcx.hir().body(body_id);\n         self.visit_fn_body(hir_id, body, span);\n \n         // Restore state from previous function.\n         self.outlives_environment.pop_snapshot_post_closure(env_snapshot);\n-        self.call_site_scope = old_call_site_scope;\n         self.body_id = old_body_id;\n         self.body_owner = old_body_owner;\n     }\n@@ -462,42 +391,6 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        debug!(\"regionck::visit_expr(e={:?}, repeating_scope={:?})\", expr, self.repeating_scope);\n-\n-        // No matter what, the type of each expression must outlive the\n-        // scope of that expression. This also guarantees basic WF.\n-        let expr_ty = self.resolve_node_type(expr.hir_id);\n-        // the region corresponding to this expression\n-        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n-            id: expr.hir_id.local_id,\n-            data: region::ScopeData::Node,\n-        }));\n-        self.type_must_outlive(\n-            infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-            expr_ty,\n-            expr_region,\n-        );\n-\n-        let is_method_call = self.tables.borrow().is_method_call(expr);\n-\n-        // If we are calling a method (either explicitly or via an\n-        // overloaded operator), check that all of the types provided as\n-        // arguments for its type parameters are well-formed, and all the regions\n-        // provided as arguments outlive the call.\n-        if is_method_call {\n-            let origin = match expr.kind {\n-                hir::ExprKind::MethodCall(..) => infer::ParameterOrigin::MethodCall,\n-                hir::ExprKind::Unary(op, _) if op == hir::UnOp::UnDeref => {\n-                    infer::ParameterOrigin::OverloadedDeref\n-                }\n-                _ => infer::ParameterOrigin::OverloadedOperator,\n-            };\n-\n-            let substs = self.tables.borrow().node_substs(expr.hir_id);\n-            self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n-            // Arguments (sub-expressions) are checked via `constrain_call`, below.\n-        }\n-\n         // Check any autoderefs or autorefs that appear.\n         let cmt_result = self.constrain_adjustments(expr);\n \n@@ -512,117 +405,10 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n             }\n         }\n \n-        debug!(\n-            \"regionck::visit_expr(e={:?}, repeating_scope={:?}) - visiting subexprs\",\n-            expr, self.repeating_scope\n-        );\n         match expr.kind {\n-            hir::ExprKind::Path(_) => {\n-                let substs = self.tables.borrow().node_substs(expr.hir_id);\n-                let origin = infer::ParameterOrigin::Path;\n-                self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n-            }\n-\n-            hir::ExprKind::Call(ref callee, ref args) => {\n-                if is_method_call {\n-                    self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n-                } else {\n-                    self.constrain_callee(&callee);\n-                    self.constrain_call(expr, None, args.iter().map(|e| &*e));\n-                }\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::MethodCall(.., ref args) => {\n-                self.constrain_call(expr, Some(&args[0]), args[1..].iter().map(|e| &*e));\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n-                if is_method_call {\n-                    self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n-                }\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Index(ref lhs, ref rhs) if is_method_call => {\n-                self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Binary(_, ref lhs, ref rhs) if is_method_call => {\n-                // As `ExprKind::MethodCall`, but the call is via an overloaded op.\n-                self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-                // If you do `x OP y`, then the types of `x` and `y` must\n-                // outlive the operation you are performing.\n-                let lhs_ty = self.resolve_expr_type_adjusted(&lhs);\n-                let rhs_ty = self.resolve_expr_type_adjusted(&rhs);\n-                for &ty in &[lhs_ty, rhs_ty] {\n-                    self.type_must_outlive(infer::Operand(expr.span), ty, expr_region);\n-                }\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Unary(hir::UnOp::UnDeref, ref base) => {\n-                // For *a, the lifetime of a must enclose the deref\n-                if is_method_call {\n-                    self.constrain_call(expr, Some(base), None::<hir::Expr<'_>>.iter());\n-                }\n-                // For overloaded derefs, base_ty is the input to `Deref::deref`,\n-                // but it's a reference type uing the same region as the output.\n-                let base_ty = self.resolve_expr_type_adjusted(base);\n-                if let ty::Ref(r_ptr, _, _) = base_ty.kind {\n-                    self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n-                }\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Unary(_, ref lhs) if is_method_call => {\n-                // As above.\n-                self.constrain_call(expr, Some(&lhs), None::<hir::Expr<'_>>.iter());\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Index(ref vec_expr, _) => {\n-                // For a[b], the lifetime of a must enclose the deref\n-                let vec_type = self.resolve_expr_type_adjusted(&vec_expr);\n-                self.constrain_index(expr, vec_type);\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Cast(ref source, _) => {\n-                // Determine if we are casting `source` to a trait\n-                // instance.  If so, we have to be sure that the type of\n-                // the source obeys the trait's region bound.\n-                self.constrain_cast(expr, &source);\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref base) => {\n                 self.link_addr_of(expr, m, &base);\n \n-                // Require that when you write a `&expr` expression, the\n-                // resulting pointer has a lifetime that encompasses the\n-                // `&expr` expression itself. Note that we constraining\n-                // the type of the node expr.id here *before applying\n-                // adjustments*.\n-                //\n-                // FIXME(https://github.com/rust-lang/rfcs/issues/811)\n-                // nested method calls requires that this rule change\n-                let ty0 = self.resolve_node_type(expr.hir_id);\n-                self.type_must_outlive(infer::AddrOf(expr.span), ty0, expr_region);\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -632,140 +418,12 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprKind::Closure(.., body_id, _, _) => {\n-                self.check_expr_fn_block(expr, body_id);\n-            }\n-\n-            hir::ExprKind::Loop(ref body, _, _) => {\n-                let repeating_scope = self.set_repeating_scope(body.hir_id);\n-                intravisit::walk_expr(self, expr);\n-                self.set_repeating_scope(repeating_scope);\n-            }\n-\n-            hir::ExprKind::Ret(Some(ref ret_expr)) => {\n-                let call_site_scope = self.call_site_scope;\n-                debug!(\n-                    \"visit_expr ExprKind::Ret ret_expr.hir_id {} call_site_scope: {:?}\",\n-                    ret_expr.hir_id, call_site_scope\n-                );\n-                let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n-                self.type_of_node_must_outlive(\n-                    infer::CallReturn(ret_expr.span),\n-                    ret_expr.hir_id,\n-                    call_site_region,\n-                );\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            _ => {\n-                intravisit::walk_expr(self, expr);\n-            }\n+            _ => intravisit::walk_expr(self, expr),\n         }\n     }\n }\n \n impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    fn constrain_cast(&mut self, cast_expr: &hir::Expr<'_>, source_expr: &hir::Expr<'_>) {\n-        debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\", cast_expr, source_expr);\n-\n-        let source_ty = self.resolve_node_type(source_expr.hir_id);\n-        let target_ty = self.resolve_node_type(cast_expr.hir_id);\n-\n-        self.walk_cast(cast_expr, source_ty, target_ty);\n-    }\n-\n-    fn walk_cast(&mut self, cast_expr: &hir::Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n-        debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\", from_ty, to_ty);\n-        match (&from_ty.kind, &to_ty.kind) {\n-            /*From:*/\n-            (&ty::Ref(from_r, from_ty, _), /*To:  */ &ty::Ref(to_r, to_ty, _)) => {\n-                // Target cannot outlive source, naturally.\n-                self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n-                self.walk_cast(cast_expr, from_ty, to_ty);\n-            }\n-\n-            /*From:*/\n-            (_, /*To:  */ &ty::Dynamic(.., r)) => {\n-                // When T is existentially quantified as a trait\n-                // `Foo+'to`, it must outlive the region bound `'to`.\n-                self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n-            }\n-\n-            /*From:*/\n-            (&ty::Adt(from_def, _), /*To:  */ &ty::Adt(to_def, _))\n-                if from_def.is_box() && to_def.is_box() =>\n-            {\n-                self.walk_cast(cast_expr, from_ty.boxed_ty(), to_ty.boxed_ty());\n-            }\n-\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_expr_fn_block(&mut self, expr: &'tcx hir::Expr<'tcx>, body_id: hir::BodyId) {\n-        let repeating_scope = self.set_repeating_scope(body_id.hir_id);\n-        intravisit::walk_expr(self, expr);\n-        self.set_repeating_scope(repeating_scope);\n-    }\n-\n-    fn constrain_callee(&mut self, callee_expr: &hir::Expr<'_>) {\n-        let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n-        match callee_ty.kind {\n-            ty::FnDef(..) | ty::FnPtr(_) => {}\n-            _ => {\n-                // this should not happen, but it does if the program is\n-                // erroneous\n-                //\n-                // bug!(\n-                //     callee_expr.span,\n-                //     \"Calling non-function: {}\",\n-                //     callee_ty);\n-            }\n-        }\n-    }\n-\n-    fn constrain_call<'b, I: Iterator<Item = &'b hir::Expr<'b>>>(\n-        &mut self,\n-        call_expr: &hir::Expr<'_>,\n-        receiver: Option<&hir::Expr<'_>>,\n-        arg_exprs: I,\n-    ) {\n-        //! Invoked on every call site (i.e., normal calls, method calls,\n-        //! and overloaded operators). Constrains the regions which appear\n-        //! in the type of the function. Also constrains the regions that\n-        //! appear in the arguments appropriately.\n-\n-        debug!(\"constrain_call(call_expr={:?}, receiver={:?})\", call_expr, receiver);\n-\n-        // `callee_region` is the scope representing the time in which the\n-        // call occurs.\n-        //\n-        // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope =\n-            region::Scope { id: call_expr.hir_id.local_id, data: region::ScopeData::Node };\n-        let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n-\n-        debug!(\"callee_region={:?}\", callee_region);\n-\n-        for arg_expr in arg_exprs {\n-            debug!(\"argument: {:?}\", arg_expr);\n-\n-            // ensure that any regions appearing in the argument type are\n-            // valid for at least the lifetime of the function:\n-            self.type_of_node_must_outlive(\n-                infer::CallArg(arg_expr.span),\n-                arg_expr.hir_id,\n-                callee_region,\n-            );\n-        }\n-\n-        // as loop above, but for receiver\n-        if let Some(r) = receiver {\n-            debug!(\"receiver: {:?}\", r);\n-            self.type_of_node_must_outlive(infer::CallRcvr(r.span), r.hir_id, callee_region);\n-        }\n-    }\n-\n     /// Creates a temporary `MemCategorizationContext` and pass it to the closure.\n     fn with_mc<F, R>(&self, f: F) -> R\n     where\n@@ -784,79 +442,40 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn constrain_adjustments(&mut self, expr: &hir::Expr<'_>) -> mc::McResult<mc::Place<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n-        let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n+        let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n \n         let tables = self.tables.borrow();\n         let adjustments = tables.expr_adjustments(&expr);\n         if adjustments.is_empty() {\n-            return Ok(cmt);\n+            return Ok(place);\n         }\n \n         debug!(\"constrain_adjustments: adjustments={:?}\", adjustments);\n \n         // If necessary, constrain destructors in the unadjusted form of this\n         // expression.\n-        self.check_safety_of_rvalue_destructor_if_necessary(&cmt, expr.span);\n+        self.check_safety_of_rvalue_destructor_if_necessary(&place, expr.span);\n \n-        let expr_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n-            id: expr.hir_id.local_id,\n-            data: region::ScopeData::Node,\n-        }));\n         for adjustment in adjustments {\n-            debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\", adjustment, cmt);\n+            debug!(\"constrain_adjustments: adjustment={:?}, place={:?}\", adjustment, place);\n \n             if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n-                debug!(\"constrain_adjustments: overloaded deref: {:?}\", deref);\n-\n-                // Treat overloaded autoderefs as if an AutoBorrow adjustment\n-                // was applied on the base type, as that is always the case.\n-                let input = self\n-                    .tcx\n-                    .mk_ref(deref.region, ty::TypeAndMut { ty: cmt.ty, mutbl: deref.mutbl });\n-                let output = self.tcx.mk_ref(\n-                    deref.region,\n-                    ty::TypeAndMut { ty: adjustment.target, mutbl: deref.mutbl },\n-                );\n-\n                 self.link_region(\n                     expr.span,\n                     deref.region,\n                     ty::BorrowKind::from_mutbl(deref.mutbl),\n-                    &cmt,\n+                    &place,\n                 );\n-\n-                // Specialized version of constrain_call.\n-                self.type_must_outlive(infer::CallRcvr(expr.span), input, expr_region);\n-                self.type_must_outlive(infer::CallReturn(expr.span), output, expr_region);\n             }\n \n             if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n-                self.link_autoref(expr, &cmt, autoref);\n-\n-                // Require that the resulting region encompasses\n-                // the current node.\n-                //\n-                // FIXME(#6268) remove to support nested method calls\n-                self.type_of_node_must_outlive(\n-                    infer::AutoBorrow(expr.span),\n-                    expr.hir_id,\n-                    expr_region,\n-                );\n+                self.link_autoref(expr, &place, autoref);\n             }\n \n-            cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n+            place = self.with_mc(|mc| mc.cat_expr_adjusted(expr, place, &adjustment))?;\n         }\n \n-        Ok(cmt)\n-    }\n-\n-    pub fn mk_subregion_due_to_dereference(\n-        &mut self,\n-        deref_span: Span,\n-        minimum_lifetime: ty::Region<'tcx>,\n-        maximum_lifetime: ty::Region<'tcx>,\n-    ) {\n-        self.sub_regions(infer::DerefPointer(deref_span), minimum_lifetime, maximum_lifetime)\n+        Ok(place)\n     }\n \n     fn check_safety_of_rvalue_destructor_if_necessary(\n@@ -872,59 +491,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Invoked on any index expression that occurs. Checks that if this is a slice\n-    /// being indexed, the lifetime of the pointer includes the deref expr.\n-    fn constrain_index(&mut self, index_expr: &hir::Expr<'_>, indexed_ty: Ty<'tcx>) {\n-        debug!(\"constrain_index(index_expr=?, indexed_ty={}\", self.ty_to_string(indexed_ty));\n-\n-        let r_index_expr = ty::ReScope(region::Scope {\n-            id: index_expr.hir_id.local_id,\n-            data: region::ScopeData::Node,\n-        });\n-        if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.kind {\n-            match r_ty.kind {\n-                ty::Slice(_) | ty::Str => {\n-                    self.sub_regions(\n-                        infer::IndexSlice(index_expr.span),\n-                        self.tcx.mk_region(r_index_expr),\n-                        r_ptr,\n-                    );\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    /// Guarantees that any lifetimes that appear in the type of the node `id` (after applying\n-    /// adjustments) are valid for at least `minimum_lifetime`.\n-    fn type_of_node_must_outlive(\n-        &mut self,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        hir_id: hir::HirId,\n-        minimum_lifetime: ty::Region<'tcx>,\n-    ) {\n-        // Try to resolve the type.  If we encounter an error, then typeck\n-        // is going to fail anyway, so just stop here and let typeck\n-        // report errors later on in the writeback phase.\n-        let ty0 = self.resolve_node_type(hir_id);\n-\n-        let ty = self\n-            .tables\n-            .borrow()\n-            .adjustments()\n-            .get(hir_id)\n-            .and_then(|adj| adj.last())\n-            .map_or(ty0, |adj| adj.target);\n-        let ty = self.resolve_type(ty);\n-        debug!(\n-            \"constrain_regions_in_type_of_node(\\\n-             ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n-            ty, ty0, hir_id, minimum_lifetime\n-        );\n-        self.type_must_outlive(origin, ty, minimum_lifetime);\n-    }\n-\n     /// Adds constraints to inference such that `T: 'a` holds (or\n     /// reports an error if it cannot).\n     ///\n@@ -1035,13 +601,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n             }\n \n-            adjustment::AutoBorrow::RawPtr(m) => {\n-                let r = self.tcx.mk_region(ty::ReScope(region::Scope {\n-                    id: expr.hir_id.local_id,\n-                    data: region::ScopeData::Node,\n-                }));\n-                self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n-            }\n+            adjustment::AutoBorrow::RawPtr(_) => {}\n         }\n     }\n \n@@ -1251,39 +811,4 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Checks that the values provided for type/region arguments in a given\n-    /// expression are well-formed and in-scope.\n-    fn substs_wf_in_scope(\n-        &mut self,\n-        origin: infer::ParameterOrigin,\n-        substs: SubstsRef<'tcx>,\n-        expr_span: Span,\n-        expr_region: ty::Region<'tcx>,\n-    ) {\n-        debug!(\n-            \"substs_wf_in_scope(substs={:?}, \\\n-             expr_region={:?}, \\\n-             origin={:?}, \\\n-             expr_span={:?})\",\n-            substs, expr_region, origin, expr_span\n-        );\n-\n-        let origin = infer::ParameterInScope(origin, expr_span);\n-\n-        for kind in substs {\n-            match kind.unpack() {\n-                GenericArgKind::Lifetime(lt) => {\n-                    self.sub_regions(origin.clone(), expr_region, lt);\n-                }\n-                GenericArgKind::Type(ty) => {\n-                    let ty = self.resolve_type(ty);\n-                    self.type_must_outlive(origin.clone(), ty, expr_region);\n-                }\n-                GenericArgKind::Const(_) => {\n-                    // Const parameters don't impose constraints.\n-                }\n-            }\n-        }\n-    }\n }"}]}