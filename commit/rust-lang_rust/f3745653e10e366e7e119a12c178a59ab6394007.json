{"sha": "f3745653e10e366e7e119a12c178a59ab6394007", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNzQ1NjUzZTEwZTM2NmU3ZTExOWExMmMxNzhhNTlhYjYzOTQwMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-03T08:30:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-03T08:30:32Z"}, "message": "Auto merge of #36767 - jseyfried:enforce_rfc_1560_shadowing, r=nrc\n\nEnforce the shadowing restrictions from RFC 1560 for today's macros\n\nThis PR enforces a weakened version of the shadowing restrictions from RFC 1560. More specifically,\n - If a macro expansion contains a `macro_rules!` macro definition that is used outside of the expansion, the defined macro may not shadow an existing macro.\n - If a macro expansion contains a `#[macro_use] extern crate` macro import that is used outside of the expansion, the imported macro may not shadow an existing macro.\n\nThis is a [breaking-change]. For example,\n```rust\nmacro_rules! m { () => {} }\nmacro_rules! n { () => {\n    macro_rules! m { () => {} } //< This shadows an existing macro.\n    m!(); //< This is inside the expansion that generated `m`'s definition, so it is OK.\n} }\nn!();\nm!(); //< This use of `m` is outside the expansion, so it causes the shadowing to be an error.\n```\n\nr? @nrc", "tree": {"sha": "bf0795b7094cd6a48b98760372b711d411f8c3a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf0795b7094cd6a48b98760372b711d411f8c3a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3745653e10e366e7e119a12c178a59ab6394007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3745653e10e366e7e119a12c178a59ab6394007", "html_url": "https://github.com/rust-lang/rust/commit/f3745653e10e366e7e119a12c178a59ab6394007", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3745653e10e366e7e119a12c178a59ab6394007/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "html_url": "https://github.com/rust-lang/rust/commit/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea"}, {"sha": "057302bcd9519a54153186abf3ee1e7facf8bdfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/057302bcd9519a54153186abf3ee1e7facf8bdfc", "html_url": "https://github.com/rust-lang/rust/commit/057302bcd9519a54153186abf3ee1e7facf8bdfc"}], "stats": {"total": 289, "additions": 210, "deletions": 79}, "files": [{"sha": "421843a7f11d8752af6ac3bfa71126a14d68d097", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -17,6 +17,7 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n use middle::cstore::InlinedItem;\n \n use syntax::ast::*;\n+use syntax::ext::hygiene::Mark;\n use syntax::visit;\n use syntax::parse::token::{self, keywords};\n \n@@ -31,7 +32,7 @@ pub struct DefCollector<'a> {\n }\n \n pub struct MacroInvocationData {\n-    pub id: NodeId,\n+    pub mark: Mark,\n     pub def_index: DefIndex,\n     pub const_integer: bool,\n }\n@@ -126,7 +127,7 @@ impl<'a> DefCollector<'a> {\n     fn visit_macro_invoc(&mut self, id: NodeId, const_integer: bool) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n-                id: id,\n+                mark: Mark::from_placeholder_id(id),\n                 const_integer: const_integer,\n                 def_index: self.parent_def.unwrap(),\n             })"}, {"sha": "be91b86dbcc95738b5479d5339371dc535819870", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -423,7 +423,12 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub enum LoadedMacro {\n+pub struct LoadedMacro {\n+    pub import_site: Span,\n+    pub kind: LoadedMacroKind,\n+}\n+\n+pub enum LoadedMacroKind {\n     Def(ast::MacroDef),\n     CustomDerive(String, Rc<MultiItemModifier>),\n }"}, {"sha": "385f582e2d36b84f0d0b1da715e8a55163415d5a", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -18,7 +18,7 @@ use std::mem;\n use creader::{CrateLoader, Macros};\n \n use rustc::hir::def_id::DefIndex;\n-use rustc::middle::cstore::LoadedMacro;\n+use rustc::middle::cstore::{LoadedMacro, LoadedMacroKind};\n use rustc::session::Session;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_back::dynamic_lib::DynamicLibrary;\n@@ -28,14 +28,19 @@ use syntax::ast;\n use syntax::attr;\n use syntax::parse::token;\n use syntax_ext::deriving::custom::CustomDerive;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n     span_err!(a, b, E0467, \"bad macro reexport\");\n }\n \n pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n \n+enum ImportSelection {\n+    All(Span),\n+    Some(MacroSelection),\n+}\n+\n pub fn load_macros(loader: &mut CrateLoader, extern_crate: &ast::Item, allows_macros: bool)\n                    -> Vec<LoadedMacro> {\n     loader.load_crate(extern_crate, allows_macros)\n@@ -46,7 +51,7 @@ impl<'a> CrateLoader<'a> {\n                   extern_crate: &ast::Item,\n                   allows_macros: bool) -> Vec<LoadedMacro> {\n         // Parse the attributes relating to macros.\n-        let mut import = Some(FnvHashMap());  // None => load all\n+        let mut import = ImportSelection::Some(FnvHashMap());\n         let mut reexport = FnvHashMap();\n \n         for attr in &extern_crate.attrs {\n@@ -55,11 +60,9 @@ impl<'a> CrateLoader<'a> {\n                 \"macro_use\" => {\n                     let names = attr.meta_item_list();\n                     if names.is_none() {\n-                        // no names => load all\n-                        import = None;\n-                    }\n-                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n-                        for attr in names {\n+                        import = ImportSelection::All(attr.span);\n+                    } else if let ImportSelection::Some(ref mut sel) = import {\n+                        for attr in names.unwrap() {\n                             if let Some(word) = attr.word() {\n                                 sel.insert(word.name().clone(), attr.span());\n                             } else {\n@@ -98,10 +101,10 @@ impl<'a> CrateLoader<'a> {\n     fn load_macros<'b>(&mut self,\n                        vi: &ast::Item,\n                        allows_macros: bool,\n-                       import: Option<MacroSelection>,\n+                       import: ImportSelection,\n                        reexport: MacroSelection)\n                        -> Vec<LoadedMacro> {\n-        if let Some(sel) = import.as_ref() {\n+        if let ImportSelection::Some(ref sel) = import {\n             if sel.is_empty() && reexport.is_empty() {\n                 return Vec::new();\n             }\n@@ -120,15 +123,19 @@ impl<'a> CrateLoader<'a> {\n         for mut def in macros.macro_rules.drain(..) {\n             let name = def.ident.name.as_str();\n \n-            def.use_locally = match import.as_ref() {\n-                None => true,\n-                Some(sel) => sel.contains_key(&name),\n+            let import_site = match import {\n+                ImportSelection::All(span) => Some(span),\n+                ImportSelection::Some(ref sel) => sel.get(&name).cloned()\n             };\n+            def.use_locally = import_site.is_some();\n             def.export = reexport.contains_key(&name);\n             def.allow_internal_unstable = attr::contains_name(&def.attrs,\n                                                               \"allow_internal_unstable\");\n             debug!(\"load_macros: loaded: {:?}\", def);\n-            ret.push(LoadedMacro::Def(def));\n+            ret.push(LoadedMacro {\n+                kind: LoadedMacroKind::Def(def),\n+                import_site: import_site.unwrap_or(DUMMY_SP),\n+            });\n             seen.insert(name);\n         }\n \n@@ -137,7 +144,7 @@ impl<'a> CrateLoader<'a> {\n             // exported macros, enforced elsewhere\n             assert_eq!(ret.len(), 0);\n \n-            if import.is_some() {\n+            if let ImportSelection::Some(..) = import {\n                 self.sess.span_err(vi.span, \"`rustc-macro` crates cannot be \\\n                                              selectively imported from, must \\\n                                              use `#[macro_use]`\");\n@@ -151,10 +158,10 @@ impl<'a> CrateLoader<'a> {\n             self.load_derive_macros(vi.span, &macros, index, &mut ret);\n         }\n \n-        if let Some(sel) = import.as_ref() {\n+        if let ImportSelection::Some(sel) = import {\n             for (name, span) in sel {\n                 if !seen.contains(&name) {\n-                    span_err!(self.sess, *span, E0469,\n+                    span_err!(self.sess, span, E0469,\n                               \"imported macro not found\");\n                 }\n             }\n@@ -199,18 +206,21 @@ impl<'a> CrateLoader<'a> {\n             mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n         };\n \n-        struct MyRegistrar<'a>(&'a mut Vec<LoadedMacro>);\n+        struct MyRegistrar<'a>(&'a mut Vec<LoadedMacro>, Span);\n \n         impl<'a> Registry for MyRegistrar<'a> {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream) {\n                 let derive = Rc::new(CustomDerive::new(expand));\n-                self.0.push(LoadedMacro::CustomDerive(trait_name.to_string(), derive));\n+                self.0.push(LoadedMacro {\n+                    kind: LoadedMacroKind::CustomDerive(trait_name.to_string(), derive),\n+                    import_site: self.1,\n+                });\n             }\n         }\n \n-        registrar(&mut MyRegistrar(ret));\n+        registrar(&mut MyRegistrar(ret, span));\n \n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long."}, {"sha": "2bf517600b73d693321e6487886a20167ab5a5e0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -13,14 +13,15 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n+use macros;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use {Module, ModuleS, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind, ToNameBinding};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::LoadedMacro;\n+use rustc::middle::cstore::LoadedMacroKind;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::map::DefPathData;\n@@ -39,6 +40,7 @@ use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ext::base::{MultiItemModifier, Resolver as SyntaxResolver};\n use syntax::ext::hygiene::Mark;\n use syntax::feature_gate::{self, emit_feature_err};\n+use syntax::ext::tt::macro_rules;\n use syntax::parse::token::keywords;\n use syntax::visit::{self, Visitor};\n \n@@ -77,7 +79,7 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item) {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n         let parent = self.current_module;\n         let name = item.ident.name;\n         let sp = item.span;\n@@ -188,10 +190,29 @@ impl<'b> Resolver<'b> {\n                 // We need to error on `#[macro_use] extern crate` when it isn't at the\n                 // crate root, because `$crate` won't work properly.\n                 let is_crate_root = self.current_module.parent.is_none();\n-                for def in self.crate_loader.load_macros(item, is_crate_root) {\n-                    match def {\n-                        LoadedMacro::Def(def) => self.add_macro(Mark::root(), def),\n-                        LoadedMacro::CustomDerive(name, ext) => {\n+                for loaded_macro in self.crate_loader.load_macros(item, is_crate_root) {\n+                    match loaded_macro.kind {\n+                        LoadedMacroKind::Def(mut def) => {\n+                            let name = def.ident.name;\n+                            if def.use_locally {\n+                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n+                                let shadowing =\n+                                    self.resolve_macro_name(Mark::root(), name, false).is_some();\n+                                self.expansion_data[&Mark::root()].module.macros.borrow_mut()\n+                                    .insert(name, macros::NameBinding {\n+                                        ext: Rc::new(ext),\n+                                        expansion: expansion,\n+                                        shadowing: shadowing,\n+                                        span: loaded_macro.import_site,\n+                                    });\n+                                self.macro_names.insert(name);\n+                            }\n+                            if def.export {\n+                                def.id = self.next_node_id();\n+                                self.exported_macros.push(def);\n+                            }\n+                        }\n+                        LoadedMacroKind::CustomDerive(name, ext) => {\n                             self.insert_custom_derive(&name, ext, item.span);\n                         }\n                     }\n@@ -527,11 +548,12 @@ impl<'b> Resolver<'b> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n     pub resolver: &'a mut Resolver<'b>,\n+    pub expansion: Mark,\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) {\n-        self.resolver.expansion_data.get_mut(&id.as_u32()).unwrap().module =\n+        self.resolver.expansion_data.get_mut(&Mark::from_placeholder_id(id)).unwrap().module =\n             self.resolver.current_module;\n     }\n }\n@@ -562,7 +584,7 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n         }\n \n         let parent = self.resolver.current_module;\n-        self.resolver.build_reduced_graph_for_item(item);\n+        self.resolver.build_reduced_graph_for_item(item, self.expansion);\n         visit::walk_item(self, item);\n         self.resolver.current_module = parent;\n     }"}, {"sha": "90a9e5960617e65d6e41e8bc797e704232ce29a0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -57,7 +57,6 @@ use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n-use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -793,7 +792,7 @@ pub struct ModuleS<'a> {\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n \n-    macros: RefCell<FnvHashMap<Name, Rc<SyntaxExtension>>>,\n+    macros: RefCell<FnvHashMap<Name, macros::NameBinding>>,\n     macros_escape: bool,\n }\n \n@@ -1074,6 +1073,7 @@ pub struct Resolver<'a> {\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n+    macro_shadowing_errors: FnvHashSet<Span>,\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n@@ -1085,7 +1085,7 @@ pub struct Resolver<'a> {\n     macro_names: FnvHashSet<Name>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    expansion_data: FnvHashMap<u32, macros::ExpansionData<'a>>,\n+    expansion_data: FnvHashMap<Mark, macros::ExpansionData<'a>>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1203,7 +1203,7 @@ impl<'a> Resolver<'a> {\n         DefCollector::new(&mut definitions).collect_root();\n \n         let mut expansion_data = FnvHashMap();\n-        expansion_data.insert(0, macros::ExpansionData::root(graph_root)); // Crate root expansion\n+        expansion_data.insert(Mark::root(), macros::ExpansionData::root(graph_root));\n \n         Resolver {\n             session: session,\n@@ -1249,6 +1249,7 @@ impl<'a> Resolver<'a> {\n \n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n+            macro_shadowing_errors: FnvHashSet(),\n \n             arenas: arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {"}, {"sha": "3f6c69278bee8a2ec91472228925a01d262f4909", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 77, "deletions": 31, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -18,13 +18,23 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+// FIXME(jseyfried) Merge with `::NameBinding`.\n+pub struct NameBinding {\n+    pub ext: Rc<SyntaxExtension>,\n+    pub expansion: Mark,\n+    pub shadowing: bool,\n+    pub span: Span,\n+}\n \n #[derive(Clone)]\n pub struct ExpansionData<'a> {\n+    backtrace: SyntaxContext,\n     pub module: Module<'a>,\n     def_index: DefIndex,\n     // True if this expansion is in a `const_integer` position, for example `[u32; m!()]`.\n@@ -35,6 +45,7 @@ pub struct ExpansionData<'a> {\n impl<'a> ExpansionData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n         ExpansionData {\n+            backtrace: SyntaxContext::empty(),\n             module: graph_root,\n             def_index: CRATE_DEF_INDEX,\n             const_integer: false,\n@@ -50,7 +61,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n         let mark = Mark::fresh();\n         let module = self.module_map[&id];\n-        self.expansion_data.insert(mark.as_u32(), ExpansionData {\n+        self.expansion_data.insert(mark, ExpansionData {\n+            backtrace: SyntaxContext::empty(),\n             module: module,\n             def_index: module.def_id().unwrap().index,\n             const_integer: false,\n@@ -60,34 +72,44 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n         self.collect_def_ids(mark, expansion);\n-        self.current_module = self.expansion_data[&mark.as_u32()].module;\n-        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: self });\n+        self.current_module = self.expansion_data[&mark].module;\n+        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: self, expansion: mark });\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n         if &def.ident.name.as_str() == \"macro_rules\" {\n             self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n         if def.use_locally {\n-            let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-            self.add_ext(scope, def.ident, Rc::new(ext));\n+            let ExpansionData { mut module, backtrace, .. } = self.expansion_data[&scope];\n+            while module.macros_escape {\n+                module = module.parent.unwrap();\n+            }\n+            let binding = NameBinding {\n+                ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n+                expansion: backtrace.data().prev_ctxt.data().outer_mark,\n+                shadowing: self.resolve_macro_name(scope, def.ident.name, false).is_some(),\n+                span: def.span,\n+            };\n+            module.macros.borrow_mut().insert(def.ident.name, binding);\n+            self.macro_names.insert(def.ident.name);\n         }\n         if def.export {\n             def.id = self.next_node_id();\n             self.exported_macros.push(def);\n         }\n     }\n \n-    fn add_ext(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n+    fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n-\n-        let mut module = self.expansion_data[&scope.as_u32()].module;\n-        while module.macros_escape {\n-            module = module.parent.unwrap();\n-        }\n-        module.macros.borrow_mut().insert(ident.name, ext);\n+        self.graph_root.macros.borrow_mut().insert(ident.name, NameBinding {\n+            ext: ext,\n+            expansion: Mark::root(),\n+            shadowing: false,\n+            span: DUMMY_SP,\n+        });\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n@@ -97,8 +119,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n-            match self.expansion_data[&0].module.macros.borrow().get(&name) {\n-                Some(ext) => match **ext {\n+            match self.expansion_data[&Mark::root()].module.macros.borrow().get(&name) {\n+                Some(binding) => match *binding.ext {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -125,30 +147,53 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n         };\n \n-        let mut module = self.expansion_data[&scope.as_u32()].module;\n+        self.resolve_macro_name(scope, name, true).or_else(|| {\n+            let mut err =\n+                self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n+            self.suggest_macro_name(&name.as_str(), &mut err);\n+            err.emit();\n+            None\n+        })\n+    }\n+\n+    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>> {\n+        self.derive_modes.get(&ident.name).cloned()\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    pub fn resolve_macro_name(&mut self, scope: Mark, name: ast::Name, record_used: bool)\n+                              -> Option<Rc<SyntaxExtension>> {\n+        let ExpansionData { mut module, backtrace, .. } = self.expansion_data[&scope];\n         loop {\n-            if let Some(ext) = module.macros.borrow().get(&name) {\n-                return Some(ext.clone());\n+            if let Some(binding) = module.macros.borrow().get(&name) {\n+                let mut backtrace = backtrace.data();\n+                while binding.expansion != backtrace.outer_mark {\n+                    if backtrace.outer_mark != Mark::root() {\n+                        backtrace = backtrace.prev_ctxt.data();\n+                        continue\n+                    }\n+\n+                    if record_used && binding.shadowing &&\n+                       self.macro_shadowing_errors.insert(binding.span) {\n+                        let msg = format!(\"`{}` is already in scope\", name);\n+                        self.session.struct_span_err(binding.span, &msg)\n+                            .note(\"macro-expanded `macro_rules!`s and `#[macro_use]`s \\\n+                                   may not shadow existing macros (see RFC 1560)\")\n+                            .emit();\n+                    }\n+                    break\n+                }\n+                return Some(binding.ext.clone());\n             }\n             match module.parent {\n                 Some(parent) => module = parent,\n                 None => break,\n             }\n         }\n-\n-        let mut err =\n-            self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n-        self.suggest_macro_name(&name.as_str(), &mut err);\n-        err.emit();\n         None\n     }\n \n-    fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>> {\n-        self.derive_modes.get(&ident.name).cloned()\n-    }\n-}\n-\n-impl<'a> Resolver<'a> {\n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n         if let Some(suggestion) = find_best_match_for_name(self.macro_names.iter(), name, None) {\n             if suggestion != name {\n@@ -161,9 +206,10 @@ impl<'a> Resolver<'a> {\n \n     fn collect_def_ids(&mut self, mark: Mark, expansion: &Expansion) {\n         let expansion_data = &mut self.expansion_data;\n-        let ExpansionData { def_index, const_integer, module } = expansion_data[&mark.as_u32()];\n+        let ExpansionData { backtrace, def_index, const_integer, module } = expansion_data[&mark];\n         let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n-            expansion_data.entry(invoc.id.as_u32()).or_insert(ExpansionData {\n+            expansion_data.entry(invoc.mark).or_insert(ExpansionData {\n+                backtrace: backtrace.apply_mark(invoc.mark),\n                 def_index: invoc.def_index,\n                 const_integer: invoc.const_integer,\n                 module: module,"}, {"sha": "b56018e1e9dcd98b33e30a6c421e47559ef1bdd4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -519,7 +519,7 @@ pub trait Resolver {\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n     fn add_macro(&mut self, scope: Mark, def: ast::MacroDef);\n-    fn add_ext(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n+    fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n@@ -535,7 +535,7 @@ impl Resolver for DummyResolver {\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n     fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef) {}\n-    fn add_ext(&mut self, _scope: Mark, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n+    fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n@@ -749,7 +749,7 @@ impl<'a> ExtCtxt<'a> {\n \n         for (name, extension) in user_exts {\n             let ident = ast::Ident::with_empty_ctxt(name);\n-            self.resolver.add_ext(Mark::root(), ident, Rc::new(extension));\n+            self.resolver.add_ext(ident, Rc::new(extension));\n         }\n \n         let mut module = ModuleData {"}, {"sha": "0fd72277cca9f46015f5df1600e015b26365cede", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -15,6 +15,7 @@\n //! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n //! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n \n+use ast::NodeId;\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n@@ -46,6 +47,10 @@ impl Mark {\n         Mark(0)\n     }\n \n+    pub fn from_placeholder_id(id: NodeId) -> Self {\n+        Mark(id.as_u32())\n+    }\n+\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }"}, {"sha": "6e4f3dde4bd24d7153abc4f71ba0277e347d31e5", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -51,13 +51,12 @@ pub mod deriving;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier};\n-use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules::MacroRulesExpander;\n use syntax::parse::token::intern;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quotes: bool) {\n     let mut register = |name, ext| {\n-        resolver.add_ext(Mark::root(), ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n+        resolver.add_ext(ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n     };\n \n     register(\"macro_rules\", IdentTT(Box::new(MacroRulesExpander), None, false));"}, {"sha": "317a47156c1ac072c877554ad136d1b92429c78b", "filename": "src/test/compile-fail/issue-32922.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Ftest%2Fcompile-fail%2Fissue-32922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Ftest%2Fcompile-fail%2Fissue-32922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32922.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -17,7 +17,7 @@ macro_rules! foo { () => {\n     let _ = bar!();\n }}\n \n-macro_rules! bar { // test issue #31856\n+macro_rules! m { // test issue #31856\n     ($n:ident) => (\n         let a = 1;\n         let $n = a;"}, {"sha": "22463825ef98f1618a84af4996a589994163f75e", "filename": "src/test/compile-fail/macro-shadowing.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+\n+macro_rules! foo { () => {} }\n+macro_rules! macro_one { () => {} }\n+\n+macro_rules! m1 { () => {\n+    macro_rules! foo { () => {} } //~ ERROR `foo` is already in scope\n+    //~^ NOTE macro-expanded `macro_rules!`s and `#[macro_use]`s may not shadow existing macros\n+\n+    #[macro_use] //~ ERROR `macro_one` is already in scope\n+    //~^ NOTE macro-expanded `macro_rules!`s and `#[macro_use]`s may not shadow existing macros\n+    extern crate two_macros;\n+}}\n+m1!(); //~ NOTE in this expansion\n+       //~| NOTE in this expansion\n+       //~| NOTE in this expansion\n+       //~| NOTE in this expansion\n+\n+fn f() { macro_one!(); }\n+foo!();\n+\n+macro_rules! m2 { () => {\n+    macro_rules! foo { () => {} }\n+    #[macro_use] extern crate two_macros as __;\n+\n+    fn g() { macro_one!(); }\n+    foo!();\n+}}\n+m2!();\n+//^ Since `foo` and `macro_one` are not used outside this expansion, they are not shadowing errors.\n+\n+fn main() {}"}, {"sha": "91648ee5798266e3bb6e0b8ef498341156f77a2d", "filename": "src/test/run-pass/hygiene.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3745653e10e366e7e119a12c178a59ab6394007/src%2Ftest%2Frun-pass%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3745653e10e366e7e119a12c178a59ab6394007/src%2Ftest%2Frun-pass%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene.rs?ref=f3745653e10e366e7e119a12c178a59ab6394007", "patch": "@@ -22,23 +22,23 @@ fn f() {\n \n fn g() {\n     let x = 0;\n-    macro_rules! m { ($x:ident) => {\n-        macro_rules! m2 { () => { ($x, x) } }\n+    macro_rules! m { ($m1:ident, $m2:ident, $x:ident) => {\n+        macro_rules! $m1 { () => { ($x, x) } }\n         let x = 1;\n-        macro_rules! m3 { () => { ($x, x) } }\n+        macro_rules! $m2 { () => { ($x, x) } }\n     } }\n \n     let x = 2;\n-    m!(x);\n+    m!(m2, m3, x);\n \n     let x = 3;\n     assert_eq!(m2!(), (2, 0));\n     assert_eq!(m3!(), (2, 1));\n \n     let x = 4;\n-    m!(x);\n-    assert_eq!(m2!(), (4, 0));\n-    assert_eq!(m3!(), (4, 1));\n+    m!(m4, m5, x);\n+    assert_eq!(m4!(), (4, 0));\n+    assert_eq!(m5!(), (4, 1));\n }\n \n mod foo {"}]}