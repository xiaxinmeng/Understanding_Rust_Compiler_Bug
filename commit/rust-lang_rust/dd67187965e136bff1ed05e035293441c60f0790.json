{"sha": "dd67187965e136bff1ed05e035293441c60f0790", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNjcxODc5NjVlMTM2YmZmMWVkMDVlMDM1MjkzNDQxYzYwZjA3OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-16T16:31:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-16T16:31:23Z"}, "message": "Auto merge of #67133 - oli-obk:it_must_be_a_sign, r=eddyb\n\nDeduplicate pretty printing of constants\n\nr? @eddyb for the pretty printing logic\ncc @RalfJung", "tree": {"sha": "d14a26886de5881e560f4754531975e84957bd29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d14a26886de5881e560f4754531975e84957bd29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd67187965e136bff1ed05e035293441c60f0790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd67187965e136bff1ed05e035293441c60f0790", "html_url": "https://github.com/rust-lang/rust/commit/dd67187965e136bff1ed05e035293441c60f0790", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd67187965e136bff1ed05e035293441c60f0790/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59f4ba95045e91a63e921e0d736242d7e1ffabec", "url": "https://api.github.com/repos/rust-lang/rust/commits/59f4ba95045e91a63e921e0d736242d7e1ffabec", "html_url": "https://github.com/rust-lang/rust/commit/59f4ba95045e91a63e921e0d736242d7e1ffabec"}, {"sha": "6ca65bdd752a32b376a7f5cb1dba4953e91f46bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ca65bdd752a32b376a7f5cb1dba4953e91f46bb", "html_url": "https://github.com/rust-lang/rust/commit/6ca65bdd752a32b376a7f5cb1dba4953e91f46bb"}], "stats": {"total": 568, "additions": 379, "deletions": 189}, "files": [{"sha": "9018cd2656f9fb1836217b43d4653ce65a00e874", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -2562,15 +2562,15 @@ impl<'tcx> Debug for Constant<'tcx> {\n \n impl<'tcx> Display for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n+        use crate::ty::print::PrettyPrinter;\n         write!(fmt, \"const \")?;\n-        // FIXME make the default pretty printing of raw pointers more detailed. Here we output the\n-        // debug representation of raw pointers, so that the raw pointers in the mir dump output are\n-        // detailed and just not '{pointer}'.\n-        if let ty::RawPtr(_) = self.literal.ty.kind {\n-            write!(fmt, \"{:?} : {}\", self.literal.val, self.literal.ty)\n-        } else {\n-            write!(fmt, \"{}\", self.literal)\n-        }\n+        ty::tls::with(|tcx| {\n+            let literal = tcx.lift(&self.literal).unwrap();\n+            let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n+            cx.print_alloc_ids = true;\n+            cx.pretty_print_const(literal, true)?;\n+            Ok(())\n+        })\n     }\n }\n "}, {"sha": "cb01d821c18712e5ba8e0824add0c1a92566aca0", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 295, "deletions": 105, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -1,7 +1,7 @@\n use crate::hir::map::{DefPathData, DisambiguatedDefPathData};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use crate::middle::region;\n-use crate::mir::interpret::{sign_extend, truncate, ConstValue, Scalar};\n+use crate::mir::interpret::{sign_extend, truncate, AllocId, ConstValue, Pointer, Scalar};\n use crate::ty::layout::{Integer, IntegerExt, Size};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n@@ -17,6 +17,7 @@ use rustc_span::symbol::{kw, Symbol};\n use rustc_target::spec::abi::Abi;\n \n use std::cell::Cell;\n+use std::char;\n use std::collections::BTreeMap;\n use std::fmt::{self, Write as _};\n use std::ops::{Deref, DerefMut};\n@@ -210,6 +211,21 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n+    /// Prints `{f: t}` or `{f as t}` depending on the `cast` argument\n+    fn typed_value(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+        t: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+        conversion: &str,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.write_str(\"{\")?;\n+        self = f(self)?;\n+        self.write_str(conversion)?;\n+        self = t(self)?;\n+        self.write_str(\"}\")?;\n+        Ok(self)\n+    }\n+\n     /// Prints `<...>` around what `f` prints.\n     fn generic_delimiters(\n         self,\n@@ -517,14 +533,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Error => p!(write(\"[type error]\")),\n             ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n-                ty::BoundTyKind::Anon => {\n-                    if debruijn == ty::INNERMOST {\n-                        p!(write(\"^{}\", bound_ty.var.index()))\n-                    } else {\n-                        p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n-                    }\n-                }\n-\n+                ty::BoundTyKind::Anon => self.pretty_print_bound_var(debruijn, bound_ty.var)?,\n                 ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n             },\n             ty::Adt(def, substs) => {\n@@ -689,7 +698,7 @@ pub trait PrettyPrinter<'tcx>:\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n                     p!(write(\"_\"));\n-                } else if let Some(n) = sz.try_eval_usize(self.tcx(), ty::ParamEnv::empty()) {\n+                } else if let Some(n) = sz.val.try_to_bits(self.tcx().data_layout.pointer_size) {\n                     p!(write(\"{}\", n));\n                 } else {\n                     p!(write(\"_\"));\n@@ -702,6 +711,18 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n+    fn pretty_print_bound_var(\n+        &mut self,\n+        debruijn: ty::DebruijnIndex,\n+        var: ty::BoundVar,\n+    ) -> Result<(), Self::Error> {\n+        if debruijn == ty::INNERMOST {\n+            write!(self, \"^{}\", var.index())\n+        } else {\n+            write!(self, \"^{}_{}\", debruijn.index(), var.index())\n+        }\n+    }\n+\n     fn infer_ty_name(&self, _: ty::TyVid) -> Option<String> {\n         None\n     }\n@@ -842,16 +863,23 @@ pub trait PrettyPrinter<'tcx>:\n \n         macro_rules! print_underscore {\n             () => {{\n-                p!(write(\"_\"));\n                 if print_ty {\n-                    p!(write(\": \"), print(ct.ty));\n+                    self = self.typed_value(\n+                        |mut this| {\n+                            write!(this, \"_\")?;\n+                            Ok(this)\n+                        },\n+                        |this| this.print_type(ct.ty),\n+                        \": \",\n+                    )?;\n+                } else {\n+                    write!(self, \"_\")?;\n                 }\n             }};\n         }\n \n-        match (ct.val, &ct.ty.kind) {\n-            (_, ty::FnDef(did, substs)) => p!(print_value_path(*did, substs)),\n-            (ty::ConstKind::Unevaluated(did, substs, promoted), _) => {\n+        match ct.val {\n+            ty::ConstKind::Unevaluated(did, substs, promoted) => {\n                 if let Some(promoted) = promoted {\n                     p!(print_value_path(did, substs));\n                     p!(write(\"::{:?}\", promoted));\n@@ -876,143 +904,265 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                 }\n             }\n-            (ty::ConstKind::Infer(..), _) => print_underscore!(),\n-            (ty::ConstKind::Param(ParamConst { name, .. }), _) => p!(write(\"{}\", name)),\n-            (ty::ConstKind::Value(value), _) => {\n+            ty::ConstKind::Infer(..) => print_underscore!(),\n+            ty::ConstKind::Param(ParamConst { name, .. }) => p!(write(\"{}\", name)),\n+            ty::ConstKind::Value(value) => {\n                 return self.pretty_print_const_value(value, ct.ty, print_ty);\n             }\n \n-            _ => {\n-                // fallback\n-                p!(write(\"{:?}\", ct.val));\n-                if print_ty {\n-                    p!(write(\": \"), print(ct.ty));\n-                }\n+            ty::ConstKind::Bound(debruijn, bound_var) => {\n+                self.pretty_print_bound_var(debruijn, bound_var)?\n             }\n+            ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n         };\n         Ok(self)\n     }\n \n-    fn pretty_print_const_value(\n+    fn pretty_print_const_scalar(\n         mut self,\n-        ct: ConstValue<'tcx>,\n+        scalar: Scalar,\n         ty: Ty<'tcx>,\n         print_ty: bool,\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        if self.tcx().sess.verbose() {\n-            p!(write(\"ConstValue({:?}: {:?})\", ct, ty));\n-            return Ok(self);\n-        }\n-\n-        let u8 = self.tcx().types.u8;\n-\n-        match (ct, &ty.kind) {\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Bool) => {\n-                p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }))\n-            }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F32)) => {\n+        match (scalar, &ty.kind) {\n+            // Byte strings (&[u8; N])\n+            (\n+                Scalar::Ptr(ptr),\n+                ty::Ref(\n+                    _,\n+                    ty::TyS {\n+                        kind:\n+                            ty::Array(\n+                                ty::TyS { kind: ty::Uint(ast::UintTy::U8), .. },\n+                                ty::Const {\n+                                    val:\n+                                        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw {\n+                                            data,\n+                                            ..\n+                                        })),\n+                                    ..\n+                                },\n+                            ),\n+                        ..\n+                    },\n+                    _,\n+                ),\n+            ) => {\n+                let byte_str = self\n+                    .tcx()\n+                    .alloc_map\n+                    .lock()\n+                    .unwrap_memory(ptr.alloc_id)\n+                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data as u64))\n+                    .unwrap();\n+                p!(pretty_print_byte_str(byte_str));\n+            }\n+            // Bool\n+            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(write(\"false\")),\n+            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(write(\"true\")),\n+            // Float\n+            (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F32)) => {\n                 p!(write(\"{}f32\", Single::from_bits(data)))\n             }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F64)) => {\n+            (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F64)) => {\n                 p!(write(\"{}f64\", Double::from_bits(data)))\n             }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Uint(ui)) => {\n+            // Int\n+            (Scalar::Raw { data, .. }, ty::Uint(ui)) => {\n                 let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n                 let max = truncate(u128::MAX, bit_size);\n \n                 let ui_str = ui.name_str();\n                 if data == max {\n                     p!(write(\"std::{}::MAX\", ui_str))\n                 } else {\n-                    p!(write(\"{}{}\", data, ui_str))\n+                    if print_ty { p!(write(\"{}{}\", data, ui_str)) } else { p!(write(\"{}\", data)) }\n                 };\n             }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Int(i)) => {\n-                let bit_size = Integer::from_attr(&self.tcx(), SignedInt(*i)).size().bits() as u128;\n+            (Scalar::Raw { data, .. }, ty::Int(i)) => {\n+                let size = Integer::from_attr(&self.tcx(), SignedInt(*i)).size();\n+                let bit_size = size.bits() as u128;\n                 let min = 1u128 << (bit_size - 1);\n                 let max = min - 1;\n \n-                let ty = self.tcx().lift(&ty).unwrap();\n-                let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n                 let i_str = i.name_str();\n                 match data {\n                     d if d == min => p!(write(\"std::{}::MIN\", i_str)),\n                     d if d == max => p!(write(\"std::{}::MAX\", i_str)),\n-                    _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i_str)),\n+                    _ => {\n+                        let data = sign_extend(data, size) as i128;\n+                        if print_ty {\n+                            p!(write(\"{}{}\", data, i_str))\n+                        } else {\n+                            p!(write(\"{}\", data))\n+                        }\n+                    }\n                 }\n             }\n-            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Char) => {\n-                p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap()))\n-            }\n-            (ConstValue::Scalar(_), ty::RawPtr(_)) => p!(write(\"{{pointer}}\")),\n-            (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::FnPtr(_)) => {\n+            // Char\n+            (Scalar::Raw { data, .. }, ty::Char) if char::from_u32(data as u32).is_some() => {\n+                p!(write(\"{:?}\", char::from_u32(data as u32).unwrap()))\n+            }\n+            // Raw pointers\n+            (Scalar::Raw { data, .. }, ty::RawPtr(_)) => {\n+                self = self.typed_value(\n+                    |mut this| {\n+                        write!(this, \"0x{:x}\", data)?;\n+                        Ok(this)\n+                    },\n+                    |this| this.print_type(ty),\n+                    \" as \",\n+                )?;\n+            }\n+            (Scalar::Ptr(ptr), ty::FnPtr(_)) => {\n                 let instance = {\n                     let alloc_map = self.tcx().alloc_map.lock();\n                     alloc_map.unwrap_fn(ptr.alloc_id)\n                 };\n-                p!(print_value_path(instance.def_id(), instance.substs));\n-            }\n-            _ => {\n-                let printed = if let ty::Ref(_, ref_ty, _) = ty.kind {\n-                    let byte_str = match (ct, &ref_ty.kind) {\n-                        (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n-                            let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n-                            Some(\n-                                self.tcx()\n-                                    .alloc_map\n-                                    .lock()\n-                                    .unwrap_memory(ptr.alloc_id)\n-                                    .get_bytes(&self.tcx(), ptr, Size::from_bytes(n))\n-                                    .unwrap(),\n-                            )\n-                        }\n-                        (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                            // The `inspect` here is okay since we checked the bounds, and there are\n-                            // no relocations (we have an active slice reference here). We don't use\n-                            // this result to affect interpreter execution.\n-                            Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n-                        }\n-                        _ => None,\n-                    };\n-\n-                    if let Some(byte_str) = byte_str {\n-                        p!(write(\"b\\\"\"));\n-                        for &c in byte_str {\n-                            for e in std::ascii::escape_default(c) {\n-                                self.write_char(e as char)?;\n-                            }\n-                        }\n-                        p!(write(\"\\\"\"));\n-                        true\n-                    } else if let (ConstValue::Slice { data, start, end }, ty::Str) =\n-                        (ct, &ref_ty.kind)\n-                    {\n-                        // The `inspect` here is okay since we checked the bounds, and there are no\n-                        // relocations (we have an active `str` reference here). We don't use this\n-                        // result to affect interpreter execution.\n-                        let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n-                        let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n-                        p!(write(\"{:?}\", s));\n-                        true\n+                self = self.typed_value(\n+                    |this| this.print_value_path(instance.def_id(), instance.substs),\n+                    |this| this.print_type(ty),\n+                    \" as \",\n+                )?;\n+            }\n+            // For function type zsts just printing the path is enough\n+            (Scalar::Raw { size: 0, .. }, ty::FnDef(d, s)) => p!(print_value_path(*d, s)),\n+            // Empty tuples are frequently occurring, so don't print the fallback.\n+            (Scalar::Raw { size: 0, .. }, ty::Tuple(ts)) if ts.is_empty() => p!(write(\"()\")),\n+            // Zero element arrays have a trivial representation.\n+            (\n+                Scalar::Raw { size: 0, .. },\n+                ty::Array(\n+                    _,\n+                    ty::Const {\n+                        val: ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: 0, .. })),\n+                        ..\n+                    },\n+                ),\n+            ) => p!(write(\"[]\")),\n+            // Nontrivial types with scalar bit representation\n+            (Scalar::Raw { data, size }, _) => {\n+                let print = |mut this: Self| {\n+                    if size == 0 {\n+                        write!(this, \"transmute(())\")?;\n                     } else {\n-                        false\n+                        write!(this, \"transmute(0x{:01$x})\", data, size as usize * 2)?;\n                     }\n+                    Ok(this)\n+                };\n+                self = if print_ty {\n+                    self.typed_value(print, |this| this.print_type(ty), \": \")?\n                 } else {\n-                    false\n+                    print(self)?\n                 };\n-                if !printed {\n-                    // fallback\n-                    p!(write(\"{:?}\", ct));\n-                    if print_ty {\n-                        p!(write(\": \"), print(ty));\n-                    }\n-                }\n             }\n-        };\n+            // Any pointer values not covered by a branch above\n+            (Scalar::Ptr(p), _) => {\n+                self = self.pretty_print_const_pointer(p, ty, print_ty)?;\n+            }\n+        }\n         Ok(self)\n     }\n+\n+    /// This is overridden for MIR printing because we only want to hide alloc ids from users, not\n+    /// from MIR where it is actually useful.\n+    fn pretty_print_const_pointer(\n+        mut self,\n+        _: Pointer,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        if print_ty {\n+            self.typed_value(\n+                |mut this| {\n+                    this.write_str(\"&_\")?;\n+                    Ok(this)\n+                },\n+                |this| this.print_type(ty),\n+                \": \",\n+            )\n+        } else {\n+            self.write_str(\"&_\")?;\n+            Ok(self)\n+        }\n+    }\n+\n+    fn pretty_print_byte_str(mut self, byte_str: &'tcx [u8]) -> Result<Self::Const, Self::Error> {\n+        define_scoped_cx!(self);\n+        p!(write(\"b\\\"\"));\n+        for &c in byte_str {\n+            for e in std::ascii::escape_default(c) {\n+                self.write_char(e as char)?;\n+            }\n+        }\n+        p!(write(\"\\\"\"));\n+        Ok(self)\n+    }\n+\n+    fn pretty_print_const_value(\n+        mut self,\n+        ct: ConstValue<'tcx>,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        if self.tcx().sess.verbose() {\n+            p!(write(\"ConstValue({:?}: {:?})\", ct, ty));\n+            return Ok(self);\n+        }\n+\n+        let u8_type = self.tcx().types.u8;\n+\n+        match (ct, &ty.kind) {\n+            (ConstValue::Scalar(scalar), _) => self.pretty_print_const_scalar(scalar, ty, print_ty),\n+            (\n+                ConstValue::Slice { data, start, end },\n+                ty::Ref(_, ty::TyS { kind: ty::Slice(t), .. }, _),\n+            ) if *t == u8_type => {\n+                // The `inspect` here is okay since we checked the bounds, and there are\n+                // no relocations (we have an active slice reference here). We don't use\n+                // this result to affect interpreter execution.\n+                let byte_str = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                self.pretty_print_byte_str(byte_str)\n+            }\n+            (\n+                ConstValue::Slice { data, start, end },\n+                ty::Ref(_, ty::TyS { kind: ty::Str, .. }, _),\n+            ) => {\n+                // The `inspect` here is okay since we checked the bounds, and there are no\n+                // relocations (we have an active `str` reference here). We don't use this\n+                // result to affect interpreter execution.\n+                let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+                p!(write(\"{:?}\", s));\n+                Ok(self)\n+            }\n+            (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n+                let n = n.val.try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n+                // cast is ok because we already checked for pointer size (32 or 64 bit) above\n+                let n = Size::from_bytes(n as u64);\n+                let ptr = Pointer::new(AllocId(0), offset);\n+\n+                let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();\n+                p!(write(\"*\"));\n+                p!(pretty_print_byte_str(byte_str));\n+                Ok(self)\n+            }\n+            // FIXME(oli-obk): also pretty print arrays and other aggregate constants by reading\n+            // their fields instead of just dumping the memory.\n+            _ => {\n+                // fallback\n+                p!(write(\"{:?}\", ct));\n+                if print_ty {\n+                    p!(write(\": \"), print(ty));\n+                }\n+                Ok(self)\n+            }\n+        }\n+    }\n }\n \n // HACK(eddyb) boxed to avoid moving around a large struct by-value.\n@@ -1024,6 +1174,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n \n     empty_path: bool,\n     in_value: bool,\n+    pub print_alloc_ids: bool,\n \n     used_region_names: FxHashSet<Symbol>,\n     region_index: usize,\n@@ -1054,6 +1205,7 @@ impl<F> FmtPrinter<'a, 'tcx, F> {\n             fmt,\n             empty_path: false,\n             in_value: ns == Namespace::ValueNS,\n+            print_alloc_ids: false,\n             used_region_names: Default::default(),\n             region_index: 0,\n             binder_depth: 0,\n@@ -1326,6 +1478,22 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self.pretty_in_binder(value)\n     }\n \n+    fn typed_value(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+        t: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+        conversion: &str,\n+    ) -> Result<Self::Const, Self::Error> {\n+        self.write_str(\"{\")?;\n+        self = f(self)?;\n+        self.write_str(conversion)?;\n+        let was_in_value = std::mem::replace(&mut self.in_value, false);\n+        self = t(self)?;\n+        self.in_value = was_in_value;\n+        self.write_str(\"}\")?;\n+        Ok(self)\n+    }\n+\n     fn generic_delimiters(\n         mut self,\n         f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n@@ -1382,6 +1550,28 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n             ty::ReStatic | ty::ReEmpty(_) | ty::ReClosureBound(_) => true,\n         }\n     }\n+\n+    fn pretty_print_const_pointer(\n+        self,\n+        p: Pointer,\n+        ty: Ty<'tcx>,\n+        print_ty: bool,\n+    ) -> Result<Self::Const, Self::Error> {\n+        let print = |mut this: Self| {\n+            define_scoped_cx!(this);\n+            if this.print_alloc_ids {\n+                p!(write(\"{:?}\", p));\n+            } else {\n+                p!(write(\"&_\"));\n+            }\n+            Ok(this)\n+        };\n+        if print_ty {\n+            self.typed_value(print, |this| this.print_type(ty), \": \")\n+        } else {\n+            print(self)\n+        }\n+    }\n }\n \n // HACK(eddyb) limited to `FmtPrinter` because of `region_highlight_mode`."}, {"sha": "677dc69773516e6687af9a0fb1308a9798ea217c", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -157,6 +157,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n         }\n     }\n }\n+\n impl PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n     fn region_should_not_be_omitted(&self, _region: ty::Region<'_>) -> bool {\n         false"}, {"sha": "75452b9395b50b213d954588f81969b5e7200dcc", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -3,18 +3,20 @@\n \n use std::convert::{TryFrom, TryInto};\n \n-use rustc::ty::layout::{\n-    self, HasDataLayout, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n-};\n-use rustc::{mir, ty};\n-\n use super::{InterpCx, MPlaceTy, Machine, MemPlace, Place, PlaceTy};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n use rustc::mir::interpret::{\n     sign_extend, truncate, AllocId, ConstValue, GlobalId, InterpResult, Pointer, Scalar,\n };\n-use rustc_ast::ast;\n+use rustc::ty::layout::{\n+    self, HasDataLayout, IntegerExt, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n+};\n+use rustc::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n+use rustc::ty::Ty;\n+use rustc::{mir, ty};\n+use rustc_hir::def::Namespace;\n use rustc_macros::HashStable;\n+use std::fmt::Write;\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n ///\n@@ -92,47 +94,44 @@ pub struct ImmTy<'tcx, Tag = ()> {\n     pub layout: TyLayout<'tcx>,\n }\n \n-// `Tag: Copy` because some methods on `Scalar` consume them by value\n impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n-    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match &self.imm {\n-            // We cannot use `to_bits_or_ptr` as we do not have a `tcx`.\n-            // So we use `is_bits` and circumvent a bunch of sanity checking -- but\n-            // this is anyway only for printing.\n-            Immediate::Scalar(ScalarMaybeUndef::Scalar(s)) if s.is_ptr() => {\n-                fmt.write_str(\"{pointer}\")\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        /// Helper function for printing a scalar to a FmtPrinter\n+        fn p<'a, 'tcx, F: std::fmt::Write, Tag>(\n+            cx: FmtPrinter<'a, 'tcx, F>,\n+            s: ScalarMaybeUndef<Tag>,\n+            ty: Ty<'tcx>,\n+        ) -> Result<FmtPrinter<'a, 'tcx, F>, std::fmt::Error> {\n+            match s {\n+                ScalarMaybeUndef::Scalar(s) => {\n+                    cx.pretty_print_const_scalar(s.erase_tag(), ty, true)\n+                }\n+                ScalarMaybeUndef::Undef => cx.typed_value(\n+                    |mut this| {\n+                        this.write_str(\"{undef \")?;\n+                        Ok(this)\n+                    },\n+                    |this| this.print_type(ty),\n+                    \" \",\n+                ),\n             }\n-            Immediate::Scalar(ScalarMaybeUndef::Scalar(s)) => {\n-                let s = s.assert_bits(self.layout.size);\n-                match self.layout.ty.kind {\n-                    ty::Int(_) => {\n-                        return write!(fmt, \"{}\", super::sign_extend(s, self.layout.size) as i128,);\n-                    }\n-                    ty::Uint(_) => return write!(fmt, \"{}\", s),\n-                    ty::Bool if s == 0 => return fmt.write_str(\"false\"),\n-                    ty::Bool if s == 1 => return fmt.write_str(\"true\"),\n-                    ty::Char => {\n-                        if let Some(c) = u32::try_from(s).ok().and_then(std::char::from_u32) {\n-                            return write!(fmt, \"{}\", c);\n-                        }\n-                    }\n-                    ty::Float(ast::FloatTy::F32) => {\n-                        if let Ok(u) = u32::try_from(s) {\n-                            return write!(fmt, \"{}\", f32::from_bits(u));\n-                        }\n-                    }\n-                    ty::Float(ast::FloatTy::F64) => {\n-                        if let Ok(u) = u64::try_from(s) {\n-                            return write!(fmt, \"{}\", f64::from_bits(u));\n-                        }\n+        }\n+        ty::tls::with(|tcx| {\n+            match self.imm {\n+                Immediate::Scalar(s) => {\n+                    if let Some(ty) = tcx.lift(&self.layout.ty) {\n+                        let cx = FmtPrinter::new(tcx, f, Namespace::ValueNS);\n+                        p(cx, s, ty)?;\n+                        return Ok(());\n                     }\n-                    _ => {}\n+                    write!(f, \"{:?}: {}\", s.erase_tag(), self.layout.ty)\n+                }\n+                Immediate::ScalarPair(a, b) => {\n+                    // FIXME(oli-obk): at least print tuples and slices nicely\n+                    write!(f, \"({:?}, {:?}): {}\", a.erase_tag(), b.erase_tag(), self.layout.ty,)\n                 }\n-                write!(fmt, \"{:x}\", s)\n             }\n-            Immediate::Scalar(ScalarMaybeUndef::Undef) => fmt.write_str(\"{undef}\"),\n-            Immediate::ScalarPair(..) => fmt.write_str(\"{wide pointer or tuple}\"),\n-        }\n+        })\n     }\n }\n "}, {"sha": "0d4a6d1bafdd21e5437ac486476ab7f955fd693f", "filename": "src/test/mir-opt/const-promotion-extern-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -14,7 +14,7 @@ fn main() {}\n // START rustc.FOO.PromoteTemps.before.mir\n // bb0: {\n // ...\n-//     _5 = const Scalar(alloc1+0) : &i32;\n+//     _5 = const {alloc1+0: &i32};\n //     _4 = &(*_5);\n //     _3 = [move _4];\n //     _2 = &_3;\n@@ -31,7 +31,7 @@ fn main() {}\n // START rustc.BAR.PromoteTemps.before.mir\n // bb0: {\n // ...\n-//     _5 = const Scalar(alloc0+0) : &i32;\n+//     _5 = const {alloc0+0: &i32};\n //     _4 = &(*_5);\n //     _3 = [move _4];\n //     _2 = &_3;"}, {"sha": "636aa1af6533341513200eb57adda716331d6488", "filename": "src/test/mir-opt/const_prop/discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -31,7 +31,7 @@ fn main() {\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      _3 = const Scalar(0x01) : std::option::Option<bool>;\n+//      _3 = const {transmute(0x01): std::option::Option<bool>};\n //      _4 = const 1isize;\n //      switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1];\n //  }"}, {"sha": "f332bb895095bf276e861b72f1c229454306a7a3", "filename": "src/test/mir-opt/const_prop/issue-66971.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fissue-66971.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -29,7 +29,7 @@ fn main() {\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      _3 = const Scalar(<ZST>) : ();\n+//      _3 = const ();\n //      _2 = (move _3, const 0u8, const 0u8);\n //      ...\n //      _1 = const encode(move _2) -> bb1;"}, {"sha": "d307cebd71539fb3fa37307f6cf27dfcfe59ac8b", "filename": "src/test/mir-opt/const_prop/read_immutable_static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -10,10 +10,10 @@ fn main() {\n // START rustc.main.ConstProp.before.mir\n //  bb0: {\n //      ...\n-//      _3 = const Scalar(alloc0+0) : &u8;\n+//      _3 = const {alloc0+0: &u8};\n //      _2 = (*_3);\n //      ...\n-//      _5 = const Scalar(alloc0+0) : &u8;\n+//      _5 = const {alloc0+0: &u8};\n //      _4 = (*_5);\n //      _1 = Add(move _2, move _4);\n //      ..."}, {"sha": "e427fd55ad6807a82d9e2cb342ad84e50eddd75b", "filename": "src/test/mir-opt/simplify-locals-removes-unused-consts.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-locals-removes-unused-consts.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -1,18 +1,18 @@\n // compile-flags: -C overflow-checks=no\n \n-fn use_zst(_: ((), ())) { }\n+fn use_zst(_: ((), ())) {}\n \n struct Temp {\n-    x: u8\n+    x: u8,\n }\n \n-fn use_u8(_: u8) { }\n+fn use_u8(_: u8) {}\n \n fn main() {\n     let ((), ()) = ((), ());\n     use_zst(((), ()));\n \n-    use_u8((Temp { x : 40 }).x + 2);\n+    use_u8((Temp { x: 40 }).x + 2);\n }\n \n // END RUST SOURCE\n@@ -35,28 +35,28 @@ fn main() {\n // bb0: {\n //   StorageLive(_1);\n //   StorageLive(_2);\n-//   _2 = const Scalar(<ZST>) : ();\n+//   _2 = const ();\n //   StorageLive(_3);\n-//   _3 = const Scalar(<ZST>) : ();\n-//   _1 = const Scalar(<ZST>) : ((), ());\n+//   _3 = const ();\n+//   _1 = const {transmute(()): ((), ())};\n //   StorageDead(_3);\n //   StorageDead(_2);\n //   StorageDead(_1);\n //   StorageLive(_4);\n //   StorageLive(_6);\n-//   _6 = const Scalar(<ZST>) : ();\n+//   _6 = const ();\n //   StorageLive(_7);\n-//   _7 = const Scalar(<ZST>) : ();\n+//   _7 = const ();\n //   StorageDead(_7);\n //   StorageDead(_6);\n-//   _4 = const use_zst(const Scalar(<ZST>) : ((), ())) -> bb1;\n+//   _4 = const use_zst(const {transmute(()): ((), ())}) -> bb1;\n // }\n // bb1: {\n //   StorageDead(_4);\n //   StorageLive(_8);\n //   StorageLive(_10);\n //   StorageLive(_11);\n-//   _11 = const Scalar(0x28) : Temp;\n+//   _11 = const {transmute(0x28) : Temp};\n //   _10 = const 40u8;\n //   StorageDead(_10);\n //   _8 = const use_u8(const 42u8) -> bb2;\n@@ -75,7 +75,7 @@ fn main() {\n // }\n // bb0: {\n //   StorageLive(_1);\n-//   _1 = const use_zst(const Scalar(<ZST>) : ((), ())) -> bb1;\n+//   _1 = const use_zst(const {transmute(()): ((), ())}) -> bb1;\n // }\n // bb1: {\n //   StorageDead(_1);"}, {"sha": "c1d7022d56b5f848d92e718162cb9fd4808ac301", "filename": "src/test/ui/const-generics/cannot-infer-const-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -10,7 +10,7 @@ error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-const-args.rs:9:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for fn item `fn() -> usize {foo::<_: usize>}`\n+   |     ^^^ cannot infer type for fn item `fn() -> usize {foo::<{_: usize}>}`\n \n error: aborting due to previous error\n "}, {"sha": "469843d6aae1ef5a971531d7f44329eff8b7612f", "filename": "src/test/ui/const-generics/const-generic-type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Fconst-generic-type_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Fconst-generic-type_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-generic-type_name.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -7,5 +7,5 @@\n struct S<const N: usize>;\n \n fn main() {\n-    assert_eq!(std::any::type_name::<S<3>>(), \"const_generic_type_name::S<3usize>\");\n+    assert_eq!(std::any::type_name::<S<3>>(), \"const_generic_type_name::S<3>\");\n }"}, {"sha": "05d2dff8e986816a9a355b25b6876a8eab7e7fe0", "filename": "src/test/ui/const-generics/fn-const-param-infer.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -10,12 +10,12 @@ error[E0308]: mismatched types\n   --> $DIR/fn-const-param-infer.rs:16:31\n    |\n LL |     let _: Checked<not_one> = Checked::<not_two>;\n-   |            ----------------   ^^^^^^^^^^^^^^^^^^ expected `not_one`, found `not_two`\n+   |            ----------------   ^^^^^^^^^^^^^^^^^^ expected `{not_one as fn(usize) -> bool}`, found `{not_two as fn(usize) -> bool}`\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `Checked<not_one>`\n-              found struct `Checked<not_two>`\n+   = note: expected struct `Checked<{not_one as fn(usize) -> bool}>`\n+              found struct `Checked<{not_two as fn(usize) -> bool}>`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-const-param-infer.rs:20:24\n@@ -36,12 +36,12 @@ error[E0308]: mismatched types\n   --> $DIR/fn-const-param-infer.rs:25:40\n    |\n LL |     let _: Checked<{generic::<u32>}> = Checked::<{generic::<u16>}>;\n-   |            -------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `generic::<u32>`, found `generic::<u16>`\n+   |            -------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{generic::<u32> as fn(usize) -> bool}`, found `{generic::<u16> as fn(usize) -> bool}`\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `Checked<generic::<u32>>`\n-              found struct `Checked<generic::<u16>>`\n+   = note: expected struct `Checked<{generic::<u32> as fn(usize) -> bool}>`\n+              found struct `Checked<{generic::<u16> as fn(usize) -> bool}>`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "f0349f469626f971884526e77420700385f9c306", "filename": "src/test/ui/const-generics/raw-ptr-const-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -4,6 +4,6 @@\n struct Const<const P: *const u32>;\n \n fn main() {\n-    let _: Const<{15 as *const _}> = Const::<{10 as *const _}>; //~ mismatched types\n-    let _: Const<{10 as *const _}> = Const::<{10 as *const _}>;\n+    let _: Const<{ 15 as *const _ }> = Const::<{ 10 as *const _ }>; //~ mismatched types\n+    let _: Const<{ 10 as *const _ }> = Const::<{ 10 as *const _ }>;\n }"}, {"sha": "d9794f60a19ceb2bd648bf1709a7d909d66a501a", "filename": "src/test/ui/const-generics/raw-ptr-const-param.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -7,15 +7,15 @@ LL | #![feature(const_generics, const_compare_raw_pointers)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0308]: mismatched types\n-  --> $DIR/raw-ptr-const-param.rs:7:38\n+  --> $DIR/raw-ptr-const-param.rs:7:40\n    |\n-LL |     let _: Const<{15 as *const _}> = Const::<{10 as *const _}>;\n-   |            -----------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{pointer}`, found `{pointer}`\n+LL |     let _: Const<{ 15 as *const _ }> = Const::<{ 10 as *const _ }>;\n+   |            -------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{0xf as *const u32}`, found `{0xa as *const u32}`\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `Const<{pointer}>`\n-              found struct `Const<{pointer}>`\n+   = note: expected struct `Const<{0xf as *const u32}>`\n+              found struct `Const<{0xa as *const u32}>`\n \n error: aborting due to previous error\n "}, {"sha": "bbe3344b412b39ed31b1d67c82572ae474a39484", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd67187965e136bff1ed05e035293441c60f0790/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=dd67187965e136bff1ed05e035293441c60f0790", "patch": "@@ -43,7 +43,7 @@ error: any use of this value will cause an error\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n-   |           exact_div: 1 cannot be divided by 2 without remainder\n+   |           exact_div: 1isize cannot be divided by 2isize without remainder\n    |           inside call to `std::ptr::const_ptr::<impl *const u16>::offset_from` at $DIR/offset_from_ub.rs:36:14\n    | \n   ::: $DIR/offset_from_ub.rs:31:1"}]}