{"sha": "daed54d016bd7940d11d2d5c25f7e778ab24810b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZWQ1NGQwMTZiZDc5NDBkMTFkMmQ1YzI1ZjdlNzc4YWIyNDgxMGI=", "commit": {"author": {"name": "A.J. Gardner", "email": "mrhota@users.noreply.github.com", "date": "2014-12-07T19:42:43Z"}, "committer": {"name": "A.J. Gardner", "email": "mrhota@users.noreply.github.com", "date": "2014-12-24T20:42:21Z"}, "message": "Guide changes: Generics and Traits sections\n\nMostly copy-editing, clarification---in particular, monomorphization", "tree": {"sha": "b877fb44f1e60f9d67f8d90c4c400c6bb6c23860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b877fb44f1e60f9d67f8d90c4c400c6bb6c23860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daed54d016bd7940d11d2d5c25f7e778ab24810b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daed54d016bd7940d11d2d5c25f7e778ab24810b", "html_url": "https://github.com/rust-lang/rust/commit/daed54d016bd7940d11d2d5c25f7e778ab24810b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daed54d016bd7940d11d2d5c25f7e778ab24810b/comments", "author": {"login": "mrhota", "id": 403641, "node_id": "MDQ6VXNlcjQwMzY0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/403641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrhota", "html_url": "https://github.com/mrhota", "followers_url": "https://api.github.com/users/mrhota/followers", "following_url": "https://api.github.com/users/mrhota/following{/other_user}", "gists_url": "https://api.github.com/users/mrhota/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrhota/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrhota/subscriptions", "organizations_url": "https://api.github.com/users/mrhota/orgs", "repos_url": "https://api.github.com/users/mrhota/repos", "events_url": "https://api.github.com/users/mrhota/events{/privacy}", "received_events_url": "https://api.github.com/users/mrhota/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mrhota", "id": 403641, "node_id": "MDQ6VXNlcjQwMzY0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/403641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrhota", "html_url": "https://github.com/mrhota", "followers_url": "https://api.github.com/users/mrhota/followers", "following_url": "https://api.github.com/users/mrhota/following{/other_user}", "gists_url": "https://api.github.com/users/mrhota/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrhota/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrhota/subscriptions", "organizations_url": "https://api.github.com/users/mrhota/orgs", "repos_url": "https://api.github.com/users/mrhota/repos", "events_url": "https://api.github.com/users/mrhota/events{/privacy}", "received_events_url": "https://api.github.com/users/mrhota/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ad8539b9c408eebbe7252f74c754f4e0a41d46", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ad8539b9c408eebbe7252f74c754f4e0a41d46", "html_url": "https://github.com/rust-lang/rust/commit/29ad8539b9c408eebbe7252f74c754f4e0a41d46"}], "stats": {"total": 232, "additions": 110, "deletions": 122}, "files": [{"sha": "1f956a02513d19e7500908f1cd3b087dcda91770", "filename": "src/doc/guide.md", "status": "modified", "additions": 110, "deletions": 122, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/daed54d016bd7940d11d2d5c25f7e778ab24810b/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/daed54d016bd7940d11d2d5c25f7e778ab24810b/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=daed54d016bd7940d11d2d5c25f7e778ab24810b", "patch": "@@ -4738,13 +4738,13 @@ enum OptionalFloat64 {\n }\n ```\n \n-This is really unfortunate. Luckily, Rust has a feature that gives us a better\n-way: generics. Generics are called **parametric polymorphism** in type theory,\n-which means that they are types or functions that have multiple forms (\"poly\"\n-is multiple, \"morph\" is form) over a given parameter (\"parametric\").\n+Such repetition is unfortunate. Luckily, Rust has a feature that gives us a\n+better way: **generics**. Generics are called **parametric polymorphism** in\n+type theory, which means that they are types or functions that have multiple\n+forms over a given parameter (\"parametric\").\n \n-Anyway, enough with type theory declarations, let's check out the generic form\n-of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n+Let's see how generics help us escape `OptionalInt`. `Option` is already\n+provided in Rust's standard library and looks like this:\n \n ```rust\n enum Option<T> {\n@@ -4753,25 +4753,27 @@ enum Option<T> {\n }\n ```\n \n-The `<T>` part, which you've seen a few times before, indicates that this is\n-a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n-we substitute that type for the same type used in the generic. Here's an\n-example of using `Option<T>`, with some extra type annotations:\n+The `<T>` part, which you've seen a few times before, indicates that this is a\n+generic data type. `T` is called a **type parameter**. When we create instances\n+of `Option`, we need to provide a concrete type in place of the type\n+parameter. For example, if we wanted something like our `OptionalInt`, we would\n+need to instantiate an `Option<int>`. Inside the declaration of our enum,\n+wherever we see a `T`, we replace it with the type specified (or inferred by the\n+the compiler).\n \n ```{rust}\n let x: Option<int> = Some(5i);\n ```\n \n-In the type declaration, we say `Option<int>`. Note how similar this looks to\n-`Option<T>`. So, in this particular `Option`, `T` has the value of `int`. On\n-the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n-Since that's an `int`, the two sides match, and Rust is happy. If they didn't\n-match, we'd get an error:\n+In this particular `Option`, `T` has the value of `int`. On the right-hand side\n+of the binding, we do make a `Some(T)`, where `T` is `5i`.  Since that's an\n+`int`, the two sides match, and Rust is happy. If they didn't match, we'd get an\n+error:\n \n ```{rust,ignore}\n let x: Option<f64> = Some(5i);\n-// error: mismatched types: expected `core::option::Option<f64>`\n-// but found `core::option::Option<int>` (expected f64 but found int)\n+// error: mismatched types: expected `core::option::Option<f64>`,\n+// found `core::option::Option<int>` (expected f64, found int)\n ```\n \n That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n@@ -4782,8 +4784,6 @@ let x: Option<int> = Some(5i);\n let y: Option<f64> = Some(5.0f64);\n ```\n \n-This is just fine. One definition, multiple uses.\n-\n Generics don't have to only be generic over one type. Consider Rust's built-in\n `Result<T, E>` type:\n \n@@ -4804,20 +4804,20 @@ enum Result<H, N> {\n }\n ```\n \n-if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error'. Rust doesn't care, however.\n+Convention says that the first generic parameter should be `T`, for \"type,\" and\n+that we use `E` for \"error.\"\n \n-The `Result<T, E>` type is intended to\n-be used to return the result of a computation, and to have the ability to\n-return an error if it didn't work out. Here's an example:\n+The `Result<T, E>` type is intended to be used to return the result of a\n+computation and to have the ability to return an error if it didn't work\n+out. Here's an example:\n \n ```{rust}\n let x: Result<f64, String> = Ok(2.3f64);\n let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n ```\n \n-This particular Result will return an `f64` if there's a success, and a\n-`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n+This particular `Result` will return an `f64` upon success and a `String` if\n+there's a failure. Let's write a function that uses `Result<T, E>`:\n \n ```{rust}\n fn inverse(x: f64) -> Result<f64, String> {\n@@ -4827,17 +4827,18 @@ fn inverse(x: f64) -> Result<f64, String> {\n }\n ```\n \n-We don't want to take the inverse of zero, so we check to make sure that we\n-weren't passed zero. If we were, then we return an `Err`, with a message. If\n-it's okay, we return an `Ok`, with the answer.\n+We want to indicate that `inverse(0.0f64)` is undefined or is an erroneous usage\n+of the function, so we check to make sure that we weren't passed zero. If we\n+were, we return an `Err` with a message. If it's okay, we return an `Ok` with\n+the answer.\n \n Why does this matter? Well, remember how `match` does exhaustive matches?\n Here's how this function gets used:\n \n ```{rust}\n # fn inverse(x: f64) -> Result<f64, String> {\n-#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n-#     Ok(1.0f64 / x)\n+# if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+# Ok(1.0f64 / x)\n # }\n let x = inverse(25.0f64);\n \n@@ -4858,8 +4859,8 @@ println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied\n ```\n \n This function is great, but there's one other problem: it only works for 64 bit\n-floating point values. What if we wanted to handle 32 bit floating point as\n-well? We'd have to write this:\n+floating point values. If we wanted to handle 32 bit floating point values we'd\n+have to write this:\n \n ```{rust}\n fn inverse32(x: f32) -> Result<f32, String> {\n@@ -4869,9 +4870,9 @@ fn inverse32(x: f32) -> Result<f32, String> {\n }\n ```\n \n-Bummer. What we need is a **generic function**. Luckily, we can write one!\n-However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n-A generic version of `inverse` would look something like this:\n+What we need is a **generic function**. We can do that with Rust! However, it\n+won't _quite_ work yet. We need to talk about syntax. A first attempt at a\n+generic version of `inverse` might look something like this:\n \n ```{rust,ignore}\n fn inverse<T>(x: T) -> Result<T, String> {\n@@ -4881,24 +4882,34 @@ fn inverse<T>(x: T) -> Result<T, String> {\n }\n ```\n \n-Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n-We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n-of the `Result` has type `T`. However, if we try to compile that example, we'll get\n-an error:\n+Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.  We\n+can then use `T` inside the rest of the signature: `x` has type `T`, and half of\n+the `Result` has type `T`. However, if we try to compile that example, we'll get\n+some errors:\n \n ```text\n error: binary operation `==` cannot be applied to type `T`\n+     if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n+                ^~~~~~~~\n+error: mismatched types: expected `_`, found `T` (expected floating-point variable, found type parameter)\n+     Ok(1.0 / x)\n+              ^\n+error: mismatched types: expected `core::result::Result<T, collections::string::String>`, found `core::result::Result<_, _>` (expected type parameter, found floating-point variable)\n+     Ok(1.0 / x)\n+     ^~~~~~~~~~~\n ```\n \n-Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n-and therefore, the first line would be wrong. What do we do?\n+The problem is that `T` is unconstrained: it can be _any_ type. It could be a\n+`String`, and the expression `1.0 / x` has no meaning if `x` is a `String`. It\n+may be a type that doesn't implement `==`, and the first line would be\n+wrong. What do we do?\n \n-To fix this example, we need to learn about another Rust feature: traits.\n+To fix this example, we need to learn about another Rust feature: **traits**.\n \n # Traits\n \n-Do you remember the `impl` keyword, used to call a function with method\n-syntax?\n+Our discussion of **traits** begins with the `impl` keyword. We used it before\n+to specify methods.\n \n ```{rust}\n struct Circle {\n@@ -4914,8 +4925,8 @@ impl Circle {\n }\n ```\n \n-Traits are similar, except that we define a trait with just the method\n-signature, then implement the trait for that struct. Like this:\n+We define a trait in terms of its methods. We then `impl` a trait `for` a type\n+(or many types).\n \n ```{rust}\n struct Circle {\n@@ -4935,19 +4946,18 @@ impl HasArea for Circle {\n }\n ```\n \n-As you can see, the `trait` block looks very similar to the `impl` block,\n-but we don't define a body, just a type signature. When we `impl` a trait,\n-we use `impl Trait for Item`, rather than just `impl Item`.\n+The `trait` block defines only type signatures. When we `impl` a trait, we use\n+`impl Trait for Item`, rather than just `impl Item`.\n \n-So what's the big deal? Remember the error we were getting with our generic\n-`inverse` function?\n+The first of the three errors we got with our generic `inverse` function was\n+this:\n \n ```text\n error: binary operation `==` cannot be applied to type `T`\n ```\n \n-We can use traits to constrain our generics. Consider this function, which\n-does not compile, and gives us a similar error:\n+We can use traits to constrain generic type parameters. Consider this function,\n+which does not compile, and gives us a similar error:\n \n ```{rust,ignore}\n fn print_area<T>(shape: T) {\n@@ -4962,8 +4972,9 @@ error: type `T` does not implement any method in scope named `area`\n ```\n \n Because `T` can be any type, we can't be sure that it implements the `area`\n-method. But we can add a **trait constraint** to our generic `T`, ensuring\n-that it does:\n+method. But we can add a **trait constraint** to our generic `T`, ensuring that\n+we can only compile the function if it's called with types which `impl` the\n+`HasArea` trait:\n \n ```{rust}\n # trait HasArea {\n@@ -4974,9 +4985,9 @@ fn print_area<T: HasArea>(shape: T) {\n }\n ```\n \n-The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n-Because traits define function type signatures, we can be sure that any type\n-which implements `HasArea` will have an `.area()` method.\n+The syntax `<T: HasArea>` means \"any type that implements the HasArea trait.\"\n+Because traits define method signatures, we can be sure that any type which\n+implements `HasArea` will have an `area` method.\n \n Here's an extended example of how this works:\n \n@@ -5074,55 +5085,22 @@ impl HasArea for int {\n It is considered poor style to implement methods on such primitive types, even\n though it is possible.\n \n-This may seem like the Wild West, but there are two other restrictions around\n-implementing traits that prevent this from getting out of hand. First, traits\n-must be `use`d in any scope where you wish to use the trait's method. So for\n-example, this does not work:\n-\n-```{rust,ignore}\n-mod shapes {\n-    use std::f64::consts;\n-\n-    trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    struct Circle {\n-        x: f64,\n-        y: f64,\n-        radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n+## Scoped Method Resolution and Orphan `impl`s\n \n-    println!(\"{}\", c.area());\n-}\n-```\n-\n-Now that we've moved the structs and traits into their own module, we get an\n-error:\n+There are two restrictions for implementing traits that prevent this from\n+getting out of hand.\n \n-```text\n-error: type `shapes::Circle` does not implement any method in scope named `area`\n-```\n+1. **Scope-based Method Resolution**: Traits must be `use`d in any scope where\n+   you wish to use the trait's methods\n+2. **No Orphan `impl`s**: Either the trait or the type you're writing the `impl`\n+   for must be inside your crate.\n \n-If we add a `use` line right above `main` and make the right things public,\n-everything is fine:\n+If we organize our crate differently by using modules, we'll need to ensure both\n+of the conditions are satisfied. Don't worry, you can lean on the compiler since\n+it won't let you get away with violating them.\n \n ```{rust}\n-use shapes::HasArea;\n+use shapes::HasArea; // satisfies #1\n \n mod shapes {\n     use std::f64::consts;\n@@ -5144,8 +5122,8 @@ mod shapes {\n     }\n }\n \n-\n fn main() {\n+    // use shapes::HasArea; // This would satisfy #1, too\n     let c = shapes::Circle {\n         x: 0.0f64,\n         y: 0.0f64,\n@@ -5156,18 +5134,25 @@ fn main() {\n }\n ```\n \n-This means that even if someone does something bad like add methods to `int`,\n-it won't affect you, unless you `use` that trait.\n+Requiring us to `use` traits whose methods we want means that even if someone\n+does something bad like add methods to `int`, it won't affect us, unless you\n+`use` that trait.\n+\n+The second condition allows us to `impl` built-in `trait`s for types we define,\n+or allows us to `impl` our own `trait`s for built-in types, but restricts us\n+from mixing and matching third party or built-in `impl`s with third party or\n+built-in types.\n \n-There's one more restriction on implementing traits. Either the trait or the\n-type you're writing the `impl` for must be inside your crate. So, we could\n-implement the `HasArea` type for `int`, because `HasArea` is in our crate.  But\n-if we tried to implement `Float`, a trait provided by Rust, for `int`, we could\n-not, because both the trait and the type aren't in our crate.\n+We could `impl` the `HasArea` trait for `int`, because `HasArea` is in our\n+crate. But if we tried to implement `Float`, a standard library `trait`, for\n+`int`, we could not, because neither the `trait` nor the `type` are in our\n+crate.\n \n-One last thing about traits: generic functions with a trait bound use\n-**monomorphization** (\"mono\": one, \"morph\": form), so they are statically\n-dispatched. What's that mean? Well, let's take a look at `print_area` again:\n+## Monomorphization\n+\n+One last thing about generics and traits: the compiler performs\n+**monomorphization** on generic functions so they are statically dispatched. To\n+see what that means, let's take a look at `print_area` again:\n \n ```{rust,ignore}\n fn print_area<T: HasArea>(shape: T) {\n@@ -5184,10 +5169,11 @@ fn main() {\n }\n ```\n \n-When we use this trait with `Circle` and `Square`, Rust ends up generating\n-two different functions with the concrete type, and replacing the call sites with\n-calls to the concrete implementations. In other words, you get something like\n-this:\n+Because we have called `print_area` with two different types in place of its\n+type paramater `T`, Rust will generate two versions of the function with the\n+appropriate concrete types, replacing the call sites with calls to the concrete\n+implementations. In other words, the compiler will actually compile something\n+more like this:\n \n ```{rust,ignore}\n fn __print_area_circle(shape: Circle) {\n@@ -5208,10 +5194,12 @@ fn main() {\n }\n ```\n \n-The names don't actually change to this, it's just for illustration. But\n-as you can see, there's no overhead of deciding which version to call here,\n-hence 'statically dispatched'. The downside is that we have two copies of\n-the same function, so our binary is a little bit larger.\n+These names are for illustration; the compiler will generate its own cryptic\n+names for internal uses. The point is that there is no runtime overhead of\n+deciding which version to call. The function to be called is determined\n+statically, at compile time. Thus, generic functions are **statically\n+dispatched**. The downside is that we have two similar functions, so our binary\n+is larger.\n \n # Tasks\n "}]}