{"sha": "969e25033bc150bd3811468cea59cb1edaf1382e", "node_id": "C_kwDOAAsO6NoAKDk2OWUyNTAzM2JjMTUwYmQzODExNDY4Y2VhNTljYjFlZGFmMTM4MmU", "commit": {"author": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-11-25T12:02:44Z"}, "committer": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-11-25T12:02:44Z"}, "message": "Merge commit 'f5fde4df4' into HEAD", "tree": {"sha": "5cc3e97f81ae0f052e40ced1d33afde11eb5542e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cc3e97f81ae0f052e40ced1d33afde11eb5542e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/969e25033bc150bd3811468cea59cb1edaf1382e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/969e25033bc150bd3811468cea59cb1edaf1382e", "html_url": "https://github.com/rust-lang/rust/commit/969e25033bc150bd3811468cea59cb1edaf1382e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/969e25033bc150bd3811468cea59cb1edaf1382e/comments", "author": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3553623805c09279c8de634f22578c5a43f4383", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3553623805c09279c8de634f22578c5a43f4383", "html_url": "https://github.com/rust-lang/rust/commit/b3553623805c09279c8de634f22578c5a43f4383"}, {"sha": "f5fde4df43fa9a6cf929b1cb0f6ab8233a4be4dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5fde4df43fa9a6cf929b1cb0f6ab8233a4be4dc", "html_url": "https://github.com/rust-lang/rust/commit/f5fde4df43fa9a6cf929b1cb0f6ab8233a4be4dc"}], "stats": {"total": 2215, "additions": 1587, "deletions": 628}, "files": [{"sha": "216cf51447fadd00bd93c30d4d0698a5ab818762", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -394,6 +394,7 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"paths\",\n+ \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n  \"stdx\",\n@@ -660,6 +661,7 @@ dependencies = [\n  \"indexmap\",\n  \"itertools\",\n  \"limit\",\n+ \"memchr\",\n  \"once_cell\",\n  \"parser\",\n  \"profile\","}, {"sha": "688e790c5368cdbe67c15b21287681b9e2f5fa22", "filename": "crates/flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2FCargo.toml?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -13,6 +13,7 @@ doctest = false\n crossbeam-channel = \"0.5.5\"\n tracing = \"0.1.35\"\n cargo_metadata = \"0.15.0\"\n+rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = \"1.0.81\"\n jod-thread = \"0.1.2\""}, {"sha": "fdc03f4053a2714b18b0364b58127eb73d195ab9", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -12,6 +12,7 @@ use std::{\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use paths::AbsPathBuf;\n+use rustc_hash::FxHashMap;\n use serde::Deserialize;\n use stdx::{process::streaming_output, JodChild};\n \n@@ -30,18 +31,20 @@ pub enum FlycheckConfig {\n         all_features: bool,\n         features: Vec<String>,\n         extra_args: Vec<String>,\n+        extra_env: FxHashMap<String, String>,\n     },\n     CustomCommand {\n         command: String,\n         args: Vec<String>,\n+        extra_env: FxHashMap<String, String>,\n     },\n }\n \n impl fmt::Display for FlycheckConfig {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             FlycheckConfig::CargoCommand { command, .. } => write!(f, \"cargo {}\", command),\n-            FlycheckConfig::CustomCommand { command, args } => {\n+            FlycheckConfig::CustomCommand { command, args, .. } => {\n                 write!(f, \"{} {}\", command, args.join(\" \"))\n             }\n         }\n@@ -256,6 +259,7 @@ impl FlycheckActor {\n                 all_features,\n                 extra_args,\n                 features,\n+                extra_env,\n             } => {\n                 let mut cmd = Command::new(toolchain::cargo());\n                 cmd.arg(command);\n@@ -281,11 +285,13 @@ impl FlycheckActor {\n                     }\n                 }\n                 cmd.args(extra_args);\n+                cmd.envs(extra_env);\n                 cmd\n             }\n-            FlycheckConfig::CustomCommand { command, args } => {\n+            FlycheckConfig::CustomCommand { command, args, extra_env } => {\n                 let mut cmd = Command::new(command);\n                 cmd.args(args);\n+                cmd.envs(extra_env);\n                 cmd\n             }\n         };"}, {"sha": "b94b50004093ccdee496da7c23884e9a46428b5b", "filename": "crates/hir-def/src/find_path.rs", "status": "modified", "additions": 231, "deletions": 131, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -1,6 +1,6 @@\n //! An algorithm to find a path to refer to a certain item.\n \n-use std::iter;\n+use std::{cmp::Ordering, iter};\n \n use hir_expand::name::{known, AsName, Name};\n use rustc_hash::FxHashSet;\n@@ -16,57 +16,29 @@ use crate::{\n \n /// Find a path that can be used to refer to a certain item. This can depend on\n /// *from where* you're referring to the item, hence the `from` parameter.\n-pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+pub fn find_path(\n+    db: &dyn DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    prefer_no_std: bool,\n+) -> Option<ModPath> {\n     let _p = profile::span(\"find_path\");\n-    find_path_inner(db, item, from, None)\n+    find_path_inner(db, item, from, None, prefer_no_std)\n }\n \n pub fn find_path_prefixed(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n     prefix_kind: PrefixKind,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     let _p = profile::span(\"find_path_prefixed\");\n-    find_path_inner(db, item, from, Some(prefix_kind))\n+    find_path_inner(db, item, from, Some(prefix_kind), prefer_no_std)\n }\n \n const MAX_PATH_LEN: usize = 15;\n \n-trait ModPathExt {\n-    fn starts_with_std(&self) -> bool;\n-    fn can_start_with_std(&self) -> bool;\n-}\n-\n-impl ModPathExt for ModPath {\n-    fn starts_with_std(&self) -> bool {\n-        self.segments().first() == Some(&known::std)\n-    }\n-\n-    // Can we replace the first segment with `std::` and still get a valid, identical path?\n-    fn can_start_with_std(&self) -> bool {\n-        let first_segment = self.segments().first();\n-        first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n-    }\n-}\n-\n-fn check_self_super(def_map: &DefMap, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n-    if item == ItemInNs::Types(from.into()) {\n-        // - if the item is the module we're in, use `self`\n-        Some(ModPath::from_segments(PathKind::Super(0), None))\n-    } else if let Some(parent_id) = def_map[from.local_id].parent {\n-        // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n-        let parent_id = def_map.module_id(parent_id);\n-        if item == ItemInNs::Types(ModuleDefId::ModuleId(parent_id)) {\n-            Some(ModPath::from_segments(PathKind::Super(1), None))\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum PrefixKind {\n     /// Causes paths to always start with either `self`, `super`, `crate` or a crate-name.\n@@ -94,135 +66,247 @@ impl PrefixKind {\n         self == &PrefixKind::ByCrate\n     }\n }\n+\n /// Attempts to find a path to refer to the given `item` visible from the `from` ModuleId\n fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n     prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n-    // FIXME: Do fast path for std/core libs?\n+    // - if the item is a builtin, it's in scope\n+    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n+        return Some(ModPath::from_segments(PathKind::Plain, Some(builtin.as_name())));\n+    }\n \n-    let mut visited_modules = FxHashSet::default();\n     let def_map = from.def_map(db);\n-    find_path_inner_(db, &def_map, from, item, MAX_PATH_LEN, prefixed, &mut visited_modules)\n+    let crate_root = def_map.crate_root(db);\n+    // - if the item is a module, jump straight to module search\n+    if let ItemInNs::Types(ModuleDefId::ModuleId(module_id)) = item {\n+        let mut visited_modules = FxHashSet::default();\n+        return find_path_for_module(\n+            db,\n+            &def_map,\n+            &mut visited_modules,\n+            crate_root,\n+            from,\n+            module_id,\n+            MAX_PATH_LEN,\n+            prefixed,\n+            prefer_no_std || db.crate_supports_no_std(crate_root.krate),\n+        );\n+    }\n+\n+    // - if the item is already in scope, return the name under which it is\n+    let scope_name = find_in_scope(db, &def_map, from, item);\n+    if prefixed.is_none() {\n+        if let Some(scope_name) = scope_name {\n+            return Some(ModPath::from_segments(PathKind::Plain, Some(scope_name)));\n+        }\n+    }\n+\n+    // - if the item is in the prelude, return the name from there\n+    if let Some(value) = find_in_prelude(db, &crate_root.def_map(db), item, from) {\n+        return value;\n+    }\n+\n+    if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n+        // - if the item is an enum variant, refer to it via the enum\n+        if let Some(mut path) = find_path_inner(\n+            db,\n+            ItemInNs::Types(variant.parent.into()),\n+            from,\n+            prefixed,\n+            prefer_no_std,\n+        ) {\n+            let data = db.enum_data(variant.parent);\n+            path.push_segment(data.variants[variant.local_id].name.clone());\n+            return Some(path);\n+        }\n+        // If this doesn't work, it seems we have no way of referring to the\n+        // enum; that's very weird, but there might still be a reexport of the\n+        // variant somewhere\n+    }\n+\n+    let mut visited_modules = FxHashSet::default();\n+\n+    calculate_best_path(\n+        db,\n+        &def_map,\n+        &mut visited_modules,\n+        crate_root,\n+        MAX_PATH_LEN,\n+        item,\n+        from,\n+        prefixed,\n+        prefer_no_std || db.crate_supports_no_std(crate_root.krate),\n+        scope_name,\n+    )\n }\n \n-fn find_path_inner_(\n+fn find_path_for_module(\n     db: &dyn DefDatabase,\n     def_map: &DefMap,\n+    visited_modules: &mut FxHashSet<ModuleId>,\n+    crate_root: ModuleId,\n     from: ModuleId,\n-    item: ItemInNs,\n+    module_id: ModuleId,\n     max_len: usize,\n-    mut prefixed: Option<PrefixKind>,\n-    visited_modules: &mut FxHashSet<ModuleId>,\n+    prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     if max_len == 0 {\n         return None;\n     }\n \n     // Base cases:\n-\n     // - if the item is already in scope, return the name under which it is\n-    let scope_name = def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n-        def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n-    });\n+    let scope_name = find_in_scope(db, def_map, from, ItemInNs::Types(module_id.into()));\n     if prefixed.is_none() {\n         if let Some(scope_name) = scope_name {\n             return Some(ModPath::from_segments(PathKind::Plain, Some(scope_name)));\n         }\n     }\n \n-    // - if the item is a builtin, it's in scope\n-    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n-        return Some(ModPath::from_segments(PathKind::Plain, Some(builtin.as_name())));\n-    }\n-\n     // - if the item is the crate root, return `crate`\n-    let crate_root = def_map.crate_root(db);\n-    if item == ItemInNs::Types(ModuleDefId::ModuleId(crate_root)) {\n+    if module_id == crate_root {\n         return Some(ModPath::from_segments(PathKind::Crate, None));\n     }\n \n+    // - if relative paths are fine, check if we are searching for a parent\n     if prefixed.filter(PrefixKind::is_absolute).is_none() {\n-        if let modpath @ Some(_) = check_self_super(&def_map, item, from) {\n+        if let modpath @ Some(_) = find_self_super(&def_map, module_id, from) {\n             return modpath;\n         }\n     }\n \n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n     let root_def_map = crate_root.def_map(db);\n-    if let ItemInNs::Types(ModuleDefId::ModuleId(item)) = item {\n-        for (name, &def_id) in root_def_map.extern_prelude() {\n-            if item == def_id {\n-                let name = scope_name.unwrap_or_else(|| name.clone());\n-\n-                let name_already_occupied_in_type_ns = def_map\n-                    .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n-                        def_map[local_id]\n-                            .scope\n-                            .type_(&name)\n-                            .filter(|&(id, _)| id != ModuleDefId::ModuleId(def_id))\n-                    })\n-                    .is_some();\n-                let kind = if name_already_occupied_in_type_ns {\n-                    cov_mark::hit!(ambiguous_crate_start);\n-                    PathKind::Abs\n-                } else {\n-                    PathKind::Plain\n-                };\n-                return Some(ModPath::from_segments(kind, Some(name)));\n-            }\n+    for (name, &def_id) in root_def_map.extern_prelude() {\n+        if module_id == def_id {\n+            let name = scope_name.unwrap_or_else(|| name.clone());\n+\n+            let name_already_occupied_in_type_ns = def_map\n+                .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+                    def_map[local_id]\n+                        .scope\n+                        .type_(&name)\n+                        .filter(|&(id, _)| id != ModuleDefId::ModuleId(def_id))\n+                })\n+                .is_some();\n+            let kind = if name_already_occupied_in_type_ns {\n+                cov_mark::hit!(ambiguous_crate_start);\n+                PathKind::Abs\n+            } else {\n+                PathKind::Plain\n+            };\n+            return Some(ModPath::from_segments(kind, Some(name)));\n         }\n     }\n \n-    // - if the item is in the prelude, return the name from there\n+    if let Some(value) = find_in_prelude(db, &root_def_map, ItemInNs::Types(module_id.into()), from)\n+    {\n+        return value;\n+    }\n+    calculate_best_path(\n+        db,\n+        def_map,\n+        visited_modules,\n+        crate_root,\n+        max_len,\n+        ItemInNs::Types(module_id.into()),\n+        from,\n+        prefixed,\n+        prefer_no_std,\n+        scope_name,\n+    )\n+}\n+\n+fn find_in_scope(\n+    db: &dyn DefDatabase,\n+    def_map: &DefMap,\n+    from: ModuleId,\n+    item: ItemInNs,\n+) -> Option<Name> {\n+    def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+        def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n+    })\n+}\n+\n+fn find_in_prelude(\n+    db: &dyn DefDatabase,\n+    root_def_map: &DefMap,\n+    item: ItemInNs,\n+    from: ModuleId,\n+) -> Option<Option<ModPath>> {\n     if let Some(prelude_module) = root_def_map.prelude() {\n         // Preludes in block DefMaps are ignored, only the crate DefMap is searched\n         let prelude_def_map = prelude_module.def_map(db);\n         let prelude_scope = &prelude_def_map[prelude_module.local_id].scope;\n         if let Some((name, vis)) = prelude_scope.name_of(item) {\n             if vis.is_visible_from(db, from) {\n-                return Some(ModPath::from_segments(PathKind::Plain, Some(name.clone())));\n+                return Some(Some(ModPath::from_segments(PathKind::Plain, Some(name.clone()))));\n             }\n         }\n     }\n+    None\n+}\n \n-    // Recursive case:\n-    // - if the item is an enum variant, refer to it via the enum\n-    if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n-        if let Some(mut path) = find_path(db, ItemInNs::Types(variant.parent.into()), from) {\n-            let data = db.enum_data(variant.parent);\n-            path.push_segment(data.variants[variant.local_id].name.clone());\n-            return Some(path);\n+fn find_self_super(def_map: &DefMap, item: ModuleId, from: ModuleId) -> Option<ModPath> {\n+    if item == from {\n+        // - if the item is the module we're in, use `self`\n+        Some(ModPath::from_segments(PathKind::Super(0), None))\n+    } else if let Some(parent_id) = def_map[from.local_id].parent {\n+        // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n+        let parent_id = def_map.module_id(parent_id);\n+        if item == parent_id {\n+            Some(ModPath::from_segments(PathKind::Super(1), None))\n+        } else {\n+            None\n         }\n-        // If this doesn't work, it seems we have no way of referring to the\n-        // enum; that's very weird, but there might still be a reexport of the\n-        // variant somewhere\n+    } else {\n+        None\n     }\n+}\n \n-    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n-    let prefer_no_std = db.crate_supports_no_std(crate_root.krate);\n+fn calculate_best_path(\n+    db: &dyn DefDatabase,\n+    def_map: &DefMap,\n+    visited_modules: &mut FxHashSet<ModuleId>,\n+    crate_root: ModuleId,\n+    max_len: usize,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    mut prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n+    scope_name: Option<Name>,\n+) -> Option<ModPath> {\n+    if max_len <= 1 {\n+        return None;\n+    }\n     let mut best_path = None;\n-    let mut best_path_len = max_len;\n-\n+    // Recursive case:\n+    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n     if item.krate(db) == Some(from.krate) {\n+        let mut best_path_len = max_len;\n         // Item was defined in the same crate that wants to import it. It cannot be found in any\n         // dependency in this case.\n-        // FIXME: this should have a fast path that doesn't look through the prelude again?\n         for (module_id, name) in find_local_import_locations(db, item, from) {\n             if !visited_modules.insert(module_id) {\n                 cov_mark::hit!(recursive_imports);\n                 continue;\n             }\n-            if let Some(mut path) = find_path_inner_(\n+            if let Some(mut path) = find_path_for_module(\n                 db,\n                 def_map,\n+                visited_modules,\n+                crate_root,\n                 from,\n-                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+                module_id,\n                 best_path_len - 1,\n                 prefixed,\n-                visited_modules,\n+                prefer_no_std,\n             ) {\n                 path.push_segment(name);\n \n@@ -245,14 +329,16 @@ fn find_path_inner_(\n             import_map.import_info_for(item).and_then(|info| {\n                 // Determine best path for containing module and append last segment from `info`.\n                 // FIXME: we should guide this to look up the path locally, or from the same crate again?\n-                let mut path = find_path_inner_(\n+                let mut path = find_path_for_module(\n                     db,\n                     def_map,\n+                    visited_modules,\n                     from,\n-                    ItemInNs::Types(ModuleDefId::ModuleId(info.container)),\n-                    best_path_len - 1,\n+                    crate_root,\n+                    info.container,\n+                    max_len - 1,\n                     prefixed,\n-                    visited_modules,\n+                    prefer_no_std,\n                 )?;\n                 cov_mark::hit!(partially_imported);\n                 path.push_segment(info.path.segments.last()?.clone());\n@@ -268,16 +354,12 @@ fn find_path_inner_(\n             best_path = Some(new_path);\n         }\n     }\n-\n-    // If the item is declared inside a block expression, don't use a prefix, as we don't handle\n-    // that correctly (FIXME).\n-    if let Some(item_module) = item.as_module_def_id().and_then(|did| did.module(db)) {\n-        if item_module.def_map(db).block_id().is_some() && prefixed.is_some() {\n+    if let Some(module) = item.module(db) {\n+        if module.def_map(db).block_id().is_some() && prefixed.is_some() {\n             cov_mark::hit!(prefixed_in_block_expression);\n             prefixed = Some(PrefixKind::Plain);\n         }\n     }\n-\n     match prefixed.map(PrefixKind::prefix) {\n         Some(prefix) => best_path.or_else(|| {\n             scope_name.map(|scope_name| ModPath::from_segments(prefix, Some(scope_name)))\n@@ -287,29 +369,48 @@ fn find_path_inner_(\n }\n \n fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -> ModPath {\n-    if old_path.starts_with_std() && new_path.can_start_with_std() {\n-        if prefer_no_std {\n-            cov_mark::hit!(prefer_no_std_paths);\n-            new_path\n-        } else {\n-            cov_mark::hit!(prefer_std_paths);\n-            old_path\n+    const STD_CRATES: [Name; 3] = [known::std, known::core, known::alloc];\n+    match (old_path.segments().first(), new_path.segments().first()) {\n+        (Some(old), Some(new)) if STD_CRATES.contains(old) && STD_CRATES.contains(new) => {\n+            let rank = match prefer_no_std {\n+                false => |name: &Name| match name {\n+                    name if name == &known::core => 0,\n+                    name if name == &known::alloc => 0,\n+                    name if name == &known::std => 1,\n+                    _ => unreachable!(),\n+                },\n+                true => |name: &Name| match name {\n+                    name if name == &known::core => 2,\n+                    name if name == &known::alloc => 1,\n+                    name if name == &known::std => 0,\n+                    _ => unreachable!(),\n+                },\n+            };\n+            let nrank = rank(new);\n+            let orank = rank(old);\n+            match nrank.cmp(&orank) {\n+                Ordering::Less => old_path,\n+                Ordering::Equal => {\n+                    if new_path.len() < old_path.len() {\n+                        new_path\n+                    } else {\n+                        old_path\n+                    }\n+                }\n+                Ordering::Greater => new_path,\n+            }\n         }\n-    } else if new_path.starts_with_std() && old_path.can_start_with_std() {\n-        if prefer_no_std {\n-            cov_mark::hit!(prefer_no_std_paths);\n-            old_path\n-        } else {\n-            cov_mark::hit!(prefer_std_paths);\n-            new_path\n+        _ => {\n+            if new_path.len() < old_path.len() {\n+                new_path\n+            } else {\n+                old_path\n+            }\n         }\n-    } else if new_path.len() < old_path.len() {\n-        new_path\n-    } else {\n-        old_path\n     }\n }\n \n+// FIXME: Remove allocations\n /// Finds locations in `from.krate` from which `item` can be imported by `from`.\n fn find_local_import_locations(\n     db: &dyn DefDatabase,\n@@ -428,7 +529,8 @@ mod tests {\n             .take_types()\n             .unwrap();\n \n-        let found_path = find_path_inner(&db, ItemInNs::Types(resolved), module, prefix_kind);\n+        let found_path =\n+            find_path_inner(&db, ItemInNs::Types(resolved), module, prefix_kind, false);\n         assert_eq!(found_path, Some(mod_path), \"{:?}\", prefix_kind);\n     }\n \n@@ -468,8 +570,8 @@ $0\n         \"#,\n             \"E::A\",\n             \"E::A\",\n-            \"E::A\",\n-            \"E::A\",\n+            \"crate::E::A\",\n+            \"self::E::A\",\n         );\n     }\n \n@@ -788,7 +890,6 @@ pub use super::foo;\n \n     #[test]\n     fn prefer_std_paths_over_alloc() {\n-        cov_mark::check!(prefer_std_paths);\n         check_found_path(\n             r#\"\n //- /main.rs crate:main deps:alloc,std\n@@ -813,7 +914,6 @@ pub mod sync {\n \n     #[test]\n     fn prefer_core_paths_over_std() {\n-        cov_mark::check!(prefer_no_std_paths);\n         check_found_path(\n             r#\"\n //- /main.rs crate:main deps:core,std"}, {"sha": "7721221c444758a23d2d4d45c06d692657fbe6fb", "filename": "crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     ConstId, HasModule, ImplId, LocalModuleId, MacroId, ModuleDefId, ModuleId, TraitId,\n };\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) enum ImportType {\n     Glob,\n     Named,\n@@ -302,13 +302,13 @@ impl ItemScope {\n                             $changed = true;\n                         }\n                         Entry::Occupied(mut entry)\n-                            if $glob_imports.$field.contains(&$lookup)\n-                                && matches!($def_import_type, ImportType::Named) =>\n+                            if matches!($def_import_type, ImportType::Named) =>\n                         {\n-                            cov_mark::hit!(import_shadowed);\n-                            $glob_imports.$field.remove(&$lookup);\n-                            entry.insert(fld);\n-                            $changed = true;\n+                            if $glob_imports.$field.remove(&$lookup) {\n+                                cov_mark::hit!(import_shadowed);\n+                                entry.insert(fld);\n+                                $changed = true;\n+                            }\n                         }\n                         _ => {}\n                     }\n@@ -457,8 +457,15 @@ impl ItemInNs {\n     /// Returns the crate defining this item (or `None` if `self` is built-in).\n     pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n         match self {\n-            ItemInNs::Types(did) | ItemInNs::Values(did) => did.module(db).map(|m| m.krate),\n+            ItemInNs::Types(id) | ItemInNs::Values(id) => id.module(db).map(|m| m.krate),\n             ItemInNs::Macros(id) => Some(id.module(db).krate),\n         }\n     }\n+\n+    pub fn module(&self, db: &dyn DefDatabase) -> Option<ModuleId> {\n+        match self {\n+            ItemInNs::Types(id) | ItemInNs::Values(id) => id.module(db),\n+            ItemInNs::Macros(id) => Some(id.module(db)),\n+        }\n+    }\n }"}, {"sha": "9242b48c59319a89cad17f21d4b431eccf52fa4d", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -534,6 +534,7 @@ impl DefCollector<'_> {\n             match per_ns.types {\n                 Some((ModuleDefId::ModuleId(m), _)) => {\n                     self.def_map.prelude = Some(m);\n+                    break;\n                 }\n                 types => {\n                     tracing::debug!("}, {"sha": "69283e55a4c2cb0e6acce24fe7f2ac73c11d2410", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -150,6 +150,14 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n         id: chalk_db::AssociatedTyValueId,\n     ) -> Arc<chalk_db::AssociatedTyValue>;\n \n+    #[salsa::invoke(crate::traits::normalize_projection_query)]\n+    #[salsa::transparent]\n+    fn normalize_projection(\n+        &self,\n+        projection: crate::ProjectionTy,\n+        env: Arc<crate::TraitEnvironment>,\n+    ) -> Ty;\n+\n     #[salsa::invoke(trait_solve_wait)]\n     #[salsa::transparent]\n     fn trait_solve("}, {"sha": "874abdaea8370f4ef2a8e3bc1c28abab3d5c6dcc", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -533,6 +533,7 @@ impl HirDisplay for Ty {\n                             f.db.upcast(),\n                             ItemInNs::Types((*def_id).into()),\n                             module_id,\n+                            false,\n                         ) {\n                             write!(f, \"{}\", path)?;\n                         } else {"}, {"sha": "e37763e8ea7f03075b5c19349d4c7d5ff1baf69d", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -673,10 +673,6 @@ impl<'a> InferenceContext<'a> {\n         )\n     }\n \n-    fn resolve_obligations_as_possible(&mut self) {\n-        self.table.resolve_obligations_as_possible();\n-    }\n-\n     fn push_obligation(&mut self, o: DomainGoal) {\n         self.table.register_obligation(o.cast(Interner));\n     }\n@@ -696,7 +692,6 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_ty_shallow(&mut self, ty: &Ty) -> Ty {\n-        self.resolve_obligations_as_possible();\n         self.table.resolve_ty_shallow(ty)\n     }\n "}, {"sha": "de4a5446e57f00e948bee718ae6013dcddbb99b7", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -196,20 +196,6 @@ pub(crate) fn make_binders<T: HasInterner<Interner = Interner>>(\n     make_binders_with_count(db, usize::MAX, generics, value)\n }\n \n-// FIXME: get rid of this\n-pub fn make_canonical<T: HasInterner<Interner = Interner>>(\n-    value: T,\n-    kinds: impl IntoIterator<Item = TyVariableKind>,\n-) -> Canonical<T> {\n-    let kinds = kinds.into_iter().map(|tk| {\n-        chalk_ir::CanonicalVarKind::new(\n-            chalk_ir::VariableKind::Ty(tk),\n-            chalk_ir::UniverseIndex::ROOT,\n-        )\n-    });\n-    Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(Interner, kinds) }\n-}\n-\n // FIXME: get rid of this, just replace it by FnPointer\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type."}, {"sha": "41fcef73d9be40827aa671979c8da0f0931560c6", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -914,22 +914,10 @@ fn iterate_trait_method_candidates(\n     let db = table.db;\n     let env = table.trait_env.clone();\n     let self_is_array = matches!(self_ty.kind(Interner), chalk_ir::TyKind::Array(..));\n-    // if ty is `dyn Trait`, the trait doesn't need to be in scope\n-    let inherent_trait =\n-        self_ty.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = matches!(self_ty.kind(Interner), TyKind::Placeholder(_))\n-        // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n-        .then(|| {\n-            env.traits_in_scope_from_clauses(self_ty.clone())\n-                .flat_map(|t| all_super_traits(db.upcast(), t))\n-        })\n-        .into_iter()\n-        .flatten();\n-    let traits = inherent_trait.chain(env_traits).chain(traits_in_scope.iter().copied());\n \n     let canonical_self_ty = table.canonicalize(self_ty.clone()).value;\n \n-    'traits: for t in traits {\n+    'traits: for &t in traits_in_scope {\n         let data = db.trait_data(t);\n \n         // Traits annotated with `#[rustc_skip_array_during_method_dispatch]` are skipped during\n@@ -979,6 +967,44 @@ fn iterate_inherent_methods(\n ) -> ControlFlow<()> {\n     let db = table.db;\n     let env = table.trait_env.clone();\n+\n+    // For trait object types and placeholder types with trait bounds, the methods of the trait and\n+    // its super traits are considered inherent methods. This matters because these methods have\n+    // higher priority than the other traits' methods, which would be considered in\n+    // `iterate_trait_method_candidates()` only after this function.\n+    match self_ty.kind(Interner) {\n+        TyKind::Placeholder(_) => {\n+            let env = table.trait_env.clone();\n+            let traits = env\n+                .traits_in_scope_from_clauses(self_ty.clone())\n+                .flat_map(|t| all_super_traits(db.upcast(), t));\n+            iterate_inherent_trait_methods(\n+                self_ty,\n+                table,\n+                name,\n+                receiver_ty,\n+                receiver_adjustments.clone(),\n+                callback,\n+                traits,\n+            )?;\n+        }\n+        TyKind::Dyn(_) => {\n+            if let Some(principal_trait) = self_ty.dyn_trait() {\n+                let traits = all_super_traits(db.upcast(), principal_trait);\n+                iterate_inherent_trait_methods(\n+                    self_ty,\n+                    table,\n+                    name,\n+                    receiver_ty,\n+                    receiver_adjustments.clone(),\n+                    callback,\n+                    traits.into_iter(),\n+                )?;\n+            }\n+        }\n+        _ => {}\n+    }\n+\n     let def_crates = match def_crates(db, self_ty, env.krate) {\n         Some(k) => k,\n         None => return ControlFlow::Continue(()),\n@@ -1020,6 +1046,28 @@ fn iterate_inherent_methods(\n     }\n     return ControlFlow::Continue(());\n \n+    fn iterate_inherent_trait_methods(\n+        self_ty: &Ty,\n+        table: &mut InferenceTable<'_>,\n+        name: Option<&Name>,\n+        receiver_ty: Option<&Ty>,\n+        receiver_adjustments: Option<ReceiverAdjustments>,\n+        callback: &mut dyn FnMut(ReceiverAdjustments, AssocItemId) -> ControlFlow<()>,\n+        traits: impl Iterator<Item = TraitId>,\n+    ) -> ControlFlow<()> {\n+        let db = table.db;\n+        for t in traits {\n+            let data = db.trait_data(t);\n+            for &(_, item) in data.items.iter() {\n+                // We don't pass `visible_from_module` as all trait items should be visible.\n+                if is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n+                    callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n+                }\n+            }\n+        }\n+        ControlFlow::Continue(())\n+    }\n+\n     fn impls_for_self_ty(\n         impls: &InherentImpls,\n         self_ty: &Ty,"}, {"sha": "ac8edb841a580322b18b5a47b9eb39ae174b3a49", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -1218,6 +1218,40 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn dyn_trait_method_priority() {\n+    check_types(\n+        r#\"\n+//- minicore: from\n+trait Trait {\n+    fn into(&self) -> usize { 0 }\n+}\n+\n+fn foo(a: &dyn Trait) {\n+    let _ = a.into();\n+      //^usize\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_method_priority_for_placeholder_type() {\n+    check_types(\n+        r#\"\n+//- minicore: from\n+trait Trait {\n+    fn into(&self) -> usize { 0 }\n+}\n+\n+fn foo<T: Trait>(a: &T) {\n+    let _ = a.into();\n+      //^usize\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn autoderef_visibility_field() {\n     check("}, {"sha": "372c3a3cca644fd0966c88bc992c5c06087ffb03", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -1,6 +1,6 @@\n //! Trait solving using Chalk.\n \n-use std::env::var;\n+use std::{env::var, sync::Arc};\n \n use chalk_ir::GoalData;\n use chalk_recursive::Cache;\n@@ -12,8 +12,9 @@ use stdx::panic_context;\n use syntax::SmolStr;\n \n use crate::{\n-    db::HirDatabase, AliasEq, AliasTy, Canonical, DomainGoal, Goal, Guidance, InEnvironment,\n-    Interner, Solution, TraitRefExt, Ty, TyKind, WhereClause,\n+    db::HirDatabase, infer::unify::InferenceTable, AliasEq, AliasTy, Canonical, DomainGoal, Goal,\n+    Guidance, InEnvironment, Interner, ProjectionTy, Solution, TraitRefExt, Ty, TyKind,\n+    WhereClause,\n };\n \n /// This controls how much 'time' we give the Chalk solver before giving up.\n@@ -64,6 +65,16 @@ impl TraitEnvironment {\n     }\n }\n \n+pub(crate) fn normalize_projection_query(\n+    db: &dyn HirDatabase,\n+    projection: ProjectionTy,\n+    env: Arc<TraitEnvironment>,\n+) -> Ty {\n+    let mut table = InferenceTable::new(db, env);\n+    let ty = table.normalize_projection_ty(projection);\n+    table.resolve_completely(ty)\n+}\n+\n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n     db: &dyn HirDatabase,"}, {"sha": "d2717c5665471e70f7b1bbe7e0f9a01d2d193295", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -63,10 +63,9 @@ use hir_ty::{\n     primitive::UintTy,\n     subst_prefix,\n     traits::FnTrait,\n-    AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast,\n-    ClosureId, DebruijnIndex, GenericArgData, InEnvironment, Interner, ParamKind,\n-    QuantifiedWhereClause, Scalar, Solution, Substitution, TraitEnvironment, TraitRefExt, Ty,\n-    TyBuilder, TyDefId, TyExt, TyKind, TyVariableKind, WhereClause,\n+    AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n+    GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n+    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, WhereClause,\n };\n use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n@@ -582,8 +581,13 @@ impl Module {\n \n     /// Finds a path that can be used to refer to the given item from within\n     /// this module, if possible.\n-    pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>) -> Option<ModPath> {\n-        hir_def::find_path::find_path(db, item.into().into(), self.into())\n+    pub fn find_use_path(\n+        self,\n+        db: &dyn DefDatabase,\n+        item: impl Into<ItemInNs>,\n+        prefer_no_std: bool,\n+    ) -> Option<ModPath> {\n+        hir_def::find_path::find_path(db, item.into().into(), self.into(), prefer_no_std)\n     }\n \n     /// Finds a path that can be used to refer to the given item from within\n@@ -593,8 +597,15 @@ impl Module {\n         db: &dyn DefDatabase,\n         item: impl Into<ItemInNs>,\n         prefix_kind: PrefixKind,\n+        prefer_no_std: bool,\n     ) -> Option<ModPath> {\n-        hir_def::find_path::find_path_prefixed(db, item.into().into(), self.into(), prefix_kind)\n+        hir_def::find_path::find_path_prefixed(\n+            db,\n+            item.into().into(),\n+            self.into(),\n+            prefix_kind,\n+            prefer_no_std,\n+        )\n     }\n }\n \n@@ -2880,27 +2891,12 @@ impl Type {\n                 }\n             })\n             .build();\n-        let goal = hir_ty::make_canonical(\n-            InEnvironment::new(\n-                &self.env.env,\n-                AliasEq {\n-                    alias: AliasTy::Projection(projection),\n-                    ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n-                        .intern(Interner),\n-                }\n-                .cast(Interner),\n-            ),\n-            [TyVariableKind::General].into_iter(),\n-        );\n \n-        match db.trait_solve(self.env.krate, goal)? {\n-            Solution::Unique(s) => s\n-                .value\n-                .subst\n-                .as_slice(Interner)\n-                .first()\n-                .map(|ty| self.derived(ty.assert_ty_ref(Interner).clone())),\n-            Solution::Ambig(_) => None,\n+        let ty = db.normalize_projection(projection, self.env.clone());\n+        if ty.is_unknown() {\n+            None\n+        } else {\n+            Some(self.derived(ty))\n         }\n     }\n "}, {"sha": "60d1588a44e54dba41e753f2511ffd879ac64f73", "filename": "crates/ide-assists/src/assist_config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fassist_config.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -13,4 +13,5 @@ pub struct AssistConfig {\n     pub snippet_cap: Option<SnippetCap>,\n     pub allowed: Option<Vec<AssistKind>>,\n     pub insert_use: InsertUseConfig,\n+    pub prefer_no_std: bool,\n }"}, {"sha": "73f4db4e5ff2ba065a20ee39c7aa368ff91f754e", "filename": "crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -87,7 +87,7 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n             .into_iter()\n             .filter_map(|variant| {\n                 Some((\n-                    build_pat(ctx.db(), module, variant)?,\n+                    build_pat(ctx.db(), module, variant, ctx.config.prefer_no_std)?,\n                     variant.should_be_hidden(ctx.db(), module.krate()),\n                 ))\n             })\n@@ -132,8 +132,9 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n                 let is_hidden = variants\n                     .iter()\n                     .any(|variant| variant.should_be_hidden(ctx.db(), module.krate()));\n-                let patterns =\n-                    variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n+                let patterns = variants.into_iter().filter_map(|variant| {\n+                    build_pat(ctx.db(), module, variant, ctx.config.prefer_no_std)\n+                });\n \n                 (ast::Pat::from(make::tuple_pat(patterns)), is_hidden)\n             })\n@@ -349,10 +350,16 @@ fn resolve_tuple_of_enum_def(\n         .collect()\n }\n \n-fn build_pat(db: &RootDatabase, module: hir::Module, var: ExtendedVariant) -> Option<ast::Pat> {\n+fn build_pat(\n+    db: &RootDatabase,\n+    module: hir::Module,\n+    var: ExtendedVariant,\n+    prefer_no_std: bool,\n+) -> Option<ast::Pat> {\n     match var {\n         ExtendedVariant::Variant(var) => {\n-            let path = mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var))?);\n+            let path =\n+                mod_path_to_ast(&module.find_use_path(db, ModuleDef::from(var), prefer_no_std)?);\n \n             // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n             let pat: ast::Pat = match var.source(db)?.value.kind() {"}, {"sha": "e257218ba937686275d3c8f78f998d0f49e4d073", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -89,8 +89,11 @@ use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n // ```\n pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n-    let mut proposed_imports =\n-        import_assets.search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind);\n+    let mut proposed_imports = import_assets.search_for_imports(\n+        &ctx.sema,\n+        ctx.config.insert_use.prefix_kind,\n+        ctx.config.prefer_no_std,\n+    );\n     if proposed_imports.is_empty() {\n         return None;\n     }"}, {"sha": "95d11abe8bc0f6fea075297b0c1473e81ec7a77b", "filename": "crates/ide-assists/src/handlers/convert_into_to_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -50,7 +50,7 @@ pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext<'_>) -\n             _ => return None,\n         };\n \n-        mod_path_to_ast(&module.find_use_path(ctx.db(), src_type_def)?)\n+        mod_path_to_ast(&module.find_use_path(ctx.db(), src_type_def, ctx.config.prefer_no_std)?)\n     };\n \n     let dest_type = match &ast_trait {"}, {"sha": "d6c8ea785f84aa87f1b2904e06ddcdab103eafc1", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -152,6 +152,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                         ctx.sema.db,\n                         ModuleDef::from(control_flow_enum),\n                         ctx.config.insert_use.prefix_kind,\n+                        ctx.config.prefer_no_std,\n                     );\n \n                     if let Some(mod_path) = mod_path {"}, {"sha": "8d5cab283d0616d3297e864a782f61e4965975cd", "filename": "crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -409,6 +409,7 @@ fn process_references(\n                     ctx.sema.db,\n                     *enum_module_def,\n                     ctx.config.insert_use.prefix_kind,\n+                    ctx.config.prefer_no_std,\n                 );\n                 if let Some(mut mod_path) = mod_path {\n                     mod_path.pop_segment();"}, {"sha": "8f4405a8c869cf9273e481775f98bff95e63a24b", "filename": "crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -58,7 +58,8 @@ fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n \n     let module = ctx.sema.to_def(&strukt)?.module(ctx.db());\n     let trait_ = deref_type_to_generate.to_trait(&ctx.sema, module.krate())?;\n-    let trait_path = module.find_use_path(ctx.db(), ModuleDef::Trait(trait_))?;\n+    let trait_path =\n+        module.find_use_path(ctx.db(), ModuleDef::Trait(trait_), ctx.config.prefer_no_std)?;\n \n     let field_type = field.ty()?;\n     let field_name = field.name()?;\n@@ -98,7 +99,8 @@ fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()\n \n     let module = ctx.sema.to_def(&strukt)?.module(ctx.db());\n     let trait_ = deref_type_to_generate.to_trait(&ctx.sema, module.krate())?;\n-    let trait_path = module.find_use_path(ctx.db(), ModuleDef::Trait(trait_))?;\n+    let trait_path =\n+        module.find_use_path(ctx.db(), ModuleDef::Trait(trait_), ctx.config.prefer_no_std)?;\n \n     let field_type = field.ty()?;\n     let target = field.syntax().text_range();"}, {"sha": "9cda74d9e0d31e4c41c65ed99b396d1cec982545", "filename": "crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -60,8 +60,11 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n \n                 let item_in_ns = hir::ItemInNs::from(hir::ModuleDef::from(ty.as_adt()?));\n \n-                let type_path = current_module\n-                    .find_use_path(ctx.sema.db, item_for_path_search(ctx.sema.db, item_in_ns)?)?;\n+                let type_path = current_module.find_use_path(\n+                    ctx.sema.db,\n+                    item_for_path_search(ctx.sema.db, item_in_ns)?,\n+                    ctx.config.prefer_no_std,\n+                )?;\n \n                 let expr = use_trivial_constructor(\n                     &ctx.sema.db,"}, {"sha": "92b2fa79d717bda9deeecb4811de419160c89b55", "filename": "crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -0,0 +1,268 @@\n+use crate::{AssistContext, Assists};\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    syntax_helpers::{\n+        format_string::is_format_string,\n+        format_string_exprs::{parse_format_exprs, Arg},\n+    },\n+};\n+use itertools::Itertools;\n+use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n+\n+// Assist: move_format_string_arg\n+//\n+// Move an expression out of a format string.\n+//\n+// ```\n+// macro_rules! format_args {\n+//     ($lit:literal $(tt:tt)*) => { 0 },\n+// }\n+// macro_rules! print {\n+//     ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+// }\n+//\n+// fn main() {\n+//     print!(\"{x + 1}$0\");\n+// }\n+// ```\n+// ->\n+// ```\n+// macro_rules! format_args {\n+//     ($lit:literal $(tt:tt)*) => { 0 },\n+// }\n+// macro_rules! print {\n+//     ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+// }\n+//\n+// fn main() {\n+//     print!(\"{}\"$0, x + 1);\n+// }\n+// ```\n+\n+pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let fmt_string = ctx.find_token_at_offset::<ast::String>()?;\n+    let tt = fmt_string.syntax().parent().and_then(ast::TokenTree::cast)?;\n+\n+    let expanded_t = ast::String::cast(\n+        ctx.sema.descend_into_macros_with_kind_preference(fmt_string.syntax().clone()),\n+    )?;\n+    if !is_format_string(&expanded_t) {\n+        return None;\n+    }\n+\n+    let (new_fmt, extracted_args) = parse_format_exprs(fmt_string.text()).ok()?;\n+    if extracted_args.is_empty() {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\n+            \"move_format_string_arg\",\n+            // if there aren't any expressions, then make the assist a RefactorExtract\n+            if extracted_args.iter().filter(|f| matches!(f, Arg::Expr(_))).count() == 0 {\n+                AssistKind::RefactorExtract\n+            } else {\n+                AssistKind::QuickFix\n+            },\n+        ),\n+        \"Extract format args\",\n+        tt.syntax().text_range(),\n+        |edit| {\n+            let fmt_range = fmt_string.syntax().text_range();\n+\n+            // Replace old format string with new format string whose arguments have been extracted\n+            edit.replace(fmt_range, new_fmt);\n+\n+            // Insert cursor at end of format string\n+            edit.insert(fmt_range.end(), \"$0\");\n+\n+            // Extract existing arguments in macro\n+            let tokens =\n+                tt.token_trees_and_tokens().filter_map(NodeOrToken::into_token).collect_vec();\n+\n+            let mut existing_args: Vec<String> = vec![];\n+\n+            let mut current_arg = String::new();\n+            if let [_opening_bracket, format_string, _args_start_comma, tokens @ .., end_bracket] =\n+                tokens.as_slice()\n+            {\n+                for t in tokens {\n+                    if t.kind() == COMMA {\n+                        existing_args.push(current_arg.trim().into());\n+                        current_arg.clear();\n+                    } else {\n+                        current_arg.push_str(t.text());\n+                    }\n+                }\n+                existing_args.push(current_arg.trim().into());\n+\n+                // delete everything after the format string till end bracket\n+                // we're going to insert the new arguments later\n+                edit.delete(TextRange::new(\n+                    format_string.text_range().end(),\n+                    end_bracket.text_range().start(),\n+                ));\n+            }\n+\n+            // Start building the new args\n+            let mut existing_args = existing_args.into_iter();\n+            let mut args = String::new();\n+\n+            let mut placeholder_idx = 1;\n+\n+            for extracted_args in extracted_args {\n+                // remove expr from format string\n+                args.push_str(\", \");\n+\n+                match extracted_args {\n+                    Arg::Ident(s) | Arg::Expr(s) => {\n+                        // insert arg\n+                        args.push_str(&s);\n+                    }\n+                    Arg::Placeholder => {\n+                        // try matching with existing argument\n+                        match existing_args.next() {\n+                            Some(ea) => {\n+                                args.push_str(&ea);\n+                            }\n+                            None => {\n+                                // insert placeholder\n+                                args.push_str(&format!(\"${placeholder_idx}\"));\n+                                placeholder_idx += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Insert new args\n+            edit.insert(fmt_range.end(), args);\n+        },\n+    );\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::tests::check_assist;\n+\n+    const MACRO_DECL: &'static str = r#\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\"#;\n+\n+    fn add_macro_decl(s: &'static str) -> String {\n+        MACRO_DECL.to_string() + s\n+    }\n+\n+    #[test]\n+    fn multiple_middle_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {}$0\", y + 2, 2);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, y + 2, x + 1, 2);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn single_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{obj.value:b}$0\",);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{:b}\"$0, obj.value);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_middle_placeholders_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {} {}$0\", y + 2, 2);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {} {}\"$0, y + 2, x + 1, 2, $1);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_trailing_args() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn improper_commas() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1,);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+}"}, {"sha": "e57d1d065d6229361ca68604e8ace6c8b9331c1d", "filename": "crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -44,8 +44,11 @@ pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n     let current_module = ctx.sema.scope(call.syntax())?.module();\n     let target_module_def = ModuleDef::from(resolved_call);\n     let item_in_ns = ItemInNs::from(target_module_def);\n-    let receiver_path = current_module\n-        .find_use_path(ctx.sema.db, item_for_path_search(ctx.sema.db, item_in_ns)?)?;\n+    let receiver_path = current_module.find_use_path(\n+        ctx.sema.db,\n+        item_for_path_search(ctx.sema.db, item_in_ns)?,\n+        ctx.config.prefer_no_std,\n+    )?;\n \n     let qualify_candidate = QualifyCandidate::ImplMethod(ctx.sema.db, call, resolved_call);\n "}, {"sha": "4b2af550bc5e4902c15bdf4a158ba6ee0bef6326", "filename": "crates/ide-assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -37,7 +37,8 @@ use crate::{\n // ```\n pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (import_assets, syntax_under_caret) = find_importable_node(ctx)?;\n-    let mut proposed_imports = import_assets.search_for_relative_paths(&ctx.sema);\n+    let mut proposed_imports =\n+        import_assets.search_for_relative_paths(&ctx.sema, ctx.config.prefer_no_std);\n     if proposed_imports.is_empty() {\n         return None;\n     }"}, {"sha": "9fd5e1886d206ef3dad043c6e29f2a4eb88b1219", "filename": "crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -85,7 +85,7 @@ pub(crate) fn replace_derive_with_manual_impl(\n     })\n     .flat_map(|trait_| {\n         current_module\n-            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n+            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_), ctx.config.prefer_no_std)\n             .as_ref()\n             .map(mod_path_to_ast)\n             .zip(Some(trait_))"}, {"sha": "dbbc56958f1e2ede4419e6887073c662bdc9f40e", "filename": "crates/ide-assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -67,6 +67,7 @@ pub(crate) fn replace_qualified_name_with_use(\n                 ctx.sema.db,\n                 module,\n                 ctx.config.insert_use.prefix_kind,\n+                ctx.config.prefer_no_std,\n             )\n         })\n         .flatten();"}, {"sha": "812d22efbd797c42bc533d20c9a477207481aad6", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -136,6 +136,7 @@ mod handlers {\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n+    mod move_format_string_arg;\n     mod generate_constant;\n     mod generate_default_from_enum_variant;\n     mod generate_default_from_new;\n@@ -254,6 +255,7 @@ mod handlers {\n             merge_imports::merge_imports,\n             merge_match_arms::merge_match_arms,\n             move_bounds::move_bounds_to_where_clause,\n+            move_format_string_arg::move_format_string_arg,\n             move_guard::move_arm_cond_to_match_guard,\n             move_guard::move_guard_to_arm_body,\n             move_module_to_file::move_module_to_file,"}, {"sha": "258144bae3d08dfad368fa824804d9c4f3128674", "filename": "crates/ide-assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -29,6 +29,7 @@ pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {\n         group: true,\n         skip_glob_imports: true,\n     },\n+    prefer_no_std: false,\n };\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {"}, {"sha": "3a696635afd275c8830781e30259f5944f71f2d1", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -1591,6 +1591,37 @@ fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n     )\n }\n \n+#[test]\n+fn doctest_move_format_string_arg() {\n+    check_doc_test(\n+        \"move_format_string_arg\",\n+        r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n+fn main() {\n+    print!(\"{x + 1}$0\");\n+}\n+\"#####,\n+        r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n+fn main() {\n+    print!(\"{}\"$0, x + 1);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_move_from_mod_rs() {\n     check_doc_test("}, {"sha": "97b90c62dd7775b1073181148bb6ae5ea27826c9", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -551,7 +551,11 @@ fn enum_variants_with_paths(\n     }\n \n     for variant in variants {\n-        if let Some(path) = ctx.module.find_use_path(ctx.db, hir::ModuleDef::from(variant)) {\n+        if let Some(path) = ctx.module.find_use_path(\n+            ctx.db,\n+            hir::ModuleDef::from(variant),\n+            ctx.config.prefer_no_std,\n+        ) {\n             // Variants with trivial paths are already added by the existing completion logic,\n             // so we should avoid adding these twice\n             if path.segments().len() > 1 {"}, {"sha": "3192b21cfb2e2da3ae3bd49b5e560c561fa58fd1", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -165,7 +165,11 @@ pub(crate) fn complete_expr_path(\n                     hir::Adt::Struct(strukt) => {\n                         let path = ctx\n                             .module\n-                            .find_use_path(ctx.db, hir::ModuleDef::from(strukt))\n+                            .find_use_path(\n+                                ctx.db,\n+                                hir::ModuleDef::from(strukt),\n+                                ctx.config.prefer_no_std,\n+                            )\n                             .filter(|it| it.len() > 1);\n \n                         acc.add_struct_literal(ctx, path_ctx, strukt, path, None);\n@@ -183,7 +187,11 @@ pub(crate) fn complete_expr_path(\n                     hir::Adt::Union(un) => {\n                         let path = ctx\n                             .module\n-                            .find_use_path(ctx.db, hir::ModuleDef::from(un))\n+                            .find_use_path(\n+                                ctx.db,\n+                                hir::ModuleDef::from(un),\n+                                ctx.config.prefer_no_std,\n+                            )\n                             .filter(|it| it.len() > 1);\n \n                         acc.add_union_literal(ctx, un, path, None);"}, {"sha": "364969af9c9abc8aa6721d9ccbdfa1f515915251", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -262,7 +262,11 @@ fn import_on_the_fly(\n \n     acc.add_all(\n         import_assets\n-            .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+            .search_for_imports(\n+                &ctx.sema,\n+                ctx.config.insert_use.prefix_kind,\n+                ctx.config.prefer_no_std,\n+            )\n             .into_iter()\n             .filter(ns_filter)\n             .filter(|import| {\n@@ -306,7 +310,11 @@ fn import_on_the_fly_pat_(\n \n     acc.add_all(\n         import_assets\n-            .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+            .search_for_imports(\n+                &ctx.sema,\n+                ctx.config.insert_use.prefix_kind,\n+                ctx.config.prefer_no_std,\n+            )\n             .into_iter()\n             .filter(ns_filter)\n             .filter(|import| {\n@@ -344,7 +352,7 @@ fn import_on_the_fly_method(\n     let user_input_lowercased = potential_import_name.to_lowercase();\n \n     import_assets\n-        .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+        .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind, ctx.config.prefer_no_std)\n         .into_iter()\n         .filter(|import| {\n             !ctx.is_item_hidden(&import.item_to_import)"}, {"sha": "58d5bf114cca4abfbee7ae0f200c92e9c1780a0a", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -145,6 +145,7 @@ pub(crate) fn complete_pattern_path(\n                             u.ty(ctx.db)\n                         }\n                         hir::PathResolution::Def(hir::ModuleDef::BuiltinType(ty)) => ty.ty(ctx.db),\n+                        hir::PathResolution::Def(hir::ModuleDef::TypeAlias(ty)) => ty.ty(ctx.db),\n                         _ => return,\n                     };\n "}, {"sha": "b43bdb9ab9d1a5b861b148195bfdee890c56192e", "filename": "crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 12, "deletions": 235, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -16,8 +16,11 @@\n //\n // image::https://user-images.githubusercontent.com/48062697/113020656-b560f500-917a-11eb-87de-02991f61beb8.gif[]\n \n-use ide_db::SnippetCap;\n-use syntax::ast::{self, AstToken};\n+use ide_db::{\n+    syntax_helpers::format_string_exprs::{parse_format_exprs, with_placeholders},\n+    SnippetCap,\n+};\n+use syntax::{ast, AstToken};\n \n use crate::{\n     completions::postfix::build_postfix_snippet_builder, context::CompletionContext, Completions,\n@@ -43,250 +46,24 @@ pub(crate) fn add_format_like_completions(\n     cap: SnippetCap,\n     receiver_text: &ast::String,\n ) {\n-    let input = match string_literal_contents(receiver_text) {\n-        // It's not a string literal, do not parse input.\n-        Some(input) => input,\n-        None => return,\n-    };\n-\n     let postfix_snippet = match build_postfix_snippet_builder(ctx, cap, dot_receiver) {\n         Some(it) => it,\n         None => return,\n     };\n-    let mut parser = FormatStrParser::new(input);\n \n-    if parser.parse().is_ok() {\n+    if let Ok((out, exprs)) = parse_format_exprs(receiver_text.text()) {\n+        let exprs = with_placeholders(exprs);\n         for (label, macro_name) in KINDS {\n-            let snippet = parser.to_suggestion(macro_name);\n+            let snippet = format!(r#\"{}({}, {})\"#, macro_name, out, exprs.join(\", \"));\n \n             postfix_snippet(label, macro_name, &snippet).add_to(acc);\n         }\n     }\n }\n \n-/// Checks whether provided item is a string literal.\n-fn string_literal_contents(item: &ast::String) -> Option<String> {\n-    let item = item.text();\n-    if item.len() >= 2 && item.starts_with('\\\"') && item.ends_with('\\\"') {\n-        return Some(item[1..item.len() - 1].to_owned());\n-    }\n-\n-    None\n-}\n-\n-/// Parser for a format-like string. It is more allowing in terms of string contents,\n-/// as we expect variable placeholders to be filled with expressions.\n-#[derive(Debug)]\n-pub(crate) struct FormatStrParser {\n-    input: String,\n-    output: String,\n-    extracted_expressions: Vec<String>,\n-    state: State,\n-    parsed: bool,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum State {\n-    NotExpr,\n-    MaybeExpr,\n-    Expr,\n-    MaybeIncorrect,\n-    FormatOpts,\n-}\n-\n-impl FormatStrParser {\n-    pub(crate) fn new(input: String) -> Self {\n-        Self {\n-            input,\n-            output: String::new(),\n-            extracted_expressions: Vec::new(),\n-            state: State::NotExpr,\n-            parsed: false,\n-        }\n-    }\n-\n-    pub(crate) fn parse(&mut self) -> Result<(), ()> {\n-        let mut current_expr = String::new();\n-\n-        let mut placeholder_id = 1;\n-\n-        // Count of open braces inside of an expression.\n-        // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n-        // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n-        let mut inexpr_open_count = 0;\n-\n-        // We need to escape '\\' and '$'. See the comments on `get_receiver_text()` for detail.\n-        let mut chars = self.input.chars().peekable();\n-        while let Some(chr) = chars.next() {\n-            match (self.state, chr) {\n-                (State::NotExpr, '{') => {\n-                    self.output.push(chr);\n-                    self.state = State::MaybeExpr;\n-                }\n-                (State::NotExpr, '}') => {\n-                    self.output.push(chr);\n-                    self.state = State::MaybeIncorrect;\n-                }\n-                (State::NotExpr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        self.output.push('\\\\');\n-                    }\n-                    self.output.push(chr);\n-                }\n-                (State::MaybeIncorrect, '}') => {\n-                    // It's okay, we met \"}}\".\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeIncorrect, _) => {\n-                    // Error in the string.\n-                    return Err(());\n-                }\n-                (State::MaybeExpr, '{') => {\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeExpr, '}') => {\n-                    // This is an empty sequence '{}'. Replace it with placeholder.\n-                    self.output.push(chr);\n-                    self.extracted_expressions.push(format!(\"${}\", placeholder_id));\n-                    placeholder_id += 1;\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeExpr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        current_expr.push('\\\\');\n-                    }\n-                    current_expr.push(chr);\n-                    self.state = State::Expr;\n-                }\n-                (State::Expr, '}') => {\n-                    if inexpr_open_count == 0 {\n-                        self.output.push(chr);\n-                        self.extracted_expressions.push(current_expr.trim().into());\n-                        current_expr = String::new();\n-                        self.state = State::NotExpr;\n-                    } else {\n-                        // We're closing one brace met before inside of the expression.\n-                        current_expr.push(chr);\n-                        inexpr_open_count -= 1;\n-                    }\n-                }\n-                (State::Expr, ':') if chars.peek().copied() == Some(':') => {\n-                    // path separator\n-                    current_expr.push_str(\"::\");\n-                    chars.next();\n-                }\n-                (State::Expr, ':') => {\n-                    if inexpr_open_count == 0 {\n-                        // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n-                        self.output.push(chr);\n-                        self.extracted_expressions.push(current_expr.trim().into());\n-                        current_expr = String::new();\n-                        self.state = State::FormatOpts;\n-                    } else {\n-                        // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n-                        current_expr.push(chr);\n-                    }\n-                }\n-                (State::Expr, '{') => {\n-                    current_expr.push(chr);\n-                    inexpr_open_count += 1;\n-                }\n-                (State::Expr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        current_expr.push('\\\\');\n-                    }\n-                    current_expr.push(chr);\n-                }\n-                (State::FormatOpts, '}') => {\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::FormatOpts, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        self.output.push('\\\\');\n-                    }\n-                    self.output.push(chr);\n-                }\n-            }\n-        }\n-\n-        if self.state != State::NotExpr {\n-            return Err(());\n-        }\n-\n-        self.parsed = true;\n-        Ok(())\n-    }\n-\n-    pub(crate) fn to_suggestion(&self, macro_name: &str) -> String {\n-        assert!(self.parsed, \"Attempt to get a suggestion from not parsed expression\");\n-\n-        let expressions_as_string = self.extracted_expressions.join(\", \");\n-        format!(r#\"{}(\"{}\", {})\"#, macro_name, self.output, expressions_as_string)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use expect_test::{expect, Expect};\n-\n-    fn check(input: &str, expect: &Expect) {\n-        let mut parser = FormatStrParser::new((*input).to_owned());\n-        let outcome_repr = if parser.parse().is_ok() {\n-            // Parsing should be OK, expected repr is \"string; expr_1, expr_2\".\n-            if parser.extracted_expressions.is_empty() {\n-                parser.output\n-            } else {\n-                format!(\"{}; {}\", parser.output, parser.extracted_expressions.join(\", \"))\n-            }\n-        } else {\n-            // Parsing should fail, expected repr is \"-\".\n-            \"-\".to_owned()\n-        };\n-\n-        expect.assert_eq(&outcome_repr);\n-    }\n-\n-    #[test]\n-    fn format_str_parser() {\n-        let test_vector = &[\n-            (\"no expressions\", expect![[\"no expressions\"]]),\n-            (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n-            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n-            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n-            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n-            (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n-            (\"{malformed\", expect![[\"-\"]]),\n-            (\"malformed}\", expect![[\"-\"]]),\n-            (\"{{correct\", expect![[\"{{correct\"]]),\n-            (\"correct}}\", expect![[\"correct}}\"]]),\n-            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n-            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n-            (\"{incorrect}}\", expect![[\"-\"]]),\n-            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n-            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n-            (\n-                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n-                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n-            ),\n-            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n-            (\n-                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n-                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n-            ),\n-            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n-            (\"{strsim::jaro_winkle(a)}\", expect![[\"{}; strsim::jaro_winkle(a)\"]]),\n-            (\"{foo::bar::baz()}\", expect![[\"{}; foo::bar::baz()\"]]),\n-            (\"{foo::bar():?}\", expect![[\"{:?}; foo::bar()\"]]),\n-        ];\n-\n-        for (input, output) in test_vector {\n-            check(input, output)\n-        }\n-    }\n \n     #[test]\n     fn test_into_suggestion() {\n@@ -302,10 +79,10 @@ mod tests {\n         ];\n \n         for (kind, input, output) in test_vector {\n-            let mut parser = FormatStrParser::new((*input).to_owned());\n-            parser.parse().expect(\"Parsing must succeed\");\n-\n-            assert_eq!(&parser.to_suggestion(*kind), output);\n+            let (parsed_string, exprs) = parse_format_exprs(input).unwrap();\n+            let exprs = with_placeholders(exprs);\n+            let snippet = format!(r#\"{}(\"{}\", {})\"#, kind, parsed_string, exprs.join(\", \"));\n+            assert_eq!(&snippet, output);\n         }\n     }\n }"}, {"sha": "a0f5e81b4fb6c3396efd9d1ec7093e6402f43e85", "filename": "crates/ide-completion/src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fconfig.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -17,6 +17,7 @@ pub struct CompletionConfig {\n     pub callable: Option<CallableSnippets>,\n     pub snippet_cap: Option<SnippetCap>,\n     pub insert_use: InsertUseConfig,\n+    pub prefer_no_std: bool,\n     pub snippets: Vec<Snippet>,\n }\n "}, {"sha": "8d21f4fce0a2b324a3fc112c23ac2faef9560afa", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -234,7 +234,12 @@ pub fn resolve_completion_edits(\n         );\n         let import = items_with_name\n             .filter_map(|candidate| {\n-                current_module.find_use_path_prefixed(db, candidate, config.insert_use.prefix_kind)\n+                current_module.find_use_path_prefixed(\n+                    db,\n+                    candidate,\n+                    config.insert_use.prefix_kind,\n+                    config.prefer_no_std,\n+                )\n             })\n             .find(|mod_path| mod_path.to_string() == full_import_path);\n         if let Some(import_path) = import {"}, {"sha": "f3b8eae4fe8cd8c25fff08afa889326e37da642e", "filename": "crates/ide-completion/src/snippet.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fsnippet.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -174,8 +174,12 @@ fn import_edits(ctx: &CompletionContext<'_>, requires: &[GreenNode]) -> Option<V\n             hir::PathResolution::Def(def) => def.into(),\n             _ => return None,\n         };\n-        let path =\n-            ctx.module.find_use_path_prefixed(ctx.db, item, ctx.config.insert_use.prefix_kind)?;\n+        let path = ctx.module.find_use_path_prefixed(\n+            ctx.db,\n+            item,\n+            ctx.config.insert_use.prefix_kind,\n+            ctx.config.prefer_no_std,\n+        )?;\n         Some((path.len() > 1).then(|| LocatedImport::new(path.clone(), item, item, None)))\n     };\n     let mut res = Vec::with_capacity(requires.len());"}, {"sha": "9e2beb9ee328862289fd507f504a4e79767ec903", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -66,6 +66,7 @@ pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n     enable_private_editable: false,\n     callable: Some(CallableSnippets::FillArguments),\n     snippet_cap: SnippetCap::new(true),\n+    prefer_no_std: false,\n     insert_use: InsertUseConfig {\n         granularity: ImportGranularity::Crate,\n         prefix_kind: PrefixKind::Plain,"}, {"sha": "db8bef66405efb3e55e564c55385edfe9dc7b823", "filename": "crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -714,3 +714,30 @@ impl Ty {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn through_alias() {\n+    check_empty(\n+        r#\"\n+enum Enum<T> {\n+    Unit,\n+    Tuple(T),\n+}\n+\n+type EnumAlias<T> = Enum<T>;\n+\n+fn f(x: EnumAlias<u8>) {\n+    match x {\n+        EnumAlias::$0 => (),\n+        _ => (),\n+    }\n+\n+}\n+\n+\"#,\n+        expect![[r#\"\n+            bn Tuple(\u2026) Tuple($1)$0\n+            bn Unit     Unit$0\n+        \"#]],\n+    );\n+}"}, {"sha": "30272bc16f636754489c6838c64448ac48f8283a", "filename": "crates/ide-db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2FCargo.toml?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -20,6 +20,7 @@ either = \"1.7.0\"\n itertools = \"0.10.3\"\n arrayvec = \"0.7.2\"\n indexmap = \"1.9.1\"\n+memchr = \"2.5.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }"}, {"sha": "40a6a3e8970fb770428c092b901ad23bc1bf7536", "filename": "crates/ide-db/src/imports/import_assets.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -212,18 +212,20 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n         prefix_kind: PrefixKind,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_imports\");\n-        self.search_for(sema, Some(prefix_kind))\n+        self.search_for(sema, Some(prefix_kind), prefer_no_std)\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n     pub fn search_for_relative_paths(\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_relative_paths\");\n-        self.search_for(sema, None)\n+        self.search_for(sema, None, prefer_no_std)\n     }\n \n     pub fn path_fuzzy_name_to_exact(&mut self, case_sensitive: bool) {\n@@ -242,6 +244,7 @@ impl ImportAssets {\n         &self,\n         sema: &Semantics<'_, RootDatabase>,\n         prefixed: Option<PrefixKind>,\n+        prefer_no_std: bool,\n     ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for\");\n \n@@ -252,6 +255,7 @@ impl ImportAssets {\n                 item_for_path_search(sema.db, item)?,\n                 &self.module_with_candidate,\n                 prefixed,\n+                prefer_no_std,\n             )\n         };\n \n@@ -564,11 +568,12 @@ fn get_mod_path(\n     item_to_search: ItemInNs,\n     module_with_candidate: &Module,\n     prefixed: Option<PrefixKind>,\n+    prefer_no_std: bool,\n ) -> Option<ModPath> {\n     if let Some(prefix_kind) = prefixed {\n-        module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind)\n+        module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind, prefer_no_std)\n     } else {\n-        module_with_candidate.find_use_path(db, item_to_search)\n+        module_with_candidate.find_use_path(db, item_to_search, prefer_no_std)\n     }\n }\n "}, {"sha": "e0bc0f89f0a1d14bdd54d384802ae8587311e41d", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -38,6 +38,7 @@ pub mod syntax_helpers {\n     pub mod node_ext;\n     pub mod insert_whitespace_into_node;\n     pub mod format_string;\n+    pub mod format_string_exprs;\n \n     pub use parser::LexedStr;\n }"}, {"sha": "12d873b4a0aa8be0c067f697cb7823375e7ce625", "filename": "crates/ide-db/src/path_transform.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fpath_transform.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -173,6 +173,7 @@ impl<'a> Ctx<'a> {\n                             let found_path = self.target_module.find_use_path(\n                                 self.source_scope.db.upcast(),\n                                 hir::ModuleDef::Trait(trait_ref),\n+                                false,\n                             )?;\n                             match ast::make::ty_path(mod_path_to_ast(&found_path)) {\n                                 ast::Type::PathType(path_ty) => Some(path_ty),\n@@ -209,7 +210,7 @@ impl<'a> Ctx<'a> {\n                 }\n \n                 let found_path =\n-                    self.target_module.find_use_path(self.source_scope.db.upcast(), def)?;\n+                    self.target_module.find_use_path(self.source_scope.db.upcast(), def, false)?;\n                 let res = mod_path_to_ast(&found_path).clone_for_update();\n                 if let Some(args) = path.segment().and_then(|it| it.generic_arg_list()) {\n                     if let Some(segment) = res.segment() {"}, {"sha": "7cabdb55e8d284100a4a272f0888029340742bcb", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -8,7 +8,9 @@ use std::{mem, sync::Arc};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n+use memchr::memmem::Finder;\n use once_cell::unsync::Lazy;\n+use parser::SyntaxKind;\n use stdx::hash::NoHashHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n@@ -67,6 +69,7 @@ pub enum ReferenceCategory {\n     // Create\n     Write,\n     Read,\n+    Import,\n     // FIXME: Some day should be able to search in doc comments. Would probably\n     // need to switch from enum to bitflags then?\n     // DocComment\n@@ -409,14 +412,17 @@ impl<'a> FindUsages<'a> {\n             Some(s) => s.as_str(),\n             None => return,\n         };\n+        let finder = &Finder::new(name);\n+        let include_self_kw_refs =\n+            self.include_self_kw_refs.as_ref().map(|ty| (ty, Finder::new(\"Self\")));\n \n-        // these can't be closures because rust infers the lifetimes wrong ...\n+        // for<'a> |text: &'a str, name: &'a str, search_range: TextRange| -> impl Iterator<Item = TextSize> + 'a { ... }\n         fn match_indices<'a>(\n             text: &'a str,\n-            name: &'a str,\n+            finder: &'a Finder<'a>,\n             search_range: TextRange,\n         ) -> impl Iterator<Item = TextSize> + 'a {\n-            text.match_indices(name).filter_map(move |(idx, _)| {\n+            finder.find_iter(text.as_bytes()).filter_map(move |idx| {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n                     return None;\n@@ -425,6 +431,7 @@ impl<'a> FindUsages<'a> {\n             })\n         }\n \n+        // for<'a> |scope: &'a SearchScope| -> impl Iterator<Item = (Arc<String>, FileId, TextRange)> + 'a { ... }\n         fn scope_files<'a>(\n             sema: &'a Semantics<'_, RootDatabase>,\n             scope: &'a SearchScope,\n@@ -448,7 +455,7 @@ impl<'a> FindUsages<'a> {\n             let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n             // Search for occurrences of the items name\n-            for offset in match_indices(&text, name, search_range) {\n+            for offset in match_indices(&text, finder, search_range) {\n                 for name in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                     if match name {\n                         ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n@@ -460,8 +467,8 @@ impl<'a> FindUsages<'a> {\n                 }\n             }\n             // Search for occurrences of the `Self` referring to our type\n-            if let Some(self_ty) = &self.include_self_kw_refs {\n-                for offset in match_indices(&text, \"Self\", search_range) {\n+            if let Some((self_ty, finder)) = &include_self_kw_refs {\n+                for offset in match_indices(&text, finder, search_range) {\n                     for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                         if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n                             return;\n@@ -477,20 +484,22 @@ impl<'a> FindUsages<'a> {\n                 let scope = search_scope\n                     .intersection(&SearchScope::module_and_children(self.sema.db, module));\n \n-                let is_crate_root = module.is_crate_root(self.sema.db);\n+                let is_crate_root =\n+                    module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n+                let finder = &Finder::new(\"super\");\n \n                 for (text, file_id, search_range) in scope_files(sema, &scope) {\n                     let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n-                    for offset in match_indices(&text, \"super\", search_range) {\n+                    for offset in match_indices(&text, finder, search_range) {\n                         for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                             if self.found_name_ref(&name_ref, sink) {\n                                 return;\n                             }\n                         }\n                     }\n-                    if is_crate_root {\n-                        for offset in match_indices(&text, \"crate\", search_range) {\n+                    if let Some(finder) = &is_crate_root {\n+                        for offset in match_indices(&text, finder, search_range) {\n                             for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                                 if self.found_name_ref(&name_ref, sink) {\n                                     return;\n@@ -531,8 +540,9 @@ impl<'a> FindUsages<'a> {\n                     search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(text.as_str())));\n \n                 let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n+                let finder = &Finder::new(\"self\");\n \n-                for offset in match_indices(&text, \"self\", search_range) {\n+                for offset in match_indices(&text, finder, search_range) {\n                     for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                         if self.found_self_module_name_ref(&name_ref, sink) {\n                             return;\n@@ -577,7 +587,7 @@ impl<'a> FindUsages<'a> {\n                 let reference = FileReference {\n                     range,\n                     name: ast::NameLike::NameRef(name_ref.clone()),\n-                    category: None,\n+                    category: is_name_ref_in_import(name_ref).then(|| ReferenceCategory::Import),\n                 };\n                 sink(file_id, reference)\n             }\n@@ -756,7 +766,7 @@ impl ReferenceCategory {\n     fn new(def: &Definition, r: &ast::NameRef) -> Option<ReferenceCategory> {\n         // Only Locals and Fields have accesses for now.\n         if !matches!(def, Definition::Local(_) | Definition::Field(_)) {\n-            return None;\n+            return is_name_ref_in_import(r).then(|| ReferenceCategory::Import);\n         }\n \n         let mode = r.syntax().ancestors().find_map(|node| {\n@@ -783,3 +793,12 @@ impl ReferenceCategory {\n         mode.or(Some(ReferenceCategory::Read))\n     }\n }\n+\n+fn is_name_ref_in_import(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .parent()\n+        .and_then(ast::PathSegment::cast)\n+        .and_then(|it| it.parent_path().top_path().syntax().parent())\n+        .map_or(false, |it| it.kind() == SyntaxKind::USE_TREE)\n+}"}, {"sha": "ac6c6e8feeea01e1b2ef90cc2c664fd0b1bb76fe", "filename": "crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -0,0 +1,267 @@\n+//! Tools to work with expressions present in format string literals for the `format_args!` family of macros.\n+//! Primarily meant for assists and completions.\n+\n+/// Enum for represenging extraced format string args.\n+/// Can either be extracted expressions (which includes identifiers),\n+/// or placeholders `{}`.\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum Arg {\n+    Placeholder,\n+    Ident(String),\n+    Expr(String),\n+}\n+\n+/**\n+ Add placeholders like `$1` and `$2` in place of [`Arg::Placeholder`],\n+ and unwraps the [`Arg::Ident`] and [`Arg::Expr`] enums.\n+ ```rust\n+ # use ide_db::syntax_helpers::format_string_exprs::*;\n+ assert_eq!(with_placeholders(vec![Arg::Ident(\"ident\".to_owned()), Arg::Placeholder, Arg::Expr(\"expr + 2\".to_owned())]), vec![\"ident\".to_owned(), \"$1\".to_owned(), \"expr + 2\".to_owned()])\n+ ```\n+*/\n+\n+pub fn with_placeholders(args: Vec<Arg>) -> Vec<String> {\n+    let mut placeholder_id = 1;\n+    args.into_iter()\n+        .map(move |a| match a {\n+            Arg::Expr(s) | Arg::Ident(s) => s,\n+            Arg::Placeholder => {\n+                let s = format!(\"${placeholder_id}\");\n+                placeholder_id += 1;\n+                s\n+            }\n+        })\n+        .collect()\n+}\n+\n+/**\n+ Parser for a format-like string. It is more allowing in terms of string contents,\n+ as we expect variable placeholders to be filled with expressions.\n+\n+ Built for completions and assists, and escapes `\\` and `$` in output.\n+ (See the comments on `get_receiver_text()` for detail.)\n+ Splits a format string that may contain expressions\n+ like\n+ ```rust\n+ assert_eq!(parse(\"{ident} {} {expr + 42} \").unwrap(), (\"{} {} {}\", vec![Arg::Ident(\"ident\"), Arg::Placeholder, Arg::Expr(\"expr + 42\")]));\n+ ```\n+*/\n+pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n+    #[derive(Debug, Clone, Copy, PartialEq)]\n+    enum State {\n+        NotArg,\n+        MaybeArg,\n+        Expr,\n+        Ident,\n+        MaybeIncorrect,\n+        FormatOpts,\n+    }\n+\n+    let mut state = State::NotArg;\n+    let mut current_expr = String::new();\n+    let mut extracted_expressions = Vec::new();\n+    let mut output = String::new();\n+\n+    // Count of open braces inside of an expression.\n+    // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n+    // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n+    let mut inexpr_open_count = 0;\n+\n+    let mut chars = input.chars().peekable();\n+    while let Some(chr) = chars.next() {\n+        match (state, chr) {\n+            (State::NotArg, '{') => {\n+                output.push(chr);\n+                state = State::MaybeArg;\n+            }\n+            (State::NotArg, '}') => {\n+                output.push(chr);\n+                state = State::MaybeIncorrect;\n+            }\n+            (State::NotArg, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    output.push('\\\\');\n+                }\n+                output.push(chr);\n+            }\n+            (State::MaybeIncorrect, '}') => {\n+                // It's okay, we met \"}}\".\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeIncorrect, _) => {\n+                // Error in the string.\n+                return Err(());\n+            }\n+            // Escaped braces `{{`\n+            (State::MaybeArg, '{') => {\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeArg, '}') => {\n+                // This is an empty sequence '{}'.\n+                output.push(chr);\n+                extracted_expressions.push(Arg::Placeholder);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeArg, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    current_expr.push('\\\\');\n+                }\n+                current_expr.push(chr);\n+\n+                // While Rust uses the unicode sets of XID_start and XID_continue for Identifiers\n+                // this is probably the best we can do to avoid a false positive\n+                if chr.is_alphabetic() || chr == '_' {\n+                    state = State::Ident;\n+                } else {\n+                    state = State::Expr;\n+                }\n+            }\n+            (State::Ident | State::Expr, '}') => {\n+                if inexpr_open_count == 0 {\n+                    output.push(chr);\n+\n+                    if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    } else {\n+                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                    }\n+\n+                    current_expr = String::new();\n+                    state = State::NotArg;\n+                } else {\n+                    // We're closing one brace met before inside of the expression.\n+                    current_expr.push(chr);\n+                    inexpr_open_count -= 1;\n+                }\n+            }\n+            (State::Ident | State::Expr, ':') if matches!(chars.peek(), Some(':')) => {\n+                // path separator\n+                state = State::Expr;\n+                current_expr.push_str(\"::\");\n+                chars.next();\n+            }\n+            (State::Ident | State::Expr, ':') => {\n+                if inexpr_open_count == 0 {\n+                    // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n+                    output.push(chr);\n+\n+                    if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    } else {\n+                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                    }\n+\n+                    current_expr = String::new();\n+                    state = State::FormatOpts;\n+                } else {\n+                    // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n+                    current_expr.push(chr);\n+                }\n+            }\n+            (State::Ident | State::Expr, '{') => {\n+                state = State::Expr;\n+                current_expr.push(chr);\n+                inexpr_open_count += 1;\n+            }\n+            (State::Ident | State::Expr, _) => {\n+                if !(chr.is_alphanumeric() || chr == '_' || chr == '#') {\n+                    state = State::Expr;\n+                }\n+\n+                if matches!(chr, '\\\\' | '$') {\n+                    current_expr.push('\\\\');\n+                }\n+                current_expr.push(chr);\n+            }\n+            (State::FormatOpts, '}') => {\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::FormatOpts, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    output.push('\\\\');\n+                }\n+                output.push(chr);\n+            }\n+        }\n+    }\n+\n+    if state != State::NotArg {\n+        return Err(());\n+    }\n+\n+    Ok((output, extracted_expressions))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use expect_test::{expect, Expect};\n+\n+    fn check(input: &str, expect: &Expect) {\n+        let (output, exprs) = parse_format_exprs(input).unwrap_or((\"-\".to_string(), vec![]));\n+        let outcome_repr = if !exprs.is_empty() {\n+            format!(\"{}; {}\", output, with_placeholders(exprs).join(\", \"))\n+        } else {\n+            output\n+        };\n+\n+        expect.assert_eq(&outcome_repr);\n+    }\n+\n+    #[test]\n+    fn format_str_parser() {\n+        let test_vector = &[\n+            (\"no expressions\", expect![[\"no expressions\"]]),\n+            (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n+            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n+            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n+            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n+            (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n+            (\"{malformed\", expect![[\"-\"]]),\n+            (\"malformed}\", expect![[\"-\"]]),\n+            (\"{{correct\", expect![[\"{{correct\"]]),\n+            (\"correct}}\", expect![[\"correct}}\"]]),\n+            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n+            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n+            (\"{incorrect}}\", expect![[\"-\"]]),\n+            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n+            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n+                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n+                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n+            (\"{strsim::jaro_winkle(a)}\", expect![[\"{}; strsim::jaro_winkle(a)\"]]),\n+            (\"{foo::bar::baz()}\", expect![[\"{}; foo::bar::baz()\"]]),\n+            (\"{foo::bar():?}\", expect![[\"{:?}; foo::bar()\"]]),\n+        ];\n+\n+        for (input, output) in test_vector {\n+            check(input, output)\n+        }\n+    }\n+\n+    #[test]\n+    fn arg_type() {\n+        assert_eq!(\n+            parse_format_exprs(\"{_ident} {r#raw_ident} {expr.obj} {name {thing: 42} } {}\")\n+                .unwrap()\n+                .1,\n+            vec![\n+                Arg::Ident(\"_ident\".to_owned()),\n+                Arg::Ident(\"r#raw_ident\".to_owned()),\n+                Arg::Expr(\"expr.obj\".to_owned()),\n+                Arg::Expr(\"name {thing: 42}\".to_owned()),\n+                Arg::Placeholder\n+            ]\n+        );\n+    }\n+}"}, {"sha": "3034295196b42a32a26882259e2338facaa52cc6", "filename": "crates/ide-diagnostics/src/handlers/json_is_not_rust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -137,6 +137,7 @@ pub(crate) fn json_in_items(\n                                         sema.db,\n                                         it,\n                                         config.insert_use.prefix_kind,\n+                                        config.prefer_no_std,\n                                     ) {\n                                         insert_use(\n                                             &scope,\n@@ -152,6 +153,7 @@ pub(crate) fn json_in_items(\n                                         sema.db,\n                                         it,\n                                         config.insert_use.prefix_kind,\n+                                        config.prefer_no_std,\n                                     ) {\n                                         insert_use(\n                                             &scope,"}, {"sha": "7f140eb6a74a6223dbdf26da59289184e1354e75", "filename": "crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -124,6 +124,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n                         let type_path = current_module?.find_use_path(\n                             ctx.sema.db,\n                             item_for_path_search(ctx.sema.db, item_in_ns)?,\n+                            ctx.config.prefer_no_std,\n                         )?;\n \n                         use_trivial_constructor("}, {"sha": "62c69f90baa4f9f55b1b15bcb827f67883c3f1cd", "filename": "crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -59,9 +59,6 @@ fn add_reference(\n     d: &hir::TypeMismatch,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let expr_node = d.expr.value.to_node(&root);\n-\n     let range = ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range;\n \n     let (_, mutability) = d.expected.as_reference()?;\n@@ -72,7 +69,7 @@ fn add_reference(\n \n     let ampersands = format!(\"&{}\", mutability.as_keyword_for_ref());\n \n-    let edit = TextEdit::insert(expr_node.syntax().text_range().start(), ampersands);\n+    let edit = TextEdit::insert(range.start(), ampersands);\n     let source_change =\n         SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n     acc.push(fix(\"add_reference_here\", \"Add reference here\", source_change, range));\n@@ -314,6 +311,34 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn test_add_reference_to_macro_call() {\n+        check_fix(\n+            r#\"\n+macro_rules! thousand {\n+    () => {\n+        1000_u64\n+    };\n+}\n+fn test(foo: &u64) {}\n+fn main() {\n+    test($0thousand!());\n+}\n+            \"#,\n+            r#\"\n+macro_rules! thousand {\n+    () => {\n+        1000_u64\n+    };\n+}\n+fn test(foo: &u64) {}\n+fn main() {\n+    test(&thousand!());\n+}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_add_mutable_reference_to_let_stmt() {\n         check_fix("}, {"sha": "ae299f0584148937c64b897e7cf658359a5c7069", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -150,6 +150,7 @@ pub struct DiagnosticsConfig {\n     pub expr_fill_default: ExprFillDefaultMode,\n     // FIXME: We may want to include a whole `AssistConfig` here\n     pub insert_use: InsertUseConfig,\n+    pub prefer_no_std: bool,\n }\n \n impl DiagnosticsConfig {\n@@ -170,6 +171,7 @@ impl DiagnosticsConfig {\n                 group: false,\n                 skip_glob_imports: false,\n             },\n+            prefer_no_std: false,\n         }\n     }\n }"}, {"sha": "57b5ab6abda6936f281eaf5315854261cd4d0e7b", "filename": "crates/ide-ssr/src/matching.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide-ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Fmatching.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -648,9 +648,10 @@ impl Match {\n             .module();\n         for (path, resolved_path) in &template.resolved_paths {\n             if let hir::PathResolution::Def(module_def) = resolved_path.resolution {\n-                let mod_path = module.find_use_path(sema.db, module_def).ok_or_else(|| {\n-                    match_error!(\"Failed to render template path `{}` at match location\")\n-                })?;\n+                let mod_path =\n+                    module.find_use_path(sema.db, module_def, false).ok_or_else(|| {\n+                        match_error!(\"Failed to render template path `{}` at match location\")\n+                    })?;\n                 self.rendered_template_paths.insert(path.clone(), mod_path);\n             }\n         }"}, {"sha": "bfbe0db6e4b84f3c579a376cd9ca40faa2cade2c", "filename": "crates/ide/src/annotations.rs", "status": "modified", "additions": 75, "deletions": 18, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -41,6 +41,12 @@ pub struct AnnotationConfig {\n     pub annotate_references: bool,\n     pub annotate_method_references: bool,\n     pub annotate_enum_variant_references: bool,\n+    pub location: AnnotationLocation,\n+}\n+\n+pub enum AnnotationLocation {\n+    AboveName,\n+    AboveWholeItem,\n }\n \n pub(crate) fn annotations(\n@@ -65,10 +71,10 @@ pub(crate) fn annotations(\n     visit_file_defs(&Semantics::new(db), file_id, &mut |def| {\n         let range = match def {\n             Definition::Const(konst) if config.annotate_references => {\n-                konst.source(db).and_then(|node| name_range(db, node, file_id))\n+                konst.source(db).and_then(|node| name_range(db, config, node, file_id))\n             }\n             Definition::Trait(trait_) if config.annotate_references || config.annotate_impls => {\n-                trait_.source(db).and_then(|node| name_range(db, node, file_id))\n+                trait_.source(db).and_then(|node| name_range(db, config, node, file_id))\n             }\n             Definition::Adt(adt) => match adt {\n                 hir::Adt::Enum(enum_) => {\n@@ -77,7 +83,9 @@ pub(crate) fn annotations(\n                             .variants(db)\n                             .into_iter()\n                             .map(|variant| {\n-                                variant.source(db).and_then(|node| name_range(db, node, file_id))\n+                                variant\n+                                    .source(db)\n+                                    .and_then(|node| name_range(db, config, node, file_id))\n                             })\n                             .flatten()\n                             .for_each(|range| {\n@@ -88,14 +96,14 @@ pub(crate) fn annotations(\n                             })\n                     }\n                     if config.annotate_references || config.annotate_impls {\n-                        enum_.source(db).and_then(|node| name_range(db, node, file_id))\n+                        enum_.source(db).and_then(|node| name_range(db, config, node, file_id))\n                     } else {\n                         None\n                     }\n                 }\n                 _ => {\n                     if config.annotate_references || config.annotate_impls {\n-                        adt.source(db).and_then(|node| name_range(db, node, file_id))\n+                        adt.source(db).and_then(|node| name_range(db, config, node, file_id))\n                     } else {\n                         None\n                     }\n@@ -113,6 +121,7 @@ pub(crate) fn annotations(\n             annotations\n                 .push(Annotation { range, kind: AnnotationKind::HasImpls { file_id, data: None } });\n         }\n+\n         if config.annotate_references {\n             annotations.push(Annotation {\n                 range,\n@@ -122,12 +131,18 @@ pub(crate) fn annotations(\n \n         fn name_range<T: HasName>(\n             db: &RootDatabase,\n+            config: &AnnotationConfig,\n             node: InFile<T>,\n             source_file_id: FileId,\n         ) -> Option<TextRange> {\n             if let Some(InFile { file_id, value }) = node.original_ast_node(db) {\n                 if file_id == source_file_id.into() {\n-                    return value.name().map(|it| it.syntax().text_range());\n+                    return match config.location {\n+                        AnnotationLocation::AboveName => {\n+                            value.name().map(|name| name.syntax().text_range())\n+                        }\n+                        AnnotationLocation::AboveWholeItem => Some(value.syntax().text_range()),\n+                    };\n                 }\n             }\n             None\n@@ -188,21 +203,23 @@ mod tests {\n \n     use crate::{fixture, Annotation, AnnotationConfig};\n \n-    fn check(ra_fixture: &str, expect: Expect) {\n+    use super::AnnotationLocation;\n+\n+    const DEFAULT_CONFIG: AnnotationConfig = AnnotationConfig {\n+        binary_target: true,\n+        annotate_runnables: true,\n+        annotate_impls: true,\n+        annotate_references: true,\n+        annotate_method_references: true,\n+        annotate_enum_variant_references: true,\n+        location: AnnotationLocation::AboveName,\n+    };\n+\n+    fn check_with_config(ra_fixture: &str, expect: Expect, config: &AnnotationConfig) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n \n         let annotations: Vec<Annotation> = analysis\n-            .annotations(\n-                &AnnotationConfig {\n-                    binary_target: true,\n-                    annotate_runnables: true,\n-                    annotate_impls: true,\n-                    annotate_references: true,\n-                    annotate_method_references: true,\n-                    annotate_enum_variant_references: true,\n-                },\n-                file_id,\n-            )\n+            .annotations(config, file_id)\n             .unwrap()\n             .into_iter()\n             .map(|annotation| analysis.resolve_annotation(annotation).unwrap())\n@@ -211,6 +228,10 @@ mod tests {\n         expect.assert_debug_eq(&annotations);\n     }\n \n+    fn check(ra_fixture: &str, expect: Expect) {\n+        check_with_config(ra_fixture, expect, &DEFAULT_CONFIG);\n+    }\n+\n     #[test]\n     fn const_annotations() {\n         check(\n@@ -786,4 +807,40 @@ m!();\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_annotations_appear_above_whole_item_when_configured_to_do_so() {\n+        check_with_config(\n+            r#\"\n+/// This is a struct named Foo, obviously.\n+#[derive(Clone)]\n+struct Foo;\n+\"#,\n+            expect![[r#\"\n+                [\n+                    Annotation {\n+                        range: 0..71,\n+                        kind: HasImpls {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            data: Some(\n+                                [],\n+                            ),\n+                        },\n+                    },\n+                    Annotation {\n+                        range: 0..71,\n+                        kind: HasReferences {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            data: None,\n+                        },\n+                    },\n+                ]\n+            \"#]],\n+            &AnnotationConfig { location: AnnotationLocation::AboveWholeItem, ..DEFAULT_CONFIG },\n+        );\n+    }\n }"}, {"sha": "1bdd626f1e834cbec0c8437639d46b130988c55d", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -377,6 +377,7 @@ mod tests {\n                         match it {\n                             ReferenceCategory::Read => \"read\",\n                             ReferenceCategory::Write => \"write\",\n+                            ReferenceCategory::Import => \"import\",\n                         }\n                         .to_string()\n                     }),\n@@ -423,20 +424,20 @@ struct Foo;\n         check(\n             r#\"\n use crate$0;\n-  //^^^^^\n+  //^^^^^ import\n use self;\n-  //^^^^\n+  //^^^^ import\n mod __ {\n     use super;\n-      //^^^^^\n+      //^^^^^ import\n }\n \"#,\n         );\n         check(\n             r#\"\n //- /main.rs crate:main deps:lib\n use lib$0;\n-  //^^^\n+  //^^^ import\n //- /lib.rs crate:lib\n \"#,\n         );\n@@ -450,7 +451,7 @@ use lib$0;\n mod foo;\n //- /foo.rs\n use self$0;\n- // ^^^^\n+ // ^^^^ import\n \"#,\n         );\n     }"}, {"sha": "93fcd7cad7a18e976a5a0ea98f389ac4aa02b8ba", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -1687,6 +1687,74 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn iterator_hint_regression_issue_12674() {\n+        // Ensure we don't crash while solving the projection type of iterators.\n+        check_expect(\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: iterators\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn iter(&self) -> Iter<'_, T> { loop {} }\n+}\n+struct Iter<'a, T: 'a>(&'a T);\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> { loop {} }\n+}\n+struct Container<'a> {\n+    elements: S<&'a str>,\n+}\n+struct SliceIter<'a, T>(&'a T);\n+impl<'a, T> Iterator for SliceIter<'a, T> {\n+    type Item = &'a T;\n+    fn next(&mut self) -> Option<Self::Item> { loop {} }\n+}\n+\n+fn main(a: SliceIter<'_, Container>) {\n+    a\n+    .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n+    .map(|e| e);\n+}\n+            \"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 484..554,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"impl Iterator<Item = impl Iterator<Item = &&str>>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                484..554,\n+                            ),\n+                        ),\n+                    },\n+                    InlayHint {\n+                        range: 484..485,\n+                        kind: ChainingHint,\n+                        label: [\n+                            \"SliceIter<Container>\",\n+                        ],\n+                        tooltip: Some(\n+                            HoverRanged(\n+                                FileId(\n+                                    0,\n+                                ),\n+                                484..485,\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn infer_call_method_return_associated_types_with_generic() {\n         check_types("}, {"sha": "c1ef25b592b1be4e2aebc8c3a6b719f7c3c27db3", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -74,7 +74,7 @@ use syntax::SourceFile;\n use crate::navigation_target::{ToNav, TryToNav};\n \n pub use crate::{\n-    annotations::{Annotation, AnnotationConfig, AnnotationKind},\n+    annotations::{Annotation, AnnotationConfig, AnnotationKind, AnnotationLocation},\n     call_hierarchy::CallItem,\n     expand_macro::ExpandedMacro,\n     file_structure::{StructureNode, StructureNodeKind},"}, {"sha": "e942413c11057ed40810a518b85eb0dcf641ea7c", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -742,7 +742,7 @@ pub struct Foo {\n             expect![[r#\"\n                 foo Module FileId(0) 0..8 4..7\n \n-                FileId(0) 14..17\n+                FileId(0) 14..17 Import\n             \"#]],\n         );\n     }\n@@ -760,7 +760,7 @@ use self$0;\n             expect![[r#\"\n                 foo Module FileId(0) 0..8 4..7\n \n-                FileId(1) 4..8\n+                FileId(1) 4..8 Import\n             \"#]],\n         );\n     }\n@@ -775,7 +775,7 @@ use self$0;\n             expect![[r#\"\n                 Module FileId(0) 0..10\n \n-                FileId(0) 4..8\n+                FileId(0) 4..8 Import\n             \"#]],\n         );\n     }\n@@ -803,7 +803,7 @@ pub(super) struct Foo$0 {\n             expect![[r#\"\n                 Foo Struct FileId(2) 0..41 18..21\n \n-                FileId(1) 20..23\n+                FileId(1) 20..23 Import\n                 FileId(1) 47..50\n             \"#]],\n         );\n@@ -966,7 +966,7 @@ fn g() { f(); }\n             expect![[r#\"\n                 f Function FileId(0) 22..31 25..26\n \n-                FileId(1) 11..12\n+                FileId(1) 11..12 Import\n                 FileId(1) 24..25\n             \"#]],\n         );\n@@ -1424,9 +1424,9 @@ pub use level1::Foo;\n             expect![[r#\"\n                 Foo Struct FileId(0) 0..15 11..14\n \n-                FileId(1) 16..19\n-                FileId(2) 16..19\n-                FileId(3) 16..19\n+                FileId(1) 16..19 Import\n+                FileId(2) 16..19 Import\n+                FileId(3) 16..19 Import\n             \"#]],\n         );\n     }\n@@ -1454,7 +1454,7 @@ lib::foo!();\n             expect![[r#\"\n                 foo Macro FileId(1) 0..61 29..32\n \n-                FileId(0) 46..49\n+                FileId(0) 46..49 Import\n                 FileId(2) 0..3\n                 FileId(3) 5..8\n             \"#]],\n@@ -1617,7 +1617,7 @@ struct Foo;\n             expect![[r#\"\n                 derive_identity Derive FileId(2) 1..107 45..60\n \n-                FileId(0) 17..31\n+                FileId(0) 17..31 Import\n                 FileId(0) 56..70\n             \"#]],\n         );"}, {"sha": "139a8cb8cbe589b9e586cdf6c8c0f94c36126e54", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -203,17 +203,16 @@ impl BindingsBuilder {\n     }\n \n     fn build(self, idx: &BindingsIdx) -> Bindings {\n-        let mut bindings = Bindings::default();\n-        self.build_inner(&mut bindings, &self.nodes[idx.0]);\n-        bindings\n+        self.build_inner(&self.nodes[idx.0])\n     }\n \n-    fn build_inner(&self, bindings: &mut Bindings, link_nodes: &[LinkNode<Rc<BindingKind>>]) {\n+    fn build_inner(&self, link_nodes: &[LinkNode<Rc<BindingKind>>]) -> Bindings {\n+        let mut bindings = Bindings::default();\n         let mut nodes = Vec::new();\n         self.collect_nodes(link_nodes, &mut nodes);\n \n         for cmd in nodes {\n-            match &**cmd {\n+            match cmd {\n                 BindingKind::Empty(name) => {\n                     bindings.push_empty(name);\n                 }\n@@ -246,13 +245,15 @@ impl BindingsBuilder {\n                 }\n             }\n         }\n+\n+        bindings\n     }\n \n     fn collect_nested_ref<'a>(\n         &'a self,\n         id: usize,\n         len: usize,\n-        nested_refs: &mut Vec<&'a Vec<LinkNode<Rc<BindingKind>>>>,\n+        nested_refs: &mut Vec<&'a [LinkNode<Rc<BindingKind>>]>,\n     ) {\n         self.nested[id].iter().take(len).for_each(|it| match it {\n             LinkNode::Node(id) => nested_refs.push(&self.nodes[*id]),\n@@ -262,26 +263,16 @@ impl BindingsBuilder {\n \n     fn collect_nested(&self, idx: usize, nested_idx: usize, nested: &mut Vec<Bindings>) {\n         let last = &self.nodes[idx];\n-        let mut nested_refs = Vec::new();\n+        let mut nested_refs: Vec<&[_]> = Vec::new();\n         self.nested[nested_idx].iter().for_each(|it| match *it {\n             LinkNode::Node(idx) => nested_refs.push(&self.nodes[idx]),\n             LinkNode::Parent { idx, len } => self.collect_nested_ref(idx, len, &mut nested_refs),\n         });\n         nested_refs.push(last);\n-\n-        nested_refs.into_iter().for_each(|iter| {\n-            let mut child_bindings = Bindings::default();\n-            self.build_inner(&mut child_bindings, iter);\n-            nested.push(child_bindings)\n-        })\n+        nested.extend(nested_refs.into_iter().map(|iter| self.build_inner(iter)));\n     }\n \n-    fn collect_nodes_ref<'a>(\n-        &'a self,\n-        id: usize,\n-        len: usize,\n-        nodes: &mut Vec<&'a Rc<BindingKind>>,\n-    ) {\n+    fn collect_nodes_ref<'a>(&'a self, id: usize, len: usize, nodes: &mut Vec<&'a BindingKind>) {\n         self.nodes[id].iter().take(len).for_each(|it| match it {\n             LinkNode::Node(it) => nodes.push(it),\n             LinkNode::Parent { idx, len } => self.collect_nodes_ref(*idx, *len, nodes),\n@@ -291,7 +282,7 @@ impl BindingsBuilder {\n     fn collect_nodes<'a>(\n         &'a self,\n         link_nodes: &'a [LinkNode<Rc<BindingKind>>],\n-        nodes: &mut Vec<&'a Rc<BindingKind>>,\n+        nodes: &mut Vec<&'a BindingKind>,\n     ) {\n         link_nodes.iter().for_each(|it| match it {\n             LinkNode::Node(it) => nodes.push(it),\n@@ -386,10 +377,10 @@ fn match_loop_inner<'t>(\n         let op = match item.dot.peek() {\n             None => {\n                 // We are at or past the end of the matcher of `item`.\n-                if item.up.is_some() {\n+                if let Some(up) = &item.up {\n                     if item.sep_parsed.is_none() {\n                         // Get the `up` matcher\n-                        let mut new_pos = *item.up.clone().unwrap();\n+                        let mut new_pos = (**up).clone();\n                         new_pos.bindings = bindings_builder.copy(&new_pos.bindings);\n                         // Add matches from this repetition to the `matches` of `up`\n                         bindings_builder.push_nested(&mut new_pos.bindings, &item.bindings);\n@@ -402,7 +393,7 @@ fn match_loop_inner<'t>(\n \n                     // Check if we need a separator.\n                     // We check the separator one by one\n-                    let sep_idx = *item.sep_parsed.as_ref().unwrap_or(&0);\n+                    let sep_idx = item.sep_parsed.unwrap_or(0);\n                     let sep_len = item.sep.as_ref().map_or(0, Separator::tt_count);\n                     if item.sep.is_some() && sep_idx != sep_len {\n                         let sep = item.sep.as_ref().unwrap();"}, {"sha": "837ea016193cdc4f6f22f80c65a27ebcd7bbc7d9", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -43,10 +43,12 @@ impl WorkspaceBuildScripts {\n         if let Some([program, args @ ..]) = config.run_build_script_command.as_deref() {\n             let mut cmd = Command::new(program);\n             cmd.args(args);\n+            cmd.envs(&config.extra_env);\n             return cmd;\n         }\n \n         let mut cmd = Command::new(toolchain::cargo());\n+        cmd.envs(&config.extra_env);\n \n         cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n "}, {"sha": "736d80041bd5115ac5bc3701f6549ea6feb35e52", "filename": "crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -2,6 +2,7 @@\n \n use std::iter;\n use std::path::PathBuf;\n+use std::str::from_utf8;\n use std::{ops, process::Command};\n \n use anyhow::{Context, Result};\n@@ -98,6 +99,8 @@ pub struct CargoConfig {\n     pub wrap_rustc_in_build_scripts: bool,\n \n     pub run_build_script_command: Option<Vec<String>>,\n+\n+    pub extra_env: FxHashMap<String, String>,\n }\n \n impl CargoConfig {\n@@ -263,8 +266,8 @@ impl CargoWorkspace {\n         let target = config\n             .target\n             .clone()\n-            .or_else(|| cargo_config_build_target(cargo_toml))\n-            .or_else(|| rustc_discover_host_triple(cargo_toml));\n+            .or_else(|| cargo_config_build_target(cargo_toml, config))\n+            .or_else(|| rustc_discover_host_triple(cargo_toml, config));\n \n         let mut meta = MetadataCommand::new();\n         meta.cargo_path(toolchain::cargo());\n@@ -292,8 +295,27 @@ impl CargoWorkspace {\n         // unclear whether cargo itself supports it.\n         progress(\"metadata\".to_string());\n \n-        let meta =\n-            meta.exec().with_context(|| format!(\"Failed to run `{:?}`\", meta.cargo_command()))?;\n+        fn exec_with_env(\n+            command: &cargo_metadata::MetadataCommand,\n+            extra_env: &FxHashMap<String, String>,\n+        ) -> Result<cargo_metadata::Metadata, cargo_metadata::Error> {\n+            let mut command = command.cargo_command();\n+            command.envs(extra_env);\n+            let output = command.output()?;\n+            if !output.status.success() {\n+                return Err(cargo_metadata::Error::CargoMetadata {\n+                    stderr: String::from_utf8(output.stderr)?,\n+                });\n+            }\n+            let stdout = from_utf8(&output.stdout)?\n+                .lines()\n+                .find(|line| line.starts_with('{'))\n+                .ok_or(cargo_metadata::Error::NoJson)?;\n+            cargo_metadata::MetadataCommand::parse(stdout)\n+        }\n+\n+        let meta = exec_with_env(&meta, &config.extra_env)\n+            .with_context(|| format!(\"Failed to run `{:?}`\", meta.cargo_command()))?;\n \n         Ok(meta)\n     }\n@@ -463,8 +485,9 @@ impl CargoWorkspace {\n     }\n }\n \n-fn rustc_discover_host_triple(cargo_toml: &ManifestPath) -> Option<String> {\n+fn rustc_discover_host_triple(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<String> {\n     let mut rustc = Command::new(toolchain::rustc());\n+    rustc.envs(&config.extra_env);\n     rustc.current_dir(cargo_toml.parent()).arg(\"-vV\");\n     tracing::debug!(\"Discovering host platform by {:?}\", rustc);\n     match utf8_stdout(rustc) {\n@@ -486,8 +509,9 @@ fn rustc_discover_host_triple(cargo_toml: &ManifestPath) -> Option<String> {\n     }\n }\n \n-fn cargo_config_build_target(cargo_toml: &ManifestPath) -> Option<String> {\n+fn cargo_config_build_target(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<String> {\n     let mut cargo_config = Command::new(toolchain::cargo());\n+    cargo_config.envs(&config.extra_env);\n     cargo_config\n         .current_dir(cargo_toml.parent())\n         .args(&[\"-Z\", \"unstable-options\", \"config\", \"get\", \"build.target\"])"}, {"sha": "486cb143b80bd22678fa584a6aedacd14529e9d8", "filename": "crates/project-model/src/rustc_cfg.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Frustc_cfg.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -4,9 +4,13 @@ use std::process::Command;\n \n use anyhow::Result;\n \n-use crate::{cfg_flag::CfgFlag, utf8_stdout, ManifestPath};\n+use crate::{cfg_flag::CfgFlag, utf8_stdout, CargoConfig, ManifestPath};\n \n-pub(crate) fn get(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Vec<CfgFlag> {\n+pub(crate) fn get(\n+    cargo_toml: Option<&ManifestPath>,\n+    target: Option<&str>,\n+    config: &CargoConfig,\n+) -> Vec<CfgFlag> {\n     let _p = profile::span(\"rustc_cfg::get\");\n     let mut res = Vec::with_capacity(6 * 2 + 1);\n \n@@ -18,7 +22,7 @@ pub(crate) fn get(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Ve\n         }\n     }\n \n-    match get_rust_cfgs(cargo_toml, target) {\n+    match get_rust_cfgs(cargo_toml, target, config) {\n         Ok(rustc_cfgs) => {\n             tracing::debug!(\n                 \"rustc cfgs found: {:?}\",\n@@ -35,9 +39,14 @@ pub(crate) fn get(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Ve\n     res\n }\n \n-fn get_rust_cfgs(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Result<String> {\n+fn get_rust_cfgs(\n+    cargo_toml: Option<&ManifestPath>,\n+    target: Option<&str>,\n+    config: &CargoConfig,\n+) -> Result<String> {\n     if let Some(cargo_toml) = cargo_toml {\n         let mut cargo_config = Command::new(toolchain::cargo());\n+        cargo_config.envs(&config.extra_env);\n         cargo_config\n             .current_dir(cargo_toml.parent())\n             .args(&[\"-Z\", \"unstable-options\", \"rustc\", \"--print\", \"cfg\"])\n@@ -52,6 +61,7 @@ fn get_rust_cfgs(cargo_toml: Option<&ManifestPath>, target: Option<&str>) -> Res\n     }\n     // using unstable cargo features failed, fall back to using plain rustc\n     let mut cmd = Command::new(toolchain::rustc());\n+    cmd.envs(&config.extra_env);\n     cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n     if let Some(target) = target {\n         cmd.args(&[\"--target\", target]);"}, {"sha": "3282719fef3d7a3d0b1c188487797cb384b24817", "filename": "crates/project-model/src/sysroot.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -10,7 +10,7 @@ use anyhow::{format_err, Result};\n use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n \n-use crate::{utf8_stdout, ManifestPath};\n+use crate::{utf8_stdout, CargoConfig, ManifestPath};\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Sysroot {\n@@ -67,18 +67,20 @@ impl Sysroot {\n         self.crates.iter().map(|(id, _data)| id)\n     }\n \n-    pub fn discover(dir: &AbsPath) -> Result<Sysroot> {\n+    pub fn discover(dir: &AbsPath, config: &CargoConfig) -> Result<Sysroot> {\n         tracing::debug!(\"Discovering sysroot for {}\", dir.display());\n-        let sysroot_dir = discover_sysroot_dir(dir)?;\n-        let sysroot_src_dir = discover_sysroot_src_dir(&sysroot_dir, dir)?;\n+        let sysroot_dir = discover_sysroot_dir(dir, config)?;\n+        let sysroot_src_dir = discover_sysroot_src_dir(&sysroot_dir, dir, config)?;\n         let res = Sysroot::load(sysroot_dir, sysroot_src_dir)?;\n         Ok(res)\n     }\n \n-    pub fn discover_rustc(cargo_toml: &ManifestPath) -> Option<ManifestPath> {\n+    pub fn discover_rustc(cargo_toml: &ManifestPath, config: &CargoConfig) -> Option<ManifestPath> {\n         tracing::debug!(\"Discovering rustc source for {}\", cargo_toml.display());\n         let current_dir = cargo_toml.parent();\n-        discover_sysroot_dir(current_dir).ok().and_then(|sysroot_dir| get_rustc_src(&sysroot_dir))\n+        discover_sysroot_dir(current_dir, config)\n+            .ok()\n+            .and_then(|sysroot_dir| get_rustc_src(&sysroot_dir))\n     }\n \n     pub fn load(sysroot_dir: AbsPathBuf, sysroot_src_dir: AbsPathBuf) -> Result<Sysroot> {\n@@ -144,8 +146,9 @@ impl Sysroot {\n     }\n }\n \n-fn discover_sysroot_dir(current_dir: &AbsPath) -> Result<AbsPathBuf> {\n+fn discover_sysroot_dir(current_dir: &AbsPath, config: &CargoConfig) -> Result<AbsPathBuf> {\n     let mut rustc = Command::new(toolchain::rustc());\n+    rustc.envs(&config.extra_env);\n     rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n     tracing::debug!(\"Discovering sysroot by {:?}\", rustc);\n     let stdout = utf8_stdout(rustc)?;\n@@ -155,6 +158,7 @@ fn discover_sysroot_dir(current_dir: &AbsPath) -> Result<AbsPathBuf> {\n fn discover_sysroot_src_dir(\n     sysroot_path: &AbsPathBuf,\n     current_dir: &AbsPath,\n+    config: &CargoConfig,\n ) -> Result<AbsPathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n         let path = AbsPathBuf::try_from(path.as_str())\n@@ -170,6 +174,7 @@ fn discover_sysroot_src_dir(\n     get_rust_src(sysroot_path)\n         .or_else(|| {\n             let mut rustup = Command::new(toolchain::rustup());\n+            rustup.envs(&config.extra_env);\n             rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n             utf8_stdout(rustup).ok()?;\n             get_rust_src(sysroot_path)"}, {"sha": "bea624bd54195e73651a0539919a4e80b03a4932", "filename": "crates/project-model/src/tests.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Ftests.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -10,8 +10,8 @@ use paths::{AbsPath, AbsPathBuf};\n use serde::de::DeserializeOwned;\n \n use crate::{\n-    CargoWorkspace, CfgOverrides, ProjectJson, ProjectJsonData, ProjectWorkspace, Sysroot,\n-    WorkspaceBuildScripts,\n+    CargoConfig, CargoWorkspace, CfgOverrides, ProjectJson, ProjectJsonData, ProjectWorkspace,\n+    Sysroot, WorkspaceBuildScripts,\n };\n \n fn load_cargo(file: &str) -> CrateGraph {\n@@ -92,13 +92,17 @@ fn rooted_project_json(data: ProjectJsonData) -> ProjectJson {\n }\n \n fn to_crate_graph(project_workspace: ProjectWorkspace) -> CrateGraph {\n-    project_workspace.to_crate_graph(&mut |_, _| Ok(Vec::new()), &mut {\n-        let mut counter = 0;\n-        move |_path| {\n-            counter += 1;\n-            Some(FileId(counter))\n-        }\n-    })\n+    project_workspace.to_crate_graph(\n+        &mut |_, _| Ok(Vec::new()),\n+        &mut {\n+            let mut counter = 0;\n+            move |_path| {\n+                counter += 1;\n+                Some(FileId(counter))\n+            }\n+        },\n+        &CargoConfig::default(),\n+    )\n }\n \n fn check_crate_graph(crate_graph: CrateGraph, expect: Expect) {"}, {"sha": "bc4ab45daeffc80a418711f3f0f03a4c7e8f73c1", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -156,11 +156,12 @@ impl ProjectWorkspace {\n                 })?;\n                 let project_location = project_json.parent().to_path_buf();\n                 let project_json = ProjectJson::new(&project_location, data);\n-                ProjectWorkspace::load_inline(project_json, config.target.as_deref())?\n+                ProjectWorkspace::load_inline(project_json, config.target.as_deref(), config)?\n             }\n             ProjectManifest::CargoToml(cargo_toml) => {\n                 let cargo_version = utf8_stdout({\n                     let mut cmd = Command::new(toolchain::cargo());\n+                    cmd.envs(&config.extra_env);\n                     cmd.arg(\"--version\");\n                     cmd\n                 })?;\n@@ -186,7 +187,7 @@ impl ProjectWorkspace {\n                 let sysroot = if config.no_sysroot {\n                     None\n                 } else {\n-                    Some(Sysroot::discover(cargo_toml.parent()).with_context(|| {\n+                    Some(Sysroot::discover(cargo_toml.parent(), config).with_context(|| {\n                         format!(\n                             \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n                             cargo_toml.display()\n@@ -196,7 +197,7 @@ impl ProjectWorkspace {\n \n                 let rustc_dir = match &config.rustc_source {\n                     Some(RustcSource::Path(path)) => ManifestPath::try_from(path.clone()).ok(),\n-                    Some(RustcSource::Discover) => Sysroot::discover_rustc(&cargo_toml),\n+                    Some(RustcSource::Discover) => Sysroot::discover_rustc(&cargo_toml, config),\n                     None => None,\n                 };\n \n@@ -216,7 +217,7 @@ impl ProjectWorkspace {\n                     None => None,\n                 };\n \n-                let rustc_cfg = rustc_cfg::get(Some(&cargo_toml), config.target.as_deref());\n+                let rustc_cfg = rustc_cfg::get(Some(&cargo_toml), config.target.as_deref(), config);\n \n                 let cfg_overrides = config.cfg_overrides();\n                 ProjectWorkspace::Cargo {\n@@ -237,6 +238,7 @@ impl ProjectWorkspace {\n     pub fn load_inline(\n         project_json: ProjectJson,\n         target: Option<&str>,\n+        config: &CargoConfig,\n     ) -> Result<ProjectWorkspace> {\n         let sysroot = match (project_json.sysroot.clone(), project_json.sysroot_src.clone()) {\n             (Some(sysroot), Some(sysroot_src)) => Some(Sysroot::load(sysroot, sysroot_src)?),\n@@ -258,7 +260,7 @@ impl ProjectWorkspace {\n             (None, None) => None,\n         };\n \n-        let rustc_cfg = rustc_cfg::get(None, target);\n+        let rustc_cfg = rustc_cfg::get(None, target, config);\n         Ok(ProjectWorkspace::Json { project: project_json, sysroot, rustc_cfg })\n     }\n \n@@ -268,8 +270,9 @@ impl ProjectWorkspace {\n                 .first()\n                 .and_then(|it| it.parent())\n                 .ok_or_else(|| format_err!(\"No detached files to load\"))?,\n+            &CargoConfig::default(),\n         )?;\n-        let rustc_cfg = rustc_cfg::get(None, None);\n+        let rustc_cfg = rustc_cfg::get(None, None, &CargoConfig::default());\n         Ok(ProjectWorkspace::DetachedFiles { files: detached_files, sysroot, rustc_cfg })\n     }\n \n@@ -416,6 +419,7 @@ impl ProjectWorkspace {\n         &self,\n         load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+        config: &CargoConfig,\n     ) -> CrateGraph {\n         let _p = profile::span(\"ProjectWorkspace::to_crate_graph\");\n \n@@ -426,6 +430,7 @@ impl ProjectWorkspace {\n                 load,\n                 project,\n                 sysroot,\n+                config,\n             ),\n             ProjectWorkspace::Cargo {\n                 cargo,\n@@ -464,6 +469,7 @@ fn project_json_to_crate_graph(\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     project: &ProjectJson,\n     sysroot: &Option<Sysroot>,\n+    config: &CargoConfig,\n ) -> CrateGraph {\n     let mut crate_graph = CrateGraph::default();\n     let sysroot_deps = sysroot\n@@ -489,9 +495,9 @@ fn project_json_to_crate_graph(\n             };\n \n             let target_cfgs = match krate.target.as_deref() {\n-                Some(target) => {\n-                    cfg_cache.entry(target).or_insert_with(|| rustc_cfg::get(None, Some(target)))\n-                }\n+                Some(target) => cfg_cache\n+                    .entry(target)\n+                    .or_insert_with(|| rustc_cfg::get(None, Some(target), config)),\n                 None => &rustc_cfg,\n             };\n "}, {"sha": "80128e43fd3c50f6be8ce8aec7190ff8a4fe9df6", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -80,7 +80,8 @@ impl flags::AnalysisStats {\n             Some(build_scripts_sw.elapsed())\n         };\n \n-        let (host, vfs, _proc_macro) = load_workspace(workspace, &load_cargo_config)?;\n+        let (host, vfs, _proc_macro) =\n+            load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n         let db = host.raw_database();\n         eprint!(\"{:<20} {}\", \"Database loaded:\", db_load_sw.elapsed());\n         eprint!(\" (metadata {}\", metadata_time);"}, {"sha": "88953096e2bcd5fff1e61984085458505319b62a", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -38,7 +38,7 @@ pub fn load_workspace_at(\n         workspace.set_build_scripts(build_scripts)\n     }\n \n-    load_workspace(workspace, load_config)\n+    load_workspace(workspace, cargo_config, load_config)\n }\n \n // Note: Since this function is used by external tools that use rust-analyzer as a library\n@@ -48,6 +48,7 @@ pub fn load_workspace_at(\n // these tools need access to `ProjectWorkspace`, too, which `load_workspace_at` hides.\n pub fn load_workspace(\n     ws: ProjectWorkspace,\n+    cargo_config: &CargoConfig,\n     load_config: &LoadCargoConfig,\n ) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroServer>)> {\n     let (sender, receiver) = unbounded();\n@@ -75,6 +76,7 @@ pub fn load_workspace(\n             vfs.set_file_contents(path.clone(), contents);\n             vfs.file_id(&path)\n         },\n+        cargo_config,\n     );\n \n     let project_folders = ProjectFolders::new(&[ws], &[]);"}, {"sha": "79577bf78c8f9d64096e6754017c19164ead274b", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -299,7 +299,8 @@ impl flags::Lsif {\n \n         let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n \n-        let (host, vfs, _proc_macro) = load_workspace(workspace, &load_cargo_config)?;\n+        let (host, vfs, _proc_macro) =\n+            load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n         let db = host.raw_database();\n         let analysis = host.analysis();\n "}, {"sha": "05c16bb39e3515960130a7b4d19307ee083be650", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -40,7 +40,7 @@ impl flags::Scip {\n \n         let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n \n-        let (host, vfs, _) = load_workspace(workspace, &load_cargo_config)?;\n+        let (host, vfs, _) = load_workspace(workspace, &cargo_config, &load_cargo_config)?;\n         let db = host.raw_database();\n         let analysis = host.analysis();\n "}, {"sha": "9ef79e6f381208c0a09dbcafbef2518751fc1ee5", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -84,6 +84,9 @@ config_data! {\n         /// Use `RUSTC_WRAPPER=rust-analyzer` when running build scripts to\n         /// avoid checking unnecessary things.\n         cargo_buildScripts_useRustcWrapper: bool = \"true\",\n+        /// Extra environment variables that will be set when running cargo, rustc\n+        /// or other commands within the workspace. Useful for setting RUSTFLAGS.\n+        cargo_extraEnv: FxHashMap<String, String> = \"{}\",\n         /// List of features to activate.\n         ///\n         /// Set this to `\"all\"` to pass `--all-features` to cargo.\n@@ -105,6 +108,8 @@ config_data! {\n         checkOnSave_enable: bool                         = \"true\",\n         /// Extra arguments for `cargo check`.\n         checkOnSave_extraArgs: Vec<String>               = \"[]\",\n+        /// Extra environment variables that will be set when running `cargo check`.\n+        checkOnSave_extraEnv: FxHashMap<String, String> = \"{}\",\n         /// List of features to activate. Defaults to\n         /// `#rust-analyzer.cargo.features#`.\n         ///\n@@ -219,7 +224,6 @@ config_data! {\n         files_excludeDirs: Vec<PathBuf> = \"[]\",\n         /// Controls file watching implementation.\n         files_watcher: FilesWatcherDef = \"\\\"client\\\"\",\n-\n         /// Enables highlighting of related references while the cursor is on `break`, `loop`, `while`, or `for` keywords.\n         highlightRelated_breakPoints_enable: bool = \"true\",\n         /// Enables highlighting of all exit points while the cursor is on any `return`, `?`, `fn`, or return type arrow (`->`).\n@@ -263,6 +267,8 @@ config_data! {\n         imports_group_enable: bool                           = \"true\",\n         /// Whether to allow import insertion to merge new imports into single path glob imports like `use std::fmt::*;`.\n         imports_merge_glob: bool           = \"true\",\n+        /// Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\n+        imports_prefer_no_std: bool                     = \"false\",\n         /// The path structure for newly inserted paths to use.\n         imports_prefix: ImportPrefixDef               = \"\\\"plain\\\"\",\n \n@@ -307,6 +313,7 @@ config_data! {\n         /// Join lines unwraps trivial blocks.\n         joinLines_unwrapTrivialBlock: bool = \"true\",\n \n+\n         /// Whether to show `Debug` lens. Only applies when\n         /// `#rust-analyzer.lens.enable#` is set.\n         lens_debug_enable: bool            = \"true\",\n@@ -318,6 +325,8 @@ config_data! {\n         /// Whether to show `Implementations` lens. Only applies when\n         /// `#rust-analyzer.lens.enable#` is set.\n         lens_implementations_enable: bool  = \"true\",\n+        /// Where to render annotations.\n+        lens_location: AnnotationLocation = \"\\\"above_name\\\"\",\n         /// Whether to show `References` lens for Struct, Enum, and Union.\n         /// Only applies when `#rust-analyzer.lens.enable#` is set.\n         lens_references_adt_enable: bool = \"false\",\n@@ -359,6 +368,9 @@ config_data! {\n         /// this is rust-analyzer itself, but we override this in tests).\n         procMacro_server: Option<PathBuf>          = \"null\",\n \n+        /// Exclude imports from find-all-references.\n+        references_excludeImports: bool = \"false\",\n+\n         /// Command to be executed instead of 'cargo' for runnables.\n         runnables_command: Option<String> = \"null\",\n         /// Additional arguments to be passed to cargo for runnables such as\n@@ -494,6 +506,25 @@ pub struct LensConfig {\n     pub refs_adt: bool,   // for Struct, Enum, Union and Trait\n     pub refs_trait: bool, // for Struct, Enum, Union and Trait\n     pub enum_variant_refs: bool,\n+\n+    // annotations\n+    pub location: AnnotationLocation,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Deserialize)]\n+#[serde(rename_all = \"snake_case\")]\n+pub enum AnnotationLocation {\n+    AboveName,\n+    AboveWholeItem,\n+}\n+\n+impl From<AnnotationLocation> for ide::AnnotationLocation {\n+    fn from(location: AnnotationLocation) -> Self {\n+        match location {\n+            AnnotationLocation::AboveName => ide::AnnotationLocation::AboveName,\n+            AnnotationLocation::AboveWholeItem => ide::AnnotationLocation::AboveWholeItem,\n+        }\n+    }\n }\n \n impl LensConfig {\n@@ -918,6 +949,7 @@ impl Config {\n                 ExprFillDefaultDef::Default => ExprFillDefaultMode::Default,\n             },\n             insert_use: self.insert_use_config(),\n+            prefer_no_std: self.data.imports_prefer_no_std,\n         }\n     }\n \n@@ -929,6 +961,16 @@ impl Config {\n         }\n     }\n \n+    pub fn extra_env(&self) -> &FxHashMap<String, String> {\n+        &self.data.cargo_extraEnv\n+    }\n+\n+    pub fn check_on_save_extra_env(&self) -> FxHashMap<String, String> {\n+        let mut extra_env = self.data.cargo_extraEnv.clone();\n+        extra_env.extend(self.data.checkOnSave_extraEnv.clone());\n+        extra_env\n+    }\n+\n     pub fn lru_capacity(&self) -> Option<usize> {\n         self.data.lru_capacity\n     }\n@@ -998,6 +1040,7 @@ impl Config {\n             unset_test_crates: UnsetTestCrates::Only(self.data.cargo_unsetTest.clone()),\n             wrap_rustc_in_build_scripts: self.data.cargo_buildScripts_useRustcWrapper,\n             run_build_script_command: self.data.cargo_buildScripts_overrideCommand.clone(),\n+            extra_env: self.data.cargo_extraEnv.clone(),\n         }\n     }\n \n@@ -1023,7 +1066,11 @@ impl Config {\n             Some(args) if !args.is_empty() => {\n                 let mut args = args.clone();\n                 let command = args.remove(0);\n-                FlycheckConfig::CustomCommand { command, args }\n+                FlycheckConfig::CustomCommand {\n+                    command,\n+                    args,\n+                    extra_env: self.check_on_save_extra_env(),\n+                }\n             }\n             Some(_) | None => FlycheckConfig::CargoCommand {\n                 command: self.data.checkOnSave_command.clone(),\n@@ -1051,6 +1098,7 @@ impl Config {\n                     CargoFeatures::Listed(it) => it,\n                 },\n                 extra_args: self.data.checkOnSave_extraArgs.clone(),\n+                extra_env: self.check_on_save_extra_env(),\n             },\n         };\n         Some(flycheck_config)\n@@ -1133,6 +1181,7 @@ impl Config {\n                 CallableCompletionDef::None => None,\n             },\n             insert_use: self.insert_use_config(),\n+            prefer_no_std: self.data.imports_prefer_no_std,\n             snippet_cap: SnippetCap::new(try_or_def!(\n                 self.caps\n                     .text_document\n@@ -1147,6 +1196,10 @@ impl Config {\n         }\n     }\n \n+    pub fn find_all_refs_exclude_imports(&self) -> bool {\n+        self.data.references_excludeImports\n+    }\n+\n     pub fn snippet_cap(&self) -> bool {\n         self.experimental(\"snippetTextEdit\")\n     }\n@@ -1156,6 +1209,7 @@ impl Config {\n             snippet_cap: SnippetCap::new(self.experimental(\"snippetTextEdit\")),\n             allowed: None,\n             insert_use: self.insert_use_config(),\n+            prefer_no_std: self.data.imports_prefer_no_std,\n         }\n     }\n \n@@ -1185,6 +1239,7 @@ impl Config {\n             refs_trait: self.data.lens_enable && self.data.lens_references_trait_enable,\n             enum_variant_refs: self.data.lens_enable\n                 && self.data.lens_references_enumVariant_enable,\n+            location: self.data.lens_location,\n         }\n     }\n \n@@ -1921,6 +1976,14 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 \"Use server-side file watching\",\n             ],\n         },\n+        \"AnnotationLocation\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"above_name\", \"above_whole_item\"],\n+            \"enumDescriptions\": [\n+                \"Render annotations above the name of the item.\",\n+                \"Render annotations above the whole item, including documentation comments and attributes.\"\n+            ],\n+        },\n         _ => panic!(\"missing entry for {}: {}\", ty, default),\n     }\n "}, {"sha": "8c3ea77d0611587c2f7f7b94083f5d4764d0cf6b", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -10,8 +10,8 @@ use std::{\n use anyhow::Context;\n use ide::{\n     AnnotationConfig, AssistKind, AssistResolveStrategy, FileId, FilePosition, FileRange,\n-    HoverAction, HoverGotoTypeData, Query, RangeInfo, Runnable, RunnableKind, SingleResolve,\n-    SourceChange, TextEdit,\n+    HoverAction, HoverGotoTypeData, Query, RangeInfo, ReferenceCategory, Runnable, RunnableKind,\n+    SingleResolve, SourceChange, TextEdit,\n };\n use ide_db::SymbolKind;\n use lsp_server::ErrorCode;\n@@ -1012,6 +1012,8 @@ pub(crate) fn handle_references(\n     let _p = profile::span(\"handle_references\");\n     let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n+    let exclude_imports = snap.config.find_all_refs_exclude_imports();\n+\n     let refs = match snap.analysis.find_all_refs(position, None)? {\n         None => return Ok(None),\n         Some(refs) => refs,\n@@ -1032,7 +1034,11 @@ pub(crate) fn handle_references(\n             refs.references\n                 .into_iter()\n                 .flat_map(|(file_id, refs)| {\n-                    refs.into_iter().map(move |(range, _)| FileRange { file_id, range })\n+                    refs.into_iter()\n+                        .filter(|&(_, category)| {\n+                            !exclude_imports || category != Some(ReferenceCategory::Import)\n+                        })\n+                        .map(move |(range, _)| FileRange { file_id, range })\n                 })\n                 .chain(decl)\n         })\n@@ -1234,6 +1240,7 @@ pub(crate) fn handle_code_lens(\n             annotate_references: lens_config.refs_adt,\n             annotate_method_references: lens_config.method_refs,\n             annotate_enum_variant_references: lens_config.enum_variant_refs,\n+            location: lens_config.location.into(),\n         },\n         file_id,\n     )?;\n@@ -1283,7 +1290,7 @@ pub(crate) fn handle_document_highlight(\n         .into_iter()\n         .map(|ide::HighlightedRange { range, category }| lsp_types::DocumentHighlight {\n             range: to_proto::range(&line_index, range),\n-            kind: category.map(to_proto::document_highlight_kind),\n+            kind: category.and_then(to_proto::document_highlight_kind),\n         })\n         .collect();\n     Ok(Some(res))\n@@ -1782,6 +1789,7 @@ fn run_rustfmt(\n     let mut command = match snap.config.rustfmt() {\n         RustfmtConfig::Rustfmt { extra_args, enable_range_formatting } => {\n             let mut cmd = process::Command::new(toolchain::rustfmt());\n+            cmd.envs(snap.config.extra_env());\n             cmd.args(extra_args);\n             // try to chdir to the file so we can respect `rustfmt.toml`\n             // FIXME: use `rustfmt --config-path` once\n@@ -1839,6 +1847,7 @@ fn run_rustfmt(\n         }\n         RustfmtConfig::CustomCommand { command, args } => {\n             let mut cmd = process::Command::new(command);\n+            cmd.envs(snap.config.extra_env());\n             cmd.args(args);\n             cmd\n         }"}, {"sha": "96b1cb6b12713d5f0c666d8791cdb890a1d20e43", "filename": "crates/rust-analyzer/src/integrated_benchmarks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -145,6 +145,7 @@ fn integrated_completion_benchmark() {\n                 skip_glob_imports: true,\n             },\n             snippets: Vec::new(),\n+            prefer_no_std: false,\n         };\n         let position =\n             FilePosition { file_id, offset: TextSize::try_from(completion_offset).unwrap() };\n@@ -182,6 +183,7 @@ fn integrated_completion_benchmark() {\n                 skip_glob_imports: true,\n             },\n             snippets: Vec::new(),\n+            prefer_no_std: false,\n         };\n         let position =\n             FilePosition { file_id, offset: TextSize::try_from(completion_offset).unwrap() };"}, {"sha": "4cf5de46c485ed134f8d93469a046e5016ca199f", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -143,6 +143,7 @@ impl GlobalState {\n                             project_model::ProjectWorkspace::load_inline(\n                                 it.clone(),\n                                 cargo_config.target.as_deref(),\n+                                &cargo_config,\n                             )\n                         }\n                     })\n@@ -398,7 +399,11 @@ impl GlobalState {\n                         dummy_replacements.get(crate_name).map(|v| &**v).unwrap_or_default(),\n                     )\n                 };\n-                crate_graph.extend(ws.to_crate_graph(&mut load_proc_macro, &mut load));\n+                crate_graph.extend(ws.to_crate_graph(\n+                    &mut load_proc_macro,\n+                    &mut load,\n+                    &self.config.cargo(),\n+                ));\n             }\n             crate_graph\n         };"}, {"sha": "1de801e23e5c861c6e80e9dab1231332e4244e72", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -83,10 +83,11 @@ pub(crate) fn structure_node_kind(kind: StructureNodeKind) -> lsp_types::SymbolK\n \n pub(crate) fn document_highlight_kind(\n     category: ReferenceCategory,\n-) -> lsp_types::DocumentHighlightKind {\n+) -> Option<lsp_types::DocumentHighlightKind> {\n     match category {\n-        ReferenceCategory::Read => lsp_types::DocumentHighlightKind::READ,\n-        ReferenceCategory::Write => lsp_types::DocumentHighlightKind::WRITE,\n+        ReferenceCategory::Read => Some(lsp_types::DocumentHighlightKind::READ),\n+        ReferenceCategory::Write => Some(lsp_types::DocumentHighlightKind::WRITE),\n+        ReferenceCategory::Import => None,\n     }\n }\n "}, {"sha": "996d4c023d7b2a04799033a96af490c27662b709", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -46,6 +46,12 @@ cargo check --quiet --workspace --message-format=json --all-targets\n Use `RUSTC_WRAPPER=rust-analyzer` when running build scripts to\n avoid checking unnecessary things.\n --\n+[[rust-analyzer.cargo.extraEnv]]rust-analyzer.cargo.extraEnv (default: `{}`)::\n++\n+--\n+Extra environment variables that will be set when running cargo, rustc\n+or other commands within the workspace. Useful for setting RUSTFLAGS.\n+--\n [[rust-analyzer.cargo.features]]rust-analyzer.cargo.features (default: `[]`)::\n +\n --\n@@ -93,6 +99,11 @@ Run specified `cargo check` command for diagnostics on save.\n --\n Extra arguments for `cargo check`.\n --\n+[[rust-analyzer.checkOnSave.extraEnv]]rust-analyzer.checkOnSave.extraEnv (default: `{}`)::\n++\n+--\n+Extra environment variables that will be set when running `cargo check`.\n+--\n [[rust-analyzer.checkOnSave.features]]rust-analyzer.checkOnSave.features (default: `null`)::\n +\n --\n@@ -353,6 +364,11 @@ Group inserted imports by the https://rust-analyzer.github.io/manual.html#auto-i\n --\n Whether to allow import insertion to merge new imports into single path glob imports like `use std::fmt::*;`.\n --\n+[[rust-analyzer.imports.prefer.no.std]]rust-analyzer.imports.prefer.no.std (default: `false`)::\n++\n+--\n+Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\n+--\n [[rust-analyzer.imports.prefix]]rust-analyzer.imports.prefix (default: `\"plain\"`)::\n +\n --\n@@ -474,6 +490,11 @@ client doesn't set the corresponding capability.\n Whether to show `Implementations` lens. Only applies when\n `#rust-analyzer.lens.enable#` is set.\n --\n+[[rust-analyzer.lens.location]]rust-analyzer.lens.location (default: `\"above_name\"`)::\n++\n+--\n+Where to render annotations.\n+--\n [[rust-analyzer.lens.references.adt.enable]]rust-analyzer.lens.references.adt.enable (default: `false`)::\n +\n --\n@@ -546,6 +567,11 @@ This config takes a map of crate names with the exported proc-macro names to ign\n Internal config, path to proc-macro server executable (typically,\n this is rust-analyzer itself, but we override this in tests).\n --\n+[[rust-analyzer.references.excludeImports]]rust-analyzer.references.excludeImports (default: `false`)::\n++\n+--\n+Exclude imports from find-all-references.\n+--\n [[rust-analyzer.runnables.command]]rust-analyzer.runnables.command (default: `null`)::\n +\n --"}, {"sha": "94b41c049bc3008214ae934fbf88815e67f93d07", "filename": "editors/code/package.json", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -206,11 +206,6 @@\n                 \"title\": \"Show RA Version\",\n                 \"category\": \"rust-analyzer\"\n             },\n-            {\n-                \"command\": \"rust-analyzer.toggleInlayHints\",\n-                \"title\": \"Toggle inlay hints\",\n-                \"category\": \"rust-analyzer\"\n-            },\n             {\n                 \"command\": \"rust-analyzer.openDocs\",\n                 \"title\": \"Open docs under cursor\",\n@@ -442,6 +437,11 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.cargo.extraEnv\": {\n+                    \"markdownDescription\": \"Extra environment variables that will be set when running cargo, rustc\\nor other commands within the workspace. Useful for setting RUSTFLAGS.\",\n+                    \"default\": {},\n+                    \"type\": \"object\"\n+                },\n                 \"rust-analyzer.cargo.features\": {\n                     \"markdownDescription\": \"List of features to activate.\\n\\nSet this to `\\\"all\\\"` to pass `--all-features` to cargo.\",\n                     \"default\": [],\n@@ -514,6 +514,11 @@\n                         \"type\": \"string\"\n                     }\n                 },\n+                \"rust-analyzer.checkOnSave.extraEnv\": {\n+                    \"markdownDescription\": \"Extra environment variables that will be set when running `cargo check`.\",\n+                    \"default\": {},\n+                    \"type\": \"object\"\n+                },\n                 \"rust-analyzer.checkOnSave.features\": {\n                     \"markdownDescription\": \"List of features to activate. Defaults to\\n`#rust-analyzer.cargo.features#`.\\n\\nSet to `\\\"all\\\"` to pass `--all-features` to Cargo.\",\n                     \"default\": null,\n@@ -803,6 +808,11 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.imports.prefer.no.std\": {\n+                    \"markdownDescription\": \"Prefer to unconditionally use imports of the core and alloc crate, over the std crate.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.imports.prefix\": {\n                     \"markdownDescription\": \"The path structure for newly inserted paths to use.\",\n                     \"default\": \"plain\",\n@@ -963,6 +973,19 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.lens.location\": {\n+                    \"markdownDescription\": \"Where to render annotations.\",\n+                    \"default\": \"above_name\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"above_name\",\n+                        \"above_whole_item\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"Render annotations above the name of the item.\",\n+                        \"Render annotations above the whole item, including documentation comments and attributes.\"\n+                    ]\n+                },\n                 \"rust-analyzer.lens.references.adt.enable\": {\n                     \"markdownDescription\": \"Whether to show `References` lens for Struct, Enum, and Union.\\nOnly applies when `#rust-analyzer.lens.enable#` is set.\",\n                     \"default\": false,\n@@ -1036,6 +1059,11 @@\n                         \"string\"\n                     ]\n                 },\n+                \"rust-analyzer.references.excludeImports\": {\n+                    \"markdownDescription\": \"Exclude imports from find-all-references.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.runnables.command\": {\n                     \"markdownDescription\": \"Command to be executed instead of 'cargo' for runnables.\",\n                     \"default\": null,\n@@ -1633,10 +1661,6 @@\n                     \"command\": \"rust-analyzer.serverVersion\",\n                     \"when\": \"inRustProject\"\n                 },\n-                {\n-                    \"command\": \"rust-analyzer.toggleInlayHints\",\n-                    \"when\": \"inRustProject\"\n-                },\n                 {\n                     \"command\": \"rust-analyzer.openDocs\",\n                     \"when\": \"inRustProject\""}, {"sha": "b9ad525e361f0e20e5807ac9d2b24ab306d4f716", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -321,30 +321,6 @@ export function serverVersion(ctx: Ctx): Cmd {\n     };\n }\n \n-export function toggleInlayHints(_ctx: Ctx): Cmd {\n-    return async () => {\n-        const config = vscode.workspace.getConfiguration(\"editor.inlayHints\", {\n-            languageId: \"rust\",\n-        });\n-\n-        const value = config.get(\"enabled\");\n-        let stringValue;\n-        if (typeof value === \"string\") {\n-            stringValue = value;\n-        } else {\n-            stringValue = value ? \"on\" : \"off\";\n-        }\n-        const nextValues: Record<string, string> = {\n-            on: \"off\",\n-            off: \"on\",\n-            onUnlessPressed: \"offUnlessPressed\",\n-            offUnlessPressed: \"onUnlessPressed\",\n-        };\n-        const nextValue = nextValues[stringValue] ?? \"on\";\n-        await config.update(\"enabled\", nextValue, vscode.ConfigurationTarget.Global);\n-    };\n-}\n-\n // Opens the virtual file that will show the syntax tree\n //\n // The contents of the file come from the `TextDocumentContentProvider`"}, {"sha": "41bde4195e07d254da0d5532101c140969c17dc2", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/969e25033bc150bd3811468cea59cb1edaf1382e/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/969e25033bc150bd3811468cea59cb1edaf1382e/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=969e25033bc150bd3811468cea59cb1edaf1382e", "patch": "@@ -180,7 +180,6 @@ async function initCommonContext(context: vscode.ExtensionContext, ctx: Ctx) {\n \n     ctx.registerCommand(\"ssr\", commands.ssr);\n     ctx.registerCommand(\"serverVersion\", commands.serverVersion);\n-    ctx.registerCommand(\"toggleInlayHints\", commands.toggleInlayHints);\n \n     // Internal commands which are invoked by the server.\n     ctx.registerCommand(\"runSingle\", commands.runSingle);"}]}