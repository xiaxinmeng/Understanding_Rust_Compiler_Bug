{"sha": "1d07c5bc25599a6b823db3c70db69519177b019c", "node_id": "C_kwDOAAsO6NoAKDFkMDdjNWJjMjU1OTlhNmI4MjNkYjNjNzBkYjY5NTE5MTc3YjAxOWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-28T11:09:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-28T11:09:27Z"}, "message": "Auto merge of #14218 - Veykril:root-dedup, r=Veykril\n\nDeduplicate source roots that have overlapping include paths\n\nFixes flycheck not working for the rustc workspace when using `linkedProjects`", "tree": {"sha": "0d0d1ee1e233e6afc815916841c50290b66bf140", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d0d1ee1e233e6afc815916841c50290b66bf140"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d07c5bc25599a6b823db3c70db69519177b019c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d07c5bc25599a6b823db3c70db69519177b019c", "html_url": "https://github.com/rust-lang/rust/commit/1d07c5bc25599a6b823db3c70db69519177b019c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d07c5bc25599a6b823db3c70db69519177b019c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c386316fe0aae4f49a76dec8c81c0bd560c50e77", "url": "https://api.github.com/repos/rust-lang/rust/commits/c386316fe0aae4f49a76dec8c81c0bd560c50e77", "html_url": "https://github.com/rust-lang/rust/commit/c386316fe0aae4f49a76dec8c81c0bd560c50e77"}, {"sha": "47a567b833b19a1e2f7e487e9a17d1e8da81b44e", "url": "https://api.github.com/repos/rust-lang/rust/commits/47a567b833b19a1e2f7e487e9a17d1e8da81b44e", "html_url": "https://github.com/rust-lang/rust/commit/47a567b833b19a1e2f7e487e9a17d1e8da81b44e"}], "stats": {"total": 189, "additions": 135, "deletions": 54}, "files": [{"sha": "19800224db604ade33ed01568924476319a9bfcd", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1d07c5bc25599a6b823db3c70db69519177b019c/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d07c5bc25599a6b823db3c70db69519177b019c/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=1d07c5bc25599a6b823db3c70db69519177b019c", "patch": "@@ -76,7 +76,7 @@ impl fmt::Display for FlycheckConfig {\n #[derive(Debug)]\n pub struct FlycheckHandle {\n     // XXX: drop order is significant\n-    sender: Sender<Restart>,\n+    sender: Sender<StateChange>,\n     _thread: jod_thread::JoinHandle,\n     id: usize,\n }\n@@ -89,7 +89,7 @@ impl FlycheckHandle {\n         workspace_root: AbsPathBuf,\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n-        let (sender, receiver) = unbounded::<Restart>();\n+        let (sender, receiver) = unbounded::<StateChange>();\n         let thread = jod_thread::Builder::new()\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n@@ -99,12 +99,12 @@ impl FlycheckHandle {\n \n     /// Schedule a re-start of the cargo check worker.\n     pub fn restart(&self) {\n-        self.sender.send(Restart::Yes).unwrap();\n+        self.sender.send(StateChange::Restart).unwrap();\n     }\n \n     /// Stop this cargo check worker.\n     pub fn cancel(&self) {\n-        self.sender.send(Restart::No).unwrap();\n+        self.sender.send(StateChange::Cancel).unwrap();\n     }\n \n     pub fn id(&self) -> usize {\n@@ -149,9 +149,9 @@ pub enum Progress {\n     DidFailToRestart(String),\n }\n \n-enum Restart {\n-    Yes,\n-    No,\n+enum StateChange {\n+    Restart,\n+    Cancel,\n }\n \n /// A [`FlycheckActor`] is a single check instance of a workspace.\n@@ -172,7 +172,7 @@ struct FlycheckActor {\n }\n \n enum Event {\n-    Restart(Restart),\n+    RequestStateChange(StateChange),\n     CheckEvent(Option<CargoMessage>),\n }\n \n@@ -191,30 +191,31 @@ impl FlycheckActor {\n         self.send(Message::Progress { id: self.id, progress });\n     }\n \n-    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n+    fn next_event(&self, inbox: &Receiver<StateChange>) -> Option<Event> {\n         let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n         if let Ok(msg) = inbox.try_recv() {\n             // give restarts a preference so check outputs don't block a restart or stop\n-            return Some(Event::Restart(msg));\n+            return Some(Event::RequestStateChange(msg));\n         }\n         select! {\n-            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n+            recv(inbox) -> msg => msg.ok().map(Event::RequestStateChange),\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n         }\n     }\n \n-    fn run(mut self, inbox: Receiver<Restart>) {\n+    fn run(mut self, inbox: Receiver<StateChange>) {\n         'event: while let Some(event) = self.next_event(&inbox) {\n             match event {\n-                Event::Restart(Restart::No) => {\n+                Event::RequestStateChange(StateChange::Cancel) => {\n+                    tracing::debug!(flycheck_id = self.id, \"flycheck cancelled\");\n                     self.cancel_check_process();\n                 }\n-                Event::Restart(Restart::Yes) => {\n+                Event::RequestStateChange(StateChange::Restart) => {\n                     // Cancel the previously spawned process\n                     self.cancel_check_process();\n                     while let Ok(restart) = inbox.recv_timeout(Duration::from_millis(50)) {\n                         // restart chained with a stop, so just cancel\n-                        if let Restart::No = restart {\n+                        if let StateChange::Cancel = restart {\n                             continue 'event;\n                         }\n                     }\n@@ -255,10 +256,20 @@ impl FlycheckActor {\n                 }\n                 Event::CheckEvent(Some(message)) => match message {\n                     CargoMessage::CompilerArtifact(msg) => {\n+                        tracing::trace!(\n+                            flycheck_id = self.id,\n+                            artifact = msg.target.name,\n+                            \"artifact received\"\n+                        );\n                         self.report_progress(Progress::DidCheckCrate(msg.target.name));\n                     }\n \n                     CargoMessage::Diagnostic(msg) => {\n+                        tracing::trace!(\n+                            flycheck_id = self.id,\n+                            message = msg.message,\n+                            \"diagnostic received\"\n+                        );\n                         self.send(Message::AddDiagnostic {\n                             id: self.id,\n                             workspace_root: self.root.clone(),"}, {"sha": "45cb896196157d143cb6ef8b7583f767bc1a868c", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1d07c5bc25599a6b823db3c70db69519177b019c/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d07c5bc25599a6b823db3c70db69519177b019c/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=1d07c5bc25599a6b823db3c70db69519177b019c", "patch": "@@ -237,7 +237,7 @@ impl ProjectWorkspace {\n                 };\n \n                 if let Some(sysroot) = &sysroot {\n-                    tracing::info!(src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n+                    tracing::info!(workspace = %cargo_toml.display(), src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n                 }\n \n                 let rustc_dir = match &config.rustc_source {\n@@ -247,27 +247,31 @@ impl ProjectWorkspace {\n                     }\n                     None => None,\n                 };\n-                if let Some(rustc_dir) = &rustc_dir {\n-                    tracing::info!(rustc_dir = %rustc_dir.display(), \"Using rustc source\");\n-                }\n \n                 let rustc = match rustc_dir {\n-                    Some(rustc_dir) => match CargoWorkspace::fetch_metadata(\n-                        &rustc_dir,\n-                        cargo_toml.parent(),\n-                        config,\n-                        progress,\n-                    ) {\n-                        Ok(meta) => Some(CargoWorkspace::new(meta)),\n-                        Err(e) => {\n-                            tracing::error!(\n-                                %e,\n-                                \"Failed to read Cargo metadata from rustc source at {}\",\n-                                rustc_dir.display()\n-                            );\n-                            None\n+                    Some(rustc_dir) if rustc_dir == cargo_toml => {\n+                        tracing::info!(rustc_dir = %rustc_dir.display(), \"Workspace is the rustc workspace itself, not adding the rustc workspace separately\");\n+                        None\n+                    }\n+                    Some(rustc_dir) => {\n+                        tracing::info!(workspace = %cargo_toml.display(), rustc_dir = %rustc_dir.display(), \"Using rustc source\");\n+                        match CargoWorkspace::fetch_metadata(\n+                            &rustc_dir,\n+                            cargo_toml.parent(),\n+                            config,\n+                            progress,\n+                        ) {\n+                            Ok(meta) => Some(CargoWorkspace::new(meta)),\n+                            Err(e) => {\n+                                tracing::error!(\n+                                    %e,\n+                                    \"Failed to read Cargo metadata from rustc source at {}\",\n+                                    rustc_dir.display()\n+                                );\n+                                None\n+                            }\n                         }\n-                    },\n+                    }\n                     None => None,\n                 };\n "}, {"sha": "0d75607f35d8684dca007eb1c3416345d68555ee", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1d07c5bc25599a6b823db3c70db69519177b019c/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d07c5bc25599a6b823db3c70db69519177b019c/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=1d07c5bc25599a6b823db3c70db69519177b019c", "patch": "@@ -854,27 +854,27 @@ impl Config {\n     }\n     pub fn linked_projects(&self) -> Vec<LinkedProject> {\n         match self.data.linkedProjects.as_slice() {\n-            [] => match self.discovered_projects.as_ref() {\n-                Some(discovered_projects) => {\n-                    let exclude_dirs: Vec<_> = self\n-                        .data\n-                        .files_excludeDirs\n+            [] => {\n+                match self.discovered_projects.as_ref() {\n+                    Some(discovered_projects) => {\n+                        let exclude_dirs: Vec<_> = self\n+                            .data\n+                            .files_excludeDirs\n+                            .iter()\n+                            .map(|p| self.root_path.join(p))\n+                            .collect();\n+                        discovered_projects\n                         .iter()\n-                        .map(|p| self.root_path.join(p))\n-                        .collect();\n-                    discovered_projects\n-                        .iter()\n-                        .filter(|p| {\n-                            let (ProjectManifest::ProjectJson(path)\n-                            | ProjectManifest::CargoToml(path)) = p;\n+                        .filter(|(ProjectManifest::ProjectJson(path) | ProjectManifest::CargoToml(path))| {\n                             !exclude_dirs.iter().any(|p| path.starts_with(p))\n                         })\n                         .cloned()\n                         .map(LinkedProject::from)\n                         .collect()\n+                    }\n+                    None => Vec::new(),\n                 }\n-                None => Vec::new(),\n-            },\n+            }\n             linked_projects => linked_projects\n                 .iter()\n                 .filter_map(|linked_project| match linked_project {"}, {"sha": "1a396bb06a3dbdf107b6303d9e401bebe4adcb2f", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1d07c5bc25599a6b823db3c70db69519177b019c/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d07c5bc25599a6b823db3c70db69519177b019c/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=1d07c5bc25599a6b823db3c70db69519177b019c", "patch": "@@ -12,17 +12,21 @@\n //! correct. Instead, we try to provide a best-effort service. Even if the\n //! project is currently loading and we don't have a full project model, we\n //! still want to respond to various  requests.\n-use std::{mem, sync::Arc};\n+use std::{collections::hash_map::Entry, mem, sync::Arc};\n \n use flycheck::{FlycheckConfig, FlycheckHandle};\n use hir::db::DefDatabase;\n use ide::Change;\n-use ide_db::base_db::{\n-    CrateGraph, Env, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacroKind,\n-    ProcMacroLoadResult, SourceRoot, VfsPath,\n+use ide_db::{\n+    base_db::{\n+        CrateGraph, Env, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacroKind,\n+        ProcMacroLoadResult, SourceRoot, VfsPath,\n+    },\n+    FxHashMap,\n };\n+use itertools::Itertools;\n use proc_macro_api::{MacroDylib, ProcMacroServer};\n-use project_model::{ProjectWorkspace, WorkspaceBuildScripts};\n+use project_model::{PackageRoot, ProjectWorkspace, WorkspaceBuildScripts};\n use syntax::SmolStr;\n use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n \n@@ -494,7 +498,69 @@ impl ProjectFolders {\n         let mut fsc = FileSetConfig::builder();\n         let mut local_filesets = vec![];\n \n-        for root in workspaces.iter().flat_map(|ws| ws.to_roots()) {\n+        // Dedup source roots\n+        // Depending on the project setup, we can have duplicated source roots, or for example in\n+        // the case of the rustc workspace, we can end up with two source roots that are almost the\n+        // same but not quite, like:\n+        // PackageRoot { is_local: false, include: [AbsPathBuf(\".../rust/src/tools/miri/cargo-miri\")], exclude: [] }\n+        // PackageRoot {\n+        //     is_local: true,\n+        //     include: [AbsPathBuf(\".../rust/src/tools/miri/cargo-miri\"), AbsPathBuf(\".../rust/build/x86_64-pc-windows-msvc/stage0-tools/x86_64-pc-windows-msvc/release/build/cargo-miri-85801cd3d2d1dae4/out\")],\n+        //     exclude: [AbsPathBuf(\".../rust/src/tools/miri/cargo-miri/.git\"), AbsPathBuf(\".../rust/src/tools/miri/cargo-miri/target\")]\n+        // }\n+        //\n+        // The first one comes from the explicit rustc workspace which points to the rustc workspace itself\n+        // The second comes from the rustc workspace that we load as the actual project workspace\n+        // These `is_local` differing in this kind of way gives us problems, especially when trying to filter diagnostics as we don't report diagnostics for external libraries.\n+        // So we need to deduplicate these, usually it would be enough to deduplicate by `include`, but as the rustc example shows here that doesn't work,\n+        // so we need to also coalesce the includes if they overlap.\n+\n+        let mut roots: Vec<_> = workspaces\n+            .iter()\n+            .flat_map(|ws| ws.to_roots())\n+            .update(|root| root.include.sort())\n+            .sorted_by(|a, b| a.include.cmp(&b.include))\n+            .collect();\n+\n+        // map that tracks indices of overlapping roots\n+        let mut overlap_map = FxHashMap::<_, Vec<_>>::default();\n+        let mut done = false;\n+\n+        while !mem::replace(&mut done, true) {\n+            // maps include paths to indices of the corresponding root\n+            let mut include_to_idx = FxHashMap::default();\n+            // Find and note down the indices of overlapping roots\n+            for (idx, root) in roots.iter().filter(|it| !it.include.is_empty()).enumerate() {\n+                for include in &root.include {\n+                    match include_to_idx.entry(include) {\n+                        Entry::Occupied(e) => {\n+                            overlap_map.entry(*e.get()).or_default().push(idx);\n+                        }\n+                        Entry::Vacant(e) => {\n+                            e.insert(idx);\n+                        }\n+                    }\n+                }\n+            }\n+            for (k, v) in overlap_map.drain() {\n+                done = false;\n+                for v in v {\n+                    let r = mem::replace(\n+                        &mut roots[v],\n+                        PackageRoot { is_local: false, include: vec![], exclude: vec![] },\n+                    );\n+                    roots[k].is_local |= r.is_local;\n+                    roots[k].include.extend(r.include);\n+                    roots[k].exclude.extend(r.exclude);\n+                }\n+                roots[k].include.sort();\n+                roots[k].exclude.sort();\n+                roots[k].include.dedup();\n+                roots[k].exclude.dedup();\n+            }\n+        }\n+\n+        for root in roots.into_iter().filter(|it| !it.include.is_empty()) {\n             let file_set_roots: Vec<VfsPath> =\n                 root.include.iter().cloned().map(VfsPath::from).collect();\n "}]}