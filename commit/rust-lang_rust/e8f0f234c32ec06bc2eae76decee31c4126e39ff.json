{"sha": "e8f0f234c32ec06bc2eae76decee31c4126e39ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZjBmMjM0YzMyZWMwNmJjMmVhZTc2ZGVjZWUzMWM0MTI2ZTM5ZmY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-31T16:04:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-31T16:04:54Z"}, "message": "Merge #10100\n\n10100: internal: cleanup proc macro server error handlig r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "047fcc5edb1c8a984e26e79c3d7dc6bc568a64f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/047fcc5edb1c8a984e26e79c3d7dc6bc568a64f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8f0f234c32ec06bc2eae76decee31c4126e39ff", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhLlMmCRBK7hj4Ov3rIwAAY4QIAEergczGd7hi5Hopjn54HXSi\nTUutwm6D1CrReqrFe92N3vmlgoUe7+YzpZHexkpUzDDFrNb9EVWcc84uuYOP2v+h\n82FoXYySxIS/M16bws1SaBGB1zfBHCM0BWkqyHODmdcE0xSSdK3yL6mcJ5WceFLU\n7PohHi0dsDN9hwIE9xXM56ElppvuLvoSGjPyloh3JoBonZHbGjxhykSHD+SxhiQV\ne4hQYF5BxRHbvjhJH2kUTwLWX3KARPlTd0NfsbnkJ1pboY+V2cM+NJKR3hMUtmT8\nXc6DwbkhVTVRDVljMmELc8PYYp9F0ILC/rXjMfJB2ZKebU6oJ/j7jxFUHD2blNY=\n=558F\n-----END PGP SIGNATURE-----\n", "payload": "tree 047fcc5edb1c8a984e26e79c3d7dc6bc568a64f6\nparent 2c538e9c8c622123853d94ac4827d6a41dded447\nparent d8a3d6f37890734e7bb273a4d6bf9e36fd2bbc74\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630425894 +0000\ncommitter GitHub <noreply@github.com> 1630425894 +0000\n\nMerge #10100\n\n10100: internal: cleanup proc macro server error handlig r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f0f234c32ec06bc2eae76decee31c4126e39ff", "html_url": "https://github.com/rust-lang/rust/commit/e8f0f234c32ec06bc2eae76decee31c4126e39ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8f0f234c32ec06bc2eae76decee31c4126e39ff/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c538e9c8c622123853d94ac4827d6a41dded447", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c538e9c8c622123853d94ac4827d6a41dded447", "html_url": "https://github.com/rust-lang/rust/commit/2c538e9c8c622123853d94ac4827d6a41dded447"}, {"sha": "d8a3d6f37890734e7bb273a4d6bf9e36fd2bbc74", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8a3d6f37890734e7bb273a4d6bf9e36fd2bbc74", "html_url": "https://github.com/rust-lang/rust/commit/d8a3d6f37890734e7bb273a4d6bf9e36fd2bbc74"}], "stats": {"total": 521, "additions": 246, "deletions": 275}, "files": [{"sha": "20c5ffaebd1c338155e038407b7e8781d78991e3", "filename": "crates/proc_macro_api/src/lib.rs", "status": "modified", "additions": 85, "deletions": 55, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Flib.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -7,25 +7,32 @@\n \n pub mod msg;\n mod process;\n-mod rpc;\n mod version;\n \n-use paths::{AbsPath, AbsPathBuf};\n+use paths::AbsPathBuf;\n use std::{\n     ffi::OsStr,\n-    io,\n+    fmt, io,\n     sync::{Arc, Mutex},\n };\n \n-use tt::{SmolStr, Subtree};\n+use serde::{Deserialize, Serialize};\n+use tt::Subtree;\n \n-use crate::process::ProcMacroProcessSrv;\n-\n-pub use rpc::{\n-    flat::FlatTree, ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind,\n+use crate::{\n+    msg::{ExpandMacro, FlatTree, PanicMessage},\n+    process::ProcMacroProcessSrv,\n };\n+\n pub use version::{read_dylib_info, RustCInfo};\n \n+#[derive(Copy, Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n+pub enum ProcMacroKind {\n+    CustomDerive,\n+    FuncLike,\n+    Attr,\n+}\n+\n /// A handle to an external process which load dylibs with macros (.so or .dll)\n /// and runs actual macro expansion functions.\n #[derive(Debug)]\n@@ -39,6 +46,26 @@ pub struct ProcMacroServer {\n     process: Arc<Mutex<ProcMacroProcessSrv>>,\n }\n \n+pub struct MacroDylib {\n+    path: AbsPathBuf,\n+}\n+\n+impl MacroDylib {\n+    // FIXME: this is buggy due to TOCTOU, we should check the version in the\n+    // macro process instead.\n+    pub fn new(path: AbsPathBuf) -> io::Result<MacroDylib> {\n+        let _p = profile::span(\"MacroDylib::new\");\n+\n+        let info = version::read_dylib_info(&path)?;\n+        if info.version.0 < 1 || info.version.1 < 47 {\n+            let msg = format!(\"proc-macro {} built by {:#?} is not supported by Rust Analyzer, please update your rust version.\", path.display(), info);\n+            return Err(io::Error::new(io::ErrorKind::InvalidData, msg));\n+        }\n+\n+        Ok(MacroDylib { path })\n+    }\n+}\n+\n /// A handle to a specific macro (a `#[proc_macro]` annotated function).\n ///\n /// It exists withing a context of a specific [`ProcMacroProcess`] -- currently\n@@ -47,7 +74,7 @@ pub struct ProcMacroServer {\n pub struct ProcMacro {\n     process: Arc<Mutex<ProcMacroProcessSrv>>,\n     dylib_path: AbsPathBuf,\n-    name: SmolStr,\n+    name: String,\n     kind: ProcMacroKind,\n }\n \n@@ -61,6 +88,25 @@ impl PartialEq for ProcMacro {\n     }\n }\n \n+pub struct ServerError {\n+    pub message: String,\n+    pub io: Option<io::Error>,\n+}\n+\n+impl fmt::Display for ServerError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.message)?;\n+        if let Some(io) = &self.io {\n+            write!(f, \": {}\", io)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+pub struct MacroPanic {\n+    pub message: String,\n+}\n+\n impl ProcMacroServer {\n     /// Spawns an external process as the proc macro server and returns a client connected to it.\n     pub fn spawn(\n@@ -71,45 +117,27 @@ impl ProcMacroServer {\n         Ok(ProcMacroServer { process: Arc::new(Mutex::new(process)) })\n     }\n \n-    pub fn load_dylib(&self, dylib_path: &AbsPath) -> Vec<ProcMacro> {\n+    pub fn load_dylib(\n+        &self,\n+        dylib: MacroDylib,\n+    ) -> Result<Result<Vec<ProcMacro>, String>, ServerError> {\n         let _p = profile::span(\"ProcMacroClient::by_dylib_path\");\n-        match version::read_dylib_info(dylib_path) {\n-            Ok(info) => {\n-                if info.version.0 < 1 || info.version.1 < 47 {\n-                    eprintln!(\"proc-macro {} built by {:#?} is not supported by Rust Analyzer, please update your rust version.\", dylib_path.display(), info);\n-                }\n-            }\n-            Err(err) => {\n-                eprintln!(\n-                    \"proc-macro {} failed to find the given version. Reason: {}\",\n-                    dylib_path.display(),\n-                    err\n-                );\n-            }\n-        }\n-\n-        let macros = match self\n-            .process\n-            .lock()\n-            .unwrap_or_else(|e| e.into_inner())\n-            .find_proc_macros(dylib_path)\n-        {\n-            Err(err) => {\n-                eprintln!(\"Failed to find proc macros. Error: {:#?}\", err);\n-                return vec![];\n-            }\n-            Ok(macros) => macros,\n-        };\n-\n-        macros\n-            .into_iter()\n-            .map(|(name, kind)| ProcMacro {\n-                process: self.process.clone(),\n-                name: name.into(),\n-                kind,\n-                dylib_path: dylib_path.to_path_buf(),\n-            })\n-            .collect()\n+        let macros =\n+            self.process.lock().unwrap_or_else(|e| e.into_inner()).find_proc_macros(&dylib.path)?;\n+\n+        let res = macros.map(|macros| {\n+            macros\n+                .into_iter()\n+                .map(|(name, kind)| ProcMacro {\n+                    process: self.process.clone(),\n+                    name: name.into(),\n+                    kind,\n+                    dylib_path: dylib.path.clone(),\n+                })\n+                .collect()\n+        });\n+\n+        Ok(res)\n     }\n }\n \n@@ -127,20 +155,22 @@ impl ProcMacro {\n         subtree: &Subtree,\n         attr: Option<&Subtree>,\n         env: Vec<(String, String)>,\n-    ) -> Result<Subtree, tt::ExpansionError> {\n-        let task = ExpansionTask {\n+    ) -> Result<Result<Subtree, PanicMessage>, ServerError> {\n+        let task = ExpandMacro {\n             macro_body: FlatTree::new(subtree),\n             macro_name: self.name.to_string(),\n             attributes: attr.map(FlatTree::new),\n             lib: self.dylib_path.to_path_buf().into(),\n             env,\n         };\n \n-        let result: ExpansionResult = self\n-            .process\n-            .lock()\n-            .unwrap_or_else(|e| e.into_inner())\n-            .send_task(msg::Request::ExpansionMacro(task))?;\n-        Ok(result.expansion.to_subtree())\n+        let request = msg::Request::ExpandMacro(task);\n+        let response = self.process.lock().unwrap_or_else(|e| e.into_inner()).send_task(request)?;\n+        match response {\n+            msg::Response::ExpandMacro(it) => Ok(it.map(|it| it.to_subtree())),\n+            msg::Response::ListMacros { .. } => {\n+                Err(ServerError { message: \"unexpected response\".to_string(), io: None })\n+            }\n+        }\n     }\n }"}, {"sha": "e9764a7dc6a0035cdff4ea7fdd7711a916984356", "filename": "crates/proc_macro_api/src/msg.rs", "status": "modified", "additions": 80, "deletions": 36, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -1,57 +1,53 @@\n //! Defines messages for cross-process message passing based on `ndjson` wire protocol\n+pub(crate) mod flat;\n \n use std::{\n-    convert::TryFrom,\n     io::{self, BufRead, Write},\n+    path::PathBuf,\n };\n \n use serde::{de::DeserializeOwned, Deserialize, Serialize};\n \n-use crate::{\n-    rpc::{ListMacrosResult, ListMacrosTask},\n-    ExpansionResult, ExpansionTask,\n-};\n+use crate::ProcMacroKind;\n+\n+pub use crate::msg::flat::FlatTree;\n \n #[derive(Debug, Serialize, Deserialize)]\n pub enum Request {\n-    ListMacro(ListMacrosTask),\n-    ExpansionMacro(ExpansionTask),\n+    ListMacros { dylib_path: PathBuf },\n+    ExpandMacro(ExpandMacro),\n }\n \n #[derive(Debug, Serialize, Deserialize)]\n pub enum Response {\n-    Error(ResponseError),\n-    ListMacro(ListMacrosResult),\n-    ExpansionMacro(ExpansionResult),\n-}\n-\n-macro_rules! impl_try_from_response {\n-    ($ty:ty, $tag:ident) => {\n-        impl TryFrom<Response> for $ty {\n-            type Error = &'static str;\n-            fn try_from(value: Response) -> Result<Self, Self::Error> {\n-                match value {\n-                    Response::$tag(res) => Ok(res),\n-                    _ => Err(concat!(\"Failed to convert response to \", stringify!($tag))),\n-                }\n-            }\n-        }\n-    };\n+    ListMacros(Result<Vec<(String, ProcMacroKind)>, String>),\n+    ExpandMacro(Result<FlatTree, PanicMessage>),\n }\n \n-impl_try_from_response!(ListMacrosResult, ListMacro);\n-impl_try_from_response!(ExpansionResult, ExpansionMacro);\n-\n-#[derive(Debug, Serialize, Deserialize, Clone)]\n-pub struct ResponseError {\n-    pub code: ErrorCode,\n-    pub message: String,\n-}\n+#[derive(Debug, Serialize, Deserialize)]\n+pub struct PanicMessage(pub String);\n \n-#[derive(Debug, Serialize, Deserialize, Clone)]\n-pub enum ErrorCode {\n-    ServerErrorEnd,\n-    ExpansionError,\n+#[derive(Debug, Serialize, Deserialize)]\n+pub struct ExpandMacro {\n+    /// Argument of macro call.\n+    ///\n+    /// In custom derive this will be a struct or enum; in attribute-like macro - underlying\n+    /// item; in function-like macro - the macro body.\n+    pub macro_body: FlatTree,\n+\n+    /// Name of macro to expand.\n+    ///\n+    /// In custom derive this is the name of the derived trait (`Serialize`, `Getters`, etc.).\n+    /// In attribute-like and function-like macros - single name of macro itself (`show_streams`).\n+    pub macro_name: String,\n+\n+    /// Possible attributes for the attribute-like macros.\n+    pub attributes: Option<FlatTree>,\n+\n+    pub lib: PathBuf,\n+\n+    /// Environment variables to set during macro expansion.\n+    pub env: Vec<(String, String)>,\n }\n \n pub trait Message: Serialize + DeserializeOwned {\n@@ -108,3 +104,51 @@ fn write_json(out: &mut impl Write, msg: &str) -> io::Result<()> {\n     out.flush()?;\n     Ok(())\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use tt::*;\n+\n+    fn fixture_token_tree() -> Subtree {\n+        let mut subtree = Subtree::default();\n+        subtree\n+            .token_trees\n+            .push(TokenTree::Leaf(Ident { text: \"struct\".into(), id: TokenId(0) }.into()));\n+        subtree\n+            .token_trees\n+            .push(TokenTree::Leaf(Ident { text: \"Foo\".into(), id: TokenId(1) }.into()));\n+        subtree.token_trees.push(TokenTree::Leaf(Leaf::Literal(Literal {\n+            text: \"Foo\".into(),\n+            id: TokenId::unspecified(),\n+        })));\n+        subtree.token_trees.push(TokenTree::Leaf(Leaf::Punct(Punct {\n+            char: '@',\n+            id: TokenId::unspecified(),\n+            spacing: Spacing::Joint,\n+        })));\n+        subtree.token_trees.push(TokenTree::Subtree(Subtree {\n+            delimiter: Some(Delimiter { id: TokenId(2), kind: DelimiterKind::Brace }),\n+            token_trees: vec![],\n+        }));\n+        subtree\n+    }\n+\n+    #[test]\n+    fn test_proc_macro_rpc_works() {\n+        let tt = fixture_token_tree();\n+        let task = ExpandMacro {\n+            macro_body: FlatTree::new(&tt),\n+            macro_name: Default::default(),\n+            attributes: None,\n+            lib: std::env::current_dir().unwrap(),\n+            env: Default::default(),\n+        };\n+\n+        let json = serde_json::to_string(&task).unwrap();\n+        // println!(\"{}\", json);\n+        let back: ExpandMacro = serde_json::from_str(&json).unwrap();\n+\n+        assert_eq!(tt, back.macro_body.to_subtree());\n+    }\n+}"}, {"sha": "d427fa87d23a8a1f088efaceb3039dcd52900f0f", "filename": "crates/proc_macro_api/src/msg/flat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_api%2Fsrc%2Fmsg%2Fflat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_api%2Fsrc%2Fmsg%2Fflat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fmsg%2Fflat.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "previous_filename": "crates/proc_macro_api/src/rpc/flat.rs"}, {"sha": "16741fc0ad1931c807cefc992eae67b9980ac224", "filename": "crates/proc_macro_api/src/process.rs", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -1,7 +1,6 @@\n //! Handle process life-time and message passing for proc-macro client\n \n use std::{\n-    convert::{TryFrom, TryInto},\n     ffi::{OsStr, OsString},\n     io::{self, BufRead, BufReader, Write},\n     process::{Child, ChildStdin, ChildStdout, Command, Stdio},\n@@ -11,8 +10,8 @@ use paths::{AbsPath, AbsPathBuf};\n use stdx::JodChild;\n \n use crate::{\n-    msg::{ErrorCode, Message, Request, Response, ResponseError},\n-    rpc::{ListMacrosResult, ListMacrosTask, ProcMacroKind},\n+    msg::{Message, Request, Response},\n+    ProcMacroKind, ServerError,\n };\n \n #[derive(Debug)]\n@@ -38,43 +37,23 @@ impl ProcMacroProcessSrv {\n     pub(crate) fn find_proc_macros(\n         &mut self,\n         dylib_path: &AbsPath,\n-    ) -> Result<Vec<(String, ProcMacroKind)>, tt::ExpansionError> {\n-        let task = ListMacrosTask { lib: dylib_path.to_path_buf().into() };\n+    ) -> Result<Result<Vec<(String, ProcMacroKind)>, String>, ServerError> {\n+        let request = Request::ListMacros { dylib_path: dylib_path.to_path_buf().into() };\n \n-        let result: ListMacrosResult = self.send_task(Request::ListMacro(task))?;\n-        Ok(result.macros)\n-    }\n+        let response = self.send_task(request)?;\n \n-    pub(crate) fn send_task<R>(&mut self, req: Request) -> Result<R, tt::ExpansionError>\n-    where\n-        R: TryFrom<Response, Error = &'static str>,\n-    {\n-        let mut buf = String::new();\n-        let res = match send_request(&mut self.stdin, &mut self.stdout, req, &mut buf) {\n-            Ok(res) => res,\n-            Err(err) => {\n-                let result = self.process.child.try_wait();\n-                tracing::error!(\n-                    \"proc macro server crashed, server process state: {:?}, server request error: {:?}\",\n-                    result,\n-                    err\n-                );\n-                let res = Response::Error(ResponseError {\n-                    code: ErrorCode::ServerErrorEnd,\n-                    message: \"proc macro server crashed\".into(),\n-                });\n-                Some(res)\n+        match response {\n+            Response::ListMacros(it) => Ok(it),\n+            Response::ExpandMacro { .. } => {\n+                Err(ServerError { message: \"unexpected response\".to_string(), io: None })\n             }\n-        };\n-\n-        match res {\n-            Some(Response::Error(err)) => Err(tt::ExpansionError::ExpansionError(err.message)),\n-            Some(res) => Ok(res.try_into().map_err(|err| {\n-                tt::ExpansionError::Unknown(format!(\"Fail to get response, reason : {:#?} \", err))\n-            })?),\n-            None => Err(tt::ExpansionError::Unknown(\"Empty result\".into())),\n         }\n     }\n+\n+    pub(crate) fn send_task(&mut self, req: Request) -> Result<Response, ServerError> {\n+        let mut buf = String::new();\n+        send_request(&mut self.stdin, &mut self.stdout, req, &mut buf)\n+    }\n }\n \n #[derive(Debug)]\n@@ -118,7 +97,10 @@ fn send_request(\n     mut reader: &mut impl BufRead,\n     req: Request,\n     buf: &mut String,\n-) -> io::Result<Option<Response>> {\n-    req.write(&mut writer)?;\n-    Response::read(&mut reader, buf)\n+) -> Result<Response, ServerError> {\n+    req.write(&mut writer)\n+        .map_err(|err| ServerError { message: \"failed to write request\".into(), io: Some(err) })?;\n+    let res = Response::read(&mut reader, buf)\n+        .map_err(|err| ServerError { message: \"failed to read response\".into(), io: Some(err) })?;\n+    res.ok_or_else(|| ServerError { message: \"server exited\".into(), io: None })\n }"}, {"sha": "31d0aa56d3b77ed6de94667f427258994b9373cc", "filename": "crates/proc_macro_api/src/rpc.rs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c538e9c8c622123853d94ac4827d6a41dded447/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs?ref=2c538e9c8c622123853d94ac4827d6a41dded447", "patch": "@@ -1,107 +0,0 @@\n-//! Data structure serialization related stuff for RPC\n-//!\n-//! Defines all necessary rpc serialization data structures,\n-//! which includes `tt` related data and some task messages.\n-//! Although adding `Serialize` and `Deserialize` traits to `tt` directly seems\n-//! to be much easier, we deliberately duplicate `tt` structs with `#[serde(with = \"XXDef\")]`\n-//! for separation of code responsibility.\n-pub(crate) mod flat;\n-\n-use std::path::PathBuf;\n-\n-use serde::{Deserialize, Serialize};\n-\n-use crate::rpc::flat::FlatTree;\n-\n-#[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n-pub struct ListMacrosTask {\n-    pub lib: PathBuf,\n-}\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n-pub enum ProcMacroKind {\n-    CustomDerive,\n-    FuncLike,\n-    Attr,\n-}\n-\n-#[derive(Clone, Eq, PartialEq, Debug, Default, Serialize, Deserialize)]\n-pub struct ListMacrosResult {\n-    pub macros: Vec<(String, ProcMacroKind)>,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize)]\n-pub struct ExpansionTask {\n-    /// Argument of macro call.\n-    ///\n-    /// In custom derive this will be a struct or enum; in attribute-like macro - underlying\n-    /// item; in function-like macro - the macro body.\n-    pub macro_body: FlatTree,\n-\n-    /// Name of macro to expand.\n-    ///\n-    /// In custom derive this is the name of the derived trait (`Serialize`, `Getters`, etc.).\n-    /// In attribute-like and function-like macros - single name of macro itself (`show_streams`).\n-    pub macro_name: String,\n-\n-    /// Possible attributes for the attribute-like macros.\n-    pub attributes: Option<FlatTree>,\n-\n-    pub lib: PathBuf,\n-\n-    /// Environment variables to set during macro expansion.\n-    pub env: Vec<(String, String)>,\n-}\n-\n-#[derive(Debug, Serialize, Deserialize)]\n-pub struct ExpansionResult {\n-    pub expansion: FlatTree,\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use tt::*;\n-\n-    fn fixture_token_tree() -> Subtree {\n-        let mut subtree = Subtree::default();\n-        subtree\n-            .token_trees\n-            .push(TokenTree::Leaf(Ident { text: \"struct\".into(), id: TokenId(0) }.into()));\n-        subtree\n-            .token_trees\n-            .push(TokenTree::Leaf(Ident { text: \"Foo\".into(), id: TokenId(1) }.into()));\n-        subtree.token_trees.push(TokenTree::Leaf(Leaf::Literal(Literal {\n-            text: \"Foo\".into(),\n-            id: TokenId::unspecified(),\n-        })));\n-        subtree.token_trees.push(TokenTree::Leaf(Leaf::Punct(Punct {\n-            char: '@',\n-            id: TokenId::unspecified(),\n-            spacing: Spacing::Joint,\n-        })));\n-        subtree.token_trees.push(TokenTree::Subtree(Subtree {\n-            delimiter: Some(Delimiter { id: TokenId(2), kind: DelimiterKind::Brace }),\n-            token_trees: vec![],\n-        }));\n-        subtree\n-    }\n-\n-    #[test]\n-    fn test_proc_macro_rpc_works() {\n-        let tt = fixture_token_tree();\n-        let task = ExpansionTask {\n-            macro_body: FlatTree::new(&tt),\n-            macro_name: Default::default(),\n-            attributes: None,\n-            lib: std::env::current_dir().unwrap(),\n-            env: Default::default(),\n-        };\n-\n-        let json = serde_json::to_string(&task).unwrap();\n-        // println!(\"{}\", json);\n-        let back: ExpansionTask = serde_json::from_str(&json).unwrap();\n-\n-        assert_eq!(tt, back.macro_body.to_subtree());\n-    }\n-}"}, {"sha": "b944143a07982c76eeecc2cbe5cbfe1e25ab6715", "filename": "crates/proc_macro_srv/src/abis/abi_1_47/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_47%2Fmod.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -7,8 +7,8 @@ mod proc_macro;\n #[allow(dead_code)]\n #[doc(hidden)]\n mod rustc_server;\n-use libloading::Library;\n \n+use libloading::Library;\n use proc_macro_api::ProcMacroKind;\n \n use super::PanicMessage;"}, {"sha": "81c55cf10c73d8b2092dd800d4f9bc02d3412424", "filename": "crates/proc_macro_srv/src/abis/abi_1_55/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_55%2Fmod.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -7,8 +7,8 @@ mod proc_macro;\n #[allow(dead_code)]\n #[doc(hidden)]\n mod rustc_server;\n-use libloading::Library;\n \n+use libloading::Library;\n use proc_macro_api::ProcMacroKind;\n \n use super::PanicMessage;"}, {"sha": "96b71d3f21892fa2653e5a72581453c7b12d9e23", "filename": "crates/proc_macro_srv/src/abis/abi_1_56/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fabis%2Fabi_1_56%2Fmod.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -7,8 +7,8 @@ mod proc_macro;\n #[allow(dead_code)]\n #[doc(hidden)]\n mod rustc_server;\n-use libloading::Library;\n \n+use libloading::Library;\n use proc_macro_api::ProcMacroKind;\n \n use super::PanicMessage;"}, {"sha": "f1e131c135d837afe8d86f61ca72d8a0b57ba9b9", "filename": "crates/proc_macro_srv/src/cli.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -1,31 +1,22 @@\n //! Driver for proc macro server\n+use std::io;\n \n-use crate::ProcMacroSrv;\n use proc_macro_api::msg::{self, Message};\n-use std::io;\n+\n+use crate::ProcMacroSrv;\n \n pub fn run() -> io::Result<()> {\n     let mut srv = ProcMacroSrv::default();\n     let mut buf = String::new();\n \n     while let Some(req) = read_request(&mut buf)? {\n         let res = match req {\n-            msg::Request::ListMacro(task) => srv.list_macros(&task).map(msg::Response::ListMacro),\n-            msg::Request::ExpansionMacro(task) => {\n-                srv.expand(task).map(msg::Response::ExpansionMacro)\n+            msg::Request::ListMacros { dylib_path } => {\n+                msg::Response::ListMacros(srv.list_macros(&dylib_path))\n             }\n+            msg::Request::ExpandMacro(task) => msg::Response::ExpandMacro(srv.expand(task)),\n         };\n-\n-        let msg = res.unwrap_or_else(|err| {\n-            msg::Response::Error(msg::ResponseError {\n-                code: msg::ErrorCode::ExpansionError,\n-                message: err,\n-            })\n-        });\n-\n-        if let Err(err) = write_response(msg) {\n-            eprintln!(\"Write message error: {}\", err);\n-        }\n+        write_response(res)?\n     }\n \n     Ok(())"}, {"sha": "6f3943870e694c2934f7547f89216936d741982b", "filename": "crates/proc_macro_srv/src/lib.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -12,25 +12,31 @@\n #![allow(unreachable_pub)]\n \n mod dylib;\n-\n mod abis;\n \n-use proc_macro_api::{ExpansionResult, ExpansionTask, FlatTree, ListMacrosResult, ListMacrosTask};\n use std::{\n     collections::{hash_map::Entry, HashMap},\n     env, fs,\n     path::{Path, PathBuf},\n     time::SystemTime,\n };\n \n+use proc_macro_api::{\n+    msg::{ExpandMacro, FlatTree, PanicMessage},\n+    ProcMacroKind,\n+};\n+\n #[derive(Default)]\n pub(crate) struct ProcMacroSrv {\n     expanders: HashMap<(PathBuf, SystemTime), dylib::Expander>,\n }\n \n impl ProcMacroSrv {\n-    pub fn expand(&mut self, task: ExpansionTask) -> Result<ExpansionResult, String> {\n-        let expander = self.expander(task.lib.as_ref())?;\n+    pub fn expand(&mut self, task: ExpandMacro) -> Result<FlatTree, PanicMessage> {\n+        let expander = self.expander(task.lib.as_ref()).map_err(|err| {\n+            debug_assert!(false, \"should list macros before asking to expand\");\n+            PanicMessage(format!(\"failed to load macro: {}\", err))\n+        })?;\n \n         let mut prev_env = HashMap::new();\n         for (k, v) in &task.env {\n@@ -51,15 +57,15 @@ impl ProcMacroSrv {\n             }\n         }\n \n-        match result {\n-            Ok(expansion) => Ok(ExpansionResult { expansion }),\n-            Err(msg) => Err(format!(\"proc-macro panicked: {}\", msg)),\n-        }\n+        result.map_err(PanicMessage)\n     }\n \n-    pub fn list_macros(&mut self, task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n-        let expander = self.expander(task.lib.as_ref())?;\n-        Ok(ListMacrosResult { macros: expander.list_macros() })\n+    pub(crate) fn list_macros(\n+        &mut self,\n+        dylib_path: &Path,\n+    ) -> Result<Vec<(String, ProcMacroKind)>, String> {\n+        let expander = self.expander(dylib_path)?;\n+        Ok(expander.list_macros())\n     }\n \n     fn expander(&mut self, path: &Path) -> Result<&dylib::Expander, String> {"}, {"sha": "f8cbf70b619a26642e187f21c79831ee695ddfea", "filename": "crates/proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -3,7 +3,6 @@\n use crate::dylib;\n use crate::ProcMacroSrv;\n use expect_test::Expect;\n-use proc_macro_api::ListMacrosTask;\n use std::str::FromStr;\n \n pub mod fixtures {\n@@ -40,9 +39,9 @@ fn assert_expand_impl(macro_name: &str, input: &str, attr: Option<&str>, expect:\n     expect.assert_eq(&format!(\"{:?}\", res));\n }\n \n-pub fn list() -> Vec<String> {\n-    let task = ListMacrosTask { lib: fixtures::proc_macro_test_dylib_path() };\n+pub(crate) fn list() -> Vec<String> {\n+    let dylib_path = fixtures::proc_macro_test_dylib_path();\n     let mut srv = ProcMacroSrv::default();\n-    let res = srv.list_macros(&task).unwrap();\n-    res.macros.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()\n+    let res = srv.list_macros(&dylib_path).unwrap();\n+    res.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()\n }"}, {"sha": "0a1226af5ea07b968df770f90becd63c18190156", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f0f234c32ec06bc2eae76decee31c4126e39ff/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=e8f0f234c32ec06bc2eae76decee31c4126e39ff", "patch": "@@ -7,7 +7,7 @@ use ide::Change;\n use ide_db::base_db::{\n     CrateGraph, Env, ProcMacro, ProcMacroExpander, ProcMacroKind, SourceRoot, VfsPath,\n };\n-use proc_macro_api::ProcMacroServer;\n+use proc_macro_api::{MacroDylib, ProcMacroServer};\n use project_model::{ProjectWorkspace, WorkspaceBuildScripts};\n use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n \n@@ -557,10 +557,32 @@ impl SourceRootConfig {\n }\n \n pub(crate) fn load_proc_macro(client: Option<&ProcMacroServer>, path: &AbsPath) -> Vec<ProcMacro> {\n+    let dylib = match MacroDylib::new(path.to_path_buf()) {\n+        Ok(it) => it,\n+        Err(err) => {\n+            // FIXME: that's not really right -- we store this error in a\n+            // persistent status.\n+            tracing::warn!(\"failed to load proc macro: {}\", err);\n+            return Vec::new();\n+        }\n+    };\n+\n     return client\n-        .map(|it| it.load_dylib(path))\n-        .unwrap_or_default()\n+        .map(|it| it.load_dylib(dylib))\n         .into_iter()\n+        .flat_map(|it| match it {\n+            Ok(Ok(macros)) => macros,\n+            Err(err) => {\n+                tracing::error!(\"proc macro server crashed: {}\", err);\n+                Vec::new()\n+            }\n+            Ok(Err(err)) => {\n+                // FIXME: that's not really right -- we store this error in a\n+                // persistent status.\n+                tracing::warn!(\"failed to load proc macro: {}\", err);\n+                Vec::new()\n+            }\n+        })\n         .map(expander_to_proc_macro)\n         .collect();\n \n@@ -586,7 +608,11 @@ pub(crate) fn load_proc_macro(client: Option<&ProcMacroServer>, path: &AbsPath)\n             env: &Env,\n         ) -> Result<tt::Subtree, tt::ExpansionError> {\n             let env = env.iter().map(|(k, v)| (k.to_string(), v.to_string())).collect();\n-            self.0.expand(subtree, attrs, env)\n+            match self.0.expand(subtree, attrs, env) {\n+                Ok(Ok(subtree)) => Ok(subtree),\n+                Ok(Err(err)) => Err(tt::ExpansionError::ExpansionError(err.0)),\n+                Err(err) => Err(tt::ExpansionError::Unknown(err.to_string())),\n+            }\n         }\n     }\n }"}]}