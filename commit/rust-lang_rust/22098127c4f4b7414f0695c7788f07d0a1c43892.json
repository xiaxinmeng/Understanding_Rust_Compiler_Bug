{"sha": "22098127c4f4b7414f0695c7788f07d0a1c43892", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMDk4MTI3YzRmNGI3NDE0ZjA2OTVjNzc4OGYwN2QwYTFjNDM4OTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T15:22:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-25T15:22:18Z"}, "message": "Move request dispatcher to a separate file", "tree": {"sha": "9e3bba5041c7afa181625ac1ddc5cb4b77cd519f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e3bba5041c7afa181625ac1ddc5cb4b77cd519f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22098127c4f4b7414f0695c7788f07d0a1c43892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22098127c4f4b7414f0695c7788f07d0a1c43892", "html_url": "https://github.com/rust-lang/rust/commit/22098127c4f4b7414f0695c7788f07d0a1c43892", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22098127c4f4b7414f0695c7788f07d0a1c43892/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "379a096de9ad06c23347b76a54d9cc22aee80f6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/379a096de9ad06c23347b76a54d9cc22aee80f6a", "html_url": "https://github.com/rust-lang/rust/commit/379a096de9ad06c23347b76a54d9cc22aee80f6a"}], "stats": {"total": 275, "additions": 146, "deletions": 129}, "files": [{"sha": "0a9b0428d1bfdda5296954c915e2acb609c1cfee", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/22098127c4f4b7414f0695c7788f07d0a1c43892/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22098127c4f4b7414f0695c7788f07d0a1c43892/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=22098127c4f4b7414f0695c7788f07d0a1c43892", "patch": "@@ -0,0 +1,137 @@\n+use std::{panic, time::Instant};\n+\n+use serde::{de::DeserializeOwned, Serialize};\n+\n+use crate::{\n+    global_state::{GlobalState, GlobalStateSnapshot},\n+    lsp_utils::is_canceled,\n+    main_loop::Task,\n+    LspError, Result,\n+};\n+\n+pub(crate) struct RequestDispatcher<'a> {\n+    pub(crate) req: Option<lsp_server::Request>,\n+    pub(crate) global_state: &'a mut GlobalState,\n+    pub(crate) request_received: Instant,\n+}\n+\n+impl<'a> RequestDispatcher<'a> {\n+    /// Dispatches the request onto the current thread\n+    pub(crate) fn on_sync<R>(\n+        &mut self,\n+        f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + panic::UnwindSafe + 'static,\n+        R::Result: Serialize + 'static,\n+    {\n+        let (id, params) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => {\n+                return Ok(self);\n+            }\n+        };\n+        let world = panic::AssertUnwindSafe(&mut *self.global_state);\n+        let task = panic::catch_unwind(move || {\n+            let result = f(world.0, params);\n+            result_to_task::<R>(id, result)\n+        })\n+        .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n+        self.global_state.on_task(task);\n+        Ok(self)\n+    }\n+\n+    /// Dispatches the request onto thread pool\n+    pub(crate) fn on<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + Send + 'static,\n+        R::Result: Serialize + 'static,\n+    {\n+        let (id, params) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => {\n+                return Ok(self);\n+            }\n+        };\n+\n+        self.global_state.task_pool.0.spawn({\n+            let world = self.global_state.snapshot();\n+            move || {\n+                let result = f(world, params);\n+                result_to_task::<R>(id, result)\n+            }\n+        });\n+\n+        Ok(self)\n+    }\n+\n+    pub(crate) fn finish(&mut self) {\n+        match self.req.take() {\n+            None => (),\n+            Some(req) => {\n+                log::error!(\"unknown request: {:?}\", req);\n+                let resp = lsp_server::Response::new_err(\n+                    req.id,\n+                    lsp_server::ErrorCode::MethodNotFound as i32,\n+                    \"unknown request\".to_string(),\n+                );\n+                self.global_state.send(resp.into());\n+            }\n+        }\n+    }\n+\n+    fn parse<R>(&mut self) -> Option<(lsp_server::RequestId, R::Params)>\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + 'static,\n+    {\n+        let req = self.req.take()?;\n+        let (id, params) = match req.extract::<R::Params>(R::METHOD) {\n+            Ok(it) => it,\n+            Err(req) => {\n+                self.req = Some(req);\n+                return None;\n+            }\n+        };\n+        self.global_state\n+            .req_queue\n+            .incoming\n+            .register(id.clone(), (R::METHOD, self.request_received));\n+        Some((id, params))\n+    }\n+}\n+\n+fn result_to_task<R>(id: lsp_server::RequestId, result: Result<R::Result>) -> Task\n+where\n+    R: lsp_types::request::Request + 'static,\n+    R::Params: DeserializeOwned + 'static,\n+    R::Result: Serialize + 'static,\n+{\n+    let response = match result {\n+        Ok(resp) => lsp_server::Response::new_ok(id, &resp),\n+        Err(e) => match e.downcast::<LspError>() {\n+            Ok(lsp_error) => lsp_server::Response::new_err(id, lsp_error.code, lsp_error.message),\n+            Err(e) => {\n+                if is_canceled(&*e) {\n+                    lsp_server::Response::new_err(\n+                        id,\n+                        lsp_server::ErrorCode::ContentModified as i32,\n+                        \"content modified\".to_string(),\n+                    )\n+                } else {\n+                    lsp_server::Response::new_err(\n+                        id,\n+                        lsp_server::ErrorCode::InternalError as i32,\n+                        e.to_string(),\n+                    )\n+                }\n+            }\n+        },\n+    };\n+    Task::Respond(response)\n+}"}, {"sha": "d503fe96e2d0382caf77293974158ea371832d58", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22098127c4f4b7414f0695c7788f07d0a1c43892/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22098127c4f4b7414f0695c7788f07d0a1c43892/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=22098127c4f4b7414f0695c7788f07d0a1c43892", "patch": "@@ -19,6 +19,7 @@ macro_rules! eprintln {\n \n mod global_state;\n mod main_loop;\n+mod dispatch;\n mod handlers;\n mod caps;\n mod cargo_target_spec;"}, {"sha": "ebc232736afa419f4e8dc415d1cd0d6fa24d6f55", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 8, "deletions": 129, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/22098127c4f4b7414f0695c7788f07d0a1c43892/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22098127c4f4b7414f0695c7788f07d0a1c43892/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=22098127c4f4b7414f0695c7788f07d0a1c43892", "patch": "@@ -6,26 +6,26 @@ use std::{\n };\n \n use crossbeam_channel::{never, select, Receiver};\n-use lsp_server::{Connection, ErrorCode, Notification, Request, RequestId, Response};\n+use lsp_server::{Connection, Notification, Request, RequestId, Response};\n use lsp_types::{notification::Notification as _, request::Request as _, NumberOrString};\n use ra_db::VfsPath;\n use ra_ide::{Canceled, FileId};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n-use serde::{de::DeserializeOwned, Serialize};\n \n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n     diagnostics::DiagnosticTask,\n+    dispatch::RequestDispatcher,\n     from_proto,\n-    global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot, Status},\n+    global_state::{file_id_to_url, GlobalState, Status},\n     handlers, lsp_ext,\n     lsp_utils::{\n         apply_document_changes, is_canceled, notification_cast, notification_is, notification_new,\n         show_message,\n     },\n     request_metrics::RequestMetrics,\n-    LspError, Result,\n+    Result,\n };\n \n pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n@@ -241,7 +241,7 @@ impl GlobalState {\n \n     fn on_request(&mut self, request_received: Instant, req: Request) -> Result<()> {\n         let mut pool_dispatcher =\n-            PoolDispatcher { req: Some(req), global_state: self, request_received };\n+            RequestDispatcher { req: Some(req), global_state: self, request_received };\n         pool_dispatcher\n             .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n             .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n@@ -426,7 +426,8 @@ impl GlobalState {\n         log::error!(\"unhandled notification: {:?}\", not);\n         Ok(())\n     }\n-    fn on_task(&mut self, task: Task) {\n+    // TODO\n+    pub(crate) fn on_task(&mut self, task: Task) {\n         match task {\n             Task::Respond(response) => {\n                 if let Some((method, start)) = self.req_queue.incoming.complete(response.id.clone())\n@@ -480,6 +481,7 @@ impl GlobalState {\n     }\n }\n \n+// TODO\n #[derive(Debug)]\n pub(crate) enum Task {\n     Respond(Response),\n@@ -645,126 +647,3 @@ fn report_progress(\n         });\n     global_state.send(notification.into());\n }\n-\n-struct PoolDispatcher<'a> {\n-    req: Option<Request>,\n-    global_state: &'a mut GlobalState,\n-    request_received: Instant,\n-}\n-\n-impl<'a> PoolDispatcher<'a> {\n-    /// Dispatches the request onto the current thread\n-    fn on_sync<R>(\n-        &mut self,\n-        f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n-    ) -> Result<&mut Self>\n-    where\n-        R: lsp_types::request::Request + 'static,\n-        R::Params: DeserializeOwned + panic::UnwindSafe + 'static,\n-        R::Result: Serialize + 'static,\n-    {\n-        let (id, params) = match self.parse::<R>() {\n-            Some(it) => it,\n-            None => {\n-                return Ok(self);\n-            }\n-        };\n-        let world = panic::AssertUnwindSafe(&mut *self.global_state);\n-        let task = panic::catch_unwind(move || {\n-            let result = f(world.0, params);\n-            result_to_task::<R>(id, result)\n-        })\n-        .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        self.global_state.on_task(task);\n-        Ok(self)\n-    }\n-\n-    /// Dispatches the request onto thread pool\n-    fn on<R>(\n-        &mut self,\n-        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n-    ) -> Result<&mut Self>\n-    where\n-        R: lsp_types::request::Request + 'static,\n-        R::Params: DeserializeOwned + Send + 'static,\n-        R::Result: Serialize + 'static,\n-    {\n-        let (id, params) = match self.parse::<R>() {\n-            Some(it) => it,\n-            None => {\n-                return Ok(self);\n-            }\n-        };\n-\n-        self.global_state.task_pool.0.spawn({\n-            let world = self.global_state.snapshot();\n-            move || {\n-                let result = f(world, params);\n-                result_to_task::<R>(id, result)\n-            }\n-        });\n-\n-        Ok(self)\n-    }\n-\n-    fn parse<R>(&mut self) -> Option<(RequestId, R::Params)>\n-    where\n-        R: lsp_types::request::Request + 'static,\n-        R::Params: DeserializeOwned + 'static,\n-    {\n-        let req = self.req.take()?;\n-        let (id, params) = match req.extract::<R::Params>(R::METHOD) {\n-            Ok(it) => it,\n-            Err(req) => {\n-                self.req = Some(req);\n-                return None;\n-            }\n-        };\n-        self.global_state\n-            .req_queue\n-            .incoming\n-            .register(id.clone(), (R::METHOD, self.request_received));\n-        Some((id, params))\n-    }\n-\n-    fn finish(&mut self) {\n-        match self.req.take() {\n-            None => (),\n-            Some(req) => {\n-                log::error!(\"unknown request: {:?}\", req);\n-                let resp = Response::new_err(\n-                    req.id,\n-                    ErrorCode::MethodNotFound as i32,\n-                    \"unknown request\".to_string(),\n-                );\n-                self.global_state.send(resp.into());\n-            }\n-        }\n-    }\n-}\n-\n-fn result_to_task<R>(id: RequestId, result: Result<R::Result>) -> Task\n-where\n-    R: lsp_types::request::Request + 'static,\n-    R::Params: DeserializeOwned + 'static,\n-    R::Result: Serialize + 'static,\n-{\n-    let response = match result {\n-        Ok(resp) => Response::new_ok(id, &resp),\n-        Err(e) => match e.downcast::<LspError>() {\n-            Ok(lsp_error) => Response::new_err(id, lsp_error.code, lsp_error.message),\n-            Err(e) => {\n-                if is_canceled(&*e) {\n-                    Response::new_err(\n-                        id,\n-                        ErrorCode::ContentModified as i32,\n-                        \"content modified\".to_string(),\n-                    )\n-                } else {\n-                    Response::new_err(id, ErrorCode::InternalError as i32, e.to_string())\n-                }\n-            }\n-        },\n-    };\n-    Task::Respond(response)\n-}"}]}