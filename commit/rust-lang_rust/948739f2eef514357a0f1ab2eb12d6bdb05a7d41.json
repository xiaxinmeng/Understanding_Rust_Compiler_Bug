{"sha": "948739f2eef514357a0f1ab2eb12d6bdb05a7d41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ODczOWYyZWVmNTE0MzU3YTBmMWFiMmViMTJkNmJkYjA1YTdkNDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-08-12T23:21:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-08-12T23:21:13Z"}, "message": "revamp comment", "tree": {"sha": "778890a8e5c21ab2395cdefb57dd9d9f48460c73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/778890a8e5c21ab2395cdefb57dd9d9f48460c73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/948739f2eef514357a0f1ab2eb12d6bdb05a7d41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/948739f2eef514357a0f1ab2eb12d6bdb05a7d41", "html_url": "https://github.com/rust-lang/rust/commit/948739f2eef514357a0f1ab2eb12d6bdb05a7d41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/948739f2eef514357a0f1ab2eb12d6bdb05a7d41/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03e7b9628199f5c82d083cd02116c4424a31f47f", "url": "https://api.github.com/repos/rust-lang/rust/commits/03e7b9628199f5c82d083cd02116c4424a31f47f", "html_url": "https://github.com/rust-lang/rust/commit/03e7b9628199f5c82d083cd02116c4424a31f47f"}], "stats": {"total": 76, "additions": 61, "deletions": 15}, "files": [{"sha": "8901738637453717f0b2898305cdb6ae3c45c02b", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/948739f2eef514357a0f1ab2eb12d6bdb05a7d41/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948739f2eef514357a0f1ab2eb12d6bdb05a7d41/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=948739f2eef514357a0f1ab2eb12d6bdb05a7d41", "patch": "@@ -2570,7 +2570,54 @@ impl<'a> LoweringContext<'a> {\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n+        // When we create the opaque type for this async fn, it is going to have\n+        // to capture all the lifetimes involved in the signature (including in the\n+        // return type). This is done by introducing lifetime parameters for:\n+        //\n+        // - all the explicitly declared lifetimes from the impl and function itself;\n+        // - all the elided lifetimes in the fn arguments;\n+        // - all the elided lifetimes in the return type.\n+        //\n+        // So for example in this snippet:\n+        //\n+        // ```rust\n+        // impl<'a> Foo<'a> {\n+        //   async fn bar<'b>(&self, x: &'b Vec<f64>, y: &str) -> &u32 {\n+        //   //               ^ '0                       ^ '1     ^ '2\n+        //   // elided lifetimes used below\n+        //   }\n+        // }\n+        // ```\n+        //\n+        // we would create an opaque type like:\n+        //\n+        // ```\n+        // type Bar<'a, 'b, '0, '1, '2> = impl Future<Output = &'2 u32>;\n+        // ```\n+        //\n+        // and we would then desugar `bar` to the equivalent of:\n+        //\n+        // ```rust\n+        // impl<'a> Foo<'a> {\n+        //   fn bar<'b, '0, '1>(&'0 self, x: &'b Vec<f64>, y: &'1 str) -> Bar<'a, 'b, '0, '1, '_>\n+        // }\n+        // ```\n+        //\n+        // Note that the final parameter to `Bar` is `'_`, not `'2` --\n+        // this is because the elided lifetimes from the return type\n+        // should be figured out using the ordinary elision rules, and\n+        // this desugaring achieves that.\n+        //\n+        // The variable `input_lifetimes_count` tracks the number of\n+        // lifetime parameters to the opaque type *not counting* those\n+        // lifetimes elided in the return type. This includes those\n+        // that are explicitly declared (`in_scope_lifetimes`) and\n+        // those elided lifetimes we found in the arguments (current\n+        // content of `lifetimes_to_define`). Next, we will process\n+        // the return type, which will cause `lifetimes_to_define` to\n+        // grow.\n         let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n+\n         let (opaque_ty_id, lifetime_params) = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n@@ -2635,29 +2682,27 @@ impl<'a> LoweringContext<'a> {\n             (opaque_ty_id, lifetime_params)\n         });\n \n-        // Create the generic lifetime arguments that we will supply\n-        // to the opaque return type. Consider:\n+        // As documented above on the variable\n+        // `input_lifetimes_count`, we need to create the lifetime\n+        // arguments to our opaque type. Continuing with our example,\n+        // we're creating the type arguments for the return type:\n         //\n-        // ```rust\n-        // async fn foo(x: &u32, ) -> &[&u32] { .. }\n         // ```\n-        //\n-        // Here, we would create something like:\n-        //\n-        // ```rust\n-        // type Foo<'a, 'b, 'c> = impl Future<Output = &'a [&'b u32]>;\n-        // fn foo<'a>(x: &'a u32) -> Foo<'a, '_, '_>\n+        // Bar<'a, 'b, '0, '1, '_>\n         // ```\n         //\n-        // Note that for the lifetimes which came from the input\n-        // (`'a`, here), we supply them as arguments to the return\n-        // type `Foo`. But for those lifetime parameters (`'b`, `'c`)\n-        // that we created from the return type, we want to use `'_`\n-        // in the return type, so as to trigger elision.\n+        // For the \"input\" lifetime parameters, we wish to create\n+        // references to the parameters themselves, including the\n+        // \"implicit\" ones created from parameter types (`'a`, `'b`,\n+        // '`0`, `'1`).\n+        //\n+        // For the \"output\" lifetime parameters, we just want to\n+        // generate `'_`.\n         let mut generic_args: Vec<_> =\n             lifetime_params[..input_lifetimes_count]\n             .iter()\n             .map(|&(span, hir_name)| {\n+                // Input lifetime like `'a` or `'1`:\n                 GenericArg::Lifetime(hir::Lifetime {\n                     hir_id: self.next_id(),\n                     span,\n@@ -2669,6 +2714,7 @@ impl<'a> LoweringContext<'a> {\n             lifetime_params[input_lifetimes_count..]\n             .iter()\n             .map(|&(span, _)| {\n+                // Output lifetime like `'_`.\n                 GenericArg::Lifetime(hir::Lifetime {\n                     hir_id: self.next_id(),\n                     span,"}]}