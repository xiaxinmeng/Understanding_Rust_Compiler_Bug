{"sha": "788a21edd4fab6c0035d91f1ac9f5896f065e06f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4OGEyMWVkZDRmYWI2YzAwMzVkOTFmMWFjOWY1ODk2ZjA2NWUwNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-20T18:35:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-20T18:35:16Z"}, "message": "Auto merge of #31608 - frewsxcv:osstring-simple-functions, r=alexcrichton\n\nhttps://github.com/rust-lang/rust/issues/29453", "tree": {"sha": "fe6ad30da3ba5d35be27ed58ae3612195e65e89b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe6ad30da3ba5d35be27ed58ae3612195e65e89b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/788a21edd4fab6c0035d91f1ac9f5896f065e06f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/788a21edd4fab6c0035d91f1ac9f5896f065e06f", "html_url": "https://github.com/rust-lang/rust/commit/788a21edd4fab6c0035d91f1ac9f5896f065e06f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/788a21edd4fab6c0035d91f1ac9f5896f065e06f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d14b39204e648a219a17335e712c3fb14666a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d14b39204e648a219a17335e712c3fb14666a07", "html_url": "https://github.com/rust-lang/rust/commit/2d14b39204e648a219a17335e712c3fb14666a07"}, {"sha": "2338d7419743f876135f723d1823dde16bdb7fdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2338d7419743f876135f723d1823dde16bdb7fdf", "html_url": "https://github.com/rust-lang/rust/commit/2338d7419743f876135f723d1823dde16bdb7fdf"}], "stats": {"total": 268, "additions": 268, "deletions": 0}, "files": [{"sha": "90ea7396a8ab37e03501e3c31ee2a44db96fa3aa", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/788a21edd4fab6c0035d91f1ac9f5896f065e06f/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788a21edd4fab6c0035d91f1ac9f5896f065e06f/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=788a21edd4fab6c0035d91f1ac9f5896f065e06f", "patch": "@@ -102,6 +102,58 @@ impl OsString {\n     pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n         self.inner.push_slice(&s.as_ref().inner)\n     }\n+\n+    /// Creates a new `OsString` with the given capacity. The string will be\n+    /// able to hold exactly `capacity` bytes without reallocating. If\n+    /// `capacity` is 0, the string will not allocate.\n+    ///\n+    /// See main `OsString` documentation information about encoding.\n+    #[unstable(feature = \"osstring_simple_functions\",\n+               reason = \"recently added\", issue = \"29453\")]\n+    pub fn with_capacity(capacity: usize) -> OsString {\n+        OsString {\n+            inner: Buf::with_capacity(capacity)\n+        }\n+    }\n+\n+    /// Truncates the `OsString` to zero length.\n+    #[unstable(feature = \"osstring_simple_functions\",\n+               reason = \"recently added\", issue = \"29453\")]\n+    pub fn clear(&mut self) {\n+        self.inner.clear()\n+    }\n+\n+    /// Returns the number of bytes this `OsString` can hold without\n+    /// reallocating.\n+    ///\n+    /// See `OsString` introduction for information about encoding.\n+    #[unstable(feature = \"osstring_simple_functions\",\n+               reason = \"recently added\", issue = \"29453\")]\n+    pub fn capacity(&self) -> usize {\n+        self.inner.capacity()\n+    }\n+\n+    /// Reserves capacity for at least `additional` more bytes to be inserted\n+    /// in the given `OsString`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    #[unstable(feature = \"osstring_simple_functions\",\n+               reason = \"recently added\", issue = \"29453\")]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.inner.reserve(additional)\n+    }\n+\n+    /// Reserves the minimum capacity for exactly `additional` more bytes to be\n+    /// inserted in the given `OsString`. Does nothing if the capacity is\n+    /// already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer reserve if future insertions are expected.\n+    #[unstable(feature = \"osstring_simple_functions\",\n+               reason = \"recently added\", issue = \"29453\")]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.inner.reserve_exact(additional)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -277,6 +329,22 @@ impl OsStr {\n         self.to_bytes().and_then(|b| CString::new(b).ok())\n     }\n \n+    /// Checks whether the `OsStr` is empty.\n+    #[unstable(feature = \"osstring_simple_functions\",\n+               reason = \"recently added\", issue = \"29453\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.inner.inner.is_empty()\n+    }\n+\n+    /// Returns the number of bytes in this `OsStr`.\n+    ///\n+    /// See `OsStr` introduction for information about encoding.\n+    #[unstable(feature = \"osstring_simple_functions\",\n+               reason = \"recently added\", issue = \"29453\")]\n+    pub fn len(&self) -> usize {\n+        self.inner.inner.len()\n+    }\n+\n     /// Gets the underlying byte representation.\n     ///\n     /// Note: it is *crucial* that this API is private, to avoid\n@@ -414,3 +482,113 @@ impl AsInner<Slice> for OsStr {\n         &self.inner\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use sys_common::{AsInner, IntoInner};\n+\n+    #[test]\n+    fn test_os_string_with_capacity() {\n+        let os_string = OsString::with_capacity(0);\n+        assert_eq!(0, os_string.inner.into_inner().capacity());\n+\n+        let os_string = OsString::with_capacity(10);\n+        assert_eq!(10, os_string.inner.into_inner().capacity());\n+\n+        let mut os_string = OsString::with_capacity(0);\n+        os_string.push(\"abc\");\n+        assert!(os_string.inner.into_inner().capacity() >= 3);\n+    }\n+\n+    #[test]\n+    fn test_os_string_clear() {\n+        let mut os_string = OsString::from(\"abc\");\n+        assert_eq!(3, os_string.inner.as_inner().len());\n+\n+        os_string.clear();\n+        assert_eq!(&os_string, \"\");\n+        assert_eq!(0, os_string.inner.as_inner().len());\n+    }\n+\n+    #[test]\n+    fn test_os_string_capacity() {\n+        let os_string = OsString::with_capacity(0);\n+        assert_eq!(0, os_string.capacity());\n+\n+        let os_string = OsString::with_capacity(10);\n+        assert_eq!(10, os_string.capacity());\n+\n+        let mut os_string = OsString::with_capacity(0);\n+        os_string.push(\"abc\");\n+        assert!(os_string.capacity() >= 3);\n+    }\n+\n+    #[test]\n+    fn test_os_string_reserve() {\n+        let mut os_string = OsString::new();\n+        assert_eq!(os_string.capacity(), 0);\n+\n+        os_string.reserve(2);\n+        assert!(os_string.capacity() >= 2);\n+\n+        for _ in 0..16 {\n+            os_string.push(\"a\");\n+        }\n+\n+        assert!(os_string.capacity() >= 16);\n+        os_string.reserve(16);\n+        assert!(os_string.capacity() >= 32);\n+\n+        os_string.push(\"a\");\n+\n+        os_string.reserve(16);\n+        assert!(os_string.capacity() >= 33)\n+    }\n+\n+    #[test]\n+    fn test_os_string_reserve_exact() {\n+        let mut os_string = OsString::new();\n+        assert_eq!(os_string.capacity(), 0);\n+\n+        os_string.reserve_exact(2);\n+        assert!(os_string.capacity() >= 2);\n+\n+        for _ in 0..16 {\n+            os_string.push(\"a\");\n+        }\n+\n+        assert!(os_string.capacity() >= 16);\n+        os_string.reserve_exact(16);\n+        assert!(os_string.capacity() >= 32);\n+\n+        os_string.push(\"a\");\n+\n+        os_string.reserve_exact(16);\n+        assert!(os_string.capacity() >= 33)\n+    }\n+\n+    #[test]\n+    fn test_os_str_is_empty() {\n+        let mut os_string = OsString::new();\n+        assert!(os_string.is_empty());\n+\n+        os_string.push(\"abc\");\n+        assert!(!os_string.is_empty());\n+\n+        os_string.clear();\n+        assert!(os_string.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_os_str_len() {\n+        let mut os_string = OsString::new();\n+        assert_eq!(0, os_string.len());\n+\n+        os_string.push(\"abc\");\n+        assert_eq!(3, os_string.len());\n+\n+        os_string.clear();\n+        assert_eq!(0, os_string.len());\n+    }\n+}"}, {"sha": "68ba2fe20b4b3434579ed4568071f5bd0af79d98", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/788a21edd4fab6c0035d91f1ac9f5896f065e06f/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788a21edd4fab6c0035d91f1ac9f5896f065e06f/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=788a21edd4fab6c0035d91f1ac9f5896f065e06f", "patch": "@@ -178,6 +178,10 @@ impl Wtf8Buf {\n         Wtf8Buf { bytes: <[_]>::to_vec(str.as_bytes()) }\n     }\n \n+    pub fn clear(&mut self) {\n+        self.bytes.clear()\n+    }\n+\n     /// Creates a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.\n     ///\n     /// This is lossless: calling `.encode_wide()` on the resulting string\n@@ -234,6 +238,11 @@ impl Wtf8Buf {\n         self.bytes.reserve(additional)\n     }\n \n+    #[inline]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.bytes.reserve_exact(additional)\n+    }\n+\n     /// Returns the number of bytes that this string buffer can hold without reallocating.\n     #[inline]\n     pub fn capacity(&self) -> usize {\n@@ -443,6 +452,11 @@ impl Wtf8 {\n         self.bytes.len()\n     }\n \n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.bytes.is_empty()\n+    }\n+\n     /// Returns the code point at `position` if it is in the ASCII range,\n     /// or `b'\\xFF' otherwise.\n     ///"}, {"sha": "d5eea5d1f3be563887c6545c818cae8f372e1663", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/788a21edd4fab6c0035d91f1ac9f5896f065e06f/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788a21edd4fab6c0035d91f1ac9f5896f065e06f/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=788a21edd4fab6c0035d91f1ac9f5896f065e06f", "patch": "@@ -17,6 +17,7 @@ use vec::Vec;\n use str;\n use string::String;\n use mem;\n+use sys_common::{AsInner, IntoInner};\n \n #[derive(Clone, Hash)]\n pub struct Buf {\n@@ -39,11 +40,51 @@ impl Debug for Buf {\n     }\n }\n \n+impl IntoInner<Vec<u8>> for Buf {\n+    fn into_inner(self) -> Vec<u8> {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<[u8]> for Buf {\n+    fn as_inner(&self) -> &[u8] {\n+        &self.inner\n+    }\n+}\n+\n+\n impl Buf {\n     pub fn from_string(s: String) -> Buf {\n         Buf { inner: s.into_bytes() }\n     }\n \n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Buf {\n+        Buf {\n+            inner: Vec::with_capacity(capacity)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.inner.clear()\n+    }\n+\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.inner.capacity()\n+    }\n+\n+    #[inline]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.inner.reserve(additional)\n+    }\n+\n+    #[inline]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.inner.reserve_exact(additional)\n+    }\n+\n     pub fn as_slice(&self) -> &Slice {\n         unsafe { mem::transmute(&*self.inner) }\n     }"}, {"sha": "26767a1349e6fc12a121fbef639843292333ba1d", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/788a21edd4fab6c0035d91f1ac9f5896f065e06f/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788a21edd4fab6c0035d91f1ac9f5896f065e06f/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=788a21edd4fab6c0035d91f1ac9f5896f065e06f", "patch": "@@ -18,12 +18,25 @@ use string::String;\n use result::Result;\n use option::Option;\n use mem;\n+use sys_common::{AsInner, IntoInner};\n \n #[derive(Clone, Hash)]\n pub struct Buf {\n     pub inner: Wtf8Buf\n }\n \n+impl IntoInner<Wtf8Buf> for Buf {\n+    fn into_inner(self) -> Wtf8Buf {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<Wtf8> for Buf {\n+    fn as_inner(&self) -> &Wtf8 {\n+        &self.inner\n+    }\n+}\n+\n impl Debug for Buf {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         self.as_slice().fmt(formatter)\n@@ -41,6 +54,20 @@ impl Debug for Slice {\n }\n \n impl Buf {\n+    pub fn with_capacity(capacity: usize) -> Buf {\n+        Buf {\n+            inner: Wtf8Buf::with_capacity(capacity)\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        self.inner.clear()\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.inner.capacity()\n+    }\n+\n     pub fn from_string(s: String) -> Buf {\n         Buf { inner: Wtf8Buf::from_string(s) }\n     }\n@@ -56,6 +83,14 @@ impl Buf {\n     pub fn push_slice(&mut self, s: &Slice) {\n         self.inner.push_wtf8(&s.inner)\n     }\n+\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.inner.reserve(additional)\n+    }\n+\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.inner.reserve_exact(additional)\n+    }\n }\n \n impl Slice {"}]}