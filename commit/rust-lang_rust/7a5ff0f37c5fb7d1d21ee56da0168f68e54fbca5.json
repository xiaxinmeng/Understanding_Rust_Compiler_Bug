{"sha": "7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNWZmMGYzN2M1ZmI3ZDFkMjFlZTU2ZGEwMTY4ZjY4ZTU0ZmJjYTU=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-02-28T14:53:59Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-02-28T14:53:59Z"}, "message": "Simpilfy origin_range logic", "tree": {"sha": "50fd6510b35d89967ae6e449a69fcbc6fc0233cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50fd6510b35d89967ae6e449a69fcbc6fc0233cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5", "html_url": "https://github.com/rust-lang/rust/commit/7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e25b17cfd0bd9bbd741ca6cf16ab39089910a74", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e25b17cfd0bd9bbd741ca6cf16ab39089910a74", "html_url": "https://github.com/rust-lang/rust/commit/3e25b17cfd0bd9bbd741ca6cf16ab39089910a74"}], "stats": {"total": 89, "additions": 51, "deletions": 38}, "files": [{"sha": "eecccdae22a3d64f7f2ceda3ee47020b8308971c", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5", "patch": "@@ -8,8 +8,7 @@ use hir_def::{\n };\n use ra_db::{FileId, FileRange};\n use ra_syntax::{\n-    algo::{find_covering_element, skip_trivia_token},\n-    ast, match_ast, AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxToken,\n+    algo::skip_trivia_token, ast, match_ast, AstNode, Direction, SyntaxNode, SyntaxToken,\n     TextRange, TextUnit,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -21,6 +20,7 @@ use crate::{\n     Function, HirFileId, InFile, Local, MacroDef, Module, Name, Origin, Path, PathResolution,\n     ScopeDef, StructField, Trait, Type, TypeParam, VariantDef,\n };\n+use hir_expand::ExpansionInfo;\n use ra_prof::profile;\n \n /// Primary API to get semantic information, like types, from syntax trees.\n@@ -337,22 +337,12 @@ impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n \n // FIXME: Change `HasSource` trait to work with `Semantics` and remove this?\n pub fn original_range(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n-    let mut elem: InFile<SyntaxElement> = node.map(|n| n.clone().into());\n-\n-    while let Some((range, Origin::Call)) = original_range_and_origin(db, elem.as_ref()) {\n+    if let Some(range) = original_range_opt(db, node) {\n         let original_file = range.file_id.original_file(db);\n-\n         if range.file_id == original_file.into() {\n             return FileRange { file_id: original_file, range: range.value };\n         }\n \n-        if range.file_id != elem.file_id {\n-            if let Some(root) = db.parse_or_expand(range.file_id) {\n-                elem = range.with_value(find_covering_element(&root, range.value));\n-                continue;\n-            }\n-        }\n-\n         log::error!(\"Fail to mapping up more for {:?}\", range);\n         return FileRange { file_id: range.file_id.original_file(db), range: range.value };\n     }\n@@ -370,43 +360,42 @@ pub fn original_range(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> FileR\n     FileRange { file_id: node.file_id.original_file(db), range: node.value.text_range() }\n }\n \n-fn original_range_and_origin(\n+fn original_range_opt(\n     db: &impl HirDatabase,\n-    elem: InFile<&SyntaxElement>,\n-) -> Option<(InFile<TextRange>, Origin)> {\n-    let expansion = elem.file_id.expansion_info(db)?;\n-\n-    let node = match elem.as_ref().value {\n-        NodeOrToken::Node(it) => elem.with_value(it),\n-        NodeOrToken::Token(it) => {\n-            let (tt, origin) = expansion.map_token_up(elem.with_value(it))?;\n-            return Some((tt.map(|it| it.text_range()), origin));\n-        }\n-    };\n+    node: InFile<&SyntaxNode>,\n+) -> Option<InFile<TextRange>> {\n+    let expansion = node.file_id.expansion_info(db)?;\n \n     // the input node has only one token ?\n     let single = skip_trivia_token(node.value.first_token()?, Direction::Next)?\n         == skip_trivia_token(node.value.last_token()?, Direction::Prev)?;\n \n     Some(node.value.descendants().find_map(|it| {\n         let first = skip_trivia_token(it.first_token()?, Direction::Next)?;\n-        let last = skip_trivia_token(it.last_token()?, Direction::Prev)?;\n-\n-        if !single && first == last {\n-            return None;\n-        }\n+        let first = ascend_call_token(db, &expansion, node.with_value(first))?;\n \n-        // Try to map first and last tokens of node, and, if success, return the union range of mapped tokens\n-        let (first, first_origin) = expansion.map_token_up(node.with_value(&first))?;\n-        let (last, last_origin) = expansion.map_token_up(node.with_value(&last))?;\n+        let last = skip_trivia_token(it.last_token()?, Direction::Prev)?;\n+        let last = ascend_call_token(db, &expansion, node.with_value(last))?;\n \n-        if first.file_id != last.file_id || first_origin != last_origin {\n+        if (!single && first == last) || (first.file_id != last.file_id) {\n             return None;\n         }\n \n-        Some((\n-            first.with_value(first.value.text_range().extend_to(&last.value.text_range())),\n-            first_origin,\n-        ))\n+        Some(first.with_value(first.value.text_range().extend_to(&last.value.text_range())))\n     })?)\n }\n+\n+fn ascend_call_token(\n+    db: &impl HirDatabase,\n+    expansion: &ExpansionInfo,\n+    token: InFile<SyntaxToken>,\n+) -> Option<InFile<SyntaxToken>> {\n+    let (mapped, origin) = expansion.map_token_up(token.as_ref())?;\n+    if origin != Origin::Call {\n+        return None;\n+    }\n+    if let Some(info) = mapped.file_id.expansion_info(db) {\n+        return ascend_call_token(db, &info, mapped);\n+    }\n+    Some(mapped)\n+}"}, {"sha": "cc79f1fab1b5914177eda2bfdeeb3b9f2f0ce6fe", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=7a5ff0f37c5fb7d1d21ee56da0168f68e54fbca5", "patch": "@@ -738,6 +738,30 @@ fn func(foo: i32) { if true { <|>foo; }; }\n         assert_eq!(hover_on, \"bar\")\n     }\n \n+    #[test]\n+    fn test_hover_through_func_in_macro_recursive() {\n+        let hover_on = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            macro_rules! id_deep {\n+                ($($tt:tt)*) => { $($tt)* }\n+            }\n+            macro_rules! id {\n+                ($($tt:tt)*) => { id_deep!($($tt)*) }\n+            }\n+            fn bar() -> u32 {\n+                0\n+            }\n+            fn foo() {\n+                let a = id!([0u32, bar(<|>)] );\n+            }\n+            \",\n+            &[\"u32\"],\n+        );\n+\n+        assert_eq!(hover_on, \"bar()\")\n+    }\n+\n     #[test]\n     fn test_hover_through_literal_string_in_macro() {\n         let hover_on = check_hover_result("}]}