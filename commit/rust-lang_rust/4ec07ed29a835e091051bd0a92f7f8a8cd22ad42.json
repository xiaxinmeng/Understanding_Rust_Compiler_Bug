{"sha": "4ec07ed29a835e091051bd0a92f7f8a8cd22ad42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYzA3ZWQyOWE4MzVlMDkxMDUxYmQwYTkyZjdmOGE4Y2QyMmFkNDI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-03-14T05:22:04Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-03-24T21:18:39Z"}, "message": "syntax: Allow where strings to be parsed independent from generics\n\nThis allows quasiquoting to insert where clauses.", "tree": {"sha": "02f75b6e72646da7998b57d91c5d810321d05553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02f75b6e72646da7998b57d91c5d810321d05553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ec07ed29a835e091051bd0a92f7f8a8cd22ad42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec07ed29a835e091051bd0a92f7f8a8cd22ad42", "html_url": "https://github.com/rust-lang/rust/commit/4ec07ed29a835e091051bd0a92f7f8a8cd22ad42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ec07ed29a835e091051bd0a92f7f8a8cd22ad42/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3f4fba9cc218957797cdd0c70b2028b39a7cfbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3f4fba9cc218957797cdd0c70b2028b39a7cfbd", "html_url": "https://github.com/rust-lang/rust/commit/c3f4fba9cc218957797cdd0c70b2028b39a7cfbd"}], "stats": {"total": 41, "additions": 25, "deletions": 16}, "files": [{"sha": "7dac40c87d189a8fe9146b60dd94c2d645f9f1ec", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ec07ed29a835e091051bd0a92f7f8a8cd22ad42/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec07ed29a835e091051bd0a92f7f8a8cd22ad42/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=4ec07ed29a835e091051bd0a92f7f8a8cd22ad42", "patch": "@@ -175,6 +175,7 @@ pub mod rt {\n     impl_to_source! { ast::Block, block_to_string }\n     impl_to_source! { ast::Arg, arg_to_string }\n     impl_to_source! { Generics, generics_to_string }\n+    impl_to_source! { ast::WhereClause, where_clause_to_string }\n     impl_to_source! { P<ast::Item>, item_to_string }\n     impl_to_source! { P<ast::ImplItem>, impl_item_to_string }\n     impl_to_source! { P<ast::TraitItem>, trait_item_to_string }\n@@ -318,6 +319,7 @@ pub mod rt {\n     impl_to_tokens! { ast::Ty }\n     impl_to_tokens_lifetime! { &'a [ast::Ty] }\n     impl_to_tokens! { Generics }\n+    impl_to_tokens! { ast::WhereClause }\n     impl_to_tokens! { P<ast::Stmt> }\n     impl_to_tokens! { P<ast::Expr> }\n     impl_to_tokens! { ast::Block }"}, {"sha": "023f6e69945aba4fe028b4c8b168414f05985673", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4ec07ed29a835e091051bd0a92f7f8a8cd22ad42/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ec07ed29a835e091051bd0a92f7f8a8cd22ad42/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4ec07ed29a835e091051bd0a92f7f8a8cd22ad42", "patch": "@@ -1126,7 +1126,7 @@ impl<'a> Parser<'a> {\n                     p.parse_arg_general(false)\n                 });\n \n-                p.parse_where_clause(&mut generics);\n+                generics.where_clause = p.parse_where_clause();\n                 let sig = ast::MethodSig {\n                     unsafety: style,\n                     decl: d,\n@@ -3932,9 +3932,14 @@ impl<'a> Parser<'a> {\n     /// ```\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n-    fn parse_where_clause(&mut self, generics: &mut ast::Generics) {\n+    fn parse_where_clause(&mut self) -> ast::WhereClause {\n+        let mut where_clause = WhereClause {\n+            id: ast::DUMMY_NODE_ID,\n+            predicates: Vec::new(),\n+        };\n+\n         if !self.eat_keyword(keywords::Where) {\n-            return\n+            return where_clause;\n         }\n \n         let mut parsed_something = false;\n@@ -3957,7 +3962,7 @@ impl<'a> Parser<'a> {\n                     let hi = self.span.hi;\n                     let span = mk_sp(lo, hi);\n \n-                    generics.where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n+                    where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n                         ast::WhereRegionPredicate {\n                             span: span,\n                             lifetime: bounded_lifetime,\n@@ -3992,7 +3997,7 @@ impl<'a> Parser<'a> {\n                                            at least one bound in it\");\n                         }\n \n-                        generics.where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n+                        where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                                 ast::WhereBoundPredicate {\n                                     span: span,\n                                     bound_lifetimes: bound_lifetimes,\n@@ -4005,7 +4010,7 @@ impl<'a> Parser<'a> {\n                         // let ty = self.parse_ty();\n                         let hi = self.span.hi;\n                         let span = mk_sp(lo, hi);\n-                        // generics.where_clause.predicates.push(\n+                        // where_clause.predicates.push(\n                         //     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                         //         id: ast::DUMMY_NODE_ID,\n                         //         span: span,\n@@ -4036,6 +4041,8 @@ impl<'a> Parser<'a> {\n                           \"a `where` clause must have at least one predicate \\\n                            in it\");\n         }\n+\n+        where_clause\n     }\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n@@ -4354,7 +4361,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_fn(&mut self, unsafety: Unsafety, abi: abi::Abi) -> ItemInfo {\n         let (ident, mut generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(false);\n-        self.parse_where_clause(&mut generics);\n+        generics.where_clause = self.parse_where_clause();\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         (ident, ItemFn(decl, unsafety, abi, generics, body), Some(inner_attrs))\n     }\n@@ -4439,7 +4446,7 @@ impl<'a> Parser<'a> {\n             let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n                     p.parse_arg()\n                 });\n-            self.parse_where_clause(&mut generics);\n+            generics.where_clause = self.parse_where_clause();\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n             (ident, inner_attrs, MethodImplItem(ast::MethodSig {\n                 generics: generics,\n@@ -4460,7 +4467,7 @@ impl<'a> Parser<'a> {\n         // Parse supertrait bounds.\n         let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n \n-        self.parse_where_clause(&mut tps);\n+        tps.where_clause = self.parse_where_clause();\n \n         let meths = self.parse_trait_items();\n         (ident, ItemTrait(unsafety, tps, bounds, meths), None)\n@@ -4531,7 +4538,7 @@ impl<'a> Parser<'a> {\n             if opt_trait.is_some() {\n                 ty = self.parse_ty_sum();\n             }\n-            self.parse_where_clause(&mut generics);\n+            generics.where_clause = self.parse_where_clause();\n \n             self.expect(&token::OpenDelim(token::Brace));\n             let attrs = self.parse_inner_attributes();\n@@ -4603,7 +4610,7 @@ impl<'a> Parser<'a> {\n         // struct.\n \n         let (fields, ctor_id) = if self.token.is_keyword(keywords::Where) {\n-            self.parse_where_clause(&mut generics);\n+            generics.where_clause = self.parse_where_clause();\n             if self.eat(&token::Semi) {\n                 // If we see a: `struct Foo<T> where T: Copy;` style decl.\n                 (Vec::new(), Some(ast::DUMMY_NODE_ID))\n@@ -4684,12 +4691,12 @@ impl<'a> Parser<'a> {\n                     token::get_ident(class_name.clone())));\n             }\n \n-            self.parse_where_clause(generics);\n+            generics.where_clause = self.parse_where_clause();\n             self.expect(&token::Semi);\n             fields\n         // This is the case where we just see struct Foo<T> where T: Copy;\n         } else if self.token.is_keyword(keywords::Where) {\n-            self.parse_where_clause(generics);\n+            generics.where_clause = self.parse_where_clause();\n             self.expect(&token::Semi);\n             Vec::new()\n         // This case is where we see: `struct Foo<T>;`\n@@ -4937,7 +4944,7 @@ impl<'a> Parser<'a> {\n \n         let (ident, mut generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(true);\n-        self.parse_where_clause(&mut generics);\n+        generics.where_clause = self.parse_where_clause();\n         let hi = self.span.hi;\n         self.expect(&token::Semi);\n         P(ast::ForeignItem {\n@@ -5082,7 +5089,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_type(&mut self) -> ItemInfo {\n         let ident = self.parse_ident();\n         let mut tps = self.parse_generics();\n-        self.parse_where_clause(&mut tps);\n+        tps.where_clause = self.parse_where_clause();\n         self.expect(&token::Eq);\n         let ty = self.parse_ty_sum();\n         self.expect(&token::Semi);\n@@ -5182,7 +5189,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_enum(&mut self) -> ItemInfo {\n         let id = self.parse_ident();\n         let mut generics = self.parse_generics();\n-        self.parse_where_clause(&mut generics);\n+        generics.where_clause = self.parse_where_clause();\n         self.expect(&token::OpenDelim(token::Brace));\n \n         let enum_definition = self.parse_enum_def(&generics);"}]}