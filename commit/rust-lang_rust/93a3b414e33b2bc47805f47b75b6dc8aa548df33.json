{"sha": "93a3b414e33b2bc47805f47b75b6dc8aa548df33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzYTNiNDE0ZTMzYjJiYzQ3ODA1ZjQ3Yjc1YjZkYzhhYTU0OGRmMzM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-30T14:25:10Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-04-20T11:21:40Z"}, "message": "Move almost all of cg_llvm/back/link.rs to cg_ssa", "tree": {"sha": "69667a5978cf93ffb1adf5c14bfe61531474d15a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69667a5978cf93ffb1adf5c14bfe61531474d15a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93a3b414e33b2bc47805f47b75b6dc8aa548df33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93a3b414e33b2bc47805f47b75b6dc8aa548df33", "html_url": "https://github.com/rust-lang/rust/commit/93a3b414e33b2bc47805f47b75b6dc8aa548df33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93a3b414e33b2bc47805f47b75b6dc8aa548df33/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de4ee55dc70292a16c0a3c975737d5e3c4cdd25c", "url": "https://api.github.com/repos/rust-lang/rust/commits/de4ee55dc70292a16c0a3c975737d5e3c4cdd25c", "html_url": "https://github.com/rust-lang/rust/commit/de4ee55dc70292a16c0a3c975737d5e3c4cdd25c"}], "stats": {"total": 2226, "additions": 1115, "deletions": 1111}, "files": [{"sha": "72a05753d097a835a70ebd14380b24968e13388a", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93a3b414e33b2bc47805f47b75b6dc8aa548df33/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/93a3b414e33b2bc47805f47b75b6dc8aa548df33/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=93a3b414e33b2bc47805f47b75b6dc8aa548df33", "patch": "@@ -2634,6 +2634,7 @@ dependencies = [\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n+ \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "1350676ea0a91ffa21e66f83906a2f2ea44f8f5a", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 15, "deletions": 1102, "changes": 1117, "blob_url": "https://github.com/rust-lang/rust/blob/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=93a3b414e33b2bc47805f47b75b6dc8aa548df33", "patch": "@@ -1,1112 +1,25 @@\n-use super::archive::LlvmArchiveBuilder;\n-use super::rpath::RPathConfig;\n-use super::rpath;\n-use crate::back::wasm;\n-use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n-use rustc_codegen_ssa::back::linker::Linker;\n-use rustc_codegen_ssa::back::link::*;\n-use rustc_codegen_ssa::back::command::Command;\n-use rustc::session::config::{self, DebugInfo, OutputFilenames, OutputType, PrintRequest};\n-use rustc::session::config::{RUST_CGU_EXT, Sanitizer};\n-use rustc::session::filesearch;\n-use rustc::session::search_paths::PathKind;\n+use rustc::session::config::OutputFilenames;\n use rustc::session::Session;\n-use rustc::middle::cstore::NativeLibraryKind;\n-use rustc::middle::dependency_format::Linkage;\n use rustc_codegen_ssa::CodegenResults;\n-use rustc::util::common::{time, time_ext};\n-use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-use rustc::hir::def_id::CrateNum;\n-use tempfile::{Builder as TempFileBuilder, TempDir};\n-use rustc_target::spec::{PanicStrategy, RelroLevel, LinkerFlavor};\n-use rustc_data_structures::fx::FxHashSet;\n-\n-use std::ascii;\n-use std::char;\n-use std::env;\n-use std::fs;\n-use std::io;\n-use std::path::{Path, PathBuf};\n-use std::str;\n+use super::archive::LlvmArchiveBuilder;\n \n+use std::path::PathBuf;\n pub use rustc_codegen_utils::link::*;\n \n /// Performs the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n-pub(crate) fn link_binary<'a>(sess: &'a Session,\n-                          codegen_results: &CodegenResults,\n-                          outputs: &OutputFilenames,\n-                          crate_name: &str) -> Vec<PathBuf> {\n-    let target_cpu = crate::llvm_util::target_cpu(sess);\n-    let mut out_filenames = Vec::new();\n-    for &crate_type in sess.crate_types.borrow().iter() {\n-        // Ignore executable crates if we have -Z no-codegen, as they will error.\n-        let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n-        if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen()) &&\n-           !output_metadata &&\n-           crate_type == config::CrateType::Executable {\n-            continue;\n-        }\n-\n-        if invalid_output_for_target(sess, crate_type) {\n-           bug!(\"invalid output type `{:?}` for target os `{}`\",\n-                crate_type, sess.opts.target_triple);\n-        }\n-        let out_files = link_binary_output::<LlvmArchiveBuilder<'a>>(sess,\n-                                           codegen_results,\n-                                           crate_type,\n-                                           outputs,\n-                                           crate_name,\n-                                           target_cpu);\n-        out_filenames.extend(out_files);\n-    }\n-\n-    // Remove the temporary object file and metadata if we aren't saving temps\n-    if !sess.opts.cg.save_temps {\n-        if sess.opts.output_types.should_codegen() && !preserve_objects_for_their_debuginfo(sess) {\n-            for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-                remove(sess, obj);\n-            }\n-        }\n-        for obj in codegen_results.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n-            remove(sess, obj);\n-        }\n-        if let Some(ref obj) = codegen_results.metadata_module.object {\n-            remove(sess, obj);\n-        }\n-        if let Some(ref allocator) = codegen_results.allocator_module {\n-            if let Some(ref obj) = allocator.object {\n-                remove(sess, obj);\n-            }\n-            if let Some(ref bc) = allocator.bytecode_compressed {\n-                remove(sess, bc);\n-            }\n-        }\n-    }\n-\n-    out_filenames\n-}\n-\n-fn link_binary_output<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n-                      codegen_results: &CodegenResults,\n-                      crate_type: config::CrateType,\n-                      outputs: &OutputFilenames,\n-                      crate_name: &str,\n-                      target_cpu: &str) -> Vec<PathBuf> {\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        check_file_is_writeable(obj, sess);\n-    }\n-\n-    let mut out_filenames = vec![];\n-\n-    if outputs.outputs.contains_key(&OutputType::Metadata) {\n-        let out_filename = filename_for_metadata(sess, crate_name, outputs);\n-        // To avoid races with another rustc process scanning the output directory,\n-        // we need to write the file somewhere else and atomically move it to its\n-        // final destination, with a `fs::rename` call. In order for the rename to\n-        // always succeed, the temporary file needs to be on the same filesystem,\n-        // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = TempFileBuilder::new()\n-            .prefix(\"rmeta\")\n-            .tempdir_in(out_filename.parent().unwrap())\n-            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-        let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n-        if let Err(e) = fs::rename(metadata, &out_filename) {\n-            sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n-        }\n-        out_filenames.push(out_filename);\n-    }\n-\n-    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n-        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-\n-    if outputs.outputs.should_codegen() {\n-        let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n-        match crate_type {\n-            config::CrateType::Rlib => {\n-                link_rlib::<B>(sess,\n-                          codegen_results,\n-                          RlibFlavor::Normal,\n-                          &out_filename,\n-                          &tmpdir).build();\n-            }\n-            config::CrateType::Staticlib => {\n-                link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n-            }\n-            _ => {\n-                link_natively::<B>(sess, crate_type, &out_filename, codegen_results, tmpdir.path(), target_cpu);\n-            }\n-        }\n-        out_filenames.push(out_filename);\n-    }\n-\n-    if sess.opts.cg.save_temps {\n-        let _ = tmpdir.into_path();\n-    }\n-\n-    out_filenames\n-}\n-\n-/// We use a temp directory here to avoid races between concurrent rustc processes,\n-/// such as builds in the same directory using the same filename for metadata while\n-/// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n-/// directory being searched for `extern crate` (observing an incomplete file).\n-/// The returned path is the temporary file containing the complete metadata.\n-fn emit_metadata<'a>(\n+pub(crate) fn link_binary<'a>(\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n-    tmpdir: &TempDir\n-) -> PathBuf {\n-    let out_filename = tmpdir.path().join(METADATA_FILENAME);\n-    let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n-\n-    if let Err(e) = result {\n-        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n-    }\n-\n-    out_filename\n-}\n-\n-// Create an 'rlib'\n-//\n-// An rlib in its current incarnation is essentially a renamed .a file. The\n-// rlib primarily contains the object file of the crate, but it also contains\n-// all of the object files from native libraries. This is done by unzipping\n-// native libraries and inserting all of the contents into this archive.\n-fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n-                 codegen_results: &CodegenResults,\n-                 flavor: RlibFlavor,\n-                 out_filename: &Path,\n-                 tmpdir: &TempDir) -> B {\n-    info!(\"preparing rlib to {:?}\", out_filename);\n-    let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n-\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        ab.add_file(obj);\n-    }\n-\n-    // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n-    // we may not be configured to actually include a static library if we're\n-    // adding it here. That's because later when we consume this rlib we'll\n-    // decide whether we actually needed the static library or not.\n-    //\n-    // To do this \"correctly\" we'd need to keep track of which libraries added\n-    // which object files to the archive. We don't do that here, however. The\n-    // #[link(cfg(..))] feature is unstable, though, and only intended to get\n-    // liblibc working. In that sense the check below just indicates that if\n-    // there are any libraries we want to omit object files for at link time we\n-    // just exclude all custom object files.\n-    //\n-    // Eventually if we want to stabilize or flesh out the #[link(cfg(..))]\n-    // feature then we'll need to figure out how to record what objects were\n-    // loaded from the libraries found here and then encode that into the\n-    // metadata of the rlib we're generating somehow.\n-    for lib in codegen_results.crate_info.used_libraries.iter() {\n-        match lib.kind {\n-            NativeLibraryKind::NativeStatic => {}\n-            NativeLibraryKind::NativeStaticNobundle |\n-            NativeLibraryKind::NativeFramework |\n-            NativeLibraryKind::NativeUnknown => continue,\n-        }\n-        if let Some(name) = lib.name {\n-            ab.add_native_library(&name.as_str());\n-        }\n-    }\n-\n-    // After adding all files to the archive, we need to update the\n-    // symbol table of the archive.\n-    ab.update_symbols();\n-\n-    // Note that it is important that we add all of our non-object \"magical\n-    // files\" *after* all of the object files in the archive. The reason for\n-    // this is as follows:\n-    //\n-    // * When performing LTO, this archive will be modified to remove\n-    //   objects from above. The reason for this is described below.\n-    //\n-    // * When the system linker looks at an archive, it will attempt to\n-    //   determine the architecture of the archive in order to see whether its\n-    //   linkable.\n-    //\n-    //   The algorithm for this detection is: iterate over the files in the\n-    //   archive. Skip magical SYMDEF names. Interpret the first file as an\n-    //   object file. Read architecture from the object file.\n-    //\n-    // * As one can probably see, if \"metadata\" and \"foo.bc\" were placed\n-    //   before all of the objects, then the architecture of this archive would\n-    //   not be correctly inferred once 'foo.o' is removed.\n-    //\n-    // Basically, all this means is that this code should not move above the\n-    // code above.\n-    match flavor {\n-        RlibFlavor::Normal => {\n-            // Instead of putting the metadata in an object file section, rlibs\n-            // contain the metadata in a separate file.\n-            ab.add_file(&emit_metadata(sess, codegen_results, tmpdir));\n-\n-            // For LTO purposes, the bytecode of this library is also inserted\n-            // into the archive.\n-            for bytecode in codegen_results\n-                .modules\n-                .iter()\n-                .filter_map(|m| m.bytecode_compressed.as_ref())\n-            {\n-                ab.add_file(bytecode);\n-            }\n-\n-            // After adding all files to the archive, we need to update the\n-            // symbol table of the archive. This currently dies on macOS (see\n-            // #11162), and isn't necessary there anyway\n-            if !sess.target.target.options.is_like_osx {\n-                ab.update_symbols();\n-            }\n-        }\n-\n-        RlibFlavor::StaticlibBase => {\n-            let obj = codegen_results.allocator_module\n-                .as_ref()\n-                .and_then(|m| m.object.as_ref());\n-            if let Some(obj) = obj {\n-                ab.add_file(obj);\n-            }\n-        }\n-    }\n-\n-    ab\n-}\n-\n-// Create a static archive\n-//\n-// This is essentially the same thing as an rlib, but it also involves adding\n-// all of the upstream crates' objects into the archive. This will slurp in\n-// all of the native libraries of upstream dependencies as well.\n-//\n-// Additionally, there's no way for us to link dynamic libraries, so we warn\n-// about all dynamic library dependencies that they're not linked in.\n-//\n-// There's no need to include metadata in a static archive, so ensure to not\n-// link in the metadata object file (and also don't prepare the archive with a\n-// metadata file).\n-fn link_staticlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n-                  codegen_results: &CodegenResults,\n-                  out_filename: &Path,\n-                  tempdir: &TempDir) {\n-    let mut ab = link_rlib::<B>(sess,\n-                           codegen_results,\n-                           RlibFlavor::StaticlibBase,\n-                           out_filename,\n-                           tempdir);\n-    let mut all_native_libs = vec![];\n-\n-    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n-        let name = &codegen_results.crate_info.crate_name[&cnum];\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-\n-        // Here when we include the rlib into our staticlib we need to make a\n-        // decision whether to include the extra object files along the way.\n-        // These extra object files come from statically included native\n-        // libraries, but they may be cfg'd away with #[link(cfg(..))].\n-        //\n-        // This unstable feature, though, only needs liblibc to work. The only\n-        // use case there is where musl is statically included in liblibc.rlib,\n-        // so if we don't want the included version we just need to skip it. As\n-        // a result the logic here is that if *any* linked library is cfg'd away\n-        // we just skip all object files.\n-        //\n-        // Clearly this is not sufficient for a general purpose feature, and\n-        // we'd want to read from the library's metadata to determine which\n-        // object files come from where and selectively skip them.\n-        let skip_object_files = native_libs.iter().any(|lib| {\n-            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n-        });\n-        ab.add_rlib(path,\n-                    &name.as_str(),\n-                    are_upstream_rust_objects_already_included(sess) &&\n-                        !ignored_for_lto(sess, &codegen_results.crate_info, cnum),\n-                    skip_object_files).unwrap();\n-\n-        all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n-    });\n-    if let Err(e) = res {\n-        sess.fatal(&e);\n-    }\n-\n-    ab.update_symbols();\n-    ab.build();\n-\n-    if !all_native_libs.is_empty() {\n-        if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n-            print_native_static_libs(sess, &all_native_libs);\n-        }\n-    }\n-}\n-\n-// Create a dynamic library or executable\n-//\n-// This will invoke the system linker/cc to create the resulting file. This\n-// links to all upstream files as well.\n-fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n-                 crate_type: config::CrateType,\n-                 out_filename: &Path,\n-                 codegen_results: &CodegenResults,\n-                 tmpdir: &Path,\n-                 target_cpu: &str) {\n-    info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n-    let (linker, flavor) = linker_and_flavor(sess);\n-\n-    // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n-\n-    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n-        if sess.crt_static() {\n-            cmd.args(args);\n-        }\n-    }\n-    if let Some(ref args) = sess.opts.debugging_opts.pre_link_args {\n-        cmd.args(args);\n-    }\n-    cmd.args(&sess.opts.debugging_opts.pre_link_arg);\n-\n-    if sess.target.target.options.is_like_fuchsia {\n-        let prefix = match sess.opts.debugging_opts.sanitizer {\n-            Some(Sanitizer::Address) => \"asan/\",\n-            _ => \"\",\n-        };\n-        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n-    }\n-\n-    let pre_link_objects = if crate_type == config::CrateType::Executable {\n-        &sess.target.target.options.pre_link_objects_exe\n-    } else {\n-        &sess.target.target.options.pre_link_objects_dll\n-    };\n-    for obj in pre_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-\n-    if crate_type == config::CrateType::Executable && sess.crt_static() {\n-        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-\n-    if sess.target.target.options.is_like_emscripten {\n-        cmd.arg(\"-s\");\n-        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n-            \"DISABLE_EXCEPTION_CATCHING=1\"\n-        } else {\n-            \"DISABLE_EXCEPTION_CATCHING=0\"\n-        });\n-    }\n-\n-    {\n-        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n-        link_args::<B>(&mut *linker, flavor, sess, crate_type, tmpdir,\n-                  out_filename, codegen_results);\n-        cmd = linker.finalize();\n-    }\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    for obj in &sess.target.target.options.post_link_objects {\n-        cmd.arg(get_file_path(sess, obj));\n-    }\n-    if sess.crt_static() {\n-        for obj in &sess.target.target.options.post_link_objects_crt {\n-            cmd.arg(get_file_path(sess, obj));\n-        }\n-    }\n-    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n-        cmd.args(args);\n-    }\n-    for &(ref k, ref v) in &sess.target.target.options.link_env {\n-        cmd.env(k, v);\n-    }\n-\n-    if sess.opts.debugging_opts.print_link_args {\n-        println!(\"{:?}\", &cmd);\n-    }\n-\n-    // May have not found libraries in the right formats.\n-    sess.abort_if_errors();\n-\n-    // Invoke the system linker\n-    //\n-    // Note that there's a terribly awful hack that really shouldn't be present\n-    // in any compiler. Here an environment variable is supported to\n-    // automatically retry the linker invocation if the linker looks like it\n-    // segfaulted.\n-    //\n-    // Gee that seems odd, normally segfaults are things we want to know about!\n-    // Unfortunately though in rust-lang/rust#38878 we're experiencing the\n-    // linker segfaulting on Travis quite a bit which is causing quite a bit of\n-    // pain to land PRs when they spuriously fail due to a segfault.\n-    //\n-    // The issue #38878 has some more debugging information on it as well, but\n-    // this unfortunately looks like it's just a race condition in macOS's linker\n-    // with some thread pool working in the background. It seems that no one\n-    // currently knows a fix for this so in the meantime we're left with this...\n-    info!(\"{:?}\", &cmd);\n-    let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n-    let mut prog;\n-    let mut i = 0;\n-    loop {\n-        i += 1;\n-        prog = time(sess, \"running linker\", || {\n-            exec_linker(sess, &mut cmd, out_filename, tmpdir)\n-        });\n-        let output = match prog {\n-            Ok(ref output) => output,\n-            Err(_) => break,\n-        };\n-        if output.status.success() {\n-            break\n-        }\n-        let mut out = output.stderr.clone();\n-        out.extend(&output.stdout);\n-        let out = String::from_utf8_lossy(&out);\n-\n-        // Check to see if the link failed with \"unrecognized command line option:\n-        // '-no-pie'\" for gcc or \"unknown argument: '-no-pie'\" for clang. If so,\n-        // reperform the link step without the -no-pie option. This is safe because\n-        // if the linker doesn't support -no-pie then it should not default to\n-        // linking executables as pie. Different versions of gcc seem to use\n-        // different quotes in the error message so don't check for them.\n-        if sess.target.target.options.linker_is_gnu &&\n-           flavor != LinkerFlavor::Ld &&\n-           (out.contains(\"unrecognized command line option\") ||\n-            out.contains(\"unknown argument\")) &&\n-           out.contains(\"-no-pie\") &&\n-           cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-no-pie\") {\n-            info!(\"linker output: {:?}\", out);\n-            warn!(\"Linker does not support -no-pie command line option. Retrying without.\");\n-            for arg in cmd.take_args() {\n-                if arg.to_string_lossy() != \"-no-pie\" {\n-                    cmd.arg(arg);\n-                }\n-            }\n-            info!(\"{:?}\", &cmd);\n-            continue;\n-        }\n-        if !retry_on_segfault || i > 3 {\n-            break\n-        }\n-        let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n-        let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n-        if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n-            break\n-        }\n-\n-        warn!(\n-            \"looks like the linker segfaulted when we tried to call it, \\\n-             automatically retrying again. cmd = {:?}, out = {}.\",\n-            cmd,\n-            out,\n-        );\n-    }\n-\n-    match prog {\n-        Ok(prog) => {\n-            fn escape_string(s: &[u8]) -> String {\n-                str::from_utf8(s).map(|s| s.to_owned())\n-                    .unwrap_or_else(|_| {\n-                        let mut x = \"Non-UTF-8 output: \".to_string();\n-                        x.extend(s.iter()\n-                                  .flat_map(|&b| ascii::escape_default(b))\n-                                  .map(char::from));\n-                        x\n-                    })\n-            }\n-            if !prog.status.success() {\n-                let mut output = prog.stderr.clone();\n-                output.extend_from_slice(&prog.stdout);\n-                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n-                                         pname.display(),\n-                                         prog.status))\n-                    .note(&format!(\"{:?}\", &cmd))\n-                    .note(&escape_string(&output))\n-                    .emit();\n-                sess.abort_if_errors();\n-            }\n-            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n-            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n-        },\n-        Err(e) => {\n-            let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n-\n-            let mut linker_error = {\n-                if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n-                } else {\n-                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n-                }\n-            };\n-\n-            linker_error.note(&e.to_string());\n-\n-            if !linker_not_found {\n-                linker_error.note(&format!(\"{:?}\", &cmd));\n-            }\n-\n-            linker_error.emit();\n-\n-            if sess.target.target.options.is_like_msvc && linker_not_found {\n-                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n-                    but `link.exe` was not found\");\n-                sess.note_without_error(\"please ensure that VS 2013, VS 2015 or VS 2017 \\\n-                    was installed with the Visual C++ option\");\n-            }\n-            sess.abort_if_errors();\n-        }\n-    }\n-\n-\n-    // On macOS, debuggers need this utility to get run to do some munging of\n-    // the symbols. Note, though, that if the object files are being preserved\n-    // for their debug information there's no need for us to run dsymutil.\n-    if sess.target.target.options.is_like_osx &&\n-        sess.opts.debuginfo != DebugInfo::None &&\n-        !preserve_objects_for_their_debuginfo(sess)\n-    {\n-        if let Err(e) = Command::new(\"dsymutil\").arg(out_filename).output() {\n-            sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n-        }\n-    }\n-\n-    if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n-        wasm::add_producer_section(\n-            &out_filename,\n-            &sess.edition().to_string(),\n-            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n-        );\n-    }\n-}\n-\n-fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n-             flavor: LinkerFlavor,\n-             sess: &'a Session,\n-             crate_type: config::CrateType,\n-             tmpdir: &Path,\n-             out_filename: &Path,\n-             codegen_results: &CodegenResults) {\n-\n-    // Linker plugins should be specified early in the list of arguments\n-    cmd.linker_plugin_lto();\n-\n-    // The default library location, we need this to find the runtime.\n-    // The location of crates will be determined as needed.\n-    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n-\n-    // target descriptor\n-    let t = &sess.target.target;\n-\n-    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n-    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n-        cmd.add_object(obj);\n-    }\n-    cmd.output_filename(out_filename);\n-\n-    if crate_type == config::CrateType::Executable &&\n-       sess.target.target.options.is_like_windows {\n-        if let Some(ref s) = codegen_results.windows_subsystem {\n-            cmd.subsystem(s);\n-        }\n-    }\n-\n-    // If we're building a dynamic library then some platforms need to make sure\n-    // that all symbols are exported correctly from the dynamic library.\n-    if crate_type != config::CrateType::Executable ||\n-       sess.target.target.options.is_like_emscripten {\n-        cmd.export_symbols(tmpdir, crate_type);\n-    }\n-\n-    // When linking a dynamic library, we put the metadata into a section of the\n-    // executable. This metadata is in a separate object file from the main\n-    // object file, so we link that in here.\n-    if crate_type == config::CrateType::Dylib ||\n-       crate_type == config::CrateType::ProcMacro {\n-        if let Some(obj) = codegen_results.metadata_module.object.as_ref() {\n-            cmd.add_object(obj);\n-        }\n-    }\n-\n-    let obj = codegen_results.allocator_module\n-        .as_ref()\n-        .and_then(|m| m.object.as_ref());\n-    if let Some(obj) = obj {\n-        cmd.add_object(obj);\n-    }\n-\n-    // Try to strip as much out of the generated object by removing unused\n-    // sections if possible. See more comments in linker.rs\n-    if !sess.opts.cg.link_dead_code {\n-        let keep_metadata = crate_type == config::CrateType::Dylib;\n-        cmd.gc_sections(keep_metadata);\n-    }\n-\n-    let used_link_args = &codegen_results.crate_info.link_args;\n-\n-    if crate_type == config::CrateType::Executable {\n-        let mut position_independent_executable = false;\n-\n-        if t.options.position_independent_executables {\n-            let empty_vec = Vec::new();\n-            let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n-            let more_args = &sess.opts.cg.link_arg;\n-            let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n-\n-            if is_pic(sess) && !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n-                position_independent_executable = true;\n-            }\n-        }\n-\n-        if position_independent_executable {\n-            cmd.position_independent_executable();\n-        } else {\n-            // recent versions of gcc can be configured to generate position\n-            // independent executables by default. We have to pass -no-pie to\n-            // explicitly turn that off. Not applicable to ld.\n-            if sess.target.target.options.linker_is_gnu\n-                && flavor != LinkerFlavor::Ld {\n-                cmd.no_position_independent_executable();\n-            }\n-        }\n-    }\n-\n-    let relro_level = match sess.opts.debugging_opts.relro_level {\n-        Some(level) => level,\n-        None => t.options.relro_level,\n-    };\n-    match relro_level {\n-        RelroLevel::Full => {\n-            cmd.full_relro();\n-        },\n-        RelroLevel::Partial => {\n-            cmd.partial_relro();\n-        },\n-        RelroLevel::Off => {\n-            cmd.no_relro();\n-        },\n-        RelroLevel::None => {\n-        },\n-    }\n-\n-    // Pass optimization flags down to the linker.\n-    cmd.optimize();\n-\n-    // Pass debuginfo flags down to the linker.\n-    cmd.debuginfo();\n-\n-    // We want to, by default, prevent the compiler from accidentally leaking in\n-    // any system libraries, so we may explicitly ask linkers to not link to any\n-    // libraries by default. Note that this does not happen for windows because\n-    // windows pulls in some large number of libraries and I couldn't quite\n-    // figure out which subset we wanted.\n-    //\n-    // This is all naturally configurable via the standard methods as well.\n-    if !sess.opts.cg.default_linker_libraries.unwrap_or(false) &&\n-        t.options.no_default_libraries\n-    {\n-        cmd.no_default_libraries();\n-    }\n-\n-    // Take careful note of the ordering of the arguments we pass to the linker\n-    // here. Linkers will assume that things on the left depend on things to the\n-    // right. Things on the right cannot depend on things on the left. This is\n-    // all formally implemented in terms of resolving symbols (libs on the right\n-    // resolve unknown symbols of libs on the left, but not vice versa).\n-    //\n-    // For this reason, we have organized the arguments we pass to the linker as\n-    // such:\n-    //\n-    //  1. The local object that LLVM just generated\n-    //  2. Local native libraries\n-    //  3. Upstream rust libraries\n-    //  4. Upstream native libraries\n-    //\n-    // The rationale behind this ordering is that those items lower down in the\n-    // list can't depend on items higher up in the list. For example nothing can\n-    // depend on what we just generated (e.g., that'd be a circular dependency).\n-    // Upstream rust libraries are not allowed to depend on our local native\n-    // libraries as that would violate the structure of the DAG, in that\n-    // scenario they are required to link to them as well in a shared fashion.\n-    //\n-    // Note that upstream rust libraries may contain native dependencies as\n-    // well, but they also can't depend on what we just started to add to the\n-    // link line. And finally upstream native libraries can't depend on anything\n-    // in this DAG so far because they're only dylibs and dylibs can only depend\n-    // on other dylibs (e.g., other native deps).\n-    add_local_native_libraries(cmd, sess, codegen_results);\n-    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n-    add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n-\n-    // Tell the linker what we're doing.\n-    if crate_type != config::CrateType::Executable {\n-        cmd.build_dylib(out_filename);\n-    }\n-    if crate_type == config::CrateType::Executable && sess.crt_static() {\n-        cmd.build_static_executable();\n-    }\n-\n-    if sess.opts.debugging_opts.pgo_gen.enabled() {\n-        cmd.pgo_gen();\n-    }\n-\n-    // FIXME (#2397): At some point we want to rpath our guesses as to\n-    // where extern libraries might live, based on the\n-    // addl_lib_search_paths\n-    if sess.opts.cg.rpath {\n-        let target_triple = sess.opts.target_triple.triple();\n-        let mut get_install_prefix_lib_path = || {\n-            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n-            let mut path = PathBuf::from(install_prefix);\n-            path.push(&tlib);\n-\n-            path\n-        };\n-        let mut rpath_config = RPathConfig {\n-            used_crates: &codegen_results.crate_info.used_crates_dynamic,\n-            out_filename: out_filename.to_path_buf(),\n-            has_rpath: sess.target.target.options.has_rpath,\n-            is_like_osx: sess.target.target.options.is_like_osx,\n-            linker_is_gnu: sess.target.target.options.linker_is_gnu,\n-            get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n-        };\n-        cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n-    }\n-\n-    // Finally add all the linker arguments provided on the command line along\n-    // with any #[link_args] attributes found inside the crate\n-    if let Some(ref args) = sess.opts.cg.link_args {\n-        cmd.args(args);\n-    }\n-    cmd.args(&sess.opts.cg.link_arg);\n-    cmd.args(&used_link_args);\n-}\n-\n-// # Rust Crate linking\n-//\n-// Rust crates are not considered at all when creating an rlib output. All\n-// dependencies will be linked when producing the final output (instead of\n-// the intermediate rlib version)\n-fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n-                            sess: &'a Session,\n-                            codegen_results: &CodegenResults,\n-                            crate_type: config::CrateType,\n-                            tmpdir: &Path) {\n-    // All of the heavy lifting has previously been accomplished by the\n-    // dependency_format module of the compiler. This is just crawling the\n-    // output of that module, adding crates as necessary.\n-    //\n-    // Linking to a rlib involves just passing it to the linker (the linker\n-    // will slurp up the object files inside), and linking to a dynamic library\n-    // involves just passing the right -l flag.\n-\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n-\n-    // Invoke get_used_crates to ensure that we get a topological sorting of\n-    // crates.\n-    let deps = &codegen_results.crate_info.used_crates_dynamic;\n-\n-    // There's a few internal crates in the standard library (aka libcore and\n-    // libstd) which actually have a circular dependence upon one another. This\n-    // currently arises through \"weak lang items\" where libcore requires things\n-    // like `rust_begin_unwind` but libstd ends up defining it. To get this\n-    // circular dependence to work correctly in all situations we'll need to be\n-    // sure to correctly apply the `--start-group` and `--end-group` options to\n-    // GNU linkers, otherwise if we don't use any other symbol from the standard\n-    // library it'll get discarded and the whole application won't link.\n-    //\n-    // In this loop we're calculating the `group_end`, after which crate to\n-    // pass `--end-group` and `group_start`, before which crate to pass\n-    // `--start-group`. We currently do this by passing `--end-group` after\n-    // the first crate (when iterating backwards) that requires a lang item\n-    // defined somewhere else. Once that's set then when we've defined all the\n-    // necessary lang items we'll pass `--start-group`.\n-    //\n-    // Note that this isn't amazing logic for now but it should do the trick\n-    // for the current implementation of the standard library.\n-    let mut group_end = None;\n-    let mut group_start = None;\n-    let mut end_with = FxHashSet::default();\n-    let info = &codegen_results.crate_info;\n-    for &(cnum, _) in deps.iter().rev() {\n-        if let Some(missing) = info.missing_lang_items.get(&cnum) {\n-            end_with.extend(missing.iter().cloned());\n-            if end_with.len() > 0 && group_end.is_none() {\n-                group_end = Some(cnum);\n-            }\n-        }\n-        end_with.retain(|item| info.lang_item_to_crate.get(item) != Some(&cnum));\n-        if end_with.len() == 0 && group_end.is_some() {\n-            group_start = Some(cnum);\n-            break\n-        }\n-    }\n-\n-    // If we didn't end up filling in all lang items from upstream crates then\n-    // we'll be filling it in with our crate. This probably means we're the\n-    // standard library itself, so skip this for now.\n-    if group_end.is_some() && group_start.is_none() {\n-        group_end = None;\n-    }\n-\n-    let mut compiler_builtins = None;\n-\n-    for &(cnum, _) in deps.iter() {\n-        if group_start == Some(cnum) {\n-            cmd.group_start();\n-        }\n-\n-        // We may not pass all crates through to the linker. Some crates may\n-        // appear statically in an existing dylib, meaning we'll pick up all the\n-        // symbols from the dylib.\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        match data[cnum.as_usize() - 1] {\n-            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-            }\n-            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n-                link_sanitizer_runtime::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n-            }\n-            // compiler-builtins are always placed last to ensure that they're\n-            // linked correctly.\n-            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n-                assert!(compiler_builtins.is_none());\n-                compiler_builtins = Some(cnum);\n-            }\n-            Linkage::NotLinked |\n-            Linkage::IncludedFromDylib => {}\n-            Linkage::Static => {\n-                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-            }\n-            Linkage::Dynamic => {\n-                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n-            }\n-        }\n-\n-        if group_end == Some(cnum) {\n-            cmd.group_end();\n-        }\n-    }\n-\n-    // compiler-builtins are always placed last to ensure that they're\n-    // linked correctly.\n-    // We must always link the `compiler_builtins` crate statically. Even if it\n-    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n-    // is used)\n-    if let Some(cnum) = compiler_builtins {\n-        add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n-    }\n-\n-    // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(config: &config::Config, stem: &'a str) -> &'a str {\n-        if stem.starts_with(\"lib\") && !config.target.options.is_like_windows {\n-            &stem[3..]\n-        } else {\n-            stem\n-        }\n-    }\n-\n-    // We must link the sanitizer runtime using -Wl,--whole-archive but since\n-    // it's packed in a .rlib, it contains stuff that are not objects that will\n-    // make the linker error. So we must remove those bits from the .rlib before\n-    // linking it.\n-    fn link_sanitizer_runtime<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n-                              sess: &'a Session,\n-                              codegen_results: &CodegenResults,\n-                              tmpdir: &Path,\n-                              cnum: CrateNum) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        if sess.target.target.options.is_like_osx {\n-            // On Apple platforms, the sanitizer is always built as a dylib, and\n-            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n-            // rpath to the library as well (the rpath should be absolute, see\n-            // PR #41352 for details).\n-            //\n-            // FIXME: Remove this logic into librustc_*san once Cargo supports it\n-            let rpath = cratepath.parent().unwrap();\n-            let rpath = rpath.to_str().expect(\"non-utf8 component in path\");\n-            cmd.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n-        archive.update_symbols();\n-\n-        for f in archive.src_files() {\n-            if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n-                archive.remove_file(&f);\n-            }\n-        }\n-\n-        archive.build();\n-\n-        cmd.link_whole_rlib(&dst);\n-    }\n-\n-    // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO and\n-    // dynamic libraries. Specifically:\n-    //\n-    // * For LTO, we remove upstream object files.\n-    // * For dylibs we remove metadata and bytecode from upstream rlibs\n-    //\n-    // When performing LTO, almost(*) all of the bytecode from the upstream\n-    // libraries has already been included in our object file output. As a\n-    // result we need to remove the object files in the upstream libraries so\n-    // the linker doesn't try to include them twice (or whine about duplicate\n-    // symbols). We must continue to include the rest of the rlib, however, as\n-    // it may contain static native libraries which must be linked in.\n-    //\n-    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n-    // their bytecode wasn't included. The object files in those libraries must\n-    // still be passed to the linker.\n-    //\n-    // When making a dynamic library, linkers by default don't include any\n-    // object files in an archive if they're not necessary to resolve the link.\n-    // We basically want to convert the archive (rlib) to a dylib, though, so we\n-    // *do* want everything included in the output, regardless of whether the\n-    // linker thinks it's needed or not. As a result we must use the\n-    // --whole-archive option (or the platform equivalent). When using this\n-    // option the linker will fail if there are non-objects in the archive (such\n-    // as our own metadata and/or bytecode). All in all, for rlibs to be\n-    // entirely included in dylibs, we need to remove all non-object files.\n-    //\n-    // Note, however, that if we're not doing LTO or we're not producing a dylib\n-    // (aka we're making an executable), we can just pass the rlib blindly to\n-    // the linker (fast) because it's fine if it's not actually included as\n-    // we're at the end of the dependency chain.\n-    fn add_static_crate<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n-                        sess: &'a Session,\n-                        codegen_results: &CodegenResults,\n-                        tmpdir: &Path,\n-                        crate_type: config::CrateType,\n-                        cnum: CrateNum) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        // See the comment above in `link_staticlib` and `link_rlib` for why if\n-        // there's a static library that's not relevant we skip all object\n-        // files.\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-        let skip_native = native_libs.iter().any(|lib| {\n-            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n-        });\n-\n-        if (!are_upstream_rust_objects_already_included(sess) ||\n-            ignored_for_lto(sess, &codegen_results.crate_info, cnum)) &&\n-           crate_type != config::CrateType::Dylib &&\n-           !skip_native {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n-            return\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let name = cratepath.file_name().unwrap().to_str().unwrap();\n-        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-\n-        time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n-            let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n-            archive.update_symbols();\n-\n-            let mut any_objects = false;\n-            for f in archive.src_files() {\n-                if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n-                    archive.remove_file(&f);\n-                    continue\n-                }\n-\n-                let canonical = f.replace(\"-\", \"_\");\n-                let canonical_name = name.replace(\"-\", \"_\");\n-\n-                // Look for `.rcgu.o` at the end of the filename to conclude\n-                // that this is a Rust-related object file.\n-                fn looks_like_rust(s: &str) -> bool {\n-                    let path = Path::new(s);\n-                    let ext = path.extension().and_then(|s| s.to_str());\n-                    if ext != Some(OutputType::Object.extension()) {\n-                        return false\n-                    }\n-                    let ext2 = path.file_stem()\n-                        .and_then(|s| Path::new(s).extension())\n-                        .and_then(|s| s.to_str());\n-                    ext2 == Some(RUST_CGU_EXT)\n-                }\n-\n-                let is_rust_object =\n-                    canonical.starts_with(&canonical_name) &&\n-                    looks_like_rust(&f);\n-\n-                // If we've been requested to skip all native object files\n-                // (those not generated by the rust compiler) then we can skip\n-                // this file. See above for why we may want to do this.\n-                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n-\n-                // If we're performing LTO and this is a rust-generated object\n-                // file, then we don't need the object file as it's part of the\n-                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                // though, so we let that object file slide.\n-                let skip_because_lto = are_upstream_rust_objects_already_included(sess) &&\n-                    is_rust_object &&\n-                    (sess.target.target.options.no_builtins ||\n-                     !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n-\n-                if skip_because_cfg_say_so || skip_because_lto {\n-                    archive.remove_file(&f);\n-                } else {\n-                    any_objects = true;\n-                }\n-            }\n-\n-            if !any_objects {\n-                return\n-            }\n-            archive.build();\n-\n-            // If we're creating a dylib, then we need to include the\n-            // whole of each object in our archive into that artifact. This is\n-            // because a `dylib` can be reused as an intermediate artifact.\n-            //\n-            // Note, though, that we don't want to include the whole of a\n-            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n-            // repeatedly linked anyway.\n-            if crate_type == config::CrateType::Dylib &&\n-                codegen_results.crate_info.compiler_builtins != Some(cnum) {\n-                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            } else {\n-                cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n-            }\n-        });\n-    }\n-\n-    // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n-        // Just need to tell the linker about where the library lives and\n-        // what its name is\n-        let parent = cratepath.parent();\n-        if let Some(dir) = parent {\n-            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n-        }\n-        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_rust_dylib(&unlib(&sess.target, filestem),\n-                            parent.unwrap_or(Path::new(\"\")));\n-    }\n-}\n-\n-fn is_pic(sess: &Session) -> bool {\n-    let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => &s[..],\n-        None => &sess.target.target.options.relocation_model[..],\n-    };\n-\n-    reloc_model_arg == \"pic\"\n+    outputs: &OutputFilenames,\n+    crate_name: &str,\n+) -> Vec<PathBuf> {\n+    let target_cpu = crate::llvm_util::target_cpu(sess);\n+    rustc_codegen_ssa::back::link::link_binary::<LlvmArchiveBuilder<'a>>(\n+        sess,\n+        codegen_results,\n+        outputs,\n+        crate_name,\n+        target_cpu,\n+    )\n }"}, {"sha": "8283d1aa1b5d26ad57a54ffcccfdf66d33121014", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=93a3b414e33b2bc47805f47b75b6dc8aa548df33", "patch": "@@ -44,8 +44,6 @@ extern crate rustc_fs_util;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n-extern crate serialize;\n-extern crate tempfile;\n \n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, FatLTOInput};\n@@ -78,8 +76,6 @@ mod back {\n     pub mod link;\n     pub mod lto;\n     pub mod write;\n-    mod rpath;\n-    pub mod wasm;\n }\n \n mod abi;"}, {"sha": "af99d39182c248c9bb534b5719204942cde0d496", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=93a3b414e33b2bc47805f47b75b6dc8aa548df33", "patch": "@@ -20,6 +20,7 @@ log = \"0.4.5\"\n libc = \"0.2.44\"\n jobserver = \"0.1.11\"\n parking_lot = \"0.7\"\n+tempfile = \"3.0.5\"\n \n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "acd2237617fbfb27e492fc8ab3a2e9aadb4dfbb8", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1096, "deletions": 5, "changes": 1101, "blob_url": "https://github.com/rust-lang/rust/blob/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=93a3b414e33b2bc47805f47b75b6dc8aa548df33", "patch": "@@ -1,24 +1,36 @@\n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n \n-use rustc::session::{Session, config};\n+use rustc::session::{Session, filesearch};\n+use rustc::session::config::{\n+    self, RUST_CGU_EXT, DebugInfo, OutputFilenames, OutputType, PrintRequest, Sanitizer\n+};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::cstore::{LibSource, NativeLibrary, NativeLibraryKind};\n-use rustc_target::spec::LinkerFlavor;\n+use rustc::util::common::{time, time_ext};\n use rustc::hir::def_id::CrateNum;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n+use rustc_target::spec::{PanicStrategy, RelroLevel, LinkerFlavor};\n \n+use crate::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION, CrateInfo, CodegenResults};\n+use super::archive::ArchiveBuilder;\n use super::command::Command;\n-use crate::{CrateInfo, CodegenResults};\n-use crate::back::linker::Linker;\n+use super::linker::Linker;\n+use super::rpath::{self, RPathConfig};\n \n use cc::windows_registry;\n+use tempfile::{Builder as TempFileBuilder, TempDir};\n+\n+use std::ascii;\n+use std::char;\n use std::fmt;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n use std::process::{Output, Stdio};\n+use std::str;\n use std::env;\n \n pub use rustc_codegen_utils::link::*;\n@@ -31,6 +43,122 @@ pub fn remove(sess: &Session, path: &Path) {\n     }\n }\n \n+/// Performs the linkage portion of the compilation phase. This will generate all\n+/// of the requested outputs for this compilation session.\n+pub fn link_binary<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                          codegen_results: &CodegenResults,\n+                          outputs: &OutputFilenames,\n+                          crate_name: &str,\n+                          target_cpu: &str) -> Vec<PathBuf> {\n+    let mut out_filenames = Vec::new();\n+    for &crate_type in sess.crate_types.borrow().iter() {\n+        // Ignore executable crates if we have -Z no-codegen, as they will error.\n+        let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n+        if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen()) &&\n+           !output_metadata &&\n+           crate_type == config::CrateType::Executable {\n+            continue;\n+        }\n+\n+        if invalid_output_for_target(sess, crate_type) {\n+           bug!(\"invalid output type `{:?}` for target os `{}`\",\n+                crate_type, sess.opts.target_triple);\n+        }\n+        let out_files = link_binary_output::<B>(sess,\n+                                           codegen_results,\n+                                           crate_type,\n+                                           outputs,\n+                                           crate_name,\n+                                           target_cpu);\n+        out_filenames.extend(out_files);\n+    }\n+\n+    // Remove the temporary object file and metadata if we aren't saving temps\n+    if !sess.opts.cg.save_temps {\n+        if sess.opts.output_types.should_codegen() && !preserve_objects_for_their_debuginfo(sess) {\n+            for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+                remove(sess, obj);\n+            }\n+        }\n+        for obj in codegen_results.modules.iter().filter_map(|m| m.bytecode_compressed.as_ref()) {\n+            remove(sess, obj);\n+        }\n+        if let Some(ref obj) = codegen_results.metadata_module.object {\n+            remove(sess, obj);\n+        }\n+        if let Some(ref allocator) = codegen_results.allocator_module {\n+            if let Some(ref obj) = allocator.object {\n+                remove(sess, obj);\n+            }\n+            if let Some(ref bc) = allocator.bytecode_compressed {\n+                remove(sess, bc);\n+            }\n+        }\n+    }\n+\n+    out_filenames\n+}\n+\n+fn link_binary_output<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                      codegen_results: &CodegenResults,\n+                      crate_type: config::CrateType,\n+                      outputs: &OutputFilenames,\n+                      crate_name: &str,\n+                      target_cpu: &str) -> Vec<PathBuf> {\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        check_file_is_writeable(obj, sess);\n+    }\n+\n+    let mut out_filenames = vec![];\n+\n+    if outputs.outputs.contains_key(&OutputType::Metadata) {\n+        let out_filename = filename_for_metadata(sess, crate_name, outputs);\n+        // To avoid races with another rustc process scanning the output directory,\n+        // we need to write the file somewhere else and atomically move it to its\n+        // final destination, with a `fs::rename` call. In order for the rename to\n+        // always succeed, the temporary file needs to be on the same filesystem,\n+        // which is why we create it inside the output directory specifically.\n+        let metadata_tmpdir = TempFileBuilder::new()\n+            .prefix(\"rmeta\")\n+            .tempdir_in(out_filename.parent().unwrap())\n+            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+        let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n+        if let Err(e) = fs::rename(metadata, &out_filename) {\n+            sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+        }\n+        out_filenames.push(out_filename);\n+    }\n+\n+    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n+        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+\n+    if outputs.outputs.should_codegen() {\n+        let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n+        match crate_type {\n+            config::CrateType::Rlib => {\n+                link_rlib::<B>(sess,\n+                          codegen_results,\n+                          RlibFlavor::Normal,\n+                          &out_filename,\n+                          &tmpdir).build();\n+            }\n+            config::CrateType::Staticlib => {\n+                link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n+            }\n+            _ => {\n+                link_natively::<B>(sess, crate_type, &out_filename, codegen_results, tmpdir.path(), target_cpu);\n+            }\n+        }\n+        out_filenames.push(out_filename);\n+    }\n+\n+    if sess.opts.cg.save_temps {\n+        let _ = tmpdir.into_path();\n+    }\n+\n+    out_filenames\n+}\n+\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n@@ -123,6 +251,444 @@ pub fn each_linked_rlib(sess: &Session,\n     Ok(())\n }\n \n+/// We use a temp directory here to avoid races between concurrent rustc processes,\n+/// such as builds in the same directory using the same filename for metadata while\n+/// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n+/// directory being searched for `extern crate` (observing an incomplete file).\n+/// The returned path is the temporary file containing the complete metadata.\n+fn emit_metadata<'a>(\n+    sess: &'a Session,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &TempDir\n+) -> PathBuf {\n+    let out_filename = tmpdir.path().join(METADATA_FILENAME);\n+    let result = fs::write(&out_filename, &codegen_results.metadata.raw_data);\n+\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+    }\n+\n+    out_filename\n+}\n+\n+// Create an 'rlib'\n+//\n+// An rlib in its current incarnation is essentially a renamed .a file. The\n+// rlib primarily contains the object file of the crate, but it also contains\n+// all of the object files from native libraries. This is done by unzipping\n+// native libraries and inserting all of the contents into this archive.\n+fn link_rlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                 codegen_results: &CodegenResults,\n+                 flavor: RlibFlavor,\n+                 out_filename: &Path,\n+                 tmpdir: &TempDir) -> B {\n+    info!(\"preparing rlib to {:?}\", out_filename);\n+    let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n+\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        ab.add_file(obj);\n+    }\n+\n+    // Note that in this loop we are ignoring the value of `lib.cfg`. That is,\n+    // we may not be configured to actually include a static library if we're\n+    // adding it here. That's because later when we consume this rlib we'll\n+    // decide whether we actually needed the static library or not.\n+    //\n+    // To do this \"correctly\" we'd need to keep track of which libraries added\n+    // which object files to the archive. We don't do that here, however. The\n+    // #[link(cfg(..))] feature is unstable, though, and only intended to get\n+    // liblibc working. In that sense the check below just indicates that if\n+    // there are any libraries we want to omit object files for at link time we\n+    // just exclude all custom object files.\n+    //\n+    // Eventually if we want to stabilize or flesh out the #[link(cfg(..))]\n+    // feature then we'll need to figure out how to record what objects were\n+    // loaded from the libraries found here and then encode that into the\n+    // metadata of the rlib we're generating somehow.\n+    for lib in codegen_results.crate_info.used_libraries.iter() {\n+        match lib.kind {\n+            NativeLibraryKind::NativeStatic => {}\n+            NativeLibraryKind::NativeStaticNobundle |\n+            NativeLibraryKind::NativeFramework |\n+            NativeLibraryKind::NativeUnknown => continue,\n+        }\n+        if let Some(name) = lib.name {\n+            ab.add_native_library(&name.as_str());\n+        }\n+    }\n+\n+    // After adding all files to the archive, we need to update the\n+    // symbol table of the archive.\n+    ab.update_symbols();\n+\n+    // Note that it is important that we add all of our non-object \"magical\n+    // files\" *after* all of the object files in the archive. The reason for\n+    // this is as follows:\n+    //\n+    // * When performing LTO, this archive will be modified to remove\n+    //   objects from above. The reason for this is described below.\n+    //\n+    // * When the system linker looks at an archive, it will attempt to\n+    //   determine the architecture of the archive in order to see whether its\n+    //   linkable.\n+    //\n+    //   The algorithm for this detection is: iterate over the files in the\n+    //   archive. Skip magical SYMDEF names. Interpret the first file as an\n+    //   object file. Read architecture from the object file.\n+    //\n+    // * As one can probably see, if \"metadata\" and \"foo.bc\" were placed\n+    //   before all of the objects, then the architecture of this archive would\n+    //   not be correctly inferred once 'foo.o' is removed.\n+    //\n+    // Basically, all this means is that this code should not move above the\n+    // code above.\n+    match flavor {\n+        RlibFlavor::Normal => {\n+            // Instead of putting the metadata in an object file section, rlibs\n+            // contain the metadata in a separate file.\n+            ab.add_file(&emit_metadata(sess, codegen_results, tmpdir));\n+\n+            // For LTO purposes, the bytecode of this library is also inserted\n+            // into the archive.\n+            for bytecode in codegen_results\n+                .modules\n+                .iter()\n+                .filter_map(|m| m.bytecode_compressed.as_ref())\n+            {\n+                ab.add_file(bytecode);\n+            }\n+\n+            // After adding all files to the archive, we need to update the\n+            // symbol table of the archive. This currently dies on macOS (see\n+            // #11162), and isn't necessary there anyway\n+            if !sess.target.target.options.is_like_osx {\n+                ab.update_symbols();\n+            }\n+        }\n+\n+        RlibFlavor::StaticlibBase => {\n+            let obj = codegen_results.allocator_module\n+                .as_ref()\n+                .and_then(|m| m.object.as_ref());\n+            if let Some(obj) = obj {\n+                ab.add_file(obj);\n+            }\n+        }\n+    }\n+\n+    ab\n+}\n+\n+// Create a static archive\n+//\n+// This is essentially the same thing as an rlib, but it also involves adding\n+// all of the upstream crates' objects into the archive. This will slurp in\n+// all of the native libraries of upstream dependencies as well.\n+//\n+// Additionally, there's no way for us to link dynamic libraries, so we warn\n+// about all dynamic library dependencies that they're not linked in.\n+//\n+// There's no need to include metadata in a static archive, so ensure to not\n+// link in the metadata object file (and also don't prepare the archive with a\n+// metadata file).\n+fn link_staticlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                  codegen_results: &CodegenResults,\n+                  out_filename: &Path,\n+                  tempdir: &TempDir) {\n+    let mut ab = link_rlib::<B>(sess,\n+                           codegen_results,\n+                           RlibFlavor::StaticlibBase,\n+                           out_filename,\n+                           tempdir);\n+    let mut all_native_libs = vec![];\n+\n+    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n+        let name = &codegen_results.crate_info.crate_name[&cnum];\n+        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+\n+        // Here when we include the rlib into our staticlib we need to make a\n+        // decision whether to include the extra object files along the way.\n+        // These extra object files come from statically included native\n+        // libraries, but they may be cfg'd away with #[link(cfg(..))].\n+        //\n+        // This unstable feature, though, only needs liblibc to work. The only\n+        // use case there is where musl is statically included in liblibc.rlib,\n+        // so if we don't want the included version we just need to skip it. As\n+        // a result the logic here is that if *any* linked library is cfg'd away\n+        // we just skip all object files.\n+        //\n+        // Clearly this is not sufficient for a general purpose feature, and\n+        // we'd want to read from the library's metadata to determine which\n+        // object files come from where and selectively skip them.\n+        let skip_object_files = native_libs.iter().any(|lib| {\n+            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n+        });\n+        ab.add_rlib(path,\n+                    &name.as_str(),\n+                    are_upstream_rust_objects_already_included(sess) &&\n+                        !ignored_for_lto(sess, &codegen_results.crate_info, cnum),\n+                    skip_object_files).unwrap();\n+\n+        all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n+    });\n+    if let Err(e) = res {\n+        sess.fatal(&e);\n+    }\n+\n+    ab.update_symbols();\n+    ab.build();\n+\n+    if !all_native_libs.is_empty() {\n+        if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n+            print_native_static_libs(sess, &all_native_libs);\n+        }\n+    }\n+}\n+\n+// Create a dynamic library or executable\n+//\n+// This will invoke the system linker/cc to create the resulting file. This\n+// links to all upstream files as well.\n+fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n+                 crate_type: config::CrateType,\n+                 out_filename: &Path,\n+                 codegen_results: &CodegenResults,\n+                 tmpdir: &Path,\n+                 target_cpu: &str) {\n+    info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n+    let (linker, flavor) = linker_and_flavor(sess);\n+\n+    // The invocations of cc share some flags across platforms\n+    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n+\n+    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n+        if sess.crt_static() {\n+            cmd.args(args);\n+        }\n+    }\n+    if let Some(ref args) = sess.opts.debugging_opts.pre_link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&sess.opts.debugging_opts.pre_link_arg);\n+\n+    if sess.target.target.options.is_like_fuchsia {\n+        let prefix = match sess.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => \"asan/\",\n+            _ => \"\",\n+        };\n+        cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n+    }\n+\n+    let pre_link_objects = if crate_type == config::CrateType::Executable {\n+        &sess.target.target.options.pre_link_objects_exe\n+    } else {\n+        &sess.target.target.options.pre_link_objects_dll\n+    };\n+    for obj in pre_link_objects {\n+        cmd.arg(get_file_path(sess, obj));\n+    }\n+\n+    if crate_type == config::CrateType::Executable && sess.crt_static() {\n+        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n+            cmd.arg(get_file_path(sess, obj));\n+        }\n+    }\n+\n+    if sess.target.target.options.is_like_emscripten {\n+        cmd.arg(\"-s\");\n+        cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n+            \"DISABLE_EXCEPTION_CATCHING=1\"\n+        } else {\n+            \"DISABLE_EXCEPTION_CATCHING=0\"\n+        });\n+    }\n+\n+    {\n+        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor, target_cpu);\n+        link_args::<B>(&mut *linker, flavor, sess, crate_type, tmpdir,\n+                  out_filename, codegen_results);\n+        cmd = linker.finalize();\n+    }\n+    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    for obj in &sess.target.target.options.post_link_objects {\n+        cmd.arg(get_file_path(sess, obj));\n+    }\n+    if sess.crt_static() {\n+        for obj in &sess.target.target.options.post_link_objects_crt {\n+            cmd.arg(get_file_path(sess, obj));\n+        }\n+    }\n+    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n+        cmd.args(args);\n+    }\n+    for &(ref k, ref v) in &sess.target.target.options.link_env {\n+        cmd.env(k, v);\n+    }\n+\n+    if sess.opts.debugging_opts.print_link_args {\n+        println!(\"{:?}\", &cmd);\n+    }\n+\n+    // May have not found libraries in the right formats.\n+    sess.abort_if_errors();\n+\n+    // Invoke the system linker\n+    //\n+    // Note that there's a terribly awful hack that really shouldn't be present\n+    // in any compiler. Here an environment variable is supported to\n+    // automatically retry the linker invocation if the linker looks like it\n+    // segfaulted.\n+    //\n+    // Gee that seems odd, normally segfaults are things we want to know about!\n+    // Unfortunately though in rust-lang/rust#38878 we're experiencing the\n+    // linker segfaulting on Travis quite a bit which is causing quite a bit of\n+    // pain to land PRs when they spuriously fail due to a segfault.\n+    //\n+    // The issue #38878 has some more debugging information on it as well, but\n+    // this unfortunately looks like it's just a race condition in macOS's linker\n+    // with some thread pool working in the background. It seems that no one\n+    // currently knows a fix for this so in the meantime we're left with this...\n+    info!(\"{:?}\", &cmd);\n+    let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n+    let mut prog;\n+    let mut i = 0;\n+    loop {\n+        i += 1;\n+        prog = time(sess, \"running linker\", || {\n+            exec_linker(sess, &mut cmd, out_filename, tmpdir)\n+        });\n+        let output = match prog {\n+            Ok(ref output) => output,\n+            Err(_) => break,\n+        };\n+        if output.status.success() {\n+            break\n+        }\n+        let mut out = output.stderr.clone();\n+        out.extend(&output.stdout);\n+        let out = String::from_utf8_lossy(&out);\n+\n+        // Check to see if the link failed with \"unrecognized command line option:\n+        // '-no-pie'\" for gcc or \"unknown argument: '-no-pie'\" for clang. If so,\n+        // reperform the link step without the -no-pie option. This is safe because\n+        // if the linker doesn't support -no-pie then it should not default to\n+        // linking executables as pie. Different versions of gcc seem to use\n+        // different quotes in the error message so don't check for them.\n+        if sess.target.target.options.linker_is_gnu &&\n+           flavor != LinkerFlavor::Ld &&\n+           (out.contains(\"unrecognized command line option\") ||\n+            out.contains(\"unknown argument\")) &&\n+           out.contains(\"-no-pie\") &&\n+           cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-no-pie\") {\n+            info!(\"linker output: {:?}\", out);\n+            warn!(\"Linker does not support -no-pie command line option. Retrying without.\");\n+            for arg in cmd.take_args() {\n+                if arg.to_string_lossy() != \"-no-pie\" {\n+                    cmd.arg(arg);\n+                }\n+            }\n+            info!(\"{:?}\", &cmd);\n+            continue;\n+        }\n+        if !retry_on_segfault || i > 3 {\n+            break\n+        }\n+        let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n+        let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n+        if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n+            break\n+        }\n+\n+        warn!(\n+            \"looks like the linker segfaulted when we tried to call it, \\\n+             automatically retrying again. cmd = {:?}, out = {}.\",\n+            cmd,\n+            out,\n+        );\n+    }\n+\n+    match prog {\n+        Ok(prog) => {\n+            fn escape_string(s: &[u8]) -> String {\n+                str::from_utf8(s).map(|s| s.to_owned())\n+                    .unwrap_or_else(|_| {\n+                        let mut x = \"Non-UTF-8 output: \".to_string();\n+                        x.extend(s.iter()\n+                                  .flat_map(|&b| ascii::escape_default(b))\n+                                  .map(char::from));\n+                        x\n+                    })\n+            }\n+            if !prog.status.success() {\n+                let mut output = prog.stderr.clone();\n+                output.extend_from_slice(&prog.stdout);\n+                sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n+                                         pname.display(),\n+                                         prog.status))\n+                    .note(&format!(\"{:?}\", &cmd))\n+                    .note(&escape_string(&output))\n+                    .emit();\n+                sess.abort_if_errors();\n+            }\n+            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n+        },\n+        Err(e) => {\n+            let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n+\n+            let mut linker_error = {\n+                if linker_not_found {\n+                    sess.struct_err(&format!(\"linker `{}` not found\", pname.display()))\n+                } else {\n+                    sess.struct_err(&format!(\"could not exec the linker `{}`\", pname.display()))\n+                }\n+            };\n+\n+            linker_error.note(&e.to_string());\n+\n+            if !linker_not_found {\n+                linker_error.note(&format!(\"{:?}\", &cmd));\n+            }\n+\n+            linker_error.emit();\n+\n+            if sess.target.target.options.is_like_msvc && linker_not_found {\n+                sess.note_without_error(\"the msvc targets depend on the msvc linker \\\n+                    but `link.exe` was not found\");\n+                sess.note_without_error(\"please ensure that VS 2013, VS 2015 or VS 2017 \\\n+                    was installed with the Visual C++ option\");\n+            }\n+            sess.abort_if_errors();\n+        }\n+    }\n+\n+\n+    // On macOS, debuggers need this utility to get run to do some munging of\n+    // the symbols. Note, though, that if the object files are being preserved\n+    // for their debug information there's no need for us to run dsymutil.\n+    if sess.target.target.options.is_like_osx &&\n+        sess.opts.debuginfo != DebugInfo::None &&\n+        !preserve_objects_for_their_debuginfo(sess)\n+    {\n+        if let Err(e) = Command::new(\"dsymutil\").arg(out_filename).output() {\n+            sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n+        }\n+    }\n+\n+    if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n+        super::wasm::add_producer_section(\n+            &out_filename,\n+            &sess.edition().to_string(),\n+            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n+        );\n+    }\n+}\n+\n /// Returns a boolean indicating whether the specified crate should be ignored\n /// during LTO.\n ///\n@@ -258,7 +824,7 @@ pub fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     sess.target_filesearch(PathKind::Native).search_path_dirs()\n }\n \n-pub enum RlibFlavor {\n+enum RlibFlavor {\n     Normal,\n     StaticlibBase,\n }\n@@ -451,6 +1017,209 @@ pub fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdi\n     }\n }\n \n+fn link_args<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+             flavor: LinkerFlavor,\n+             sess: &'a Session,\n+             crate_type: config::CrateType,\n+             tmpdir: &Path,\n+             out_filename: &Path,\n+             codegen_results: &CodegenResults) {\n+\n+    // Linker plugins should be specified early in the list of arguments\n+    cmd.linker_plugin_lto();\n+\n+    // The default library location, we need this to find the runtime.\n+    // The location of crates will be determined as needed.\n+    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+\n+    // target descriptor\n+    let t = &sess.target.target;\n+\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+    for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n+        cmd.add_object(obj);\n+    }\n+    cmd.output_filename(out_filename);\n+\n+    if crate_type == config::CrateType::Executable &&\n+       sess.target.target.options.is_like_windows {\n+        if let Some(ref s) = codegen_results.windows_subsystem {\n+            cmd.subsystem(s);\n+        }\n+    }\n+\n+    // If we're building a dynamic library then some platforms need to make sure\n+    // that all symbols are exported correctly from the dynamic library.\n+    if crate_type != config::CrateType::Executable ||\n+       sess.target.target.options.is_like_emscripten {\n+        cmd.export_symbols(tmpdir, crate_type);\n+    }\n+\n+    // When linking a dynamic library, we put the metadata into a section of the\n+    // executable. This metadata is in a separate object file from the main\n+    // object file, so we link that in here.\n+    if crate_type == config::CrateType::Dylib ||\n+       crate_type == config::CrateType::ProcMacro {\n+        if let Some(obj) = codegen_results.metadata_module.object.as_ref() {\n+            cmd.add_object(obj);\n+        }\n+    }\n+\n+    let obj = codegen_results.allocator_module\n+        .as_ref()\n+        .and_then(|m| m.object.as_ref());\n+    if let Some(obj) = obj {\n+        cmd.add_object(obj);\n+    }\n+\n+    // Try to strip as much out of the generated object by removing unused\n+    // sections if possible. See more comments in linker.rs\n+    if !sess.opts.cg.link_dead_code {\n+        let keep_metadata = crate_type == config::CrateType::Dylib;\n+        cmd.gc_sections(keep_metadata);\n+    }\n+\n+    let used_link_args = &codegen_results.crate_info.link_args;\n+\n+    if crate_type == config::CrateType::Executable {\n+        let mut position_independent_executable = false;\n+\n+        if t.options.position_independent_executables {\n+            let empty_vec = Vec::new();\n+            let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n+            let more_args = &sess.opts.cg.link_arg;\n+            let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n+\n+            if is_pic(sess) && !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n+                position_independent_executable = true;\n+            }\n+        }\n+\n+        if position_independent_executable {\n+            cmd.position_independent_executable();\n+        } else {\n+            // recent versions of gcc can be configured to generate position\n+            // independent executables by default. We have to pass -no-pie to\n+            // explicitly turn that off. Not applicable to ld.\n+            if sess.target.target.options.linker_is_gnu\n+                && flavor != LinkerFlavor::Ld {\n+                cmd.no_position_independent_executable();\n+            }\n+        }\n+    }\n+\n+    let relro_level = match sess.opts.debugging_opts.relro_level {\n+        Some(level) => level,\n+        None => t.options.relro_level,\n+    };\n+    match relro_level {\n+        RelroLevel::Full => {\n+            cmd.full_relro();\n+        },\n+        RelroLevel::Partial => {\n+            cmd.partial_relro();\n+        },\n+        RelroLevel::Off => {\n+            cmd.no_relro();\n+        },\n+        RelroLevel::None => {\n+        },\n+    }\n+\n+    // Pass optimization flags down to the linker.\n+    cmd.optimize();\n+\n+    // Pass debuginfo flags down to the linker.\n+    cmd.debuginfo();\n+\n+    // We want to, by default, prevent the compiler from accidentally leaking in\n+    // any system libraries, so we may explicitly ask linkers to not link to any\n+    // libraries by default. Note that this does not happen for windows because\n+    // windows pulls in some large number of libraries and I couldn't quite\n+    // figure out which subset we wanted.\n+    //\n+    // This is all naturally configurable via the standard methods as well.\n+    if !sess.opts.cg.default_linker_libraries.unwrap_or(false) &&\n+        t.options.no_default_libraries\n+    {\n+        cmd.no_default_libraries();\n+    }\n+\n+    // Take careful note of the ordering of the arguments we pass to the linker\n+    // here. Linkers will assume that things on the left depend on things to the\n+    // right. Things on the right cannot depend on things on the left. This is\n+    // all formally implemented in terms of resolving symbols (libs on the right\n+    // resolve unknown symbols of libs on the left, but not vice versa).\n+    //\n+    // For this reason, we have organized the arguments we pass to the linker as\n+    // such:\n+    //\n+    //  1. The local object that LLVM just generated\n+    //  2. Local native libraries\n+    //  3. Upstream rust libraries\n+    //  4. Upstream native libraries\n+    //\n+    // The rationale behind this ordering is that those items lower down in the\n+    // list can't depend on items higher up in the list. For example nothing can\n+    // depend on what we just generated (e.g., that'd be a circular dependency).\n+    // Upstream rust libraries are not allowed to depend on our local native\n+    // libraries as that would violate the structure of the DAG, in that\n+    // scenario they are required to link to them as well in a shared fashion.\n+    //\n+    // Note that upstream rust libraries may contain native dependencies as\n+    // well, but they also can't depend on what we just started to add to the\n+    // link line. And finally upstream native libraries can't depend on anything\n+    // in this DAG so far because they're only dylibs and dylibs can only depend\n+    // on other dylibs (e.g., other native deps).\n+    add_local_native_libraries(cmd, sess, codegen_results);\n+    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n+    add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n+\n+    // Tell the linker what we're doing.\n+    if crate_type != config::CrateType::Executable {\n+        cmd.build_dylib(out_filename);\n+    }\n+    if crate_type == config::CrateType::Executable && sess.crt_static() {\n+        cmd.build_static_executable();\n+    }\n+\n+    if sess.opts.debugging_opts.pgo_gen.enabled() {\n+        cmd.pgo_gen();\n+    }\n+\n+    // FIXME (#2397): At some point we want to rpath our guesses as to\n+    // where extern libraries might live, based on the\n+    // addl_lib_search_paths\n+    if sess.opts.cg.rpath {\n+        let target_triple = sess.opts.target_triple.triple();\n+        let mut get_install_prefix_lib_path = || {\n+            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n+            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n+            let mut path = PathBuf::from(install_prefix);\n+            path.push(&tlib);\n+\n+            path\n+        };\n+        let mut rpath_config = RPathConfig {\n+            used_crates: &codegen_results.crate_info.used_crates_dynamic,\n+            out_filename: out_filename.to_path_buf(),\n+            has_rpath: sess.target.target.options.has_rpath,\n+            is_like_osx: sess.target.target.options.is_like_osx,\n+            linker_is_gnu: sess.target.target.options.linker_is_gnu,\n+            get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n+        };\n+        cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n+    }\n+\n+    // Finally add all the linker arguments provided on the command line along\n+    // with any #[link_args] attributes found inside the crate\n+    if let Some(ref args) = sess.opts.cg.link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&sess.opts.cg.link_arg);\n+    cmd.args(&used_link_args);\n+}\n+\n // # Native library linking\n //\n // User-supplied library search paths (-L on the command line). These are\n@@ -493,6 +1262,319 @@ pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n     }\n }\n \n+// # Rust Crate linking\n+//\n+// Rust crates are not considered at all when creating an rlib output. All\n+// dependencies will be linked when producing the final output (instead of\n+// the intermediate rlib version)\n+fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                            sess: &'a Session,\n+                            codegen_results: &CodegenResults,\n+                            crate_type: config::CrateType,\n+                            tmpdir: &Path) {\n+    // All of the heavy lifting has previously been accomplished by the\n+    // dependency_format module of the compiler. This is just crawling the\n+    // output of that module, adding crates as necessary.\n+    //\n+    // Linking to a rlib involves just passing it to the linker (the linker\n+    // will slurp up the object files inside), and linking to a dynamic library\n+    // involves just passing the right -l flag.\n+\n+    let formats = sess.dependency_formats.borrow();\n+    let data = formats.get(&crate_type).unwrap();\n+\n+    // Invoke get_used_crates to ensure that we get a topological sorting of\n+    // crates.\n+    let deps = &codegen_results.crate_info.used_crates_dynamic;\n+\n+    // There's a few internal crates in the standard library (aka libcore and\n+    // libstd) which actually have a circular dependence upon one another. This\n+    // currently arises through \"weak lang items\" where libcore requires things\n+    // like `rust_begin_unwind` but libstd ends up defining it. To get this\n+    // circular dependence to work correctly in all situations we'll need to be\n+    // sure to correctly apply the `--start-group` and `--end-group` options to\n+    // GNU linkers, otherwise if we don't use any other symbol from the standard\n+    // library it'll get discarded and the whole application won't link.\n+    //\n+    // In this loop we're calculating the `group_end`, after which crate to\n+    // pass `--end-group` and `group_start`, before which crate to pass\n+    // `--start-group`. We currently do this by passing `--end-group` after\n+    // the first crate (when iterating backwards) that requires a lang item\n+    // defined somewhere else. Once that's set then when we've defined all the\n+    // necessary lang items we'll pass `--start-group`.\n+    //\n+    // Note that this isn't amazing logic for now but it should do the trick\n+    // for the current implementation of the standard library.\n+    let mut group_end = None;\n+    let mut group_start = None;\n+    let mut end_with = FxHashSet::default();\n+    let info = &codegen_results.crate_info;\n+    for &(cnum, _) in deps.iter().rev() {\n+        if let Some(missing) = info.missing_lang_items.get(&cnum) {\n+            end_with.extend(missing.iter().cloned());\n+            if end_with.len() > 0 && group_end.is_none() {\n+                group_end = Some(cnum);\n+            }\n+        }\n+        end_with.retain(|item| info.lang_item_to_crate.get(item) != Some(&cnum));\n+        if end_with.len() == 0 && group_end.is_some() {\n+            group_start = Some(cnum);\n+            break\n+        }\n+    }\n+\n+    // If we didn't end up filling in all lang items from upstream crates then\n+    // we'll be filling it in with our crate. This probably means we're the\n+    // standard library itself, so skip this for now.\n+    if group_end.is_some() && group_start.is_none() {\n+        group_end = None;\n+    }\n+\n+    let mut compiler_builtins = None;\n+\n+    for &(cnum, _) in deps.iter() {\n+        if group_start == Some(cnum) {\n+            cmd.group_start();\n+        }\n+\n+        // We may not pass all crates through to the linker. Some crates may\n+        // appear statically in an existing dylib, meaning we'll pick up all the\n+        // symbols from the dylib.\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        match data[cnum.as_usize() - 1] {\n+            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n+                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+            }\n+            _ if codegen_results.crate_info.sanitizer_runtime == Some(cnum) => {\n+                link_sanitizer_runtime::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+            }\n+            // compiler-builtins are always placed last to ensure that they're\n+            // linked correctly.\n+            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n+                assert!(compiler_builtins.is_none());\n+                compiler_builtins = Some(cnum);\n+            }\n+            Linkage::NotLinked |\n+            Linkage::IncludedFromDylib => {}\n+            Linkage::Static => {\n+                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+            }\n+            Linkage::Dynamic => {\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n+            }\n+        }\n+\n+        if group_end == Some(cnum) {\n+            cmd.group_end();\n+        }\n+    }\n+\n+    // compiler-builtins are always placed last to ensure that they're\n+    // linked correctly.\n+    // We must always link the `compiler_builtins` crate statically. Even if it\n+    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n+    // is used)\n+    if let Some(cnum) = compiler_builtins {\n+        add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n+    }\n+\n+    // Converts a library file-stem into a cc -l argument\n+    fn unlib<'a>(config: &config::Config, stem: &'a str) -> &'a str {\n+        if stem.starts_with(\"lib\") && !config.target.options.is_like_windows {\n+            &stem[3..]\n+        } else {\n+            stem\n+        }\n+    }\n+\n+    // We must link the sanitizer runtime using -Wl,--whole-archive but since\n+    // it's packed in a .rlib, it contains stuff that are not objects that will\n+    // make the linker error. So we must remove those bits from the .rlib before\n+    // linking it.\n+    fn link_sanitizer_runtime<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                              sess: &'a Session,\n+                              codegen_results: &CodegenResults,\n+                              tmpdir: &Path,\n+                              cnum: CrateNum) {\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n+\n+        if sess.target.target.options.is_like_osx {\n+            // On Apple platforms, the sanitizer is always built as a dylib, and\n+            // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n+            // rpath to the library as well (the rpath should be absolute, see\n+            // PR #41352 for details).\n+            //\n+            // FIXME: Remove this logic into librustc_*san once Cargo supports it\n+            let rpath = cratepath.parent().unwrap();\n+            let rpath = rpath.to_str().expect(\"non-utf8 component in path\");\n+            cmd.args(&[\"-Wl,-rpath\".into(), \"-Xlinker\".into(), rpath.into()]);\n+        }\n+\n+        let dst = tmpdir.join(cratepath.file_name().unwrap());\n+        let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n+        archive.update_symbols();\n+\n+        for f in archive.src_files() {\n+            if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n+                archive.remove_file(&f);\n+            }\n+        }\n+\n+        archive.build();\n+\n+        cmd.link_whole_rlib(&dst);\n+    }\n+\n+    // Adds the static \"rlib\" versions of all crates to the command line.\n+    // There's a bit of magic which happens here specifically related to LTO and\n+    // dynamic libraries. Specifically:\n+    //\n+    // * For LTO, we remove upstream object files.\n+    // * For dylibs we remove metadata and bytecode from upstream rlibs\n+    //\n+    // When performing LTO, almost(*) all of the bytecode from the upstream\n+    // libraries has already been included in our object file output. As a\n+    // result we need to remove the object files in the upstream libraries so\n+    // the linker doesn't try to include them twice (or whine about duplicate\n+    // symbols). We must continue to include the rest of the rlib, however, as\n+    // it may contain static native libraries which must be linked in.\n+    //\n+    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n+    // their bytecode wasn't included. The object files in those libraries must\n+    // still be passed to the linker.\n+    //\n+    // When making a dynamic library, linkers by default don't include any\n+    // object files in an archive if they're not necessary to resolve the link.\n+    // We basically want to convert the archive (rlib) to a dylib, though, so we\n+    // *do* want everything included in the output, regardless of whether the\n+    // linker thinks it's needed or not. As a result we must use the\n+    // --whole-archive option (or the platform equivalent). When using this\n+    // option the linker will fail if there are non-objects in the archive (such\n+    // as our own metadata and/or bytecode). All in all, for rlibs to be\n+    // entirely included in dylibs, we need to remove all non-object files.\n+    //\n+    // Note, however, that if we're not doing LTO or we're not producing a dylib\n+    // (aka we're making an executable), we can just pass the rlib blindly to\n+    // the linker (fast) because it's fine if it's not actually included as\n+    // we're at the end of the dependency chain.\n+    fn add_static_crate<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n+                        sess: &'a Session,\n+                        codegen_results: &CodegenResults,\n+                        tmpdir: &Path,\n+                        crate_type: config::CrateType,\n+                        cnum: CrateNum) {\n+        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n+\n+        // See the comment above in `link_staticlib` and `link_rlib` for why if\n+        // there's a static library that's not relevant we skip all object\n+        // files.\n+        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+        let skip_native = native_libs.iter().any(|lib| {\n+            lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n+        });\n+\n+        if (!are_upstream_rust_objects_already_included(sess) ||\n+            ignored_for_lto(sess, &codegen_results.crate_info, cnum)) &&\n+           crate_type != config::CrateType::Dylib &&\n+           !skip_native {\n+            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n+            return\n+        }\n+\n+        let dst = tmpdir.join(cratepath.file_name().unwrap());\n+        let name = cratepath.file_name().unwrap().to_str().unwrap();\n+        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+\n+        time_ext(sess.time_extended(), Some(sess), &format!(\"altering {}.rlib\", name), || {\n+            let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n+            archive.update_symbols();\n+\n+            let mut any_objects = false;\n+            for f in archive.src_files() {\n+                if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n+                    archive.remove_file(&f);\n+                    continue\n+                }\n+\n+                let canonical = f.replace(\"-\", \"_\");\n+                let canonical_name = name.replace(\"-\", \"_\");\n+\n+                // Look for `.rcgu.o` at the end of the filename to conclude\n+                // that this is a Rust-related object file.\n+                fn looks_like_rust(s: &str) -> bool {\n+                    let path = Path::new(s);\n+                    let ext = path.extension().and_then(|s| s.to_str());\n+                    if ext != Some(OutputType::Object.extension()) {\n+                        return false\n+                    }\n+                    let ext2 = path.file_stem()\n+                        .and_then(|s| Path::new(s).extension())\n+                        .and_then(|s| s.to_str());\n+                    ext2 == Some(RUST_CGU_EXT)\n+                }\n+\n+                let is_rust_object =\n+                    canonical.starts_with(&canonical_name) &&\n+                    looks_like_rust(&f);\n+\n+                // If we've been requested to skip all native object files\n+                // (those not generated by the rust compiler) then we can skip\n+                // this file. See above for why we may want to do this.\n+                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+\n+                // If we're performing LTO and this is a rust-generated object\n+                // file, then we don't need the object file as it's part of the\n+                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                // though, so we let that object file slide.\n+                let skip_because_lto = are_upstream_rust_objects_already_included(sess) &&\n+                    is_rust_object &&\n+                    (sess.target.target.options.no_builtins ||\n+                     !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n+\n+                if skip_because_cfg_say_so || skip_because_lto {\n+                    archive.remove_file(&f);\n+                } else {\n+                    any_objects = true;\n+                }\n+            }\n+\n+            if !any_objects {\n+                return\n+            }\n+            archive.build();\n+\n+            // If we're creating a dylib, then we need to include the\n+            // whole of each object in our archive into that artifact. This is\n+            // because a `dylib` can be reused as an intermediate artifact.\n+            //\n+            // Note, though, that we don't want to include the whole of a\n+            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n+            // repeatedly linked anyway.\n+            if crate_type == config::CrateType::Dylib &&\n+                codegen_results.crate_info.compiler_builtins != Some(cnum) {\n+                cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n+            } else {\n+                cmd.link_rlib(&fix_windows_verbatim_for_gcc(&dst));\n+            }\n+        });\n+    }\n+\n+    // Same thing as above, but for dynamic crates instead of static crates.\n+    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n+        // Just need to tell the linker about where the library lives and\n+        // what its name is\n+        let parent = cratepath.parent();\n+        if let Some(dir) = parent {\n+            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n+        }\n+        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n+        cmd.link_rust_dylib(&unlib(&sess.target, filestem),\n+                            parent.unwrap_or(Path::new(\"\")));\n+    }\n+}\n+\n // Link in all of our upstream crates' native dependencies. Remember that\n // all of these upstream native dependencies are all non-static\n // dependencies. We've got two cases then:\n@@ -577,3 +1659,12 @@ pub fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n         config::Lto::ThinLocal => false,\n     }\n }\n+\n+fn is_pic(sess: &Session) -> bool {\n+    let reloc_model_arg = match sess.opts.cg.relocation_model {\n+        Some(ref s) => &s[..],\n+        None => &sess.target.target.options.relocation_model[..],\n+    };\n+\n+    reloc_model_arg == \"pic\"\n+}"}, {"sha": "a16d099ee3e4d0f16120b6ae1eea3dbcd354b36a", "filename": "src/librustc_codegen_ssa/back/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fmod.rs?ref=93a3b414e33b2bc47805f47b75b6dc8aa548df33", "patch": "@@ -5,3 +5,5 @@ pub mod link;\n pub mod command;\n pub mod symbol_export;\n pub mod archive;\n+pub mod rpath;\n+pub mod wasm;"}, {"sha": "2b7abcb52bef8cf5391c551c3c7127592e8c5360", "filename": "src/librustc_codegen_ssa/back/rpath.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs?ref=93a3b414e33b2bc47805f47b75b6dc8aa548df33", "previous_filename": "src/librustc_codegen_llvm/back/rpath.rs"}, {"sha": "f90bb89fbe87d66c6f8516af5a32508b3b5ba43b", "filename": "src/librustc_codegen_ssa/back/wasm.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93a3b414e33b2bc47805f47b75b6dc8aa548df33/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwasm.rs?ref=93a3b414e33b2bc47805f47b75b6dc8aa548df33", "previous_filename": "src/librustc_codegen_llvm/back/wasm.rs"}]}