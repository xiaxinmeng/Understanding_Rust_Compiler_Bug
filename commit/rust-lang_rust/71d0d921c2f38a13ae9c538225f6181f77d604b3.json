{"sha": "71d0d921c2f38a13ae9c538225f6181f77d604b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZDBkOTIxYzJmMzhhMTNhZTljNTM4MjI1ZjYxODFmNzdkNjA0YjM=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2017-02-08T09:24:49Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-03-10T01:54:26Z"}, "message": "Initial implementation of inlining for MIR\n\nFairly basic implementation of inlining for MIR. Uses conservative\nheuristics for inlining.", "tree": {"sha": "fb96399cb31a9fe9cfb70303e1596342dcb23545", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb96399cb31a9fe9cfb70303e1596342dcb23545"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71d0d921c2f38a13ae9c538225f6181f77d604b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71d0d921c2f38a13ae9c538225f6181f77d604b3", "html_url": "https://github.com/rust-lang/rust/commit/71d0d921c2f38a13ae9c538225f6181f77d604b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71d0d921c2f38a13ae9c538225f6181f77d604b3/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "540b52e145afb09f1784c6094220a7f8268f09ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/540b52e145afb09f1784c6094220a7f8268f09ed", "html_url": "https://github.com/rust-lang/rust/commit/540b52e145afb09f1784c6094220a7f8268f09ed"}], "stats": {"total": 1479, "additions": 1473, "deletions": 6}, "files": [{"sha": "fea576f7067807bf2933906496e5e5610b6df142", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 346, "deletions": 2, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=71d0d921c2f38a13ae9c538225f6181f77d604b3", "patch": "@@ -19,6 +19,7 @@ use hir::def::CtorKind;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n+use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use util::ppaux;\n use rustc_back::slice;\n use hir::InlineAsm;\n@@ -63,8 +64,7 @@ macro_rules! newtype_index {\n }\n \n /// Lowered representation of a single function.\n-// Do not implement clone for Mir, which can be accidently done and kind of expensive.\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -1333,3 +1333,347 @@ impl Location {\n         }\n     }\n }\n+\n+\n+/*\n+ * TypeFoldable implementations for MIR types\n+ */\n+\n+impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        Mir {\n+            basic_blocks: self.basic_blocks.fold_with(folder),\n+            visibility_scopes: self.visibility_scopes.clone(),\n+            promoted: self.promoted.fold_with(folder),\n+            return_ty: self.return_ty.fold_with(folder),\n+            local_decls: self.local_decls.fold_with(folder),\n+            arg_count: self.arg_count,\n+            upvar_decls: self.upvar_decls.clone(),\n+            spread_arg: self.spread_arg,\n+            span: self.span,\n+            cache: cache::Cache::new()\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.basic_blocks.visit_with(visitor) ||\n+        self.promoted.visit_with(visitor)     ||\n+        self.return_ty.visit_with(visitor)    ||\n+        self.local_decls.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for LocalDecl<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        LocalDecl {\n+            ty: self.ty.fold_with(folder),\n+            ..self.clone()\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.ty.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        BasicBlockData {\n+            statements: self.statements.fold_with(folder),\n+            terminator: self.terminator.fold_with(folder),\n+            is_cleanup: self.is_cleanup\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.statements.visit_with(visitor) || self.terminator.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use mir::StatementKind::*;\n+\n+        let kind = match self.kind {\n+            Assign(ref lval, ref rval) => Assign(lval.fold_with(folder), rval.fold_with(folder)),\n+            SetDiscriminant { ref lvalue, variant_index } => SetDiscriminant {\n+                lvalue: lvalue.fold_with(folder),\n+                variant_index: variant_index\n+            },\n+            StorageLive(ref lval) => StorageLive(lval.fold_with(folder)),\n+            StorageDead(ref lval) => StorageDead(lval.fold_with(folder)),\n+            InlineAsm { ref asm, ref outputs, ref inputs } => InlineAsm {\n+                asm: asm.clone(),\n+                outputs: outputs.fold_with(folder),\n+                inputs: inputs.fold_with(folder)\n+            },\n+            Nop => Nop,\n+        };\n+        Statement {\n+            source_info: self.source_info,\n+            kind: kind\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use mir::StatementKind::*;\n+\n+        match self.kind {\n+            Assign(ref lval, ref rval) => { lval.visit_with(visitor) || rval.visit_with(visitor) }\n+            SetDiscriminant { ref lvalue, .. } |\n+            StorageLive(ref lvalue) |\n+            StorageDead(ref lvalue) => lvalue.visit_with(visitor),\n+            InlineAsm { ref outputs, ref inputs, .. } =>\n+                outputs.visit_with(visitor) || inputs.visit_with(visitor),\n+            Nop => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use mir::TerminatorKind::*;\n+\n+        let kind = match self.kind {\n+            Goto { target } => Goto { target: target },\n+            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n+                discr: discr.fold_with(folder),\n+                switch_ty: switch_ty.fold_with(folder),\n+                values: values.clone(),\n+                targets: targets.clone()\n+            },\n+            Drop { ref location, target, unwind } => Drop {\n+                location: location.fold_with(folder),\n+                target: target,\n+                unwind: unwind\n+            },\n+            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n+                location: location.fold_with(folder),\n+                value: value.fold_with(folder),\n+                target: target,\n+                unwind: unwind\n+            },\n+            Call { ref func, ref args, ref destination, cleanup } => {\n+                let dest = destination.as_ref().map(|&(ref loc, dest)| {\n+                    (loc.fold_with(folder), dest)\n+                });\n+\n+                Call {\n+                    func: func.fold_with(folder),\n+                    args: args.fold_with(folder),\n+                    destination: dest,\n+                    cleanup: cleanup\n+                }\n+            },\n+            Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                let msg = if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n+                    AssertMessage::BoundsCheck {\n+                        len: len.fold_with(folder),\n+                        index: index.fold_with(folder),\n+                    }\n+                } else {\n+                    msg.clone()\n+                };\n+                Assert {\n+                    cond: cond.fold_with(folder),\n+                    expected: expected,\n+                    msg: msg,\n+                    target: target,\n+                    cleanup: cleanup\n+                }\n+            },\n+            Resume => Resume,\n+            Return => Return,\n+            Unreachable => Unreachable,\n+        };\n+        Terminator {\n+            source_info: self.source_info,\n+            kind: kind\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use mir::TerminatorKind::*;\n+\n+        match self.kind {\n+            SwitchInt { ref discr, switch_ty, .. } =>\n+                discr.visit_with(visitor) || switch_ty.visit_with(visitor),\n+            Drop { ref location, ..} => location.visit_with(visitor),\n+            DropAndReplace { ref location, ref value, ..} =>\n+                location.visit_with(visitor) || value.visit_with(visitor),\n+            Call { ref func, ref args, ref destination, .. } => {\n+                let dest = if let Some((ref loc, _)) = *destination {\n+                    loc.visit_with(visitor)\n+                } else { false };\n+                dest || func.visit_with(visitor) || args.visit_with(visitor)\n+            },\n+            Assert { ref cond, ref msg, .. } => {\n+                if cond.visit_with(visitor) {\n+                    if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n+                        len.visit_with(visitor) || index.visit_with(visitor)\n+                    } else {\n+                        false\n+                    }\n+                } else {\n+                    false\n+                }\n+            },\n+            Goto { .. } |\n+            Resume |\n+            Return |\n+            Unreachable => false\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Lvalue<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match self {\n+            &Lvalue::Projection(ref p) => Lvalue::Projection(p.fold_with(folder)),\n+            _ => self.clone()\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        if let &Lvalue::Projection(ref p) = self {\n+            p.visit_with(visitor)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use mir::Rvalue::*;\n+        match *self {\n+            Use(ref op) => Use(op.fold_with(folder)),\n+            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n+            Ref(region, bk, ref lval) => Ref(region.fold_with(folder), bk, lval.fold_with(folder)),\n+            Len(ref lval) => Len(lval.fold_with(folder)),\n+            Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n+            BinaryOp(op, ref rhs, ref lhs) =>\n+                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder)),\n+            CheckedBinaryOp(op, ref rhs, ref lhs) =>\n+                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder)),\n+            UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n+            Discriminant(ref lval) => Discriminant(lval.fold_with(folder)),\n+            Box(ty) => Box(ty.fold_with(folder)),\n+            Aggregate(ref kind, ref fields) => {\n+                let kind = match *kind {\n+                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n+                    AggregateKind::Tuple => AggregateKind::Tuple,\n+                    AggregateKind::Adt(def, v, substs, n) =>\n+                        AggregateKind::Adt(def, v, substs.fold_with(folder), n),\n+                    AggregateKind::Closure(id, substs) =>\n+                        AggregateKind::Closure(id, substs.fold_with(folder))\n+                };\n+                Aggregate(kind, fields.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use mir::Rvalue::*;\n+        match *self {\n+            Use(ref op) => op.visit_with(visitor),\n+            Repeat(ref op, _) => op.visit_with(visitor),\n+            Ref(region, _, ref lval) => region.visit_with(visitor) || lval.visit_with(visitor),\n+            Len(ref lval) => lval.visit_with(visitor),\n+            Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n+            BinaryOp(_, ref rhs, ref lhs) |\n+            CheckedBinaryOp(_, ref rhs, ref lhs) =>\n+                rhs.visit_with(visitor) || lhs.visit_with(visitor),\n+            UnaryOp(_, ref val) => val.visit_with(visitor),\n+            Discriminant(ref lval) => lval.visit_with(visitor),\n+            Box(ty) => ty.visit_with(visitor),\n+            Aggregate(ref kind, ref fields) => {\n+                (match *kind {\n+                    AggregateKind::Array(ty) => ty.visit_with(visitor),\n+                    AggregateKind::Tuple => false,\n+                    AggregateKind::Adt(_, _, substs, _) => substs.visit_with(visitor),\n+                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor)\n+                }) || fields.visit_with(visitor)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            Operand::Consume(ref lval) => Operand::Consume(lval.fold_with(folder)),\n+            Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            Operand::Consume(ref lval) => lval.visit_with(visitor),\n+            Operand::Constant(ref c) => c.visit_with(visitor)\n+        }\n+    }\n+}\n+\n+impl<'tcx, B, V> TypeFoldable<'tcx> for Projection<'tcx, B, V>\n+    where B: TypeFoldable<'tcx>, V: TypeFoldable<'tcx>\n+{\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use mir::ProjectionElem::*;\n+\n+        let base = self.base.fold_with(folder);\n+        let elem = match self.elem {\n+            Deref => Deref,\n+            Field(f, ty) => Field(f, ty.fold_with(folder)),\n+            Index(ref v) => Index(v.fold_with(folder)),\n+            ref elem => elem.clone()\n+        };\n+\n+        Projection {\n+            base: base,\n+            elem: elem\n+        }\n+    }\n+\n+    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n+        use mir::ProjectionElem::*;\n+\n+        self.base.visit_with(visitor) ||\n+            match self.elem {\n+                Field(_, ty) => ty.visit_with(visitor),\n+                Index(ref v) => v.visit_with(visitor),\n+                _ => false\n+            }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        Constant {\n+            span: self.span.clone(),\n+            ty: self.ty.fold_with(folder),\n+            literal: self.literal.fold_with(folder)\n+        }\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.ty.visit_with(visitor) || self.literal.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Literal<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            Literal::Item { def_id, substs } => Literal::Item {\n+                def_id: def_id,\n+                substs: substs.fold_with(folder)\n+            },\n+            _ => self.clone()\n+        }\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            Literal::Item { substs, .. } => substs.visit_with(visitor),\n+            _ => false\n+        }\n+    }\n+}"}, {"sha": "3c37c7353d683b739e76b4a4358dd911984481ec", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=71d0d921c2f38a13ae9c538225f6181f77d604b3", "patch": "@@ -2302,6 +2302,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         queries::mir::get(self, DUMMY_SP, did).borrow()\n     }\n \n+    /// Given the DefId of an item, returns its MIR, borrowed immutably.\n+    /// Returns None if there is no MIR for the DefId\n+    pub fn maybe_item_mir(self, did: DefId) -> Option<Ref<'gcx, Mir<'gcx>>> {\n+        if did.is_local() && !self.maps.mir.borrow().contains_key(&did) {\n+            return None;\n+        }\n+\n+        if !did.is_local() && !self.sess.cstore.is_item_mir_available(did) {\n+            return None;\n+        }\n+\n+        Some(self.item_mir(did))\n+    }\n+\n     /// If `type_needs_drop` returns true, then `ty` is definitely\n     /// non-copy and *might* have a destructor attached; if it returns\n     /// false, then `ty` definitely has no destructor (i.e. no drop glue)."}, {"sha": "7790a84da494422d170869ca281f156b855a85c6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=71d0d921c2f38a13ae9c538225f6181f77d604b3", "patch": "@@ -1048,6 +1048,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n \n         // No lifetime analysis based on borrowing can be done from here on out.\n+        passes.push_pass(box mir::transform::inline::Inline);\n         passes.push_pass(box mir::transform::instcombine::InstCombine::new());\n         passes.push_pass(box mir::transform::deaggregator::Deaggregator);\n         passes.push_pass(box mir::transform::copy_prop::CopyPropagation);"}, {"sha": "69416289d8e2682b1d68e8f18a902b866b22f36e", "filename": "src/librustc_mir/callgraph.rs", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Fcallgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Fcallgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fcallgraph.rs?ref=71d0d921c2f38a13ae9c538225f6181f77d604b3", "patch": "@@ -0,0 +1,252 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! MIR-based callgraph.\n+//!\n+//! This only considers direct calls\n+\n+use rustc::hir::def_id::DefId;\n+use rustc_data_structures::graph;\n+\n+use rustc::mir::*;\n+use rustc::mir::visit::*;\n+\n+use rustc::ty;\n+\n+use rustc::util::nodemap::DefIdMap;\n+\n+pub struct CallGraph {\n+    node_map: DefIdMap<graph::NodeIndex>,\n+    graph: graph::Graph<DefId, ()>\n+}\n+\n+impl CallGraph {\n+    // FIXME: allow for construction of a callgraph that inspects\n+    // cross-crate MIRs if available.\n+    pub fn build<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> CallGraph {\n+        let def_ids = tcx.maps.mir.borrow().keys();\n+\n+        let mut callgraph = CallGraph {\n+            node_map: DefIdMap(),\n+            graph: graph::Graph::new()\n+        };\n+\n+        for def_id in def_ids {\n+            if !def_id.is_local() { continue; }\n+\n+            let idx = callgraph.add_node(def_id);\n+\n+            let mut call_visitor = CallVisitor {\n+                caller: idx,\n+                graph: &mut callgraph\n+            };\n+\n+            let mir = tcx.item_mir(def_id);\n+            call_visitor.visit_mir(&mir);\n+        }\n+\n+        callgraph\n+    }\n+\n+    // Iterate over the strongly-connected components of the graph\n+    pub fn scc_iter(&self) -> SCCIterator {\n+        SCCIterator::new(&self.graph)\n+    }\n+\n+    // Get the def_id for the given graph node\n+    pub fn def_id(&self, node: graph::NodeIndex) -> DefId {\n+        *self.graph.node_data(node)\n+    }\n+\n+    fn add_node(&mut self, id: DefId) -> graph::NodeIndex {\n+        let graph = &mut self.graph;\n+        *self.node_map.entry(id).or_insert_with(|| {\n+            graph.add_node(id)\n+        })\n+    }\n+}\n+\n+struct CallVisitor<'a> {\n+    caller: graph::NodeIndex,\n+    graph: &'a mut CallGraph\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for CallVisitor<'a> {\n+    fn visit_terminator_kind(&mut self, _block: BasicBlock,\n+                             kind: &TerminatorKind<'tcx>, _loc: Location) {\n+        if let TerminatorKind::Call {\n+            func: Operand::Constant(ref f)\n+            , .. } = *kind {\n+            if let ty::TyFnDef(def_id, _, _) = f.ty.sty {\n+                let callee = self.graph.add_node(def_id);\n+                self.graph.graph.add_edge(self.caller, callee, ());\n+            }\n+        }\n+    }\n+}\n+\n+struct StackElement<'g> {\n+    node: graph::NodeIndex,\n+    lowlink: usize,\n+    children: graph::AdjacentTargets<'g, DefId, ()>\n+}\n+\n+/**\n+ * Iterator over strongly-connected-components using Tarjan's algorithm[1]\n+ *\n+ * [1]: https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n+ */\n+pub struct SCCIterator<'g> {\n+    graph: &'g graph::Graph<DefId, ()>,\n+    index: usize,\n+    node_indices: Vec<Option<usize>>,\n+    scc_stack: Vec<graph::NodeIndex>,\n+    current_scc: Vec<graph::NodeIndex>,\n+    visit_stack: Vec<StackElement<'g>>,\n+}\n+\n+impl<'g> SCCIterator<'g> {\n+    pub fn new(graph: &'g graph::Graph<DefId, ()>) -> SCCIterator<'g> {\n+        if graph.len_nodes() == 0 {\n+            return SCCIterator {\n+                graph: graph,\n+                index: 0,\n+                node_indices: Vec::new(),\n+                scc_stack: Vec::new(),\n+                current_scc: Vec::new(),\n+                visit_stack: Vec::new()\n+            };\n+        }\n+\n+        let first = graph::NodeIndex(0);\n+\n+        SCCIterator::with_entry(graph, first)\n+    }\n+\n+    pub fn with_entry(graph: &'g graph::Graph<DefId, ()>,\n+                      entry: graph::NodeIndex) -> SCCIterator<'g> {\n+        let mut iter = SCCIterator {\n+            graph: graph,\n+            index: 0,\n+            node_indices: Vec::with_capacity(graph.len_nodes()),\n+            scc_stack: Vec::new(),\n+            current_scc: Vec::new(),\n+            visit_stack: Vec::new()\n+        };\n+\n+        iter.visit_one(entry);\n+\n+        iter\n+    }\n+\n+    fn get_next(&mut self) {\n+        self.current_scc.clear();\n+\n+        while !self.visit_stack.is_empty() {\n+            self.visit_children();\n+\n+            let node = self.visit_stack.pop().unwrap();\n+\n+            if let Some(last) = self.visit_stack.last_mut() {\n+                if last.lowlink > node.lowlink {\n+                    last.lowlink = node.lowlink;\n+                }\n+            }\n+\n+            debug!(\"TarjanSCC: Popped node {:?} : lowlink = {:?}; index = {:?}\",\n+                   node.node, node.lowlink, self.node_index(node.node).unwrap());\n+\n+            if node.lowlink != self.node_index(node.node).unwrap() {\n+                continue;\n+            }\n+\n+            loop {\n+                let n = self.scc_stack.pop().unwrap();\n+                self.current_scc.push(n);\n+                self.set_node_index(n, !0);\n+                if n == node.node { return; }\n+            }\n+        }\n+    }\n+\n+    fn visit_one(&mut self, node: graph::NodeIndex) {\n+        self.index += 1;\n+        let idx =  self.index;\n+        self.set_node_index(node, idx);\n+        self.scc_stack.push(node);\n+        self.visit_stack.push(StackElement {\n+            node: node,\n+            lowlink: self.index,\n+            children: self.graph.successor_nodes(node)\n+        });\n+        debug!(\"TarjanSCC: Node {:?} : index = {:?}\", node, idx);\n+    }\n+\n+    fn visit_children(&mut self) {\n+        while let Some(child) = self.visit_stack.last_mut().unwrap().children.next() {\n+            if let Some(child_num) = self.node_index(child) {\n+                let cur = self.visit_stack.last_mut().unwrap();\n+                if cur.lowlink > child_num {\n+                    cur.lowlink = child_num;\n+                }\n+            } else {\n+                self.visit_one(child);\n+            }\n+        }\n+    }\n+\n+    fn node_index(&self, node: graph::NodeIndex) -> Option<usize> {\n+        self.node_indices.get(node.node_id()).and_then(|&idx| idx)\n+    }\n+\n+    fn set_node_index(&mut self, node: graph::NodeIndex, idx: usize) {\n+        let i = node.node_id();\n+        if i >= self.node_indices.len() {\n+            self.node_indices.resize(i + 1, None);\n+        }\n+        self.node_indices[i] = Some(idx);\n+    }\n+}\n+\n+impl<'g> Iterator for SCCIterator<'g> {\n+    type Item = Vec<graph::NodeIndex>;\n+\n+    fn next(&mut self) -> Option<Vec<graph::NodeIndex>> {\n+        self.get_next();\n+\n+        if self.current_scc.is_empty() {\n+            // Try a new root for the next SCC, if the node_indices\n+            // map is doesn't contain all nodes, use the smallest one\n+            // with no entry, otherwise find the first empty node.\n+            //\n+            // FIXME: This should probably use a set of precomputed\n+            // roots instead\n+            if self.node_indices.len() < self.graph.len_nodes() {\n+                let idx = graph::NodeIndex(self.node_indices.len());\n+                self.visit_one(idx);\n+            } else {\n+                for idx in 0..self.node_indices.len() {\n+                    if self.node_indices[idx].is_none() {\n+                        let idx = graph::NodeIndex(idx);\n+                        self.visit_one(idx);\n+                        break;\n+                    }\n+                }\n+            }\n+            self.get_next();\n+        }\n+\n+        if self.current_scc.is_empty() {\n+            None\n+        } else {\n+            Some(self.current_scc.clone())\n+        }\n+    }\n+}"}, {"sha": "f21f1881c832e17212dea3ee392641ce0d68589a", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=71d0d921c2f38a13ae9c538225f6181f77d604b3", "patch": "@@ -46,6 +46,7 @@ extern crate rustc_const_eval;\n pub mod diagnostics;\n \n pub mod build;\n+pub mod callgraph;\n pub mod def_use;\n pub mod graphviz;\n mod hair;\n@@ -58,4 +59,4 @@ use rustc::ty::maps::Providers;\n pub fn provide(providers: &mut Providers) {\n     mir_map::provide(providers);\n     transform::qualify_consts::provide(providers);\n-}\n+}\n\\ No newline at end of file"}, {"sha": "4b8e2bf49b9ee5f790b99496a1037c34210469e7", "filename": "src/librustc_mir/transform/inline.rs", "status": "added", "additions": 842, "deletions": 0, "changes": 842, "blob_url": "https://github.com/rust-lang/rust/blob/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=71d0d921c2f38a13ae9c538225f6181f77d604b3", "patch": "@@ -0,0 +1,842 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Inlining pass for MIR functions\n+\n+use rustc::hir::def_id::DefId;\n+\n+use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::graph;\n+\n+use rustc::dep_graph::DepNode;\n+use rustc::mir::*;\n+use rustc::mir::transform::{MirMapPass, MirPassHook, MirSource, Pass};\n+use rustc::mir::visit::*;\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::{Subst,Substs};\n+use rustc::util::nodemap::{DefIdSet};\n+\n+use super::simplify::{remove_dead_blocks, CfgSimplifier};\n+\n+use syntax::attr;\n+use syntax::abi::Abi;\n+\n+use callgraph;\n+\n+const DEFAULT_THRESHOLD: usize = 50;\n+const HINT_THRESHOLD: usize = 100;\n+\n+const INSTR_COST: usize = 5;\n+const CALL_PENALTY: usize = 25;\n+\n+const UNKNOWN_SIZE_COST: usize = 10;\n+\n+pub struct Inline;\n+\n+impl<'tcx> MirMapPass<'tcx> for Inline {\n+    fn run_pass<'a>(\n+        &mut self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        hooks: &mut [Box<for<'s> MirPassHook<'s>>]) {\n+\n+        //if tcx.sess.opts.debugging_opts.mir_opt_level < 2 { return; }\n+\n+        let _ignore = tcx.dep_graph.in_ignore();\n+\n+        let callgraph = callgraph::CallGraph::build(tcx);\n+\n+        let mut inliner = Inliner {\n+            tcx: tcx,\n+        };\n+\n+        let def_ids = tcx.maps.mir.borrow().keys();\n+        for &def_id in &def_ids {\n+            if !def_id.is_local() { continue; }\n+\n+            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n+            let mut mir = if let Some(mir) = tcx.maps.mir.borrow().get(&def_id) {\n+                mir.borrow_mut()\n+            } else {\n+                continue;\n+            };\n+\n+            tcx.dep_graph.write(DepNode::Mir(def_id));\n+\n+            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+            let src = MirSource::from_node(tcx, id);\n+\n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, &mut mir, self, false);\n+            }\n+        }\n+\n+        for scc in callgraph.scc_iter() {\n+            inliner.inline_scc(&callgraph, &scc);\n+        }\n+\n+        for def_id in def_ids {\n+            if !def_id.is_local() { continue; }\n+\n+            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n+            let mut mir = tcx.maps.mir.borrow()[&def_id].borrow_mut();\n+            tcx.dep_graph.write(DepNode::Mir(def_id));\n+\n+            let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+            let src = MirSource::from_node(tcx, id);\n+\n+            for hook in &mut *hooks {\n+                hook.on_mir_pass(tcx, src, &mut mir, self, true);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> Pass for Inline { }\n+\n+struct Inliner<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+#[derive(Copy, Clone)]\n+struct CallSite<'tcx> {\n+    caller: DefId,\n+    callee: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+    bb: BasicBlock,\n+    location: SourceInfo,\n+}\n+\n+impl<'a, 'tcx> Inliner<'a, 'tcx> {\n+    fn inline_scc(&mut self, callgraph: &callgraph::CallGraph, scc: &[graph::NodeIndex]) -> bool {\n+        let mut callsites = Vec::new();\n+        let mut in_scc = DefIdSet();\n+\n+        let mut inlined_into = DefIdSet();\n+\n+        for &node in scc {\n+            let def_id = callgraph.def_id(node);\n+\n+            // Don't inspect functions from other crates\n+            let id = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+                id\n+            } else {\n+                continue;\n+            };\n+            let src = MirSource::from_node(self.tcx, id);\n+            if let MirSource::Fn(_) = src {\n+                if let Some(mir) = self.tcx.maybe_item_mir(def_id) {\n+                    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n+                        // Don't inline calls that are in cleanup blocks.\n+                        if bb_data.is_cleanup { continue; }\n+\n+                        // Only consider direct calls to functions\n+                        let terminator = bb_data.terminator();\n+                        if let TerminatorKind::Call {\n+                            func: Operand::Constant(ref f), .. } = terminator.kind {\n+                            if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                                callsites.push(CallSite {\n+                                    caller: def_id,\n+                                    callee: callee_def_id,\n+                                    substs: substs,\n+                                    bb: bb,\n+                                    location: terminator.source_info\n+                                });\n+                            }\n+                        }\n+                    }\n+\n+                    in_scc.insert(def_id);\n+                }\n+            }\n+        }\n+\n+        // Move callsites that are in the the SCC to the end so\n+        // they're inlined after calls to outside the SCC\n+        let mut first_call_in_scc = callsites.len();\n+\n+        let mut i = 0;\n+        while i < first_call_in_scc {\n+            let f = callsites[i].caller;\n+            if in_scc.contains(&f) {\n+                first_call_in_scc -= 1;\n+                callsites.swap(i, first_call_in_scc);\n+            } else {\n+                i += 1;\n+            }\n+        }\n+\n+        let mut local_change;\n+        let mut changed = false;\n+\n+        loop {\n+            local_change = false;\n+            let mut csi = 0;\n+            while csi < callsites.len() {\n+                let callsite = callsites[csi];\n+                csi += 1;\n+\n+                let callee_mir = {\n+                    if let Some(callee_mir) = self.tcx.maybe_item_mir(callsite.callee) {\n+                        if !self.should_inline(callsite, &callee_mir) {\n+                            continue;\n+                        }\n+\n+                        callee_mir.subst(self.tcx, callsite.substs)\n+                    } else {\n+                        continue;\n+                    }\n+\n+                };\n+\n+                let mut caller_mir = {\n+                    let map = self.tcx.maps.mir.borrow();\n+                    let mir = map.get(&callsite.caller).unwrap();\n+                    mir.borrow_mut()\n+                };\n+\n+                let start = caller_mir.basic_blocks().len();\n+\n+                if !self.inline_call(callsite, &mut caller_mir, callee_mir) {\n+                    continue;\n+                }\n+\n+                inlined_into.insert(callsite.caller);\n+\n+                // Add callsites from inlined function\n+                for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated().skip(start) {\n+                    // Only consider direct calls to functions\n+                    let terminator = bb_data.terminator();\n+                    if let TerminatorKind::Call {\n+                        func: Operand::Constant(ref f), .. } = terminator.kind {\n+                        if let ty::TyFnDef(callee_def_id, substs, _) = f.ty.sty {\n+                            // Don't inline the same function multiple times.\n+                            if callsite.callee != callee_def_id {\n+                                callsites.push(CallSite {\n+                                    caller: callsite.caller,\n+                                    callee: callee_def_id,\n+                                    substs: substs,\n+                                    bb: bb,\n+                                    location: terminator.source_info\n+                                });\n+                            }\n+                        }\n+                    }\n+                }\n+\n+\n+                csi -= 1;\n+                if scc.len() == 1 {\n+                    callsites.swap_remove(csi);\n+                } else {\n+                    callsites.remove(csi);\n+                }\n+\n+                local_change = true;\n+                changed = true;\n+            }\n+\n+            if !local_change {\n+                break;\n+            }\n+        }\n+\n+        // Simplify functions we inlined into.\n+        for def_id in inlined_into {\n+            let mut caller_mir = {\n+                let map = self.tcx.maps.mir.borrow();\n+                let mir = map.get(&def_id).unwrap();\n+                mir.borrow_mut()\n+            };\n+\n+            debug!(\"Running simplify cfg on {:?}\", def_id);\n+            CfgSimplifier::new(&mut caller_mir).simplify();\n+            remove_dead_blocks(&mut caller_mir);\n+        }\n+        changed\n+    }\n+\n+    fn should_inline(&self, callsite: CallSite<'tcx>,\n+                     callee_mir: &'a Mir<'tcx>) -> bool {\n+\n+        let tcx = self.tcx;\n+\n+        // Don't inline closures that have captures\n+        // FIXME: Handle closures better\n+        if callee_mir.upvar_decls.len() > 0 {\n+            return false;\n+        }\n+\n+        // Don't inline calls to trait methods\n+        // FIXME: Should try to resolve it to a concrete method, and\n+        // only bail if that isn't possible\n+        let trait_def = tcx.trait_of_item(callsite.callee);\n+        if trait_def.is_some() { return false; }\n+\n+        let attrs = tcx.get_attrs(callsite.callee);\n+        let hint = attr::find_inline_attr(None, &attrs[..]);\n+\n+        let hinted = match hint {\n+            // Just treat inline(always) as a hint for now,\n+            // there are cases that prevent inlining that we\n+            // need to check for first.\n+            attr::InlineAttr::Always => true,\n+            attr::InlineAttr::Never => return false,\n+            attr::InlineAttr::Hint => true,\n+            attr::InlineAttr::None => false,\n+        };\n+\n+        // Only inline local functions if they would be eligible for\n+        // cross-crate inlining. This ensures that any symbols they\n+        // use are reachable cross-crate\n+        // FIXME(#36594): This shouldn't be necessary, and is more conservative\n+        // than it could be, but trans should generate the reachable set from\n+        // the MIR anyway, making any check obsolete.\n+        if callsite.callee.is_local() {\n+            // No type substs and no inline hint means this function\n+            // wouldn't be eligible for cross-crate inlining\n+            if callsite.substs.types().count() == 0 && !hinted {\n+                return false;\n+            }\n+\n+        }\n+\n+        let mut threshold = if hinted {\n+            HINT_THRESHOLD\n+        } else {\n+            DEFAULT_THRESHOLD\n+        };\n+\n+        // Significantly lower the threshold for inlining cold functions\n+        if attr::contains_name(&attrs[..], \"cold\") {\n+            threshold /= 5;\n+        }\n+\n+        // Give a bonus functions with a small number of blocks,\n+        // We normally have two or three blocks for even\n+        // very small functions.\n+        if callee_mir.basic_blocks().len() <= 3 {\n+            threshold += threshold / 4;\n+        }\n+\n+        // FIXME: Give a bonus to functions with only a single caller\n+\n+        let id = tcx.hir.as_local_node_id(callsite.caller).expect(\"Caller not local\");\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+\n+        let mut first_block = true;\n+        let mut cost = 0;\n+\n+        // Traverse the MIR manually so we can account for the effects of\n+        // inlining on the CFG.\n+        let mut work_list = vec![START_BLOCK];\n+        let mut visited = BitVector::new(callee_mir.basic_blocks().len());\n+        while let Some(bb) = work_list.pop() {\n+            if !visited.insert(bb.index()) { continue; }\n+            let blk = &callee_mir.basic_blocks()[bb];\n+\n+            for stmt in &blk.statements {\n+                // Don't count StorageLive/StorageDead in the inlining cost.\n+                match stmt.kind {\n+                    StatementKind::StorageLive(_) |\n+                    StatementKind::StorageDead(_) |\n+                    StatementKind::Nop => {}\n+                    _ => cost += INSTR_COST\n+                }\n+            }\n+            let term = blk.terminator();\n+            let mut is_drop = false;\n+            match term.kind {\n+                TerminatorKind::Drop { ref location, target, unwind } |\n+                TerminatorKind::DropAndReplace { ref location, target, unwind, .. } => {\n+                    is_drop = true;\n+                    work_list.push(target);\n+                    // If the location doesn't actually need dropping, treat it like\n+                    // a regular goto.\n+                    let ty = location.ty(&callee_mir, tcx).subst(tcx, callsite.substs);\n+                    let ty = ty.to_ty(tcx);\n+                    if tcx.type_needs_drop_given_env(ty, &param_env) {\n+                        cost += CALL_PENALTY;\n+                        if let Some(unwind) = unwind {\n+                            work_list.push(unwind);\n+                        }\n+                    } else {\n+                        cost += INSTR_COST;\n+                    }\n+                }\n+\n+                TerminatorKind::Unreachable |\n+                TerminatorKind::Call { destination: None, .. } if first_block => {\n+                    // If the function always diverges, don't inline\n+                    // unless the cost is zero\n+                    threshold = 0;\n+                }\n+\n+                TerminatorKind::Call {func: Operand::Constant(ref f), .. } => {\n+                    if let ty::TyFnDef(.., f) = f.ty.sty {\n+                        // Don't give intrinsics the extra penalty for calls\n+                        if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n+                            cost += INSTR_COST;\n+                        } else {\n+                            cost += CALL_PENALTY;\n+                        }\n+                    }\n+                }\n+                TerminatorKind::Assert { .. } => cost += CALL_PENALTY,\n+                _ => cost += INSTR_COST\n+            }\n+\n+            if !is_drop {\n+                for &succ in &term.successors()[..] {\n+                    work_list.push(succ);\n+                }\n+            }\n+\n+            first_block = false;\n+        }\n+\n+        // Count up the cost of local variables and temps, if we know the size\n+        // use that, otherwise we use a moderately-large dummy cost.\n+\n+        let ptr_size = tcx.data_layout.pointer_size.bytes();\n+\n+        for v in callee_mir.vars_and_temps_iter() {\n+            let v = &callee_mir.local_decls[v];\n+            let ty = v.ty.subst(tcx, callsite.substs);\n+            // Cost of the var is the size in machine-words, if we know\n+            // it.\n+            if let Some(size) = type_size_of(tcx, param_env.clone(), ty) {\n+                cost += (size / ptr_size) as usize;\n+            } else {\n+                cost += UNKNOWN_SIZE_COST;\n+            }\n+        }\n+\n+        debug!(\"Inline cost for {:?} is {}\", callsite.callee, cost);\n+\n+        if let attr::InlineAttr::Always = hint {\n+            true\n+        } else {\n+            cost <= threshold\n+        }\n+    }\n+\n+\n+    fn inline_call(&self, callsite: CallSite<'tcx>,\n+                             caller_mir: &mut Mir<'tcx>, mut callee_mir: Mir<'tcx>) -> bool {\n+\n+        // Don't inline a function into itself\n+        if callsite.caller == callsite.callee { return false; }\n+\n+        let _task = self.tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));\n+\n+\n+        let terminator = caller_mir[callsite.bb].terminator.take().unwrap();\n+        match terminator.kind {\n+            // FIXME: Handle inlining of diverging calls\n+            TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n+\n+                debug!(\"Inlined {:?} into {:?}\", callsite.callee, callsite.caller);\n+\n+                let is_box_free = Some(callsite.callee) == self.tcx.lang_items.box_free_fn();\n+\n+                let mut local_map = IndexVec::with_capacity(callee_mir.local_decls.len());\n+                let mut scope_map = IndexVec::with_capacity(callee_mir.visibility_scopes.len());\n+                let mut promoted_map = IndexVec::with_capacity(callee_mir.promoted.len());\n+\n+                for mut scope in callee_mir.visibility_scopes.iter().cloned() {\n+                    if scope.parent_scope.is_none() {\n+                        scope.parent_scope = Some(callsite.location.scope);\n+                        scope.span = callee_mir.span;\n+                    }\n+\n+                    scope.span = callsite.location.span;\n+\n+                    let idx = caller_mir.visibility_scopes.push(scope);\n+                    scope_map.push(idx);\n+                }\n+\n+                for loc in callee_mir.vars_and_temps_iter() {\n+                    let mut local = callee_mir.local_decls[loc].clone();\n+\n+                    if let Some(ref mut source_info) = local.source_info {\n+                        source_info.scope = scope_map[source_info.scope];\n+\n+                        source_info.span = callsite.location.span;\n+                    }\n+\n+                    let idx = caller_mir.local_decls.push(local);\n+                    local_map.push(idx);\n+                }\n+\n+                for p in callee_mir.promoted.iter().cloned() {\n+                    let idx = caller_mir.promoted.push(p);\n+                    promoted_map.push(idx);\n+                }\n+\n+                // If the call is something like `a[*i] = f(i)`, where\n+                // `i : &mut usize`, then just duplicating the `a[*i]`\n+                // Lvalue could result in two different locations if `f`\n+                // writes to `i`. To prevent this we need to create a temporary\n+                // borrow of the lvalue and pass the destination as `*temp` instead.\n+                fn dest_needs_borrow(lval: &Lvalue) -> bool {\n+                    match *lval {\n+                        Lvalue::Projection(ref p) => {\n+                            match p.elem {\n+                                ProjectionElem::Deref |\n+                                ProjectionElem::Index(_) => true,\n+                                _ => dest_needs_borrow(&p.base)\n+                            }\n+                        }\n+                        // Static variables need a borrow because the callee\n+                        // might modify the same static.\n+                        Lvalue::Static(_) => true,\n+                        _ => false\n+                    }\n+                }\n+\n+                let dest = if dest_needs_borrow(&destination.0) {\n+                    debug!(\"Creating temp for return destination\");\n+                    let dest = Rvalue::Ref(\n+                        self.tcx.mk_region(ty::ReErased),\n+                        BorrowKind::Mut,\n+                        destination.0);\n+\n+                    let ty = dest.ty(caller_mir, self.tcx);\n+\n+                    let temp = LocalDecl::new_temp(ty);\n+\n+                    let tmp = caller_mir.local_decls.push(temp);\n+                    let tmp = Lvalue::Local(tmp);\n+\n+                    let stmt = Statement {\n+                        source_info: callsite.location,\n+                        kind: StatementKind::Assign(tmp.clone(), dest)\n+                    };\n+                    caller_mir[callsite.bb]\n+                        .statements.push(stmt);\n+                    tmp.deref()\n+                } else {\n+                    destination.0\n+                };\n+\n+                let return_block = destination.1;\n+\n+                let args : Vec<_> = if is_box_free {\n+                    assert!(args.len() == 1);\n+                    // box_free takes a Box, but is defined with a *mut T, inlining\n+                    // needs to generate the cast.\n+                    // FIXME: we should probably just generate correct MIR in the first place...\n+\n+                    let arg = if let Operand::Consume(ref lval) = args[0] {\n+                        lval.clone()\n+                    } else {\n+                        bug!(\"Constant arg to \\\"box_free\\\"\");\n+                    };\n+\n+                    let ptr_ty = args[0].ty(caller_mir, self.tcx);\n+                    vec![self.cast_box_free_arg(arg, ptr_ty, &callsite, caller_mir)]\n+                } else {\n+                    // Copy the arguments if needed.\n+                    self.make_call_args(args, &callsite, caller_mir)\n+                };\n+\n+                let bb_len = caller_mir.basic_blocks().len();\n+                let mut integrator = Integrator {\n+                    block_idx: bb_len,\n+                    args: &args,\n+                    local_map: local_map,\n+                    scope_map: scope_map,\n+                    promoted_map: promoted_map,\n+                    _callsite: callsite,\n+                    destination: dest,\n+                    return_block: return_block,\n+                    cleanup_block: cleanup,\n+                    in_cleanup_block: false\n+                };\n+\n+\n+                for (bb, mut block) in callee_mir.basic_blocks_mut().drain_enumerated(..) {\n+                    integrator.visit_basic_block_data(bb, &mut block);\n+                    caller_mir.basic_blocks_mut().push(block);\n+                }\n+\n+                let terminator = Terminator {\n+                    source_info: callsite.location,\n+                    kind: TerminatorKind::Goto { target: BasicBlock::new(bb_len) }\n+                };\n+\n+                caller_mir[callsite.bb].terminator = Some(terminator);\n+\n+                true\n+            }\n+            kind => {\n+                caller_mir[callsite.bb].terminator = Some(Terminator {\n+                    source_info: terminator.source_info,\n+                    kind: kind\n+                });\n+                false\n+            }\n+        }\n+    }\n+\n+    fn cast_box_free_arg(&self, arg: Lvalue<'tcx>, ptr_ty: Ty<'tcx>,\n+                         callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Operand<'tcx> {\n+        let arg = Rvalue::Ref(\n+            self.tcx.mk_region(ty::ReErased),\n+            BorrowKind::Mut,\n+            arg.deref());\n+\n+        let ty = arg.ty(caller_mir, self.tcx);\n+        let ref_tmp = LocalDecl::new_temp(ty);\n+        let ref_tmp = caller_mir.local_decls.push(ref_tmp);\n+        let ref_tmp = Lvalue::Local(ref_tmp);\n+\n+        let ref_stmt = Statement {\n+            source_info: callsite.location,\n+            kind: StatementKind::Assign(ref_tmp.clone(), arg)\n+        };\n+\n+        caller_mir[callsite.bb]\n+            .statements.push(ref_stmt);\n+\n+        let pointee_ty = match ptr_ty.sty {\n+            ty::TyRawPtr(tm) | ty::TyRef(_, tm) => tm.ty,\n+            _ if ptr_ty.is_box() => ptr_ty.boxed_ty(),\n+            _ => bug!(\"Invalid type `{:?}` for call to box_free\", ptr_ty)\n+        };\n+        let ptr_ty = self.tcx.mk_mut_ptr(pointee_ty);\n+\n+        let raw_ptr = Rvalue::Cast(CastKind::Misc, Operand::Consume(ref_tmp), ptr_ty);\n+\n+        let cast_tmp = LocalDecl::new_temp(ptr_ty);\n+        let cast_tmp = caller_mir.local_decls.push(cast_tmp);\n+        let cast_tmp = Lvalue::Local(cast_tmp);\n+\n+        let cast_stmt = Statement {\n+            source_info: callsite.location,\n+            kind: StatementKind::Assign(cast_tmp.clone(), raw_ptr)\n+        };\n+\n+        caller_mir[callsite.bb]\n+            .statements.push(cast_stmt);\n+\n+        Operand::Consume(cast_tmp)\n+    }\n+\n+    fn make_call_args(&self, args: Vec<Operand<'tcx>>,\n+                      callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Vec<Operand<'tcx>> {\n+        let tcx = self.tcx;\n+        // FIXME: Analysis of the usage of the arguments to avoid\n+        // unnecessary temporaries.\n+        args.into_iter().map(|a| {\n+            if let Operand::Consume(Lvalue::Local(local)) = a {\n+                if caller_mir.local_kind(local) == LocalKind::Temp {\n+                    // Reuse the operand if it's a temporary already\n+                    return a;\n+                }\n+            }\n+\n+            debug!(\"Creating temp for argument\");\n+            // Otherwise, create a temporary for the arg\n+            let arg = Rvalue::Use(a);\n+\n+            let ty = arg.ty(caller_mir, tcx);\n+\n+            let arg_tmp = LocalDecl::new_temp(ty);\n+            let arg_tmp = caller_mir.local_decls.push(arg_tmp);\n+            let arg_tmp = Lvalue::Local(arg_tmp);\n+\n+            let stmt = Statement {\n+                source_info: callsite.location,\n+                kind: StatementKind::Assign(arg_tmp.clone(), arg)\n+            };\n+            caller_mir[callsite.bb].statements.push(stmt);\n+            Operand::Consume(arg_tmp)\n+        }).collect()\n+    }\n+}\n+\n+fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, param_env: ty::ParameterEnvironment<'tcx>,\n+                          ty: Ty<'tcx>) -> Option<u64> {\n+    tcx.infer_ctxt(param_env, traits::Reveal::All).enter(|infcx| {\n+        ty.layout(&infcx).ok().map(|layout| {\n+            layout.size(&tcx.data_layout).bytes()\n+        })\n+    })\n+}\n+\n+/**\n+ * Integrator.\n+ *\n+ * Integrates blocks from the callee function into the calling function.\n+ * Updates block indices, references to locals and other control flow\n+ * stuff.\n+ */\n+struct Integrator<'a, 'tcx: 'a> {\n+    block_idx: usize,\n+    args: &'a [Operand<'tcx>],\n+    local_map: IndexVec<Local, Local>,\n+    scope_map: IndexVec<VisibilityScope, VisibilityScope>,\n+    promoted_map: IndexVec<Promoted, Promoted>,\n+    _callsite: CallSite<'tcx>,\n+    destination: Lvalue<'tcx>,\n+    return_block: BasicBlock,\n+    cleanup_block: Option<BasicBlock>,\n+    in_cleanup_block: bool,\n+}\n+\n+impl<'a, 'tcx> Integrator<'a, 'tcx> {\n+    fn update_target(&self, tgt: BasicBlock) -> BasicBlock {\n+        let new = BasicBlock::new(tgt.index() + self.block_idx);\n+        debug!(\"Updating target `{:?}`, new: `{:?}`\", tgt, new);\n+        new\n+    }\n+\n+    fn update_local(&self, local: Local) -> Option<Local> {\n+        let idx = local.index();\n+        if idx < (self.args.len() + 1) {\n+            return None;\n+        }\n+        let idx = idx - (self.args.len() + 1);\n+        let local = Local::new(idx);\n+        self.local_map.get(local).cloned()\n+    }\n+\n+    fn arg_index(&self, arg: Local) -> Option<usize> {\n+        let idx = arg.index();\n+        if idx > 0 && idx <= self.args.len() {\n+            Some(idx - 1)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    _ctxt: LvalueContext<'tcx>,\n+                    _location: Location) {\n+        if let Lvalue::Local(ref mut local) = *lvalue {\n+            if let Some(l) = self.update_local(*local) {\n+                // Temp or Var; update the local reference\n+                *local = l;\n+                return;\n+            }\n+        }\n+        if let Lvalue::Local(local) = *lvalue {\n+            if local == RETURN_POINTER {\n+                // Return pointer; update the lvalue itself\n+                *lvalue = self.destination.clone();\n+            } else if local.index() < (self.args.len() + 1) {\n+                // Argument, once again update the the lvalue itself\n+                let idx = local.index() - 1;\n+                if let Operand::Consume(ref lval) = self.args[idx] {\n+                    *lvalue = lval.clone();\n+                } else {\n+                    bug!(\"Arg operand `{:?}` is not an Lvalue use.\", idx)\n+                }\n+            }\n+        } else {\n+            self.super_lvalue(lvalue, _ctxt, _location)\n+        }\n+    }\n+\n+    fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n+        if let Operand::Consume(Lvalue::Local(arg)) = *operand {\n+            if let Some(idx) = self.arg_index(arg) {\n+                let new_arg = self.args[idx].clone();\n+                *operand = new_arg;\n+                return;\n+            }\n+        }\n+        self.super_operand(operand, location);\n+    }\n+\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n+        self.in_cleanup_block = data.is_cleanup;\n+        self.super_basic_block_data(block, data);\n+        self.in_cleanup_block = false;\n+    }\n+\n+    fn visit_terminator_kind(&mut self, block: BasicBlock,\n+                             kind: &mut TerminatorKind<'tcx>, loc: Location) {\n+        self.super_terminator_kind(block, kind, loc);\n+\n+        match *kind {\n+            TerminatorKind::Goto { ref mut target} => {\n+                *target = self.update_target(*target);\n+            }\n+            TerminatorKind::SwitchInt { ref mut targets, .. } => {\n+                for tgt in targets {\n+                    *tgt = self.update_target(*tgt);\n+                }\n+            }\n+            TerminatorKind::Drop { ref mut target, ref mut unwind, .. } |\n+            TerminatorKind::DropAndReplace { ref mut target, ref mut unwind, .. } => {\n+                *target = self.update_target(*target);\n+                if let Some(tgt) = *unwind {\n+                    *unwind = Some(self.update_target(tgt));\n+                } else if !self.in_cleanup_block {\n+                    // Unless this drop is in a cleanup block, add an unwind edge to\n+                    // the orignal call's cleanup block\n+                    *unwind = self.cleanup_block;\n+                }\n+            }\n+            TerminatorKind::Call { ref mut destination, ref mut cleanup, .. } => {\n+                if let Some((_, ref mut tgt)) = *destination {\n+                    *tgt = self.update_target(*tgt);\n+                }\n+                if let Some(tgt) = *cleanup {\n+                    *cleanup = Some(self.update_target(tgt));\n+                } else if !self.in_cleanup_block {\n+                    // Unless this call is in a cleanup block, add an unwind edge to\n+                    // the orignal call's cleanup block\n+                    *cleanup = self.cleanup_block;\n+                }\n+            }\n+            TerminatorKind::Assert { ref mut target, ref mut cleanup, .. } => {\n+                *target = self.update_target(*target);\n+                if let Some(tgt) = *cleanup {\n+                    *cleanup = Some(self.update_target(tgt));\n+                } else if !self.in_cleanup_block {\n+                    // Unless this assert is in a cleanup block, add an unwind edge to\n+                    // the orignal call's cleanup block\n+                    *cleanup = self.cleanup_block;\n+                }\n+            }\n+            TerminatorKind::Return => {\n+                *kind = TerminatorKind::Goto { target: self.return_block };\n+            }\n+            TerminatorKind::Resume => {\n+                if let Some(tgt) = self.cleanup_block {\n+                    *kind = TerminatorKind::Goto { target: tgt }\n+                }\n+            }\n+            TerminatorKind::Unreachable => { }\n+        }\n+    }\n+\n+    fn visit_visibility_scope(&mut self, scope: &mut VisibilityScope) {\n+        *scope = self.scope_map[*scope];\n+    }\n+\n+    fn visit_literal(&mut self, literal: &mut Literal<'tcx>, loc: Location) {\n+        if let Literal::Promoted { ref mut index } = *literal {\n+            if let Some(p) = self.promoted_map.get(*index).cloned() {\n+                *index = p;\n+            }\n+        } else {\n+            self.super_literal(literal, loc);\n+        }\n+    }\n+}"}, {"sha": "cbd054a72499b9adbdf5c044b7aa48f08a77f3b5", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=71d0d921c2f38a13ae9c538225f6181f77d604b3", "patch": "@@ -20,3 +20,4 @@ pub mod dump_mir;\n pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n+pub mod inline;"}, {"sha": "a762507f35e7ecccdaf994db4667df34048b5266", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d0d921c2f38a13ae9c538225f6181f77d604b3/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=71d0d921c2f38a13ae9c538225f6181f77d604b3", "patch": "@@ -79,7 +79,7 @@ pub struct CfgSimplifier<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n-    fn new(mir: &'a mut Mir<'tcx>) -> Self {\n+    pub fn new(mir: &'a mut Mir<'tcx>) -> Self {\n         let mut pred_count = IndexVec::from_elem(0u32, mir.basic_blocks());\n \n         // we can't use mir.predecessors() here because that counts\n@@ -102,7 +102,7 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n         }\n     }\n \n-    fn simplify(mut self) {\n+    pub fn simplify(mut self) {\n         loop {\n             let mut changed = false;\n \n@@ -137,6 +137,8 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n \n             if !changed { break }\n         }\n+\n+        self.strip_nops()\n     }\n \n     // Collapse a goto chain starting from `start`\n@@ -231,9 +233,19 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n         terminator.kind = TerminatorKind::Goto { target: first_succ };\n         true\n     }\n+\n+    fn strip_nops(&mut self) {\n+        for blk in self.basic_blocks.iter_mut() {\n+            blk.statements.retain(|stmt| if let StatementKind::Nop = stmt.kind {\n+                false\n+            } else {\n+                true\n+            })\n+        }\n+    }\n }\n \n-fn remove_dead_blocks(mir: &mut Mir) {\n+pub fn remove_dead_blocks(mir: &mut Mir) {\n     let mut seen = BitVector::new(mir.basic_blocks().len());\n     for (bb, _) in traversal::preorder(mir) {\n         seen.insert(bb.index());"}]}