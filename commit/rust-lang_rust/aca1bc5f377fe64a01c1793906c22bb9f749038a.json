{"sha": "aca1bc5f377fe64a01c1793906c22bb9f749038a", "node_id": "C_kwDOAAsO6NoAKGFjYTFiYzVmMzc3ZmU2NGEwMWMxNzkzOTA2YzIyYmI5Zjc0OTAzOGE", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-12-06T06:58:24Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-12-14T09:10:41Z"}, "message": "Add documentation for custom mir", "tree": {"sha": "4a46e30df94c31a6f252747b22f18fa54f4c4429", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a46e30df94c31a6f252747b22f18fa54f4c4429"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aca1bc5f377fe64a01c1793906c22bb9f749038a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aca1bc5f377fe64a01c1793906c22bb9f749038a", "html_url": "https://github.com/rust-lang/rust/commit/aca1bc5f377fe64a01c1793906c22bb9f749038a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aca1bc5f377fe64a01c1793906c22bb9f749038a/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e59839454d1d0ab2bf72ff66ecf4f50135023ca5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e59839454d1d0ab2bf72ff66ecf4f50135023ca5", "html_url": "https://github.com/rust-lang/rust/commit/e59839454d1d0ab2bf72ff66ecf4f50135023ca5"}], "stats": {"total": 260, "additions": 224, "deletions": 36}, "files": [{"sha": "e7fa9af9d50b605b3f5e2fc18427a66ba8047961", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 224, "deletions": 36, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/aca1bc5f377fe64a01c1793906c22bb9f749038a/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aca1bc5f377fe64a01c1793906c22bb9f749038a/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=aca1bc5f377fe64a01c1793906c22bb9f749038a", "patch": "@@ -21,11 +21,10 @@\n //! #[custom_mir(dialect = \"built\")]\n //! pub fn simple(x: i32) -> i32 {\n //!     mir!(\n-//!         let temp1: i32;\n-//!         let temp2: _;\n+//!         let temp2: i32;\n //!\n //!         {\n-//!             temp1 = x;\n+//!             let temp1 = x;\n //!             Goto(exit)\n //!         }\n //!\n@@ -38,22 +37,166 @@\n //! }\n //! ```\n //!\n-//! Hopefully most of this is fairly self-explanatory. Expanding on some notable details:\n+//! Hopefully the syntax is fairly self-explanatory to anyone familiar with MIR. The `custom_mir`\n+//! attribute tells the compiler to treat the function as being custom MIR. This attribute only\n+//! works on functions - there is no way to insert custom MIR into the middle of another function.\n+//! The `dialect` and `phase` parameters indicate which version of MIR you are inserting here. This\n+//! will normally be the phase that corresponds to the thing you are trying to test. The phase can\n+//! be omitted for dialects that have just one.\n //!\n-//!  - The `custom_mir` attribute tells the compiler to treat the function as being custom MIR. This\n-//!    attribute only works on functions - there is no way to insert custom MIR into the middle of\n-//!    another function.\n-//!  - The `dialect` and `phase` parameters indicate which version of MIR you are inserting here.\n-//!    This will normally be the phase that corresponds to the thing you are trying to test. The\n-//!    phase can be omitted for dialects that have just one.\n-//!  - You should define your function signature like you normally would. Externally, this function\n-//!    can be called like any other function.\n-//!  - Type inference works - you don't have to spell out the type of all of your locals.\n+//! The input to the [`mir!`] macro is:\n //!\n-//! For now, all statements and terminators are parsed from nested invocations of the special\n-//! functions provided in this module. We additionally want to (but do not yet) support more\n-//! \"normal\" Rust syntax in places where it makes sense. Also, most kinds of instructions are not\n-//! supported yet.\n+//!  - A possibly empty list of local declarations. Locals can also be declared inline on\n+//!    assignments via `let`. Type inference generally works. Shadowing does not.\n+//!  - A list of basic blocks. The first of these is the start block and is where execution begins.\n+//!    All blocks other than the start block need to be given a name, so that they can be referred\n+//!    to later.\n+//!     - Each block is a list of semicolon terminated statements, followed by a terminator. The\n+//!       syntax for the various statements and terminators is designed to be as similar as possible\n+//!       to the syntax for analogous concepts in native Rust. See below for a list.\n+//!\n+//! # Examples\n+//!\n+//! ```rust\n+//! #![feature(core_intrinsics, custom_mir)]\n+//!\n+//! extern crate core;\n+//! use core::intrinsics::mir::*;\n+//!\n+//! #[custom_mir(dialect = \"built\")]\n+//! pub fn choose_load(a: &i32, b: &i32, c: bool) -> i32 {\n+//!     mir!(\n+//!         {\n+//!             match c {\n+//!                 true => t,\n+//!                 _ => f,\n+//!             }\n+//!         }\n+//!\n+//!         t = {\n+//!             let temp = a;\n+//!             Goto(load_and_exit)\n+//!         }\n+//!\n+//!         f = {\n+//!             temp = b;\n+//!             Goto(load_and_exit)\n+//!         }\n+//!\n+//!         load_and_exit = {\n+//!             RET = *temp;\n+//!             Return()\n+//!         }\n+//!     )\n+//! }\n+//!\n+//! #[custom_mir(dialect = \"built\")]\n+//! fn unwrap_unchecked<T>(opt: Option<T>) -> T {\n+//!     mir!({\n+//!         RET = Move(Field(Variant(opt, 1), 0));\n+//!         Return()\n+//!     })\n+//! }\n+//! ```\n+//!\n+//! We can also set off compilation failures that happen in sufficiently late stages of the\n+//! compiler:\n+//!\n+//! ```rust,compile_fail\n+//! #![feature(core_intrinsics, custom_mir)]\n+//!\n+//! extern crate core;\n+//! use core::intrinsics::mir::*;\n+//!\n+//! #[custom_mir(dialect = \"built\")]\n+//! fn borrow_error(should_init: bool) -> i32 {\n+//!     mir!(\n+//!         let temp: i32;\n+//!\n+//!         {\n+//!             match should_init {\n+//!                 true => init,\n+//!                 _ => use_temp,\n+//!             }\n+//!         }\n+//!\n+//!         init = {\n+//!             temp = 0;\n+//!             Goto(use_temp)\n+//!         }\n+//!\n+//!         use_temp = {\n+//!             RET = temp;\n+//!             Return()\n+//!         }\n+//!     )\n+//! }\n+//! ```\n+//!\n+//! ```text\n+//! error[E0381]: used binding is possibly-uninitialized\n+//!   --> test.rs:24:13\n+//!    |\n+//! 8  | /     mir!(\n+//! 9  | |         let temp: i32;\n+//! 10 | |\n+//! 11 | |         {\n+//! ...  |\n+//! 19 | |             temp = 0;\n+//!    | |             -------- binding initialized here in some conditions\n+//! ...  |\n+//! 24 | |             RET = temp;\n+//!    | |             ^^^^^^^^^^ value used here but it is possibly-uninitialized\n+//! 25 | |             Return()\n+//! 26 | |         }\n+//! 27 | |     )\n+//!    | |_____- binding declared here but left uninitialized\n+//!\n+//! error: aborting due to previous error\n+//!\n+//! For more information about this error, try `rustc --explain E0381`.\n+//! ```\n+//!\n+//! # Syntax\n+//!\n+//! The lists below are an exahustive description of how various MIR constructs can be created.\n+//! Anything missing from the list should be assumed to not be supported, PRs welcome.\n+//!\n+//! #### Locals\n+//!\n+//!  - The `_0` return local can always be accessed via `RET`.\n+//!  - Arguments can be accessed via their regular name.\n+//!  - All other locals need to be declared with `let` somewhere and then can be accessed by name.\n+//!\n+//! #### Places\n+//!  - Locals implicit convert to places.\n+//!  - Field accesses, derefs, and indexing work normally.\n+//!  - Fields in variants can be accessed via the [`Variant`] and [`Field`] methods, see their\n+//!    documentation for details.\n+//!\n+//! #### Operands\n+//!  - Places implicitly convert to `Copy` operands.\n+//!  - `Move` operands can be created via [`Move`].\n+//!  - Const blocks, literals, named constants, and const params all just work.\n+//!  - [`Static`] and [`StaticMut`] can be used to create `&T` and `*mut T`s to statics. These are\n+//!    constants in MIR and the only way to access statics.\n+//!\n+//! #### Statements\n+//!  - Assign statements work via normal Rust assignment.\n+//!  - [`Retag`] statements have an associated function.\n+//!\n+//! #### Rvalues\n+//!\n+//!  - Operands implicitly convert to `Use` rvalues.\n+//!  - `&`, `&mut`, `addr_of!`, and `addr_of_mut!` all work to create their associated rvalue.\n+//!  - [`Discriminant`] has an associated function.\n+//!\n+//! #### Terminators\n+//!\n+//!  - [`Goto`] and [`Return`] have associated functions.\n+//!  - `match some_int_operand` becomes a `SwitchInt`. Each arm should be `literal => basic_block`\n+//!     - The exception is the last arm, which must be `_ => basic_block` and corresponds to the\n+//!       otherwise branch.\n //!\n \n #![unstable(\n@@ -69,9 +212,10 @@\n pub struct BasicBlock;\n \n macro_rules! define {\n-    ($name:literal, $($sig:tt)*) => {\n+    ($name:literal, $( #[ $meta:meta ] )* fn $($sig:tt)*) => {\n         #[rustc_diagnostic_item = $name]\n-        pub $($sig)* { panic!() }\n+        $( #[ $meta ] )*\n+        pub fn $($sig)* { panic!() }\n     }\n }\n \n@@ -88,11 +232,67 @@ define!(\n     fn Discriminant<T>(place: T) -> <T as ::core::marker::DiscriminantKind>::Discriminant\n );\n define!(\"mir_set_discriminant\", fn SetDiscriminant<T>(place: T, index: u32));\n-define!(\"mir_field\", fn Field<F>(place: (), field: u32) -> F);\n-define!(\"mir_variant\", fn Variant<T>(place: T, index: u32) -> ());\n-define!(\"mir_make_place\", fn __internal_make_place<T>(place: T) -> *mut T);\n+define!(\n+    \"mir_field\",\n+    /// Access the field with the given index of some place.\n+    ///\n+    /// This only makes sense to use in conjunction with [`Variant`]. If the type you are looking to\n+    /// access the field of does not have variants, you can use normal field projection syntax.\n+    ///\n+    /// There is no proper way to do a place projection to a variant in Rust, and so these two\n+    /// functions are a workaround. You can access a field of a variant via `Field(Variant(place,\n+    /// var_idx), field_idx)`, where `var_idx` and `field_idx` are appropriate literals. Some\n+    /// caveats:\n+    ///\n+    ///  - The return type of `Variant` is always `()`. Don't worry about that, the correct MIR will\n+    ///    still be generated.\n+    ///  - In some situations, the return type of `Field` cannot be inferred. You may need to\n+    ///    annotate it on the function in these cases.\n+    ///  - Since `Field` is a function call which is not a place expression, using this on the left\n+    ///    hand side of an expression is rejected by the compiler. [`place!`] is a macro provided to\n+    ///    work around that issue. Wrap the left hand side of an assignment in the macro to convince\n+    ///    the compiler that it's ok.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(custom_mir, core_intrinsics)]\n+    ///\n+    /// extern crate core;\n+    /// use core::intrinsics::mir::*;\n+    ///\n+    /// #[custom_mir(dialect = \"built\")]\n+    /// fn unwrap_deref(opt: Option<&i32>) -> i32 {\n+    ///     mir!({\n+    ///         RET = *Field::<&i32>(Variant(opt, 1), 0);\n+    ///         Return()\n+    ///     })\n+    /// }\n+    ///\n+    /// #[custom_mir(dialect = \"built\")]\n+    /// fn set(opt: &mut Option<i32>) {\n+    ///     mir!({\n+    ///         place!(Field(Variant(*opt, 1), 0)) = 5;\n+    ///         Return()\n+    ///     })\n+    /// }\n+    /// ```\n+    fn Field<F>(place: (), field: u32) -> F\n+);\n+define!(\n+    \"mir_variant\",\n+    /// Adds a variant projection with the given index to the place.\n+    ///\n+    /// See [`Field`] for documentation.\n+    fn Variant<T>(place: T, index: u32) -> ()\n+);\n+define!(\n+    \"mir_make_place\",\n+    #[doc(hidden)]\n+    fn __internal_make_place<T>(place: T) -> *mut T\n+);\n \n-/// Convenience macro for generating custom MIR.\n+/// Macro for generating custom MIR.\n ///\n /// See the module documentation for syntax details. This macro is not magic - it only transforms\n /// your MIR into something that is easier to parse in the compiler.\n@@ -150,19 +350,7 @@ pub macro mir {\n \n /// Helper macro that allows you to treat a value expression like a place expression.\n ///\n-/// This is necessary in combination with the [`Field`] and [`Variant`] methods. Specifically,\n-/// something like this won't compile on its own, reporting an error about not being able to assign\n-/// to such an expression:\n-///\n-/// ```rust,ignore(syntax-highlighting-only)\n-/// Field(something, 0) = 5;\n-/// ```\n-///\n-/// Instead, you'll need to write\n-///\n-/// ```rust,ignore(syntax-highlighting-only)\n-/// place!(Field(something, 0)) = 5;\n-/// ```\n+/// See the documentation on [`Variant`] for why this is necessary and how to use it.\n pub macro place($e:expr) {\n     (*::core::intrinsics::mir::__internal_make_place($e))\n }"}]}