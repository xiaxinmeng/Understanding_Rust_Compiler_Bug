{"sha": "c46b32c44987de02559f7ec5898765722fa45166", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NmIzMmM0NDk4N2RlMDI1NTlmN2VjNTg5ODc2NTcyMmZhNDUxNjY=", "commit": {"author": {"name": "ivan770", "email": "leshenko.ivan770@gmail.com", "date": "2021-02-13T13:27:04Z"}, "committer": {"name": "ivan770", "email": "leshenko.ivan770@gmail.com", "date": "2021-02-13T13:27:04Z"}, "message": "Added annotation tests", "tree": {"sha": "89eb9df7bdbfe8dc953493291dc142eba72a62ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89eb9df7bdbfe8dc953493291dc142eba72a62ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c46b32c44987de02559f7ec5898765722fa45166", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEcPkYW+t8+2SKgl5T2MS9WuTZzE0FAmAn06gACgkQ2MS9WuTZ\nzE1D7gf9HF3dRxn3fb5tqKc6SfT0vtsUHGht6SSeR0wGEMiiuDxY0Kj6EXUf/+X4\n8nJc8eNl9UxrVeshZ/fwJYsrnOO3ErwzBfi2M+pvtIlS/W15mwhhY+MHXT5jf7RM\nJcKtoI9frWsS+G8UsFQzJYcH6P+e09lx7y3yG4JZ2wwyeDq5K0T4QY82ie5ZtF3n\nsXHhlwH/2RITPCciV2YfurKgSFaStkSmiRGie9ed4UAh62QIZnTEKmk6sgjENxIv\nkzmst2+R8fwBM/LN4Enrvg2dQ7rqdOkHpraW9FRakTLxOZoi6frIl0sovLX3L86p\nStvkzRFh4c/WdDvTxQ2Wx0DsOdRm5Q==\n=f8Ws\n-----END PGP SIGNATURE-----", "payload": "tree 89eb9df7bdbfe8dc953493291dc142eba72a62ac\nparent 02ad828c6dc544ac2fb20b85d85ccf6ea495df9c\nauthor ivan770 <leshenko.ivan770@gmail.com> 1613222824 +0200\ncommitter ivan770 <leshenko.ivan770@gmail.com> 1613222824 +0200\n\nAdded annotation tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c46b32c44987de02559f7ec5898765722fa45166", "html_url": "https://github.com/rust-lang/rust/commit/c46b32c44987de02559f7ec5898765722fa45166", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c46b32c44987de02559f7ec5898765722fa45166/comments", "author": {"login": "ivan770", "id": 14003886, "node_id": "MDQ6VXNlcjE0MDAzODg2", "avatar_url": "https://avatars.githubusercontent.com/u/14003886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivan770", "html_url": "https://github.com/ivan770", "followers_url": "https://api.github.com/users/ivan770/followers", "following_url": "https://api.github.com/users/ivan770/following{/other_user}", "gists_url": "https://api.github.com/users/ivan770/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivan770/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivan770/subscriptions", "organizations_url": "https://api.github.com/users/ivan770/orgs", "repos_url": "https://api.github.com/users/ivan770/repos", "events_url": "https://api.github.com/users/ivan770/events{/privacy}", "received_events_url": "https://api.github.com/users/ivan770/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ivan770", "id": 14003886, "node_id": "MDQ6VXNlcjE0MDAzODg2", "avatar_url": "https://avatars.githubusercontent.com/u/14003886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivan770", "html_url": "https://github.com/ivan770", "followers_url": "https://api.github.com/users/ivan770/followers", "following_url": "https://api.github.com/users/ivan770/following{/other_user}", "gists_url": "https://api.github.com/users/ivan770/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivan770/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivan770/subscriptions", "organizations_url": "https://api.github.com/users/ivan770/orgs", "repos_url": "https://api.github.com/users/ivan770/repos", "events_url": "https://api.github.com/users/ivan770/events{/privacy}", "received_events_url": "https://api.github.com/users/ivan770/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02ad828c6dc544ac2fb20b85d85ccf6ea495df9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/02ad828c6dc544ac2fb20b85d85ccf6ea495df9c", "html_url": "https://github.com/rust-lang/rust/commit/02ad828c6dc544ac2fb20b85d85ccf6ea495df9c"}], "stats": {"total": 267, "additions": 267, "deletions": 0}, "files": [{"sha": "97a36119433d404b30678779b615bcddd2fb2d7a", "filename": "crates/ide/src/annotations.rs", "status": "modified", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/c46b32c44987de02559f7ec5898765722fa45166/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46b32c44987de02559f7ec5898765722fa45166/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=c46b32c44987de02559f7ec5898765722fa45166", "patch": "@@ -18,11 +18,13 @@ use crate::{\n //\n // Provides user with annotations above items for looking up references or impl blocks\n // and running/debugging binaries.\n+#[derive(Debug)]\n pub struct Annotation {\n     pub range: TextRange,\n     pub kind: AnnotationKind,\n }\n \n+#[derive(Debug)]\n pub enum AnnotationKind {\n     Runnable { debug: bool, runnable: Runnable },\n     HasImpls { position: FilePosition, data: Option<Vec<NavigationTarget>> },\n@@ -141,3 +143,268 @@ pub(crate) fn resolve_annotation(db: &RootDatabase, mut annotation: Annotation)\n \n     annotation\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use ide_db::base_db::{FileId, FileRange};\n+    use syntax::{TextRange, TextSize};\n+\n+    use crate::{fixture, Annotation, AnnotationConfig, AnnotationKind, RunnableKind};\n+\n+    fn get_annotations(\n+        ra_fixture: &str,\n+        annotation_config: AnnotationConfig,\n+    ) -> (FileId, Vec<Annotation>) {\n+        let (analysis, file_id) = fixture::file(ra_fixture);\n+\n+        let annotations: Vec<Annotation> = analysis\n+            .annotations(file_id, annotation_config)\n+            .unwrap()\n+            .into_iter()\n+            .map(move |annotation| analysis.resolve_annotation(annotation).unwrap())\n+            .collect();\n+\n+        if annotations.len() == 0 {\n+            panic!(\"unresolved annotations\")\n+        }\n+\n+        (file_id, annotations)\n+    }\n+\n+    macro_rules! check_annotation {\n+        ( $ra_fixture:expr, $config:expr, $item_positions:expr, $pattern:pat, $checker:expr ) => {\n+            let (file_id, annotations) = get_annotations($ra_fixture, $config);\n+\n+            annotations.into_iter().for_each(|annotation| {\n+                assert!($item_positions.contains(&annotation.range));\n+\n+                match annotation.kind {\n+                    $pattern => $checker(file_id),\n+                    _ => panic!(\"Unexpected annotation kind\"),\n+                }\n+            });\n+        };\n+    }\n+\n+    #[test]\n+    fn const_annotations() {\n+        check_annotation!(\n+            r#\"\n+const DEMO: i32 = 123;\n+\n+fn main() {\n+    let hello = DEMO;\n+}\n+            \"#,\n+            AnnotationConfig {\n+                binary_target: false,\n+                annotate_runnables: false,\n+                annotate_impls: false,\n+                annotate_references: true,\n+                annotate_method_references: false,\n+                run: false,\n+                debug: false,\n+            },\n+            &[TextRange::new(TextSize::from(0), TextSize::from(22))],\n+            AnnotationKind::HasReferences { data: Some(ranges), .. },\n+            |file_id| assert_eq!(\n+                *ranges.first().unwrap(),\n+                FileRange {\n+                    file_id,\n+                    range: TextRange::new(TextSize::from(52), TextSize::from(56))\n+                }\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn unused_const_annotations() {\n+        check_annotation!(\n+            r#\"\n+const DEMO: i32 = 123;\n+\n+fn main() {}\n+            \"#,\n+            AnnotationConfig {\n+                binary_target: false,\n+                annotate_runnables: false,\n+                annotate_impls: false,\n+                annotate_references: true,\n+                annotate_method_references: false,\n+                run: false,\n+                debug: false,\n+            },\n+            &[TextRange::new(TextSize::from(0), TextSize::from(22))],\n+            AnnotationKind::HasReferences { data: Some(ranges), .. },\n+            |_| assert_eq!(ranges.len(), 0)\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_references_annotations() {\n+        check_annotation!(\n+            r#\"\n+struct Test;\n+\n+fn main() {\n+    let test = Test;\n+}\n+            \"#,\n+            AnnotationConfig {\n+                binary_target: false,\n+                annotate_runnables: false,\n+                annotate_impls: false,\n+                annotate_references: true,\n+                annotate_method_references: false,\n+                run: false,\n+                debug: false,\n+            },\n+            &[TextRange::new(TextSize::from(0), TextSize::from(12))],\n+            AnnotationKind::HasReferences { data: Some(ranges), .. },\n+            |file_id| assert_eq!(\n+                *ranges.first().unwrap(),\n+                FileRange {\n+                    file_id,\n+                    range: TextRange::new(TextSize::from(41), TextSize::from(45))\n+                }\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_and_trait_impls_annotations() {\n+        check_annotation!(\n+            r#\"\n+struct Test;\n+\n+trait MyCoolTrait {}\n+\n+impl MyCoolTrait for Test {}\n+\n+fn main() {\n+    let test = Test;\n+}\n+            \"#,\n+            AnnotationConfig {\n+                binary_target: false,\n+                annotate_runnables: false,\n+                annotate_impls: true,\n+                annotate_references: false,\n+                annotate_method_references: false,\n+                run: false,\n+                debug: false,\n+            },\n+            &[\n+                TextRange::new(TextSize::from(0), TextSize::from(12)),\n+                TextRange::new(TextSize::from(14), TextSize::from(34))\n+            ],\n+            AnnotationKind::HasImpls { data: Some(ranges), .. },\n+            |_| assert_eq!(\n+                ranges.first().unwrap().full_range,\n+                TextRange::new(TextSize::from(36), TextSize::from(64))\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn run_annotation() {\n+        check_annotation!(\n+            r#\"\n+fn main() {}\n+            \"#,\n+            AnnotationConfig {\n+                binary_target: true,\n+                annotate_runnables: true,\n+                annotate_impls: false,\n+                annotate_references: false,\n+                annotate_method_references: false,\n+                run: true,\n+                debug: false,\n+            },\n+            &[TextRange::new(TextSize::from(0), TextSize::from(12))],\n+            AnnotationKind::Runnable { debug: false, runnable },\n+            |_| {\n+                assert!(matches!(runnable.kind, RunnableKind::Bin));\n+                assert!(runnable.action().run_title.contains(\"Run\"));\n+            }\n+        );\n+    }\n+\n+    #[test]\n+    fn debug_annotation() {\n+        check_annotation!(\n+            r#\"\n+fn main() {}\n+            \"#,\n+            AnnotationConfig {\n+                binary_target: true,\n+                annotate_runnables: true,\n+                annotate_impls: false,\n+                annotate_references: false,\n+                annotate_method_references: false,\n+                run: false,\n+                debug: true,\n+            },\n+            &[TextRange::new(TextSize::from(0), TextSize::from(12))],\n+            AnnotationKind::Runnable { debug: true, runnable },\n+            |_| {\n+                assert!(matches!(runnable.kind, RunnableKind::Bin));\n+                assert!(runnable.action().debugee);\n+            }\n+        );\n+    }\n+\n+    #[test]\n+    fn method_annotations() {\n+        // We actually want to skip `fn main` annotation, as it has no references in it\n+        // but just ignoring empty reference slices would lead to false-positive if something\n+        // goes wrong in annotation resolving mechanism. By tracking if we iterated before finding\n+        // an empty slice we can track if everything is settled.\n+        let mut iterated_once = false;\n+\n+        check_annotation!(\n+            r#\"\n+struct Test;\n+\n+impl Test {\n+    fn self_by_ref(&self) {}\n+}\n+\n+fn main() {\n+    Test.self_by_ref();\n+}\n+            \"#,\n+            AnnotationConfig {\n+                binary_target: false,\n+                annotate_runnables: false,\n+                annotate_impls: false,\n+                annotate_references: false,\n+                annotate_method_references: true,\n+                run: false,\n+                debug: false,\n+            },\n+            &[\n+                TextRange::new(TextSize::from(33), TextSize::from(44)),\n+                TextRange::new(TextSize::from(61), TextSize::from(65))\n+            ],\n+            AnnotationKind::HasReferences { data: Some(ranges), .. },\n+            |file_id| {\n+                match ranges.as_slice() {\n+                    [first, ..] => {\n+                        assert_eq!(\n+                            *first,\n+                            FileRange {\n+                                file_id,\n+                                range: TextRange::new(TextSize::from(79), TextSize::from(90))\n+                            }\n+                        );\n+\n+                        iterated_once = true;\n+                    }\n+                    [] if iterated_once => {}\n+                    [] => panic!(\"One reference was expected but not found\"),\n+                }\n+            }\n+        );\n+    }\n+}"}]}