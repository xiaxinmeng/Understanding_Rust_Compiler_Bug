{"sha": "7c6f242ca8a4eca33e8257906cc549b6b1418be2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNmYyNDJjYThhNGVjYTMzZTgyNTc5MDZjYzU0OWI2YjE0MThiZTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-01T16:29:35Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-17T14:34:54Z"}, "message": "rustc: don't track whether layouts are \"packed\".", "tree": {"sha": "d10a97a0b718d3f278f86524db11c432134db3ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10a97a0b718d3f278f86524db11c432134db3ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c6f242ca8a4eca33e8257906cc549b6b1418be2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6f242ca8a4eca33e8257906cc549b6b1418be2", "html_url": "https://github.com/rust-lang/rust/commit/7c6f242ca8a4eca33e8257906cc549b6b1418be2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c6f242ca8a4eca33e8257906cc549b6b1418be2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53a6d14e5bb8b1915a5f0b9371bbf0da934ed052", "url": "https://api.github.com/repos/rust-lang/rust/commits/53a6d14e5bb8b1915a5f0b9371bbf0da934ed052", "html_url": "https://github.com/rust-lang/rust/commit/53a6d14e5bb8b1915a5f0b9371bbf0da934ed052"}], "stats": {"total": 300, "additions": 116, "deletions": 184}, "files": [{"sha": "5464fa601ecad1315aa1335c328a0725f05f3131", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -895,7 +895,7 @@ pub struct InterpretInterner<'tcx> {\n     /// Allows checking whether a constant already has an allocation\n     ///\n     /// The pointers are to the beginning of an `alloc_by_id` allocation\n-    alloc_cache: FxHashMap<interpret::GlobalId<'tcx>, interpret::PtrAndAlign>,\n+    alloc_cache: FxHashMap<interpret::GlobalId<'tcx>, interpret::Pointer>,\n \n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n@@ -931,14 +931,14 @@ impl<'tcx> InterpretInterner<'tcx> {\n     pub fn get_cached(\n         &self,\n         global_id: interpret::GlobalId<'tcx>,\n-    ) -> Option<interpret::PtrAndAlign> {\n+    ) -> Option<interpret::Pointer> {\n         self.alloc_cache.get(&global_id).cloned()\n     }\n \n     pub fn cache(\n         &mut self,\n         global_id: interpret::GlobalId<'tcx>,\n-        ptr: interpret::PtrAndAlign,\n+        ptr: interpret::Pointer,\n     ) {\n         if let Some(old) = self.alloc_cache.insert(global_id, ptr) {\n             bug!(\"tried to cache {:?}, but was already existing as {:#?}\", global_id, old);"}, {"sha": "42987e3dd782a30f5121d8c0d3ccc490f3e314c3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 11, "deletions": 52, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -778,7 +778,6 @@ pub enum Abi {\n     Aggregate {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n-        packed: bool\n     }\n }\n \n@@ -790,18 +789,7 @@ impl Abi {\n             Abi::Scalar(_) |\n             Abi::ScalarPair(..) |\n             Abi::Vector { .. } => false,\n-            Abi::Aggregate { sized, .. } => !sized\n-        }\n-    }\n-\n-    /// Returns true if the fields of the layout are packed.\n-    pub fn is_packed(&self) -> bool {\n-        match *self {\n-            Abi::Uninhabited |\n-            Abi::Scalar(_) |\n-            Abi::ScalarPair(..) |\n-            Abi::Vector { .. } => false,\n-            Abi::Aggregate { packed, .. } => packed\n+            Abi::Aggregate { sized } => !sized\n         }\n     }\n }\n@@ -1077,10 +1065,7 @@ impl<'a, 'tcx> LayoutDetails {\n             }\n \n             let size = min_size.abi_align(align);\n-            let mut abi = Abi::Aggregate {\n-                sized,\n-                packed\n-            };\n+            let mut abi = Abi::Aggregate { sized };\n \n             // Unpack newtype ABIs and find scalar pairs.\n             if sized && size.bytes() > 0 {\n@@ -1254,10 +1239,7 @@ impl<'a, 'tcx> LayoutDetails {\n                         stride: element.size,\n                         count\n                     },\n-                    abi: Abi::Aggregate {\n-                        sized: true,\n-                        packed: false\n-                    },\n+                    abi: Abi::Aggregate { sized: true },\n                     align: element.align,\n                     size\n                 })\n@@ -1270,10 +1252,7 @@ impl<'a, 'tcx> LayoutDetails {\n                         stride: element.size,\n                         count: 0\n                     },\n-                    abi: Abi::Aggregate {\n-                        sized: false,\n-                        packed: false\n-                    },\n+                    abi: Abi::Aggregate { sized: false },\n                     align: element.align,\n                     size: Size::from_bytes(0)\n                 })\n@@ -1285,10 +1264,7 @@ impl<'a, 'tcx> LayoutDetails {\n                         stride: Size::from_bytes(1),\n                         count: 0\n                     },\n-                    abi: Abi::Aggregate {\n-                        sized: false,\n-                        packed: false\n-                    },\n+                    abi: Abi::Aggregate { sized: false },\n                     align: dl.i8_align,\n                     size: Size::from_bytes(0)\n                 })\n@@ -1302,7 +1278,7 @@ impl<'a, 'tcx> LayoutDetails {\n                 let mut unit = univariant_uninterned(&[], &ReprOptions::default(),\n                   StructKind::AlwaysSized)?;\n                 match unit.abi {\n-                    Abi::Aggregate { ref mut sized, .. } => *sized = false,\n+                    Abi::Aggregate { ref mut sized } => *sized = false,\n                     _ => bug!()\n                 }\n                 tcx.intern_layout(unit)\n@@ -1418,10 +1394,7 @@ impl<'a, 'tcx> LayoutDetails {\n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index: 0 },\n                         fields: FieldPlacement::Union(variants[0].len()),\n-                        abi: Abi::Aggregate {\n-                            sized: true,\n-                            packed\n-                        },\n+                        abi: Abi::Aggregate { sized: true },\n                         align,\n                         size: size.abi_align(align)\n                     }));\n@@ -1525,15 +1498,10 @@ impl<'a, 'tcx> LayoutDetails {\n                             let abi = if offset.bytes() == 0 && niche.value.size(dl) == size {\n                                 Abi::Scalar(niche.clone())\n                             } else {\n-                                let mut packed = st[i].abi.is_packed();\n                                 if offset.abi_align(niche_align) != offset {\n-                                    packed = true;\n                                     niche_align = dl.i8_align;\n                                 }\n-                                Abi::Aggregate {\n-                                    sized: true,\n-                                    packed\n-                                }\n+                                Abi::Aggregate { sized: true }\n                             };\n                             align = align.max(niche_align);\n \n@@ -1681,10 +1649,7 @@ impl<'a, 'tcx> LayoutDetails {\n                 let abi = if discr.value.size(dl) == size {\n                     Abi::Scalar(discr.clone())\n                 } else {\n-                    Abi::Aggregate {\n-                        sized: true,\n-                        packed: false\n-                    }\n+                    Abi::Aggregate { sized: true }\n                 };\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Tagged {\n@@ -2277,19 +2242,14 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         self.abi.is_unsized()\n     }\n \n-    /// Returns true if the fields of the layout are packed.\n-    pub fn is_packed(&self) -> bool {\n-        self.abi.is_packed()\n-    }\n-\n     /// Returns true if the type is a ZST and not unsized.\n     pub fn is_zst(&self) -> bool {\n         match self.abi {\n             Abi::Uninhabited => true,\n             Abi::Scalar(_) |\n             Abi::ScalarPair(..) |\n             Abi::Vector { .. } => false,\n-            Abi::Aggregate { sized, .. } => sized && self.size.bytes() == 0\n+            Abi::Aggregate { sized } => sized && self.size.bytes() == 0\n         }\n     }\n \n@@ -2452,8 +2412,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n                 element.hash_stable(hcx, hasher);\n                 count.hash_stable(hcx, hasher);\n             }\n-            Aggregate { packed, sized } => {\n-                packed.hash_stable(hcx, hasher);\n+            Aggregate { sized } => {\n                 sized.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "aaadddba0c1bb6c12bb4b9d42584df4ce5471eec", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, PrimVal, PtrAndAlign};\n+use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, Pointer, PrimVal, PtrAndAlign};\n use super::{Place, PlaceExtra, EvalContext, StackPopCleanup, ValTy, HasMemory};\n \n use rustc_const_math::ConstInt;\n@@ -45,7 +45,7 @@ pub fn eval_body<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (PtrAndAlign, Ty<'tcx>)> {\n+) -> EvalResult<'tcx, (Pointer, Ty<'tcx>)> {\n     debug!(\"eval_body: {:?}, {:?}\", instance, param_env);\n     let limits = super::ResourceLimits::default();\n     let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n@@ -69,13 +69,7 @@ pub fn eval_body<'a, 'tcx>(\n             layout.align.abi(),\n             None,\n         )?;\n-        tcx.interpret_interner.borrow_mut().cache(\n-            cid,\n-            PtrAndAlign {\n-                ptr: ptr.into(),\n-                aligned: !layout.is_packed(),\n-            },\n-        );\n+        tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n         let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n         let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n         trace!(\"const_eval: pushing stack frame for global: {}\", name);\n@@ -101,7 +95,7 @@ pub fn eval_body_as_integer<'a, 'tcx>(\n     let ptr_ty = eval_body(tcx, instance, param_env);\n     let (ptr, ty) = ptr_ty?;\n     let ecx = mk_eval_cx(tcx, instance, param_env)?;\n-    let prim = match ecx.read_maybe_aligned(ptr.aligned, |ectx| ectx.try_read_value(ptr.ptr, ty))? {\n+    let prim = match ecx.try_read_value(ptr, ty)? {\n         Some(Value::ByVal(prim)) => prim.to_bytes()?,\n         _ => return err!(TypeNotPrimitive(ty)),\n     };\n@@ -363,7 +357,10 @@ pub fn const_eval_provider<'a, 'tcx>(\n             (_, Err(err)) => Err(err),\n             (Ok((miri_val, miri_ty)), Ok(ctfe)) => {\n                 let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-                check_ctfe_against_miri(&mut ecx, miri_val, miri_ty, ctfe.val);\n+                check_ctfe_against_miri(&mut ecx, PtrAndAlign {\n+                    ptr: miri_val,\n+                    aligned: true\n+                }, miri_ty, ctfe.val);\n                 Ok(ctfe)\n             }\n         }"}, {"sha": "5fe1d6cd540d64b945ea2a441b8eb59169335297", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -261,11 +261,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                let cid = GlobalId {\n+                return Ok(self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                };\n-                return Ok(Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(cid).expect(\"static/const not cached\")));\n+                }));\n             }\n \n             Aggregate(..) |\n@@ -834,11 +833,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Literal::Value { ref value } => self.const_to_value(&value.val)?,\n \n                     Literal::Promoted { index } => {\n-                        let cid = GlobalId {\n+                        self.read_global_as_value(GlobalId {\n                             instance: self.frame().instance,\n                             promoted: Some(index),\n-                        };\n-                        Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(cid).expect(\"promoted not cached\"))\n+                        })\n                     }\n                 };\n \n@@ -951,7 +949,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn read_global_as_value(&self, gid: GlobalId) -> Value {\n-        Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"))\n+        Value::ByRef(PtrAndAlign {\n+            ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"),\n+            aligned: true\n+        })\n     }\n \n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n@@ -1149,51 +1150,29 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             Value::ByVal(primval) => {\n                 let layout = self.layout_of(dest_ty)?;\n-                if layout.is_zst() {\n-                    assert!(primval.is_undef());\n-                    Ok(())\n-                } else {\n-                    // TODO: Do we need signedness?\n-                    self.memory.write_maybe_aligned_mut(!layout.is_packed(), |mem| {\n-                        mem.write_primval(dest.to_ptr()?, primval, layout.size.bytes(), false)\n-                    })\n+                match layout.abi {\n+                    layout::Abi::Scalar(_) => {}\n+                    _ if primval.is_undef() => {}\n+                    _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout)\n                 }\n+                // TODO: Do we need signedness?\n+                self.memory.write_primval(dest.to_ptr()?, primval, layout.size.bytes(), false)\n             }\n-            Value::ByValPair(a, b) => {\n+            Value::ByValPair(a_val, b_val) => {\n                 let ptr = dest.to_ptr()?;\n                 let mut layout = self.layout_of(dest_ty)?;\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n-                let mut packed = layout.is_packed();\n-                'outer: loop {\n-                    for i in 0..layout.fields.count() {\n-                        let field = layout.field(&self, i)?;\n-                        if layout.fields.offset(i).bytes() == 0 && layout.size == field.size {\n-                            layout = field;\n-                            packed |= layout.is_packed();\n-                            continue 'outer;\n-                        }\n-                    }\n-                    break;\n-                }\n-                trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n-                assert_eq!(layout.fields.count(), 2);\n-                let field_0 = layout.field(&self, 0)?;\n-                let field_1 = layout.field(&self, 1)?;\n-                trace!(\"write_value_to_ptr field 0: {:#?}\", field_0);\n-                trace!(\"write_value_to_ptr field 1: {:#?}\", field_1);\n-                assert_eq!(\n-                    field_0.is_packed(),\n-                    field_1.is_packed(),\n-                    \"the two fields must agree on being packed\"\n-                );\n-                packed |= field_0.is_packed();\n-                let field_0_ptr = ptr.offset(layout.fields.offset(0).bytes(), &self)?.into();\n-                let field_1_ptr = ptr.offset(layout.fields.offset(1).bytes(), &self)?.into();\n+                let (a, b) = match layout.abi {\n+                    layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n+                    _ => bug!(\"write_value_to_ptr: invalid ByValPair layout: {:#?}\", layout)\n+                };\n+                let (a_size, b_size) = (a.size(&self), b.size(&self));\n+                let a_ptr = ptr;\n+                let b_offset = a_size.abi_align(b.align(&self));\n+                let b_ptr = ptr.offset(b_offset.bytes(), &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory.write_maybe_aligned_mut(!packed, |mem| {\n-                    mem.write_primval(field_0_ptr, a, field_0.size.bytes(), false)?;\n-                    mem.write_primval(field_1_ptr, b, field_1.size.bytes(), false)\n-                })?;\n+                self.memory.write_primval(a_ptr, a_val, a_size.bytes(), false)?;\n+                self.memory.write_primval(b_ptr, b_val, b_size.bytes(), false)?;\n                 Ok(())\n             }\n         }"}, {"sha": "7c19c9f308017de0423b3ec9a5c9dff76467d4fc", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -1,6 +1,6 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::mir::interpret::{GlobalId, PtrAndAlign};\n \n@@ -106,9 +106,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     instance,\n                     promoted: None,\n                 };\n-                Ok(Some(Value::ByRef(\n-                    self.tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\"),\n-                )))\n+                Ok(Some(self.read_global_as_value(cid)))\n             }\n             Projection(ref proj) => self.try_read_place_projection(proj),\n         }\n@@ -193,7 +191,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     promoted: None,\n                 };\n                 Place::Ptr {\n-                    ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\"),\n+                    ptr: PtrAndAlign {\n+                        ptr: self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"uncached global\"),\n+                        aligned: true\n+                    },\n                     extra: PlaceExtra::None,\n                 }\n             }\n@@ -232,15 +233,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let (base_ptr, base_extra) = match base {\n             Place::Ptr { ptr, extra } => (ptr, extra),\n             Place::Local { frame, local } => {\n-                match self.stack[frame].get_local(local)? {\n+                match (&self.stack[frame].get_local(local)?, &base_layout.abi) {\n                     // in case the field covers the entire type, just return the value\n-                    Value::ByVal(_) if offset.bytes() == 0 &&\n-                                       field.size == base_layout.size => {\n+                    (&Value::ByVal(_), &layout::Abi::Scalar(_)) |\n+                    (&Value::ByValPair(..), &layout::Abi::ScalarPair(..))\n+                        if offset.bytes() == 0 && field.size == base_layout.size =>\n+                    {\n                         return Ok((base, field));\n                     }\n-                    Value::ByRef { .. } |\n-                    Value::ByValPair(..) |\n-                    Value::ByVal(_) => self.force_allocation(base)?.to_ptr_extra_aligned(),\n+                    _ => self.force_allocation(base)?.to_ptr_extra_aligned(),\n                 }\n             }\n         };\n@@ -257,9 +258,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n \n         let mut ptr = base_ptr.offset(offset, &self)?;\n-        // if we were unaligned, stay unaligned\n-        // no matter what we were, if we are packed, we must not be aligned anymore\n-        ptr.aligned &= !base_layout.is_packed();\n+        ptr.aligned &= base_layout.align.abi() >= field.align.abi();\n \n         let extra = if !field.is_unsized() {\n             PlaceExtra::None"}, {"sha": "ae382bd12cd72356b9247292b7ef57e4bd3957eb", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -8,7 +8,7 @@ use rustc::mir;\n use rustc::ty::{self, Instance};\n use rustc::ty::layout::LayoutOf;\n use rustc::middle::const_val::ConstVal;\n-use rustc::mir::interpret::{PtrAndAlign, GlobalId};\n+use rustc::mir::interpret::GlobalId;\n \n use rustc::mir::interpret::{EvalResult, EvalErrorKind};\n use super::{EvalContext, StackPopCleanup, Place, Machine};\n@@ -182,13 +182,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             layout.align.abi(),\n             None,\n         )?;\n-        self.tcx.interpret_interner.borrow_mut().cache(\n-            cid,\n-            PtrAndAlign {\n-                ptr: ptr.into(),\n-                aligned: !layout.is_packed(),\n-            },\n-        );\n+        self.tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n         let internally_mutable = !layout.ty.is_freeze(self.tcx, self.param_env, span);\n         let mutability = if mutability == Mutability::Mutable || internally_mutable {\n             Mutability::Mutable\n@@ -273,13 +267,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                         layout.align.abi(),\n                         None,\n                     )?;\n-                    this.ecx.tcx.interpret_interner.borrow_mut().cache(\n-                        cid,\n-                        PtrAndAlign {\n-                            ptr: ptr.into(),\n-                            aligned: !layout.is_packed(),\n-                        },\n-                    );\n+                    this.ecx.tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n                     trace!(\"pushing stack frame for {:?}\", index);\n                     this.ecx.push_stack_frame(\n                         this.instance,"}, {"sha": "9477adc17c01966eecc760c2f2f1e9dd87222f18", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -69,7 +69,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n             let field_ty = layout.field(ccx, i).ty;\n-            let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n+            let (unsized_size, mut unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n             // to `sized_size` (to accommodate the `unsized_align`\n@@ -81,6 +81,13 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             // Return the sum of sizes and max of aligns.\n             let size = bcx.add(sized_size, unsized_size);\n \n+            // Packed types ignore the alignment of their fields.\n+            if let ty::TyAdt(def, _) = t.sty {\n+                if def.repr.packed() {\n+                    unsized_align = sized_align;\n+                }\n+            }\n+\n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n             let align = match (const_to_opt_u128(sized_align, false),"}, {"sha": "68913c1d6b78c00d4e3c7967ba5b1149c959887a", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -1134,12 +1134,14 @@ fn trans_const_adt<'a, 'tcx>(\n             if let layout::FieldPlacement::Union(_) = l.fields {\n                 assert_eq!(variant_index, 0);\n                 assert_eq!(vals.len(), 1);\n+                let (field_size, field_align) = ccx.size_and_align_of(vals[0].ty);\n                 let contents = [\n                     vals[0].llval,\n-                    padding(ccx, l.size - ccx.size_of(vals[0].ty))\n+                    padding(ccx, l.size - field_size)\n                 ];\n \n-                Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n+                let packed = l.align.abi() < field_align.abi();\n+                Const::new(C_struct(ccx, &contents, packed), t)\n             } else {\n                 if let layout::Abi::Vector { .. } = l.abi {\n                     if let layout::FieldPlacement::Array { .. } = l.fields {\n@@ -1232,28 +1234,33 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     // offset of current value\n+    let mut packed = false;\n     let mut offset = Size::from_bytes(0);\n     let mut cfields = Vec::new();\n     cfields.reserve(discr.is_some() as usize + 1 + layout.fields.count() * 2);\n \n     if let Some(discr) = discr {\n+        let (field_size, field_align) = ccx.size_and_align_of(discr.ty);\n+        packed |= layout.align.abi() < field_align.abi();\n         cfields.push(discr.llval);\n-        offset = ccx.size_of(discr.ty);\n+        offset = field_size;\n     }\n \n     let parts = layout.fields.index_by_increasing_offset().map(|i| {\n         (vals[i], layout.fields.offset(i))\n     });\n     for (val, target_offset) in parts {\n+        let (field_size, field_align) = ccx.size_and_align_of(val.ty);\n+        packed |= layout.align.abi() < field_align.abi();\n         cfields.push(padding(ccx, target_offset - offset));\n         cfields.push(val.llval);\n-        offset = target_offset + ccx.size_of(val.ty);\n+        offset = target_offset + field_size;\n     }\n \n     // Pad to the size of the whole type, not e.g. the variant.\n     cfields.push(padding(ccx, ccx.size_of(layout.ty) - offset));\n \n-    Const::new(C_struct(ccx, &cfields, layout.is_packed()), layout.ty)\n+    Const::new(C_struct(ccx, &cfields, packed), layout.ty)\n }\n \n fn padding(ccx: &CrateContext, size: Size) -> ValueRef {"}, {"sha": "214686f4ca19f22bf7bff2f319d2358e00b83d52", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -55,11 +55,7 @@ impl ops::BitOr for Alignment {\n \n impl<'a> From<TyLayout<'a>> for Alignment {\n     fn from(layout: TyLayout) -> Self {\n-        if layout.is_packed() {\n-            Alignment::Packed(layout.align)\n-        } else {\n-            Alignment::AbiAligned\n-        }\n+        Alignment::Packed(layout.align)\n     }\n }\n \n@@ -232,25 +228,27 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n             }\n         };\n \n-        // Simple case - we can just GEP the field\n-        //   * Packed struct - There is no alignment padding\n-        //   * Field is sized - pointer is properly aligned already\n-        if self.layout.is_packed() || !field.is_unsized() {\n-            return simple();\n-        }\n-\n-        // If the type of the last field is [T], str or a foreign type, then we don't need to do\n-        // any adjusments\n+        // Simple cases, which don't need DST adjustment:\n+        //   * no metadata available - just log the case\n+        //   * known alignment - sized types, [T], str or a foreign type\n+        //   * packed struct - there is no alignment padding\n         match field.ty.sty {\n+            _ if !self.has_extra() => {\n+                debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n+                    ix, Value(self.llval));\n+                return simple();\n+            }\n+            _ if !field.is_unsized() => return simple(),\n             ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => return simple(),\n-            _ => ()\n-        }\n-\n-        // There's no metadata available, log the case and just do the GEP.\n-        if !self.has_extra() {\n-            debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-                ix, Value(self.llval));\n-            return simple();\n+            ty::TyAdt(def, _) => {\n+                if def.repr.packed() {\n+                    // FIXME(eddyb) generalize the adjustment when we\n+                    // start supporting packing to larger alignments.\n+                    assert_eq!(self.layout.align.abi(), 1);\n+                    return simple();\n+                }\n+            }\n+            _ => {}\n         }\n \n         // We need to get the pointer manually now."}, {"sha": "8d9bc07fe5630257c60dd90846ec1027a3c62780", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6f242ca8a4eca33e8257906cc549b6b1418be2/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=7c6f242ca8a4eca33e8257906cc549b6b1418be2", "patch": "@@ -79,13 +79,14 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n             let fill = Type::padding_filler(ccx, layout.size, layout.align);\n+            let packed = false;\n             match name {\n                 None => {\n-                    Type::struct_(ccx, &[fill], layout.is_packed())\n+                    Type::struct_(ccx, &[fill], packed)\n                 }\n                 Some(ref name) => {\n                     let mut llty = Type::named_struct(ccx, name);\n-                    llty.set_struct_body(&[fill], layout.is_packed());\n+                    llty.set_struct_body(&[fill], packed);\n                     llty\n                 }\n             }\n@@ -96,7 +97,8 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(ccx, &struct_llfields(ccx, layout), layout.is_packed())\n+                    let (llfields, packed) = struct_llfields(ccx, layout);\n+                    Type::struct_(ccx, &llfields, packed)\n                 }\n                 Some(ref name) => {\n                     let llty = Type::named_struct(ccx, name);\n@@ -109,15 +111,19 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                             layout: TyLayout<'tcx>) -> Vec<Type> {\n+                             layout: TyLayout<'tcx>)\n+                             -> (Vec<Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n     let field_count = layout.fields.count();\n \n+    let mut packed = false;\n     let mut offset = Size::from_bytes(0);\n     let mut prev_align = layout.align;\n     let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n         let field = layout.field(ccx, i);\n+        packed |= layout.align.abi() < field.align.abi();\n+\n         let target_offset = layout.fields.offset(i as usize);\n         debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n             i, field, offset, target_offset);\n@@ -129,15 +135,6 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"    padding before: {:?}\", padding);\n \n         result.push(field.llvm_type(ccx));\n-\n-        if layout.is_packed() {\n-            assert_eq!(padding.bytes(), 0);\n-        } else {\n-            assert!(field.align.abi() <= layout.align.abi(),\n-                    \"non-packed type has field with larger align ({}): {:#?}\",\n-                    field.align.abi(), layout);\n-        }\n-\n         offset = target_offset + field.size;\n         prev_align = field.align;\n     }\n@@ -158,7 +155,7 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                offset, layout.size);\n     }\n \n-    result\n+    (result, packed)\n }\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n@@ -301,7 +298,8 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         ccx.lltypes().borrow_mut().insert((self.ty, variant_index), llty);\n \n         if let Some((mut llty, layout)) = defer {\n-            llty.set_struct_body(&struct_llfields(ccx, layout), layout.is_packed())\n+            let (llfields, packed) = struct_llfields(ccx, layout);\n+            llty.set_struct_body(&llfields, packed)\n         }\n \n         llty"}]}