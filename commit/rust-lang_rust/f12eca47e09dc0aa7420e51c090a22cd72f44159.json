{"sha": "f12eca47e09dc0aa7420e51c090a22cd72f44159", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMmVjYTQ3ZTA5ZGMwYWE3NDIwZTUxYzA5MGEyMmNkNzJmNDQxNTk=", "commit": {"author": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-07-11T14:41:03Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-16T13:09:17Z"}, "message": "TyKind", "tree": {"sha": "47c3737c3c718060a67333e436486205b1ae52c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47c3737c3c718060a67333e436486205b1ae52c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f12eca47e09dc0aa7420e51c090a22cd72f44159", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f12eca47e09dc0aa7420e51c090a22cd72f44159", "html_url": "https://github.com/rust-lang/rust/commit/f12eca47e09dc0aa7420e51c090a22cd72f44159", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f12eca47e09dc0aa7420e51c090a22cd72f44159/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a16b38198c68cf932d3f43a9663f7588d6a1a3b", "html_url": "https://github.com/rust-lang/rust/commit/6a16b38198c68cf932d3f43a9663f7588d6a1a3b"}], "stats": {"total": 285, "additions": 143, "deletions": 142}, "files": [{"sha": "8c97d5e74af35960cb4d3eb09674ce1413d0ff36", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -50,6 +50,7 @@ use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n use std::u32;\n+use std::result::Result::Err;\n \n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n@@ -576,41 +577,41 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     visitor.visit_id(typ.id);\n \n     match typ.node {\n-        TySlice(ref ty) => {\n+        TyKind::Slice(ref ty) => {\n             visitor.visit_ty(ty)\n         }\n-        TyPtr(ref mutable_type) => {\n+        TyKind::Ptr(ref mutable_type) => {\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref lifetime, ref mutable_type) => {\n+        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n             visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyNever => {},\n-        TyTup(ref tuple_element_types) => {\n+        TyKind::Never => {},\n+        TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n-        TyBareFn(ref function_declaration) => {\n+        TyKind::BareFn(ref function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n             visitor.visit_fn_decl(&function_declaration.decl);\n         }\n-        TyPath(ref qpath) => {\n+        TyKind::Path(ref qpath) => {\n             visitor.visit_qpath(qpath, typ.id, typ.span);\n         }\n-        TyArray(ref ty, ref length) => {\n+        TyKind::Array(ref ty, ref length) => {\n             visitor.visit_ty(ty);\n             visitor.visit_anon_const(length)\n         }\n-        TyTraitObject(ref bounds, ref lifetime) => {\n+        TyKind::TraitObject(ref bounds, ref lifetime) => {\n             for bound in bounds {\n                 visitor.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyTypeof(ref expression) => {\n+        TyKind::Typeof(ref expression) => {\n             visitor.visit_anon_const(expression)\n         }\n-        TyInfer | TyErr => {}\n+        TyKind::Infer | TyKind::Err => {}\n     }\n }\n "}, {"sha": "060f0e036b6ab948577b1d9c3e1107b3f08bdb54", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -1080,25 +1080,25 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext) -> hir::Ty {\n         let kind = match t.node {\n-            TyKind::Infer => hir::TyInfer,\n-            TyKind::Err => hir::TyErr,\n-            TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty, itctx)),\n-            TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt, itctx)),\n+            TyKind::Infer => hir::TyKind::Infer,\n+            TyKind::Err => hir::TyKind::Err,\n+            TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n+            TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n                 let span = t.span.shrink_to_lo();\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n                     None => self.elided_ref_lifetime(span),\n                 };\n-                hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n+                hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(\n                 &f.generic_params,\n                 |this| {\n                     this.with_anonymous_lifetime_mode(\n                         AnonymousLifetimeMode::PassThrough,\n                         |this| {\n-                            hir::TyBareFn(P(hir::BareFnTy {\n+                            hir::TyKind::BareFn(P(hir::BareFnTy {\n                                 generic_params: this.lower_generic_params(\n                                     &f.generic_params,\n                                     &NodeMap(),\n@@ -1113,9 +1113,9 @@ impl<'a> LoweringContext<'a> {\n                     )\n                 },\n             ),\n-            TyKind::Never => hir::TyNever,\n+            TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => {\n-                hir::TyTup(tys.iter().map(|ty| {\n+                hir::TyKind::Tup(tys.iter().map(|ty| {\n                     self.lower_ty_direct(ty, itctx.reborrow())\n                 }).collect())\n             }\n@@ -1126,12 +1126,12 @@ impl<'a> LoweringContext<'a> {\n                 let id = self.lower_node_id(t.id);\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit, itctx);\n                 let ty = self.ty_path(id, t.span, qpath);\n-                if let hir::TyTraitObject(..) = ty.node {\n+                if let hir::TyKind::TraitObject(..) = ty.node {\n                     self.maybe_lint_bare_trait(t.span, t.id, qself.is_none() && path.is_global());\n                 }\n                 return ty;\n             }\n-            TyKind::ImplicitSelf => hir::TyPath(hir::QPath::Resolved(\n+            TyKind::ImplicitSelf => hir::TyKind::Path(hir::QPath::Resolved(\n                 None,\n                 P(hir::Path {\n                     def: self.expect_full_def(t.id),\n@@ -1140,10 +1140,10 @@ impl<'a> LoweringContext<'a> {\n                 }),\n             )),\n             TyKind::Array(ref ty, ref length) => {\n-                hir::TyArray(self.lower_ty(ty, itctx), self.lower_anon_const(length))\n+                hir::TyKind::Array(self.lower_ty(ty, itctx), self.lower_anon_const(length))\n             }\n             TyKind::Typeof(ref expr) => {\n-                hir::TyTypeof(self.lower_anon_const(expr))\n+                hir::TyKind::Typeof(self.lower_anon_const(expr))\n             }\n             TyKind::TraitObject(ref bounds, kind) => {\n                 let mut lifetime_bound = None;\n@@ -1167,7 +1167,7 @@ impl<'a> LoweringContext<'a> {\n                 if kind != TraitObjectSyntax::Dyn {\n                     self.maybe_lint_bare_trait(t.span, t.id, false);\n                 }\n-                hir::TyTraitObject(bounds, lifetime_bound)\n+                hir::TyKind::TraitObject(bounds, lifetime_bound)\n             }\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n@@ -1206,7 +1206,7 @@ impl<'a> LoweringContext<'a> {\n                             }\n                         });\n \n-                        hir::TyPath(hir::QPath::Resolved(\n+                        hir::TyKind::Path(hir::QPath::Resolved(\n                             None,\n                             P(hir::Path {\n                                 span,\n@@ -1223,7 +1223,7 @@ impl<'a> LoweringContext<'a> {\n                             \"`impl Trait` not allowed outside of function \\\n                              and inherent method return types\"\n                         );\n-                        hir::TyErr\n+                        hir::TyKind::Err\n                     }\n                 }\n             }\n@@ -1245,7 +1245,7 @@ impl<'a> LoweringContext<'a> {\n         fn_def_id: DefId,\n         exist_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext) -> hir::GenericBounds,\n-    ) -> hir::Ty_ {\n+    ) -> hir::TyKind {\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n@@ -1320,7 +1320,7 @@ impl<'a> LoweringContext<'a> {\n                     }))\n                 }],\n             });\n-            hir::TyPath(hir::QPath::Resolved(None, path))\n+            hir::TyKind::Path(hir::QPath::Resolved(None, path))\n         })\n     }\n \n@@ -1365,7 +1365,7 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax\n-                if let hir::Ty_::TyBareFn(_) = t.node {\n+                if let hir::TyKind::BareFn(_) = t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n \n@@ -1805,7 +1805,7 @@ impl<'a> LoweringContext<'a> {\n                 let inputs = inputs.iter().map(|ty| this.lower_ty_direct(ty, DISALLOWED)).collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                    hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span }\n+                    hir::Ty { node: hir::TyKind::Tup(tys), id: node_id, hir_id, span }\n                 };\n \n                 (\n@@ -1985,7 +1985,7 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax\n-                if let &hir::Ty_::TyBareFn(_) = &t.node {\n+                if let &hir::TyKind::BareFn(_) = &t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n \n@@ -2105,7 +2105,7 @@ impl<'a> LoweringContext<'a> {\n                     P(hir::Ty {\n                         id: node_id,\n                         hir_id: hir_id,\n-                        node: hir::TyTup(hir_vec![]),\n+                        node: hir::TyKind::Tup(hir_vec![]),\n                         span: *span,\n                     })\n                 }\n@@ -4624,7 +4624,7 @@ impl<'a> LoweringContext<'a> {\n         let mut id = id;\n         let node = match qpath {\n             hir::QPath::Resolved(None, path) => {\n-                // Turn trait object paths into `TyTraitObject` instead.\n+                // Turn trait object paths into `TyKind::TraitObject` instead.\n                 if let Def::Trait(_) = path.def {\n                     let principal = hir::PolyTraitRef {\n                         bound_generic_params: hir::HirVec::new(),\n@@ -4638,12 +4638,12 @@ impl<'a> LoweringContext<'a> {\n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n                     id = self.next_id();\n-                    hir::TyTraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n+                    hir::TyKind::TraitObject(hir_vec![principal], self.elided_dyn_bound(span))\n                 } else {\n-                    hir::TyPath(hir::QPath::Resolved(None, path))\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, path))\n                 }\n             }\n-            _ => hir::TyPath(qpath),\n+            _ => hir::TyKind::Path(qpath),\n         };\n         hir::Ty {\n             id: id.node_id,"}, {"sha": "3397c7b8432a9747a1e873c565eabf014f667ce8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -33,6 +33,7 @@ use hir::svh::Svh;\n use util::nodemap::FxHashMap;\n \n use std::io;\n+use std::result::Result::Err;\n use ty::TyCtxt;\n \n pub mod blocks;"}, {"sha": "edacada9be4d46b606f0f68fb0e46e8a9a687568", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -17,7 +17,6 @@ pub use self::ForeignItem_::*;\n pub use self::Item_::*;\n pub use self::Mutability::*;\n pub use self::PrimTy::*;\n-pub use self::Ty_::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n \n@@ -439,7 +438,7 @@ impl GenericArgs {\n                 match arg {\n                     GenericArg::Lifetime(_) => {}\n                     GenericArg::Type(ref ty) => {\n-                        if let TyTup(ref tys) = ty.node {\n+                        if let TyKind::Tup(ref tys) = ty.node {\n                             return tys;\n                         }\n                         break;\n@@ -1448,7 +1447,7 @@ pub enum QPath {\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n     /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n-    /// the `X` and `Y` nodes each being a `TyPath(QPath::TypeRelative(..))`.\n+    /// the `X` and `Y` nodes each being a `TyKind::Path(QPath::TypeRelative(..))`.\n     TypeRelative(P<Ty>, P<PathSegment>)\n }\n \n@@ -1638,7 +1637,7 @@ pub struct TypeBinding {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub id: NodeId,\n-    pub node: Ty_,\n+    pub node: TyKind,\n     pub span: Span,\n     pub hir_id: HirId,\n }\n@@ -1679,36 +1678,36 @@ pub struct ExistTy {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n /// The different kinds of types recognized by the compiler\n-pub enum Ty_ {\n+pub enum TyKind {\n     /// A variable length slice (`[T]`)\n-    TySlice(P<Ty>),\n+    Slice(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n-    TyArray(P<Ty>, AnonConst),\n+    Array(P<Ty>, AnonConst),\n     /// A raw pointer (`*const T` or `*mut T`)\n-    TyPtr(MutTy),\n+    Ptr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n-    TyRptr(Lifetime, MutTy),\n+    Rptr(Lifetime, MutTy),\n     /// A bare function (e.g. `fn(usize) -> bool`)\n-    TyBareFn(P<BareFnTy>),\n+    BareFn(P<BareFnTy>),\n     /// The never type (`!`)\n-    TyNever,\n+    Never,\n     /// A tuple (`(A, B, C, D,...)`)\n-    TyTup(HirVec<Ty>),\n+    Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n     /// associated type, e.g. `<Vec<T> as Trait>::Type` or `<T>::Target`.\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n-    TyPath(QPath),\n+    Path(QPath),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n+    TraitObject(HirVec<PolyTraitRef>, Lifetime),\n     /// Unused for now\n-    TyTypeof(AnonConst),\n-    /// TyInfer means the type should be inferred instead of it having been\n+    Typeof(AnonConst),\n+    /// TyKind::Infer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n-    TyInfer,\n+    Infer,\n     /// Placeholder for a type that has failed to be defined.\n-    TyErr,\n+    Err,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "5c1378fd9414f0cd85a649301c3ebd7dd26b5af1", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -367,43 +367,43 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ty.span.lo())?;\n         self.ibox(0)?;\n         match ty.node {\n-            hir::TySlice(ref ty) => {\n+            hir::TyKind::Slice(ref ty) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n                 self.s.word(\"]\")?;\n             }\n-            hir::TyPtr(ref mt) => {\n+            hir::TyKind::Ptr(ref mt) => {\n                 self.s.word(\"*\")?;\n                 match mt.mutbl {\n                     hir::MutMutable => self.word_nbsp(\"mut\")?,\n                     hir::MutImmutable => self.word_nbsp(\"const\")?,\n                 }\n                 self.print_type(&mt.ty)?;\n             }\n-            hir::TyRptr(ref lifetime, ref mt) => {\n+            hir::TyKind::Rptr(ref lifetime, ref mt) => {\n                 self.s.word(\"&\")?;\n                 self.print_opt_lifetime(lifetime)?;\n                 self.print_mt(mt)?;\n             }\n-            hir::TyNever => {\n+            hir::TyKind::Never => {\n                 self.s.word(\"!\")?;\n             },\n-            hir::TyTup(ref elts) => {\n+            hir::TyKind::Tup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty))?;\n                 if elts.len() == 1 {\n                     self.s.word(\",\")?;\n                 }\n                 self.pclose()?;\n             }\n-            hir::TyBareFn(ref f) => {\n+            hir::TyKind::BareFn(ref f) => {\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &f.generic_params,\n                                  &f.arg_names[..])?;\n             }\n-            hir::TyPath(ref qpath) => {\n+            hir::TyKind::Path(ref qpath) => {\n                 self.print_qpath(qpath, false)?\n             }\n-            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+            hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 let mut first = true;\n                 for bound in bounds {\n                     if first {\n@@ -420,22 +420,22 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime)?;\n                 }\n             }\n-            hir::TyArray(ref ty, ref length) => {\n+            hir::TyKind::Array(ref ty, ref length) => {\n                 self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n                 self.s.word(\"; \")?;\n                 self.print_anon_const(length)?;\n                 self.s.word(\"]\")?;\n             }\n-            hir::TyTypeof(ref e) => {\n+            hir::TyKind::Typeof(ref e) => {\n                 self.s.word(\"typeof(\")?;\n                 self.print_anon_const(e)?;\n                 self.s.word(\")\")?;\n             }\n-            hir::TyInfer => {\n+            hir::TyKind::Infer => {\n                 self.s.word(\"_\")?;\n             }\n-            hir::TyErr => {\n+            hir::TyKind::Err => {\n                 self.s.word(\"?\")?;\n             }\n         }\n@@ -2035,7 +2035,7 @@ impl<'a> State<'a> {\n             s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n             i += 1;\n \n-            if let hir::TyInfer = ty.node {\n+            if let hir::TyKind::Infer = ty.node {\n                 // Print nothing\n             } else {\n                 s.s.word(\":\")?;"}, {"sha": "d8f7e09f6b4f3e9fdc7286ce974bac4002fb8d02", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -330,19 +330,19 @@ impl_stable_hash_for!(struct hir::ExistTy {\n     bounds\n });\n \n-impl_stable_hash_for!(enum hir::Ty_ {\n-    TySlice(t),\n-    TyArray(t, body_id),\n-    TyPtr(t),\n-    TyRptr(lifetime, t),\n-    TyBareFn(t),\n-    TyNever,\n-    TyTup(ts),\n-    TyPath(qpath),\n-    TyTraitObject(trait_refs, lifetime),\n-    TyTypeof(body_id),\n-    TyErr,\n-    TyInfer\n+impl_stable_hash_for!(enum hir::TyKind {\n+    Slice(t),\n+    Array(t, body_id),\n+    Ptr(t),\n+    Rptr(lifetime, t),\n+    BareFn(t),\n+    Never,\n+    Tup(ts),\n+    Path(qpath),\n+    TraitObject(trait_refs, lifetime),\n+    Typeof(body_id),\n+    Err,\n+    Infer\n });\n \n impl_stable_hash_for!(struct hir::FnDecl {"}, {"sha": "022d4fb8d1e7e29bdcf385d7ed77ea9c349a5d25", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -109,20 +109,20 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n         match arg.node {\n-            hir::TyBareFn(_) => {\n+            hir::TyKind::BareFn(_) => {\n                 self.current_index.shift_in(1);\n                 intravisit::walk_ty(self, arg);\n                 self.current_index.shift_out(1);\n                 return;\n             }\n \n-            hir::TyTraitObject(ref bounds, _) => for bound in bounds {\n+            hir::TyKind::TraitObject(ref bounds, _) => for bound in bounds {\n                 self.current_index.shift_in(1);\n                 self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 self.current_index.shift_out(1);\n             },\n \n-            hir::TyRptr(ref lifetime, _) => {\n+            hir::TyKind::Rptr(ref lifetime, _) => {\n                 // the lifetime of the TyRptr\n                 let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n                 match (self.tcx.named_region(hir_id), self.bound_region) {\n@@ -190,8 +190,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            // Checks if it is of type `hir::TyPath` which corresponds to a struct.\n-            hir::TyPath(_) => {\n+            // Checks if it is of type `hir::TyKind::Path` which corresponds to a struct.\n+            hir::TyKind::Path(_) => {\n                 let subvisitor = &mut TyPathVisitor {\n                     tcx: self.tcx,\n                     found_it: false,\n@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n }\n \n // The visitor captures the corresponding `hir::Ty` of the anonymous region\n-// in the case of structs ie. `hir::TyPath`.\n+// in the case of structs ie. `hir::TyKind::Path`.\n // This visitor would be invoked for each lifetime corresponding to a struct,\n // and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n // where that lifetime appears. This allows us to highlight the"}, {"sha": "cec5197acc8ef70b4a9a8b576af087acb0f4823a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -567,7 +567,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.id, ty);\n         match ty.node {\n-            hir::TyBareFn(ref c) => {\n+            hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 });\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n-            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+            hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n@@ -617,15 +617,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::TyRptr(ref lifetime_ref, ref mt) => {\n+            hir::TyKind::Rptr(ref lifetime_ref, ref mt) => {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n                     s: self.scope,\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n-            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+            hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                 if let Def::Existential(exist_ty_did) = path.def {\n                     assert!(exist_ty_did.is_local());\n                     // Resolve the lifetimes that are applied to the existential type.\n@@ -1287,7 +1287,7 @@ fn object_lifetime_defaults_for_item(\n                 }\n \n                 let def = match data.bounded_ty.node {\n-                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.def,\n                     _ => continue,\n                 };\n \n@@ -1912,7 +1912,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // Can't always rely on literal (or implied) `Self` due\n                 // to the way elision rules were originally specified.\n                 let impl_self = impl_self.map(|ty| &ty.node);\n-                if let Some(&hir::TyPath(hir::QPath::Resolved(None, ref path))) = impl_self {\n+                if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) = impl_self {\n                     match path.def {\n                         // Whitelist the types that unambiguously always\n                         // result in the same type constructor being used\n@@ -1927,8 +1927,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 false\n             };\n \n-            if let hir::TyRptr(lifetime_ref, ref mt) = inputs[0].node {\n-                if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n+            if let hir::TyKind::Rptr(lifetime_ref, ref mt) = inputs[0].node {\n+                if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n                     if is_self_ty(path.def) {\n                         if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n                             let scope = Scope::Elision {\n@@ -2007,10 +2007,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_ty(&mut self, ty: &hir::Ty) {\n-                if let hir::TyBareFn(_) = ty.node {\n+                if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_in(1);\n                 }\n-                if let hir::TyTraitObject(ref bounds, ref lifetime) = ty.node {\n+                if let hir::TyKind::TraitObject(ref bounds, ref lifetime) = ty.node {\n                     for bound in bounds {\n                         self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                     }\n@@ -2023,7 +2023,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 } else {\n                     intravisit::walk_ty(self, ty);\n                 }\n-                if let hir::TyBareFn(_) = ty.node {\n+                if let hir::TyKind::BareFn(_) = ty.node {\n                     self.outer_index.shift_out(1);\n                 }\n             }\n@@ -2578,14 +2578,14 @@ fn insert_late_bound_lifetimes(\n \n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n             match ty.node {\n-                hir::TyPath(hir::QPath::Resolved(Some(_), _))\n-                | hir::TyPath(hir::QPath::TypeRelative(..)) => {\n+                hir::TyKind::Path(hir::QPath::Resolved(Some(_), _))\n+                | hir::TyKind::Path(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type\n                     // projections, as they are not *constrained*\n                     // (defined above)\n                 }\n \n-                hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently\n                     // valid to have them elsewhere, but even if it"}, {"sha": "9fd2748e5ead40d59732e9a0a9e47010ff5cffee", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -970,7 +970,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }) => {\n                 (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n                         .map(|arg| match arg.clone().node {\n-                    hir::TyTup(ref tys) => ArgKind::Tuple(\n+                    hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n                         tys.iter()\n                             .map(|_| (\"_\".to_owned(), \"_\".to_owned()))"}, {"sha": "3ae1e5aac507611938bc57855c1d5f18200720db", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -1131,7 +1131,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn suggest_mut_for_immutable(&self, pty: &hir::Ty, is_implicit_self: bool) -> Option<String> {\n         // Check whether the argument is an immutable reference\n         debug!(\"suggest_mut_for_immutable({:?}, {:?})\", pty, is_implicit_self);\n-        if let hir::TyRptr(lifetime, hir::MutTy {\n+        if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n             mutbl: hir::Mutability::MutImmutable,\n             ref ty\n         }) = pty.node {\n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     // avoid suggesting `mut &self`.\n                     return\n                 }\n-                if let Some(&hir::TyRptr(\n+                if let Some(&hir::TyKind::Rptr(\n                     _,\n                     hir::MutTy {\n                         mutbl: hir::MutMutable,"}, {"sha": "0ebb1a2bca82eb08f31b25a933aae4c15eeac24b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -1475,7 +1475,7 @@ impl TypeAliasBounds {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n                 match ty.node {\n-                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                         match path.def {\n                             Def::TyParam(_) => true,\n                             _ => false"}, {"sha": "7721fa00f1a2f1eb84bfca138713de7c13409db1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -1678,7 +1678,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n-            hir::TyArray(_, ref length) => {\n+            hir::TyKind::Array(_, ref length) => {\n                 let def_id = self.tcx.hir.local_def_id(length.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_const, def_id);\n             }"}, {"sha": "b8c50e8852990922ba2792e1e3030f169798b5cf", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -201,7 +201,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // This indicates a variable with no type annotation, like\n             // `|x|`... in that case, we can't highlight the type but\n             // must highlight the variable.\n-            hir::TyInfer => None,\n+            hir::TyKind::Infer => None,\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n                 tcx,\n@@ -263,7 +263,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 //\n                 //     &\n                 //     - let's call the lifetime of this reference `'1`\n-                (ty::TyRef(region, referent_ty, _), hir::TyRptr(_lifetime, referent_hir_ty)) => {\n+                (ty::TyRef(region, referent_ty, _), hir::TyKind::Rptr(_lifetime, referent_hir_ty)) => {\n                     if region.to_region_vid() == needle_fr {\n                         let region_name = self.synthesize_region_name(counter);\n \n@@ -287,7 +287,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n \n                 // Match up something like `Foo<'1>`\n-                (ty::TyAdt(_adt_def, substs), hir::TyPath(hir::QPath::Resolved(None, path))) => {\n+                (ty::TyAdt(_adt_def, substs), hir::TyKind::Path(hir::QPath::Resolved(None, path))) => {\n                     if let Some(last_segment) = path.segments.last() {\n                         if let Some(name) = self.match_adt_and_segment(\n                             substs,\n@@ -305,16 +305,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // The following cases don't have lifetimes, so we\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n-                (ty::TyTuple(elem_tys), hir::TyTup(elem_hir_tys)) => {\n+                (ty::TyTuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n                     search_stack.extend(elem_tys.iter().cloned().zip(elem_hir_tys));\n                 }\n \n-                (ty::TySlice(elem_ty), hir::TySlice(elem_hir_ty))\n-                | (ty::TyArray(elem_ty, _), hir::TyArray(elem_hir_ty, _)) => {\n+                (ty::TySlice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n+                | (ty::TyArray(elem_ty, _), hir::TyKind::Array(elem_hir_ty, _)) => {\n                     search_stack.push((elem_ty, elem_hir_ty));\n                 }\n \n-                (ty::TyRawPtr(mut_ty), hir::TyPtr(mut_hir_ty)) => {\n+                (ty::TyRawPtr(mut_ty), hir::TyKind::Ptr(mut_hir_ty)) => {\n                     search_stack.push((mut_ty.ty, &mut_hir_ty.ty));\n                 }\n "}, {"sha": "cd1bc4b449032ee6f9c41a1b8712a472c0c625a5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -1052,15 +1052,15 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     }\n \n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = ty.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.node {\n             if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n                 // found what we're looking for so let's stop\n                 // working.\n                 return\n             }\n         }\n-        if let hir::TyPath(_) = ty.node {\n+        if let hir::TyKind::Path(_) = ty.node {\n             if self.at_outer_type {\n                 self.outer_type_is_public_path = true;\n             }\n@@ -1293,7 +1293,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = t.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.node {\n             if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.id);\n             }"}, {"sha": "7355ae4a7c840db9a3b8b9c741affce13527e059", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -666,7 +666,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }) => HirDef::Local(canonical_id),\n \n             Node::NodeTy(ty) => if let hir::Ty {\n-                node: hir::TyPath(ref qpath),\n+                node: hir::TyKind::Path(ref qpath),\n                 ..\n             } = *ty\n             {"}, {"sha": "f85e7b0685889f35a8bf19dbf6ff569ad6577211", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -1117,75 +1117,75 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         let result_ty = match ast_ty.node {\n-            hir::TySlice(ref ty) => {\n+            hir::TyKind::Slice(ref ty) => {\n                 tcx.mk_slice(self.ast_ty_to_ty(&ty))\n             }\n-            hir::TyPtr(ref mt) => {\n+            hir::TyKind::Ptr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut {\n                     ty: self.ast_ty_to_ty(&mt.ty),\n                     mutbl: mt.mutbl\n                 })\n             }\n-            hir::TyRptr(ref region, ref mt) => {\n+            hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(\"TyRef r={:?}\", r);\n                 let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n-            hir::TyNever => {\n+            hir::TyKind::Never => {\n                 tcx.types.never\n             },\n-            hir::TyTup(ref fields) => {\n+            hir::TyKind::Tup(ref fields) => {\n                 tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)))\n             }\n-            hir::TyBareFn(ref bf) => {\n+            hir::TyKind::BareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n                 tcx.mk_fn_ptr(self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl))\n             }\n-            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+            hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n+            hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                     self.ast_ty_to_ty(qself)\n                 });\n                 self.def_to_ty(opt_self_ty, path, false)\n             }\n-            hir::TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+            hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n                 let ty = self.ast_ty_to_ty(qself);\n \n-                let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                let def = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n                 } else {\n                     Def::Err\n                 };\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n-            hir::TyArray(ref ty, ref length) => {\n+            hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir.local_def_id(length.id);\n                 let substs = Substs::identity_for_item(tcx, length_def_id);\n                 let length = ty::Const::unevaluated(tcx, length_def_id, substs, tcx.types.usize);\n                 let array_ty = tcx.mk_ty(ty::TyArray(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n-            hir::TyTypeof(ref _e) => {\n+            hir::TyKind::Typeof(ref _e) => {\n                 struct_span_err!(tcx.sess, ast_ty.span, E0516,\n                                  \"`typeof` is a reserved keyword but unimplemented\")\n                     .span_label(ast_ty.span, \"reserved keyword\")\n                     .emit();\n \n                 tcx.types.err\n             }\n-            hir::TyInfer => {\n+            hir::TyKind::Infer => {\n                 // TyInfer also appears as the type of arguments or return\n                 // values in a ExprKind::Closure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(ast_ty.span)\n             }\n-            hir::TyErr => {\n+            hir::TyKind::Err => {\n                 tcx.types.err\n             }\n         };\n@@ -1241,7 +1241,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                      -> Ty<'tcx>\n     {\n         match ty.node {\n-            hir::TyInfer if expected_ty.is_some() => {\n+            hir::TyKind::Infer if expected_ty.is_some() => {\n                 self.record_ty(ty.hir_id, expected_ty.unwrap(), ty.span);\n                 expected_ty.unwrap()\n             }"}, {"sha": "220dd122b26795b6c7516fb11c3e8a71f800b070", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -429,8 +429,8 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n \n                 impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n                     match (&impl_arg.node, &trait_arg.node) {\n-                        (&hir::TyRptr(_, ref impl_mt), &hir::TyRptr(_, ref trait_mt)) |\n-                        (&hir::TyPtr(ref impl_mt), &hir::TyPtr(ref trait_mt)) => {\n+                        (&hir::TyKind::Rptr(_, ref impl_mt), &hir::TyKind::Rptr(_, ref trait_mt)) |\n+                        (&hir::TyKind::Ptr(ref impl_mt), &hir::TyKind::Ptr(ref trait_mt)) => {\n                             impl_mt.mutbl != trait_mt.mutbl\n                         }\n                         _ => false,\n@@ -822,7 +822,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             fn visit_ty(&mut self, ty: &'v hir::Ty) {\n                                 hir::intravisit::walk_ty(self, ty);\n                                 match ty.node {\n-                                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n+                                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                                         if let hir::def::Def::TyParam(def_id) = path.def {\n                                             if def_id == self.1 {\n                                                 self.0 = Some(ty.span);"}, {"sha": "6cbe1f42accee79a55edd773b59c3212de1bd3bd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -4265,7 +4265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                let def = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n                 } else {\n                     Def::Err"}, {"sha": "a8cf09154463e25724d780bbe27c3ddbfb5b77e6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -346,7 +346,7 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       param_id: ast::NodeId)\n                       -> bool\n {\n-    if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n+    if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.def {\n             Def::SelfTy(Some(def_id), None) |\n             Def::TyParam(def_id) => {\n@@ -701,7 +701,7 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n             if self.has_late_bound_regions.is_some() { return }\n             match ty.node {\n-                hir::TyBareFn(..) => {\n+                hir::TyKind::BareFn(..) => {\n                     self.outer_index.shift_in(1);\n                     intravisit::walk_ty(self, ty);\n                     self.outer_index.shift_out(1);\n@@ -1118,8 +1118,8 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         NodeAnonConst(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n-            NodeTy(&hir::Ty { node: TyArray(_, ref constant), .. }) |\n-            NodeTy(&hir::Ty { node: TyTypeof(ref constant), .. }) |\n+            NodeTy(&hir::Ty { node: hir::TyKind::Array(_, ref constant), .. }) |\n+            NodeTy(&hir::Ty { node: hir::TyKind::Typeof(ref constant), .. }) |\n             NodeExpr(&hir::Expr { node: ExprKind::Repeat(_, ref constant), .. })\n                 if constant.id == node_id => tcx.types.usize,\n "}, {"sha": "cbb8b3e396211e14847c0dbef629a07cd88f4f3f", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n             let ty = hir::Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: hir::Ty_::TyPath(hir::QPath::Resolved(None, P(new_path))),\n+                node: hir::TyKind::TyPath(hir::QPath::Resolved(None, P(new_path))),\n                 span: DUMMY_SP,\n                 hir_id: hir::DUMMY_HIR_ID,\n             };\n@@ -279,7 +279,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n         hir::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            node: hir::Ty_::TyPath(hir::QPath::Resolved(\n+            node: hir::TyKind::TyPath(hir::QPath::Resolved(\n                 None,\n                 P(hir::Path {\n                     span: DUMMY_SP,"}, {"sha": "a8980cbd5c89ac3a157f121d22ebbe29083571bb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f12eca47e09dc0aa7420e51c090a22cd72f44159/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f12eca47e09dc0aa7420e51c090a22cd72f44159", "patch": "@@ -2586,7 +2586,7 @@ pub struct PolyTrait {\n /// it does not preserve mutability or boxes.\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum Type {\n-    /// structs/enums/traits (most that'd be an hir::TyPath)\n+    /// structs/enums/traits (most that'd be an hir::TyKind::Path)\n     ResolvedPath {\n         path: Path,\n         typarams: Option<Vec<GenericBound>>,"}]}