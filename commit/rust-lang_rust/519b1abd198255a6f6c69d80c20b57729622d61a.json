{"sha": "519b1abd198255a6f6c69d80c20b57729622d61a", "node_id": "C_kwDOAAsO6NoAKDUxOWIxYWJkMTk4MjU1YTZmNmM2OWQ4MGMyMGI1NzcyOTYyMmQ2MWE", "commit": {"author": {"name": "mejrs", "email": "", "date": "2022-12-19T23:28:33Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2023-01-11T22:39:27Z"}, "message": "Translate const_to_pat.rs", "tree": {"sha": "d37b7ad576ebbd7329b3f2a97a81189c95929491", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d37b7ad576ebbd7329b3f2a97a81189c95929491"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/519b1abd198255a6f6c69d80c20b57729622d61a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmO/Op8ACgkQ+boUO5X/\nbYKQXQ//UxD9Vl2D8QG2pjwLjKH7qdALTNOuRoLpIjovSr8lC2ETm75/TJb1Wmq2\nvfNQiUVHumZa3YZGF7BtmT9uLEQz8w3lxvUppYYeghxD8ijGCdVJ3b+ZTjGJGQiN\no4gG9CSQz9DYujG6/Lxwrou9C4ri429J0M4pvBJYDpmAm9zrAm77lVWK6KnVCVzB\nDSC0JST4rvZKaFqaafCjOqX93wGkOA4/PPvTo5DQn7u3gJuXGuGllZErYViJwMEb\nMIw1syEf6LSXf5u0RpdgVeJcUh2H+MTyow+VOM6SSbogFf+VxuuscDHEtYlG5j6V\nyWp9CNgHI9hh3MBJimx/nZ4GFl4FMuvhEKVv29zprchRW6YFJoVXFtooLGKM57C8\n8KI9TIy0gzvSZv/PH4L3azv2D3w2MXZw5w5d87iqiVeY+qiDP909ABR8oLARRf/b\nF/ZcWUmvIAIJKn/TsZPT32zDrgqwoMZisrmjFVzTsTSRcnYCwaU7jBK8GRHFk5w2\nTKDn9Mnodgpptt+eaheJI31D3FcKhjE/Ilo6Mr4nTr/jfrR9yjhqPBQSPhP5Ekx8\nBeZwBoUiWUr9+alehaRZaJX5lLRRo3ntXRcYfndxvFgPcp+TJKRUGzbCT8hzUeKE\n4JvUichjR+Eff/pV/nGJWldGp0vUG5evcdoHjVzUAeUN6QmQhyM=\n=SBxm\n-----END PGP SIGNATURE-----", "payload": "tree d37b7ad576ebbd7329b3f2a97a81189c95929491\nparent ef4046e4f3932991971cdb64915172899532aece\nauthor mejrs <> 1671492513 +0100\ncommitter David Tolnay <dtolnay@gmail.com> 1673476767 -0800\n\nTranslate const_to_pat.rs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/519b1abd198255a6f6c69d80c20b57729622d61a", "html_url": "https://github.com/rust-lang/rust/commit/519b1abd198255a6f6c69d80c20b57729622d61a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/519b1abd198255a6f6c69d80c20b57729622d61a/comments", "author": {}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef4046e4f3932991971cdb64915172899532aece", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4046e4f3932991971cdb64915172899532aece", "html_url": "https://github.com/rust-lang/rust/commit/ef4046e4f3932991971cdb64915172899532aece"}], "stats": {"total": 260, "additions": 122, "deletions": 138}, "files": [{"sha": "4faaffce7bb353423809ce13cca733df19b16047", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/519b1abd198255a6f6c69d80c20b57729622d61a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/519b1abd198255a6f6c69d80c20b57729622d61a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=519b1abd198255a6f6c69d80c20b57729622d61a", "patch": "@@ -299,3 +299,22 @@ mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once a\n     .mutable_borrow = another mutable borrow, by `{$name_mut}`, occurs here\n     .immutable_borrow = also borrowed as immutable, by `{$name_immut}`, here\n     .moved = also moved into `{$name_moved}` here\n+\n+mir_build_union_pattern = cannot use unions in constant patterns\n+\n+mir_build_type_not_structural =\n+     to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_unsized_pattern = cannot use unsized non-slice type `{$non_sm_ty}` in constant patterns\n+\n+mir_build_invalid_pattern = `{$non_sm_ty}` cannot be used in patterns\n+\n+mir_build_float_pattern = floating-point types cannot be used in patterns\n+\n+mir_build_pointer_pattern = function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+\n+mir_build_indirect_structural_match = \n+    to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_nontrivial_structural_match = \n+    to use a constant of type `{$non_sm_ty}` in a pattern, the constant's initializer must be trivial or `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n\\ No newline at end of file"}, {"sha": "840a1faf95a264dbcd63a09ec480b2d040280f9c", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/519b1abd198255a6f6c69d80c20b57729622d61a/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b1abd198255a6f6c69d80c20b57729622d61a/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=519b1abd198255a6f6c69d80c20b57729622d61a", "patch": "@@ -614,3 +614,54 @@ pub enum MultipleMutBorrowOccurence {\n         name_moved: Ident,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_union_pattern)]\n+pub struct UnionPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_type_not_structural)]\n+pub struct TypeNotStructural<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_invalid_pattern)]\n+pub struct InvalidPattern<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_unsized_pattern)]\n+pub struct UnsizedPattern<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_float_pattern)]\n+pub struct FloatPattern;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_pointer_pattern)]\n+pub struct PointerPattern;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_indirect_structural_match)]\n+pub struct IndirectStructuralMatch<'tcx> {\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_nontrivial_structural_match)]\n+pub struct NontrivialStructuralMatch<'tcx> {\n+    pub non_sm_ty: Ty<'tcx>,\n+}"}, {"sha": "8e7ca32feb346e940ec43ab0f40b3b403b141219", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 52, "deletions": 138, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/519b1abd198255a6f6c69d80c20b57729622d61a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b1abd198255a6f6c69d80c20b57729622d61a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=519b1abd198255a6f6c69d80c20b57729622d61a", "patch": "@@ -1,11 +1,9 @@\n-use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::Span;\n use rustc_trait_selection::traits::predicate_for_trait_def;\n@@ -15,6 +13,10 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n use std::cell::Cell;\n \n use super::PatCtxt;\n+use crate::errors::{\n+    FloatPattern, IndirectStructuralMatch, InvalidPattern, NontrivialStructuralMatch,\n+    PointerPattern, TypeNotStructural, UnionPattern, UnsizedPattern,\n+};\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible).\n@@ -105,47 +107,6 @@ impl<'tcx> ConstToPat<'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn adt_derive_msg(&self, adt_def: AdtDef<'tcx>) -> String {\n-        let path = self.tcx().def_path_str(adt_def.did());\n-        format!(\n-            \"to use a constant of type `{}` in a pattern, \\\n-            `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-            path, path,\n-        )\n-    }\n-\n-    fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n-            with_no_trimmed_paths!(match non_sm_ty.kind() {\n-                ty::Adt(adt, _) => self.adt_derive_msg(*adt),\n-                ty::Dynamic(..) => {\n-                    \"trait objects cannot be used in patterns\".to_string()\n-                }\n-                ty::Alias(ty::Opaque, ..) => {\n-                    \"opaque types cannot be used in patterns\".to_string()\n-                }\n-                ty::Closure(..) => {\n-                    \"closures cannot be used in patterns\".to_string()\n-                }\n-                ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                    \"generators cannot be used in patterns\".to_string()\n-                }\n-                ty::Float(..) => {\n-                    \"floating-point numbers cannot be used in patterns\".to_string()\n-                }\n-                ty::FnPtr(..) => {\n-                    \"function pointers cannot be used in patterns\".to_string()\n-                }\n-                ty::RawPtr(..) => {\n-                    \"raw pointers cannot be used in patterns\".to_string()\n-                }\n-                _ => {\n-                    bug!(\"use of a value of `{non_sm_ty}` inside a pattern\")\n-                }\n-            })\n-        })\n-    }\n-\n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n@@ -176,7 +137,8 @@ impl<'tcx> ConstToPat<'tcx> {\n             // If we were able to successfully convert the const to some pat,\n             // double-check that all types in the const implement `Structural`.\n \n-            let structural = self.search_for_structural_match_violation(cv.ty());\n+            let structural =\n+                traits::search_for_structural_match_violation(self.span, self.tcx(), cv.ty());\n             debug!(\n                 \"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n                 cv.ty(),\n@@ -194,17 +156,18 @@ impl<'tcx> ConstToPat<'tcx> {\n                 return inlined_const_as_pat;\n             }\n \n-            if let Some(msg) = structural {\n+            if let Some(non_sm_ty) = structural {\n                 if !self.type_may_have_partial_eq_impl(cv.ty()) {\n-                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx().sess.span_fatal(self.span, &msg);\n+                    // fatal avoids ICE from resolution of non-existent method (rare case).\n+                    self.tcx()\n+                        .sess\n+                        .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty: non_sm_ty });\n                 } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n-                    self.tcx().struct_span_lint_hir(\n+                    self.tcx().emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n-                        msg,\n-                        |lint| lint,\n+                        IndirectStructuralMatch { non_sm_ty },\n                     );\n                 } else {\n                     debug!(\n@@ -278,42 +241,34 @@ impl<'tcx> ConstToPat<'tcx> {\n         let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n                 if self.include_lint_checks {\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                         id,\n                         span,\n-                        \"floating-point types cannot be used in patterns\",\n-                        |lint| lint,\n+                        FloatPattern,\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.saw_const_match_error.set(true);\n-                let msg = \"cannot use unions in constant patterns\";\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, msg);\n-                }\n+                let err = UnionPattern { span };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             ty::Adt(..)\n                 if !self.type_may_have_partial_eq_impl(cv.ty())\n                     // FIXME(#73448): Find a way to bring const qualification into parity with\n                     // `search_for_structural_match_violation` and then remove this condition.\n-                    && self.search_for_structural_match_violation(cv.ty()).is_some() =>\n+\n+                    // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n+                    // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n+                    && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty()) =>\n             {\n-                // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n-                // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-                let msg = self.search_for_structural_match_violation(cv.ty()).unwrap();\n                 self.saw_const_match_error.set(true);\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(self.span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(self.span, &msg);\n-                }\n+                let err = TypeNotStructural { span, non_sm_ty };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             // If the type is not structurally comparable, just emit the constant directly,\n@@ -331,19 +286,11 @@ impl<'tcx> ConstToPat<'tcx> {\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        DelayDm(|| {\n-                            format!(\n-                                \"to use a constant of type `{}` in a pattern, \\\n-                                 `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                cv.ty(),\n-                                cv.ty(),\n-                            )\n-                        }),\n-                        |lint| lint,\n+                        IndirectStructuralMatch { non_sm_ty: cv.ty() },\n                     );\n                 }\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n@@ -357,18 +304,9 @@ impl<'tcx> ConstToPat<'tcx> {\n                     adt_def,\n                     cv.ty()\n                 );\n-                let path = tcx.def_path_str(adt_def.did());\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path, path,\n-                );\n                 self.saw_const_match_error.set(true);\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, &msg);\n-                }\n+                let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n@@ -401,12 +339,8 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // These are not allowed and will error elsewhere anyway.\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n-                    let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n-                    if self.include_lint_checks {\n-                        tcx.sess.span_err(span, &msg);\n-                    } else {\n-                        tcx.sess.delay_span_bug(span, &msg);\n-                    }\n+                    let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                     PatKind::Wild\n                 }\n                 // `&str` is represented as `ConstValue::Slice`, let's keep using this\n@@ -471,32 +405,26 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // this pattern to a `PartialEq::eq` comparison and `PartialEq::eq` takes a\n                 // reference. This makes the rest of the matching logic simpler as it doesn't have\n                 // to figure out how to get a reference again.\n-                ty::Adt(adt_def, _) if !self.type_marked_structural(*pointee_ty) => {\n+                ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n                         if self.include_lint_checks\n                             && !self.saw_const_match_error.get()\n                             && !self.saw_const_match_lint.get()\n                         {\n-                            self.saw_const_match_lint.set(true);\n-                            let msg = self.adt_derive_msg(adt_def);\n-                            self.tcx().struct_span_lint_hir(\n+                           self.saw_const_match_lint.set(true);\n+                           tcx.emit_spanned_lint(\n                                 lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                                 self.id,\n-                                self.span,\n-                                msg,\n-                                |lint| lint,\n+                                span,\n+                                IndirectStructuralMatch { non_sm_ty: *pointee_ty },\n                             );\n                         }\n                         PatKind::Constant { value: cv }\n                     } else {\n                         if !self.saw_const_match_error.get() {\n                             self.saw_const_match_error.set(true);\n-                            let msg = self.adt_derive_msg(adt_def);\n-                            if self.include_lint_checks {\n-                                tcx.sess.span_err(span, &msg);\n-                            } else {\n-                                tcx.sess.delay_span_bug(span, &msg);\n-                            }\n+                            let err = TypeNotStructural { span, non_sm_ty: *pointee_ty };\n+                            tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                         }\n                         PatKind::Wild\n                     }\n@@ -507,13 +435,11 @@ impl<'tcx> ConstToPat<'tcx> {\n                 _ => {\n                     if !pointee_ty.is_sized(tcx, param_env) {\n                         // `tcx.deref_mir_constant()` below will ICE with an unsized type\n-                        // (except slices, which are handled in a separate arm above).\n-                        let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n-                        if self.include_lint_checks {\n-                            tcx.sess.span_err(span, &msg);\n-                        } else {\n-                            tcx.sess.delay_span_bug(span, &msg);\n-                        }\n+                        // (except slices, which are handled in a separate arm above).                        \n+\n+                        let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n+                        tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n@@ -545,27 +471,19 @@ impl<'tcx> ConstToPat<'tcx> {\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n-                    let msg = \"function pointers and unsized pointers in patterns behave \\\n-                        unpredictably and should not be relied upon. \\\n-                        See https://github.com/rust-lang/rust/issues/70861 for details.\";\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::POINTER_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        msg,\n-                        |lint| lint,\n+                        PointerPattern\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n             }\n             _ => {\n                 self.saw_const_match_error.set(true);\n-                let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, &msg);\n-                }\n+                let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n         };\n@@ -576,21 +494,17 @@ impl<'tcx> ConstToPat<'tcx> {\n             && mir_structural_match_violation\n             // FIXME(#73448): Find a way to bring const qualification into parity with\n             // `search_for_structural_match_violation` and then remove this condition.\n-            && self.search_for_structural_match_violation(cv.ty()).is_some()\n-        {\n-            self.saw_const_match_lint.set(true);\n+\n             // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n             // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-            let msg = self.search_for_structural_match_violation(cv.ty()).unwrap().replace(\n-                \"in a pattern,\",\n-                \"in a pattern, the constant's initializer must be trivial or\",\n-            );\n-            tcx.struct_span_lint_hir(\n+            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty())\n+        {\n+            self.saw_const_match_lint.set(true);\n+            tcx.emit_spanned_lint(\n                 lint::builtin::NONTRIVIAL_STRUCTURAL_MATCH,\n                 id,\n                 span,\n-                msg,\n-                |lint| lint,\n+                NontrivialStructuralMatch {non_sm_ty}\n             );\n         }\n "}]}