{"sha": "59bdb31c890adf726aec2036c3c8170c2e3a1767", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YmRiMzFjODkwYWRmNzI2YWVjMjAzNmMzYzgxNzBjMmUzYTE3Njc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-21T09:21:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-21T09:21:59Z"}, "message": "final pin projections tweaking", "tree": {"sha": "303222e8eba7936f0a55364d07763a6729bb0f27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/303222e8eba7936f0a55364d07763a6729bb0f27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59bdb31c890adf726aec2036c3c8170c2e3a1767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59bdb31c890adf726aec2036c3c8170c2e3a1767", "html_url": "https://github.com/rust-lang/rust/commit/59bdb31c890adf726aec2036c3c8170c2e3a1767", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59bdb31c890adf726aec2036c3c8170c2e3a1767/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9ade6a577ae92d951aecd95973fefb69cdbf08a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9ade6a577ae92d951aecd95973fefb69cdbf08a", "html_url": "https://github.com/rust-lang/rust/commit/c9ade6a577ae92d951aecd95973fefb69cdbf08a"}], "stats": {"total": 50, "additions": 23, "deletions": 27}, "files": [{"sha": "bcd5c65d3815c80193f22ede79161b5a0f8a59ae", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/59bdb31c890adf726aec2036c3c8170c2e3a1767/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59bdb31c890adf726aec2036c3c8170c2e3a1767/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=59bdb31c890adf726aec2036c3c8170c2e3a1767", "patch": "@@ -177,20 +177,12 @@\n //! In a similar vein, when can a generic wrapper type (such as `Vec`, `Box`, or `RefCell`)\n //! have an operation with type `fn(Pin<&[mut] Wrapper<T>>) -> Pin<&[mut] T>`?\n //!\n-//! This question is closely related to the question of whether pinning is \"structural\".\n-//! Structural pinning means that when you have pinned a wrapper type, the contents are\n-//! also pinned. Structural pinning thus explains why pinning projections are correct. This means\n-//! that if the type should have pinning projections for some fields, pinning must be structural\n-//! for those fields.\n+//! Having a pinning projection for some field means that pinning is \"structural\":\n+//! when the wrapper is pinned, the field must be considered pinned, too.\n+//! After all, the pinning projection lets us get a `Pin<&[mut] Field>`.\n //!\n-//! In general, deciding for which fields pinning is structural (and thus for which fields\n-//! pinning projections could be offered) is entirely up to the author of any given type.\n-//! For many types, both answers are reasonable. For example, there could be a version\n-//! of `Vec` with structural pinning and `get_pin`/`get_pin_mut` projections to access\n-//! the `Vec` elements, and another version where the contents remain movable even when\n-//! the `Vec` is pinned.\n-//!\n-//! However, structural pinning comes with a few extra requirements:\n+//! However, structural pinning comes with a few extra requirements, so not all\n+//! wrappers can be structural and hence not all wrappers can offer pinning projections:\n //!\n //! 1.  The wrapper must only be [`Unpin`] if all the structural fields are\n //!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n@@ -214,8 +206,9 @@\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n //!     the fields when your type is pinned. For example, if the wrapper contains an\n-//!     `Option<T>` and there is an operation such as `fn(Pin<&mut Wrapper<T>>) -> Option<T>`,\n-//!     that operation can be used to move a `T` out of a pinned `Wrapper` -- that means\n+//!     `Option<T>` and there is a `take`-like operation with type\n+//!     `fn(Pin<&mut Wrapper<T>>) -> Option<T>`,\n+//!     that operation can be used to move a `T` out of a pinned `Wrapper` -- which means\n //!     pinning cannot be structural.\n //!\n //!     For a more complex example of moving data out of a pinnd type, imagine if `RefCell`\n@@ -233,20 +226,23 @@\n //!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n //!     reference we got later.\n //!\n-//! On the other hand, if you decide *not* to offer any pinning projections, you\n-//! do not have to do anything. If your type also does not do any pinning itself,\n-//! you are free to `impl<T> Unpin for Wrapper<T>`. In the standard library,\n-//! this is done for all pointer types: `Box<T>: Unpin` holds for all `T`.\n+//! For a type like `Vec`, both possibilites (structural pinning or not) make sense,\n+//! and the choice is up to the author. A `Vec` with structural pinning could\n+//! have `get_pin`/`get_pin_mut` projections. However, it could *not* allow calling\n+//! `pop` on a pinned `Vec` because that would move the (structurally pinned) contents!\n+//! Nor could it allow `push`, which might reallocate and thus also move the contents.\n+//! A `Vec` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n+//! are never pinned and the `Vec` itself is fine with being moved as well.\n+//!\n+//! In the standard library, pointer types generally do not have structural pinning,\n+//! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n //! It makes sense to do this for pointer types, because moving the `Box<T>`\n-//! does not actually move the `T`: the `Box<T>` can be freely movable even if the `T`\n+//! does not actually move the `T`: the `Box<T>` can be freely movable (aka `Unpin`) even if the `T`\n //! is not. In fact, even `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves,\n-//! for the same reason.\n-//!\n-//! Another case where you might want to have a wrapper without structural pinning is when even\n-//! a pinned wrapper lets its contents move, e.g. with a `take`-like operation. And, finally,\n-//! if it is not possible to satisfy the requirements for structural pinning, it makes sense\n-//! to add the `impl<T> Unpin for Wrapper<T>` to explicitly document this fact, and to let\n-//! library clients benefit from the easier interaction with [`Pin`] that [`Unpin`] types enjoy.\n+//! for the same reason: their contents (the `T`) are pinned, but the pointers themselves\n+//! can be moved without moving the pinned data. For both `Box<T>` and `Pin<Box<T>>`,\n+//! whether the content is pinned is entirely independent of whether the pointer is\n+//! pinned, meaning pinning is *not* structural.\n //!\n //! [`Pin`]: struct.Pin.html\n //! [`Unpin`]: ../../std/marker/trait.Unpin.html"}]}