{"sha": "f016b77dffb77ec04e1386811d3aec62446c619e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMTZiNzdkZmZiNzdlYzA0ZTEzODY4MTFkM2FlYzYyNDQ2YzYxOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-03T12:48:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-03T12:48:14Z"}, "message": "Auto merge of #30180 - tbu-:pr_isize_to_i32, r=arielb1\n\ns/isize/i32", "tree": {"sha": "7625357f79f672865e8d6517f5d42bb1b0c670e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7625357f79f672865e8d6517f5d42bb1b0c670e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f016b77dffb77ec04e1386811d3aec62446c619e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f016b77dffb77ec04e1386811d3aec62446c619e", "html_url": "https://github.com/rust-lang/rust/commit/f016b77dffb77ec04e1386811d3aec62446c619e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f016b77dffb77ec04e1386811d3aec62446c619e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5150dd9b42d15563e18218910cafc0d4d053250", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5150dd9b42d15563e18218910cafc0d4d053250", "html_url": "https://github.com/rust-lang/rust/commit/f5150dd9b42d15563e18218910cafc0d4d053250"}, {"sha": "57dad535f5ae7377854607857ad3e9ba0c7115d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/57dad535f5ae7377854607857ad3e9ba0c7115d0", "html_url": "https://github.com/rust-lang/rust/commit/57dad535f5ae7377854607857ad3e9ba0c7115d0"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "f6068f1b6449852d94227bfb22af402330deb901", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=f016b77dffb77ec04e1386811d3aec62446c619e", "patch": "@@ -159,8 +159,8 @@ pub enum RegionResolutionError<'tcx> {\n /// like to indicate so to the user.\n /// For example, the following function\n /// ```\n-/// struct Foo { bar: isize }\n-/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b isize {\n+/// struct Foo { bar: i32 }\n+/// fn foo2<'a, 'b>(x: &'a Foo) -> &'b i32 {\n ///    &x.bar\n /// }\n /// ```"}, {"sha": "2a8b1b83d224cde88e17e5beefc24cd4c98c5eac", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f016b77dffb77ec04e1386811d3aec62446c619e", "patch": "@@ -1583,7 +1583,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let r = self.should_warn(var);\n             if let Some(name) = r {\n \n-                // annoying: for parameters in funcs like `fn(x: isize)\n+                // annoying: for parameters in funcs like `fn(x: i32)\n                 // {ret}`, there is only one node, so asking about\n                 // assigned_on_exit() is not meaningful.\n                 let is_assigned = if ln == self.s.exit_ln {"}, {"sha": "50169ca64307b3f91f727d60618168a5d9a483b1", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=f016b77dffb77ec04e1386811d3aec62446c619e", "patch": "@@ -719,10 +719,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// For example:\n     ///\n     /// ```ignore\n-    /// let a: isize;\n+    /// let a: i32;\n     /// a = 10; // ok, even though a is uninitialized\n     ///\n-    /// struct Point { x: usize, y: usize }\n+    /// struct Point { x: u32, y: u32 }\n     /// let p: Point;\n     /// p.x = 22; // ok, even though `p` is uninitialized\n     ///"}, {"sha": "47f29a26db145d09baac303b694cbf4cdacd7f65", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f016b77dffb77ec04e1386811d3aec62446c619e", "patch": "@@ -486,9 +486,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! come about when variables of `&mut` type are re-borrowed,\n         //! as in this example:\n         //!\n-        //!     struct Foo { counter: usize }\n+        //!     struct Foo { counter: u32 }\n         //!\n-        //!     fn counter<'a>(v: &'a mut Foo) -> &'a mut usize {\n+        //!     fn counter<'a>(v: &'a mut Foo) -> &'a mut u32 {\n         //!         &mut v.counter\n         //!     }\n         //!"}, {"sha": "bcf5eb99200766c3b758e1154cb57ed705e75bcf", "filename": "src/librustc_trans/trans/debuginfo/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fdoc.rs?ref=f016b77dffb77ec04e1386811d3aec62446c619e", "patch": "@@ -66,7 +66,7 @@\n //!\n //! ```\n //! struct List {\n-//!     value: isize,\n+//!     value: i32,\n //!     tail: Option<Box<List>>,\n //! }\n //! ```\n@@ -75,7 +75,7 @@\n //!\n //! ```\n //! describe(t = List)\n-//!   describe(t = int)\n+//!   describe(t = i32)\n //!   describe(t = Option<Box<List>>)\n //!     describe(t = Box<List>)\n //!       describe(t = List) // at the beginning again...\n@@ -166,7 +166,7 @@\n //!\n //! (3) Tuple-, pointer and function types are structurally identified, which\n //!     means that they are equivalent if their component types are equivalent\n-//!     (i.e. (int, int) is the same regardless in which crate it is used).\n+//!     (i.e. (i32, i32) is the same regardless in which crate it is used).\n //!\n //! This algorithm also provides a stable ID for types that are defined in one\n //! crate but instantiated from metadata within another crate. We just have to"}, {"sha": "d514348bfe6108e7ca751b1e7d0c9ad5286b8c2e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f016b77dffb77ec04e1386811d3aec62446c619e", "patch": "@@ -182,17 +182,17 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     //         fn from<U:Foo>(n: U) -> Option<Self>;\n     //     }\n     //     ...\n-    //     let f = <Vec<int> as Convert>::from::<String>(...)\n+    //     let f = <Vec<i32> as Convert>::from::<String>(...)\n     //\n     // Here, in this call, which I've written with explicit UFCS\n     // notation, the set of type parameters will be:\n     //\n     //     rcvr_type: [] <-- nothing declared on the trait itself\n-    //     rcvr_self: [Vec<int>] <-- the self type\n+    //     rcvr_self: [Vec<i32>] <-- the self type\n     //     rcvr_method: [String] <-- method type parameter\n     //\n     // So we create a trait reference using the first two,\n-    // basically corresponding to `<Vec<int> as Convert>`.\n+    // basically corresponding to `<Vec<i32> as Convert>`.\n     // The remaining type parameters (`rcvr_method`) will be used below.\n     let trait_substs =\n         Substs::erased(VecPerParamSpace::new(rcvr_type,\n@@ -223,13 +223,13 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             //        fn from<U:Foo>(n: U) { ... }\n             //    }\n             //\n-            // Recall that we matched `<Vec<int> as Convert>`. Trait\n+            // Recall that we matched `<Vec<i32> as Convert>`. Trait\n             // resolution will have given us a substitution\n-            // containing `impl_substs=[[T=int],[],[]]` (the type\n+            // containing `impl_substs=[[T=i32],[],[]]` (the type\n             // parameters defined on the impl). We combine\n             // that with the `rcvr_method` from before, which tells us\n             // the type parameters from the *method*, to yield\n-            // `callee_substs=[[T=int],[],[U=String]]`.\n+            // `callee_substs=[[T=i32],[],[U=String]]`.\n             let subst::SeparateVecsPerParamSpace {\n                 types: impl_type,\n                 selfs: impl_self,\n@@ -456,7 +456,7 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Generate a shim function that allows an object type like `SomeTrait` to\n /// implement the type `SomeTrait`. Imagine a trait definition:\n ///\n-///    trait SomeTrait { fn get(&self) -> isize; ... }\n+///    trait SomeTrait { fn get(&self) -> i32; ... }\n ///\n /// And a generic bit of code:\n ///\n@@ -468,7 +468,7 @@ fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// What is the value of `x` when `foo` is invoked with `T=SomeTrait`?\n /// The answer is that it is a shim function generated by this routine:\n ///\n-///    fn shim(t: &SomeTrait) -> isize {\n+///    fn shim(t: &SomeTrait) -> i32 {\n ///        // ... call t.get() virtually ...\n ///    }\n ///"}, {"sha": "5f4eecf49513c9f1686cb4567769c2312c8f4e4e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f016b77dffb77ec04e1386811d3aec62446c619e", "patch": "@@ -59,9 +59,9 @@\n //! There are a number of troublesome scenarios in the tests\n //! `region-dependent-*.rs`, but here is one example:\n //!\n-//!     struct Foo { i: isize }\n+//!     struct Foo { i: i32 }\n //!     struct Bar { foo: Foo  }\n-//!     fn get_i(x: &'a Bar) -> &'a int {\n+//!     fn get_i(x: &'a Bar) -> &'a i32 {\n //!        let foo = &x.foo; // Lifetime L1\n //!        &foo.i            // Lifetime L2\n //!     }\n@@ -233,8 +233,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Consider this silly example:\n     ///\n     /// ```\n-    /// fn borrow(x: &int) -> &isize {x}\n-    /// fn foo(x: @int) -> isize {  // block: B\n+    /// fn borrow(x: &i32) -> &i32 {x}\n+    /// fn foo(x: @i32) -> i32 {  // block: B\n     ///     let b = borrow(x);    // region: <R0>\n     ///     *b\n     /// }\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Here, the region of `b` will be `<R0>`.  `<R0>` is constrained to be some subregion of the\n     /// block B and some superregion of the call.  If we forced it now, we'd choose the smaller\n     /// region (the call).  But that would make the *b illegal.  Since we don't resolve, the type\n-    /// of b will be `&<R0>.isize` and then `*b` will require that `<R0>` be bigger than the let and\n+    /// of b will be `&<R0>.i32` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.fcx.infcx().resolve_type_vars_if_possible(&unresolved_ty)"}, {"sha": "1fafe3484f0f24c9410606c225b94719f398424d", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f016b77dffb77ec04e1386811d3aec62446c619e/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=f016b77dffb77ec04e1386811d3aec62446c619e", "patch": "@@ -172,14 +172,14 @@\n //!\n //! Now imagine that I have an implementation of `ConvertTo` for `Object`:\n //!\n-//!     impl ConvertTo<isize> for Object { ... }\n+//!     impl ConvertTo<i32> for Object { ... }\n //!\n //! And I want to call `convertAll` on an array of strings. Suppose\n //! further that for whatever reason I specifically supply the value of\n //! `String` for the type parameter `T`:\n //!\n //!     let mut vector = vec![\"string\", ...];\n-//!     convertAll::<isize, String>(vector);\n+//!     convertAll::<i32, String>(vector);\n //!\n //! Is this legal? To put another way, can we apply the `impl` for\n //! `Object` to the type `String`? The answer is yes, but to see why\n@@ -190,25 +190,25 @@\n //! - It will then call the impl of `convertTo()` that is intended\n //!   for use with objects. This has the type:\n //!\n-//!       fn(self: &Object) -> isize\n+//!       fn(self: &Object) -> i32\n //!\n //!   It is ok to provide a value for `self` of type `&String` because\n //!   `&String <: &Object`.\n //!\n //! OK, so intuitively we want this to be legal, so let's bring this back\n //! to variance and see whether we are computing the correct result. We\n //! must first figure out how to phrase the question \"is an impl for\n-//! `Object,isize` usable where an impl for `String,isize` is expected?\"\n+//! `Object,i32` usable where an impl for `String,i32` is expected?\"\n //!\n //! Maybe it's helpful to think of a dictionary-passing implementation of\n //! type classes. In that case, `convertAll()` takes an implicit parameter\n //! representing the impl. In short, we *have* an impl of type:\n //!\n-//!     V_O = ConvertTo<isize> for Object\n+//!     V_O = ConvertTo<i32> for Object\n //!\n //! and the function prototype expects an impl of type:\n //!\n-//!     V_S = ConvertTo<isize> for String\n+//!     V_S = ConvertTo<i32> for String\n //!\n //! As with any argument, this is legal if the type of the value given\n //! (`V_O`) is a subtype of the type expected (`V_S`). So is `V_O <: V_S`?\n@@ -217,7 +217,7 @@\n //! covariant, it means that:\n //!\n //!     V_O <: V_S iff\n-//!         isize <: isize\n+//!         i32 <: i32\n //!         String <: Object\n //!\n //! These conditions are satisfied and so we are happy."}]}