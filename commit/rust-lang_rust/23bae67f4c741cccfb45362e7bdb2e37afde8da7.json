{"sha": "23bae67f4c741cccfb45362e7bdb2e37afde8da7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzYmFlNjdmNGM3NDFjY2NmYjQ1MzYyZTdiZGIyZTM3YWZkZThkYTc=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-06T18:07:29Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-06T18:36:06Z"}, "message": "Simplify arguments to trans_anon_obj and friends.", "tree": {"sha": "3b203ed924ed72445ab215440c86d66eb36e2033", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b203ed924ed72445ab215440c86d66eb36e2033"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23bae67f4c741cccfb45362e7bdb2e37afde8da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23bae67f4c741cccfb45362e7bdb2e37afde8da7", "html_url": "https://github.com/rust-lang/rust/commit/23bae67f4c741cccfb45362e7bdb2e37afde8da7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23bae67f4c741cccfb45362e7bdb2e37afde8da7/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc5d6aefdabc2ee928cb0599c5a8c73799f191ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc5d6aefdabc2ee928cb0599c5a8c73799f191ef", "html_url": "https://github.com/rust-lang/rust/commit/bc5d6aefdabc2ee928cb0599c5a8c73799f191ef"}], "stats": {"total": 34, "additions": 13, "deletions": 21}, "files": [{"sha": "86f2dc34af3b2be3c93f1088ee25fea8e808a683", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/23bae67f4c741cccfb45362e7bdb2e37afde8da7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23bae67f4c741cccfb45362e7bdb2e37afde8da7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=23bae67f4c741cccfb45362e7bdb2e37afde8da7", "patch": "@@ -6268,8 +6268,8 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         case (ast::expr_spawn(?dom, ?name, ?func, ?args)) {\n             ret trans_spawn(cx, dom, name, func, args, e.id);\n         }\n-        case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid)) {\n-            ret trans_anon_obj(cx, e.span, anon_obj, tps, odid.ctor, e.id);\n+        case (ast::expr_anon_obj(?anon_obj, ?tps, _)) {\n+            ret trans_anon_obj(cx, e.span, anon_obj, tps, e.id);\n         }\n         case (_) {\n             // The expression is an lvalue. Fall through.\n@@ -6929,8 +6929,7 @@ fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n // instead \"inlining\" the construction of the object and returning the object\n // itself.\n fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj, \n-                  &vec[ast::ty_param] ty_params, ast::node_id oid,\n-                  ast::node_id type_id) -> result {\n+                  &vec[ast::ty_param] ty_params, ast::node_id id) -> result {\n \n     // Right now, we're assuming that anon objs don't take ty params, even\n     // though the AST supports it.  It's nonsensical to write an expression\n@@ -6960,7 +6959,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n \n     // Get the type of the eventual entire anonymous object, possibly with\n     // extensions.  NB: This type includes both inner and outer methods.\n-    auto outer_obj_ty = ty::node_id_to_type(ccx.tcx, type_id);\n+    auto outer_obj_ty = ty::node_id_to_type(ccx.tcx, id);\n     auto llouter_obj_ty = type_of(ccx, sp, outer_obj_ty);\n \n     // Create a vtable for the anonymous object.\n@@ -6979,7 +6978,6 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n \n     let result with_obj_val;\n     let ty::t with_obj_ty;\n-    let TypeRef llwith_obj_ty;\n     auto vtbl;\n     alt (anon_obj.with_obj) {\n         case (none) { \n@@ -7012,8 +7010,6 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             with_obj_ty = ty::expr_ty(ccx.tcx, e);\n             //with_obj_ty = ty::node_id_to_type(ccx.tcx, e.id);\n \n-            llwith_obj_ty = type_of(ccx, sp, with_obj_ty);\n-\n             // If there's a with_obj, we pass its type along to create_vtbl().\n             // Part of what create_vtbl() will do is take the set difference\n             // of methods defined on the original and methods being added.\n@@ -7023,7 +7019,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // normal vtable entry for every method being added.\n             vtbl = create_vtbl(bcx.fcx.lcx, llouter_obj_ty, outer_obj_ty,\n                                wrapper_obj, ty_params, \n-                               some(tup(with_obj_ty, llwith_obj_ty)),\n+                               some(with_obj_ty),\n                                additional_field_tys);\n         }\n     }\n@@ -7037,7 +7033,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n                                    vec::len[ast::ty_param](ty_params))]));\n \n     // Take care of cleanups.\n-    auto t = node_id_type(ccx, type_id);\n+    auto t = node_id_type(ccx, id);\n     find_scope_cx(bcx).cleanups += [clean(bind drop_ty(_, pair, t))];\n \n     // Grab onto the first and second elements of the pair.\n@@ -7800,7 +7796,7 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n // helper function for create_vtbl.\n fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n                        ty::t self_ty, &vec[ast::ty_param] ty_params,\n-                       tup(ty::t, TypeRef) with_obj_ty_tup,\n+                       ty::t with_obj_ty,\n                        ty::t[] additional_field_tys) -> ValueRef {\n \n     // NB: self_ty (and llself_ty) is the type of the outer object;\n@@ -7816,10 +7812,6 @@ fn process_fwding_mthd(@local_ctxt cx, @ty::method m, TypeRef llself_ty,\n     // on.  That object won't exist until run-time, but we know its type\n     // statically.\n \n-    // Unpack the tuple.\n-    let ty::t with_obj_ty = with_obj_ty_tup._0;\n-    // TODO: We don't actually need both halves of this.\n-\n     // Create a fake span for functions that expect it.  Shouldn't matter what\n     // it is, since this isn't user-written code.  (Possibly better: have\n     // create_vtable take a span argument and pass it in here?)\n@@ -8024,7 +8016,7 @@ fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n // read-only memory.\n fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n                &ast::_obj ob, &vec[ast::ty_param] ty_params,\n-               option::t[tup(ty::t, TypeRef)] with_obj_ty_tup,\n+               option::t[ty::t] with_obj_ty,\n                ty::t[] additional_field_tys) -> ValueRef {\n \n     // Used only inside create_vtbl to distinguish different kinds of slots\n@@ -8048,15 +8040,15 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n     let vec[ValueRef] llmethods = [dtor];\n     let vec[vtbl_mthd] meths = [];\n \n-    alt (with_obj_ty_tup) {\n+    alt (with_obj_ty) {\n         case (none) {\n             // If there's no with_obj, then we don't need any forwarding\n             // slots.  Just use the object's regular methods.\n             for (@ast::method m in ob.methods) {\n                 meths += [normal_mthd(m)];\n             }\n         }\n-        case (some(?with_obj_ty_tup)) {\n+        case (some(?with_obj_ty)) {\n             // Handle forwarding slots.\n \n             // If this vtable is being created for an extended object, then\n@@ -8074,7 +8066,7 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n             // methods we need forwarding methods for.\n \n             // Gather up methods on the original object in 'meths'.\n-            alt (ty::struct(cx.ccx.tcx, with_obj_ty_tup._0)) {\n+            alt (ty::struct(cx.ccx.tcx, with_obj_ty)) {\n                 case (ty::ty_obj(?with_obj_methods)) {\n                     for (ty::method m in with_obj_methods) {\n                         meths += [fwding_mthd(@m)];\n@@ -8156,11 +8148,11 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n             // If we have to process a forwarding method, then we need to know\n             // about the with_obj's type as well as the outer object's type.\n             case (fwding_mthd(?fm)) {\n-                alt (with_obj_ty_tup) {\n+                alt (with_obj_ty) {\n                     case (none) {\n                         // This shouldn't happen; if we're trying to process a\n                         // forwarding method, then we should always have a\n-                        // with_obj_ty_tup.\n+                        // with_obj_ty.\n                         cx.ccx.sess.bug(\"create_vtbl(): trying to create \"\n                                         + \"forwarding method without a type \"\n                                         + \"of object to forward to\");"}]}