{"sha": "30565e5871ce59e1277879bcd391adf9f544b39e", "node_id": "C_kwDOAAsO6NoAKDMwNTY1ZTU4NzFjZTU5ZTEyNzc4NzliY2QzOTFhZGY5ZjU0NGIzOWU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-23T14:27:52Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-07-26T17:00:31Z"}, "message": "Stop resolving lifetime elision on HIR.", "tree": {"sha": "7ac391e9ef14f145f8ad827396352c494f8b961b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ac391e9ef14f145f8ad827396352c494f8b961b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30565e5871ce59e1277879bcd391adf9f544b39e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30565e5871ce59e1277879bcd391adf9f544b39e", "html_url": "https://github.com/rust-lang/rust/commit/30565e5871ce59e1277879bcd391adf9f544b39e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30565e5871ce59e1277879bcd391adf9f544b39e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267d3620a59c66a58d4d53f77d3f31e44f0f07fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/267d3620a59c66a58d4d53f77d3f31e44f0f07fe", "html_url": "https://github.com/rust-lang/rust/commit/267d3620a59c66a58d4d53f77d3f31e44f0f07fe"}], "stats": {"total": 477, "additions": 52, "deletions": 425}, "files": [{"sha": "c6af81ed507ceb24d2274ebec74feb7f381ccce3", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 52, "deletions": 425, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/30565e5871ce59e1277879bcd391adf9f544b39e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30565e5871ce59e1277879bcd391adf9f544b39e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=30565e5871ce59e1277879bcd391adf9f544b39e", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n use rustc_span::def_id::DefId;\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -215,9 +215,8 @@ enum Scope<'a> {\n     },\n \n     /// A scope which either determines unspecified lifetimes or errors\n-    /// on them (e.g., due to ambiguity). For more details, see `Elide`.\n+    /// on them (e.g., due to ambiguity).\n     Elision {\n-        elide: Elide,\n         s: ScopeRef<'a>,\n     },\n \n@@ -290,9 +289,7 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n             Scope::Body { id, s: _ } => {\n                 f.debug_struct(\"Body\").field(\"id\", id).field(\"s\", &\"..\").finish()\n             }\n-            Scope::Elision { elide, s: _ } => {\n-                f.debug_struct(\"Elision\").field(\"elide\", elide).field(\"s\", &\"..\").finish()\n-            }\n+            Scope::Elision { s: _ } => f.debug_struct(\"Elision\").field(\"s\", &\"..\").finish(),\n             Scope::ObjectLifetimeDefault { lifetime, s: _ } => f\n                 .debug_struct(\"ObjectLifetimeDefault\")\n                 .field(\"lifetime\", lifetime)\n@@ -309,21 +306,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-enum Elide {\n-    /// Use a fresh anonymous late-bound lifetime each time, by\n-    /// incrementing the counter to generate sequential indices. All\n-    /// anonymous lifetimes must start *after* named bound vars.\n-    FreshLateAnon(u32, Cell<u32>),\n-    /// Always use this one lifetime.\n-    Exact(Region),\n-    /// Less or more than one lifetime were found, error on unspecified.\n-    Error,\n-    /// Forbid lifetime elision inside of a larger scope where it would be\n-    /// permitted. For example, in let position impl trait.\n-    Forbid,\n-}\n-\n type ScopeRef<'a> = &'a Scope<'a>;\n \n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n@@ -664,8 +646,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n                 // No lifetime parameters, but implied 'static.\n-                let scope = Scope::Elision { elide: Elide::Exact(Region::Static), s: ROOT_SCOPE };\n-                self.with(scope, |this| intravisit::walk_item(this, item));\n+                self.with(Scope::Elision { s: self.scope }, |this| {\n+                    intravisit::walk_item(this, item)\n+                });\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n                 // Opaque types are visited when we visit the\n@@ -860,7 +843,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // position impl Trait\n                         let scope = Scope::TraitRefBoundary { s: self.scope };\n                         self.with(scope, |this| {\n-                            let scope = Scope::Elision { elide: Elide::Forbid, s: this.scope };\n+                            let scope = Scope::Elision { s: this.scope };\n                             this.with(scope, |this| {\n                                 intravisit::walk_item(this, opaque_ty);\n                             })\n@@ -936,7 +919,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index_for_opaque_type();\n                 debug!(?index);\n \n-                let mut elision = None;\n                 let mut lifetimes = FxIndexMap::default();\n                 let mut non_lifetime_count = 0;\n                 debug!(?generics.params);\n@@ -945,15 +927,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n                             lifetimes.insert(def_id, reg);\n-                            if let hir::ParamName::Plain(Ident {\n-                                name: kw::UnderscoreLifetime,\n-                                ..\n-                            }) = param.name\n-                            {\n-                                // Pick the elided lifetime \"definition\" if one exists\n-                                // and use it to make an elision scope.\n-                                elision = Some(reg);\n-                            }\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                             non_lifetime_count += 1;\n@@ -963,51 +936,25 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let next_early_index = index + non_lifetime_count;\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n \n-                if let Some(elision_region) = elision {\n-                    let scope =\n-                        Scope::Elision { elide: Elide::Exact(elision_region), s: self.scope };\n-                    self.with(scope, |this| {\n-                        let scope = Scope::Binder {\n-                            hir_id: ty.hir_id,\n-                            lifetimes,\n-                            next_early_index,\n-                            s: this.scope,\n-                            opaque_type_parent: false,\n-                            scope_type: BinderScopeType::Normal,\n-                            allow_late_bound: false,\n-                            where_bound_origin: None,\n-                        };\n-                        this.with(scope, |this| {\n-                            this.visit_generics(generics);\n-                            let scope = Scope::TraitRefBoundary { s: this.scope };\n-                            this.with(scope, |this| {\n-                                for bound in bounds {\n-                                    this.visit_param_bound(bound);\n-                                }\n-                            })\n-                        });\n-                    });\n-                } else {\n-                    let scope = Scope::Binder {\n-                        hir_id: ty.hir_id,\n-                        lifetimes,\n-                        next_early_index,\n-                        s: self.scope,\n-                        opaque_type_parent: false,\n-                        scope_type: BinderScopeType::Normal,\n-                        allow_late_bound: false,\n-                        where_bound_origin: None,\n-                    };\n-                    self.with(scope, |this| {\n-                        let scope = Scope::TraitRefBoundary { s: this.scope };\n-                        this.with(scope, |this| {\n-                            this.visit_generics(generics);\n-                            for bound in bounds {\n-                                this.visit_param_bound(bound);\n-                            }\n-                        })\n-                    });\n-                }\n+                let scope = Scope::Binder {\n+                    hir_id: ty.hir_id,\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                    opaque_type_parent: false,\n+                    scope_type: BinderScopeType::Normal,\n+                    allow_late_bound: false,\n+                    where_bound_origin: None,\n+                };\n+                self.with(scope, |this| {\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |this| {\n+                        this.visit_generics(generics);\n+                        for bound in bounds {\n+                            this.visit_param_bound(bound);\n+                        }\n+                    })\n+                });\n             }\n             _ => intravisit::walk_ty(self, ty),\n         }\n@@ -1156,12 +1103,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl<'tcx>) {\n+    fn visit_fn(\n+        &mut self,\n+        fk: intravisit::FnKind<'tcx>,\n+        fd: &'tcx hir::FnDecl<'tcx>,\n+        body_id: hir::BodyId,\n+        _: Span,\n+        _: hir::HirId,\n+    ) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n             hir::FnRetTy::Return(ref ty) => Some(&**ty),\n         };\n-        self.visit_fn_like_elision(&fd.inputs, output);\n+        self.visit_fn_like_elision(&fd.inputs, output, matches!(fk, intravisit::FnKind::Closure));\n+        intravisit::walk_fn_kind(self, fk);\n+        self.visit_nested_body(body_id)\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n@@ -1773,7 +1729,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n \n         if generic_args.parenthesized {\n-            self.visit_fn_like_elision(generic_args.inputs(), Some(generic_args.bindings[0].ty()));\n+            self.visit_fn_like_elision(\n+                generic_args.inputs(),\n+                Some(generic_args.bindings[0].ty()),\n+                false,\n+            );\n             return;\n         }\n \n@@ -2052,319 +2012,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         &mut self,\n         inputs: &'tcx [hir::Ty<'tcx>],\n         output: Option<&'tcx hir::Ty<'tcx>>,\n+        in_closure: bool,\n     ) {\n-        debug!(\"visit_fn_like_elision: enter\");\n-        let mut scope = &*self.scope;\n-        let hir_id = loop {\n-            match scope {\n-                Scope::Binder { hir_id, allow_late_bound: true, .. } => {\n-                    break *hir_id;\n-                }\n-                Scope::ObjectLifetimeDefault { ref s, .. }\n-                | Scope::Elision { ref s, .. }\n-                | Scope::Supertrait { ref s, .. }\n-                | Scope::TraitRefBoundary { ref s, .. } => {\n-                    scope = *s;\n-                }\n-                Scope::Root\n-                | Scope::Body { .. }\n-                | Scope::Binder { allow_late_bound: false, .. } => {\n-                    // See issues #83907 and #83693. Just bail out from looking inside.\n-                    // See the issue #95023 for not allowing late bound\n-                    self.tcx.sess.delay_span_bug(\n-                        rustc_span::DUMMY_SP,\n-                        \"In fn_like_elision without appropriate scope above\",\n-                    );\n-                    return;\n-                }\n-            }\n-        };\n-        // While not strictly necessary, we gather anon lifetimes *before* actually\n-        // visiting the argument types.\n-        let mut gather = GatherAnonLifetimes { anon_count: 0 };\n-        for input in inputs {\n-            gather.visit_ty(input);\n-        }\n-        trace!(?gather.anon_count);\n-        let late_bound_vars = self.map.late_bound_vars.entry(hir_id).or_default();\n-        let named_late_bound_vars = late_bound_vars.len() as u32;\n-        late_bound_vars.extend(\n-            (0..gather.anon_count).map(|var| ty::BoundVariableKind::Region(ty::BrAnon(var))),\n-        );\n-        let arg_scope = Scope::Elision {\n-            elide: Elide::FreshLateAnon(named_late_bound_vars, Cell::new(0)),\n-            s: self.scope,\n-        };\n-        self.with(arg_scope, |this| {\n+        self.with(Scope::Elision { s: self.scope }, |this| {\n             for input in inputs {\n                 this.visit_ty(input);\n             }\n-        });\n-\n-        let Some(output) = output else { return };\n-\n-        debug!(\"determine output\");\n-\n-        // Figure out if there's a body we can get argument names from,\n-        // and whether there's a `self` argument (treated specially).\n-        let mut assoc_item_kind = None;\n-        let mut impl_self = None;\n-        let parent = self.tcx.hir().get_parent_node(output.hir_id);\n-        match self.tcx.hir().get(parent) {\n-            // `fn` definitions and methods.\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. }) => {}\n-\n-            Node::TraitItem(&hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. }) => {\n-                if let hir::ItemKind::Trait(.., ref trait_items) =\n-                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n-                {\n-                    assoc_item_kind =\n-                        trait_items.iter().find(|ti| ti.id.hir_id() == parent).map(|ti| ti.kind);\n-                }\n-            }\n-\n-            Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, _), .. }) => {\n-                if let hir::ItemKind::Impl(hir::Impl { ref self_ty, ref items, .. }) =\n-                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n-                {\n-                    impl_self = Some(self_ty);\n-                    assoc_item_kind =\n-                        items.iter().find(|ii| ii.id.hir_id() == parent).map(|ii| ii.kind);\n-                }\n-            }\n-\n-            // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => {},\n-\n-            Node::TypeBinding(_) if let Node::TraitRef(_) = self.tcx.hir().get(self.tcx.hir().get_parent_node(parent)) => {},\n-\n-            // Everything else (only closures?) doesn't\n-            // actually enjoy elision in return types.\n-            _ => {\n-                self.visit_ty(output);\n-                return;\n-            }\n-        };\n-\n-        let has_self = match assoc_item_kind {\n-            Some(hir::AssocItemKind::Fn { has_self }) => has_self,\n-            _ => false,\n-        };\n-\n-        // In accordance with the rules for lifetime elision, we can determine\n-        // what region to use for elision in the output type in two ways.\n-        // First (determined here), if `self` is by-reference, then the\n-        // implied output region is the region of the self parameter.\n-        if has_self {\n-            struct SelfVisitor<'a> {\n-                map: &'a NamedRegionMap,\n-                impl_self: Option<&'a hir::TyKind<'a>>,\n-                lifetime: Set1<Region>,\n-            }\n-\n-            impl SelfVisitor<'_> {\n-                // Look for `self: &'a Self` - also desugared from `&'a self`,\n-                // and if that matches, use it for elision and return early.\n-                fn is_self_ty(&self, res: Res) -> bool {\n-                    if let Res::SelfTy { .. } = res {\n-                        return true;\n-                    }\n-\n-                    // Can't always rely on literal (or implied) `Self` due\n-                    // to the way elision rules were originally specified.\n-                    if let Some(&hir::TyKind::Path(hir::QPath::Resolved(None, ref path))) =\n-                        self.impl_self\n-                    {\n-                        match path.res {\n-                            // Permit the types that unambiguously always\n-                            // result in the same type constructor being used\n-                            // (it can't differ between `Self` and `self`).\n-                            Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum, _)\n-                            | Res::PrimTy(_) => return res == path.res,\n-                            _ => {}\n-                        }\n-                    }\n-\n-                    false\n-                }\n-            }\n-\n-            impl<'a> Visitor<'a> for SelfVisitor<'a> {\n-                fn visit_ty(&mut self, ty: &'a hir::Ty<'a>) {\n-                    if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.kind {\n-                        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.kind\n-                        {\n-                            if self.is_self_ty(path.res) {\n-                                if let Some(lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n-                                    self.lifetime.insert(*lifetime);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    intravisit::walk_ty(self, ty)\n-                }\n-            }\n-\n-            let mut visitor = SelfVisitor {\n-                map: self.map,\n-                impl_self: impl_self.map(|ty| &ty.kind),\n-                lifetime: Set1::Empty,\n-            };\n-            visitor.visit_ty(&inputs[0]);\n-            if let Set1::One(lifetime) = visitor.lifetime {\n-                let scope = Scope::Elision { elide: Elide::Exact(lifetime), s: self.scope };\n-                self.with(scope, |this| this.visit_ty(output));\n-                return;\n-            }\n-        }\n-\n-        // Second, if there was exactly one lifetime (either a substitution or a\n-        // reference) in the arguments, then any anonymous regions in the output\n-        // have that lifetime.\n-        let mut possible_implied_output_region = None;\n-        let mut lifetime_count = 0;\n-        for input in inputs.iter().skip(has_self as usize) {\n-            let mut gather = GatherLifetimes {\n-                map: self.map,\n-                outer_index: ty::INNERMOST,\n-                have_bound_regions: false,\n-                lifetimes: Default::default(),\n-            };\n-            gather.visit_ty(input);\n-\n-            lifetime_count += gather.lifetimes.len();\n-\n-            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n-                // there's a chance that the unique lifetime of this\n-                // iteration will be the appropriate lifetime for output\n-                // parameters, so lets store it.\n-                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n-            }\n-        }\n-\n-        let elide = if lifetime_count == 1 {\n-            Elide::Exact(possible_implied_output_region.unwrap())\n-        } else {\n-            Elide::Error\n-        };\n-\n-        debug!(?elide);\n-\n-        let scope = Scope::Elision { elide, s: self.scope };\n-        self.with(scope, |this| this.visit_ty(output));\n-\n-        struct GatherLifetimes<'a> {\n-            map: &'a NamedRegionMap,\n-            outer_index: ty::DebruijnIndex,\n-            have_bound_regions: bool,\n-            lifetimes: FxHashSet<Region>,\n-        }\n-\n-        impl<'v, 'a> Visitor<'v> for GatherLifetimes<'a> {\n-            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    self.outer_index.shift_in(1);\n-                }\n-                match ty.kind {\n-                    hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n-                        for bound in bounds {\n-                            self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n-                        }\n-\n-                        // Stay on the safe side and don't include the object\n-                        // lifetime default (which may not end up being used).\n-                        if !lifetime.is_elided() {\n-                            self.visit_lifetime(lifetime);\n-                        }\n-                    }\n-                    _ => {\n-                        intravisit::walk_ty(self, ty);\n-                    }\n-                }\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    self.outer_index.shift_out(1);\n-                }\n-            }\n-\n-            fn visit_generic_param(&mut self, param: &hir::GenericParam<'_>) {\n-                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-                    // FIXME(eddyb) Do we want this? It only makes a difference\n-                    // if this `for<'a>` lifetime parameter is never used.\n-                    self.have_bound_regions = true;\n-                }\n-\n-                intravisit::walk_generic_param(self, param);\n-            }\n-\n-            fn visit_poly_trait_ref(\n-                &mut self,\n-                trait_ref: &hir::PolyTraitRef<'_>,\n-                modifier: hir::TraitBoundModifier,\n-            ) {\n-                self.outer_index.shift_in(1);\n-                intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n-                self.outer_index.shift_out(1);\n-            }\n-\n-            fn visit_param_bound(&mut self, bound: &hir::GenericBound<'_>) {\n-                if let hir::GenericBound::LangItemTrait { .. } = bound {\n-                    self.outer_index.shift_in(1);\n-                    intravisit::walk_param_bound(self, bound);\n-                    self.outer_index.shift_out(1);\n-                } else {\n-                    intravisit::walk_param_bound(self, bound);\n-                }\n-            }\n-\n-            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n-                    match lifetime {\n-                        Region::LateBound(debruijn, _, _)\n-                        | Region::LateBoundAnon(debruijn, _, _)\n-                            if debruijn < self.outer_index =>\n-                        {\n-                            self.have_bound_regions = true;\n-                        }\n-                        _ => {\n-                            // FIXME(jackh726): nested trait refs?\n-                            self.lifetimes.insert(lifetime.shifted_out_to_binder(self.outer_index));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        struct GatherAnonLifetimes {\n-            anon_count: u32,\n-        }\n-        impl<'v> Visitor<'v> for GatherAnonLifetimes {\n-            #[instrument(skip(self), level = \"trace\")]\n-            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n-                // If we enter a `BareFn`, then we enter a *new* binding scope\n-                if let hir::TyKind::BareFn(_) = ty.kind {\n-                    return;\n-                }\n-                intravisit::walk_ty(self, ty);\n-            }\n-\n-            fn visit_generic_args(\n-                &mut self,\n-                path_span: Span,\n-                generic_args: &'v hir::GenericArgs<'v>,\n-            ) {\n-                // parenthesized args enter a new elision scope\n-                if generic_args.parenthesized {\n-                    return;\n-                }\n-                intravisit::walk_generic_args(self, path_span, generic_args)\n-            }\n-\n-            #[instrument(skip(self), level = \"trace\")]\n-            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-                if lifetime_ref.is_elided() {\n-                    self.anon_count += 1;\n-                }\n+            if !in_closure && let Some(output) = output {\n+                this.visit_ty(output);\n             }\n+        });\n+        if in_closure && let Some(output) = output {\n+            self.visit_ty(output);\n         }\n     }\n \n@@ -2375,48 +2034,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             return;\n         }\n \n-        let mut late_depth = 0;\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n                 Scope::Body { .. } => return,\n \n-                Scope::Root => break,\n-\n-                Scope::Binder { s, scope_type, .. } => {\n-                    match scope_type {\n-                        BinderScopeType::Normal => late_depth += 1,\n-                        BinderScopeType::Concatenating => {}\n-                    }\n-                    scope = s;\n-                }\n-\n-                Scope::Elision {\n-                    elide: Elide::FreshLateAnon(named_late_bound_vars, ref counter),\n-                    ..\n-                } => {\n-                    for lifetime_ref in lifetime_refs {\n-                        let lifetime =\n-                            Region::late_anon(named_late_bound_vars, counter).shifted(late_depth);\n+                Scope::Root | Scope::Elision { .. } => break,\n \n-                        self.insert_lifetime(lifetime_ref, lifetime);\n-                    }\n-                    return;\n-                }\n-\n-                Scope::Elision { elide: Elide::Exact(l), .. } => {\n-                    let lifetime = l.shifted(late_depth);\n-                    for lifetime_ref in lifetime_refs {\n-                        self.insert_lifetime(lifetime_ref, lifetime);\n-                    }\n-                    return;\n-                }\n-\n-                Scope::Elision { elide: Elide::Error, .. }\n-                | Scope::Elision { elide: Elide::Forbid, .. } => break,\n-\n-                Scope::ObjectLifetimeDefault { s, .. }\n+                Scope::Binder { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;"}]}