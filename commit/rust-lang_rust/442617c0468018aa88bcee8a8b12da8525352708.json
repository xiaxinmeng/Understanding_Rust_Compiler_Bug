{"sha": "442617c0468018aa88bcee8a8b12da8525352708", "node_id": "C_kwDOAAsO6NoAKDQ0MjYxN2MwNDY4MDE4YWE4OGJjZWU4YThiMTJkYTg1MjUzNTI3MDg", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-05-05T20:31:00Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-05-05T20:31:35Z"}, "message": "misc nameres changes for anon consts", "tree": {"sha": "f1d0ef1c03a1fd3b502378f796d91c11382e078e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1d0ef1c03a1fd3b502378f796d91c11382e078e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/442617c0468018aa88bcee8a8b12da8525352708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/442617c0468018aa88bcee8a8b12da8525352708", "html_url": "https://github.com/rust-lang/rust/commit/442617c0468018aa88bcee8a8b12da8525352708", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/442617c0468018aa88bcee8a8b12da8525352708/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "html_url": "https://github.com/rust-lang/rust/commit/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32"}], "stats": {"total": 335, "additions": 202, "deletions": 133}, "files": [{"sha": "fa1155f135d20eaf3bd119dd47ce28d6b7557eb6", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=442617c0468018aa88bcee8a8b12da8525352708", "patch": "@@ -120,6 +120,12 @@ impl Path {\n     pub fn is_global(&self) -> bool {\n         !self.segments.is_empty() && self.segments[0].ident.name == kw::PathRoot\n     }\n+\n+    /// If this path is a single identifier with no arguments, does not ensure\n+    /// that the path resolves to a const param, the caller should check this.\n+    pub fn is_potential_trivial_const_arg(&self) -> bool {\n+        self.segments.len() == 1 && self.segments[0].args.is_none()\n+    }\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of types.\n@@ -1154,7 +1160,9 @@ impl Expr {\n     ///\n     /// If this is not the case, name resolution does not resolve `N` when using\n     /// `min_const_generics` as more complex expressions are not supported.\n-    pub fn is_potential_trivial_const_param(&self) -> bool {\n+    ///\n+    /// Does not ensure that the path resolves to a const param, the caller should check this.\n+    pub fn is_potential_trivial_const_arg(&self) -> bool {\n         let this = if let ExprKind::Block(block, None) = &self.kind\n             && block.stmts.len() == 1\n             && let StmtKind::Expr(expr) = &block.stmts[0].kind\n@@ -1165,8 +1173,7 @@ impl Expr {\n         };\n \n         if let ExprKind::Path(None, path) = &this.kind\n-            && path.segments.len() == 1\n-            && path.segments[0].args.is_none()\n+            && path.is_potential_trivial_const_arg()\n         {\n             true\n         } else {"}, {"sha": "275692ad5dda7f54a2341fccfc9df7e7ee6fd058", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=442617c0468018aa88bcee8a8b12da8525352708", "patch": "@@ -188,6 +188,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_variant(&mut self, v: &'ast Variant) {\n         walk_variant(self, v)\n     }\n+    fn visit_variant_discr(&mut self, discr: &'ast AnonConst) {\n+        self.visit_anon_const(discr);\n+    }\n     fn visit_label(&mut self, label: &'ast Label) {\n         walk_label(self, label)\n     }\n@@ -380,7 +383,7 @@ where\n     visitor.visit_ident(variant.ident);\n     visitor.visit_vis(&variant.vis);\n     visitor.visit_variant_data(&variant.data);\n-    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_variant_discr, &variant.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n "}, {"sha": "ce3b0acdab370d320daf4e1df42d3c3ea5eba7fe", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=442617c0468018aa88bcee8a8b12da8525352708", "patch": "@@ -1190,13 +1190,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // parsing. We try to resolve that ambiguity by attempting resolution in both the\n                     // type and value namespaces. If we resolved the path in the value namespace, we\n                     // transform it into a generic const argument.\n-                    TyKind::Path(qself, path) => {\n+                    TyKind::Path(None, path) => {\n                         if let Some(res) = self\n                             .resolver\n                             .get_partial_res(ty.id)\n                             .and_then(|partial_res| partial_res.full_res())\n                         {\n-                            if !res.matches_ns(Namespace::TypeNS) {\n+                            if !res.matches_ns(Namespace::TypeNS)\n+                                && path.is_potential_trivial_const_arg()\n+                            {\n                                 debug!(\n                                     \"lower_generic_arg: Lowering type argument as const argument: {:?}\",\n                                     ty,\n@@ -1218,7 +1220,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                                 let path_expr = Expr {\n                                     id: ty.id,\n-                                    kind: ExprKind::Path(qself.clone(), path.clone()),\n+                                    kind: ExprKind::Path(None, path.clone()),\n                                     span,\n                                     attrs: AttrVec::new(),\n                                     tokens: None,"}, {"sha": "4f36590025bae4e6d66001a524e7730c203cc2d4", "filename": "compiler/rustc_error_codes/src/error_codes/E0771.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0771.md", "raw_url": "https://github.com/rust-lang/rust/raw/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0771.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0771.md?ref=442617c0468018aa88bcee8a8b12da8525352708", "patch": "@@ -1,9 +1,11 @@\n+#### Note: this error code is no longer emitted by the compiler\n+\n A non-`'static` lifetime was used in a const generic. This is currently not\n allowed.\n \n Erroneous code example:\n \n-```compile_fail,E0771\n+```compile_fail,E0770\n #![feature(adt_const_params)]\n \n fn function_with_str<'a, const STRING: &'a str>() {} // error!"}, {"sha": "ab2932bf969ad9c0980bc08c4a993ff86890bbed", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=442617c0468018aa88bcee8a8b12da8525352708", "patch": "@@ -51,7 +51,15 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Generics {\n                 // of a const parameter type, e.g. `struct Foo<const N: usize, const M: [u8; N]>` is not allowed.\n                 None\n             } else if tcx.lazy_normalization() {\n-                if let Some(param_id) = tcx.hir().opt_const_param_default_param_def_id(hir_id) {\n+                let parent_node = tcx.hir().get_parent(hir_id);\n+                if let Node::Variant(Variant { disr_expr: Some(constant), .. }) = parent_node\n+                    && constant.hir_id == hir_id\n+                {\n+                    // enum variant discriminants are not allowed to use any kind of generics\n+                    None\n+                } else if let Some(param_id) =\n+                    tcx.hir().opt_const_param_default_param_def_id(hir_id)\n+                {\n                     // If the def_id we are calling generics_of on is an anon ct default i.e:\n                     //\n                     // struct Foo<const N: usize = { .. }>;\n@@ -94,15 +102,15 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Generics {\n                         has_self: generics.has_self,\n                         has_late_bound_regions: generics.has_late_bound_regions,\n                     };\n+                } else {\n+                    // HACK(eddyb) this provides the correct generics when\n+                    // `feature(generic_const_expressions)` is enabled, so that const expressions\n+                    // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n+                    //\n+                    // Note that we do not supply the parent generics when using\n+                    // `min_const_generics`.\n+                    Some(parent_def_id.to_def_id())\n                 }\n-\n-                // HACK(eddyb) this provides the correct generics when\n-                // `feature(generic_const_expressions)` is enabled, so that const expressions\n-                // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n-                //\n-                // Note that we do not supply the parent generics when using\n-                // `min_const_generics`.\n-                Some(parent_def_id.to_def_id())\n             } else {\n                 let parent_node = tcx.hir().get_parent(hir_id);\n                 match parent_node {\n@@ -115,11 +123,6 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Generics {\n                     {\n                         Some(parent_def_id.to_def_id())\n                     }\n-                    Node::Variant(Variant { disr_expr: Some(constant), .. })\n-                        if constant.hir_id == hir_id =>\n-                    {\n-                        Some(parent_def_id.to_def_id())\n-                    }\n                     Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) => {\n                         Some(tcx.typeck_root_def_id(def_id.to_def_id()))\n                     }"}, {"sha": "4e1d49c12a76161eae33158d3dfd865c02e7d514", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=442617c0468018aa88bcee8a8b12da8525352708", "patch": "@@ -1188,11 +1188,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n \n                         RibKind::ConstantItem(trivial, _) => {\n-                            let features = self.tcx.sess.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial == ConstantHasGenerics::Yes\n-                                || features.generic_const_exprs)\n-                            {\n+                            if let ConstantHasGenerics::No(cause) = trivial {\n                                 // HACK(min_const_generics): If we encounter `Self` in an anonymous\n                                 // constant we can't easily tell if it's generic at this stage, so\n                                 // we instead remember this and then enforce the self type to be\n@@ -1264,11 +1260,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         | RibKind::ForwardGenericParamBan => continue,\n \n                         RibKind::ConstantItem(trivial, _) => {\n-                            let features = self.tcx.sess.features_untracked();\n-                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n-                            if !(trivial == ConstantHasGenerics::Yes\n-                                || features.generic_const_exprs)\n-                            {\n+                            if let ConstantHasGenerics::No(cause) = trivial {\n                                 if let Some(span) = finalize {\n                                     self.report_error(\n                                         span,"}, {"sha": "c6b193710e08272ad0988bc1b4dbef5f9fdba734", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 161, "deletions": 101, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442617c0468018aa88bcee8a8b12da8525352708/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=442617c0468018aa88bcee8a8b12da8525352708", "patch": "@@ -66,6 +66,15 @@ enum IsRepeatExpr {\n     Yes,\n }\n \n+/// Describes whether an `AnonConst` is a type level const arg or\n+/// some other form of anon const (i.e. inline consts or enum discriminants)\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum AnonConstKind {\n+    EnumDiscriminant,\n+    InlineConst,\n+    ConstArg(IsRepeatExpr),\n+}\n+\n impl PatternSource {\n     fn descr(self) -> &'static str {\n         match self {\n@@ -105,7 +114,7 @@ pub(crate) enum HasGenericParams {\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum ConstantHasGenerics {\n     Yes,\n-    No,\n+    No(NoConstantGenericsReason),\n }\n \n impl ConstantHasGenerics {\n@@ -114,6 +123,27 @@ impl ConstantHasGenerics {\n     }\n }\n \n+/// Reason for why an anon const is not allowed to reference generic parameters\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub(crate) enum NoConstantGenericsReason {\n+    /// Const arguments are only allowed to use generic parameters when:\n+    /// - `feature(generic_const_exprs)` is enabled\n+    /// or\n+    /// - the const argument is a sole const generic paramater, i.e. `foo::<{ N }>()`\n+    ///\n+    /// If neither of the above are true then this is used as the cause.\n+    NonTrivialConstArg,\n+    /// Enum discriminants are not allowed to reference generic parameters ever, this\n+    /// is used when an anon const is in the following position:\n+    ///\n+    /// ```rust,compile_fail\n+    /// enum Foo<const N: isize> {\n+    ///     Variant = { N }, // this anon const is not allowed to use generics\n+    /// }\n+    /// ```\n+    IsEnumDiscriminant,\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum ConstantItemKind {\n     Const,\n@@ -273,15 +303,18 @@ enum LifetimeRibKind {\n     /// Signal we cannot find which should be the anonymous lifetime.\n     ElisionFailure,\n \n-    /// FIXME(const_generics): This patches over an ICE caused by non-'static lifetimes in const\n-    /// generics. We are disallowing this until we can decide on how we want to handle non-'static\n-    /// lifetimes in const generics. See issue #74052 for discussion.\n-    ConstGeneric,\n+    /// This rib forbids usage of generic parameters inside of const parameter types.\n+    ///\n+    /// While this is desirable to support eventually, it is difficult to do and so is\n+    /// currently forbidden. See rust-lang/project-const-generics#28 for more info.\n+    ConstParamTy,\n \n-    /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics`.\n-    /// This function will emit an error if `generic_const_exprs` is not enabled, the body\n-    /// identified by `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n-    AnonConst,\n+    /// Usage of generic parameters is forbidden in various positions for anon consts:\n+    /// - const arguments when `generic_const_exprs` is not enabled\n+    /// - enum discriminant values\n+    ///\n+    /// This rib emits an error when a lifetime would resolve to a lifetime parameter.\n+    ConcreteAnonConst(NoConstantGenericsReason),\n \n     /// This rib acts as a barrier to forbid reference to lifetimes of a parent item.\n     Item,\n@@ -648,13 +681,8 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n         self.resolve_block(block);\n         self.parent_scope.macro_rules = old_macro_rules;\n     }\n-    fn visit_anon_const(&mut self, constant: &'ast AnonConst) {\n-        // We deal with repeat expressions explicitly in `resolve_expr`.\n-        self.with_lifetime_rib(LifetimeRibKind::AnonConst, |this| {\n-            this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n-                this.resolve_anon_const(constant, IsRepeatExpr::No);\n-            })\n-        })\n+    fn visit_anon_const(&mut self, _constant: &'ast AnonConst) {\n+        bug!(\"encountered anon const without a manual call to `resolve_anon_const`\");\n     }\n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         self.resolve_expr(expr, None);\n@@ -676,7 +704,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n     fn visit_ty(&mut self, ty: &'ast Ty) {\n         let prev = self.diagnostic_metadata.current_trait_object;\n         let prev_ty = self.diagnostic_metadata.current_type_path;\n-        match ty.kind {\n+        match &ty.kind {\n             TyKind::Ref(None, _) => {\n                 // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n                 // NodeId `ty.id`.\n@@ -685,7 +713,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 self.resolve_elided_lifetime(ty.id, span);\n                 visit::walk_ty(self, ty);\n             }\n-            TyKind::Path(ref qself, ref path) => {\n+            TyKind::Path(qself, path) => {\n                 self.diagnostic_metadata.current_type_path = Some(ty);\n                 self.smart_resolve_path(ty.id, &qself, path, PathSource::Type);\n \n@@ -730,11 +758,11 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 visit::walk_ty(self, ty);\n                 self.lifetime_elision_candidates = candidates;\n             }\n-            TyKind::TraitObject(ref bounds, ..) => {\n+            TyKind::TraitObject(bounds, ..) => {\n                 self.diagnostic_metadata.current_trait_object = Some(&bounds[..]);\n                 visit::walk_ty(self, ty)\n             }\n-            TyKind::BareFn(ref bare_fn) => {\n+            TyKind::BareFn(bare_fn) => {\n                 let span = ty.span.shrink_to_lo().to(bare_fn.decl_span.shrink_to_lo());\n                 self.with_generic_param_rib(\n                     &bare_fn.generic_params,\n@@ -769,6 +797,13 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                     },\n                 )\n             }\n+            TyKind::Array(element_ty, length) => {\n+                self.visit_ty(element_ty);\n+                self.resolve_anon_const(length, AnonConstKind::ConstArg(IsRepeatExpr::No));\n+            }\n+            TyKind::Typeof(ct) => {\n+                self.resolve_anon_const(ct, AnonConstKind::ConstArg(IsRepeatExpr::No))\n+            }\n             _ => visit::walk_ty(self, ty),\n         }\n         self.diagnostic_metadata.current_trait_object = prev;\n@@ -994,36 +1029,25 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 // namespace first, and if that fails we try again in the value namespace. If\n                 // resolution in the value namespace succeeds, we have an generic const argument on\n                 // our hands.\n-                if let TyKind::Path(ref qself, ref path) = ty.kind {\n+                if let TyKind::Path(None, ref path) = ty.kind {\n                     // We cannot disambiguate multi-segment paths right now as that requires type\n                     // checking.\n-                    if path.segments.len() == 1 && path.segments[0].args.is_none() {\n+                    if path.is_potential_trivial_const_arg() {\n                         let mut check_ns = |ns| {\n                             self.maybe_resolve_ident_in_lexical_scope(path.segments[0].ident, ns)\n                                 .is_some()\n                         };\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n-                            // This must be equivalent to `visit_anon_const`, but we cannot call it\n-                            // directly due to visitor lifetimes so we have to copy-paste some code.\n-                            //\n-                            // Note that we might not be inside of an repeat expression here,\n-                            // but considering that `IsRepeatExpr` is only relevant for\n-                            // non-trivial constants this is doesn't matter.\n-                            self.with_constant_rib(\n-                                IsRepeatExpr::No,\n-                                ConstantHasGenerics::Yes,\n-                                None,\n+                            self.resolve_anon_const_manual(\n+                                true,\n+                                AnonConstKind::ConstArg(IsRepeatExpr::No),\n                                 |this| {\n                                     this.smart_resolve_path(\n                                         ty.id,\n-                                        qself,\n+                                        &None,\n                                         path,\n                                         PathSource::Expr(None),\n                                     );\n-\n-                                    if let Some(ref qself) = *qself {\n-                                        this.visit_ty(&qself.ty);\n-                                    }\n                                     this.visit_path(path, ty.id);\n                                 },\n                             );\n@@ -1037,7 +1061,9 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 self.visit_ty(ty);\n             }\n             GenericArg::Lifetime(lt) => self.visit_lifetime(lt, visit::LifetimeCtxt::GenericArg),\n-            GenericArg::Const(ct) => self.visit_anon_const(ct),\n+            GenericArg::Const(ct) => {\n+                self.resolve_anon_const(ct, AnonConstKind::ConstArg(IsRepeatExpr::No))\n+            }\n         }\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n@@ -1053,7 +1079,9 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n         match constraint.kind {\n             AssocConstraintKind::Equality { ref term } => match term {\n                 Term::Ty(ty) => self.visit_ty(ty),\n-                Term::Const(c) => self.visit_anon_const(c),\n+                Term::Const(c) => {\n+                    self.resolve_anon_const(c, AnonConstKind::ConstArg(IsRepeatExpr::No))\n+                }\n             },\n             AssocConstraintKind::Bound { ref bounds } => {\n                 walk_list!(self, visit_param_bound, bounds, BoundKind::Bound);\n@@ -1102,8 +1130,8 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                             | LifetimeRibKind::AnonymousReportError\n                             | LifetimeRibKind::Elided(_)\n                             | LifetimeRibKind::ElisionFailure\n-                            | LifetimeRibKind::AnonConst\n-                            | LifetimeRibKind::ConstGeneric => {}\n+                            | LifetimeRibKind::ConcreteAnonConst(_)\n+                            | LifetimeRibKind::ConstParamTy => {}\n                         }\n                     }\n                 }\n@@ -1164,7 +1192,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 InlineAsmOperand::Const { anon_const, .. } => {\n                     // Although this is `DefKind::AnonConst`, it is allowed to reference outer\n                     // generic parameters like an inline const.\n-                    self.resolve_inline_const(anon_const);\n+                    self.resolve_anon_const(anon_const, AnonConstKind::InlineConst);\n                 }\n                 InlineAsmOperand::Sym { sym } => self.visit_inline_asm_sym(sym),\n             }\n@@ -1188,6 +1216,10 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n         visit::walk_variant(self, v)\n     }\n \n+    fn visit_variant_discr(&mut self, discr: &'ast AnonConst) {\n+        self.resolve_anon_const(discr, AnonConstKind::EnumDiscriminant);\n+    }\n+\n     fn visit_field_def(&mut self, f: &'ast FieldDef) {\n         self.resolve_doc_links(&f.attrs, MaybeExported::Ok(f.id));\n         visit::walk_field_def(self, f)\n@@ -1386,7 +1418,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n                         this.ribs[TypeNS].push(Rib::new(RibKind::ConstParamTy));\n                         this.ribs[ValueNS].push(Rib::new(RibKind::ConstParamTy));\n-                        this.with_lifetime_rib(LifetimeRibKind::ConstGeneric, |this| {\n+                        this.with_lifetime_rib(LifetimeRibKind::ConstParamTy, |this| {\n                             this.visit_ty(ty)\n                         });\n                         this.ribs[TypeNS].pop().unwrap();\n@@ -1395,9 +1427,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         if let Some(ref expr) = default {\n                             this.ribs[TypeNS].push(forward_ty_ban_rib);\n                             this.ribs[ValueNS].push(forward_const_ban_rib);\n-                            this.with_lifetime_rib(LifetimeRibKind::ConstGeneric, |this| {\n-                                this.resolve_anon_const(expr, IsRepeatExpr::No)\n-                            });\n+                            this.resolve_anon_const(\n+                                expr,\n+                                AnonConstKind::ConstArg(IsRepeatExpr::No),\n+                            );\n                             forward_const_ban_rib = this.ribs[ValueNS].pop().unwrap();\n                             forward_ty_ban_rib = this.ribs[TypeNS].pop().unwrap();\n                         }\n@@ -1475,8 +1508,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                                         LifetimeUseSet::Many\n                                     }),\n                                     LifetimeRibKind::Generics { .. }\n-                                    | LifetimeRibKind::ConstGeneric => None,\n-                                    LifetimeRibKind::AnonConst => {\n+                                    | LifetimeRibKind::ConstParamTy => None,\n+                                    LifetimeRibKind::ConcreteAnonConst(_) => {\n                                         span_bug!(ident.span, \"unexpected rib kind: {:?}\", rib.kind)\n                                     }\n                                 })\n@@ -1495,7 +1528,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             match rib.kind {\n                 LifetimeRibKind::Item => break,\n-                LifetimeRibKind::ConstGeneric => {\n+                LifetimeRibKind::ConstParamTy => {\n                     self.emit_non_static_lt_in_const_generic_error(lifetime);\n                     self.record_lifetime_res(\n                         lifetime.id,\n@@ -1504,7 +1537,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     );\n                     return;\n                 }\n-                LifetimeRibKind::AnonConst => {\n+                LifetimeRibKind::ConcreteAnonConst(cause) => {\n                     self.maybe_emit_forbidden_non_static_lifetime_error(lifetime);\n                     self.record_lifetime_res(\n                         lifetime.id,\n@@ -1604,9 +1637,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     return;\n                 }\n                 LifetimeRibKind::Item => break,\n-                LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstGeneric => {}\n-                LifetimeRibKind::AnonConst => {\n-                    // There is always an `Elided(LifetimeRes::Static)` inside an `AnonConst`.\n+                LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstParamTy => {}\n+                LifetimeRibKind::ConcreteAnonConst(_) => {\n+                    // There is always an `Elided(LifetimeRes::Infer)` inside an `AnonConst`.\n                     span_bug!(lifetime.ident.span, \"unexpected rib kind: {:?}\", rib.kind)\n                 }\n             }\n@@ -1826,9 +1859,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         self.report_missing_lifetime_specifiers(vec![missing_lifetime], None);\n                         break;\n                     }\n-                    LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstGeneric => {}\n-                    LifetimeRibKind::AnonConst => {\n-                        // There is always an `Elided(LifetimeRes::Static)` inside an `AnonConst`.\n+                    LifetimeRibKind::Generics { .. } | LifetimeRibKind::ConstParamTy => {}\n+                    LifetimeRibKind::ConcreteAnonConst(_) => {\n+                        // There is always an `Elided(LifetimeRes::Infer)` inside an `AnonConst`.\n                         span_bug!(elided_lifetime_span, \"unexpected rib kind: {:?}\", rib.kind)\n                     }\n                 }\n@@ -2560,7 +2593,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n     }\n \n-    // HACK(min_const_generics,const_evaluatable_unchecked): We\n+    // HACK(min_const_generics, generic_const_exprs): We\n     // want to keep allowing `[0; std::mem::size_of::<*mut T>()]`\n     // with a future compat lint for now. We do this by adding an\n     // additional special case for repeat expressions.\n@@ -2576,18 +2609,26 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         item: Option<(Ident, ConstantItemKind)>,\n         f: impl FnOnce(&mut Self),\n     ) {\n-        self.with_rib(ValueNS, RibKind::ConstantItem(may_use_generics, item), |this| {\n-            this.with_rib(\n-                TypeNS,\n-                RibKind::ConstantItem(\n-                    may_use_generics.force_yes_if(is_repeat == IsRepeatExpr::Yes),\n-                    item,\n-                ),\n-                |this| {\n-                    this.with_label_rib(RibKind::ConstantItem(may_use_generics, item), f);\n-                },\n-            )\n-        });\n+        let f = |this: &mut Self| {\n+            this.with_rib(ValueNS, RibKind::ConstantItem(may_use_generics, item), |this| {\n+                this.with_rib(\n+                    TypeNS,\n+                    RibKind::ConstantItem(\n+                        may_use_generics.force_yes_if(is_repeat == IsRepeatExpr::Yes),\n+                        item,\n+                    ),\n+                    |this| {\n+                        this.with_label_rib(RibKind::ConstantItem(may_use_generics, item), f);\n+                    },\n+                )\n+            })\n+        };\n+\n+        if let ConstantHasGenerics::No(cause) = may_use_generics {\n+            self.with_lifetime_rib(LifetimeRibKind::ConcreteAnonConst(cause), f)\n+        } else {\n+            f(self)\n+        }\n     }\n \n     fn with_current_self_type<T>(&mut self, self_type: &Ty, f: impl FnOnce(&mut Self) -> T) -> T {\n@@ -3924,24 +3965,54 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    fn resolve_anon_const(&mut self, constant: &'ast AnonConst, is_repeat: IsRepeatExpr) {\n-        debug!(\"resolve_anon_const {:?} is_repeat: {:?}\", constant, is_repeat);\n-        self.with_constant_rib(\n-            is_repeat,\n-            if constant.value.is_potential_trivial_const_param() {\n-                ConstantHasGenerics::Yes\n-            } else {\n-                ConstantHasGenerics::No\n-            },\n-            None,\n-            |this| visit::walk_anon_const(this, constant),\n+    fn resolve_anon_const(&mut self, constant: &'ast AnonConst, anon_const_kind: AnonConstKind) {\n+        debug!(\n+            \"resolve_anon_const(constant: {:?}, anon_const_kind: {:?})\",\n+            constant, anon_const_kind\n         );\n+\n+        self.resolve_anon_const_manual(\n+            constant.value.is_potential_trivial_const_arg(),\n+            anon_const_kind,\n+            |this| this.resolve_expr(&constant.value, None),\n+        )\n     }\n \n-    fn resolve_inline_const(&mut self, constant: &'ast AnonConst) {\n-        debug!(\"resolve_anon_const {constant:?}\");\n-        self.with_constant_rib(IsRepeatExpr::No, ConstantHasGenerics::Yes, None, |this| {\n-            visit::walk_anon_const(this, constant)\n+    /// There are a few places that we need to resolve an anon const but we did not parse an\n+    /// anon const so cannot provide an `&'ast AnonConst`. Right now this is just unbraced\n+    /// const arguments that were parsed as type arguments, and `legact_const_generics` which\n+    /// parse as normal function argument expressions. To avoid duplicating the code for resolving\n+    /// an anon const we have this function which lets the caller manually call `resolve_expr` or\n+    /// `smart_resolve_path`.\n+    fn resolve_anon_const_manual(\n+        &mut self,\n+        is_trivial_const_arg: bool,\n+        anon_const_kind: AnonConstKind,\n+        resolve_expr: impl FnOnce(&mut Self),\n+    ) {\n+        let is_repeat_expr = match anon_const_kind {\n+            AnonConstKind::ConstArg(is_repeat_expr) => is_repeat_expr,\n+            _ => IsRepeatExpr::No,\n+        };\n+\n+        let may_use_generics = match anon_const_kind {\n+            AnonConstKind::EnumDiscriminant => {\n+                ConstantHasGenerics::No(NoConstantGenericsReason::IsEnumDiscriminant)\n+            }\n+            AnonConstKind::InlineConst => ConstantHasGenerics::Yes,\n+            AnonConstKind::ConstArg(_) => {\n+                if self.r.tcx.features().generic_const_exprs || is_trivial_const_arg {\n+                    ConstantHasGenerics::Yes\n+                } else {\n+                    ConstantHasGenerics::No(NoConstantGenericsReason::NonTrivialConstArg)\n+                }\n+            }\n+        };\n+\n+        self.with_constant_rib(is_repeat_expr, may_use_generics, None, |this| {\n+            this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n+                resolve_expr(this);\n+            });\n         });\n     }\n \n@@ -4046,17 +4117,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     // Constant arguments need to be treated as AnonConst since\n                     // that is how they will be later lowered to HIR.\n                     if const_args.contains(&idx) {\n-                        self.with_constant_rib(\n-                            IsRepeatExpr::No,\n-                            if argument.is_potential_trivial_const_param() {\n-                                ConstantHasGenerics::Yes\n-                            } else {\n-                                ConstantHasGenerics::No\n-                            },\n-                            None,\n-                            |this| {\n-                                this.resolve_expr(argument, None);\n-                            },\n+                        self.resolve_anon_const_manual(\n+                            argument.is_potential_trivial_const_arg(),\n+                            AnonConstKind::ConstArg(IsRepeatExpr::No),\n+                            |this| this.resolve_expr(argument, None),\n                         );\n                     } else {\n                         self.resolve_expr(argument, None);\n@@ -4115,14 +4179,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             }\n             ExprKind::Repeat(ref elem, ref ct) => {\n                 self.visit_expr(elem);\n-                self.with_lifetime_rib(LifetimeRibKind::AnonConst, |this| {\n-                    this.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n-                        this.resolve_anon_const(ct, IsRepeatExpr::Yes)\n-                    })\n-                });\n+                self.resolve_anon_const(ct, AnonConstKind::ConstArg(IsRepeatExpr::Yes));\n             }\n             ExprKind::ConstBlock(ref ct) => {\n-                self.resolve_inline_const(ct);\n+                self.resolve_anon_const(ct, AnonConstKind::InlineConst);\n             }\n             ExprKind::Index(ref elem, ref idx) => {\n                 self.resolve_expr(elem, Some(expr));"}]}