{"sha": "5e23cc49601776e97aed012fdbe268206df11c3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMjNjYzQ5NjAxNzc2ZTk3YWVkMDEyZmRiZTI2ODIwNmRmMTFjM2U=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-09-24T06:01:17Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-10-09T21:44:24Z"}, "message": "Given `<T as Trait>::A: Ty` suggest `T: Trait<A = Ty>`\n\nFix #75829", "tree": {"sha": "32bea5088629ead812dcabbe2f7c9aed1c284e76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32bea5088629ead812dcabbe2f7c9aed1c284e76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e23cc49601776e97aed012fdbe268206df11c3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e23cc49601776e97aed012fdbe268206df11c3e", "html_url": "https://github.com/rust-lang/rust/commit/5e23cc49601776e97aed012fdbe268206df11c3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e23cc49601776e97aed012fdbe268206df11c3e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e89ce461d39686a899cd88e53dc13dcec9445c3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e89ce461d39686a899cd88e53dc13dcec9445c3f", "html_url": "https://github.com/rust-lang/rust/commit/e89ce461d39686a899cd88e53dc13dcec9445c3f"}], "stats": {"total": 161, "additions": 161, "deletions": 0}, "files": [{"sha": "a1538818df3f343ace1202d01e163717c67fa706", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e23cc49601776e97aed012fdbe268206df11c3e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23cc49601776e97aed012fdbe268206df11c3e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=5e23cc49601776e97aed012fdbe268206df11c3e", "patch": "@@ -386,6 +386,9 @@ struct DiagnosticMetadata<'ast> {\n     in_if_condition: Option<&'ast Expr>,\n \n     current_trait_object: Option<&'ast [ast::GenericBound]>,\n+\n+    /// Given `where <T as Bar>::Baz: String`, suggest `where T: Bar<Baz = String>`.\n+    current_where_predicate: Option<&'ast WherePredicate>,\n }\n \n struct LateResolutionVisitor<'a, 'b, 'ast> {\n@@ -667,6 +670,14 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         }\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n+\n+    fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n+        debug!(\"visit_where_predicate {:?}\", p);\n+        let previous_value =\n+            replace(&mut self.diagnostic_metadata.current_where_predicate, Some(p));\n+        visit::walk_where_predicate(self, p);\n+        self.diagnostic_metadata.current_where_predicate = previous_value;\n+    }\n }\n \n impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {"}, {"sha": "b983656c423ba980820a23759c53419b5f4ec144", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5e23cc49601776e97aed012fdbe268206df11c3e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23cc49601776e97aed012fdbe268206df11c3e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=5e23cc49601776e97aed012fdbe268206df11c3e", "patch": "@@ -8,6 +8,7 @@ use crate::{PathResult, PathSource, Segment};\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::visit::FnKind;\n use rustc_ast::{self as ast, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n+use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -497,6 +498,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     }\n                 }\n             }\n+\n+            fallback |= self.restrict_assoc_type_in_where_clause(span, &mut err);\n+\n             if !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span) {\n                 fallback = true;\n                 match self.diagnostic_metadata.current_let_binding {\n@@ -521,6 +525,120 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         (err, candidates)\n     }\n \n+    /// Given `where <T as Bar>::Baz: String`, suggest `where T: Bar<Baz = String>`.\n+    fn restrict_assoc_type_in_where_clause(\n+        &mut self,\n+        span: Span,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) -> bool {\n+        // Detect that we are actually in a `where` predicate.\n+        let (bounded_ty, bounds, where_span) =\n+            if let Some(ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bounded_ty,\n+                bound_generic_params,\n+                bounds,\n+                span,\n+            })) = self.diagnostic_metadata.current_where_predicate\n+            {\n+                if !bound_generic_params.is_empty() {\n+                    return false;\n+                }\n+                (bounded_ty, bounds, span)\n+            } else {\n+                return false;\n+            };\n+\n+        // Confirm that the target is an associated type.\n+        let (ty, position, path) = if let ast::TyKind::Path(\n+            Some(ast::QSelf { ty, position, .. }),\n+            path,\n+        ) = &bounded_ty.kind\n+        {\n+            // use this to verify that ident is a type param.\n+            let partial_res = if let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n+                bounded_ty.id,\n+                None,\n+                &Segment::from_path(path),\n+                Namespace::TypeNS,\n+                span,\n+                true,\n+                CrateLint::No,\n+            ) {\n+                partial_res\n+            } else {\n+                return false;\n+            };\n+            if !(matches!(\n+                partial_res.base_res(),\n+                hir::def::Res::Def(hir::def::DefKind::AssocTy, _)\n+            ) && partial_res.unresolved_segments() == 0)\n+            {\n+                return false;\n+            }\n+            (ty, position, path)\n+        } else {\n+            return false;\n+        };\n+\n+        if let ast::TyKind::Path(None, type_param_path) = &ty.kind {\n+            // Confirm that the `SelfTy` is a type parameter.\n+            let partial_res = if let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n+                bounded_ty.id,\n+                None,\n+                &Segment::from_path(type_param_path),\n+                Namespace::TypeNS,\n+                span,\n+                true,\n+                CrateLint::No,\n+            ) {\n+                partial_res\n+            } else {\n+                return false;\n+            };\n+            if !(matches!(\n+                partial_res.base_res(),\n+                hir::def::Res::Def(hir::def::DefKind::TyParam, _)\n+            ) && partial_res.unresolved_segments() == 0)\n+            {\n+                return false;\n+            }\n+            if let (\n+                [ast::PathSegment { ident, args: None, .. }],\n+                [ast::GenericBound::Trait(poly_trait_ref, ast::TraitBoundModifier::None)],\n+            ) = (&type_param_path.segments[..], &bounds[..])\n+            {\n+                if let [ast::PathSegment { ident: bound_ident, args: None, .. }] =\n+                    &poly_trait_ref.trait_ref.path.segments[..]\n+                {\n+                    if bound_ident.span == span {\n+                        err.span_suggestion_verbose(\n+                            *where_span,\n+                            &format!(\"constrain the associated type to `{}`\", bound_ident),\n+                            format!(\n+                                \"{}: {}<{} = {}>\",\n+                                ident,\n+                                path.segments[..*position]\n+                                    .iter()\n+                                    .map(|segment| path_segment_to_string(segment))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"::\"),\n+                                path.segments[*position..]\n+                                    .iter()\n+                                    .map(|segment| path_segment_to_string(segment))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"::\"),\n+                                bound_ident,\n+                            ),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     /// Check if the source is call expression and the first argument is `self`. If true,\n     /// return the span of whole call and the span for all arguments expect the first one (`self`).\n     fn call_has_self_arg(&self, source: PathSource<'_>) -> Option<(Span, Option<Span>)> {"}, {"sha": "729996c8130f9fdf932b0f426c4529d8c8ff31b4", "filename": "src/test/ui/traits/assoc_type_bound_with_struct.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e23cc49601776e97aed012fdbe268206df11c3e/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23cc49601776e97aed012fdbe268206df11c3e/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.rs?ref=5e23cc49601776e97aed012fdbe268206df11c3e", "patch": "@@ -0,0 +1,9 @@\n+trait Bar {\n+    type Baz;\n+}\n+\n+struct Foo<T> where T: Bar, <T as Bar>::Baz: String { //~ ERROR expected trait, found struct\n+    t: T,\n+}\n+\n+fn main() {}"}, {"sha": "f0c23aecf73472950a9148f7376f0f4e5b3d171e", "filename": "src/test/ui/traits/assoc_type_bound_with_struct.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e23cc49601776e97aed012fdbe268206df11c3e/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23cc49601776e97aed012fdbe268206df11c3e/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc_type_bound_with_struct.stderr?ref=5e23cc49601776e97aed012fdbe268206df11c3e", "patch": "@@ -0,0 +1,23 @@\n+error[E0404]: expected trait, found struct `String`\n+  --> $DIR/assoc_type_bound_with_struct.rs:5:46\n+   |\n+LL | struct Foo<T> where T: Bar, <T as Bar>::Baz: String {\n+   |                                              ^^^^^^ not a trait\n+   | \n+  ::: $SRC_DIR/alloc/src/string.rs:LL:COL\n+   |\n+LL | pub trait ToString {\n+   | ------------------ similarly named trait `ToString` defined here\n+   |\n+help: constrain the associated type to `String`\n+   |\n+LL | struct Foo<T> where T: Bar, T: Bar<Baz = String> {\n+   |                             ^^^^^^^^^^^^^^^^^^^^\n+help: a trait with a similar name exists\n+   |\n+LL | struct Foo<T> where T: Bar, <T as Bar>::Baz: ToString {\n+   |                                              ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0404`."}]}