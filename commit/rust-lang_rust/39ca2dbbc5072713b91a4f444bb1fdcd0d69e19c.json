{"sha": "39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5Y2EyZGJiYzUwNzI3MTNiOTFhNGY0NDRiYjFmZGNkMGQ2OWUxOWM=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-26T22:56:13Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:07Z"}, "message": "update librustc to use name comparison in most cases, and mtwt_resolve comparison in others", "tree": {"sha": "85b5b71a917f10aa2c1f48842aed5c92fb548bd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85b5b71a917f10aa2c1f48842aed5c92fb548bd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "html_url": "https://github.com/rust-lang/rust/commit/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71e72ee86260880c281d8f8ec6d4d3a1eb55e461", "url": "https://api.github.com/repos/rust-lang/rust/commits/71e72ee86260880c281d8f8ec6d4d3a1eb55e461", "html_url": "https://github.com/rust-lang/rust/commit/71e72ee86260880c281d8f8ec6d4d3a1eb55e461"}], "stats": {"total": 238, "additions": 124, "deletions": 114}, "files": [{"sha": "8c8dedeef3236365a74bb1431bdc91bf8cd7eaf5", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 85, "deletions": 78, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -23,7 +23,7 @@ use middle::pat_util::pat_bindings;\n \n use syntax::ast::*;\n use syntax::ast;\n-use syntax::ast_util::{def_id_of_def, local_def};\n+use syntax::ast_util::{def_id_of_def, local_def}; // mtwt_resolve\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n@@ -51,7 +51,7 @@ pub struct binding_info {\n }\n \n // Map from the name in a pattern to its binding mode.\n-pub type BindingMap = HashMap<Ident,binding_info>;\n+pub type BindingMap = HashMap<Name,binding_info>;\n \n // Trait method resolution\n pub type TraitMap = HashMap<NodeId,@mut ~[DefId]>;\n@@ -445,12 +445,12 @@ pub struct Module {\n     def_id: Option<DefId>,\n     kind: ModuleKind,\n \n-    children: @mut HashMap<Ident, @mut NameBindings>,\n+    children: @mut HashMap<Name, @mut NameBindings>,\n     imports: @mut ~[@ImportDirective],\n \n     // The external module children of this node that were declared with\n     // `extern mod`.\n-    external_module_children: @mut HashMap<Ident, @mut Module>,\n+    external_module_children: @mut HashMap<Name, @mut Module>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -469,7 +469,7 @@ pub struct Module {\n     anonymous_children: @mut HashMap<NodeId,@mut Module>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: @mut HashMap<Ident, @mut ImportResolution>,\n+    import_resolutions: @mut HashMap<Name, @mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: uint,\n@@ -759,15 +759,14 @@ pub fn NameBindings() -> NameBindings {\n \n /// Interns the names of the primitive types.\n pub struct PrimitiveTypeTable {\n-    primitive_types: HashMap<Ident,prim_ty>,\n+    primitive_types: HashMap<Name,prim_ty>,\n }\n \n impl PrimitiveTypeTable {\n     pub fn intern(&mut self,\n                   string: &str,\n                   primitive_type: prim_ty) {\n-        let ident = token::str_to_ident(string);\n-        self.primitive_types.insert(ident, primitive_type);\n+        self.primitive_types.insert(token::intern(string), primitive_type);\n     }\n }\n \n@@ -873,7 +872,7 @@ pub struct Resolver {\n \n     graph_root: @mut NameBindings,\n \n-    method_map: @mut HashMap<Ident, HashSet<DefId>>,\n+    method_map: @mut HashMap<Name, HashSet<DefId>>,\n     structs: HashSet<DefId>,\n \n     // The number of imports that are currently unresolved.\n@@ -1036,10 +1035,10 @@ impl Resolver {\n \n         // Add or reuse the child.\n         let new_parent = ModuleReducedGraphParent(module_);\n-        match module_.children.find(&name) {\n+        match module_.children.find(&name.name) {\n             None => {\n                 let child = @mut NameBindings();\n-                module_.children.insert(name, child);\n+                module_.children.insert(name.name, child);\n                 return (child, new_parent);\n             }\n             Some(&child) => {\n@@ -1307,7 +1306,7 @@ impl Resolver {\n                     } if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n-                        let new_parent = match parent.children.find(&name) {\n+                        let new_parent = match parent.children.find(&name.name) {\n                             // It already exists\n                             Some(&child) if child.get_module_if_available()\n                                                  .is_some() &&\n@@ -1426,7 +1425,7 @@ impl Resolver {\n                     match ty_m.explicit_self.node {\n                         sty_static => {}\n                         _ => {\n-                            method_names.insert(ident, ());\n+                            method_names.insert(ident.name, ());\n                         }\n                     }\n                 }\n@@ -1582,7 +1581,7 @@ impl Resolver {\n                                                           false);\n \n                         parent.external_module_children.insert(\n-                            name,\n+                            name.name,\n                             external_module);\n \n                         self.build_reduced_graph_for_external_crate(\n@@ -1727,7 +1726,7 @@ impl Resolver {\n \n                   // Add it to the trait info if not static.\n                   if explicit_self != sty_static {\n-                      interned_method_names.insert(method_name);\n+                      interned_method_names.insert(method_name.name);\n                   }\n               }\n               for name in interned_method_names.iter() {\n@@ -1981,7 +1980,7 @@ impl Resolver {\n                        self.idents_to_str(directive.module_path),\n                        self.session.str_of(target));\n \n-                match module_.import_resolutions.find(&target) {\n+                match module_.import_resolutions.find(&target.name) {\n                     Some(&resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n@@ -1996,7 +1995,7 @@ impl Resolver {\n                         debug!(\"(building import directive) creating new\");\n                         let resolution = @mut ImportResolution::new(privacy, id);\n                         resolution.outstanding_references = 1;\n-                        module_.import_resolutions.insert(target, resolution);\n+                        module_.import_resolutions.insert(target.name, resolution);\n                     }\n                 }\n             }\n@@ -2281,7 +2280,7 @@ impl Resolver {\n \n         // Search for direct children of the containing module.\n         self.populate_module_if_necessary(containing_module);\n-        match containing_module.children.find(&source) {\n+        match containing_module.children.find(&source.name) {\n             None => {\n                 // Continue.\n             }\n@@ -2315,7 +2314,7 @@ impl Resolver {\n                 // Now search the exported imports within the containing\n                 // module.\n \n-                match containing_module.import_resolutions.find(&source) {\n+                match containing_module.import_resolutions.find(&source.name) {\n                     None => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n@@ -2386,7 +2385,7 @@ impl Resolver {\n             BoundResult(*) => {}\n             _ => {\n                 match containing_module.external_module_children\n-                                       .find(&source) {\n+                                       .find(&source.name) {\n                     None => {} // Continue.\n                     Some(module) => {\n                         let name_bindings =\n@@ -2400,8 +2399,8 @@ impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert!(module_.import_resolutions.contains_key(&target));\n-        let import_resolution = module_.import_resolutions.get(&target);\n+        assert!(module_.import_resolutions.contains_key(&target.name));\n+        let import_resolution = module_.import_resolutions.get(&target.name);\n \n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n@@ -2563,15 +2562,15 @@ impl Resolver {\n             }\n         }\n \n-        let merge_import_resolution = |ident,\n+        let merge_import_resolution = |name,\n                                        name_bindings: @mut NameBindings| {\n             let dest_import_resolution;\n-            match module_.import_resolutions.find(&ident) {\n+            match module_.import_resolutions.find(&name) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @mut ImportResolution::new(privacy, id);\n                     module_.import_resolutions.insert\n-                        (ident, dest_import_resolution);\n+                        (name, dest_import_resolution);\n                 }\n                 Some(&existing_import_resolution) => {\n                     dest_import_resolution = existing_import_resolution;\n@@ -2580,7 +2579,7 @@ impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   self.session.str_of(ident),\n+                   interner_get(name),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    dest_import_resolution.privacy);\n@@ -2602,15 +2601,15 @@ impl Resolver {\n \n         // Add all children from the containing module.\n         self.populate_module_if_necessary(containing_module);\n-        for (&ident, name_bindings) in containing_module.children.iter() {\n-            merge_import_resolution(ident, *name_bindings);\n+        for (&name, name_bindings) in containing_module.children.iter() {\n+            merge_import_resolution(name, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n-        for (&ident, module) in containing_module.external_module_children.iter() {\n+        for (&name, module) in containing_module.external_module_children.iter() {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n-            merge_import_resolution(ident, name_bindings);\n+            merge_import_resolution(name, name_bindings);\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n@@ -2836,7 +2835,7 @@ impl Resolver {\n         // The current module node is handled specially. First, check for\n         // its immediate children.\n         self.populate_module_if_necessary(module_);\n-        match module_.children.find(&name) {\n+        match module_.children.find(&name.name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 return Success(Target::new(module_, *name_bindings));\n@@ -2848,7 +2847,7 @@ impl Resolver {\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-        match module_.import_resolutions.find(&name) {\n+        match module_.import_resolutions.find(&name.name) {\n             None => {\n                 // Not found; continue.\n             }\n@@ -2872,7 +2871,7 @@ impl Resolver {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            match module_.external_module_children.find(&name) {\n+            match module_.external_module_children.find(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3034,8 +3033,9 @@ impl Resolver {\n         }\n     }\n \n-    /// Resolves a \"module prefix\". A module prefix is one of (a) `self::`;\n+    /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n+    /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     pub fn resolve_module_prefix(@mut self,\n                                  module_: @mut Module,\n                                  module_path: &[Ident])\n@@ -3091,7 +3091,7 @@ impl Resolver {\n \n         // First, check the direct children of the module.\n         self.populate_module_if_necessary(module_);\n-        match module_.children.find(&name) {\n+        match module_.children.find(&name.name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"(resolving name in module) found node as child\");\n@@ -3112,7 +3112,7 @@ impl Resolver {\n         }\n \n         // Check the list of resolved imports.\n-        match module_.import_resolutions.find(&name) {\n+        match module_.import_resolutions.find(&name.name) {\n             Some(import_resolution) => {\n                 if import_resolution.privacy == Public &&\n                         import_resolution.outstanding_references != 0 {\n@@ -3147,7 +3147,7 @@ impl Resolver {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match module_.external_module_children.find(&name) {\n+            match module_.external_module_children.find(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3273,7 +3273,7 @@ impl Resolver {\n \n     pub fn add_exports_of_namebindings(@mut self,\n                                        exports2: &mut ~[Export2],\n-                                       ident: Ident,\n+                                       name: Name,\n                                        namebindings: @mut NameBindings,\n                                        ns: Namespace,\n                                        reexport: bool) {\n@@ -3282,11 +3282,11 @@ impl Resolver {\n             (Some(d), Some(Public)) => {\n                 debug!(\"(computing exports) YES: %s '%s' => %?\",\n                        if reexport { ~\"reexport\" } else { ~\"export\"},\n-                       self.session.str_of(ident),\n+                       interner_get(name),\n                        def_id_of_def(d));\n                 exports2.push(Export2 {\n                     reexport: reexport,\n-                    name: self.session.str_of(ident),\n+                    name: interner_get(name),\n                     def_id: def_id_of_def(d)\n                 });\n             }\n@@ -3302,20 +3302,20 @@ impl Resolver {\n     pub fn add_exports_for_module(@mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n-        for (ident, importresolution) in module_.import_resolutions.iter() {\n+        for (name, importresolution) in module_.import_resolutions.iter() {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n-                       self.session.str_of(*ident));\n+                       interner_get(*name));\n                 loop;\n             }\n             let xs = [TypeNS, ValueNS];\n             for ns in xs.iter() {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n-                               self.session.str_of(*ident));\n+                               interner_get(*name));\n                         self.add_exports_of_namebindings(&mut *exports2,\n-                                                         *ident,\n+                                                         *name,\n                                                          target.bindings,\n                                                          *ns,\n                                                          true)\n@@ -3354,7 +3354,7 @@ impl Resolver {\n             }\n             Some(name) => {\n                 self.populate_module_if_necessary(orig_module);\n-                match orig_module.children.find(&name) {\n+                match orig_module.children.find(&name.name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n                                self.session.str_of(name),\n@@ -3498,7 +3498,7 @@ impl Resolver {\n \n     pub fn search_ribs(@mut self,\n                        ribs: &mut ~[@Rib],\n-                       name: Ident,\n+                       name: Name,\n                        span: Span,\n                        allow_capturing_self: AllowCapturingSelfFlag)\n                        -> Option<DefLike> {\n@@ -3508,7 +3508,7 @@ impl Resolver {\n         let mut i = ribs.len();\n         while i != 0 {\n             i -= 1;\n-            match ribs[i].bindings.find(&name.name) {\n+            match ribs[i].bindings.find(&name) {\n                 Some(&def_like) => {\n                     return self.upvarify(ribs, i, def_like, span,\n                                          allow_capturing_self);\n@@ -3591,7 +3591,9 @@ impl Resolver {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib::new(NormalRibKind);\n                 self.type_ribs.push(self_type_rib);\n-                self_type_rib.bindings.insert(self.type_self_ident.name,\n+                // plain insert (no renaming)\n+                let name = self.type_self_ident.name;\n+                self_type_rib.bindings.insert(name,\n                                               DlDef(DefSelfTy(item.id)));\n \n                 // Create a new rib for the trait-wide type parameters.\n@@ -3733,6 +3735,7 @@ impl Resolver {\n                     // the item that bound it\n                     self.record_def(type_parameter.id,\n                                     DefTyParamBinder(node_id));\n+                    // plain insert (no renaming)\n                     function_type_rib.bindings.insert(ident.name, def_like);\n                 }\n             }\n@@ -4067,8 +4070,8 @@ impl Resolver {\n     pub fn binding_mode_map(@mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n         do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n-            let ident = path_to_ident(path);\n-            result.insert(ident,\n+            let name = path_to_ident(path).name; // mtwt_resolve(path_to_ident(path));\n+            result.insert(name,\n                           binding_info {span: sp,\n                                         binding_mode: binding_mode});\n         }\n@@ -4088,15 +4091,15 @@ impl Resolver {\n                         p.span,\n                         fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n-                             self.session.str_of(key), i + 1));\n+                             interner_get(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.resolve_error(\n                             binding_i.span,\n                             fmt!(\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n-                                 self.session.str_of(key), i + 1));\n+                                 interner_get(key), i + 1));\n                     }\n                   }\n                 }\n@@ -4108,7 +4111,7 @@ impl Resolver {\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n-                             self.session.str_of(key), i + 1));\n+                             interner_get(key), i + 1));\n                 }\n             }\n         }\n@@ -4170,11 +4173,11 @@ impl Resolver {\n \n                 // First, check to see whether the name is a primitive type.\n                 if path.segments.len() == 1 {\n-                    let name = path.segments.last().identifier;\n+                    let id = path.segments.last().identifier;\n \n                     match self.primitive_type_table\n                             .primitive_types\n-                            .find(&name) {\n+                            .find(&id.name) {\n \n                         Some(&primitive_type) => {\n                             result_def =\n@@ -4272,7 +4275,7 @@ impl Resolver {\n                            mutability: Mutability,\n                            // Maps idents to the node ID for the (outermost)\n                            // pattern that binds them\n-                           bindings_list: Option<@mut HashMap<Ident,NodeId>>,\n+                           bindings_list: Option<@mut HashMap<Name,NodeId>>,\n                            visitor: &mut ResolveVisitor) {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n@@ -4290,13 +4293,14 @@ impl Resolver {\n                     // what you want).\n \n                     let ident = path.segments[0].identifier;\n+                    let renamed = ident.name; // mtwt_resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def)\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     struct or enum variant\",\n-                                    self.session.str_of(ident));\n+                                   interner_get(renamed));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4310,13 +4314,12 @@ impl Resolver {\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n-                                                        self.session\n-                                                            .str_of(ident)));\n+                                                       interner_get(renamed)));\n                         }\n                         FoundConst(def) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     constant\",\n-                                    self.session.str_of(ident));\n+                                   interner_get(renamed));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4331,7 +4334,7 @@ impl Resolver {\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `%s`\",\n-                                   self.session.str_of(ident));\n+                                   interner_get(renamed));\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -4366,16 +4369,16 @@ impl Resolver {\n \n                             match bindings_list {\n                                 Some(bindings_list)\n-                                if !bindings_list.contains_key(&ident) => {\n+                                if !bindings_list.contains_key(&renamed) => {\n                                     let this = &mut *self;\n                                     let last_rib = this.value_ribs[\n                                             this.value_ribs.len() - 1];\n-                                    last_rib.bindings.insert(ident.name,\n+                                    last_rib.bindings.insert(renamed,\n                                                              DlDef(def));\n-                                    bindings_list.insert(ident, pat_id);\n+                                    bindings_list.insert(renamed, pat_id);\n                                 }\n                                 Some(b) => {\n-                                  if b.find(&ident) == Some(&pat_id) {\n+                                  if b.find(&renamed) == Some(&pat_id) {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n@@ -4391,7 +4394,7 @@ impl Resolver {\n                                     let this = &mut *self;\n                                     let last_rib = this.value_ribs[\n                                             this.value_ribs.len() - 1];\n-                                    last_rib.bindings.insert(ident.name,\n+                                    last_rib.bindings.insert(renamed,\n                                                              DlDef(def));\n                                 }\n                             }\n@@ -4640,7 +4643,7 @@ impl Resolver {\n                                                 -> NameDefinition {\n         // First, search children.\n         self.populate_module_if_necessary(containing_module);\n-        match containing_module.children.find(&name) {\n+        match containing_module.children.find(&name.name) {\n             Some(child_name_bindings) => {\n                 match (child_name_bindings.def_for_namespace(namespace),\n                        child_name_bindings.privacy_for_namespace(namespace)) {\n@@ -4663,7 +4666,7 @@ impl Resolver {\n         }\n \n         // Next, search import resolutions.\n-        match containing_module.import_resolutions.find(&name) {\n+        match containing_module.import_resolutions.find(&name.name) {\n             Some(import_resolution) if import_resolution.privacy == Public ||\n                                        xray == Xray => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n@@ -4691,7 +4694,7 @@ impl Resolver {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match containing_module.external_module_children.find(&name) {\n+            match containing_module.external_module_children.find(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     match module.def_id {\n@@ -4738,9 +4741,9 @@ impl Resolver {\n             }\n         }\n \n-        let name = path.segments.last().identifier;\n+        let ident = path.segments.last().identifier;\n         let def = match self.resolve_definition_of_name_in_module(containing_module,\n-                                                        name,\n+                                                        ident,\n                                                         namespace,\n                                                         xray) {\n             NoNameDefinition => {\n@@ -4753,7 +4756,7 @@ impl Resolver {\n         };\n         match containing_module.kind {\n             TraitModuleKind | ImplModuleKind => {\n-                match self.method_map.find(&name) {\n+                match self.method_map.find(&ident.name) {\n                     Some(s) => {\n                         match containing_module.def_id {\n                             Some(def_id) if s.contains(&def_id) => {\n@@ -4830,12 +4833,14 @@ impl Resolver {\n         let search_result;\n         match namespace {\n             ValueNS => {\n-                search_result = self.search_ribs(self.value_ribs, ident,\n+                let renamed = ident.name; // mtwt_resolve(ident);\n+                search_result = self.search_ribs(self.value_ribs, renamed,\n                                                  span,\n                                                  DontAllowCapturingSelf);\n             }\n             TypeNS => {\n-                search_result = self.search_ribs(self.type_ribs, ident,\n+                let name = ident.name;\n+                search_result = self.search_ribs(self.type_ribs, name,\n                                                  span, AllowCapturingSelf);\n             }\n         }\n@@ -5135,6 +5140,7 @@ impl Resolver {\n                         let this = &mut *self;\n                         let def_like = DlDef(DefLabel(expr.id));\n                         let rib = this.label_ribs[this.label_ribs.len() - 1];\n+                        // plain insert (no renaming)\n                         rib.bindings.insert(label.name, def_like);\n                     }\n \n@@ -5145,7 +5151,8 @@ impl Resolver {\n             ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n-                match self.search_ribs(self.label_ribs, label, expr.span,\n+                let name = label.name;\n+                match self.search_ribs(self.label_ribs, name, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n                         self.resolve_error(expr.span,\n@@ -5273,7 +5280,7 @@ impl Resolver {\n \n         let mut found_traits = ~[];\n         let mut search_module = self.current_module;\n-        match self.method_map.find(&name) {\n+        match self.method_map.find(&name.name) {\n             Some(candidate_traits) => loop {\n                 // Look for the current trait.\n                 match self.current_trait_refs {\n@@ -5495,7 +5502,7 @@ impl Resolver {\n         debug!(\"Children:\");\n         self.populate_module_if_necessary(module_);\n         for (&name, _) in module_.children.iter() {\n-            debug!(\"* %s\", self.session.str_of(name));\n+            debug!(\"* %s\", interner_get(name));\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -5518,7 +5525,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", self.session.str_of(*name),\n+            debug!(\"* %s:%s%s\", interner_get(*name),\n                    value_repr, type_repr);\n         }\n     }"}, {"sha": "5efd81ebc474c289706909148e1f54a8865a10bc", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -1482,7 +1482,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n                 let rec_vals = rec_fields.map(|field_name| {\n-                        let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n+                        let ix = ty::field_idx_strict(tcx, field_name.name, field_tys);\n                         adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n                         });\n                 compile_submatch(\n@@ -2159,7 +2159,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n                 for f in fields.iter() {\n-                    let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n+                    let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                       discr, ix);\n                     bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, binding_mode);"}, {"sha": "94f0b3735700101ab3a7066975ece2290edca1c3", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -374,7 +374,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n               let brepr = adt::represent_type(cx, bt);\n               let bv = const_expr(cx, base);\n               do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n-                  let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n+                  let ix = ty::field_idx_strict(cx.tcx, field.name, field_tys);\n                   adt::const_get_field(cx, brepr, bv, discr, ix)\n               }\n           }\n@@ -502,7 +502,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                   |discr, field_tys| {\n                   let cs: ~[ValueRef] = field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n-                      match fs.iter().find(|f| field_ty.ident == f.ident) {\n+                      match fs.iter().find(|f| field_ty.ident.name == f.ident.name) {\n                           Some(f) => const_expr(cx, (*f).expr),\n                           None => {\n                               match base_val {"}, {"sha": "3ecb319e468c0d1da856e886c8eec8809292a299", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -903,7 +903,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n         let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n         do with_field_tys(bcx.tcx(), base_datum.ty, None) |discr, field_tys| {\n-            let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n+            let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n             DatumBlock {\n                 datum: do base_datum.get_element(bcx,\n                                                  field_tys[ix].mt.ty,\n@@ -1176,7 +1176,8 @@ fn trans_rec_or_struct(bcx: @mut Block,\n         let mut need_base = vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = do fields.map |field| {\n-            let opt_pos = field_tys.iter().position(|field_ty| field_ty.ident == field.ident);\n+            let opt_pos = field_tys.iter().position(|field_ty|\n+                                                    field_ty.ident.name == field.ident.name);\n             match opt_pos {\n                 Some(i) => {\n                     need_base[i] = false;"}, {"sha": "3dfdb55163463e9de6b00e3a361348942e1bc5bb", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -295,6 +295,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n pub fn method_with_name(ccx: &mut CrateContext,\n                         impl_id: ast::DefId,\n                         name: ast::Ident) -> ast::DefId {\n+    // NOTE : SHOULD USE NAME (chonged later)\n     let meth_id_opt = ccx.impl_method_cache.find_copy(&(impl_id, name));\n     match meth_id_opt {\n         Some(m) => return m,\n@@ -303,7 +304,7 @@ pub fn method_with_name(ccx: &mut CrateContext,\n \n     let imp = ccx.tcx.impls.find(&impl_id)\n         .expect(\"could not find impl while translating\");\n-    let meth = imp.methods.iter().find(|m| m.ident == name)\n+    let meth = imp.methods.iter().find(|m| m.ident.name == name.name)\n         .expect(\"could not find method while translating\");\n \n     ccx.impl_method_cache.insert((impl_id, name), meth.def_id);"}, {"sha": "4a42efc339328f8f2fbe008bfc0680ab1e024bb3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -3360,19 +3360,19 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n     }\n }\n \n-pub fn field_idx(id: ast::Ident, fields: &[field]) -> Option<uint> {\n+pub fn field_idx(name: ast::Name, fields: &[field]) -> Option<uint> {\n     let mut i = 0u;\n-    for f in fields.iter() { if f.ident == id { return Some(i); } i += 1u; }\n+    for f in fields.iter() { if f.ident.name == name { return Some(i); } i += 1u; }\n     return None;\n }\n \n-pub fn field_idx_strict(tcx: ty::ctxt, id: ast::Ident, fields: &[field])\n+pub fn field_idx_strict(tcx: ty::ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n-    for f in fields.iter() { if f.ident == id { return i; } i += 1u; }\n+    for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n         \"No field named `%s` found in the list of fields `%?`\",\n-        tcx.sess.str_of(id),\n+        token::interner_get(name),\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n "}, {"sha": "48d630b4aa93d57dcc508a1e64588da54f19598e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -105,6 +105,7 @@ use syntax::ast::{sty_uniq, sty_static, NodeId};\n use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::parse::token;\n \n #[deriving(Eq)]\n pub enum CheckTraitsFlag {\n@@ -126,7 +127,7 @@ pub fn lookup(\n         self_expr: @ast::Expr,              // The expression `a`.\n         callee_id: NodeId,                  /* Where to store `a.b`'s type,\n                                              * also the scope of the call */\n-        m_name: ast::Ident,                 // The ident `b`.\n+        m_name: ast::Name,                  // The name `b`.\n         self_ty: ty::t,                     // The type of `a`.\n         supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n@@ -173,7 +174,7 @@ pub struct LookupContext<'self> {\n     expr: @ast::Expr,\n     self_expr: @ast::Expr,\n     callee_id: NodeId,\n-    m_name: ast::Ident,\n+    m_name: ast::Name,\n     supplied_tps: &'self [ty::t],\n     impl_dups: @mut HashSet<DefId>,\n     inherent_candidates: @mut ~[Candidate],\n@@ -515,7 +516,7 @@ impl<'self> LookupContext<'self> {\n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             match trait_methods.iter().position(|m| {\n                 m.explicit_self != ast::sty_static &&\n-                m.ident == self.m_name })\n+                m.ident.name == self.m_name })\n             {\n                 Some(pos) => {\n                     let method = trait_methods[pos];\n@@ -558,12 +559,12 @@ impl<'self> LookupContext<'self> {\n             return; // already visited\n         }\n         debug!(\"push_candidates_from_impl: %s %s %s\",\n-               self.m_name.repr(self.tcx()),\n+               token::interner_get(self.m_name),\n                impl_info.ident.repr(self.tcx()),\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n         let idx = {\n-            match impl_info.methods.iter().position(|m| m.ident == self.m_name) {\n+            match impl_info.methods.iter().position(|m| m.ident.name == self.m_name) {\n                 Some(idx) => idx,\n                 None => { return; } // No method with the right name.\n             }"}, {"sha": "50c93468bb1619ade57c11771e6a1e0a246200ab", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -1117,10 +1117,10 @@ pub fn impl_self_ty(vcx: &VtableContext,\n pub fn lookup_field_ty(tcx: ty::ctxt,\n                        class_id: ast::DefId,\n                        items: &[ty::field_ty],\n-                       fieldname: ast::Ident,\n+                       fieldname: ast::Name,\n                        substs: &ty::substs) -> Option<ty::t> {\n \n-    let o_field = items.iter().find(|f| f.ident == fieldname);\n+    let o_field = items.iter().find(|f| f.ident.name == fieldname);\n     do o_field.map() |f| {\n         ty::lookup_field_type(tcx, class_id, f.id, substs)\n     }\n@@ -1553,7 +1553,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              expr,\n                              rcvr,\n                              callee_id,\n-                             method_name,\n+                             method_name.name,\n                              expr_t,\n                              tps,\n                              DontDerefArgs,\n@@ -1637,7 +1637,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         op_ex: @ast::Expr,\n                         self_ex: @ast::Expr,\n                         self_t: ty::t,\n-                        opname: ast::Ident,\n+                        opname: ast::Name,\n                         args: ~[@ast::Expr],\n                         deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n@@ -1777,7 +1777,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             lhs_resolved_t, None)\n                 };\n                 return lookup_op_method(fcx, callee_id, ex, lhs_expr, lhs_resolved_t,\n-                                       fcx.tcx().sess.ident_of(*name),\n+                                       token::intern(*name),\n                                        ~[rhs], DoDerefArgs, DontAutoderefReceiver, if_op_unbound,\n                                        expected_result);\n             }\n@@ -1811,7 +1811,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     -> ty::t {\n        lookup_op_method(\n             fcx, callee_id, ex, rhs_expr, rhs_t,\n-            fcx.tcx().sess.ident_of(mname), ~[],\n+            token::intern(mname), ~[],\n             DoDerefArgs, DontAutoderefReceiver,\n             || {\n                 fcx.type_error_message(ex.span, |actual| {\n@@ -1937,7 +1937,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_field(fcx: @mut FnCtxt,\n                    expr: @ast::Expr,\n                    base: @ast::Expr,\n-                   field: ast::Ident,\n+                   field: ast::Name,\n                    tys: &[ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);\n@@ -1985,7 +1985,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     |actual| {\n                         fmt!(\"attempted to take value of method `%s` on type `%s` \\\n                               (try writing an anonymous function)\",\n-                             tcx.sess.str_of(field), actual)\n+                             token::interner_get(field), actual)\n                     },\n                     expr_t, None);\n             }\n@@ -1996,7 +1996,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     |actual| {\n                         fmt!(\"attempted access of field `%s` on type `%s`, \\\n                               but no field with that name was found\",\n-                             tcx.sess.str_of(field), actual)\n+                             token::interner_get(field), actual)\n                     },\n                     expr_t, None);\n             }\n@@ -2018,7 +2018,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut class_field_map = HashMap::new();\n         let mut fields_found = 0;\n         for field in field_types.iter() {\n-            class_field_map.insert(field.ident, (field.id, false));\n+            class_field_map.insert(field.ident.name, (field.id, false));\n         }\n \n         let mut error_happened = false;\n@@ -2027,7 +2027,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         for field in ast_fields.iter() {\n             let mut expected_field_type = ty::mk_err();\n \n-            let pair = class_field_map.find(&field.ident).map_move(|x| *x);\n+            let pair = class_field_map.find(&field.ident.name).map_move(|x| *x);\n             match pair {\n                 None => {\n                     tcx.sess.span_err(\n@@ -2048,7 +2048,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         ty::lookup_field_type(\n                             tcx, class_id, field_id, &substitutions);\n                     class_field_map.insert(\n-                        field.ident, (field_id, true));\n+                        field.ident.name, (field_id, true));\n                     fields_found += 1;\n                 }\n             }\n@@ -2070,11 +2070,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             if fields_found < field_types.len() {\n                 let mut missing_fields = ~[];\n                 for class_field in field_types.iter() {\n-                    let name = class_field.ident;\n+                    let name = class_field.ident.name;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n                         missing_fields.push(\n-                            ~\"`\" + tcx.sess.str_of(name) + \"`\");\n+                            ~\"`\" + token::interner_get(name) + \"`\");\n                     }\n                 }\n \n@@ -2846,7 +2846,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::ExprField(base, field, ref tys) => {\n-        check_field(fcx, expr, base, field, *tys);\n+        check_field(fcx, expr, base, field.name, *tys);\n       }\n       ast::ExprIndex(callee_id, base, idx) => {\n           check_expr(fcx, base);\n@@ -2886,7 +2886,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                     expr,\n                                                     base,\n                                                     resolved,\n-                                                    index_ident,\n+                                                    index_ident.name,\n                                                     ~[idx],\n                                                     DoDerefArgs,\n                                                     AutoderefReceiver,"}, {"sha": "700b60f1159a6ba9bbf70e0d8586c1d46f4d519e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -553,13 +553,13 @@ impl CoherenceChecker {\n         let mut provided_names = HashSet::new();\n         // Implemented methods\n         for elt in all_methods.iter() {\n-            provided_names.insert(elt.ident);\n+            provided_names.insert(elt.ident.name);\n         }\n \n         let r = ty::trait_methods(tcx, trait_did);\n         for method in r.iter() {\n             debug!(\"checking for %s\", method.ident.repr(tcx));\n-            if provided_names.contains(&method.ident) { loop; }\n+            if provided_names.contains(&method.ident.name) { loop; }\n \n             tcx.sess.span_err(trait_ref_span,\n                               fmt!(\"missing method `%s`\","}, {"sha": "3f5e1ef52108827e32d87ee40d73832224231234", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=39ca2dbbc5072713b91a4f444bb1fdcd0d69e19c", "patch": "@@ -698,7 +698,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     // we'll catch it in coherence\n     let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n     for impl_m in impl_ms.iter() {\n-        match trait_ms.iter().find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n+        match trait_ms.iter().find(|trait_m| trait_m.ident.name == impl_m.mty.ident.name) {\n             Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method("}]}