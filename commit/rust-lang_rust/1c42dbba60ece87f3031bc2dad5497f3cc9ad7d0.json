{"sha": "1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0", "node_id": "C_kwDOAAsO6NoAKDFjNDJkYmJhNjBlY2U4N2YzMDMxYmMyZGFkNTQ5N2YzY2M5YWQ3ZDA", "commit": {"author": {"name": "Kyle Huey", "email": "khuey@kylehuey.com", "date": "2023-01-05T03:08:37Z"}, "committer": {"name": "Kyle Huey", "email": "khuey@kylehuey.com", "date": "2023-01-05T03:08:37Z"}, "message": "Expand derivable-impls to cover enums with a default unit variant.", "tree": {"sha": "121dde5c91123e3738a7e485da9ded1bef1b0eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/121dde5c91123e3738a7e485da9ded1bef1b0eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0", "html_url": "https://github.com/rust-lang/rust/commit/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/comments", "author": {"login": "khuey", "id": 325892, "node_id": "MDQ6VXNlcjMyNTg5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/325892?v=4", "gravatar_id": "", "url": "https://api.github.com/users/khuey", "html_url": "https://github.com/khuey", "followers_url": "https://api.github.com/users/khuey/followers", "following_url": "https://api.github.com/users/khuey/following{/other_user}", "gists_url": "https://api.github.com/users/khuey/gists{/gist_id}", "starred_url": "https://api.github.com/users/khuey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/khuey/subscriptions", "organizations_url": "https://api.github.com/users/khuey/orgs", "repos_url": "https://api.github.com/users/khuey/repos", "events_url": "https://api.github.com/users/khuey/events{/privacy}", "received_events_url": "https://api.github.com/users/khuey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "khuey", "id": 325892, "node_id": "MDQ6VXNlcjMyNTg5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/325892?v=4", "gravatar_id": "", "url": "https://api.github.com/users/khuey", "html_url": "https://github.com/khuey", "followers_url": "https://api.github.com/users/khuey/followers", "following_url": "https://api.github.com/users/khuey/following{/other_user}", "gists_url": "https://api.github.com/users/khuey/gists{/gist_id}", "starred_url": "https://api.github.com/users/khuey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/khuey/subscriptions", "organizations_url": "https://api.github.com/users/khuey/orgs", "repos_url": "https://api.github.com/users/khuey/repos", "events_url": "https://api.github.com/users/khuey/events{/privacy}", "received_events_url": "https://api.github.com/users/khuey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5d8ef13d70c215ce369d035cc41ec2f2ba3d810", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d8ef13d70c215ce369d035cc41ec2f2ba3d810", "html_url": "https://github.com/rust-lang/rust/commit/d5d8ef13d70c215ce369d035cc41ec2f2ba3d810"}], "stats": {"total": 210, "additions": 167, "deletions": 43}, "files": [{"sha": "c987fdb1a6795331f0f2ed787f8921124eb1d725", "filename": "clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 101, "deletions": 42, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0", "patch": "@@ -1,11 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::indent_of;\n use clippy_utils::{is_default_equivalent, peel_blocks};\n use rustc_errors::Applicability;\n use rustc_hir::{\n-    def::{DefKind, Res},\n-    Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, TyKind,\n+    def::{CtorKind, CtorOf, DefKind, Res},\n+    Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, Ty, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{AdtDef, DefIdTree};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n \n@@ -61,6 +63,98 @@ fn is_path_self(e: &Expr<'_>) -> bool {\n     }\n }\n \n+fn check_struct<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    item: &'tcx Item<'_>,\n+    self_ty: &Ty<'_>,\n+    func_expr: &Expr<'_>,\n+    adt_def: AdtDef<'_>,\n+) {\n+    if let TyKind::Path(QPath::Resolved(_, p)) = self_ty.kind {\n+        if let Some(PathSegment { args: Some(a), .. }) = p.segments.last() {\n+            for arg in a.args {\n+                if !matches!(arg, GenericArg::Lifetime(_)) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+    let should_emit = match peel_blocks(func_expr).kind {\n+        ExprKind::Tup(fields) => fields.iter().all(|e| is_default_equivalent(cx, e)),\n+        ExprKind::Call(callee, args) if is_path_self(callee) => args.iter().all(|e| is_default_equivalent(cx, e)),\n+        ExprKind::Struct(_, fields, _) => fields.iter().all(|ef| is_default_equivalent(cx, ef.expr)),\n+        _ => false,\n+    };\n+\n+    if should_emit {\n+        let struct_span = cx.tcx.def_span(adt_def.did());\n+        span_lint_and_then(cx, DERIVABLE_IMPLS, item.span, \"this `impl` can be derived\", |diag| {\n+            diag.span_suggestion_hidden(\n+                item.span,\n+                \"remove the manual implementation...\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+            diag.span_suggestion(\n+                struct_span.shrink_to_lo(),\n+                \"...and instead derive it\",\n+                \"#[derive(Default)]\\n\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        });\n+    }\n+}\n+\n+fn check_enum<'tcx>(cx: &LateContext<'tcx>, item: &'tcx Item<'_>, func_expr: &Expr<'_>, adt_def: AdtDef<'_>) {\n+    if_chain! {\n+        if let ExprKind::Path(QPath::Resolved(None, p)) = &peel_blocks(func_expr).kind;\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = p.res;\n+        if let variant_id = cx.tcx.parent(id);\n+        if let Some(variant_def) = adt_def.variants().iter().find(|v| v.def_id == variant_id);\n+        if variant_def.fields.is_empty();\n+        if !variant_def.is_field_list_non_exhaustive();\n+\n+        then {\n+            let enum_span = cx.tcx.def_span(adt_def.did());\n+            let indent_enum = indent_of(cx, enum_span).unwrap_or(0);\n+            let variant_span = cx.tcx.def_span(variant_def.def_id);\n+            let indent_variant = indent_of(cx, variant_span).unwrap_or(0);\n+            span_lint_and_then(\n+                cx,\n+                DERIVABLE_IMPLS,\n+                item.span,\n+                \"this `impl` can be derived\",\n+                |diag| {\n+                    diag.span_suggestion_hidden(\n+                        item.span,\n+                        \"remove the manual implementation...\",\n+                        String::new(),\n+                        Applicability::MachineApplicable\n+                    );\n+                    diag.span_suggestion(\n+                        enum_span.shrink_to_lo(),\n+                        \"...and instead derive it...\",\n+                        format!(\n+                            \"#[derive(Default)]\\n{indent}\",\n+                            indent = \" \".repeat(indent_enum),\n+                        ),\n+                        Applicability::MachineApplicable\n+                    );\n+                    diag.span_suggestion(\n+                        variant_span.shrink_to_lo(),\n+                        \"...and mark the default variant\",\n+                        format!(\n+                            \"#[default]\\n{indent}\",\n+                            indent = \" \".repeat(indent_variant),\n+                        ),\n+                        Applicability::MachineApplicable\n+                    );\n+                }\n+            );\n+        }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n@@ -83,47 +177,12 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n             if !attrs.iter().any(|attr| attr.doc_str().is_some());\n             if let child_attrs = cx.tcx.hir().attrs(impl_item_hir);\n             if !child_attrs.iter().any(|attr| attr.doc_str().is_some());\n-            if adt_def.is_struct();\n-            then {\n-                if let TyKind::Path(QPath::Resolved(_, p)) = self_ty.kind {\n-                    if let Some(PathSegment { args: Some(a), .. }) = p.segments.last() {\n-                        for arg in a.args {\n-                            if !matches!(arg, GenericArg::Lifetime(_)) {\n-                                return;\n-                            }\n-                        }\n-                    }\n-                }\n-                let should_emit = match peel_blocks(func_expr).kind {\n-                    ExprKind::Tup(fields) => fields.iter().all(|e| is_default_equivalent(cx, e)),\n-                    ExprKind::Call(callee, args)\n-                        if is_path_self(callee) => args.iter().all(|e| is_default_equivalent(cx, e)),\n-                    ExprKind::Struct(_, fields, _) => fields.iter().all(|ef| is_default_equivalent(cx, ef.expr)),\n-                    _ => false,\n-                };\n \n-                if should_emit {\n-                    let struct_span = cx.tcx.def_span(adt_def.did());\n-                    span_lint_and_then(\n-                        cx,\n-                        DERIVABLE_IMPLS,\n-                        item.span,\n-                        \"this `impl` can be derived\",\n-                        |diag| {\n-                            diag.span_suggestion_hidden(\n-                                item.span,\n-                                \"remove the manual implementation...\",\n-                                String::new(),\n-                                Applicability::MachineApplicable\n-                            );\n-                            diag.span_suggestion(\n-                                struct_span.shrink_to_lo(),\n-                                \"...and instead derive it\",\n-                                \"#[derive(Default)]\\n\".to_string(),\n-                                Applicability::MachineApplicable\n-                            );\n-                        }\n-                    );\n+            then {\n+                if adt_def.is_struct() {\n+                    check_struct(cx, item, self_ty, func_expr, adt_def);\n+                } else if adt_def.is_enum() {\n+                    check_enum(cx, item, func_expr, adt_def);\n                 }\n             }\n         }"}, {"sha": "ee8456f5deb8ae89f3462f02d2ed2766378c10d6", "filename": "tests/ui/derivable_impls.fixed", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/tests%2Fui%2Fderivable_impls.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/tests%2Fui%2Fderivable_impls.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderivable_impls.fixed?ref=1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0", "patch": "@@ -210,4 +210,25 @@ impl Default for IntOrString {\n     }\n }\n \n+#[derive(Default)]\n+pub enum SimpleEnum {\n+    Foo,\n+    #[default]\n+    Bar,\n+}\n+\n+\n+\n+pub enum NonExhaustiveEnum {\n+    Foo,\n+    #[non_exhaustive]\n+    Bar,\n+}\n+\n+impl Default for NonExhaustiveEnum {\n+    fn default() -> Self {\n+        NonExhaustiveEnum::Bar\n+    }\n+}\n+\n fn main() {}"}, {"sha": "14af419bcad14ad3992a18a14cbd71099bd4afd5", "filename": "tests/ui/derivable_impls.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/tests%2Fui%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/tests%2Fui%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderivable_impls.rs?ref=1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0", "patch": "@@ -244,4 +244,27 @@ impl Default for IntOrString {\n     }\n }\n \n+pub enum SimpleEnum {\n+    Foo,\n+    Bar,\n+}\n+\n+impl Default for SimpleEnum {\n+    fn default() -> Self {\n+        SimpleEnum::Bar\n+    }\n+}\n+\n+pub enum NonExhaustiveEnum {\n+    Foo,\n+    #[non_exhaustive]\n+    Bar,\n+}\n+\n+impl Default for NonExhaustiveEnum {\n+    fn default() -> Self {\n+        NonExhaustiveEnum::Bar\n+    }\n+}\n+\n fn main() {}"}, {"sha": "81963c3be5b5d32478c63c7871e4e24d933f966e", "filename": "tests/ui/derivable_impls.stderr", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/tests%2Fui%2Fderivable_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0/tests%2Fui%2Fderivable_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderivable_impls.stderr?ref=1c42dbba60ece87f3031bc2dad5497f3cc9ad7d0", "patch": "@@ -113,5 +113,26 @@ help: ...and instead derive it\n LL | #[derive(Default)]\n    |\n \n-error: aborting due to 7 previous errors\n+error: this `impl` can be derived\n+  --> $DIR/derivable_impls.rs:252:1\n+   |\n+LL | / impl Default for SimpleEnum {\n+LL | |     fn default() -> Self {\n+LL | |         SimpleEnum::Bar\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = help: remove the manual implementation...\n+help: ...and instead derive it...\n+   |\n+LL | #[derive(Default)]\n+   |\n+help: ...and mark the default variant\n+   |\n+LL ~     #[default]\n+LL ~     Bar,\n+   |\n+\n+error: aborting due to 8 previous errors\n "}]}