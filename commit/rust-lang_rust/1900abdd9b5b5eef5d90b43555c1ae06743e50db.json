{"sha": "1900abdd9b5b5eef5d90b43555c1ae06743e50db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MDBhYmRkOWI1YjVlZWY1ZDkwYjQzNTU1YzFhZTA2NzQzZTUwZGI=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-07-10T15:53:51Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-07-15T17:55:20Z"}, "message": "Deprecate `str::from_utf16_lossy`\n\nUse `String::from_utf16_lossy` instead.\n\n[breaking-change]", "tree": {"sha": "6fa636e75b66c173547c770a89aad44246e85191", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fa636e75b66c173547c770a89aad44246e85191"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1900abdd9b5b5eef5d90b43555c1ae06743e50db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1900abdd9b5b5eef5d90b43555c1ae06743e50db", "html_url": "https://github.com/rust-lang/rust/commit/1900abdd9b5b5eef5d90b43555c1ae06743e50db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1900abdd9b5b5eef5d90b43555c1ae06743e50db/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ac4fc7fc2fb48599dbba55fcea5cfc1e6cd4602", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac4fc7fc2fb48599dbba55fcea5cfc1e6cd4602", "html_url": "https://github.com/rust-lang/rust/commit/6ac4fc7fc2fb48599dbba55fcea5cfc1e6cd4602"}], "stats": {"total": 217, "additions": 111, "deletions": 106}, "files": [{"sha": "e7536469a7ad6ee9ad9dffa4be17bc88e6e63c71", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 3, "deletions": 105, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1900abdd9b5b5eef5d90b43555c1ae06743e50db/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1900abdd9b5b5eef5d90b43555c1ae06743e50db/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=1900abdd9b5b5eef5d90b43555c1ae06743e50db", "patch": "@@ -384,23 +384,10 @@ pub fn from_utf16(v: &[u16]) -> Option<String> {\n     String::from_utf16(v)\n }\n \n-/// Decode a UTF-16 encoded vector `v` into a string, replacing\n-/// invalid data with the replacement character (U+FFFD).\n-///\n-/// # Example\n-/// ```rust\n-/// use std::str;\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///          0x0073, 0xDD1E, 0x0069, 0x0063,\n-///          0xD834];\n-///\n-/// assert_eq!(str::from_utf16_lossy(v),\n-///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_string());\n-/// ```\n+/// Deprecated. Use `String::from_utf16_lossy`.\n+#[deprecated = \"Replaced by String::from_utf16_lossy\"]\n pub fn from_utf16_lossy(v: &[u16]) -> String {\n-    utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+    String::from_utf16_lossy(v)\n }\n \n // Return the initial codepoint accumulator for the first byte.\n@@ -1655,95 +1642,6 @@ mod tests {\n         assert!(!\"\".contains_char('a'));\n     }\n \n-    #[test]\n-    fn test_utf16() {\n-        let pairs =\n-            [(String::from_str(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n-              vec![0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n-                0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n-                0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n-                0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n-\n-             (String::from_str(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n-              vec![0xd801_u16, 0xdc12_u16, 0xd801_u16,\n-                0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n-                0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n-                0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n-                0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n-                0x000a_u16]),\n-\n-             (String::from_str(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n-              vec![0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n-                0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n-                0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n-                0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n-                0xdf04_u16, 0xd800_u16, 0xdf15_u16, 0xd800_u16,\n-                0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n-                0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n-\n-             (String::from_str(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n-              vec![0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n-                0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n-                0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n-                0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n-                0xdc93_u16, 0x0020_u16, 0xd801_u16, 0xdc88_u16,\n-                0xd801_u16, 0xdc9a_u16, 0xd801_u16, 0xdc8d_u16,\n-                0x0020_u16, 0xd801_u16, 0xdc8f_u16, 0xd801_u16,\n-                0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n-                0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n-                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n-                0x000a_u16 ]),\n-             // Issue #12318, even-numbered non-BMP planes\n-             (String::from_str(\"\\U00020000\"),\n-              vec![0xD840, 0xDC00])];\n-\n-        for p in pairs.iter() {\n-            let (s, u) = (*p).clone();\n-            let s_as_utf16 = s.as_slice().utf16_units().collect::<Vec<u16>>();\n-            let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n-\n-            assert!(is_utf16(u.as_slice()));\n-            assert_eq!(s_as_utf16, u);\n-\n-            assert_eq!(u_as_string, s);\n-            assert_eq!(from_utf16_lossy(u.as_slice()), s);\n-\n-            assert_eq!(String::from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n-            assert_eq!(u_as_string.as_slice().utf16_units().collect::<Vec<u16>>(), u);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_utf16_invalid() {\n-        // completely positive cases tested above.\n-        // lead + eof\n-        assert_eq!(String::from_utf16([0xD800]), None);\n-        // lead + lead\n-        assert_eq!(String::from_utf16([0xD800, 0xD800]), None);\n-\n-        // isolated trail\n-        assert_eq!(String::from_utf16([0x0061, 0xDC00]), None);\n-\n-        // general\n-        assert_eq!(String::from_utf16([0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n-    }\n-\n-    #[test]\n-    fn test_utf16_lossy() {\n-        // completely positive cases tested above.\n-        // lead + eof\n-        assert_eq!(from_utf16_lossy([0xD800]), String::from_str(\"\\uFFFD\"));\n-        // lead + lead\n-        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), String::from_str(\"\\uFFFD\\uFFFD\"));\n-\n-        // isolated trail\n-        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), String::from_str(\"a\\uFFFD\"));\n-\n-        // general\n-        assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]),\n-                   String::from_str(\"\\uFFFD\ud801\udc8b\\uFFFD\"));\n-    }\n-\n     #[test]\n     fn test_truncate_utf16_at_nul() {\n         let v = [];"}, {"sha": "a5d66dd23ea140d92ec8f1f54a1f96fdf1858a4c", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1900abdd9b5b5eef5d90b43555c1ae06743e50db/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1900abdd9b5b5eef5d90b43555c1ae06743e50db/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=1900abdd9b5b5eef5d90b43555c1ae06743e50db", "patch": "@@ -117,6 +117,23 @@ impl String {\n         }\n         Some(s)\n     }\n+    \n+    /// Decode a UTF-16 encoded vector `v` into a string, replacing\n+    /// invalid data with the replacement character (U+FFFD).\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// // \u00f0\u009d\u201e\u017emus<invalid>ic<invalid>\n+    /// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+    ///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+    ///          0xD834];\n+    ///\n+    /// assert_eq!(String::from_utf16_lossy(v),\n+    ///            \"\u00f0\u009d\u201e\u017emus\\uFFFDic\\uFFFD\".to_string());\n+    /// ```\n+    pub fn from_utf16_lossy(v: &[u16]) -> String {\n+        str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+    }\n \n     /// Convert a vector of chars to a string\n     ///\n@@ -431,6 +448,7 @@ mod tests {\n     use test::Bencher;\n \n     use Mutable;\n+    use str;\n     use str::{Str, StrSlice};\n     use super::String;\n \n@@ -439,6 +457,95 @@ mod tests {\n       let owned: Option<::std::string::String> = from_str(\"string\");\n       assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n     }\n+    \n+    #[test]\n+    fn test_from_utf16() {\n+        let pairs =\n+            [(String::from_str(\"\u00f0\u0090\u008d\u2026\u00f0\u0090\u0152\u00bf\u00f0\u0090\u0152\u00bb\u00f0\u0090\u008d\u2020\u00f0\u0090\u0152\u00b9\u00f0\u0090\u0152\u00bb\u00f0\u0090\u0152\u00b0\\n\"),\n+              vec![0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n+                0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n+                0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n+                0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n+\n+             (String::from_str(\"\u00f0\u0090\u0090\u2019\u00f0\u0090\u2018\u2030\u00f0\u0090\u0090\u00ae\u00f0\u0090\u2018\u20ac\u00f0\u0090\u0090\u00b2\u00f0\u0090\u2018\u2039 \u00f0\u0090\u0090\u008f\u00f0\u0090\u0090\u00b2\u00f0\u0090\u2018\u008d\\n\"),\n+              vec![0xd801_u16, 0xdc12_u16, 0xd801_u16,\n+                0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n+                0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n+                0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n+                0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n+                0x000a_u16]),\n+\n+             (String::from_str(\"\u00f0\u0090\u0152\u20ac\u00f0\u0090\u0152\u2013\u00f0\u0090\u0152\u2039\u00f0\u0090\u0152\u201e\u00f0\u0090\u0152\u2018\u00f0\u0090\u0152\u2030\u00c2\u00b7\u00f0\u0090\u0152\u0152\u00f0\u0090\u0152\u201e\u00f0\u0090\u0152\u2022\u00f0\u0090\u0152\u201e\u00f0\u0090\u0152\u2039\u00f0\u0090\u0152\u2030\u00f0\u0090\u0152\u2018\\n\"),\n+              vec![0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n+                0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n+                0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n+                0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n+                0xdf04_u16, 0xd800_u16, 0xdf15_u16, 0xd800_u16,\n+                0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n+                0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n+\n+             (String::from_str(\"\u00f0\u0090\u2019\u2039\u00f0\u0090\u2019\u02dc\u00f0\u0090\u2019\u02c6\u00f0\u0090\u2019\u2018\u00f0\u0090\u2019\u203a\u00f0\u0090\u2019\u2019 \u00f0\u0090\u2019\u2022\u00f0\u0090\u2019\u201c \u00f0\u0090\u2019\u02c6\u00f0\u0090\u2019\u0161\u00f0\u0090\u2019\u008d \u00f0\u0090\u2019\u008f\u00f0\u0090\u2019\u0153\u00f0\u0090\u2019\u2019\u00f0\u0090\u2019\u2013\u00f0\u0090\u2019\u2020 \u00f0\u0090\u2019\u2022\u00f0\u0090\u2019\u2020\\n\"),\n+              vec![0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n+                0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n+                0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n+                0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n+                0xdc93_u16, 0x0020_u16, 0xd801_u16, 0xdc88_u16,\n+                0xd801_u16, 0xdc9a_u16, 0xd801_u16, 0xdc8d_u16,\n+                0x0020_u16, 0xd801_u16, 0xdc8f_u16, 0xd801_u16,\n+                0xdc9c_u16, 0xd801_u16, 0xdc92_u16, 0xd801_u16,\n+                0xdc96_u16, 0xd801_u16, 0xdc86_u16, 0x0020_u16,\n+                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n+                0x000a_u16 ]),\n+             // Issue #12318, even-numbered non-BMP planes\n+             (String::from_str(\"\\U00020000\"),\n+              vec![0xD840, 0xDC00])];\n+\n+        for p in pairs.iter() {\n+            let (s, u) = (*p).clone();\n+            let s_as_utf16 = s.as_slice().utf16_units().collect::<Vec<u16>>();\n+            let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n+\n+            assert!(str::is_utf16(u.as_slice()));\n+            assert_eq!(s_as_utf16, u);\n+\n+            assert_eq!(u_as_string, s);\n+            assert_eq!(String::from_utf16_lossy(u.as_slice()), s);\n+\n+            assert_eq!(String::from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n+            assert_eq!(u_as_string.as_slice().utf16_units().collect::<Vec<u16>>(), u);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_utf16_invalid() {\n+        // completely positive cases tested above.\n+        // lead + eof\n+        assert_eq!(String::from_utf16([0xD800]), None);\n+        // lead + lead\n+        assert_eq!(String::from_utf16([0xD800, 0xD800]), None);\n+\n+        // isolated trail\n+        assert_eq!(String::from_utf16([0x0061, 0xDC00]), None);\n+\n+        // general\n+        assert_eq!(String::from_utf16([0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n+    }\n+\n+    #[test]\n+    fn test_from_utf16_lossy() {\n+        // completely positive cases tested above.\n+        // lead + eof\n+        assert_eq!(String::from_utf16_lossy([0xD800]), String::from_str(\"\\uFFFD\"));\n+        // lead + lead\n+        assert_eq!(String::from_utf16_lossy([0xD800, 0xD800]), String::from_str(\"\\uFFFD\\uFFFD\"));\n+\n+        // isolated trail\n+        assert_eq!(String::from_utf16_lossy([0x0061, 0xDC00]), String::from_str(\"a\\uFFFD\"));\n+\n+        // general\n+        assert_eq!(String::from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]),\n+                   String::from_str(\"\\uFFFD\u00f0\u0090\u2019\u2039\\uFFFD\"));\n+    }\n \n     #[bench]\n     fn bench_with_capacity(b: &mut Bencher) {"}, {"sha": "9537d5daca0db0d8da60f70a23144c863c1c8b0d", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1900abdd9b5b5eef5d90b43555c1ae06743e50db/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1900abdd9b5b5eef5d90b43555c1ae06743e50db/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1900abdd9b5b5eef5d90b43555c1ae06743e50db", "patch": "@@ -266,7 +266,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n                 let p = &*ch.offset(i);\n                 let len = ptr::position(p, |c| *c == 0);\n                 raw::buf_as_slice(p, len, |s| {\n-                    result.push(str::from_utf16_lossy(s).into_bytes());\n+                    result.push(String::from_utf16_lossy(s).into_bytes());\n                 });\n                 i += len as int + 1;\n             }"}]}