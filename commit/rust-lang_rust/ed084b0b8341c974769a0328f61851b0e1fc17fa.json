{"sha": "ed084b0b8341c974769a0328f61851b0e1fc17fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMDg0YjBiODM0MWM5NzQ3NjlhMDMyOGY2MTg1MWIwZTFmYzE3ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-15T11:24:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-15T11:24:50Z"}, "message": "Auto merge of #69659 - CAD97:step-rework-take-3, r=Amanieu\n\nRework the std::iter::Step trait\n\nPrevious attempts: #43127 #62886 #68807\nTracking issue: #42168\n\nThis PR reworks the `Step` trait to be phrased in terms of the *successor* and *predecessor* operations. With this, `Step` hopefully has a consistent identity that can have a path towards stabilization. The proposed trait:\n\n```rust\n/// Objects that have a notion of *successor* and *predecessor* operations.\n///\n/// The *successor* operation moves towards values that compare greater.\n/// The *predecessor* operation moves towards values that compare lesser.\n///\n/// # Safety\n///\n/// This trait is `unsafe` because its implementation must be correct for\n/// the safety of `unsafe trait TrustedLen` implementations, and the results\n/// of using this trait can otherwise be trusted by `unsafe` code to be correct\n/// and fulful the listed obligations.\npub unsafe trait Step: Clone + PartialOrd + Sized {\n    /// Returns the number of *successor* steps required to get from `start` to `end`.\n    ///\n    /// Returns `None` if the number of steps would overflow `usize`\n    /// (or is infinite, or if `end` would never be reached).\n    ///\n    /// # Invariants\n    ///\n    /// For any `a`, `b`, and `n`:\n    ///\n    /// * `steps_between(&a, &b) == Some(n)` if and only if `Step::forward(&a, n) == Some(b)`\n    /// * `steps_between(&a, &b) == Some(n)` if and only if `Step::backward(&a, n) == Some(a)`\n    /// * `steps_between(&a, &b) == Some(n)` only if `a <= b`\n    ///   * Corollary: `steps_between(&a, &b) == Some(0)` if and only if `a == b`\n    ///   * Note that `a <= b` does _not_ imply `steps_between(&a, &b) != None`;\n    ///     this is the case wheen it would require more than `usize::MAX` steps to get to `b`\n    /// * `steps_between(&a, &b) == None` if `a > b`\n    fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n\n    /// Returns the value that would be obtained by taking the *successor*\n    /// of `self` `count` times.\n    ///\n    /// If this would overflow the range of values supported by `Self`, returns `None`.\n    ///\n    /// # Invariants\n    ///\n    /// For any `a`, `n`, and `m`:\n    ///\n    /// * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == Step::forward_checked(a, m).and_then(|x| Step::forward_checked(x, n))`\n    ///\n    /// For any `a`, `n`, and `m` where `n + m` does not overflow:\n    ///\n    /// * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == Step::forward_checked(a, n + m)`\n    ///\n    /// For any `a` and `n`:\n    ///\n    /// * `Step::forward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::forward_checked(&x, 1))`\n    ///   * Corollary: `Step::forward_checked(&a, 0) == Some(a)`\n    fn forward_checked(start: Self, count: usize) -> Option<Self>;\n\n    /// Returns the value that would be obtained by taking the *successor*\n    /// of `self` `count` times.\n    ///\n    /// If this would overflow the range of values supported by `Self`,\n    /// this function is allowed to panic, wrap, or saturate.\n    /// The suggested behavior is to panic when debug assertions are enabled,\n    /// and to wrap or saturate otherwise.\n    ///\n    /// Unsafe code should not rely on the correctness of behavior after overflow.\n    ///\n    /// # Invariants\n    ///\n    /// For any `a`, `n`, and `m`, where no overflow occurs:\n    ///\n    /// * `Step::forward(Step::forward(a, n), m) == Step::forward(a, n + m)`\n    ///\n    /// For any `a` and `n`, where no overflow occurs:\n    ///\n    /// * `Step::forward_checked(a, n) == Some(Step::forward(a, n))`\n    /// * `Step::forward(a, n) == (0..n).fold(a, |x, _| Step::forward(x, 1))`\n    ///   * Corollary: `Step::forward(a, 0) == a`\n    /// * `Step::forward(a, n) >= a`\n    /// * `Step::backward(Step::forward(a, n), n) == a`\n    fn forward(start: Self, count: usize) -> Self {\n        Step::forward_checked(start, count).expect(\"overflow in `Step::forward`\")\n    }\n\n    /// Returns the value that would be obtained by taking the *successor*\n    /// of `self` `count` times.\n    ///\n    /// # Safety\n    ///\n    /// It is undefined behavior for this operation to overflow the\n    /// range of values supported by `Self`. If you cannot guarantee that this\n    /// will not overflow, use `forward` or `forward_checked` instead.\n    ///\n    /// # Invariants\n    ///\n    /// For any `a`:\n    ///\n    /// * if there exists `b` such that `b > a`, it is safe to call `Step::forward_unchecked(a, 1)`\n    /// * if there exists `b`, `n` such that `steps_between(&a, &b) == Some(n)`,\n    ///   it is safe to call `Step::forward_unchecked(a, m)` for any `m <= n`.\n    ///\n    /// For any `a` and `n`, where no overflow occurs:\n    ///\n    /// * `Step::forward_unchecked(a, n)` is equivalent to `Step::forward(a, n)`\n    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n    unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n        Step::forward(start, count)\n    }\n\n    /// Returns the value that would be obtained by taking the *successor*\n    /// of `self` `count` times.\n    ///\n    /// If this would overflow the range of values supported by `Self`, returns `None`.\n    ///\n    /// # Invariants\n    ///\n    /// For any `a`, `n`, and `m`:\n    ///\n    /// * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == n.checked_add(m).and_then(|x| Step::backward_checked(a, x))`\n    /// * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == try { Step::backward_checked(a, n.checked_add(m)?) }`\n    ///\n    /// For any `a` and `n`:\n    ///\n    /// * `Step::backward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::backward_checked(&x, 1))`\n    ///   * Corollary: `Step::backward_checked(&a, 0) == Some(a)`\n    fn backward_checked(start: Self, count: usize) -> Option<Self>;\n\n    /// Returns the value that would be obtained by taking the *predecessor*\n    /// of `self` `count` times.\n    ///\n    /// If this would overflow the range of values supported by `Self`,\n    /// this function is allowed to panic, wrap, or saturate.\n    /// The suggested behavior is to panic when debug assertions are enabled,\n    /// and to wrap or saturate otherwise.\n    ///\n    /// Unsafe code should not rely on the correctness of behavior after overflow.\n    ///\n    /// # Invariants\n    ///\n    /// For any `a`, `n`, and `m`, where no overflow occurs:\n    ///\n    /// * `Step::backward(Step::backward(a, n), m) == Step::backward(a, n + m)`\n    ///\n    /// For any `a` and `n`, where no overflow occurs:\n    ///\n    /// * `Step::backward_checked(a, n) == Some(Step::backward(a, n))`\n    /// * `Step::backward(a, n) == (0..n).fold(a, |x, _| Step::backward(x, 1))`\n    ///   * Corollary: `Step::backward(a, 0) == a`\n    /// * `Step::backward(a, n) <= a`\n    /// * `Step::forward(Step::backward(a, n), n) == a`\n    fn backward(start: Self, count: usize) -> Self {\n        Step::backward_checked(start, count).expect(\"overflow in `Step::backward`\")\n    }\n\n    /// Returns the value that would be obtained by taking the *predecessor*\n    /// of `self` `count` times.\n    ///\n    /// # Safety\n    ///\n    /// It is undefined behavior for this operation to overflow the\n    /// range of values supported by `Self`. If you cannot guarantee that this\n    /// will not overflow, use `backward` or `backward_checked` instead.\n    ///\n    /// # Invariants\n    ///\n    /// For any `a`:\n    ///\n    /// * if there exists `b` such that `b < a`, it is safe to call `Step::backward_unchecked(a, 1)`\n    /// * if there exists `b`, `n` such that `steps_between(&b, &a) == Some(n)`,\n    ///   it is safe to call `Step::backward_unchecked(a, m)` for any `m <= n`.\n    ///\n    /// For any `a` and `n`, where no overflow occurs:\n    ///\n    /// * `Step::backward_unchecked(a, n)` is equivalent to `Step::backward(a, n)`\n    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n    unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n        Step::backward(start, count)\n    }\n}\n```\n\nNote that all of these are associated functions and not callable via method syntax; the calling syntax is always `Step::forward(start, n)`. This version of the trait additionally changes the stepping functions to talk their arguments by value.\n\nAs opposed to previous attempts which provided a \"step by one\" method directly, this version of the trait only exposes \"step by n\". There are a few reasons for this:\n\n- `Range*`, the primary consumer of `Step`, assumes that the \"step by n\" operation is cheap. If a single step function is provided, it will be a lot more enticing to implement \"step by n\" as n repeated calls to \"step by one\". While this is not strictly incorrect, this behavior would be surprising for anyone used to using `Range<{primitive integer}>`.\n- With a trivial default impl, this can be easily added backwards-compatibly later.\n- The debug-wrapping \"step by n\" needs to exist for `RangeFrom` to be consistent between \"step by n\" and \"step by one\" operation. (Note: the behavior is not changed by this PR, but making the behavior consistent is made tenable by this PR.)\n\nThree \"kinds\" of step are provided: `_checked`, which returns an `Option` indicating attempted overflow; (unsuffixed), which provides \"safe overflow\" behavior (is allowed to panic, wrap, or saturate, depending on what is most convenient for a given type); and `_unchecked`, which is a version which assumes overflow does not happen.\n\nReview is appreciated to check that:\n\n- The invariants as described on the `Step` functions are enough to specify the \"common sense\" consistency for successor/predecessor.\n- Implementation of `Step` functions is correct in the face of overflow and the edges of representable integers.\n- Added tests of `Step` functions are asserting the correct behavior (and not just the implemented behavior).", "tree": {"sha": "6d93d1a71e1103d031644369c537844c4c0e22c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d93d1a71e1103d031644369c537844c4c0e22c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed084b0b8341c974769a0328f61851b0e1fc17fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed084b0b8341c974769a0328f61851b0e1fc17fa", "html_url": "https://github.com/rust-lang/rust/commit/ed084b0b8341c974769a0328f61851b0e1fc17fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed084b0b8341c974769a0328f61851b0e1fc17fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "027149919e36ce5645ca5d02d55b97ef52eb55ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/027149919e36ce5645ca5d02d55b97ef52eb55ba", "html_url": "https://github.com/rust-lang/rust/commit/027149919e36ce5645ca5d02d55b97ef52eb55ba"}, {"sha": "d53068e3ea607ba757eeb496376fc955c5a85055", "url": "https://api.github.com/repos/rust-lang/rust/commits/d53068e3ea607ba757eeb496376fc955c5a85055", "html_url": "https://github.com/rust-lang/rust/commit/d53068e3ea607ba757eeb496376fc955c5a85055"}], "stats": {"total": 864, "additions": 619, "deletions": 245}, "files": [{"sha": "d74df82bddd9d97f2709597163b4a74bf9157656", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 411, "deletions": 171, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=ed084b0b8341c974769a0328f61851b0e1fc17fa", "patch": "@@ -4,175 +4,401 @@ use crate::ops::{self, Add, Sub, Try};\n \n use super::{FusedIterator, TrustedLen};\n \n-/// Objects that can be stepped over in both directions.\n+/// Objects that have a notion of *successor* and *predecessor* operations.\n ///\n-/// The `steps_between` function provides a way to efficiently compare\n-/// two `Step` objects.\n-#[unstable(\n-    feature = \"step_trait\",\n-    reason = \"likely to be replaced by finer-grained traits\",\n-    issue = \"42168\"\n-)]\n-pub trait Step: Clone + PartialOrd + Sized {\n-    /// Returns the number of steps between two step objects. The count is\n-    /// inclusive of `start` and exclusive of `end`.\n-    ///\n-    /// Returns `None` if it is not possible to calculate `steps_between`\n-    /// without overflow.\n+/// The *successor* operation moves towards values that compare greater.\n+/// The *predecessor* operation moves towards values that compare lesser.\n+///\n+/// # Safety\n+///\n+/// This trait is `unsafe` because its implementation must be correct for\n+/// the safety of `unsafe trait TrustedLen` implementations, and the results\n+/// of using this trait can otherwise be trusted by `unsafe` code to be correct\n+/// and fulfill the listed obligations.\n+#[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+pub unsafe trait Step: Clone + PartialOrd + Sized {\n+    /// Returns the number of *successor* steps required to get from `start` to `end`.\n+    ///\n+    /// Returns `None` if the number of steps would overflow `usize`\n+    /// (or is infinite, or if `end` would never be reached).\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `b`, and `n`:\n+    ///\n+    /// * `steps_between(&a, &b) == Some(n)` if and only if `Step::forward_checked(&a, n) == Some(b)`\n+    /// * `steps_between(&a, &b) == Some(n)` if and only if `Step::backward_checked(&a, n) == Some(a)`\n+    /// * `steps_between(&a, &b) == Some(n)` only if `a <= b`\n+    ///   * Corollary: `steps_between(&a, &b) == Some(0)` if and only if `a == b`\n+    ///   * Note that `a <= b` does _not_ imply `steps_between(&a, &b) != None`;\n+    ///     this is the case wheen it would require more than `usize::MAX` steps to get to `b`\n+    /// * `steps_between(&a, &b) == None` if `a > b`\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n-    /// Replaces this step with `1`, returning a clone of itself.\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`, returns `None`.\n     ///\n-    /// The output of this method should always be greater than the output of replace_zero.\n-    fn replace_one(&mut self) -> Self;\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`:\n+    ///\n+    /// * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == Step::forward_checked(a, m).and_then(|x| Step::forward_checked(x, n))`\n+    ///\n+    /// For any `a`, `n`, and `m` where `n + m` does not overflow:\n+    ///\n+    /// * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == Step::forward_checked(a, n + m)`\n+    ///\n+    /// For any `a` and `n`:\n+    ///\n+    /// * `Step::forward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::forward_checked(&x, 1))`\n+    ///   * Corollary: `Step::forward_checked(&a, 0) == Some(a)`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn forward_checked(start: Self, count: usize) -> Option<Self>;\n \n-    /// Replaces this step with `0`, returning a clone of itself.\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`,\n+    /// this function is allowed to panic, wrap, or saturate.\n+    /// The suggested behavior is to panic when debug assertions are enabled,\n+    /// and to wrap or saturate otherwise.\n     ///\n-    /// The output of this method should always be less than the output of replace_one.\n-    fn replace_zero(&mut self) -> Self;\n+    /// Unsafe code should not rely on the correctness of behavior after overflow.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`, where no overflow occurs:\n+    ///\n+    /// * `Step::forward(Step::forward(a, n), m) == Step::forward(a, n + m)`\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::forward_checked(a, n) == Some(Step::forward(a, n))`\n+    /// * `Step::forward(a, n) == (0..n).fold(a, |x, _| Step::forward(x, 1))`\n+    ///   * Corollary: `Step::forward(a, 0) == a`\n+    /// * `Step::forward(a, n) >= a`\n+    /// * `Step::backward(Step::forward(a, n), n) == a`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn forward(start: Self, count: usize) -> Self {\n+        Step::forward_checked(start, count).expect(\"overflow in `Step::forward`\")\n+    }\n \n-    /// Adds one to this step, returning the result.\n-    fn add_one(&self) -> Self;\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is undefined behavior for this operation to overflow the\n+    /// range of values supported by `Self`. If you cannot guarantee that this\n+    /// will not overflow, use `forward` or `forward_checked` instead.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`:\n+    ///\n+    /// * if there exists `b` such that `b > a`, it is safe to call `Step::forward_unchecked(a, 1)`\n+    /// * if there exists `b`, `n` such that `steps_between(&a, &b) == Some(n)`,\n+    ///   it is safe to call `Step::forward_unchecked(a, m)` for any `m <= n`.\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::forward_unchecked(a, n)` is equivalent to `Step::forward(a, n)`\n+    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n+    unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n+        Step::forward(start, count)\n+    }\n \n-    /// Subtracts one to this step, returning the result.\n-    fn sub_one(&self) -> Self;\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`, returns `None`.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`:\n+    ///\n+    /// * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == n.checked_add(m).and_then(|x| Step::backward_checked(a, x))`\n+    /// * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == try { Step::backward_checked(a, n.checked_add(m)?) }`\n+    ///\n+    /// For any `a` and `n`:\n+    ///\n+    /// * `Step::backward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::backward_checked(&x, 1))`\n+    ///   * Corollary: `Step::backward_checked(&a, 0) == Some(a)`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn backward_checked(start: Self, count: usize) -> Option<Self>;\n \n-    /// Adds a `usize`, returning `None` on overflow.\n-    fn add_usize(&self, n: usize) -> Option<Self>;\n+    /// Returns the value that would be obtained by taking the *predecessor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`,\n+    /// this function is allowed to panic, wrap, or saturate.\n+    /// The suggested behavior is to panic when debug assertions are enabled,\n+    /// and to wrap or saturate otherwise.\n+    ///\n+    /// Unsafe code should not rely on the correctness of behavior after overflow.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward(Step::backward(a, n), m) == Step::backward(a, n + m)`\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward_checked(a, n) == Some(Step::backward(a, n))`\n+    /// * `Step::backward(a, n) == (0..n).fold(a, |x, _| Step::backward(x, 1))`\n+    ///   * Corollary: `Step::backward(a, 0) == a`\n+    /// * `Step::backward(a, n) <= a`\n+    /// * `Step::forward(Step::backward(a, n), n) == a`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn backward(start: Self, count: usize) -> Self {\n+        Step::backward_checked(start, count).expect(\"overflow in `Step::backward`\")\n+    }\n \n-    /// Subtracts a `usize`, returning `None` on underflow.\n-    fn sub_usize(&self, n: usize) -> Option<Self> {\n-        // this default implementation makes the addition of `sub_usize` a non-breaking change\n-        let _ = n;\n-        unimplemented!()\n+    /// Returns the value that would be obtained by taking the *predecessor*\n+    /// of `self` `count` times.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is undefined behavior for this operation to overflow the\n+    /// range of values supported by `Self`. If you cannot guarantee that this\n+    /// will not overflow, use `backward` or `backward_checked` instead.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`:\n+    ///\n+    /// * if there exists `b` such that `b < a`, it is safe to call `Step::backward_unchecked(a, 1)`\n+    /// * if there exists `b`, `n` such that `steps_between(&b, &a) == Some(n)`,\n+    ///   it is safe to call `Step::backward_unchecked(a, m)` for any `m <= n`.\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward_unchecked(a, n)` is equivalent to `Step::backward(a, n)`\n+    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n+    unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n+        Step::backward(start, count)\n     }\n }\n \n // These are still macro-generated because the integer literals resolve to different types.\n macro_rules! step_identical_methods {\n     () => {\n         #[inline]\n-        fn replace_one(&mut self) -> Self {\n-            mem::replace(self, 1)\n+        unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n+            start.unchecked_add(n as Self)\n         }\n \n         #[inline]\n-        fn replace_zero(&mut self) -> Self {\n-            mem::replace(self, 0)\n+        unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n+            start.unchecked_sub(n as Self)\n         }\n \n         #[inline]\n-        fn add_one(&self) -> Self {\n-            Add::add(*self, 1)\n+        fn forward(start: Self, n: usize) -> Self {\n+            // In debug builds, trigger a panic on overflow.\n+            // This should optimize completely out in release builds.\n+            if Self::forward_checked(start, n).is_none() {\n+                let _ = Add::add(Self::MAX, 1);\n+            }\n+            // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.\n+            start.wrapping_add(n as Self)\n         }\n \n         #[inline]\n-        fn sub_one(&self) -> Self {\n-            Sub::sub(*self, 1)\n+        fn backward(start: Self, n: usize) -> Self {\n+            // In debug builds, trigger a panic on overflow.\n+            // This should optimize completely out in release builds.\n+            if Self::backward_checked(start, n).is_none() {\n+                let _ = Sub::sub(Self::MIN, 1);\n+            }\n+            // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.\n+            start.wrapping_sub(n as Self)\n         }\n     };\n }\n \n-macro_rules! step_impl_unsigned {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"step_trait\",\n-                   reason = \"likely to be replaced by finer-grained traits\",\n-                   issue = \"42168\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n-                if *start < *end {\n-                    usize::try_from(*end - *start).ok()\n-                } else {\n-                    Some(0)\n+macro_rules! step_integer_impls {\n+    {\n+        narrower than or same width as usize:\n+            $( [ $u_narrower:ident $i_narrower:ident ] ),+;\n+        wider than usize:\n+            $( [ $u_wider:ident $i_wider:ident ] ),+;\n+    } => {\n+        $(\n+            #[allow(unreachable_patterns)]\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $u_narrower {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        // This relies on $u_narrower <= usize\n+                        Some((*end - *start) as usize)\n+                    } else {\n+                        None\n+                    }\n                 }\n-            }\n \n-            #[inline]\n-            #[allow(unreachable_patterns)]\n-            fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n-                    Ok(n_as_t) => self.checked_add(n_as_t),\n-                    Err(_) => None,\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match Self::try_from(n) {\n+                        Ok(n) => start.checked_add(n),\n+                        Err(_) => None, // if n is out of range, `unsigned_start + n` is too\n+                    }\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match Self::try_from(n) {\n+                        Ok(n) => start.checked_sub(n),\n+                        Err(_) => None, // if n is out of range, `unsigned_start - n` is too\n+                    }\n                 }\n             }\n \n-            #[inline]\n             #[allow(unreachable_patterns)]\n-            fn sub_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n-                    Ok(n_as_t) => self.checked_sub(n_as_t),\n-                    Err(_) => None,\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $i_narrower {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        // This relies on $i_narrower <= usize\n+                        //\n+                        // Casting to isize extends the width but preserves the sign.\n+                        // Use wrapping_sub in isize space and cast to usize to compute\n+                        // the difference that may not fit inside the range of isize.\n+                        Some((*end as isize).wrapping_sub(*start as isize) as usize)\n+                    } else {\n+                        None\n+                    }\n                 }\n-            }\n \n-            step_identical_methods!();\n-        }\n-    )*)\n-}\n-macro_rules! step_impl_signed {\n-    ($( [$t:ty : $unsigned:ty] )*) => ($(\n-        #[unstable(feature = \"step_trait\",\n-                   reason = \"likely to be replaced by finer-grained traits\",\n-                   issue = \"42168\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n-                if *start < *end {\n-                    // Use .wrapping_sub and cast to unsigned to compute the\n-                    // difference that may not fit inside the range of $t.\n-                    usize::try_from(end.wrapping_sub(*start) as $unsigned).ok()\n-                } else {\n-                    Some(0)\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match $u_narrower::try_from(n) {\n+                        Ok(n) => {\n+                            // Wrapping handles cases like\n+                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n+                            // even though 200 is out of range for i8.\n+                            let wrapped = start.wrapping_add(n as Self);\n+                            if wrapped >= start {\n+                                Some(wrapped)\n+                            } else {\n+                                None // Addition overflowed\n+                            }\n+                        }\n+                        // If n is out of range of e.g. u8,\n+                        // then it is bigger than the entire range for i8 is wide\n+                        // so `any_i8 + n` necessarily overflows i8.\n+                        Err(_) => None,\n+                    }\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match $u_narrower::try_from(n) {\n+                        Ok(n) => {\n+                            // Wrapping handles cases like\n+                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n+                            // even though 200 is out of range for i8.\n+                            let wrapped = start.wrapping_sub(n as Self);\n+                            if wrapped <= start {\n+                                Some(wrapped)\n+                            } else {\n+                                None // Subtraction overflowed\n+                            }\n+                        }\n+                        // If n is out of range of e.g. u8,\n+                        // then it is bigger than the entire range for i8 is wide\n+                        // so `any_i8 - n` necessarily overflows i8.\n+                        Err(_) => None,\n+                    }\n                 }\n             }\n+        )+\n \n-            #[inline]\n+        $(\n             #[allow(unreachable_patterns)]\n-            fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n-                    Ok(n_as_unsigned) => {\n-                        // Wrapping in unsigned space handles cases like\n-                        // `-120_i8.add_usize(200) == Some(80_i8)`,\n-                        // even though 200_usize is out of range for i8.\n-                        let wrapped = (*self as $unsigned).wrapping_add(n_as_unsigned) as $t;\n-                        if wrapped >= *self {\n-                            Some(wrapped)\n-                        } else {\n-                            None  // Addition overflowed\n-                        }\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $u_wider {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        usize::try_from(*end - *start).ok()\n+                    } else {\n+                        None\n                     }\n-                    Err(_) => None,\n+                }\n+\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_add(n as Self)\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_sub(n as Self)\n                 }\n             }\n \n-            #[inline]\n             #[allow(unreachable_patterns)]\n-            fn sub_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n-                    Ok(n_as_unsigned) => {\n-                        // Wrapping in unsigned space handles cases like\n-                        // `80_i8.sub_usize(200) == Some(-120_i8)`,\n-                        // even though 200_usize is out of range for i8.\n-                        let wrapped = (*self as $unsigned).wrapping_sub(n_as_unsigned) as $t;\n-                        if wrapped <= *self {\n-                            Some(wrapped)\n-                        } else {\n-                            None  // Subtraction underflowed\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $i_wider {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        match end.checked_sub(*start) {\n+                            Some(result) => usize::try_from(result).ok(),\n+                            // If the difference is too big for e.g. i128,\n+                            // it's also gonna be too big for usize with fewer bits.\n+                            None => None,\n                         }\n+                    } else {\n+                        None\n                     }\n-                    Err(_) => None,\n+                }\n+\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_add(n as Self)\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_sub(n as Self)\n                 }\n             }\n+        )+\n+    };\n+}\n \n-            step_identical_methods!();\n-        }\n-    )*)\n+#[cfg(target_pointer_width = \"64\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [u64 i64], [usize isize];\n+    wider than usize: [u128 i128];\n }\n \n-step_impl_unsigned!(usize u8 u16 u32 u64 u128);\n-step_impl_signed!([isize: usize][i8: u8][i16: u16]);\n-step_impl_signed!([i32: u32][i64: u64][i128: u128]);\n+#[cfg(target_pointer_width = \"32\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [usize isize];\n+    wider than usize: [u64 i64], [u128 i128];\n+}\n+\n+#[cfg(target_pointer_width = \"16\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [usize isize];\n+    wider than usize: [u32 i32], [u64 i64], [u128 i128];\n+}\n \n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n@@ -188,55 +414,39 @@ macro_rules! range_incl_exact_iter_impl {\n     )*)\n }\n \n-macro_rules! range_trusted_len_impl {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::Range<$t> { }\n-    )*)\n-}\n-\n-macro_rules! range_incl_trusted_len_impl {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n-    )*)\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> Iterator for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            // We check for overflow here, even though it can't actually\n-            // happen. Adding this check does however help llvm vectorize loops\n-            // for some ranges that don't get vectorized otherwise,\n-            // and this won't actually result in an extra check in an optimized build.\n-            if let Some(mut n) = self.start.add_usize(1) {\n-                mem::swap(&mut n, &mut self.start);\n-                Some(n)\n-            } else {\n-                None\n-            }\n+            // SAFETY: just checked precondition\n+            // We use the unchecked version here, because\n+            // this helps LLVM vectorize loops for some ranges\n+            // that don't get vectorized otherwise.\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            Some(mem::replace(&mut self.start, n))\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match Step::steps_between(&self.start, &self.end) {\n-            Some(hint) => (hint, Some(hint)),\n-            None => (usize::MAX, None),\n+        if self.start < self.end {\n+            let hint = Step::steps_between(&self.start, &self.end);\n+            (hint.unwrap_or(usize::MAX), hint)\n+        } else {\n+            (0, Some(0))\n         }\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        if let Some(plus_n) = self.start.add_usize(n) {\n+        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n             if plus_n < self.end {\n-                self.start = plus_n.add_one();\n+                self.start = Step::forward(plus_n.clone(), 1);\n                 return Some(plus_n);\n             }\n         }\n@@ -262,25 +472,42 @@ impl<A: Step> Iterator for ops::Range<A> {\n }\n \n // These macros generate `ExactSizeIterator` impls for various range types.\n-// Range<{u,i}64> and RangeInclusive<{u,i}{32,64,size}> are excluded\n-// because they cannot guarantee having a length <= usize::MAX, which is\n-// required by ExactSizeIterator.\n-range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n-range_incl_exact_iter_impl!(u8 u16 i8 i16);\n-\n-// These macros generate `TrustedLen` impls.\n //\n-// They need to guarantee that .size_hint() is either exact, or that\n-// the upper bound is None when it does not fit the type limits.\n-range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n-range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n+// * `ExactSizeIterator::len` is required to always return an exact `usize`,\n+//   so no range can be longer than `usize::MAX`.\n+// * For integer types in `Range<_>` this is the case for types narrower than or as wide as `usize`.\n+//   For integer types in `RangeInclusive<_>`\n+//   this is the case for types *strictly narrower* than `usize`\n+//   since e.g. `(0..=u64::MAX).len()` would be `u64::MAX + 1`.\n+range_exact_iter_impl! {\n+    usize u8 u16\n+    isize i8 i16\n+\n+    // These are incorect per the reasoning above,\n+    // but removing them would be a breaking change as they were stabilized in Rust 1.0.0.\n+    // So e.g. `(0..66_000_u32).len()` for example will compile without error or warnings\n+    // on 16-bit platforms, but continue to give a wrong result.\n+    u32\n+    i32\n+}\n+range_incl_exact_iter_impl! {\n+    u8\n+    i8\n+\n+    // These are incorect per the reasoning above,\n+    // but removing them would be a breaking change as they were stabilized in Rust 1.26.0.\n+    // So e.g. `(0..=u16::MAX).len()` for example will compile without error or warnings\n+    // on 16-bit platforms, but continue to give a wrong result.\n+    u16\n+    i16\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            self.end = self.end.sub_one();\n+            self.end = Step::backward(self.end.clone(), 1);\n             Some(self.end.clone())\n         } else {\n             None\n@@ -289,9 +516,9 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        if let Some(minus_n) = self.end.sub_usize(n) {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n             if minus_n > self.start {\n-                self.end = minus_n.sub_one();\n+                self.end = Step::backward(minus_n, 1);\n                 return Some(self.end.clone());\n             }\n         }\n@@ -301,6 +528,9 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Step> TrustedLen for ops::Range<A> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::Range<A> {}\n \n@@ -310,9 +540,8 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let mut n = self.start.add_one();\n-        mem::swap(&mut n, &mut self.start);\n-        Some(n)\n+        let n = Step::forward(self.start.clone(), 1);\n+        Some(mem::replace(&mut self.start, n))\n     }\n \n     #[inline]\n@@ -322,8 +551,16 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        let plus_n = self.start.add_usize(n).expect(\"overflow in RangeFrom::nth\");\n-        self.start = plus_n.add_one();\n+        // If we would jump over the maximum value, panic immediately.\n+        // This is consistent with behavior before the Step redesign,\n+        // even though it's inconsistent with n `next` calls.\n+        // To get consistent behavior, change it to use `forward` instead.\n+        // This change should go through FCP separately to the redesign, so is for now left as a\n+        // FIXME: make this consistent\n+        let plus_n =\n+            Step::forward_checked(self.start.clone(), n).expect(\"overflow in RangeFrom::nth\");\n+        // The final step should always be debug-checked.\n+        self.start = Step::forward(plus_n.clone(), 1);\n         Some(plus_n)\n     }\n }\n@@ -345,7 +582,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = self.start.add_one();\n+            let n = Step::forward(self.start.clone(), 1);\n             mem::replace(&mut self.start, n)\n         } else {\n             self.exhausted = true;\n@@ -371,12 +608,12 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n             return None;\n         }\n \n-        if let Some(plus_n) = self.start.add_usize(n) {\n+        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n             use crate::cmp::Ordering::*;\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n-                    self.start = plus_n.add_one();\n+                    self.start = Step::forward(plus_n.clone(), 1);\n                     return Some(plus_n);\n                 }\n                 Some(Equal) => {\n@@ -407,7 +644,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         let mut accum = init;\n \n         while self.start < self.end {\n-            let n = self.start.add_one();\n+            let n = Step::forward(self.start.clone(), 1);\n             let n = mem::replace(&mut self.start, n);\n             accum = f(accum, n)?;\n         }\n@@ -446,7 +683,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = self.end.sub_one();\n+            let n = Step::backward(self.end.clone(), 1);\n             mem::replace(&mut self.end, n)\n         } else {\n             self.exhausted = true;\n@@ -460,12 +697,12 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             return None;\n         }\n \n-        if let Some(minus_n) = self.end.sub_usize(n) {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n             use crate::cmp::Ordering::*;\n \n             match minus_n.partial_cmp(&self.start) {\n                 Some(Greater) => {\n-                    self.end = minus_n.sub_one();\n+                    self.end = Step::backward(minus_n.clone(), 1);\n                     return Some(minus_n);\n                 }\n                 Some(Equal) => {\n@@ -496,7 +733,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         let mut accum = init;\n \n         while self.start < self.end {\n-            let n = self.end.sub_one();\n+            let n = Step::backward(self.end.clone(), 1);\n             let n = mem::replace(&mut self.end, n);\n             accum = f(accum, n)?;\n         }\n@@ -511,5 +748,8 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Step> TrustedLen for ops::RangeInclusive<A> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}"}, {"sha": "9b4872f5d9f7adab3e6d1aa7825c0a3c29cec0e1", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ed084b0b8341c974769a0328f61851b0e1fc17fa", "patch": "@@ -749,6 +749,23 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer addition. Computes `self + rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self + rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_add(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer subtraction. Computes `self - rhs`, returning `None` if\n overflow occurred.\n@@ -774,6 +791,23 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self - rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_sub(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer multiplication. Computes `self * rhs`, returning `None` if\n overflow occurred.\n@@ -799,6 +833,23 @@ $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self * rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_mul(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n or the division results in overflow.\n@@ -2936,6 +2987,23 @@ assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\", $EndFeat\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer addition. Computes `self + rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self + rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self + rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_add(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n@@ -2959,6 +3027,23 @@ assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer subtraction. Computes `self - rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self - rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self - rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_sub(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n@@ -2982,6 +3067,23 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\", $EndFeature, \"\n             }\n         }\n \n+        doc_comment! {\n+            concat!(\"Unchecked integer multiplication. Computes `self * rhs, assuming overflow\n+cannot occur. This results in undefined behavior when `self * rhs > \", stringify!($SelfT),\n+\"::max_value()` or `self * rhs < \", stringify!($SelfT), \"::min_value()`.\"),\n+            #[unstable(\n+                feature = \"unchecked_math\",\n+                reason = \"niche optimization path\",\n+                issue = \"none\",\n+            )]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n+            #[inline]\n+            pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n+                intrinsics::unchecked_mul(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Checked integer division. Computes `self / rhs`, returning `None`\n if `rhs == 0`."}, {"sha": "52cf068f0a56720c362035ff494b6453fb35c51f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 94, "deletions": 27, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=ed084b0b8341c974769a0328f61851b0e1fc17fa", "patch": "@@ -2139,6 +2139,24 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n+#[test]\n+fn test_range_len() {\n+    assert_eq!((0..10_u8).len(), 10);\n+    assert_eq!((9..10_u8).len(), 1);\n+    assert_eq!((10..10_u8).len(), 0);\n+    assert_eq!((11..10_u8).len(), 0);\n+    assert_eq!((100..10_u8).len(), 0);\n+}\n+\n+#[test]\n+fn test_range_inclusive_len() {\n+    assert_eq!((0..=10_u8).len(), 11);\n+    assert_eq!((9..=10_u8).len(), 2);\n+    assert_eq!((10..=10_u8).len(), 1);\n+    assert_eq!((11..=10_u8).len(), 0);\n+    assert_eq!((100..=10_u8).len(), 0);\n+}\n+\n #[test]\n fn test_range_step() {\n     #![allow(deprecated)]\n@@ -2509,42 +2527,91 @@ fn test_chain_fold() {\n }\n \n #[test]\n-fn test_step_replace_unsigned() {\n-    let mut x = 4u32;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_steps_between() {\n+    assert_eq!(Step::steps_between(&20_u8, &200_u8), Some(180_usize));\n+    assert_eq!(Step::steps_between(&-20_i8, &80_i8), Some(100_usize));\n+    assert_eq!(Step::steps_between(&-120_i8, &80_i8), Some(200_usize));\n+    assert_eq!(Step::steps_between(&20_u32, &4_000_100_u32), Some(4_000_080_usize));\n+    assert_eq!(Step::steps_between(&-20_i32, &80_i32), Some(100_usize));\n+    assert_eq!(Step::steps_between(&-2_000_030_i32, &2_000_050_i32), Some(4_000_080_usize));\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    // Skip u64/i64 to avoid differences with 32-bit vs 64-bit platforms\n+\n+    assert_eq!(Step::steps_between(&20_u128, &200_u128), Some(180_usize));\n+    assert_eq!(Step::steps_between(&-20_i128, &80_i128), Some(100_usize));\n+    if cfg!(target_pointer_width = \"64\") {\n+        assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_0009_u128), Some(usize::MAX));\n+    }\n+    assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_000a_u128), None);\n+    assert_eq!(Step::steps_between(&10_i128, &0x1_0000_0000_0000_000a_i128), None);\n+    assert_eq!(\n+        Step::steps_between(&-0x1_0000_0000_0000_0000_i128, &0x1_0000_0000_0000_0000_i128,),\n+        None,\n+    );\n }\n \n #[test]\n-fn test_step_replace_signed() {\n-    let mut x = 4i32;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_step_forward() {\n+    assert_eq!(Step::forward_checked(55_u8, 200_usize), Some(255_u8));\n+    assert_eq!(Step::forward_checked(252_u8, 200_usize), None);\n+    assert_eq!(Step::forward_checked(0_u8, 256_usize), None);\n+    assert_eq!(Step::forward_checked(-110_i8, 200_usize), Some(90_i8));\n+    assert_eq!(Step::forward_checked(-110_i8, 248_usize), None);\n+    assert_eq!(Step::forward_checked(-126_i8, 256_usize), None);\n+\n+    assert_eq!(Step::forward_checked(35_u16, 100_usize), Some(135_u16));\n+    assert_eq!(Step::forward_checked(35_u16, 65500_usize), Some(u16::MAX));\n+    assert_eq!(Step::forward_checked(36_u16, 65500_usize), None);\n+    assert_eq!(Step::forward_checked(-110_i16, 200_usize), Some(90_i16));\n+    assert_eq!(Step::forward_checked(-20_030_i16, 50_050_usize), Some(30_020_i16));\n+    assert_eq!(Step::forward_checked(-10_i16, 40_000_usize), None);\n+    assert_eq!(Step::forward_checked(-10_i16, 70_000_usize), None);\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    assert_eq!(Step::forward_checked(10_u128, 70_000_usize), Some(70_010_u128));\n+    assert_eq!(Step::forward_checked(10_i128, 70_030_usize), Some(70_040_i128));\n+    assert_eq!(\n+        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0xff_usize),\n+        Some(u128::MAX),\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0x100_usize),\n+        None\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0xff_usize),\n+        Some(i128::MAX),\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n+        None\n+    );\n }\n \n #[test]\n-fn test_step_replace_no_between() {\n-    let mut x = 4u128;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_step_backward() {\n+    assert_eq!(Step::backward_checked(255_u8, 200_usize), Some(55_u8));\n+    assert_eq!(Step::backward_checked(100_u8, 200_usize), None);\n+    assert_eq!(Step::backward_checked(255_u8, 256_usize), None);\n+    assert_eq!(Step::backward_checked(90_i8, 200_usize), Some(-110_i8));\n+    assert_eq!(Step::backward_checked(110_i8, 248_usize), None);\n+    assert_eq!(Step::backward_checked(127_i8, 256_usize), None);\n+\n+    assert_eq!(Step::backward_checked(135_u16, 100_usize), Some(35_u16));\n+    assert_eq!(Step::backward_checked(u16::MAX, 65500_usize), Some(35_u16));\n+    assert_eq!(Step::backward_checked(10_u16, 11_usize), None);\n+    assert_eq!(Step::backward_checked(90_i16, 200_usize), Some(-110_i16));\n+    assert_eq!(Step::backward_checked(30_020_i16, 50_050_usize), Some(-20_030_i16));\n+    assert_eq!(Step::backward_checked(-10_i16, 40_000_usize), None);\n+    assert_eq!(Step::backward_checked(-10_i16, 70_000_usize), None);\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    assert_eq!(Step::backward_checked(70_010_u128, 70_000_usize), Some(10_u128));\n+    assert_eq!(Step::backward_checked(70_020_i128, 70_030_usize), Some(-10_i128));\n+    assert_eq!(Step::backward_checked(10_u128, 7_usize), Some(3_u128));\n+    assert_eq!(Step::backward_checked(10_u128, 11_usize), None);\n+    assert_eq!(\n+        Step::backward_checked(-0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n+        Some(i128::MIN)\n+    );\n }\n \n #[test]"}, {"sha": "d636542d699f932a232a52311d8e139c58a4b252", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=ed084b0b8341c974769a0328f61851b0e1fc17fa", "patch": "@@ -22,6 +22,7 @@\n #![feature(slice_partition_at_index)]\n #![feature(specialization)]\n #![feature(step_trait)]\n+#![feature(step_trait_ext)]\n #![feature(str_internals)]\n #![feature(test)]\n #![feature(trusted_len)]"}, {"sha": "67dcea58cf82bb0b30a35ef6872810f69e3014af", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=ed084b0b8341c974769a0328f61851b0e1fc17fa", "patch": "@@ -65,7 +65,7 @@ impl Idx for u32 {\n /// `u32::MAX`. You can also customize things like the `Debug` impl,\n /// what traits are derived, and so forth via the macro.\n #[macro_export]\n-#[allow_internal_unstable(step_trait, rustc_attrs)]\n+#[allow_internal_unstable(step_trait, step_trait_ext, rustc_attrs)]\n macro_rules! newtype_index {\n     // ---- public rules ----\n \n@@ -181,7 +181,7 @@ macro_rules! newtype_index {\n             }\n         }\n \n-        impl ::std::iter::Step for $type {\n+        unsafe impl ::std::iter::Step for $type {\n             #[inline]\n             fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n                 <usize as ::std::iter::Step>::steps_between(\n@@ -191,33 +191,13 @@ macro_rules! newtype_index {\n             }\n \n             #[inline]\n-            fn replace_one(&mut self) -> Self {\n-                ::std::mem::replace(self, Self::from_u32(1))\n+            fn forward_checked(start: Self, u: usize) -> Option<Self> {\n+                Self::index(start).checked_add(u).map(Self::from_usize)\n             }\n \n             #[inline]\n-            fn replace_zero(&mut self) -> Self {\n-                ::std::mem::replace(self, Self::from_u32(0))\n-            }\n-\n-            #[inline]\n-            fn add_one(&self) -> Self {\n-                Self::from_usize(Self::index(*self) + 1)\n-            }\n-\n-            #[inline]\n-            fn sub_one(&self) -> Self {\n-                Self::from_usize(Self::index(*self) - 1)\n-            }\n-\n-            #[inline]\n-            fn add_usize(&self, u: usize) -> Option<Self> {\n-                Self::index(*self).checked_add(u).map(Self::from_usize)\n-            }\n-\n-            #[inline]\n-            fn sub_usize(&self, u: usize) -> Option<Self> {\n-                Self::index(*self).checked_sub(u).map(Self::from_usize)\n+            fn backward_checked(start: Self, u: usize) -> Option<Self> {\n+                Self::index(start).checked_sub(u).map(Self::from_usize)\n             }\n         }\n "}, {"sha": "fafab8a102a901895d07196248e8aa8f984b470c", "filename": "src/test/ui/impl-trait/example-calendar.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed084b0b8341c974769a0328f61851b0e1fc17fa/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs?ref=ed084b0b8341c974769a0328f61851b0e1fc17fa", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(fn_traits,\n            step_trait,\n+           step_trait_ext,\n            unboxed_closures,\n )]\n \n@@ -10,7 +11,6 @@\n //! Originally converted to Rust by [Daniel Keep](https://github.com/DanielKeep).\n \n use std::fmt::Write;\n-use std::mem;\n \n /// Date representation.\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n@@ -156,32 +156,16 @@ impl<'a, 'b> std::ops::Add<&'b NaiveDate> for &'a NaiveDate {\n     }\n }\n \n-impl std::iter::Step for NaiveDate {\n+unsafe impl std::iter::Step for NaiveDate {\n     fn steps_between(_: &Self, _: &Self) -> Option<usize> {\n         unimplemented!()\n     }\n \n-    fn replace_one(&mut self) -> Self {\n-        mem::replace(self, NaiveDate(0, 0, 1))\n+    fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+        Some((0..n).fold(start, |x, _| x.succ()))\n     }\n \n-    fn replace_zero(&mut self) -> Self {\n-        mem::replace(self, NaiveDate(0, 0, 0))\n-    }\n-\n-    fn add_one(&self) -> Self {\n-        self.succ()\n-    }\n-\n-    fn sub_one(&self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    fn add_usize(&self, _: usize) -> Option<Self> {\n-        unimplemented!()\n-    }\n-\n-    fn sub_usize(&self, _: usize) -> Option<Self> {\n+    fn backward_checked(_: Self, _: usize) -> Option<Self> {\n         unimplemented!()\n     }\n }"}]}