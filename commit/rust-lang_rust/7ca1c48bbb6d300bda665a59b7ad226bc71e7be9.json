{"sha": "7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "node_id": "C_kwDOAAsO6NoAKDdjYTFjNDhiYmI2ZDMwMGJkYTY2NWE1OWI3YWQyMjZiYzcxZTdiZTk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-19T23:37:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-19T23:37:33Z"}, "message": "Rollup merge of #94142 - est31:let_else_typeck, r=oli-obk\n\nrustc_typeck: adopt let else in more places\n\nContinuation of https://github.com/rust-lang/rust/pull/89933, https://github.com/rust-lang/rust/pull/91018, https://github.com/rust-lang/rust/pull/91481, https://github.com/rust-lang/rust/pull/93046, https://github.com/rust-lang/rust/pull/93590, https://github.com/rust-lang/rust/pull/94011.\n\nI have extended my clippy lint to also recognize tuple passing and match statements. The diff caused by fixing it is way above 1 thousand lines. Thus, I split it up into multiple pull requests to make reviewing easier. This PR handles rustc_typeck.", "tree": {"sha": "1e5f64d39b0c44572074e8d647e8ed1ac1272a13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e5f64d39b0c44572074e8d647e8ed1ac1272a13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiEX89CRBK7hj4Ov3rIwAAdxwIACISODD1zkhFDfj8nmdGJfvQ\nGplmJ/f7tpCbySUTdA07a2fOrksQivdN0kGv3XctxhMYjt2w0o2J2ZXvwVnz59/H\nWwszveRH9MDidqgcwPezYCBaiu2g2Cy6nwEGD9XSYgv6pY3Dkf2kCaLF/SFvJqFW\nz2VlTOVekzAN8PYZ53pzvMtrHg4fKiZWT84+lwJ4M9vyuR1u21lQEnCUxpxbTdI8\ntiLZ/KrIePA1fDl1tPeYmEecotUWsqzzap0hgMzi9iR/CmHxnpkTaJ8UotiqLcun\nyVVHqLZqlRQoLsswEAbE5Q/wljK2Jf15vXLpLQUoPXhuzNCqiUEqx+/mYAfAiAQ=\n=Ny0k\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e5f64d39b0c44572074e8d647e8ed1ac1272a13\nparent a69aaf4aeef9832ee54ca6bf20274c6f25a875e5\nparent bb0a2f985cb6e980cc026ea952733d53bb868f87\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645313853 +0100\ncommitter GitHub <noreply@github.com> 1645313853 +0100\n\nRollup merge of #94142 - est31:let_else_typeck, r=oli-obk\n\nrustc_typeck: adopt let else in more places\n\nContinuation of https://github.com/rust-lang/rust/pull/89933, https://github.com/rust-lang/rust/pull/91018, https://github.com/rust-lang/rust/pull/91481, https://github.com/rust-lang/rust/pull/93046, https://github.com/rust-lang/rust/pull/93590, https://github.com/rust-lang/rust/pull/94011.\n\nI have extended my clippy lint to also recognize tuple passing and match statements. The diff caused by fixing it is way above 1 thousand lines. Thus, I split it up into multiple pull requests to make reviewing easier. This PR handles rustc_typeck.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "html_url": "https://github.com/rust-lang/rust/commit/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a69aaf4aeef9832ee54ca6bf20274c6f25a875e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a69aaf4aeef9832ee54ca6bf20274c6f25a875e5", "html_url": "https://github.com/rust-lang/rust/commit/a69aaf4aeef9832ee54ca6bf20274c6f25a875e5"}, {"sha": "bb0a2f985cb6e980cc026ea952733d53bb868f87", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb0a2f985cb6e980cc026ea952733d53bb868f87", "html_url": "https://github.com/rust-lang/rust/commit/bb0a2f985cb6e980cc026ea952733d53bb868f87"}], "stats": {"total": 364, "additions": 135, "deletions": 229}, "files": [{"sha": "dbe7ddeb6a82412cdb542ac20f2b814134549b2b", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -1808,12 +1808,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             (_, Res::SelfTy { trait_: Some(_), alias_to: Some((impl_def_id, _)) }) => {\n                 // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference.\n-                let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n-                    Some(trait_ref) => trait_ref,\n-                    None => {\n-                        // A cycle error occurred, most likely.\n-                        return Err(ErrorReported);\n-                    }\n+                let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) else {\n+                    // A cycle error occurred, most likely.\n+                    return Err(ErrorReported);\n                 };\n \n                 self.one_bound_for_assoc_type("}, {"sha": "679cac0b82a52536b1a7ced362b632cdf3b7a698", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -219,10 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (self.tcx.lang_items().fn_mut_trait(), Ident::with_dummy_span(sym::call_mut), true),\n             (self.tcx.lang_items().fn_once_trait(), Ident::with_dummy_span(sym::call_once), false),\n         ] {\n-            let trait_def_id = match opt_trait_def_id {\n-                Some(def_id) => def_id,\n-                None => continue,\n-            };\n+            let Some(trait_def_id) = opt_trait_def_id else { continue };\n \n             let opt_input_types = opt_arg_exprs.map(|arg_exprs| {\n                 [self.tcx.mk_tup(arg_exprs.iter().map(|e| {\n@@ -246,11 +243,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if borrow {\n                     // Check for &self vs &mut self in the method signature. Since this is either\n                     // the Fn or FnMut trait, it should be one of those.\n-                    let (region, mutbl) = if let ty::Ref(r, _, mutbl) =\n-                        method.sig.inputs()[0].kind()\n-                    {\n-                        (r, mutbl)\n-                    } else {\n+                    let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind() else {\n                         // The `fn`/`fn_mut` lang item is ill-formed, which should have\n                         // caused an error elsewhere.\n                         self.tcx"}, {"sha": "a5e1b2579f8c4aeb06b4a052f189c67a3e2a31b2", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -799,21 +799,19 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         let expr_kind = fcx.pointer_kind(m_expr.ty, self.span)?;\n         let cast_kind = fcx.pointer_kind(m_cast.ty, self.span)?;\n \n-        let cast_kind = match cast_kind {\n+        let Some(cast_kind) = cast_kind else {\n             // We can't cast if target pointer kind is unknown\n-            None => return Err(CastError::UnknownCastPtrKind),\n-            Some(cast_kind) => cast_kind,\n+            return Err(CastError::UnknownCastPtrKind);\n         };\n \n         // Cast to thin pointer is OK\n         if cast_kind == PointerKind::Thin {\n             return Ok(CastKind::PtrPtrCast);\n         }\n \n-        let expr_kind = match expr_kind {\n+        let Some(expr_kind) = expr_kind else {\n             // We can't cast to fat pointer if source pointer kind is unknown\n-            None => return Err(CastError::UnknownExprPtrKind),\n-            Some(expr_kind) => expr_kind,\n+            return Err(CastError::UnknownExprPtrKind);\n         };\n \n         // thin -> fat? report invalid cast (don't complain about vtable kinds)"}, {"sha": "30ae382de42782b5e31cd1a0e0b14d7f539f9b1f", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -415,13 +415,10 @@ fn check_static_inhabited<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Spa\n     // have UB during initialization if they are uninhabited, but there also seems to be no good\n     // reason to allow any statics to be uninhabited.\n     let ty = tcx.type_of(def_id);\n-    let layout = match tcx.layout_of(ParamEnv::reveal_all().and(ty)) {\n-        Ok(l) => l,\n-        Err(_) => {\n-            // Generic statics are rejected, but we still reach this case.\n-            tcx.sess.delay_span_bug(span, \"generic static must be rejected\");\n-            return;\n-        }\n+    let Ok(layout) = tcx.layout_of(ParamEnv::reveal_all().and(ty)) else {\n+        // Generic statics are rejected, but we still reach this case.\n+        tcx.sess.delay_span_bug(span, \"generic static must be rejected\");\n+        return;\n     };\n     if layout.abi.is_uninhabited() {\n         tcx.struct_span_lint_hir(\n@@ -852,10 +849,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n     impl_id: DefId,\n     impl_item: &hir::ImplItemRef,\n ) {\n-    let ancestors = match trait_def.ancestors(tcx, impl_id) {\n-        Ok(ancestors) => ancestors,\n-        Err(_) => return,\n-    };\n+    let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) else { return };\n     let mut ancestor_impls = ancestors.skip(1).filter_map(|parent| {\n         if parent.is_from_trait() {\n             None"}, {"sha": "966ef8baedd8b9e38e11466cea2500502fd7237e", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -676,12 +676,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // We do not expect any bound regions in our predicate, so\n         // skip past the bound vars.\n-        let predicate = match predicate.no_bound_vars() {\n-            Some(p) => p,\n-            None => {\n-                debug!(\"deduce_future_output_from_projection: has late-bound regions\");\n-                return None;\n-            }\n+        let Some(predicate) = predicate.no_bound_vars() else {\n+            debug!(\"deduce_future_output_from_projection: has late-bound regions\");\n+            return None;\n         };\n \n         // Check that this is a projection from the `Future` trait."}, {"sha": "b011fb8804d3ded91d169e5a3dcf37a84450bb33", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -429,13 +429,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let InferOk { value: ty, mut obligations } = match found {\n-            Some(d) => d,\n-            None => {\n-                let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n-                debug!(\"coerce_borrowed_pointer: failed with err = {:?}\", err);\n-                return Err(err);\n-            }\n+        let Some(InferOk { value: ty, mut obligations }) = found else {\n+            let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n+            debug!(\"coerce_borrowed_pointer: failed with err = {:?}\", err);\n+            return Err(err);\n         };\n \n         if ty == a && mt_a.mutbl == hir::Mutability::Not && autoderef.step_count() == 1 {\n@@ -461,9 +458,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n-        let r_borrow = match ty.kind() {\n-            ty::Ref(r_borrow, _, _) => r_borrow,\n-            _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n+        let ty::Ref(r_borrow, _, _) = ty.kind() else {\n+            span_bug!(span, \"expected a ref type, got {:?}\", ty);\n         };\n         let mutbl = match mutbl_b {\n             hir::Mutability::Not => AutoBorrowMutability::Not,\n@@ -944,9 +940,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // We don't ever need two-phase here since we throw out the result of the coercion\n         let coerce = Coerce::new(self, cause, AllowTwoPhase::No);\n         self.probe(|_| {\n-            let ok = match coerce.coerce(source, target) {\n-                Ok(ok) => ok,\n-                _ => return false,\n+            let Ok(ok) = coerce.coerce(source, target) else {\n+                return false;\n             };\n             let mut fcx = traits::FulfillmentContext::new_in_snapshot();\n             fcx.register_predicate_obligations(self, ok.obligations);"}, {"sha": "6c45af3e78686be40897b07522b9263a83f19664", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -435,44 +435,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// opt.map(|param| { takes_ref(param) });\n     /// ```\n     fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Span, &'static str, String)> {\n-        let path = match expr.kind {\n-            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => path,\n-            _ => return None,\n+        let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind else {\n+            return None;\n         };\n \n-        let local_id = match path.res {\n-            hir::def::Res::Local(id) => id,\n-            _ => return None,\n+        let hir::def::Res::Local(local_id) = path.res else {\n+            return None;\n         };\n \n         let local_parent = self.tcx.hir().get_parent_node(local_id);\n-        let param_hir_id = match self.tcx.hir().find(local_parent) {\n-            Some(Node::Param(hir::Param { hir_id, .. })) => hir_id,\n-            _ => return None,\n+        let Some(Node::Param(hir::Param { hir_id: param_hir_id, .. })) = self.tcx.hir().find(local_parent) else {\n+            return None;\n         };\n \n         let param_parent = self.tcx.hir().get_parent_node(*param_hir_id);\n-        let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(param_parent) {\n-            Some(Node::Expr(hir::Expr {\n-                hir_id,\n-                kind: hir::ExprKind::Closure(_, decl, ..),\n-                ..\n-            })) => (hir_id, decl),\n-            _ => return None,\n+        let Some(Node::Expr(hir::Expr {\n+            hir_id: expr_hir_id,\n+            kind: hir::ExprKind::Closure(_, closure_fn_decl, ..),\n+            ..\n+        })) = self.tcx.hir().find(param_parent) else {\n+            return None;\n         };\n \n         let expr_parent = self.tcx.hir().get_parent_node(*expr_hir_id);\n         let hir = self.tcx.hir().find(expr_parent);\n         let closure_params_len = closure_fn_decl.inputs.len();\n-        let (method_path, method_expr) = match (hir, closure_params_len) {\n-            (\n-                Some(Node::Expr(hir::Expr {\n-                    kind: hir::ExprKind::MethodCall(segment, expr, _),\n-                    ..\n-                })),\n-                1,\n-            ) => (segment, expr),\n-            _ => return None,\n+        let (\n+            Some(Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::MethodCall(method_path, method_expr, _),\n+                ..\n+            })),\n+            1,\n+        ) = (hir, closure_params_len) else {\n+            return None;\n         };\n \n         let self_ty = self.typeck_results.borrow().node_type(method_expr[0].hir_id);"}, {"sha": "be9bf6399d75736ec5a37ed9bbb982d7c3419dd9", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -622,15 +622,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // the `enclosing_loops` field and let's coerce the\n             // type of `expr_opt` into what is expected.\n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = match enclosing_breakables.opt_find_breakable(target_id) {\n-                Some(ctxt) => ctxt,\n-                None => {\n-                    // Avoid ICE when `break` is inside a closure (#65383).\n-                    return tcx.ty_error_with_message(\n-                        expr.span,\n-                        \"break was outside loop, but no error was emitted\",\n-                    );\n-                }\n+            let Some(ctxt) = enclosing_breakables.opt_find_breakable(target_id) else {\n+                // Avoid ICE when `break` is inside a closure (#65383).\n+                return tcx.ty_error_with_message(\n+                    expr.span,\n+                    \"break was outside loop, but no error was emitted\",\n+                );\n             };\n \n             if let Some(ref mut coerce) = ctxt.coerce {"}, {"sha": "f6cd136940333dd1c3213f2d6eb867b3bd42b452", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -745,10 +745,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         formal_args: &[Ty<'tcx>],\n     ) -> Vec<Ty<'tcx>> {\n         let formal_ret = self.resolve_vars_with_obligations(formal_ret);\n-        let ret_ty = match expected_ret.only_has_type(self) {\n-            Some(ret) => ret,\n-            None => return Vec::new(),\n-        };\n+        let Some(ret_ty) = expected_ret.only_has_type(self) else { return Vec::new() };\n         let expect_args = self\n             .fudge_inference_if_ok(|| {\n                 // Attempt to apply a subtyping relationship between the formal\n@@ -1044,9 +1041,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;\n-        let last_expr = match last_stmt.kind {\n-            hir::StmtKind::Semi(ref e) => e,\n-            _ => return None,\n+        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n+            return None;\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n         let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n@@ -1061,11 +1057,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     last_def_id, last_bounds, exp_def_id, exp_bounds\n                 );\n \n-                let (last_local_id, exp_local_id) =\n-                    match (last_def_id.as_local(), exp_def_id.as_local()) {\n-                        (Some(last_hir_id), Some(exp_hir_id)) => (last_hir_id, exp_hir_id),\n-                        (_, _) => return None,\n-                    };\n+                let last_local_id = last_def_id.as_local()?;\n+                let exp_local_id = exp_def_id.as_local()?;\n \n                 match (\n                     &self.tcx.hir().expect_item(last_local_id).kind,"}, {"sha": "f6a2447572ffdb60b4474efd7b700ac945dede0f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -438,9 +438,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // is and we were expecting a Box, ergo Pin<Box<expected>>, we\n                 // can suggest Box::pin.\n                 let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n-                let fn_name = match self.tcx.hir().find(parent) {\n-                    Some(Node::Expr(Expr { kind: ExprKind::Call(fn_name, _), .. })) => fn_name,\n-                    _ => return false,\n+                let Some(Node::Expr(Expr { kind: ExprKind::Call(fn_name, _), .. })) = self.tcx.hir().find(parent) else {\n+                    return false;\n                 };\n                 match fn_name.kind {\n                     ExprKind::Path(QPath::TypeRelative("}, {"sha": "3fa873e46abbb72f6bc7e42337da8527852e80fb", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -149,14 +149,11 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // time writing the results into the various typeck results.\n         let mut autoderef =\n             self.autoderef_overloaded_span(self.span, unadjusted_self_ty, self.call_expr.span);\n-        let (ty, n) = match autoderef.nth(pick.autoderefs) {\n-            Some(n) => n,\n-            None => {\n-                return self.tcx.ty_error_with_message(\n-                    rustc_span::DUMMY_SP,\n-                    &format!(\"failed autoderef {}\", pick.autoderefs),\n-                );\n-            }\n+        let Some((ty, n)) = autoderef.nth(pick.autoderefs) else {\n+            return self.tcx.ty_error_with_message(\n+                rustc_span::DUMMY_SP,\n+                &format!(\"failed autoderef {}\", pick.autoderefs),\n+            );\n         };\n         assert_eq!(n, pick.autoderefs);\n \n@@ -520,10 +517,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         &self,\n         predicates: &ty::InstantiatedPredicates<'tcx>,\n     ) -> Option<Span> {\n-        let sized_def_id = match self.tcx.lang_items().sized_trait() {\n-            Some(def_id) => def_id,\n-            None => return None,\n-        };\n+        let sized_def_id = self.tcx.lang_items().sized_trait()?;\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here."}, {"sha": "780a57278c5b0db227c12137c4eed3df74763e16", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -371,15 +371,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = match self.associated_value(trait_def_id, m_name) {\n-            Some(method_item) => method_item,\n-            None => {\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    \"operator trait does not have corresponding operator method\",\n-                );\n-                return None;\n-            }\n+        let Some(method_item) = self.associated_value(trait_def_id, m_name) else {\n+            tcx.sess.delay_span_bug(\n+                span,\n+                \"operator trait does not have corresponding operator method\",\n+            );\n+            return None;\n         };\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);"}, {"sha": "876c575781cf6580c116b06475806d8d598dd9c4", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -1246,9 +1246,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             return None;\n         }\n \n-        let ty = match self_ty.kind() {\n-            &ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) => ty,\n-            _ => return None,\n+        let &ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) = self_ty.kind() else {\n+            return None;\n         };\n \n         let const_self_ty = ty::TypeAndMut { ty, mutbl: hir::Mutability::Not };"}, {"sha": "475070b6b835bf888621469879296a56bfc5dd9b", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -37,9 +37,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Closure(..) | ty::FnDef(..) | ty::FnPtr(_) => true,\n             // If it's not a simple function, look for things which implement `FnOnce`.\n             _ => {\n-                let fn_once = match tcx.lang_items().require(LangItem::FnOnce) {\n-                    Ok(fn_once) => fn_once,\n-                    Err(..) => return false,\n+                let Some(fn_once) = tcx.lang_items().fn_once_trait() else {\n+                    return false;\n                 };\n \n                 // This conditional prevents us from asking to call errors and unresolved types.\n@@ -112,12 +111,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = match self.associated_value(impl_did, item_name).or_else(|| {\n+                        let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n                             let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n                             self.associated_value(impl_trait_ref.def_id, item_name)\n-                        }) {\n-                            Some(item) => item,\n-                            None => continue,\n+                        }) else {\n+                            continue;\n                         };\n                         let note_span = self\n                             .tcx\n@@ -194,10 +192,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item = match self.associated_value(trait_did, item_name) {\n-                            Some(item) => item,\n-                            None => continue,\n-                        };\n+                        let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n                         let item_span = self\n                             .tcx\n                             .sess\n@@ -1202,10 +1197,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut derives = Vec::<(String, Span, String)>::new();\n         let mut traits = Vec::<Span>::new();\n         for (pred, _, _) in unsatisfied_predicates {\n-            let trait_pred = match pred.kind().skip_binder() {\n-                ty::PredicateKind::Trait(trait_pred) => trait_pred,\n-                _ => continue,\n-            };\n+            let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() else { continue };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n                 Some(adt) if adt.did.is_local() => adt,\n                 _ => continue,"}, {"sha": "767979c39127e9799a4580a252136d68a1de903d", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -981,9 +981,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if subpats.len() == variant.fields.len()\n             || subpats.len() < variant.fields.len() && ddpos.is_some()\n         {\n-            let substs = match pat_ty.kind() {\n-                ty::Adt(_, substs) => substs,\n-                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n+            let ty::Adt(_, substs) = pat_ty.kind() else {\n+                bug!(\"unexpected pattern type {:?}\", pat_ty);\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n@@ -1221,9 +1220,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> bool {\n         let tcx = self.tcx;\n \n-        let (substs, adt) = match adt_ty.kind() {\n-            ty::Adt(adt, substs) => (substs, adt),\n-            _ => span_bug!(pat.span, \"struct pattern is not an ADT\"),\n+        let ty::Adt(adt, substs) = adt_ty.kind() else {\n+            span_bug!(pat.span, \"struct pattern is not an ADT\");\n         };\n \n         // Index the struct fields' types."}, {"sha": "73f7cafa1628cc3270966fb459424ef3b1ca2737", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -533,19 +533,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n-                None => {\n-                    let mutability = self.determine_capture_mutability(&typeck_results, &place);\n-                    let min_cap_list = vec![ty::CapturedPlace {\n-                        place,\n-                        info: capture_info,\n-                        mutability,\n-                        region: None,\n-                    }];\n-                    root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n-                    continue;\n-                }\n-                Some(min_cap_list) => min_cap_list,\n+            let Some(min_cap_list) = root_var_min_capture_list.get_mut(&var_hir_id) else {\n+                let mutability = self.determine_capture_mutability(&typeck_results, &place);\n+                let min_cap_list = vec![ty::CapturedPlace {\n+                    place,\n+                    info: capture_info,\n+                    mutability,\n+                    region: None,\n+                }];\n+                root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n+                continue;\n             };\n \n             // Go through each entry in the current list of min_captures"}, {"sha": "78e549974030192e6bd1c4fa0af6b94f05933943", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -40,11 +40,8 @@ struct InherentCollect<'tcx> {\n \n impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let (ty, assoc_items) = match item.kind {\n-            hir::ItemKind::Impl(hir::Impl { of_trait: None, ref self_ty, items, .. }) => {\n-                (self_ty, items)\n-            }\n-            _ => return,\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, items: assoc_items, .. }) = item.kind else {\n+            return;\n         };\n \n         let self_ty = self.tcx.type_of(item.def_id);"}, {"sha": "54fffeb3cdaa6c5e0d4b10d4bd1fc45efb57241f", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -38,9 +38,8 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorRep\n     let trait_def_id = trait_ref.def_id;\n \n     let item = tcx.hir().item(hir::ItemId { def_id });\n-    let impl_ = match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => impl_,\n-        _ => bug!(\"{:?} is not an impl: {:?}\", def_id, item),\n+    let hir::ItemKind::Impl(ref impl_) = item.kind else {\n+        bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n     };\n     let sp = tcx.sess.source_map().guess_head_span(item.span);\n     let tr = impl_.of_trait.as_ref().unwrap();"}, {"sha": "19b3d35566b2484af21fd40bbeb8d81dc9860945", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -1018,9 +1017,8 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n \n     let def_id = def_id.expect_local();\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let item = match tcx.hir().get(hir_id) {\n-        Node::Item(item) => item,\n-        _ => bug!(),\n+    let Node::Item(item) = tcx.hir().get(hir_id) else {\n+        bug!();\n     };\n \n     let repr = ReprOptions::new(tcx, def_id.to_def_id());\n@@ -1122,9 +1120,8 @@ fn super_predicates_that_define_assoc_type(\n         debug!(\"super_predicates_that_define_assoc_type: local trait_def_id={:?}\", trait_def_id);\n         let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n \n-        let item = match tcx.hir().get(trait_hir_id) {\n-            Node::Item(item) => item,\n-            _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n+        let Node::Item(item) = tcx.hir().get(trait_hir_id) else {\n+            bug!(\"trait_node_id {} is not an item\", trait_hir_id);\n         };\n \n         let (generics, bounds) = match item.kind {\n@@ -2637,10 +2634,7 @@ fn from_target_feature(\n     supported_target_features: &FxHashMap<String, Option<Symbol>>,\n     target_features: &mut Vec<Symbol>,\n ) {\n-    let list = match attr.meta_item_list() {\n-        Some(list) => list,\n-        None => return,\n-    };\n+    let Some(list) = attr.meta_item_list() else { return };\n     let bad_item = |span| {\n         let msg = \"malformed `target_feature` attribute input\";\n         let code = \"enable = \\\"..\\\"\".to_owned();\n@@ -2658,35 +2652,29 @@ fn from_target_feature(\n         }\n \n         // Must be of the form `enable = \"...\"` (a string).\n-        let value = match item.value_str() {\n-            Some(value) => value,\n-            None => {\n-                bad_item(item.span());\n-                continue;\n-            }\n+        let Some(value) = item.value_str() else {\n+            bad_item(item.span());\n+            continue;\n         };\n \n         // We allow comma separation to enable multiple features.\n         target_features.extend(value.as_str().split(',').filter_map(|feature| {\n-            let feature_gate = match supported_target_features.get(feature) {\n-                Some(g) => g,\n-                None => {\n-                    let msg =\n-                        format!(\"the feature named `{}` is not valid for this target\", feature);\n-                    let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n-                    err.span_label(\n-                        item.span(),\n-                        format!(\"`{}` is not valid for this target\", feature),\n-                    );\n-                    if let Some(stripped) = feature.strip_prefix('+') {\n-                        let valid = supported_target_features.contains_key(stripped);\n-                        if valid {\n-                            err.help(\"consider removing the leading `+` in the feature name\");\n-                        }\n+            let Some(feature_gate) = supported_target_features.get(feature) else {\n+                let msg =\n+                    format!(\"the feature named `{}` is not valid for this target\", feature);\n+                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n+                err.span_label(\n+                    item.span(),\n+                    format!(\"`{}` is not valid for this target\", feature),\n+                );\n+                if let Some(stripped) = feature.strip_prefix('+') {\n+                    let valid = supported_target_features.contains_key(stripped);\n+                    if valid {\n+                        err.help(\"consider removing the leading `+` in the feature name\");\n                     }\n-                    err.emit();\n-                    return None;\n                 }\n+                err.emit();\n+                return None;\n             };\n \n             // Only allow features whose feature gates have been enabled."}, {"sha": "78097e3697fb968b46f92b6d50aed3fa8b71e431", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -164,12 +164,9 @@ fn get_impl_substs<'tcx>(\n     // Conservatively use an empty `ParamEnv`.\n     let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n     infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env, RegionckMode::default());\n-    let impl2_substs = match infcx.fully_resolve(impl2_substs) {\n-        Ok(s) => s,\n-        Err(_) => {\n-            tcx.sess.struct_span_err(span, \"could not resolve substs on overridden impl\").emit();\n-            return None;\n-        }\n+    let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n+        tcx.sess.struct_span_err(span, \"could not resolve substs on overridden impl\").emit();\n+        return None;\n     };\n     Some((impl1_substs, impl2_substs))\n }"}, {"sha": "876b1ae72ad9644a194791a5942d54fa2104d95d", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -484,9 +484,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let place_ty = self.expr_ty(expr)?;\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n-        let (region, mutbl) = match *base_ty.kind() {\n-            ty::Ref(region, _, mutbl) => (region, mutbl),\n-            _ => span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\"),\n+        let ty::Ref(region, _, mutbl) = *base_ty.kind() else {\n+            span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\");\n         };\n         let ref_ty = self.tcx().mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n \n@@ -544,14 +543,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> McResult<VariantIdx> {\n         let res = self.typeck_results.qpath_res(qpath, pat_hir_id);\n         let ty = self.typeck_results.node_type(pat_hir_id);\n-        let adt_def = match ty.kind() {\n-            ty::Adt(adt_def, _) => adt_def,\n-            _ => {\n-                self.tcx()\n-                    .sess\n-                    .delay_span_bug(span, \"struct or tuple struct pattern not applied to an ADT\");\n-                return Err(());\n-            }\n+        let ty::Adt(adt_def, _) = ty.kind() else {\n+            self.tcx()\n+                .sess\n+                .delay_span_bug(span, \"struct or tuple struct pattern not applied to an ADT\");\n+            return Err(());\n         };\n \n         match res {\n@@ -744,12 +740,9 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             PatKind::Slice(before, ref slice, after) => {\n-                let element_ty = match place_with_id.place.ty().builtin_index() {\n-                    Some(ty) => ty,\n-                    None => {\n-                        debug!(\"explicit index of non-indexable type {:?}\", place_with_id);\n-                        return Err(());\n-                    }\n+                let Some(element_ty) = place_with_id.place.ty().builtin_index() else {\n+                    debug!(\"explicit index of non-indexable type {:?}\", place_with_id);\n+                    return Err(());\n                 };\n                 let elt_place = self.cat_projection(\n                     pat,"}, {"sha": "435df9c00f466aa5e8d45d1e2ed00aa72d320888", "filename": "compiler/rustc_typeck/src/outlives/outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ca1c48bbb6d300bda665a59b7ad226bc71e7be9/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs?ref=7ca1c48bbb6d300bda665a59b7ad226bc71e7be9", "patch": "@@ -71,12 +71,9 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n             result,\n         );\n         debug!(\"implied_outlives_bounds for {:?}: {:#?}\", ty, result);\n-        let result = match result {\n-            Ok(v) => v,\n-            Err(_) => {\n-                self.tcx.sess.delay_span_bug(span, \"implied_outlives_bounds failed to instantiate\");\n-                return vec![];\n-            }\n+        let Ok(result) = result else {\n+            self.tcx.sess.delay_span_bug(span, \"implied_outlives_bounds failed to instantiate\");\n+            return vec![];\n         };\n \n         // Instantiation may have produced new inference variables and constraints on those"}]}