{"sha": "c56d8eda4677c89c1a5e2771dbe637312a6f630f", "node_id": "C_kwDOAAsO6NoAKGM1NmQ4ZWRhNDY3N2M4OWMxYTVlMjc3MWRiZTYzNzMxMmE2ZjYzMGY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-04T01:19:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-04T01:19:25Z"}, "message": "Rollup merge of #105541 - compiler-errors:iter-comb, r=cjgillot\n\nSimplify some iterator combinators\n\nSaw a `flat_map().next()` instead of a `find_map()` in some method probe code, so did a quick search for some similar usages.", "tree": {"sha": "aaaa11d309b35594d453663da1749e1de58ff551", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaaa11d309b35594d453663da1749e1de58ff551"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c56d8eda4677c89c1a5e2771dbe637312a6f630f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjtNQdCRBK7hj4Ov3rIwAAc3MIAE3gn8Ubkuhs1NCS5acgaG40\nLnhBPoP+zedAQZrxmo4SVz9CsuEogg9X/9V7XyqUoxz8bpEbhGJYLWg24MaUDPDR\n+6cxCWQgLeekCVKFvfCjJz3AS0KQSEWe/N8XIFmUm6aYqyTm3g+TesUyH/DjHyEe\nNA46CeNbbDZIgbtZoK5Ro5Rn/jkDlkXvu7J+MqbRTZpurQzi/YX69TxtHokOkHOu\nDLZuIQjYlQCg6FijOtegAWT9Hkpg3C6XPY0wdWb28Kb+9T6n9OC6xklVs9jWVH30\nC+eZC85nWo8BycIDmI4XP+OTrXvotSi9QmSTXmBaurvLRR5Lm1LH4Lwpo4J+Jdk=\n=jh9w\n-----END PGP SIGNATURE-----\n", "payload": "tree aaaa11d309b35594d453663da1749e1de58ff551\nparent 752c0f57ea4c8d9acb61adec4bfdf4d0c8b81c6b\nparent 2baee88bdb6ebbfda067818f5f4194083c2a77c1\nauthor Michael Goulet <michael@errs.io> 1672795165 -0800\ncommitter GitHub <noreply@github.com> 1672795165 -0800\n\nRollup merge of #105541 - compiler-errors:iter-comb, r=cjgillot\n\nSimplify some iterator combinators\n\nSaw a `flat_map().next()` instead of a `find_map()` in some method probe code, so did a quick search for some similar usages.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c56d8eda4677c89c1a5e2771dbe637312a6f630f", "html_url": "https://github.com/rust-lang/rust/commit/c56d8eda4677c89c1a5e2771dbe637312a6f630f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c56d8eda4677c89c1a5e2771dbe637312a6f630f/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "752c0f57ea4c8d9acb61adec4bfdf4d0c8b81c6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/752c0f57ea4c8d9acb61adec4bfdf4d0c8b81c6b", "html_url": "https://github.com/rust-lang/rust/commit/752c0f57ea4c8d9acb61adec4bfdf4d0c8b81c6b"}, {"sha": "2baee88bdb6ebbfda067818f5f4194083c2a77c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2baee88bdb6ebbfda067818f5f4194083c2a77c1", "html_url": "https://github.com/rust-lang/rust/commit/2baee88bdb6ebbfda067818f5f4194083c2a77c1"}], "stats": {"total": 305, "additions": 98, "deletions": 207}, "files": [{"sha": "50cd13a2ccc8a462b28d35faddb94998e00efa93", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -527,26 +527,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // that are *partially* initialized by assigning to a field of an uninitialized\n             // binding. We differentiate between them for more accurate wording here.\n             \"isn't fully initialized\"\n-        } else if spans\n-            .iter()\n-            .filter(|i| {\n-                // We filter these to avoid misleading wording in cases like the following,\n-                // where `x` has an `init`, but it is in the same place we're looking at:\n-                // ```\n-                // let x;\n-                // x += 1;\n-                // ```\n-                !i.contains(span)\n-                    // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n-                        && !visitor\n-                            .errors\n-                            .iter()\n-                            .map(|(sp, _)| *sp)\n-                            .any(|sp| span < sp && !sp.contains(span))\n-            })\n-            .count()\n-            == 0\n-        {\n+        } else if !spans.iter().any(|i| {\n+            // We filter these to avoid misleading wording in cases like the following,\n+            // where `x` has an `init`, but it is in the same place we're looking at:\n+            // ```\n+            // let x;\n+            // x += 1;\n+            // ```\n+            !i.contains(span)\n+            // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n+            && !visitor\n+                .errors\n+                .iter()\n+                .map(|(sp, _)| *sp)\n+                .any(|sp| span < sp && !sp.contains(span))\n+        }) {\n             show_assign_sugg = true;\n             \"isn't initialized\"\n         } else {"}, {"sha": "567a9814fccbf3dd712e61d39df4d198de855453", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 67, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -4,9 +4,9 @@\n \n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{self as hir, Item, ItemKind, Node};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::{\n         self, find_anon_type, find_param_with_region, suggest_adding_lifetime_params,\n@@ -291,71 +291,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlives_suggestion.add_suggestion(self);\n     }\n \n-    fn get_impl_ident_and_self_ty_from_trait(\n-        &self,\n-        def_id: DefId,\n-        trait_objects: &FxIndexSet<DefId>,\n-    ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n-        let tcx = self.infcx.tcx;\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n-                {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                        ..\n-                    })) => Some((impl_item.ident, self_ty)),\n-                    _ => None,\n-                }\n-            }\n-            Some(Node::TraitItem(trait_item)) => {\n-                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did.def_id) {\n-                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n-                        // The method being called is defined in the `trait`, but the `'static`\n-                        // obligation comes from the `impl`. Find that `impl` so that we can point\n-                        // at it in the suggestion.\n-                        let trait_did = trait_did.to_def_id();\n-                        match tcx\n-                            .hir()\n-                            .trait_impls(trait_did)\n-                            .iter()\n-                            .filter_map(|&impl_did| {\n-                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                    Some(Node::Item(Item {\n-                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                        ..\n-                                    })) if trait_objects.iter().all(|did| {\n-                                        // FIXME: we should check `self_ty` against the receiver\n-                                        // type in the `UnifyReceiver` context, but for now, use\n-                                        // this imperfect proxy. This will fail if there are\n-                                        // multiple `impl`s for the same trait like\n-                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                        // In that case, only the first one will get suggestions.\n-                                        let mut traits = vec![];\n-                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                        hir_v.visit_ty(self_ty);\n-                                        !traits.is_empty()\n-                                    }) =>\n-                                    {\n-                                        Some(self_ty)\n-                                    }\n-                                    _ => None,\n-                                }\n-                            })\n-                            .next()\n-                        {\n-                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n-                            _ => None,\n-                        }\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -850,7 +785,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         visitor.visit_ty(param.param_ty);\n \n         let Some((ident, self_ty)) =\n-            self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &visitor.0) else {return};\n+            NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, instance.def_id(), &visitor.0) else { return; };\n \n         self.suggest_constrain_dyn_trait_in_impl(diag, &visitor.0, ident, self_ty);\n     }"}, {"sha": "a92242b2615c1f66b1cfb438c61a0bbf48ad0e97", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -1244,7 +1244,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        let call = if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().any(|value| *value == gcc_func) {\n             self.function_call(func, args, funclet)\n         }\n         else {"}, {"sha": "4424b31c0542c65777d80571ebc85cafbdd1c925", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -253,7 +253,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n-        debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n+        debug_assert!(self.functions.borrow().values().any(|value| *value == function),\n             \"{:?} ({:?}) is not a function\", value, value.get_type());\n         function\n     }"}, {"sha": "cecf3d3f1e0644c2656924a4e4aa10cf13f9a7bc", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -240,10 +240,8 @@ fn typeck_with_fallback<'tcx>(\n                         }),\n                         Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n                         | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty = asm\n-                                .operands\n-                                .iter()\n-                                .filter_map(|(op, _op_sp)| match op {\n+                            let operand_ty =\n+                                asm.operands.iter().find_map(|(op, _op_sp)| match op {\n                                     hir::InlineAsmOperand::Const { anon_const }\n                                         if anon_const.hir_id == id =>\n                                     {\n@@ -259,8 +257,7 @@ fn typeck_with_fallback<'tcx>(\n                                         }))\n                                     }\n                                     _ => None,\n-                                })\n-                                .next();\n+                                });\n                             operand_ty.unwrap_or_else(fallback)\n                         }\n                         _ => fallback(),"}, {"sha": "3d6c2119bea333e568dbd49f026bd343f1bdb32c", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -341,8 +341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Find an identifier with which this trait was imported (note that `_` doesn't count).\n         let any_id = import_items\n             .iter()\n-            .filter_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None })\n-            .next();\n+            .find_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None });\n         if let Some(any_id) = any_id {\n             if any_id.name == Empty {\n                 // Glob import, so just use its name."}, {"sha": "2daf1979ee5e69d51642a7588f38aa29d6a12272", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -1111,7 +1111,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // a raw pointer\n                 !step.self_ty.references_error() && !step.from_unsafe_deref\n             })\n-            .flat_map(|step| {\n+            .find_map(|step| {\n                 let InferOk { value: self_ty, obligations: _ } = self\n                     .fcx\n                     .probe_instantiate_query_response(\n@@ -1147,7 +1147,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         })\n                     })\n             })\n-            .next()\n     }\n \n     /// For each type `T` in the step list, this attempts to find a method where"}, {"sha": "b04ef55a994ea61dbdcf7c36c98d48b55462f245", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -257,9 +257,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx\n                             .inherent_impls(adt_def.did())\n                             .iter()\n-                            .filter_map(|def_id| self.associated_value(*def_id, item_name))\n-                            .count()\n-                            >= 1\n+                            .any(|def_id| self.associated_value(*def_id, item_name).is_some())\n                     } else {\n                         false\n                     }"}, {"sha": "d9cdfa9dd4fc9973151c55ecbf98837c65cfbe1e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 57, "deletions": 82, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let mut v = TraitObjectVisitor(FxIndexSet::default());\n             v.visit_ty(param.param_ty);\n             if let Some((ident, self_ty)) =\n-                self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0)\n+                NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, item_def_id, &v.0)\n                 && self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty)\n             {\n                 override_error_code = Some(ident.name);\n@@ -309,19 +309,12 @@ pub fn suggest_new_region_bound(\n                 let did = item_id.owner_id.to_def_id();\n                 let ty = tcx.mk_opaque(did, ty::InternalSubsts::identity_for_item(tcx, did));\n \n-                if let Some(span) = opaque\n-                    .bounds\n-                    .iter()\n-                    .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime {\n-                            res: LifetimeName::Static,\n-                            ident,\n-                            ..\n-                        }) => Some(ident.span),\n-                        _ => None,\n-                    })\n-                    .next()\n-                {\n+                if let Some(span) = opaque.bounds.iter().find_map(|arg| match arg {\n+                    GenericBound::Outlives(Lifetime {\n+                        res: LifetimeName::Static, ident, ..\n+                    }) => Some(ident.span),\n+                    _ => None,\n+                }) {\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             span,\n@@ -338,20 +331,14 @@ pub fn suggest_new_region_bound(\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n-                } else if opaque\n-                    .bounds\n-                    .iter()\n-                    .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime { ident, .. })\n-                            if ident.name.to_string() == lifetime_name =>\n-                        {\n-                            Some(ident.span)\n-                        }\n-                        _ => None,\n-                    })\n-                    .next()\n-                    .is_some()\n-                {\n+                } else if opaque.bounds.iter().any(|arg| match arg {\n+                    GenericBound::Outlives(Lifetime { ident, .. })\n+                        if ident.name.to_string() == lifetime_name =>\n+                    {\n+                        true\n+                    }\n+                    _ => false,\n+                }) {\n                 } else {\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n@@ -403,66 +390,54 @@ pub fn suggest_new_region_bound(\n }\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    fn get_impl_ident_and_self_ty_from_trait(\n-        &self,\n+    pub fn get_impl_ident_and_self_ty_from_trait(\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         trait_objects: &FxIndexSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n-        let tcx = self.tcx();\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+        match tcx.hir().get_if_local(def_id)? {\n+            Node::ImplItem(impl_item) => {\n+                let impl_did = tcx.hir().get_parent_item(impl_item.hir_id());\n+                if let hir::OwnerNode::Item(Item {\n+                    kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                    ..\n+                }) = tcx.hir().owner(impl_did)\n                 {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                        ..\n-                    })) => Some((impl_item.ident, self_ty)),\n-                    _ => None,\n+                    Some((impl_item.ident, self_ty))\n+                } else {\n+                    None\n                 }\n             }\n-            Some(Node::TraitItem(trait_item)) => {\n-                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did.def_id) {\n-                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n-                        // The method being called is defined in the `trait`, but the `'static`\n-                        // obligation comes from the `impl`. Find that `impl` so that we can point\n-                        // at it in the suggestion.\n-                        let trait_did = trait_did.to_def_id();\n-                        match tcx\n-                            .hir()\n-                            .trait_impls(trait_did)\n-                            .iter()\n-                            .filter_map(|&impl_did| {\n-                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                    Some(Node::Item(Item {\n-                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                        ..\n-                                    })) if trait_objects.iter().all(|did| {\n-                                        // FIXME: we should check `self_ty` against the receiver\n-                                        // type in the `UnifyReceiver` context, but for now, use\n-                                        // this imperfect proxy. This will fail if there are\n-                                        // multiple `impl`s for the same trait like\n-                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                        // In that case, only the first one will get suggestions.\n-                                        let mut traits = vec![];\n-                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                        hir_v.visit_ty(self_ty);\n-                                        !traits.is_empty()\n-                                    }) =>\n-                                    {\n-                                        Some(self_ty)\n-                                    }\n-                                    _ => None,\n-                                }\n-                            })\n-                            .next()\n-                        {\n-                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n-                            _ => None,\n-                        }\n+            Node::TraitItem(trait_item) => {\n+                let trait_id = tcx.hir().get_parent_item(trait_item.hir_id());\n+                debug_assert_eq!(tcx.def_kind(trait_id.def_id), hir::def::DefKind::Trait);\n+                // The method being called is defined in the `trait`, but the `'static`\n+                // obligation comes from the `impl`. Find that `impl` so that we can point\n+                // at it in the suggestion.\n+                let trait_did = trait_id.to_def_id();\n+                tcx.hir().trait_impls(trait_did).iter().find_map(|&impl_did| {\n+                    if let Node::Item(Item {\n+                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                        ..\n+                    }) = tcx.hir().find_by_def_id(impl_did)?\n+                        && trait_objects.iter().all(|did| {\n+                            // FIXME: we should check `self_ty` against the receiver\n+                            // type in the `UnifyReceiver` context, but for now, use\n+                            // this imperfect proxy. This will fail if there are\n+                            // multiple `impl`s for the same trait like\n+                            // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                            // In that case, only the first one will get suggestions.\n+                            let mut traits = vec![];\n+                            let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n+                            hir_v.visit_ty(self_ty);\n+                            !traits.is_empty()\n+                        })\n+                    {\n+                        Some((trait_item.ident, *self_ty))\n+                    } else {\n+                        None\n                     }\n-                    _ => None,\n-                }\n+                })\n             }\n             _ => None,\n         }\n@@ -493,7 +468,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n         // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n-        let Some((ident, self_ty)) = self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0) else {\n+        let Some((ident, self_ty)) = NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, instance.def_id(), &v.0) else {\n             return false;\n         };\n "}, {"sha": "525079681ca5cec4eee3f16787df9760519508df", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -256,7 +256,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n                     )\n-                    .filter_map(|obligation| {\n+                    .find_map(|obligation| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Clause(ty::Clause::Trait(\n                             ref poly_trait_predicate,\n@@ -270,22 +270,17 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         }\n                     })\n                     .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n-                    .next()\n                 }\n-                ty::Dynamic(binders, _, _) => binders\n-                    .iter()\n-                    .filter_map(|predicate| {\n-                        if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n-                            predicate.skip_binder()\n-                        {\n-                            let def_id = trait_ref.def_id;\n-                            is_def_must_use(cx, def_id, span)\n-                        } else {\n-                            None\n-                        }\n-                        .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n-                    })\n-                    .next(),\n+                ty::Dynamic(binders, _, _) => binders.iter().find_map(|predicate| {\n+                    if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder()\n+                    {\n+                        let def_id = trait_ref.def_id;\n+                        is_def_must_use(cx, def_id, span)\n+                            .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n+                    } else {\n+                        None\n+                    }\n+                }),\n                 ty::Tuple(tys) => {\n                     let elem_exprs = if let hir::ExprKind::Tup(elem_exprs) = expr.kind {\n                         debug_assert_eq!(elem_exprs.len(), tys.len());"}, {"sha": "bd0c08a53c4f20eb2ce5b6a15a561091ce83d0a6", "filename": "compiler/rustc_macros/src/symbols/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -16,14 +16,13 @@ fn test_symbols() {\n     let m: &syn::ItemMacro = file\n         .items\n         .iter()\n-        .filter_map(|i| {\n+        .find_map(|i| {\n             if let syn::Item::Macro(m) = i {\n                 if m.mac.path == symbols_path { Some(m) } else { None }\n             } else {\n                 None\n             }\n         })\n-        .next()\n         .expect(\"did not find `symbols!` macro invocation.\");\n \n     let body_tokens = m.mac.tokens.clone();"}, {"sha": "e41fe325b811cb42cf118565782a00e1f75df0eb", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56d8eda4677c89c1a5e2771dbe637312a6f630f/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=c56d8eda4677c89c1a5e2771dbe637312a6f630f", "patch": "@@ -820,13 +820,12 @@ impl<'a> Resolver<'a> {\n             // binding if it exists. What we really want here is having two separate scopes in\n             // a module - one for non-globs and one for globs, but until that's done use this\n             // hack to avoid inconsistent resolution ICEs during import validation.\n-            let binding = [resolution.binding, resolution.shadowed_glob]\n-                .into_iter()\n-                .filter_map(|binding| match (binding, ignore_binding) {\n+            let binding = [resolution.binding, resolution.shadowed_glob].into_iter().find_map(\n+                |binding| match (binding, ignore_binding) {\n                     (Some(binding), Some(ignored)) if ptr::eq(binding, ignored) => None,\n                     _ => binding,\n-                })\n-                .next();\n+                },\n+            );\n             let Some(binding) = binding else {\n                 return Err((Determined, Weak::No));\n             };"}]}