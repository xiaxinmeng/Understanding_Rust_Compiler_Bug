{"sha": "541c6391a7254f513924eeea192d8f4e3d0d8594", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MWM2MzkxYTcyNTRmNTEzOTI0ZWVlYTE5MmQ4ZjRlM2QwZDg1OTQ=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-10T00:25:52Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-10T00:25:52Z"}, "message": "librustc: Remove old codepaths for creating intrinsic functions.", "tree": {"sha": "e9b5692229fca3ed17b417bbdeb397ec9ea6eed2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b5692229fca3ed17b417bbdeb397ec9ea6eed2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/541c6391a7254f513924eeea192d8f4e3d0d8594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/541c6391a7254f513924eeea192d8f4e3d0d8594", "html_url": "https://github.com/rust-lang/rust/commit/541c6391a7254f513924eeea192d8f4e3d0d8594", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/541c6391a7254f513924eeea192d8f4e3d0d8594/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6a148deab3c0a254742feeee22b3c352f2d1d10", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a148deab3c0a254742feeee22b3c352f2d1d10", "html_url": "https://github.com/rust-lang/rust/commit/c6a148deab3c0a254742feeee22b3c352f2d1d10"}], "stats": {"total": 523, "additions": 4, "deletions": 519}, "files": [{"sha": "ac8af182f235a3257ea300a2cbfa1a9037e8289e", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 507, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/541c6391a7254f513924eeea192d8f4e3d0d8594/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541c6391a7254f513924eeea192d8f4e3d0d8594/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=541c6391a7254f513924eeea192d8f4e3d0d8594", "patch": "@@ -10,7 +10,6 @@\n \n #![allow(non_uppercase_pattern_statics)]\n \n-use arena::TypedArena;\n use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n use lib::llvm::{ValueRef, Pointer, Array, Struct};\n use lib;\n@@ -32,7 +31,6 @@ use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n use middle::ty;\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::parse::token;\n use util::ppaux::ty_to_string;\n \n@@ -88,492 +86,6 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n     Some(ccx.get_intrinsic(&name))\n }\n \n-pub fn trans_intrinsic(ccx: &CrateContext,\n-                       decl: ValueRef,\n-                       item: &ast::ForeignItem,\n-                       substs: &param_substs,\n-                       ref_id: Option<ast::NodeId>) {\n-    debug!(\"trans_intrinsic(item.ident={})\", token::get_ident(item.ident));\n-\n-    fn with_overflow_instrinsic(bcx: &Block, name: &'static str, t: ty::t) {\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let a = get_param(bcx.fcx.llfn, first_real_arg);\n-        let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n-        let llfn = bcx.ccx().get_intrinsic(&name);\n-\n-        // convert `i1` to a `bool`, and write to the out parameter\n-        let val = Call(bcx, llfn, [a, b], []);\n-        let result = ExtractValue(bcx, val, 0);\n-        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n-        let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n-        let ret = InsertValue(bcx, ret, result, 0);\n-        let ret = InsertValue(bcx, ret, overflow, 1);\n-\n-        if type_is_immediate(bcx.ccx(), t) {\n-            Ret(bcx, ret);\n-        } else {\n-            let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n-            Store(bcx, ret, retptr);\n-            RetVoid(bcx);\n-        }\n-    }\n-\n-    fn volatile_load_intrinsic(bcx: &Block) {\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let src = get_param(bcx.fcx.llfn, first_real_arg);\n-\n-        let val = VolatileLoad(bcx, src);\n-        Ret(bcx, val);\n-    }\n-\n-    fn volatile_store_intrinsic(bcx: &Block) {\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst = get_param(bcx.fcx.llfn, first_real_arg);\n-        let val = get_param(bcx.fcx.llfn, first_real_arg + 1);\n-\n-        VolatileStore(bcx, val, dst);\n-        RetVoid(bcx);\n-    }\n-\n-    fn copy_intrinsic(bcx: &Block, allow_overlap: bool, volatile: bool, tp_ty: ty::t) {\n-        let ccx = bcx.ccx();\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n-        let size = machine::llsize_of(ccx, lltp_ty);\n-        let int_size = machine::llbitsize_of_real(ccx, ccx.int_type);\n-        let name = if allow_overlap {\n-            if int_size == 32 {\n-                \"llvm.memmove.p0i8.p0i8.i32\"\n-            } else {\n-                \"llvm.memmove.p0i8.p0i8.i64\"\n-            }\n-        } else {\n-            if int_size == 32 {\n-                \"llvm.memcpy.p0i8.p0i8.i32\"\n-            } else {\n-                \"llvm.memcpy.p0i8.p0i8.i64\"\n-            }\n-        };\n-\n-        let decl = bcx.fcx.llfn;\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p(ccx));\n-        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p(ccx));\n-        let count = get_param(decl, first_real_arg + 2);\n-        let llfn = ccx.get_intrinsic(&name);\n-        Call(bcx, llfn,\n-             [dst_ptr, src_ptr, Mul(bcx, size, count), align, C_bool(ccx, volatile)], []);\n-        RetVoid(bcx);\n-    }\n-\n-    fn memset_intrinsic(bcx: &Block, volatile: bool, tp_ty: ty::t) {\n-        let ccx = bcx.ccx();\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n-        let size = machine::llsize_of(ccx, lltp_ty);\n-        let name = if machine::llbitsize_of_real(ccx, ccx.int_type) == 32 {\n-            \"llvm.memset.p0i8.i32\"\n-        } else {\n-            \"llvm.memset.p0i8.i64\"\n-        };\n-\n-        let decl = bcx.fcx.llfn;\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p(ccx));\n-        let val = get_param(decl, first_real_arg + 1);\n-        let count = get_param(decl, first_real_arg + 2);\n-        let llfn = ccx.get_intrinsic(&name);\n-        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, C_bool(ccx, volatile)], []);\n-        RetVoid(bcx);\n-    }\n-\n-    fn count_zeros_intrinsic(bcx: &Block, name: &'static str) {\n-        let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n-        let y = C_bool(bcx.ccx(), false);\n-        let llfn = bcx.ccx().get_intrinsic(&name);\n-        let llcall = Call(bcx, llfn, [x, y], []);\n-        Ret(bcx, llcall);\n-    }\n-\n-    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), item.id));\n-\n-    let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx, decl, item.id, false, output_type,\n-                          substs, Some(item.span), &arena);\n-    let mut bcx = init_function(&fcx, true, output_type);\n-\n-    set_always_inline(fcx.llfn);\n-\n-    let first_real_arg = fcx.arg_pos(0u);\n-\n-    let name = token::get_ident(item.ident);\n-\n-    // This requires that atomic intrinsics follow a specific naming pattern:\n-    // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n-    if name.get().starts_with(\"atomic_\") {\n-        let split: Vec<&str> = name.get().split('_').collect();\n-        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n-        let order = if split.len() == 2 {\n-            lib::llvm::SequentiallyConsistent\n-        } else {\n-            match *split.get(2) {\n-                \"relaxed\" => lib::llvm::Monotonic,\n-                \"acq\"     => lib::llvm::Acquire,\n-                \"rel\"     => lib::llvm::Release,\n-                \"acqrel\"  => lib::llvm::AcquireRelease,\n-                _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n-            }\n-        };\n-\n-        match *split.get(1) {\n-            \"cxchg\" => {\n-                // See include/llvm/IR/Instructions.h for their implementation\n-                // of this, I assume that it's good enough for us to use for\n-                // now.\n-                let strongest_failure_ordering = match order {\n-                    lib::llvm::NotAtomic | lib::llvm::Unordered =>\n-                        ccx.sess().fatal(\"cmpxchg must be atomic\"),\n-                    lib::llvm::Monotonic | lib::llvm::Release =>\n-                        lib::llvm::Monotonic,\n-                    lib::llvm::Acquire | lib::llvm::AcquireRelease =>\n-                        lib::llvm::Acquire,\n-                    lib::llvm::SequentiallyConsistent =>\n-                        lib::llvm::SequentiallyConsistent,\n-                };\n-                let res = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n-                                        get_param(decl, first_real_arg + 1u),\n-                                        get_param(decl, first_real_arg + 2u),\n-                                        order, strongest_failure_ordering);\n-                if unsafe { lib::llvm::llvm::LLVMVersionMinor() >= 5 } {\n-                    Ret(bcx, ExtractValue(bcx, res, 0));\n-                } else {\n-                    Ret(bcx, res);\n-                }\n-            }\n-            \"load\" => {\n-                let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n-                                     order);\n-                Ret(bcx, old);\n-            }\n-            \"store\" => {\n-                AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n-                            get_param(decl, first_real_arg),\n-                            order);\n-                RetVoid(bcx);\n-            }\n-            \"fence\" => {\n-                AtomicFence(bcx, order);\n-                RetVoid(bcx);\n-            }\n-            op => {\n-                // These are all AtomicRMW ops\n-                let atom_op = match op {\n-                    \"xchg\"  => lib::llvm::Xchg,\n-                    \"xadd\"  => lib::llvm::Add,\n-                    \"xsub\"  => lib::llvm::Sub,\n-                    \"and\"   => lib::llvm::And,\n-                    \"nand\"  => lib::llvm::Nand,\n-                    \"or\"    => lib::llvm::Or,\n-                    \"xor\"   => lib::llvm::Xor,\n-                    \"max\"   => lib::llvm::Max,\n-                    \"min\"   => lib::llvm::Min,\n-                    \"umax\"  => lib::llvm::UMax,\n-                    \"umin\"  => lib::llvm::UMin,\n-                    _ => ccx.sess().fatal(\"unknown atomic operation\")\n-                };\n-\n-                let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n-                                    get_param(decl, first_real_arg + 1u),\n-                                    order);\n-                Ret(bcx, old);\n-            }\n-        }\n-\n-        fcx.cleanup();\n-        return;\n-    }\n-\n-    match name.get() {\n-        \"abort\" => {\n-            let llfn = bcx.ccx().get_intrinsic(&(\"llvm.trap\"));\n-            Call(bcx, llfn, [], []);\n-            Unreachable(bcx);\n-        }\n-        \"breakpoint\" => {\n-            let llfn = bcx.ccx().get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(bcx, llfn, [], []);\n-            RetVoid(bcx);\n-        }\n-        \"size_of\" => {\n-            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty) as uint));\n-        }\n-        \"move_val_init\" => {\n-            // Create a datum reflecting the value being moved.\n-            // Use `appropriate_mode` so that the datum is by ref\n-            // if the value is non-immediate. Note that, with\n-            // intrinsics, there are no argument cleanups to\n-            // concern ourselves with, so we can use an rvalue datum.\n-            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n-            let mode = appropriate_rvalue_mode(ccx, tp_ty);\n-            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty,\n-                             kind: Rvalue::new(mode)};\n-            bcx = src.store_to(bcx, get_param(decl, first_real_arg));\n-            RetVoid(bcx);\n-        }\n-        \"min_align_of\" => {\n-            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty) as uint));\n-        }\n-        \"pref_align_of\"=> {\n-            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty) as uint));\n-        }\n-        \"get_tydesc\" => {\n-            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n-            let static_ti = get_tydesc(ccx, tp_ty);\n-            glue::lazily_emit_visit_glue(ccx, &*static_ti);\n-\n-            // FIXME (#3730): ideally this shouldn't need a cast,\n-            // but there's a circularity between translating rust types to llvm\n-            // types and having a tydesc type available. So I can't directly access\n-            // the llvm type of intrinsic::TyDesc struct.\n-            let userland_tydesc_ty = type_of::type_of(ccx, output_type);\n-            let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n-            Ret(bcx, td);\n-        }\n-        \"type_id\" => {\n-            let hash = ty::hash_crate_independent(\n-                ccx.tcx(),\n-                *substs.substs.types.get(FnSpace, 0),\n-                &ccx.link_meta.crate_hash);\n-            // NB: This needs to be kept in lockstep with the TypeId struct in\n-            //     libstd/unstable/intrinsics.rs\n-            let val = C_named_struct(type_of::type_of(ccx, output_type),\n-                                     [C_u64(ccx, hash)]);\n-            match bcx.fcx.llretptr.get() {\n-                Some(ptr) => {\n-                    Store(bcx, val, ptr);\n-                    RetVoid(bcx);\n-                },\n-                None => Ret(bcx, val)\n-            }\n-        }\n-        \"init\" => {\n-            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            match bcx.fcx.llretptr.get() {\n-                Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n-                None if ty::type_is_nil(tp_ty) => RetVoid(bcx),\n-                None => Ret(bcx, C_null(lltp_ty)),\n-            }\n-        }\n-        \"uninit\" => {\n-            // Do nothing, this is effectively a no-op\n-            let retty = *substs.substs.types.get(FnSpace, 0);\n-            if type_is_immediate(ccx, retty) && !return_type_is_void(ccx, retty) {\n-                unsafe {\n-                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(arg_type_of(ccx, retty).to_ref()));\n-                }\n-            } else {\n-                RetVoid(bcx)\n-            }\n-        }\n-        \"forget\" => {\n-            RetVoid(bcx);\n-        }\n-        \"transmute\" => {\n-            let (in_type, out_type) = (*substs.substs.types.get(FnSpace, 0),\n-                                       *substs.substs.types.get(FnSpace, 1));\n-            let llintype = type_of::type_of(ccx, in_type);\n-            let llouttype = type_of::type_of(ccx, out_type);\n-\n-            let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n-            let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n-            if in_type_size != out_type_size {\n-                let sp = match ccx.tcx.map.get(ref_id.unwrap()) {\n-                    ast_map::NodeExpr(e) => e.span,\n-                    _ => fail!(\"transmute has non-expr arg\"),\n-                };\n-                ccx.sess().span_bug(sp,\n-                    format!(\"transmute called on types with different sizes: \\\n-                             {} ({} bit{}) to \\\n-                             {} ({} bit{})\",\n-                            ty_to_string(ccx.tcx(), in_type),\n-                            in_type_size,\n-                            if in_type_size == 1 {\"\"} else {\"s\"},\n-                            ty_to_string(ccx.tcx(), out_type),\n-                            out_type_size,\n-                            if out_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n-            }\n-\n-            if !return_type_is_void(ccx, out_type) {\n-                let llsrcval = get_param(decl, first_real_arg);\n-                if type_is_immediate(ccx, in_type) {\n-                    match fcx.llretptr.get() {\n-                        Some(llretptr) => {\n-                            Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n-                            RetVoid(bcx);\n-                        }\n-                        None => match (llintype.kind(), llouttype.kind()) {\n-                            (Pointer, other) | (other, Pointer) if other != Pointer => {\n-                                let tmp = Alloca(bcx, llouttype, \"\");\n-                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n-                                Ret(bcx, Load(bcx, tmp));\n-                            }\n-                            (Array, _) | (_, Array) | (Struct, _) | (_, Struct) => {\n-                                let tmp = Alloca(bcx, llouttype, \"\");\n-                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n-                                Ret(bcx, Load(bcx, tmp));\n-                            }\n-                            _ => {\n-                                let llbitcast = BitCast(bcx, llsrcval, llouttype);\n-                                Ret(bcx, llbitcast)\n-                            }\n-                        }\n-                    }\n-                } else if type_is_immediate(ccx, out_type) {\n-                    let llsrcptr = PointerCast(bcx, llsrcval, llouttype.ptr_to());\n-                    let ll_load = Load(bcx, llsrcptr);\n-                    Ret(bcx, ll_load);\n-                } else {\n-                    // NB: Do not use a Load and Store here. This causes massive\n-                    // code bloat when `transmute` is used on large structural\n-                    // types.\n-                    let lldestptr = fcx.llretptr.get().unwrap();\n-                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p(ccx));\n-                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p(ccx));\n-\n-                    let llsize = llsize_of(ccx, llintype);\n-                    call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n-                    RetVoid(bcx);\n-                };\n-            } else {\n-                RetVoid(bcx);\n-            }\n-        }\n-        \"needs_drop\" => {\n-            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n-            Ret(bcx, C_bool(ccx, ty::type_needs_drop(ccx.tcx(), tp_ty)));\n-        }\n-        \"owns_managed\" => {\n-            let tp_ty = *substs.substs.types.get(FnSpace, 0);\n-            Ret(bcx, C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed()));\n-        }\n-        \"visit_tydesc\" => {\n-            let td = get_param(decl, first_real_arg);\n-            let visitor = get_param(decl, first_real_arg + 1u);\n-            let td = PointerCast(bcx, td, ccx.tydesc_type().ptr_to());\n-            glue::call_visit_glue(bcx, visitor, td, None);\n-            RetVoid(bcx);\n-        }\n-        \"offset\" => {\n-            let ptr = get_param(decl, first_real_arg);\n-            let offset = get_param(decl, first_real_arg + 1);\n-            let lladdr = InBoundsGEP(bcx, ptr, [offset]);\n-            Ret(bcx, lladdr);\n-        }\n-        \"copy_nonoverlapping_memory\" => {\n-            copy_intrinsic(bcx, false, false, *substs.substs.types.get(FnSpace, 0))\n-        }\n-        \"copy_memory\" => {\n-            copy_intrinsic(bcx, true, false, *substs.substs.types.get(FnSpace, 0))\n-        }\n-        \"set_memory\" => {\n-            memset_intrinsic(bcx, false, *substs.substs.types.get(FnSpace, 0))\n-        }\n-\n-        \"volatile_copy_nonoverlapping_memory\" => {\n-            copy_intrinsic(bcx, false, true, *substs.substs.types.get(FnSpace, 0))\n-        }\n-\n-        \"volatile_copy_memory\" => {\n-            copy_intrinsic(bcx, true, true, *substs.substs.types.get(FnSpace, 0))\n-        }\n-\n-        \"volatile_set_memory\" => {\n-            memset_intrinsic(bcx, true, *substs.substs.types.get(FnSpace, 0))\n-        }\n-\n-        \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n-        \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n-        \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),\n-        \"ctlz64\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\"),\n-        \"cttz8\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\"),\n-        \"cttz16\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\"),\n-        \"cttz32\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\"),\n-        \"cttz64\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\"),\n-\n-        \"volatile_load\" => volatile_load_intrinsic(bcx),\n-        \"volatile_store\" => volatile_store_intrinsic(bcx),\n-\n-        \"i8_add_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i8\", output_type),\n-        \"i16_add_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i16\", output_type),\n-        \"i32_add_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i32\", output_type),\n-        \"i64_add_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i64\", output_type),\n-\n-        \"u8_add_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i8\", output_type),\n-        \"u16_add_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i16\", output_type),\n-        \"u32_add_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i32\", output_type),\n-        \"u64_add_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i64\", output_type),\n-\n-        \"i8_sub_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i8\", output_type),\n-        \"i16_sub_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i16\", output_type),\n-        \"i32_sub_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i32\", output_type),\n-        \"i64_sub_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i64\", output_type),\n-\n-        \"u8_sub_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i8\", output_type),\n-        \"u16_sub_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i16\", output_type),\n-        \"u32_sub_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i32\", output_type),\n-        \"u64_sub_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i64\", output_type),\n-\n-        \"i8_mul_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i8\", output_type),\n-        \"i16_mul_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i16\", output_type),\n-        \"i32_mul_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i32\", output_type),\n-        \"i64_mul_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i64\", output_type),\n-\n-        \"u8_mul_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i8\", output_type),\n-        \"u16_mul_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i16\", output_type),\n-        \"u32_mul_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i32\", output_type),\n-        \"u64_mul_with_overflow\" =>\n-            with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i64\", output_type),\n-\n-        _ => {\n-            // Could we make this an enum rather than a string? does it get\n-            // checked earlier?\n-            ccx.sess().span_bug(item.span, \"unknown intrinsic\");\n-        }\n-    }\n-    fcx.cleanup();\n-}\n-\n /// Performs late verification that intrinsics are used correctly. At present,\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n@@ -736,25 +248,9 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n \n             let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n-            if in_type_size != out_type_size {\n-                /*\n-                let sp = match ccx.tcx.map.get(ref_id.unwrap()) {\n-                    ast_map::NodeExpr(e) => e.span,\n-                    _ => fail!(\"transmute has non-expr arg\"),\n-                };\n-                ccx.sess().span_bug(sp,\n-                */\n-                ccx.sess().bug(\n-                    format!(\"transmute called on types with different sizes: \\\n-                             {} ({} bit{}) to \\\n-                             {} ({} bit{})\",\n-                            ty_to_string(ccx.tcx(), in_type),\n-                            in_type_size,\n-                            if in_type_size == 1 {\"\"} else {\"s\"},\n-                            ty_to_string(ccx.tcx(), out_type),\n-                            out_type_size,\n-                            if out_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n-            }\n+\n+            // This should be caught by the intrinsicck pass\n+            assert_eq!(in_type_size, out_type_size);\n \n             if !return_type_is_void(ccx, out_type) {\n                 let llsrcval = *llargs.get(0);"}, {"sha": "82dfd29320589ac046eedba399b00c2f0159f269", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/541c6391a7254f513924eeea192d8f4e3d0d8594/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/541c6391a7254f513924eeea192d8f4e3d0d8594/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=541c6391a7254f513924eeea192d8f4e3d0d8594", "patch": "@@ -18,7 +18,6 @@ use middle::trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use middle::trans::base::{trans_fn, decl_internal_rust_fn};\n use middle::trans::base;\n use middle::trans::common::*;\n-use middle::trans::intrinsic;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n@@ -158,17 +157,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n               }\n             }\n         }\n-        ast_map::NodeForeignItem(i) => {\n-            let simple = intrinsic::get_simple_intrinsic(ccx, &*i);\n-            match simple {\n-                Some(decl) => decl,\n-                None => {\n-                    let d = mk_lldecl();\n-                    intrinsic::trans_intrinsic(ccx, d, &*i, &psubsts, ref_id);\n-                    d\n-                }\n-            }\n-        }\n         ast_map::NodeVariant(v) => {\n             let parent = ccx.tcx.map.get_parent(fn_id.node);\n             let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n@@ -223,6 +211,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n \n         // Ugh -- but this ensures any new variants won't be forgotten\n+        ast_map::NodeForeignItem(..) |\n         ast_map::NodeLifetime(..) |\n         ast_map::NodeExpr(..) |\n         ast_map::NodeStmt(..) |"}]}