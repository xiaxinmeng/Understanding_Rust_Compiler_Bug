{"sha": "978d2cfee1ee9da704c960c8047e978a7003b582", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3OGQyY2ZlZTFlZTlkYTcwNGM5NjBjODA0N2U5NzhhNzAwM2I1ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-10T17:10:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-10T17:10:13Z"}, "message": "Auto merge of #41887 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 5 pull requests\n\n- Successful merges: #41531, #41536, #41809, #41854, #41886\n- Failed merges:", "tree": {"sha": "e74ba8f6a9d7b0b7bfa6a313ed7e1828219be6f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e74ba8f6a9d7b0b7bfa6a313ed7e1828219be6f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/978d2cfee1ee9da704c960c8047e978a7003b582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/978d2cfee1ee9da704c960c8047e978a7003b582", "html_url": "https://github.com/rust-lang/rust/commit/978d2cfee1ee9da704c960c8047e978a7003b582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/978d2cfee1ee9da704c960c8047e978a7003b582/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a161765fb90f2bfc78bda8fef944048e72bd26", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a161765fb90f2bfc78bda8fef944048e72bd26", "html_url": "https://github.com/rust-lang/rust/commit/25a161765fb90f2bfc78bda8fef944048e72bd26"}, {"sha": "19f1146ded4f7cfd4dc2720dcee49d9464a92429", "url": "https://api.github.com/repos/rust-lang/rust/commits/19f1146ded4f7cfd4dc2720dcee49d9464a92429", "html_url": "https://github.com/rust-lang/rust/commit/19f1146ded4f7cfd4dc2720dcee49d9464a92429"}], "stats": {"total": 291, "additions": 212, "deletions": 79}, "files": [{"sha": "27ecefe043b1e333b7788a4444c74ff519c35be3", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/978d2cfee1ee9da704c960c8047e978a7003b582/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/978d2cfee1ee9da704c960c8047e978a7003b582/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=978d2cfee1ee9da704c960c8047e978a7003b582", "patch": "@@ -54,16 +54,33 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// exception. If you need to mutate through an `Arc`, use [`Mutex`][mutex],\n /// [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n ///\n-/// `Arc` uses atomic operations for reference counting, so `Arc`s can be\n-/// sent between threads. In other words, `Arc<T>` implements [`Send`]\n-/// as long as `T` implements [`Send`] and [`Sync`][sync]. The disadvantage is\n-/// that atomic operations are more expensive than ordinary memory accesses.\n-/// If you are not sharing reference-counted values between threads, consider\n-/// using [`rc::Rc`][`Rc`] for lower overhead. [`Rc`] is a safe default, because\n-/// the compiler will catch any attempt to send an [`Rc`] between threads.\n-/// However, a library might choose `Arc` in order to give library consumers\n+/// ## Thread Safety\n+///\n+/// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n+/// counting  This means that it is thread-safe. The disadvantage is that\n+/// atomic operations are more expensive than ordinary memory accesses. If you\n+/// are not sharing reference-counted values between threads, consider using\n+/// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n+/// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n+/// However, a library might choose `Arc<T>` in order to give library consumers\n /// more flexibility.\n ///\n+/// `Arc<T>` will implement [`Send`] and [`Sync`] as long as the `T` implements\n+/// [`Send`] and [`Sync`]. Why can't you put a non-thread-safe type `T` in an\n+/// `Arc<T>` to make it thread-safe? This may be a bit counter-intuitive at\n+/// first: after all, isn't the point of `Arc<T>` thread safety? The key is\n+/// this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n+/// data, but it  doesn't add thread safety to its data. Consider\n+/// `Arc<RefCell<T>>`. `RefCell<T>` isn't [`Sync`], and if `Arc<T>` was always\n+/// [`Send`], `Arc<RefCell<T>>` would be as well. But then we'd have a problem:\n+/// `RefCell<T>` is not thread safe; it keeps track of the borrowing count using\n+/// non-atomic operations.\n+///\n+/// In the end, this means that you may need to pair `Arc<T>` with some sort of\n+/// `std::sync` type, usually `Mutex<T>`.\n+///\n+/// ## Breaking cycles with `Weak`\n+///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n /// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n /// to an `Arc`, but this will return [`None`] if the value has already been\n@@ -74,6 +91,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n /// pointers from children back to their parents.\n ///\n+/// ## `Deref` behavior\n+///\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n /// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n /// clashes with `T`'s methods, the methods of `Arc<T>` itself are [associated\n@@ -91,13 +110,13 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// [arc]: struct.Arc.html\n /// [weak]: struct.Weak.html\n-/// [`Rc`]: ../../std/rc/struct.Rc.html\n+/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n /// [atomic]: ../../std/sync/atomic/index.html\n /// [`Send`]: ../../std/marker/trait.Send.html\n-/// [sync]: ../../std/marker/trait.Sync.html\n+/// [`Sync`]: ../../std/marker/trait.Sync.html\n /// [deref]: ../../std/ops/trait.Deref.html\n /// [downgrade]: struct.Arc.html#method.downgrade\n /// [upgrade]: struct.Weak.html#method.upgrade"}, {"sha": "5f189d473be79f95c56ed2a9cc657ced02559d05", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/978d2cfee1ee9da704c960c8047e978a7003b582/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/978d2cfee1ee9da704c960c8047e978a7003b582/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=978d2cfee1ee9da704c960c8047e978a7003b582", "patch": "@@ -1005,7 +1005,7 @@ unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n #[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T: Sized> Unique<T> {\n-    /// Creates a new `Shared` that is dangling, but well-aligned.\n+    /// Creates a new `Unique` that is dangling, but well-aligned.\n     ///\n     /// This is useful for initializing types which lazily allocate, like\n     /// `Vec::new` does."}, {"sha": "f4b9a8972e3abb93f8dcfbceead1a6096d76d509", "filename": "src/libstd/path.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/978d2cfee1ee9da704c960c8047e978a7003b582/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/978d2cfee1ee9da704c960c8047e978a7003b582/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=978d2cfee1ee9da704c960c8047e978a7003b582", "patch": "@@ -51,10 +51,17 @@\n //! ```\n //! use std::path::PathBuf;\n //!\n+//! // This way works...\n //! let mut path = PathBuf::from(\"c:\\\\\");\n+//!\n //! path.push(\"windows\");\n //! path.push(\"system32\");\n+//!\n //! path.set_extension(\"dll\");\n+//!\n+//! // ... but push is best used if you don't know everything up\n+//! // front. If you do, this way is better:\n+//! let path: PathBuf = [\"c:\\\\\", \"windows\", \"system32.dll\"].iter().collect();\n //! ```\n //!\n //! [`Component`]: ../../std/path/enum.Component.html\n@@ -63,6 +70,7 @@\n //! [`Path`]: ../../std/path/struct.Path.html\n //! [`push`]: ../../std/path/struct.PathBuf.html#method.push\n //! [`String`]: ../../std/string/struct.String.html\n+//!\n //! [`str`]: ../../std/primitive.str.html\n //! [`OsString`]: ../../std/ffi/struct.OsString.html\n //! [`OsStr`]: ../../std/ffi/struct.OsStr.html\n@@ -1036,14 +1044,40 @@ impl<'a> cmp::Ord for Components<'a> {\n ///\n /// # Examples\n ///\n+/// You can use [`push`] to build up a `PathBuf` from\n+/// components:\n+///\n /// ```\n /// use std::path::PathBuf;\n ///\n-/// let mut path = PathBuf::from(\"c:\\\\\");\n+/// let mut path = PathBuf::new();\n+///\n+/// path.push(r\"C:\\\");\n /// path.push(\"windows\");\n /// path.push(\"system32\");\n+///\n /// path.set_extension(\"dll\");\n /// ```\n+///\n+/// However, [`push`] is best used for dynamic situations. This is a better way\n+/// to do this when you know all of the components ahead of time:\n+///\n+/// ```\n+/// use std::path::PathBuf;\n+///\n+/// let path: PathBuf = [r\"C:\\\", \"windows\", \"system32.dll\"].iter().collect();\n+/// ```\n+///\n+/// We can still do better than this! Since these are all strings, we can use\n+/// `From::from`:\n+///\n+/// ```\n+/// use std::path::PathBuf;\n+///\n+/// let path = PathBuf::from(r\"C:\\windows\\system32.dll\");\n+/// ```\n+///\n+/// Which method works best depends on what kind of situation you're in.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PathBuf {"}, {"sha": "230c60baf8bb49a95b123d4c29b4c4a90caeb660", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 147, "deletions": 67, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/978d2cfee1ee9da704c960c8047e978a7003b582/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/978d2cfee1ee9da704c960c8047e978a7003b582/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=978d2cfee1ee9da704c960c8047e978a7003b582", "patch": "@@ -96,41 +96,6 @@\n //! The [`thread::current`] function is available even for threads not spawned\n //! by the APIs of this module.\n //!\n-//! ## Blocking support: park and unpark\n-//!\n-//! Every thread is equipped with some basic low-level blocking support, via the\n-//! [`thread::park`][`park`] function and [`thread::Thread::unpark()`][`unpark`]\n-//! method. [`park`] blocks the current thread, which can then be resumed from\n-//! another thread by calling the [`unpark`] method on the blocked thread's handle.\n-//!\n-//! Conceptually, each [`Thread`] handle has an associated token, which is\n-//! initially not present:\n-//!\n-//! * The [`thread::park`][`park`] function blocks the current thread unless or until\n-//!   the token is available for its thread handle, at which point it atomically\n-//!   consumes the token. It may also return *spuriously*, without consuming the\n-//!   token. [`thread::park_timeout`] does the same, but allows specifying a\n-//!   maximum time to block the thread for.\n-//!\n-//! * The [`unpark`] method on a [`Thread`] atomically makes the token available\n-//!   if it wasn't already.\n-//!\n-//! In other words, each [`Thread`] acts a bit like a semaphore with initial count\n-//! 0, except that the semaphore is *saturating* (the count cannot go above 1),\n-//! and can return spuriously.\n-//!\n-//! The API is typically used by acquiring a handle to the current thread,\n-//! placing that handle in a shared data structure so that other threads can\n-//! find it, and then `park`ing. When some desired condition is met, another\n-//! thread calls [`unpark`] on the handle.\n-//!\n-//! The motivation for this design is twofold:\n-//!\n-//! * It avoids the need to allocate mutexes and condvars when building new\n-//!   synchronization primitives; the threads already provide basic blocking/signaling.\n-//!\n-//! * It can be implemented very efficiently on many platforms.\n-//!\n //! ## Thread-local storage\n //!\n //! This module also provides an implementation of thread-local storage for Rust\n@@ -322,6 +287,8 @@ impl Builder {\n     /// thread finishes). The join handle can be used to block on\n     /// termination of the child thread, including recovering its panics.\n     ///\n+    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n+    ///\n     /// # Errors\n     ///\n     /// Unlike the [`spawn`] free function, this method yields an\n@@ -396,19 +363,19 @@ impl Builder {\n /// panics, [`join`] will return an [`Err`] containing the argument given to\n /// [`panic`].\n ///\n+/// This will create a thread using default parameters of [`Builder`], if you\n+/// want to specify the stack size or the name of the thread, use this API\n+/// instead.\n+///\n /// # Panics\n ///\n /// Panics if the OS fails to create a thread; use [`Builder::spawn`]\n /// to recover from such errors.\n ///\n-/// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n-/// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n-/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-/// [`panic`]: ../../std/macro.panic.html\n-/// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n-///\n /// # Examples\n ///\n+/// Creating a thread.\n+///\n /// ```\n /// use std::thread;\n ///\n@@ -418,6 +385,54 @@ impl Builder {\n ///\n /// handler.join().unwrap();\n /// ```\n+///\n+/// As mentioned in the module documentation, threads are usually made to\n+/// communicate using [`channels`], here is how it usually looks.\n+///\n+/// This example also shows how to use `move`, in order to give ownership\n+/// of values to a thread.\n+///\n+/// ```\n+/// use std::thread;\n+/// use std::sync::mpsc::channel;\n+///\n+/// let (tx, rx) = channel();\n+///\n+/// let sender = thread::spawn(move || {\n+///     let _ = tx.send(\"Hello, thread\".to_owned());\n+/// });\n+///\n+/// let receiver = thread::spawn(move || {\n+///     println!(\"{}\", rx.recv().unwrap());\n+/// });\n+///\n+/// let _ = sender.join();\n+/// let _ = receiver.join();\n+/// ```\n+///\n+/// A thread can also return a value through its [`JoinHandle`], you can use\n+/// this to make asynchronous computations (futures might be more appropriate\n+/// though).\n+///\n+/// ```\n+/// use std::thread;\n+///\n+/// let computation = thread::spawn(|| {\n+///     // Some expensive computation.\n+///     42\n+/// });\n+///\n+/// let result = computation.join().unwrap();\n+/// println!(\"{}\", result);\n+/// ```\n+///\n+/// [`channels`]: ../../std/sync/mpsc/index.html\n+/// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n+/// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n+/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+/// [`panic`]: ../../std/macro.panic.html\n+/// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n+/// [`Builder`]: ../../std/thread/struct.Builder.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n     F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n@@ -568,23 +583,72 @@ pub fn sleep(dur: Duration) {\n \n /// Blocks unless or until the current thread's token is made available.\n ///\n-/// Every thread is equipped with some basic low-level blocking support, via\n-/// the `park()` function and the [`unpark`][unpark] method. These can be\n-/// used as a more CPU-efficient implementation of a spinlock.\n+/// A call to `park` does not guarantee that the thread will remain parked\n+/// forever, and callers should be prepared for this possibility.\n ///\n-/// [unpark]: struct.Thread.html#method.unpark\n+/// # park and unpark\n+///\n+/// Every thread is equipped with some basic low-level blocking support, via the\n+/// [`thread::park`][`park`] function and [`thread::Thread::unpark`][`unpark`]\n+/// method. [`park`] blocks the current thread, which can then be resumed from\n+/// another thread by calling the [`unpark`] method on the blocked thread's\n+/// handle.\n+///\n+/// Conceptually, each [`Thread`] handle has an associated token, which is\n+/// initially not present:\n+///\n+/// * The [`thread::park`][`park`] function blocks the current thread unless or\n+///   until the token is available for its thread handle, at which point it\n+///   atomically consumes the token. It may also return *spuriously*, without\n+///   consuming the token. [`thread::park_timeout`] does the same, but allows\n+///   specifying a maximum time to block the thread for.\n+///\n+/// * The [`unpark`] method on a [`Thread`] atomically makes the token available\n+///   if it wasn't already.\n+///\n+/// In other words, each [`Thread`] acts a bit like a spinlock that can be\n+/// locked and unlocked using `park` and `unpark`.\n ///\n /// The API is typically used by acquiring a handle to the current thread,\n /// placing that handle in a shared data structure so that other threads can\n-/// find it, and then parking (in a loop with a check for the token actually\n-/// being acquired).\n+/// find it, and then `park`ing. When some desired condition is met, another\n+/// thread calls [`unpark`] on the handle.\n ///\n-/// A call to `park` does not guarantee that the thread will remain parked\n-/// forever, and callers should be prepared for this possibility.\n+/// The motivation for this design is twofold:\n ///\n-/// See the [module documentation][thread] for more detail.\n+/// * It avoids the need to allocate mutexes and condvars when building new\n+///   synchronization primitives; the threads already provide basic\n+///   blocking/signaling.\n ///\n-/// [thread]: index.html\n+/// * It can be implemented very efficiently on many platforms.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::thread;\n+/// use std::time::Duration;\n+///\n+/// let parked_thread = thread::Builder::new()\n+///     .spawn(|| {\n+///         println!(\"Parking thread\");\n+///         thread::park();\n+///         println!(\"Thread unparked\");\n+///     })\n+///     .unwrap();\n+///\n+/// // Let some time pass for the thread to be spawned.\n+/// thread::sleep(Duration::from_millis(10));\n+///\n+/// println!(\"Unpark the thread\");\n+/// parked_thread.thread().unpark();\n+///\n+/// parked_thread.join().unwrap();\n+/// ```\n+///\n+/// [`Thread`]: ../../std/thread/struct.Thread.html\n+/// [`park`]: ../../std/thread/fn.park.html\n+/// [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n+/// [`thread::park_timeout`]: ../../std/thread/fn.park_timeout.html\n //\n // The implementation currently uses the trivial strategy of a Mutex+Condvar\n // with wakeup flag, which does not actually allow spurious wakeups. In the\n@@ -601,21 +665,21 @@ pub fn park() {\n     *guard = false;\n }\n \n-/// Use [park_timeout].\n+/// Use [`park_timeout`].\n ///\n /// Blocks unless or until the current thread's token is made available or\n /// the specified duration has been reached (may wake spuriously).\n ///\n-/// The semantics of this function are equivalent to `park()` except that the\n-/// thread will be blocked for roughly no longer than `ms`. This method\n-/// should not be used for precise timing due to anomalies such as\n+/// The semantics of this function are equivalent to [`park`] except\n+/// that the thread will be blocked for roughly no longer than `dur`. This\n+/// method should not be used for precise timing due to anomalies such as\n /// preemption or platform differences that may not cause the maximum\n /// amount of time waited to be precisely `ms` long.\n ///\n-/// See the [module documentation][thread] for more detail.\n+/// See the [park documentation][`park`] for more detail.\n ///\n-/// [thread]: index.html\n-/// [park_timeout]: fn.park_timeout.html\n+/// [`park_timeout`]: fn.park_timeout.html\n+/// [`park`]: ../../std/thread/fn.park.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::park_timeout`\")]\n pub fn park_timeout_ms(ms: u32) {\n@@ -625,13 +689,13 @@ pub fn park_timeout_ms(ms: u32) {\n /// Blocks unless or until the current thread's token is made available or\n /// the specified duration has been reached (may wake spuriously).\n ///\n-/// The semantics of this function are equivalent to `park()` except that the\n-/// thread will be blocked for roughly no longer than `dur`. This method\n-/// should not be used for precise timing due to anomalies such as\n+/// The semantics of this function are equivalent to [`park`][park] except\n+/// that the thread will be blocked for roughly no longer than `dur`. This\n+/// method should not be used for precise timing due to anomalies such as\n /// preemption or platform differences that may not cause the maximum\n /// amount of time waited to be precisely `dur` long.\n ///\n-/// See the module doc for more detail.\n+/// See the [park dococumentation][park] for more details.\n ///\n /// # Platform behavior\n ///\n@@ -656,6 +720,8 @@ pub fn park_timeout_ms(ms: u32) {\n ///     park_timeout(timeout);\n /// }\n /// ```\n+///\n+/// [park]: fn.park.html\n #[stable(feature = \"park_timeout\", since = \"1.4.0\")]\n pub fn park_timeout(dur: Duration) {\n     let thread = current();\n@@ -777,22 +843,36 @@ impl Thread {\n \n     /// Atomically makes the handle's token available if it is not already.\n     ///\n-    /// See the module doc for more detail.\n+    /// Every thread is equipped with some basic low-level blocking support, via\n+    /// the [`park`][park] function and the `unpark()` method. These can be\n+    /// used as a more CPU-efficient implementation of a spinlock.\n+    ///\n+    /// See the [park documentation][park] for more details.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::thread;\n+    /// use std::time::Duration;\n     ///\n-    /// let handler = thread::Builder::new()\n+    /// let parked_thread = thread::Builder::new()\n     ///     .spawn(|| {\n-    ///         let thread = thread::current();\n-    ///         thread.unpark();\n+    ///         println!(\"Parking thread\");\n+    ///         thread::park();\n+    ///         println!(\"Thread unparked\");\n     ///     })\n     ///     .unwrap();\n     ///\n-    /// handler.join().unwrap();\n+    /// // Let some time pass for the thread to be spawned.\n+    /// thread::sleep(Duration::from_millis(10));\n+    ///\n+    /// println!(\"Unpark the thread\");\n+    /// parked_thread.thread().unpark();\n+    ///\n+    /// parked_thread.join().unwrap();\n     /// ```\n+    ///\n+    /// [park]: fn.park.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();"}]}