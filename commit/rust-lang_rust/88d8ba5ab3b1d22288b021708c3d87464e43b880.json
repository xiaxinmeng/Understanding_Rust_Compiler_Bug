{"sha": "88d8ba5ab3b1d22288b021708c3d87464e43b880", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZDhiYTVhYjNiMWQyMjI4OGIwMjE3MDhjM2Q4NzQ2NGU0M2I4ODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-10T13:23:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-10T13:23:29Z"}, "message": "Auto merge of #22028 - nikomatsakis:issue-22019-caching, r=aturon\n\nSimplify cache selection by just using the local cache whenever there\r\nare any where-clauses at all. This seems to be the simplest possible\r\nrule and will (hopefully!) put an end to these annoying \"cache leak\"\r\nbugs. Fixes #22019.\r\n\r\nr? @aturon", "tree": {"sha": "46f6a1b2f413e8e49137fa2eed162832ba6e8ce7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46f6a1b2f413e8e49137fa2eed162832ba6e8ce7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88d8ba5ab3b1d22288b021708c3d87464e43b880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88d8ba5ab3b1d22288b021708c3d87464e43b880", "html_url": "https://github.com/rust-lang/rust/commit/88d8ba5ab3b1d22288b021708c3d87464e43b880", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88d8ba5ab3b1d22288b021708c3d87464e43b880/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94c06a1be0ccfcf1a8e105fc98d126de372dbd40", "url": "https://api.github.com/repos/rust-lang/rust/commits/94c06a1be0ccfcf1a8e105fc98d126de372dbd40", "html_url": "https://github.com/rust-lang/rust/commit/94c06a1be0ccfcf1a8e105fc98d126de372dbd40"}, {"sha": "acaad3ad675004c63f73e385f7d07153e0aceb4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/acaad3ad675004c63f73e385f7d07153e0aceb4e", "html_url": "https://github.com/rust-lang/rust/commit/acaad3ad675004c63f73e385f7d07153e0aceb4e"}], "stats": {"total": 174, "additions": 60, "deletions": 114}, "files": [{"sha": "7af046401ad60f09bfa3a33bd22202b2b68b6ed1", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 6, "deletions": 82, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/88d8ba5ab3b1d22288b021708c3d87464e43b880/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d8ba5ab3b1d22288b021708c3d87464e43b880/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=88d8ba5ab3b1d22288b021708c3d87464e43b880", "patch": "@@ -434,87 +434,11 @@ attached to the `ParameterEnvironment` and the global cache attached\n to the `tcx`. We use the local cache whenever the result might depend\n on the where clauses that are in scope. The determination of which\n cache to use is done by the method `pick_candidate_cache` in\n-`select.rs`.\n-\n-There are two cases where we currently use the local cache. The\n-current rules are probably more conservative than necessary.\n-\n-### Trait references that involve parameter types\n-\n-The most obvious case where you need the local environment is\n-when the trait reference includes parameter types. For example,\n-consider the following function:\n-\n-    impl<T> Vec<T> {\n-        fn foo(x: T)\n-            where T : Foo\n-        { ... }\n-\n-        fn bar(x: T)\n-        { ... }\n-    }\n-\n-If there is an obligation `T : Foo`, or `int : Bar<T>`, or whatever,\n-clearly the results from `foo` and `bar` are potentially different,\n-since the set of where clauses in scope are different.\n-\n-### Trait references with unbound variables when where clauses are in scope\n-\n-There is another less obvious interaction which involves unbound variables\n-where *only* where clauses are in scope (no impls). This manifested as\n-issue #18209 (`run-pass/trait-cache-issue-18209.rs`). Consider\n-this snippet:\n-\n-```\n-pub trait Foo {\n-    fn load_from() -> Box<Self>;\n-    fn load() -> Box<Self> {\n-        Foo::load_from()\n-    }\n-}\n-```\n-\n-The default method will incur an obligation `$0 : Foo` from the call\n-to `load_from`. If there are no impls, this can be eagerly resolved to\n-`VtableParam(Self : Foo)` and cached. Because the trait reference\n-doesn't involve any parameters types (only the resolution does), this\n-result was stored in the global cache, causing later calls to\n-`Foo::load_from()` to get nonsense.\n-\n-To fix this, we always use the local cache if there are unbound\n-variables and where clauses in scope. This is more conservative than\n-necessary as far as I can tell. However, it still seems to be a simple\n-rule and I observe ~99% hit rate on rustc, so it doesn't seem to hurt\n-us in particular.\n-\n-Here is an example of the kind of subtle case that I would be worried\n-about with a more complex rule (although this particular case works\n-out ok). Imagine the trait reference doesn't directly reference a\n-where clause, but the where clause plays a role in the winnowing\n-phase. Something like this:\n-\n-```\n-pub trait Foo<T> { ... }\n-pub trait Bar { ... }\n-impl<U,T:Bar> Foo<U> for T { ... } // Impl A\n-impl Foo<char> for uint { ... }    // Impl B\n-```\n-\n-Now, in some function, we have no where clauses in scope, and we have\n-an obligation `$1 : Foo<$0>`. We might then conclude that `$0=char`\n-and `$1=uint`: this is because for impl A to apply, `uint:Bar` would\n-have to hold, and we know it does not or else the coherence check\n-would have failed.  So we might enter into our global cache: `$1 :\n-Foo<$0> => Impl B`.  Then we come along in a different scope, where a\n-generic type `A` is around with the bound `A:Bar`. Now suddenly the\n-impl is viable.\n-\n-The flaw in this imaginary DOOMSDAY SCENARIO is that we would not\n-currently conclude that `$1 : Foo<$0>` implies that `$0 == uint` and\n-`$1 == char`, even though it is true that (absent type parameters)\n-there is no other type the user could enter. However, it is not\n-*completely* implausible that we *could* draw this conclusion in the\n-future; we wouldn't have to guess types, in particular, we could be\n-led by the impls.\n+`select.rs`. At the moment, we use a very simple, conservative rule:\n+if there are any where-clauses in scope, then we use the local cache.\n+We used to try and draw finer-grained distinctions, but that led to a\n+serious of annoying and weird bugs like #22019 and #18290. This simple\n+rule seems to be pretty clearly safe and also still retains a very\n+high hit rate (~95% when compiling rustc).\n \n */"}, {"sha": "1c341df85cb9840e6f84c37d09c736b32457c015", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/88d8ba5ab3b1d22288b021708c3d87464e43b880/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d8ba5ab3b1d22288b021708c3d87464e43b880/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=88d8ba5ab3b1d22288b021708c3d87464e43b880", "patch": "@@ -705,14 +705,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(Some(candidate))\n     }\n \n-    fn pick_candidate_cache(&self,\n-                            cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n-                            -> &SelectionCache<'tcx>\n-    {\n-        // High-level idea: we have to decide whether to consult the\n-        // cache that is specific to this scope, or to consult the\n-        // global cache. We want the cache that is specific to this\n-        // scope whenever where clauses might affect the result.\n+    fn pick_candidate_cache(&self) -> &SelectionCache<'tcx> {\n+        // If there are any where-clauses in scope, then we always use\n+        // a cache local to this particular scope. Otherwise, we\n+        // switch to a global cache. We used to try and draw\n+        // finer-grained distinctions, but that led to a serious of\n+        // annoying and weird bugs like #22019 and #18290. This simple\n+        // rule seems to be pretty clearly safe and also still retains\n+        // a very high hit rate (~95% when compiling rustc).\n+        if !self.param_env().caller_bounds.is_empty() {\n+            return &self.param_env().selection_cache;\n+        }\n \n         // Avoid using the master cache during coherence and just rely\n         // on the local cache. This effectively disables caching\n@@ -725,28 +728,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return &self.param_env().selection_cache;\n         }\n \n-        // If the trait refers to any parameters in scope, then use\n-        // the cache of the param-environment.\n-        if\n-            cache_fresh_trait_pred.0.input_types().iter().any(\n-                |&t| ty::type_has_self(t) || ty::type_has_params(t))\n-        {\n-            return &self.param_env().selection_cache;\n-        }\n-\n-        // If the trait refers to unbound type variables, and there\n-        // are where clauses in scope, then use the local environment.\n-        // If there are no where clauses in scope, which is a very\n-        // common case, then we can use the global environment.\n-        // See the discussion in doc.rs for more details.\n-        if\n-            !self.param_env().caller_bounds.is_empty() &&\n-            cache_fresh_trait_pred.0.input_types().iter().any(\n-                |&t| ty::type_has_ty_infer(t))\n-        {\n-            return &self.param_env().selection_cache;\n-        }\n-\n         // Otherwise, we can use the global cache.\n         &self.tcx().selection_cache\n     }\n@@ -755,7 +736,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                              cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                              -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n-        let cache = self.pick_candidate_cache(cache_fresh_trait_pred);\n+        let cache = self.pick_candidate_cache();\n         let hashmap = cache.hashmap.borrow();\n         hashmap.get(&cache_fresh_trait_pred.0.trait_ref).map(|c| (*c).clone())\n     }\n@@ -764,7 +745,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                               cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n                               candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n-        let cache = self.pick_candidate_cache(&cache_fresh_trait_pred);\n+        let cache = self.pick_candidate_cache();\n         let mut hashmap = cache.hashmap.borrow_mut();\n         hashmap.insert(cache_fresh_trait_pred.0.trait_ref.clone(), candidate);\n     }"}, {"sha": "5d3195e193708000d99dd4c2df28abeeb33bf9e4", "filename": "src/test/run-pass/traits-issue-22019.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/88d8ba5ab3b1d22288b021708c3d87464e43b880/src%2Ftest%2Frun-pass%2Ftraits-issue-22019.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d8ba5ab3b1d22288b021708c3d87464e43b880/src%2Ftest%2Frun-pass%2Ftraits-issue-22019.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-issue-22019.rs?ref=88d8ba5ab3b1d22288b021708c3d87464e43b880", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test an issue where global caching was causing free regions from\n+// distinct scopes to be compared (`'g` and `'h`). The only important\n+// thing is that compilation succeeds here.\n+\n+#![allow(missing_copy_implementations)]\n+#![allow(unused_variables)]\n+\n+use std::borrow::ToOwned;\n+\n+pub struct CFGNode;\n+\n+pub type Node<'a> = &'a CFGNode;\n+\n+pub trait GraphWalk<'c, N> {\n+    /// Returns all the nodes in this graph.\n+    fn nodes(&'c self) where [N]:ToOwned<Vec<N>>;\n+}\n+\n+impl<'g> GraphWalk<'g, Node<'g>> for u32\n+{\n+    fn nodes(&'g self) where [Node<'g>]:ToOwned<Vec<Node<'g>>>\n+    { loop { } }\n+}\n+\n+impl<'h> GraphWalk<'h, Node<'h>> for u64\n+{\n+    fn nodes(&'h self) where [Node<'h>]:ToOwned<Vec<Node<'h>>>\n+    { loop { } }\n+}\n+\n+fn main()  { }"}]}