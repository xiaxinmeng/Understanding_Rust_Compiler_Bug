{"sha": "84dd6dfd9d19176cc3c94bc1448a841e44d57890", "node_id": "C_kwDOAAsO6NoAKDg0ZGQ2ZGZkOWQxOTE3NmNjM2M5NGJjMTQ0OGE4NDFlNDRkNTc4OTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-23T07:01:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-23T07:01:03Z"}, "message": "Auto merge of #109503 - matthiaskrgr:rollup-cnp7kdd, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #108954 (rustdoc: handle generics better when matching notable traits)\n - #109203 (refactor/feat: refactor identifier parsing a bit)\n - #109213 (Eagerly intern and check CrateNum/StableCrateId collisions)\n - #109358 (rustc: Remove unused `Session` argument from some attribute functions)\n - #109359 (Update stdarch)\n - #109378 (Remove Ty::is_region_ptr)\n - #109423 (Use region-erased self type during IAT selection)\n - #109447 (new solver cleanup + implement coherence)\n - #109501 (make link clickable)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "71e3ad442c58e0eed0c500c7f2cc62e440f9818c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71e3ad442c58e0eed0c500c7f2cc62e440f9818c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84dd6dfd9d19176cc3c94bc1448a841e44d57890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84dd6dfd9d19176cc3c94bc1448a841e44d57890", "html_url": "https://github.com/rust-lang/rust/commit/84dd6dfd9d19176cc3c94bc1448a841e44d57890", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84dd6dfd9d19176cc3c94bc1448a841e44d57890/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf811810fe8dc92b3ff25e7dd29fb3178c91d409", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf811810fe8dc92b3ff25e7dd29fb3178c91d409", "html_url": "https://github.com/rust-lang/rust/commit/cf811810fe8dc92b3ff25e7dd29fb3178c91d409"}, {"sha": "783f3a1965d46d6f5945b42bdc91b6d0319883f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/783f3a1965d46d6f5945b42bdc91b6d0319883f4", "html_url": "https://github.com/rust-lang/rust/commit/783f3a1965d46d6f5945b42bdc91b6d0319883f4"}], "stats": {"total": 1489, "additions": 903, "deletions": 586}, "files": [{"sha": "3495f4d51afdb90c40b9a336896d6b05a16ff38d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -5294,6 +5294,7 @@ name = \"rustc_span\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if\",\n+ \"indexmap\",\n  \"md-5\",\n  \"rustc_arena\",\n  \"rustc_data_structures\","}, {"sha": "c4771115cacf2b868a584e42a31873ea346dc432", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -180,6 +180,12 @@ impl Attribute {\n         self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n     }\n \n+    pub fn is_proc_macro_attr(&self) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| self.has_name(*kind))\n+    }\n+\n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n         match &self.kind {\n@@ -627,6 +633,22 @@ pub fn mk_attr_name_value_str(\n     mk_attr(g, style, path, args, span)\n }\n \n+pub fn filter_by_name(attrs: &[Attribute], name: Symbol) -> impl Iterator<Item = &Attribute> {\n+    attrs.iter().filter(move |attr| attr.has_name(name))\n+}\n+\n+pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n+    filter_by_name(attrs, name).next()\n+}\n+\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n+    find_by_name(attrs, name).and_then(|attr| attr.value_str())\n+}\n+\n+pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n+    find_by_name(attrs, name).is_some()\n+}\n+\n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| item.has_name(name))\n }"}, {"sha": "0b6b02ba00fb59f6e5f3c7fc2839e4eed983d3be", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -2185,7 +2185,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             def_id: self.local_def_id(param.id),\n             name,\n             span: self.lower_span(param.span()),\n-            pure_wrt_drop: self.tcx.sess.contains_name(&param.attrs, sym::may_dangle),\n+            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n             kind,\n             colon_span: param.colon_span.map(|s| self.lower_span(s)),\n             source,"}, {"sha": "93c854cc8094286560acfbfc133c4171e7220188", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -799,11 +799,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n+        if item.attrs.iter().any(|attr| attr.is_proc_macro_attr()) {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n@@ -973,7 +973,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n-                    && !self.session.contains_name(&item.attrs, sym::path)\n+                    && !attr::contains_name(&item.attrs, sym::path)\n                 {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n@@ -1248,7 +1248,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n "}, {"sha": "344a1e7f5e795d2bd8078421f4f62f103780ac32", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n-use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n+use rustc_ast::{attr, AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd};\n use rustc_errors::{Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n@@ -232,7 +232,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if self.sess.contains_name(&i.attrs, sym::start) {\n+                if attr::contains_name(&i.attrs, sym::start) {\n                     gate_feature_post!(\n                         &self,\n                         start,\n@@ -245,7 +245,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in self.sess.filter_by_name(&i.attrs, sym::repr) {\n+                for attr in attr::filter_by_name(&i.attrs, sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n@@ -306,7 +306,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n-                let link_name = self.sess.first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm =\n                     link_name.map_or(false, |val| val.as_str().starts_with(\"llvm.\"));\n                 if links_to_llvm {"}, {"sha": "d6dbdd3975e93e3fba93551b4529d2ff7de307c8", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,6 +1,6 @@\n //! Parsing and validation of builtin attributes\n \n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n@@ -556,8 +556,8 @@ where\n     (stab, const_stab, body_stab)\n }\n \n-pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n-    sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n+    attr::first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n #[derive(Clone, Debug)]\n@@ -1177,7 +1177,7 @@ fn allow_unstable<'a>(\n     attrs: &'a [Attribute],\n     symbol: Symbol,\n ) -> impl Iterator<Item = Symbol> + 'a {\n-    let attrs = sess.filter_by_name(attrs, symbol);\n+    let attrs = attr::filter_by_name(attrs, symbol);\n     let list = attrs\n         .filter_map(move |attr| {\n             attr.meta_item_list().or_else(|| {"}, {"sha": "a8c216407f931c01169d2b4204d386afd42c3d92", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -120,9 +120,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     && !self.upvars.is_empty()\n                 {\n                     item_msg = access_place_desc;\n-                    debug_assert!(\n-                        self.body.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty.is_region_ptr()\n-                    );\n+                    debug_assert!(self.body.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty.is_ref());\n                     debug_assert!(is_closure_or_generator(\n                         Place::ty_from(\n                             the_place_err.local,\n@@ -470,11 +468,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             {\n                 let local_decl = &self.body.local_decls[local];\n \n-                let (pointer_sigil, pointer_desc) = if local_decl.ty.is_region_ptr() {\n-                    (\"&\", \"reference\")\n-                } else {\n-                    (\"*const\", \"pointer\")\n-                };\n+                let (pointer_sigil, pointer_desc) =\n+                    if local_decl.ty.is_ref() { (\"&\", \"reference\") } else { (\"*const\", \"pointer\") };\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n@@ -1258,7 +1253,7 @@ fn suggest_ampmut<'tcx>(\n     (\n         suggestability,\n         highlight_span,\n-        if local_decl.ty.is_region_ptr() {\n+        if local_decl.ty.is_ref() {\n             format!(\"&mut {}\", ty_mut.ty)\n         } else {\n             format!(\"*mut {}\", ty_mut.ty)"}, {"sha": "cc32739d083c729f09dc6fe1b1b678a8093f02af", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,7 +1,7 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use rustc_ast as ast;\n-use rustc_ast::{walk_list, EnumDef, VariantData};\n+use rustc_ast::{attr, walk_list, EnumDef, VariantData};\n use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n@@ -106,7 +106,7 @@ fn extract_default_variant<'a>(\n     let default_variants: SmallVec<[_; 1]> = enum_def\n         .variants\n         .iter()\n-        .filter(|variant| cx.sess.contains_name(&variant.attrs, kw::Default))\n+        .filter(|variant| attr::contains_name(&variant.attrs, kw::Default))\n         .collect();\n \n     let variant = match default_variants.as_slice() {\n@@ -116,7 +116,7 @@ fn extract_default_variant<'a>(\n                 .variants\n                 .iter()\n                 .filter(|variant| matches!(variant.data, VariantData::Unit(..)))\n-                .filter(|variant| !cx.sess.contains_name(&variant.attrs, sym::non_exhaustive));\n+                .filter(|variant| !attr::contains_name(&variant.attrs, sym::non_exhaustive));\n \n             let mut diag = cx.struct_span_err(trait_span, \"no default declared\");\n             diag.help(\"make a unit variant default by placing `#[default]` above it\");\n@@ -146,7 +146,7 @@ fn extract_default_variant<'a>(\n                         if v.span == variant.span {\n                             None\n                         } else {\n-                            Some((cx.sess.find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n+                            Some((attr::find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n                         }\n                     })\n                     .collect();\n@@ -174,7 +174,7 @@ fn extract_default_variant<'a>(\n         return Err(());\n     }\n \n-    if let Some(non_exhaustive_attr) = cx.sess.find_by_name(&variant.attrs, sym::non_exhaustive) {\n+    if let Some(non_exhaustive_attr) = attr::find_by_name(&variant.attrs, sym::non_exhaustive) {\n         cx.struct_span_err(variant.ident.span, \"default variant must be exhaustive\")\n             .span_label(non_exhaustive_attr.span, \"declared `#[non_exhaustive]` here\")\n             .help(\"consider a manual implementation of `Default`\")\n@@ -191,7 +191,7 @@ fn validate_default_attribute(\n     default_variant: &rustc_ast::Variant,\n ) -> Result<(), ()> {\n     let attrs: SmallVec<[_; 1]> =\n-        cx.sess.filter_by_name(&default_variant.attrs, kw::Default).collect();\n+        attr::filter_by_name(&default_variant.attrs, kw::Default).collect();\n \n     let attr = match attrs.as_slice() {\n         [attr] => attr,"}, {"sha": "a73fed6ccb222e466c66bccda77848729b222759", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{self as ast, NodeId};\n+use rustc_ast::{self as ast, attr, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{parse_macro_name_and_helper_attrs, ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n@@ -34,7 +34,6 @@ enum ProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n-    sess: &'a Session,\n     macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a rustc_errors::Handler,\n@@ -56,7 +55,6 @@ pub fn inject(\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     let mut collect = CollectProcMacros {\n-        sess,\n         macros: Vec::new(),\n         in_root: true,\n         handler,\n@@ -160,7 +158,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.kind {\n-            if self.is_proc_macro_crate && self.sess.contains_name(&item.attrs, sym::macro_export) {\n+            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n@@ -176,7 +174,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         let mut found_attr: Option<&'a ast::Attribute> = None;\n \n         for attr in &item.attrs {\n-            if self.sess.is_proc_macro_attr(&attr) {\n+            if attr.is_proc_macro_attr() {\n                 if let Some(prev_attr) = found_attr {\n                     let prev_item = prev_attr.get_normal_item();\n                     let item = attr.get_normal_item();"}, {"sha": "caed40d9fa81b02e5e00e160ca43e7b0132a840c", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n use rustc_session::Session;\n@@ -16,10 +16,10 @@ pub fn inject(\n     let edition = sess.parse_sess.edition;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n         return krate;\n-    } else if sess.contains_name(&krate.attrs, sym::no_std) {\n-        if sess.contains_name(&krate.attrs, sym::compiler_builtins) {\n+    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n+        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[sym::core]\n         } else {\n             &[sym::core, sym::compiler_builtins]"}, {"sha": "44b9c4718a75feec636591e387204d5afb3b36c3", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,12 +1,11 @@\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n-use rustc_ast as ast;\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, attr};\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n use rustc_expand::base::*;\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{FileNameDisplayPreference, Span};\n use std::iter;\n@@ -291,14 +290,11 @@ pub fn expand_test_or_bench(\n                                         ),\n                                     ),\n                                     // ignore: true | false\n-                                    field(\n-                                        \"ignore\",\n-                                        cx.expr_bool(sp, should_ignore(&cx.sess, &item)),\n-                                    ),\n+                                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item)),),\n                                     // ignore_message: Some(\"...\") | None\n                                     field(\n                                         \"ignore_message\",\n-                                        if let Some(msg) = should_ignore_message(cx, &item) {\n+                                        if let Some(msg) = should_ignore_message(&item) {\n                                             cx.expr_some(sp, cx.expr_str(sp, msg))\n                                         } else {\n                                             cx.expr_none(sp)\n@@ -425,12 +421,12 @@ enum ShouldPanic {\n     Yes(Option<Symbol>),\n }\n \n-fn should_ignore(sess: &Session, i: &ast::Item) -> bool {\n-    sess.contains_name(&i.attrs, sym::ignore)\n+fn should_ignore(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, sym::ignore)\n }\n \n-fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n-    match cx.sess.find_by_name(&i.attrs, sym::ignore) {\n+fn should_ignore_message(i: &ast::Item) -> Option<Symbol> {\n+    match attr::find_by_name(&i.attrs, sym::ignore) {\n         Some(attr) => {\n             match attr.meta_item_list() {\n                 // Handle #[ignore(bar = \"foo\")]\n@@ -444,7 +440,7 @@ fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n }\n \n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n-    match cx.sess.find_by_name(&i.attrs, sym::should_panic) {\n+    match attr::find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {\n             let sd = &cx.sess.parse_sess.span_diagnostic;\n \n@@ -510,7 +506,7 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n }\n \n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n+    let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let sd = &cx.sess.parse_sess.span_diagnostic;\n     match &i.kind {\n         ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {"}, {"sha": "2d491b2dac8b250bbfdb410c4aa5a352415ddad7", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -47,11 +47,11 @@ pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        sess.first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n+        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n-    let test_runner = get_test_runner(sess, span_diagnostic, &krate);\n+    let test_runner = get_test_runner(span_diagnostic, &krate);\n \n     if sess.opts.test {\n         let panic_strategy = match (panic_strategy, sess.opts.unstable_opts.panic_abort_tests) {\n@@ -123,7 +123,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = i.into_inner();\n-        if let Some(name) = get_test_name(&self.cx.ext_cx.sess, &item) {\n+        if let Some(name) = get_test_name(&item) {\n             debug!(\"this is a test item\");\n \n             let test = Test { span: item.span, ident: item.ident, name };\n@@ -145,12 +145,12 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n // Beware, this is duplicated in librustc_passes/entry.rs (with\n // `rustc_hir::Item`), so make sure to keep them in sync.\n-fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPointType {\n+fn entry_point_type(item: &ast::Item, depth: usize) -> EntryPointType {\n     match item.kind {\n         ast::ItemKind::Fn(..) => {\n-            if sess.contains_name(&item.attrs, sym::start) {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if sess.contains_name(&item.attrs, sym::rustc_main) {\n+            } else if attr::contains_name(&item.attrs, sym::rustc_main) {\n                 EntryPointType::RustcMainAttr\n             } else if item.ident.name == sym::main {\n                 if depth == 0 {\n@@ -184,7 +184,7 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n         // Remove any #[rustc_main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let item = match entry_point_type(self.sess, &item, self.depth) {\n+        let item = match entry_point_type(&item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::RustcMainAttr | EntryPointType::Start => {\n                 item.map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_dead_code = attr::mk_attr_nested_word(\n@@ -373,16 +373,12 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     )\n }\n \n-fn get_test_name(sess: &Session, i: &ast::Item) -> Option<Symbol> {\n-    sess.first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n+fn get_test_name(i: &ast::Item) -> Option<Symbol> {\n+    attr::first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n }\n \n-fn get_test_runner(\n-    sess: &Session,\n-    sd: &rustc_errors::Handler,\n-    krate: &ast::Crate,\n-) -> Option<ast::Path> {\n-    let test_attr = sess.find_by_name(&krate.attrs, sym::test_runner)?;\n+fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n+    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n     let meta_list = test_attr.meta_item_list()?;\n     let span = test_attr.span;\n     match &*meta_list {"}, {"sha": "9463a1418ce31bc5242c3288155c51a2d8a482c7", "filename": "compiler/rustc_builtin_macros/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{AttrStyle, Attribute, MetaItem};\n+use rustc_ast::{attr, AttrStyle, Attribute, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_feature::AttributeTemplate;\n use rustc_lint_defs::builtin::DUPLICATE_MACRO_ATTRIBUTES;\n@@ -36,7 +36,7 @@ pub fn warn_on_duplicate_attribute(ecx: &ExtCtxt<'_>, item: &Annotatable, name:\n         _ => None,\n     };\n     if let Some(attrs) = attrs {\n-        if let Some(attr) = ecx.sess.find_by_name(attrs, name) {\n+        if let Some(attr) = attr::find_by_name(attrs, name) {\n             ecx.parse_sess().buffer_lint(\n                 DUPLICATE_MACRO_ATTRIBUTES,\n                 attr.span,"}, {"sha": "94806e0d798ed5a239c40aab8be54d771e453c53", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -48,9 +48,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n ) -> (Pointer, Value) {\n     let (ptr, vtable) = 'block: {\n         if let Abi::Scalar(_) = arg.layout().abi {\n-            'descend_newtypes: while !arg.layout().ty.is_unsafe_ptr()\n-                && !arg.layout().ty.is_region_ptr()\n-            {\n+            'descend_newtypes: while !arg.layout().ty.is_unsafe_ptr() && !arg.layout().ty.is_ref() {\n                 for i in 0..arg.layout().fields.count() {\n                     let field = arg.value_field(fx, mir::Field::new(i));\n                     if !field.layout().is_zst() {"}, {"sha": "ff2b005d757672cf666734e0890cba1c5abc8e40", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -5,12 +5,12 @@ use crate::llvm;\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n use crate::value::Value;\n+use rustc_ast::attr;\n use rustc_codegen_ssa::base::collect_debugger_visualizers_transitive;\n use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_session::config::{CrateType, DebugInfo};\n-\n use rustc_span::symbol::sym;\n use rustc_span::DebuggerVisualizerType;\n \n@@ -87,7 +87,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global<'ll>(cx: &CodegenCx<'ll, '\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        cx.tcx.sess.contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n+        attr::contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     // To ensure the section `__rustc_debug_gdb_scripts_section__` will not create\n     // ODR violations at link time, this section will not be emitted for rlibs since"}, {"sha": "7ce72d2172799ceaeb85ce9f0345f29d04cfbb82", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -8,6 +8,7 @@ use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n };\n use jobserver::{Acquired, Client};\n+use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -447,8 +448,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-    let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n-    let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n+    let no_builtins = attr::contains_name(crate_attrs, sym::no_builtins);\n+    let is_compiler_builtins = attr::contains_name(crate_attrs, sym::compiler_builtins);\n \n     let crate_info = CrateInfo::new(tcx, target_cpu);\n "}, {"sha": "4d34b3da5f501e82750fc61188390eefa953650f", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -809,7 +809,7 @@ impl CrateInfo {\n             .collect();\n         let local_crate_name = tcx.crate_name(LOCAL_CRATE);\n         let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-        let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n+        let subsystem = attr::first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n         let windows_subsystem = subsystem.map(|subsystem| {\n             if subsystem != sym::windows && subsystem != sym::console {\n                 tcx.sess.emit_fatal(errors::InvalidWindowsSubsystem { subsystem });"}, {"sha": "de1e00bd7a3e383b9548df7369baa5b971b58479", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -917,7 +917,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         //\n                         // This is also relevant for `Pin<&mut Self>`, where we need to peel the `Pin`.\n                         'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                            && !op.layout.ty.is_region_ptr()\n+                            && !op.layout.ty.is_ref()\n                         {\n                             for i in 0..op.layout.fields.count() {\n                                 let field = op.extract_field(bx, i);\n@@ -959,7 +959,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     Immediate(_) => {\n                         // See comment above explaining why we peel these newtypes\n                         'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n-                            && !op.layout.ty.is_region_ptr()\n+                            && !op.layout.ty.is_ref()\n                         {\n                             for i in 0..op.layout.fields.count() {\n                                 let field = op.extract_field(bx, i);"}, {"sha": "4377a292473319ccd11ff91f53e5a66073a1dcff", "filename": "compiler/rustc_error_codes/src/error_codes/E0794.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -59,6 +59,6 @@ In the definition of `bar`, the lifetime parameter `'a` is late-bound, while\n where `'a` is universally quantified and `'b` is substituted by a specific\n lifetime. It is not allowed to explicitly specify early-bound lifetime\n arguments when late-bound lifetime parameters are present (as for `bar_fn2`,\n-see issue #42868: https://github.com/rust-lang/rust/issues/42868), although the\n+see [issue #42868](https://github.com/rust-lang/rust/issues/42868)), although the\n types that are constrained by early-bound parameters can be specified (as for\n `bar_fn3`)."}, {"sha": "6eb0d24eb976ea253a8007c428540dacfb68bf92", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -776,16 +776,14 @@ impl SyntaxExtension {\n         let allow_internal_unstable =\n             attr::allow_internal_unstable(sess, &attrs).collect::<Vec<Symbol>>();\n \n-        let allow_internal_unsafe = sess.contains_name(attrs, sym::allow_internal_unsafe);\n-        let local_inner_macros = sess\n-            .find_by_name(attrs, sym::macro_export)\n+        let allow_internal_unsafe = attr::contains_name(attrs, sym::allow_internal_unsafe);\n+        let local_inner_macros = attr::find_by_name(attrs, sym::macro_export)\n             .and_then(|macro_export| macro_export.meta_item_list())\n             .map_or(false, |l| attr::list_contains_name(&l, sym::local_inner_macros));\n-        let collapse_debuginfo = sess.contains_name(attrs, sym::collapse_debuginfo);\n+        let collapse_debuginfo = attr::contains_name(attrs, sym::collapse_debuginfo);\n         tracing::debug!(?local_inner_macros, ?collapse_debuginfo, ?allow_internal_unsafe);\n \n-        let (builtin_name, helper_attrs) = sess\n-            .find_by_name(attrs, sym::rustc_builtin_macro)\n+        let (builtin_name, helper_attrs) = attr::find_by_name(attrs, sym::rustc_builtin_macro)\n             .map(|attr| {\n                 // Override `helper_attrs` passed above if it's a built-in macro,\n                 // marking `proc_macro_derive` macros as built-in is not a realistic use case."}, {"sha": "894995c1bfca7c37b9257b7fda2689e0da05fa37", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -31,6 +31,7 @@ use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability::AllowUnstable;\n+use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -2225,47 +2226,66 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let param_env = tcx.param_env(block.owner.to_def_id());\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n+\n         let mut fulfillment_errors = Vec::new();\n-        let mut applicable_candidates: Vec<_> = candidates\n-            .iter()\n-            .filter_map(|&(impl_, (assoc_item, def_scope))| {\n-                infcx.probe(|_| {\n-                    let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n+        let mut applicable_candidates: Vec<_> = infcx.probe(|_| {\n+            let universe = infcx.create_next_universe();\n+\n+            // Regions are not considered during selection.\n+            let self_ty = tcx.replace_escaping_bound_vars_uncached(\n+                self_ty,\n+                FnMutDelegate {\n+                    regions: &mut |_| tcx.lifetimes.re_erased,\n+                    types: &mut |bv| {\n+                        tcx.mk_placeholder(ty::PlaceholderType { universe, name: bv.kind })\n+                    },\n+                    consts: &mut |bv, ty| {\n+                        tcx.mk_const(ty::PlaceholderConst { universe, name: bv }, ty)\n+                    },\n+                },\n+            );\n \n-                    let impl_ty = tcx.type_of(impl_);\n-                    let impl_substs = infcx.fresh_item_substs(impl_);\n-                    let impl_ty = impl_ty.subst(tcx, impl_substs);\n-                    let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n+            candidates\n+                .iter()\n+                .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                    infcx.probe(|_| {\n+                        let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n \n-                    // Check that the Self-types can be related.\n-                    // FIXME(fmease): Should we use `eq` here?\n-                    ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+                        let impl_ty = tcx.type_of(impl_);\n+                        let impl_substs = infcx.fresh_item_substs(impl_);\n+                        let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                        let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n-                    // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_bounds = tcx.predicates_of(impl_);\n-                    let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n+                        // Check that the Self-types can be related.\n+                        // FIXME(fmease): Should we use `eq` here?\n+                        ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n \n-                    let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n+                        // Check whether the impl imposes obligations we have to worry about.\n+                        let impl_bounds = tcx.predicates_of(impl_);\n+                        let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n \n-                    let impl_obligations = traits::predicates_for_generics(\n-                        |_, _| cause.clone(),\n-                        param_env,\n-                        impl_bounds,\n-                    );\n+                        let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n \n-                    ocx.register_obligations(impl_obligations);\n+                        let impl_obligations = traits::predicates_for_generics(\n+                            |_, _| cause.clone(),\n+                            param_env,\n+                            impl_bounds,\n+                        );\n \n-                    let mut errors = ocx.select_where_possible();\n-                    if !errors.is_empty() {\n-                        fulfillment_errors.append(&mut errors);\n-                        return None;\n-                    }\n+                        ocx.register_obligations(impl_obligations);\n+\n+                        let mut errors = ocx.select_where_possible();\n+                        if !errors.is_empty() {\n+                            fulfillment_errors.append(&mut errors);\n+                            return None;\n+                        }\n \n-                    // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n-                    Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                        // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n+                        Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                    })\n                 })\n-            })\n-            .collect();\n+                .collect()\n+        });\n \n         if applicable_candidates.len() > 1 {\n             return Err(self.complain_about_ambiguous_inherent_assoc_type("}, {"sha": "4846579b9809b041487a705ca652c97e5c0ace36", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1487,7 +1487,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     {\n                         let deref_kind = if checked_ty.is_box() {\n                             \"unboxing the value\"\n-                        } else if checked_ty.is_region_ptr() {\n+                        } else if checked_ty.is_ref() {\n                             \"dereferencing the borrow\"\n                         } else {\n                             \"dereferencing the type\""}, {"sha": "b219be4ae199219a6980f35b5e9070ab76298c41", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 .inputs()\n                                 .skip_binder()\n                                 .get(0)\n-                                .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n+                                .filter(|ty| ty.is_ref() && !rcvr_ty.is_ref())\n                                 .copied()\n                                 .unwrap_or(rcvr_ty),\n                         };"}, {"sha": "9afe9cc1e760e2312b43c9283128ed993ee48ccc", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -591,8 +591,8 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n-    pub fn intercrate(mut self) -> Self {\n-        self.intercrate = true;\n+    pub fn intercrate(mut self, intercrate: bool) -> Self {\n+        self.intercrate = intercrate;\n         self\n     }\n "}, {"sha": "1c58caa03532eaaf5ecf7e3868a02e619d021360", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::attr;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -8,7 +9,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n \n     for id in tcx.hir().items() {\n         let attrs = tcx.hir().attrs(id.hir_id());\n-        if tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n+        if attr::contains_name(attrs, sym::rustc_proc_macro_decls) {\n             decls = Some(id.owner_id.def_id);\n         }\n     }"}, {"sha": "8abdcebb7516d373796c4d53471fab75ce75b59b", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -505,7 +505,7 @@ pub fn build_output_filenames(attrs: &[ast::Attribute], sess: &Session) -> Outpu\n                 .opts\n                 .crate_name\n                 .clone()\n-                .or_else(|| rustc_attr::find_crate_name(sess, attrs).map(|n| n.to_string()))\n+                .or_else(|| rustc_attr::find_crate_name(attrs).map(|n| n.to_string()))\n                 .unwrap_or_else(|| sess.io.input.filestem().to_owned());\n \n             OutputFilenames::new("}, {"sha": "29ba480cdd20e4505f3701c5b9342f35096d76f1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -358,29 +358,29 @@ impl EarlyLintPass for UnsafeCode {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleFn);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameFn);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::link_section) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionFn);\n                 }\n             }\n \n             ast::ItemKind::Static(..) => {\n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleStatic);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameStatic);\n                 }\n \n-                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n+                if let Some(attr) = attr::find_by_name(&it.attrs, sym::link_section) {\n                     self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionStatic);\n                 }\n             }\n@@ -391,10 +391,10 @@ impl EarlyLintPass for UnsafeCode {\n \n     fn check_impl_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n         if let ast::AssocItemKind::Fn(..) = it.kind {\n-            if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+            if let Some(attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n                 self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleMethod);\n             }\n-            if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+            if let Some(attr) = attr::find_by_name(&it.attrs, sym::export_name) {\n                 self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameMethod);\n             }\n         }\n@@ -1123,12 +1123,12 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n         };\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = cx.sess().find_by_name(attrs, sym::no_mangle) {\n+                if let Some(no_mangle_attr) = attr::find_by_name(attrs, sym::no_mangle) {\n                     check_no_mangle_on_generic_fn(no_mangle_attr, None, generics, it.span);\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if cx.sess().contains_name(attrs, sym::no_mangle) {\n+                if attr::contains_name(attrs, sym::no_mangle) {\n                     // account for \"pub const\" (#45562)\n                     let start = cx\n                         .tcx\n@@ -1152,9 +1152,8 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n             hir::ItemKind::Impl(hir::Impl { generics, items, .. }) => {\n                 for it in *items {\n                     if let hir::AssocItemKind::Fn { .. } = it.kind {\n-                        if let Some(no_mangle_attr) = cx\n-                            .sess()\n-                            .find_by_name(cx.tcx.hir().attrs(it.id.hir_id()), sym::no_mangle)\n+                        if let Some(no_mangle_attr) =\n+                            attr::find_by_name(cx.tcx.hir().attrs(it.id.hir_id()), sym::no_mangle)\n                         {\n                             check_no_mangle_on_generic_fn(\n                                 no_mangle_attr,\n@@ -1836,7 +1835,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n         }\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n-        if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n+        if let Some(attr) = attr::find_by_name(attrs, sym::rustc_test_marker) {\n             cx.emit_spanned_lint(UNNAMEABLE_TEST_ITEMS, attr.span, BuiltinUnnameableTestItems);\n         }\n     }"}, {"sha": "9efc14849c76fb1fcb004df4b6f4431d8512aa64", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -328,8 +328,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            cx.sess()\n-                .find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n+            attr::find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n@@ -489,7 +488,7 @@ impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         match it.kind {\n-            hir::ItemKind::Static(..) if !cx.sess().contains_name(attrs, sym::no_mangle) => {\n+            hir::ItemKind::Static(..) if !attr::contains_name(attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "23c1aebb8ae38a1af5a40fc87ee59d202b7955c1", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 38, "deletions": 74, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -6,11 +6,11 @@ use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob\n \n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{MappedReadGuard, MappedWriteGuard, ReadGuard, WriteGuard};\n use rustc_expand::base::SyntaxExtension;\n-use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, StableCrateIdMap, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::TyCtxt;\n@@ -46,9 +46,8 @@ pub struct CStore {\n     /// This crate has a `#[alloc_error_handler]` item.\n     has_alloc_error_handler: bool,\n \n-    /// This map is used to verify we get no hash conflicts between\n-    /// `StableCrateId` values.\n-    pub(crate) stable_crate_ids: FxHashMap<StableCrateId, CrateNum>,\n+    /// The interned [StableCrateId]s.\n+    pub(crate) stable_crate_ids: StableCrateIdMap,\n \n     /// Unused externs of the crate\n     unused_externs: Vec<Symbol>,\n@@ -144,9 +143,21 @@ impl CStore {\n         })\n     }\n \n-    fn alloc_new_crate_num(&mut self) -> CrateNum {\n-        self.metas.push(None);\n-        CrateNum::new(self.metas.len() - 1)\n+    fn intern_stable_crate_id(&mut self, root: &CrateRoot) -> Result<CrateNum, CrateError> {\n+        assert_eq!(self.metas.len(), self.stable_crate_ids.len());\n+        let num = CrateNum::new(self.stable_crate_ids.len());\n+        if let Some(&existing) = self.stable_crate_ids.get(&root.stable_crate_id()) {\n+            let crate_name0 = root.name();\n+            if let Some(crate_name1) = self.metas[existing].as_ref().map(|data| data.name()) {\n+                Err(CrateError::StableCrateIdCollision(crate_name0, crate_name1))\n+            } else {\n+                Err(CrateError::SymbolConflictsCurrent(crate_name0))\n+            }\n+        } else {\n+            self.metas.push(None);\n+            self.stable_crate_ids.insert(root.stable_crate_id(), num);\n+            Ok(num)\n+        }\n     }\n \n     pub fn has_crate_data(&self, cnum: CrateNum) -> bool {\n@@ -247,7 +258,7 @@ impl CStore {\n     }\n \n     pub fn new(sess: &Session) -> CStore {\n-        let mut stable_crate_ids = FxHashMap::default();\n+        let mut stable_crate_ids = StableCrateIdMap::default();\n         stable_crate_ids.insert(sess.local_stable_crate_id(), LOCAL_CRATE);\n         CStore {\n             // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n@@ -342,42 +353,6 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         None\n     }\n \n-    fn verify_no_symbol_conflicts(&self, root: &CrateRoot) -> Result<(), CrateError> {\n-        // Check for (potential) conflicts with the local crate\n-        if self.sess.local_stable_crate_id() == root.stable_crate_id() {\n-            return Err(CrateError::SymbolConflictsCurrent(root.name()));\n-        }\n-\n-        // Check for conflicts with any crate loaded so far\n-        for (_, other) in self.cstore.iter_crate_data() {\n-            // Same stable crate id but different SVH\n-            if other.stable_crate_id() == root.stable_crate_id() && other.hash() != root.hash() {\n-                bug!(\n-                    \"Previously returned E0523 here. \\\n-                     See https://github.com/rust-lang/rust/pull/100599 for additional discussion.\\\n-                     root.name() = {}.\",\n-                    root.name()\n-                );\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn verify_no_stable_crate_id_hash_conflicts(\n-        &mut self,\n-        root: &CrateRoot,\n-        cnum: CrateNum,\n-    ) -> Result<(), CrateError> {\n-        if let Some(existing) = self.cstore.stable_crate_ids.insert(root.stable_crate_id(), cnum) {\n-            let crate_name0 = root.name();\n-            let crate_name1 = self.cstore.get_crate_data(existing).name();\n-            return Err(CrateError::StableCrateIdCollision(crate_name0, crate_name1));\n-        }\n-\n-        Ok(())\n-    }\n-\n     fn register_crate(\n         &mut self,\n         host_lib: Option<Library>,\n@@ -396,7 +371,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             self.sess.opts.externs.get(name.as_str()).map_or(false, |e| e.is_private_dep);\n \n         // Claim this crate number and cache it\n-        let cnum = self.cstore.alloc_new_crate_num();\n+        let cnum = self.cstore.intern_stable_crate_id(&crate_root)?;\n \n         info!(\n             \"register crate `{}` (cnum = {}. private_dep = {})\",\n@@ -432,14 +407,6 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             None\n         };\n \n-        // Perform some verification *after* resolve_crate_deps() above is\n-        // known to have been successful. It seems that - in error cases - the\n-        // cstore can be in a temporarily invalid state between cnum allocation\n-        // and dependency resolution and the verification code would produce\n-        // ICEs in that case (see #83045).\n-        self.verify_no_symbol_conflicts(&crate_root)?;\n-        self.verify_no_stable_crate_id_hash_conflicts(&crate_root, cnum)?;\n-\n         let crate_metadata = CrateMetadata::new(\n             self.sess,\n             &self.cstore,\n@@ -720,8 +687,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         // compilation mode also comes into play.\n         let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n-        let mut needs_panic_runtime =\n-            self.sess.contains_name(&krate.attrs, sym::needs_panic_runtime);\n+        let mut needs_panic_runtime = attr::contains_name(&krate.attrs, sym::needs_panic_runtime);\n \n         for (cnum, data) in self.cstore.iter_crate_data() {\n             needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n@@ -789,7 +755,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         info!(\"loading profiler\");\n \n         let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);\n-        if name == sym::profiler_builtins && self.sess.contains_name(&krate.attrs, sym::no_core) {\n+        if name == sym::profiler_builtins && attr::contains_name(&krate.attrs, sym::no_core) {\n             self.sess.emit_err(errors::ProfilerBuiltinsNeedsCore);\n         }\n \n@@ -803,14 +769,14 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n+        self.cstore.has_global_allocator = match &*global_allocator_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess.emit_err(errors::NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n         };\n-        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(&self.sess, krate) {\n+        self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(krate) {\n             [span1, span2, ..] => {\n                 self.sess\n                     .emit_err(errors::NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n@@ -822,7 +788,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n-        if !self.sess.contains_name(&krate.attrs, sym::needs_allocator)\n+        if !attr::contains_name(&krate.attrs, sym::needs_allocator)\n             && !self.cstore.iter_crate_data().any(|(_, data)| data.needs_allocator())\n         {\n             return;\n@@ -881,7 +847,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n             // allocator. At this point our allocator request is typically fulfilled\n             // by the standard library, denoted by the `#![default_lib_allocator]`\n             // attribute.\n-            if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n+            if !attr::contains_name(&krate.attrs, sym::default_lib_allocator)\n                 && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n             {\n                 self.sess.emit_err(errors::GlobalAllocRequired);\n@@ -1003,7 +969,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n                     }\n                     None => item.ident.name,\n                 };\n-                let dep_kind = if self.sess.contains_name(&item.attrs, sym::no_link) {\n+                let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n                     CrateDepKind::MacrosOnly\n                 } else {\n                     CrateDepKind::Explicit\n@@ -1049,16 +1015,15 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     }\n }\n \n-fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n-    struct Finder<'a> {\n-        sess: &'a Session,\n+fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder {\n         name: Symbol,\n         spans: Vec<Span>,\n     }\n-    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n         fn visit_item(&mut self, item: &'ast ast::Item) {\n             if item.ident.name == self.name\n-                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n             {\n                 self.spans.push(item.span);\n             }\n@@ -1067,21 +1032,20 @@ fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     }\n \n     let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n-    let mut f = Finder { sess, name, spans: Vec::new() };\n+    let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }\n \n-fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n-    struct Finder<'a> {\n-        sess: &'a Session,\n+fn alloc_error_handler_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder {\n         name: Symbol,\n         spans: Vec<Span>,\n     }\n-    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n         fn visit_item(&mut self, item: &'ast ast::Item) {\n             if item.ident.name == self.name\n-                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n             {\n                 self.spans.push(item.span);\n             }\n@@ -1090,7 +1054,7 @@ fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     }\n \n     let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::oom));\n-    let mut f = Finder { sess, name, spans: Vec::new() };\n+    let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }"}, {"sha": "cabc144077fd518987c2f14ff6cf06c2ff8fc825", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1709,10 +1709,6 @@ impl CrateMetadata {\n         self.root.name\n     }\n \n-    pub(crate) fn stable_crate_id(&self) -> StableCrateId {\n-        self.root.stable_crate_id\n-    }\n-\n     pub(crate) fn hash(&self) -> Svh {\n         self.root.hash\n     }"}, {"sha": "caff01498d91aaf14dcdcbc264c5dbf5952090e2", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -595,7 +595,10 @@ impl CrateStore for CStore {\n     }\n \n     fn stable_crate_id_to_crate_num(&self, stable_crate_id: StableCrateId) -> CrateNum {\n-        self.stable_crate_ids[&stable_crate_id]\n+        *self\n+            .stable_crate_ids\n+            .get(&stable_crate_id)\n+            .unwrap_or_else(|| bug!(\"uninterned StableCrateId: {stable_crate_id:?}\"))\n     }\n \n     /// Returns the `DefKey` for a given `DefId`. This indicates the"}, {"sha": "0b438d1ffad812d5cc956de19a31e42ad2ff2630", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -681,17 +681,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n                 has_alloc_error_handler: tcx.has_alloc_error_handler(LOCAL_CRATE),\n                 has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n-                has_default_lib_allocator: tcx\n-                    .sess\n-                    .contains_name(&attrs, sym::default_lib_allocator),\n+                has_default_lib_allocator: attr::contains_name(&attrs, sym::default_lib_allocator),\n                 proc_macro_data,\n                 debugger_visualizers,\n-                compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n-                needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n-                needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n-                no_builtins: tcx.sess.contains_name(&attrs, sym::no_builtins),\n-                panic_runtime: tcx.sess.contains_name(&attrs, sym::panic_runtime),\n-                profiler_runtime: tcx.sess.contains_name(&attrs, sym::profiler_runtime),\n+                compiler_builtins: attr::contains_name(&attrs, sym::compiler_builtins),\n+                needs_allocator: attr::contains_name(&attrs, sym::needs_allocator),\n+                needs_panic_runtime: attr::contains_name(&attrs, sym::needs_panic_runtime),\n+                no_builtins: attr::contains_name(&attrs, sym::no_builtins),\n+                panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n+                profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n                 symbol_mangling_version: tcx.sess.opts.get_symbol_mangling_version(),\n \n                 crate_deps,\n@@ -1747,11 +1745,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 // Proc-macros may have attributes like `#[allow_internal_unstable]`,\n                 // so downstream crates need access to them.\n                 let attrs = hir.attrs(proc_macro);\n-                let macro_kind = if tcx.sess.contains_name(attrs, sym::proc_macro) {\n+                let macro_kind = if attr::contains_name(attrs, sym::proc_macro) {\n                     MacroKind::Bang\n-                } else if tcx.sess.contains_name(attrs, sym::proc_macro_attribute) {\n+                } else if attr::contains_name(attrs, sym::proc_macro_attribute) {\n                     MacroKind::Attr\n-                } else if let Some(attr) = tcx.sess.find_by_name(attrs, sym::proc_macro_derive) {\n+                } else if let Some(attr) = attr::find_by_name(attrs, sym::proc_macro_derive) {\n                     // This unwrap chain should have been checked by the proc-macro harness.\n                     name = attr.meta_item_list().unwrap()[0]\n                         .meta_item()"}, {"sha": "512d67f34b97d6f49ca13468cc37a9895c15e16d", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -63,15 +63,14 @@ impl Certainty {\n             (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n             (Certainty::Yes, Certainty::Maybe(_)) => other,\n             (Certainty::Maybe(_), Certainty::Yes) => self,\n-            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n-                Certainty::Maybe(MaybeCause::Overflow)\n-            }\n-            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n-            // may still result in failure.\n-            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n-            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n                 Certainty::Maybe(MaybeCause::Ambiguity)\n             }\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(MaybeCause::Overflow))\n+            | (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Ambiguity))\n+            | (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n+            }\n         }\n     }\n }"}, {"sha": "a1c1acc4a25414754a010d900f31dade4af3b851", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -28,7 +28,7 @@ use crate::ty::{\n     TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy, Visibility,\n };\n use crate::ty::{GenericArg, InternalSubsts, SubstsRef};\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::intern::Interned;\n@@ -2520,9 +2520,9 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     providers.extern_mod_stmt_cnum =\n         |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n     providers.is_panic_runtime =\n-        |tcx, LocalCrate| tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::panic_runtime);\n+        |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime);\n     providers.is_compiler_builtins =\n-        |tcx, LocalCrate| tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n+        |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n     providers.has_panic_handler = |tcx, LocalCrate| {\n         // We want to check if the panic handler was defined in this crate\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())"}, {"sha": "35a581d314cd471ce76a21715f409083a53c1287", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1925,11 +1925,6 @@ impl<'tcx> Ty<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn is_region_ptr(self) -> bool {\n-        matches!(self.kind(), Ref(..))\n-    }\n-\n     #[inline]\n     pub fn is_mutable_ptr(self) -> bool {\n         matches!(\n@@ -1956,7 +1951,7 @@ impl<'tcx> Ty<'tcx> {\n     /// Tests if this is any kind of primitive pointer type (reference, raw pointer, fn pointer).\n     #[inline]\n     pub fn is_any_ptr(self) -> bool {\n-        self.is_region_ptr() || self.is_unsafe_ptr() || self.is_fn_ptr()\n+        self.is_ref() || self.is_unsafe_ptr() || self.is_fn_ptr()\n     }\n \n     #[inline]"}, {"sha": "1923e10ddb5865afd09dbe85ce2be51b604aee83", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -3,6 +3,7 @@ use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n+use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_errors::ErrorGuaranteed;\n@@ -680,7 +681,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are codegened in.\n-        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n+        let mut check_overflow = attr::contains_name(attrs, sym::rustc_inherit_overflow_checks);\n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();\n         // Constants always need overflow checks."}, {"sha": "6fd9b9dbb5755f106e54cf42f4ac249e3fb159fd", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -185,7 +185,7 @@ impl<'tcx> Cx<'tcx> {\n         if self.typeck_results().is_coercion_cast(source.hir_id) {\n             // Convert the lexpr to a vexpr.\n             ExprKind::Use { source: self.mirror_expr(source) }\n-        } else if self.typeck_results().expr_ty(source).is_region_ptr() {\n+        } else if self.typeck_results().expr_ty(source).is_ref() {\n             // Special cased so that we can type check that the element\n             // type of the source matches the pointed to type of the\n             // destination."}, {"sha": "96765c296e79bdc0b266710380853c5b4c103d1c", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -336,7 +336,7 @@ parse_expected_identifier_found_reserved_keyword = expected identifier, found re\n parse_expected_identifier_found_doc_comment = expected identifier, found doc comment\n parse_expected_identifier = expected identifier\n \n-parse_sugg_escape_to_use_as_identifier = escape `{$ident_name}` to use it as an identifier\n+parse_sugg_escape_identifier = escape `{$ident_name}` to use it as an identifier\n \n parse_sugg_remove_comma = remove this comma\n "}, {"sha": "a9d116012ae5bf680dfb337568739e436342fc0e", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -888,12 +888,12 @@ pub(crate) struct InvalidMetaItem {\n \n #[derive(Subdiagnostic)]\n #[suggestion(\n-    parse_sugg_escape_to_use_as_identifier,\n+    parse_sugg_escape_identifier,\n     style = \"verbose\",\n     applicability = \"maybe-incorrect\",\n     code = \"r#\"\n )]\n-pub(crate) struct SuggEscapeToUseAsIdentifier {\n+pub(crate) struct SuggEscapeIdentifier {\n     #[primary_span]\n     pub span: Span,\n     pub ident_name: String,\n@@ -937,7 +937,7 @@ impl ExpectedIdentifierFound {\n pub(crate) struct ExpectedIdentifier {\n     pub span: Span,\n     pub token: Token,\n-    pub suggest_raw: Option<SuggEscapeToUseAsIdentifier>,\n+    pub suggest_raw: Option<SuggEscapeIdentifier>,\n     pub suggest_remove_comma: Option<SuggRemoveComma>,\n     pub help_cannot_start_number: Option<HelpIdentifierStartsWithNumber>,\n }\n@@ -986,7 +986,10 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n \n #[derive(Subdiagnostic)]\n #[help(parse_invalid_identifier_with_leading_number)]\n-pub(crate) struct HelpIdentifierStartsWithNumber;\n+pub(crate) struct HelpIdentifierStartsWithNumber {\n+    #[primary_span]\n+    pub num_span: Span,\n+}\n \n pub(crate) struct ExpectedSemi {\n     pub span: Span,"}, {"sha": "9544afd3d6df941e23e8c52f6671de6b2bec7cca", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 89, "deletions": 34, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -6,14 +6,14 @@ use super::{\n use crate::errors::{\n     AmbiguousPlus, AttributeOnParamType, BadQPathStage2, BadTypePlus, BadTypePlusSub,\n     ComparisonOperatorsCannotBeChained, ComparisonOperatorsCannotBeChainedSugg,\n-    ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentOnParamType,\n-    DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n+    ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentDoesNotDocumentAnything,\n+    DocCommentOnParamType, DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n     GenericParamsWithoutAngleBrackets, GenericParamsWithoutAngleBracketsSugg,\n     HelpIdentifierStartsWithNumber, InInTypo, IncorrectAwait, IncorrectSemicolon,\n     IncorrectUseOfAwait, ParenthesesInForHead, ParenthesesInForHeadSugg,\n     PatternMethodParamWithoutBody, QuestionMarkInType, QuestionMarkInTypeSugg, SelfParamNotFirst,\n     StructLiteralBodyWithoutPath, StructLiteralBodyWithoutPathSugg, StructLiteralNeedingParens,\n-    StructLiteralNeedingParensSugg, SuggEscapeToUseAsIdentifier, SuggRemoveComma,\n+    StructLiteralNeedingParensSugg, SuggEscapeIdentifier, SuggRemoveComma,\n     UnexpectedConstInGenericParam, UnexpectedConstParamDeclaration,\n     UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets, UseEqInstead,\n };\n@@ -38,7 +38,7 @@ use rustc_errors::{\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n+use rustc_span::{Span, SpanSnippetError, Symbol, DUMMY_SP};\n use std::mem::take;\n use std::ops::{Deref, DerefMut};\n use thin_vec::{thin_vec, ThinVec};\n@@ -268,7 +268,21 @@ impl<'a> Parser<'a> {\n         self.sess.source_map().span_to_snippet(span)\n     }\n \n-    pub(super) fn expected_ident_found(&mut self) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+    /// Emits an error with suggestions if an identifier was expected but not found.\n+    ///\n+    /// Returns a possibly recovered identifier.\n+    pub(super) fn expected_ident_found(\n+        &mut self,\n+        recover: bool,\n+    ) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n+        if let TokenKind::DocComment(..) = self.prev_token.kind {\n+            return Err(DocCommentDoesNotDocumentAnything {\n+                span: self.prev_token.span,\n+                missing_comma: None,\n+            }\n+            .into_diagnostic(&self.sess.span_diagnostic));\n+        }\n+\n         let valid_follow = &[\n             TokenKind::Eq,\n             TokenKind::Colon,\n@@ -281,31 +295,51 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(Delimiter::Parenthesis),\n         ];\n \n-        let suggest_raw = match self.token.ident() {\n-            Some((ident, false))\n-                if ident.is_raw_guess()\n-                    && self.look_ahead(1, |t| valid_follow.contains(&t.kind)) =>\n-            {\n-                Some(SuggEscapeToUseAsIdentifier {\n-                    span: ident.span.shrink_to_lo(),\n-                    // `Symbol::to_string()` is different from `Symbol::into_diagnostic_arg()`,\n-                    // which uses `Symbol::to_ident_string()` and \"helpfully\" adds an implicit `r#`\n-                    ident_name: ident.name.to_string(),\n-                })\n-            }\n-            _ => None,\n-        };\n+        let mut recovered_ident = None;\n+        // we take this here so that the correct original token is retained in\n+        // the diagnostic, regardless of eager recovery.\n+        let bad_token = self.token.clone();\n+\n+        // suggest prepending a keyword in identifier position with `r#`\n+        let suggest_raw = if let Some((ident, false)) = self.token.ident()\n+            && ident.is_raw_guess()\n+            && self.look_ahead(1, |t| valid_follow.contains(&t.kind))\n+        {\n+            recovered_ident = Some((ident, true));\n+\n+            // `Symbol::to_string()` is different from `Symbol::into_diagnostic_arg()`,\n+            // which uses `Symbol::to_ident_string()` and \"helpfully\" adds an implicit `r#`\n+            let ident_name = ident.name.to_string();\n+\n+            Some(SuggEscapeIdentifier {\n+                span: ident.span.shrink_to_lo(),\n+                ident_name\n+            })\n+        } else { None };\n+\n+        let suggest_remove_comma =\n+            if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n+                if recover {\n+                    self.bump();\n+                    recovered_ident = self.ident_or_err(false).ok();\n+                };\n \n-        let suggest_remove_comma = (self.token == token::Comma\n-            && self.look_ahead(1, |t| t.is_ident()))\n-        .then_some(SuggRemoveComma { span: self.token.span });\n+                Some(SuggRemoveComma { span: bad_token.span })\n+            } else {\n+                None\n+            };\n \n-        let help_cannot_start_number =\n-            self.is_lit_bad_ident().then_some(HelpIdentifierStartsWithNumber);\n+        let help_cannot_start_number = self.is_lit_bad_ident().map(|(len, valid_portion)| {\n+            let (invalid, valid) = self.token.span.split_at(len as u32);\n+\n+            recovered_ident = Some((Ident::new(valid_portion, valid), false));\n+\n+            HelpIdentifierStartsWithNumber { num_span: invalid }\n+        });\n \n         let err = ExpectedIdentifier {\n-            span: self.token.span,\n-            token: self.token.clone(),\n+            span: bad_token.span,\n+            token: bad_token,\n             suggest_raw,\n             suggest_remove_comma,\n             help_cannot_start_number,\n@@ -314,6 +348,7 @@ impl<'a> Parser<'a> {\n \n         // if the token we have is a `<`\n         // it *might* be a misplaced generic\n+        // FIXME: could we recover with this?\n         if self.token == token::Lt {\n             // all keywords that could have generic applied\n             let valid_prev_keywords =\n@@ -364,18 +399,38 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        err\n+        if let Some(recovered_ident) = recovered_ident && recover {\n+            err.emit();\n+            Ok(recovered_ident)\n+        } else {\n+            Err(err)\n+        }\n+    }\n+\n+    pub(super) fn expected_ident_found_err(&mut self) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        self.expected_ident_found(false).unwrap_err()\n     }\n \n     /// Checks if the current token is a integer or float literal and looks like\n     /// it could be a invalid identifier with digits at the start.\n-    pub(super) fn is_lit_bad_ident(&mut self) -> bool {\n-        matches!(self.token.uninterpolate().kind, token::Literal(Lit { kind: token::LitKind::Integer | token::LitKind::Float, .. })\n-            // ensure that the integer literal is followed by a *invalid*\n-            // suffix: this is how we know that it is a identifier with an\n-            // invalid beginning.\n-            if rustc_ast::MetaItemLit::from_token(&self.token).is_none()\n-        )\n+    ///\n+    /// Returns the number of characters (bytes) composing the invalid portion\n+    /// of the identifier and the valid portion of the identifier.\n+    pub(super) fn is_lit_bad_ident(&mut self) -> Option<(usize, Symbol)> {\n+        // ensure that the integer literal is followed by a *invalid*\n+        // suffix: this is how we know that it is a identifier with an\n+        // invalid beginning.\n+        if let token::Literal(Lit {\n+            kind: token::LitKind::Integer | token::LitKind::Float,\n+            symbol,\n+            suffix,\n+        }) = self.token.kind\n+            && rustc_ast::MetaItemLit::from_token(&self.token).is_none()\n+        {\n+            Some((symbol.as_str().len(), suffix.unwrap()))\n+        } else {\n+            None\n+        }\n     }\n \n     pub(super) fn expected_one_of_not_found("}, {"sha": "ae8fe90e9d6116bddbc9328bdf8b0194fd3c1c94", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1181,7 +1181,7 @@ impl<'a> Parser<'a> {\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n         let impl_span = self.token.span;\n-        let mut err = self.expected_ident_found();\n+        let mut err = self.expected_ident_found_err();\n \n         // Only try to recover if this is implementing a trait for a type\n         let mut impl_info = match self.parse_item_impl(attrs, defaultness) {\n@@ -1744,7 +1744,7 @@ impl<'a> Parser<'a> {\n     /// Parses a field identifier. Specialized version of `parse_ident_common`\n     /// for better diagnostics and suggestions.\n     fn parse_field_ident(&mut self, adt_ty: &str, lo: Span) -> PResult<'a, Ident> {\n-        let (ident, is_raw) = self.ident_or_err()?;\n+        let (ident, is_raw) = self.ident_or_err(true)?;\n         if !is_raw && ident.is_reserved() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n             let err = if self.check_fn_front_matter(false, Case::Sensitive) {\n@@ -1776,7 +1776,7 @@ impl<'a> Parser<'a> {\n                     Err(err) => {\n                         err.cancel();\n                         self.restore_snapshot(snapshot);\n-                        self.expected_ident_found()\n+                        self.expected_ident_found_err()\n                     }\n                 }\n             } else if self.eat_keyword(kw::Struct) {\n@@ -1792,11 +1792,11 @@ impl<'a> Parser<'a> {\n                     Err(err) => {\n                         err.cancel();\n                         self.restore_snapshot(snapshot);\n-                        self.expected_ident_found()\n+                        self.expected_ident_found_err()\n                     }\n                 }\n             } else {\n-                let mut err = self.expected_ident_found();\n+                let mut err = self.expected_ident_found_err();\n                 if self.eat_keyword_noexpect(kw::Let)\n                     && let removal_span = self.prev_token.span.until(self.token.span)\n                     && let Ok(ident) = self.parse_ident_common(false)"}, {"sha": "53c25a80c4bf32752ce306607e3577ac8fd22b6a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -42,8 +42,7 @@ use thin_vec::ThinVec;\n use tracing::debug;\n \n use crate::errors::{\n-    DocCommentDoesNotDocumentAnything, IncorrectVisibilityRestriction, MismatchedClosingDelimiter,\n-    NonStringAbiLiteral,\n+    IncorrectVisibilityRestriction, MismatchedClosingDelimiter, NonStringAbiLiteral,\n };\n \n bitflags::bitflags! {\n@@ -552,21 +551,11 @@ impl<'a> Parser<'a> {\n         self.parse_ident_common(true)\n     }\n \n-    fn ident_or_err(&mut self) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n-        self.token.ident().ok_or_else(|| match self.prev_token.kind {\n-            TokenKind::DocComment(..) => DocCommentDoesNotDocumentAnything {\n-                span: self.prev_token.span,\n-                missing_comma: None,\n-            }\n-            .into_diagnostic(&self.sess.span_diagnostic),\n-            _ => self.expected_ident_found(),\n-        })\n-    }\n-\n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, Ident> {\n-        let (ident, is_raw) = self.ident_or_err()?;\n+        let (ident, is_raw) = self.ident_or_err(recover)?;\n+\n         if !is_raw && ident.is_reserved() {\n-            let mut err = self.expected_ident_found();\n+            let mut err = self.expected_ident_found_err();\n             if recover {\n                 err.emit();\n             } else {\n@@ -577,6 +566,21 @@ impl<'a> Parser<'a> {\n         Ok(ident)\n     }\n \n+    fn ident_or_err(&mut self, recover: bool) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n+        let result = self.token.ident().ok_or_else(|| self.expected_ident_found(recover));\n+\n+        let (ident, is_raw) = match result {\n+            Ok(ident) => ident,\n+            Err(err) => match err {\n+                // we recovered!\n+                Ok(ident) => ident,\n+                Err(err) => return Err(err),\n+            },\n+        };\n+\n+        Ok((ident, is_raw))\n+    }\n+\n     /// Checks if the next token is `tok`, and returns `true` if so.\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not"}, {"sha": "2246002f5d32a432ce891c64b438c1370bcdf9f2", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -348,10 +348,6 @@ impl<'a> Parser<'a> {\n             lo = self.token.span;\n         }\n \n-        if self.is_lit_bad_ident() {\n-            return Err(self.expected_ident_found());\n-        }\n-\n         let pat = if self.check(&token::BinOp(token::And)) || self.token.kind == token::AndAnd {\n             self.parse_pat_deref(expected)?\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n@@ -395,7 +391,13 @@ impl<'a> Parser<'a> {\n             } else {\n                 PatKind::Lit(const_expr)\n             }\n-        } else if self.can_be_ident_pat() {\n+        // Don't eagerly error on semantically invalid tokens when matching\n+        // declarative macros, as the input to those doesn't have to be\n+        // semantically valid. For attribute/derive proc macros this is not the\n+        // case, so doing the recovery for them is fine.\n+        } else if self.can_be_ident_pat()\n+            || (self.is_lit_bad_ident().is_some() && self.may_recover())\n+        {\n             // Parse `ident @ pat`\n             // This can give false positives and parse nullary enums,\n             // they are dealt with later in resolve.\n@@ -594,7 +596,7 @@ impl<'a> Parser<'a> {\n         // Make sure we don't allow e.g. `let mut $p;` where `$p:pat`.\n         if let token::Interpolated(nt) = &self.token.kind {\n             if let token::NtPat(_) = **nt {\n-                self.expected_ident_found().emit();\n+                self.expected_ident_found_err().emit();\n             }\n         }\n "}, {"sha": "1c459edabb89e1082fc6b4c6f724380fe7aebf54", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1907,7 +1907,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Fn => {\n                 for attr in attrs {\n-                    if self.tcx.sess.is_proc_macro_attr(attr) {\n+                    if attr.is_proc_macro_attr() {\n                         debug!(\"Is proc macro attr\");\n                         return true;\n                     }"}, {"sha": "f3e683f4b3a0af4545159ee1d7159d9e543e02ed", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_errors::error_code;\n use rustc_hir::def::DefKind;\n@@ -37,7 +38,7 @@ fn entry_fn(tcx: TyCtxt<'_>, (): ()) -> Option<(DefId, EntryFnType)> {\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if tcx.sess.contains_name(&tcx.hir().attrs(CRATE_HIR_ID), sym::no_main) {\n+    if attr::contains_name(&tcx.hir().attrs(CRATE_HIR_ID), sym::no_main) {\n         return None;\n     }\n \n@@ -57,9 +58,9 @@ fn entry_fn(tcx: TyCtxt<'_>, (): ()) -> Option<(DefId, EntryFnType)> {\n // An equivalent optimization was not applied to the duplicated code in test_harness.rs.\n fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> EntryPointType {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    if ctxt.tcx.sess.contains_name(attrs, sym::start) {\n+    if attr::contains_name(attrs, sym::start) {\n         EntryPointType::Start\n-    } else if ctxt.tcx.sess.contains_name(attrs, sym::rustc_main) {\n+    } else if attr::contains_name(attrs, sym::rustc_main) {\n         EntryPointType::RustcMainAttr\n     } else {\n         if let Some(name) = ctxt.tcx.opt_item_name(id.owner_id.to_def_id())\n@@ -78,7 +79,7 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n \n fn attr_span_by_symbol(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol) -> Option<Span> {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    ctxt.tcx.sess.find_by_name(attrs, sym).map(|attr| attr.span)\n+    attr::find_by_name(attrs, sym).map(|attr| attr.span)\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {"}, {"sha": "f79807fee3957f17ef296711f77ce28845006a70", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -570,7 +570,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n-                    is_prelude: self.r.tcx.sess.contains_name(&item.attrs, sym::prelude_import),\n+                    is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n                     id,\n                 };\n@@ -685,7 +685,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     expansion.to_expn_id(),\n                     item.span,\n                     parent.no_implicit_prelude\n-                        || self.r.tcx.sess.contains_name(&item.attrs, sym::no_implicit_prelude),\n+                        || attr::contains_name(&item.attrs, sym::no_implicit_prelude),\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n@@ -750,7 +750,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n                     let mut ctor_vis = if vis.is_public()\n-                        && self.r.tcx.sess.contains_name(&item.attrs, sym::non_exhaustive)\n+                        && attr::contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n                         ty::Visibility::Restricted(CRATE_DEF_ID)\n                     } else {\n@@ -1168,12 +1168,11 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-        if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro) {\n+        if attr::contains_name(&item.attrs, sym::proc_macro) {\n             return Some((MacroKind::Bang, item.ident, item.span));\n-        } else if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n             return Some((MacroKind::Attr, item.ident, item.span));\n-        } else if let Some(attr) = self.r.tcx.sess.find_by_name(&item.attrs, sym::proc_macro_derive)\n-        {\n+        } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n             if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                 if let Some(ident) = nested_meta.ident() {\n                     return Some((MacroKind::Derive, ident, ident.span));\n@@ -1228,7 +1227,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         if macro_rules {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = self.r.tcx.sess.contains_name(&item.attrs, sym::macro_export);\n+            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1488,13 +1487,12 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         self.r.visibilities.insert(def_id, vis);\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n-        let ctor_vis = if vis.is_public()\n-            && self.r.tcx.sess.contains_name(&variant.attrs, sym::non_exhaustive)\n-        {\n-            ty::Visibility::Restricted(CRATE_DEF_ID)\n-        } else {\n-            vis\n-        };\n+        let ctor_vis =\n+            if vis.is_public() && attr::contains_name(&variant.attrs, sym::non_exhaustive) {\n+                ty::Visibility::Restricted(CRATE_DEF_ID)\n+            } else {\n+                vis\n+            };\n \n         // Define a constructor name in the value namespace.\n         if let Some((ctor_kind, ctor_node_id)) = CtorKind::from_ast(&variant.data) {"}, {"sha": "a0b9188c3159e6543c03b7c4ce915eaaa668fe52", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -23,7 +23,7 @@ extern crate tracing;\n \n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n+use rustc_ast::{self as ast, attr, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n@@ -1190,7 +1190,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty),\n             ExpnId::root(),\n             krate.spans.inner_span,\n-            tcx.sess.contains_name(&krate.attrs, sym::no_implicit_prelude),\n+            attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n             &mut module_map,\n         );\n         let empty_module = arenas.new_module(\n@@ -1222,9 +1222,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             .map(|(name, _)| (Ident::from_str(name), Default::default()))\n             .collect();\n \n-        if !tcx.sess.contains_name(&krate.attrs, sym::no_core) {\n+        if !attr::contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n-            if !tcx.sess.contains_name(&krate.attrs, sym::no_std) {\n+            if !attr::contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n             }\n         }"}, {"sha": "c540682d8db385b1097d64c2b6dae1ff27e61a93", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -5,7 +5,7 @@ use crate::Namespace::*;\n use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n-use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n+use rustc_ast::{self as ast, attr, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::intern::Interned;\n@@ -113,7 +113,7 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n pub(crate) fn registered_tools(tcx: TyCtxt<'_>, (): ()) -> RegisteredTools {\n     let mut registered_tools = RegisteredTools::default();\n     let krate = tcx.crate_for_resolver(()).borrow();\n-    for attr in tcx.sess.filter_by_name(&krate.attrs, sym::register_tool) {\n+    for attr in attr::filter_by_name(&krate.attrs, sym::register_tool) {\n         for nested_meta in attr.meta_item_list().unwrap_or_default() {\n             match nested_meta.ident() {\n                 Some(ident) => {"}, {"sha": "fdb9fae44e153b4fce833ae0efda61c276b84df6", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -5,7 +5,7 @@ use crate::errors::{\n     InvalidCharacterInCrateName,\n };\n use crate::Session;\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n use std::path::{Path, PathBuf};\n@@ -56,7 +56,7 @@ pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute]) -> Symbol {\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n     let attr_crate_name =\n-        sess.find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n+        attr::find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(ref s) = sess.opts.crate_name {\n         let s = Symbol::intern(s);"}, {"sha": "700a059c368ba8164f63b4417ec716c2d9aded79", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -30,7 +30,7 @@ use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, RealFileLoader, SourceMap, Span};\n-use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n+use rustc_span::{SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n use rustc_target::spec::{\n@@ -1003,40 +1003,6 @@ impl Session {\n         || self.opts.unstable_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS | SanitizerSet::MEMORY | SanitizerSet::HWADDRESS)\n     }\n \n-    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n-        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n-            .iter()\n-            .any(|kind| attr.has_name(*kind))\n-    }\n-\n-    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n-        attrs.iter().any(|item| item.has_name(name))\n-    }\n-\n-    pub fn find_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> Option<&'a Attribute> {\n-        attrs.iter().find(|attr| attr.has_name(name))\n-    }\n-\n-    pub fn filter_by_name<'a>(\n-        &'a self,\n-        attrs: &'a [Attribute],\n-        name: Symbol,\n-    ) -> impl Iterator<Item = &'a Attribute> {\n-        attrs.iter().filter(move |attr| attr.has_name(name))\n-    }\n-\n-    pub fn first_attr_value_str_by_name(\n-        &self,\n-        attrs: &[Attribute],\n-        name: Symbol,\n-    ) -> Option<Symbol> {\n-        attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n-    }\n-\n     pub fn diagnostic_width(&self) -> usize {\n         let default_column_width = 140;\n         if let Some(width) = self.opts.diagnostic_width {"}, {"sha": "98d6e0ab117a3968a4eb80d2b93adc4d95b017ed", "filename": "compiler/rustc_span/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_span%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_span%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2FCargo.toml?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -18,3 +18,4 @@ tracing = \"0.1\"\n sha1 = \"0.10.0\"\n sha2 = \"0.10.1\"\n md5 = { package = \"md-5\", version = \"0.10.0\" }\n+indexmap = { version = \"1.9.1\" }"}, {"sha": "b2c58caff2ec440ded5130858e41866b906e9d26", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,13 +1,17 @@\n use crate::{HashStableContext, Symbol};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n+use rustc_data_structures::unhash::Unhasher;\n use rustc_data_structures::AtomicRef;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::borrow::Borrow;\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n+use std::hash::{BuildHasherDefault, Hash, Hasher};\n+\n+pub type StableCrateIdMap =\n+    indexmap::IndexMap<StableCrateId, CrateNum, BuildHasherDefault<Unhasher>>;\n \n rustc_index::newtype_index! {\n     #[custom_encodable]"}, {"sha": "02cffc762bed32597274febc1332400af944eebd", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -795,6 +795,18 @@ impl Span {\n         })\n     }\n \n+    /// Splits a span into two composite spans around a certain position.\n+    pub fn split_at(self, pos: u32) -> (Span, Span) {\n+        let len = self.hi().0 - self.lo().0;\n+        debug_assert!(pos <= len);\n+\n+        let split_pos = BytePos(self.lo().0 + pos);\n+        (\n+            Span::new(self.lo(), split_pos, self.ctxt(), self.parent()),\n+            Span::new(split_pos, self.hi(), self.ctxt(), self.parent()),\n+        )\n+    }\n+\n     /// Returns a `Span` that would enclose both `self` and `end`.\n     ///\n     /// Note that this can also be used to extend the span \"backwards\":"}, {"sha": "8cb09108e83ca5e3bb4a53cf3cb882a0b82e2048", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -2,7 +2,8 @@\n \n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::EvalCtxt;\n+use super::{EvalCtxt, SolverMode};\n+use crate::traits::coherence;\n use itertools::Itertools;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n@@ -87,6 +88,8 @@ pub(super) enum CandidateSource {\n pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n     fn self_ty(self) -> Ty<'tcx>;\n \n+    fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx>;\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n@@ -244,15 +247,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         self.assemble_object_bound_candidates(goal, &mut candidates);\n \n+        self.assemble_coherence_unknowable_candidates(goal, &mut candidates);\n+\n         candidates\n     }\n \n     /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n     ///\n     /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n-    /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n-    /// this case as projections as self types add\n-    // FIXME complete the unfinished sentence above\n+    /// self type to the list of candidates in case that succeeds. We also have to consider candidates with the\n+    /// projection as a self type as well\n     fn assemble_candidates_after_normalizing_self_ty<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -468,25 +472,49 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    fn assemble_coherence_unknowable_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        match self.solver_mode() {\n+            SolverMode::Normal => return,\n+            SolverMode::Coherence => {\n+                let trait_ref = goal.predicate.trait_ref(self.tcx());\n+                match coherence::trait_ref_is_knowable(self.tcx(), trait_ref) {\n+                    Ok(()) => {}\n+                    Err(_) => match self\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    {\n+                        Ok(result) => candidates\n+                            .push(Candidate { source: CandidateSource::BuiltinImpl, result }),\n+                        // FIXME: This will be reachable at some point if we're in\n+                        // `assemble_candidates_after_normalizing_self_ty` and we get a\n+                        // universe error. We'll deal with it at this point.\n+                        Err(NoSolution) => bug!(\"coherence candidate resulted in NoSolution\"),\n+                    },\n+                }\n+            }\n+        }\n+    }\n+\n     #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn merge_candidates_and_discard_reservation_impls(\n+    pub(super) fn merge_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         match candidates.len() {\n             0 => return Err(NoSolution),\n-            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            1 => return Ok(candidates.pop().unwrap().result),\n             _ => {}\n         }\n \n         if candidates.len() > 1 {\n             let mut i = 0;\n             'outer: while i < candidates.len() {\n                 for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.trait_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n+                    if self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n+                    {\n                         debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n                         candidates.swap_remove(i);\n                         continue 'outer;\n@@ -511,11 +539,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n         }\n \n-        // FIXME: What if there are >1 candidates left with the same response, and one is a reservation impl?\n-        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+        Ok(candidates.pop().unwrap().result)\n     }\n \n-    fn trait_candidate_should_be_dropped_in_favor_of(\n+    fn candidate_should_be_dropped_in_favor_of(\n         &self,\n         candidate: &Candidate<'tcx>,\n         other: &Candidate<'tcx>,\n@@ -528,20 +555,4 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | (CandidateSource::BuiltinImpl, _) => false,\n         }\n     }\n-\n-    fn discard_reservation_impl(&mut self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n-        if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n-                debug!(\"Selected reservation impl\");\n-                // We assemble all candidates inside of a probe so by\n-                // making a new canonical response here our result will\n-                // have no constraints.\n-                candidate.result = self\n-                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n-                    .unwrap();\n-            }\n-        }\n-\n-        candidate\n-    }\n }"}, {"sha": "c492c8c0aea0510328b5ba70d009cdf6aad96fbf", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -17,6 +17,7 @@ use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n use super::search_graph::{self, OverflowHandler};\n+use super::SolverMode;\n use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n@@ -78,7 +79,9 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n+        let mode = if self.intercrate { SolverMode::Coherence } else { SolverMode::Normal };\n+\n+        let mut search_graph = search_graph::SearchGraph::new(self.tcx, mode);\n \n         let mut ecx = EvalCtxt {\n             search_graph: &mut search_graph,\n@@ -101,6 +104,10 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    pub(super) fn solver_mode(&self) -> SolverMode {\n+        self.search_graph.solver_mode()\n+    }\n+\n     /// The entry point of the solver.\n     ///\n     /// This function deals with (coinductive) cycles, overflow, and caching\n@@ -120,8 +127,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         //\n         // The actual solver logic happens in `ecx.compute_goal`.\n         search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n-            let (ref infcx, goal, var_values) =\n-                tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let intercrate = match search_graph.solver_mode() {\n+                SolverMode::Normal => false,\n+                SolverMode::Coherence => true,\n+            };\n+            let (ref infcx, goal, var_values) = tcx\n+                .infer_ctxt()\n+                .intercrate(intercrate)\n+                .build_with_canonical(DUMMY_SP, &canonical_goal);\n             let mut ecx = EvalCtxt {\n                 infcx,\n                 var_values,"}, {"sha": "89f4056a58db42436eb204d98f1584e1a50f31dd", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -9,10 +9,6 @@\n //! FIXME(@lcnr): Write that section. If you read this before then ask me\n //! about it on zulip.\n \n-// FIXME: Instead of using `infcx.canonicalize_query` we have to add a new routine which\n-// preserves universes and creates a unique var (in the highest universe) for each\n-// appearance of a region.\n-\n // FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n \n use rustc_hir::def_id::DefId;\n@@ -41,6 +37,19 @@ mod trait_goals;\n pub use eval_ctxt::{EvalCtxt, InferCtxtEvalExt};\n pub use fulfill::FulfillmentCtxt;\n \n+#[derive(Debug, Clone, Copy)]\n+enum SolverMode {\n+    /// Ordinary trait solving, using everywhere except for coherence.\n+    Normal,\n+    /// Trait solving during coherence. There are a few notable differences\n+    /// between coherence and ordinary trait solving.\n+    ///\n+    /// Most importantly, trait solving during coherence must not be incomplete,\n+    /// i.e. return `Err(NoSolution)` for goals for which a solution exists.\n+    /// This means that we must not make any guesses or arbitrary choices.\n+    Coherence,\n+}\n+\n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n }\n@@ -255,7 +264,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             return Err(NoSolution);\n         }\n \n-        // FIXME(-Ztreat-solver=next): We should instead try to find a `Certainty::Yes` response with\n+        // FIXME(-Ztrait-solver=next): We should instead try to find a `Certainty::Yes` response with\n         // a subset of the constraints that all the other responses have.\n         let one = candidates[0];\n         if candidates[1..].iter().all(|resp| resp == &one) {"}, {"sha": "998859966528b2e1b8a19cc31ff39855271f62e8", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // projection cache in the solver.\n         if self.term_is_fully_unconstrained(goal) {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_candidates_and_discard_reservation_impls(candidates)\n+            self.merge_candidates(candidates)\n         } else {\n             let predicate = goal.predicate;\n             let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n@@ -56,6 +56,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.self_ty()\n     }\n \n+    fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+        self.projection_ty.trait_ref(tcx)\n+    }\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n         self.with_self_ty(tcx, self_ty)\n     }"}, {"sha": "219890b9dc42c1726110306d19a2800d87fedae5", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,8 +1,9 @@\n mod cache;\n mod overflow;\n \n+pub(super) use overflow::OverflowHandler;\n+\n use self::cache::ProvisionalEntry;\n-pub(super) use crate::solve::search_graph::overflow::OverflowHandler;\n use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n@@ -11,6 +12,8 @@ use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryRes\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n+use super::SolverMode;\n+\n rustc_index::newtype_index! {\n     pub struct StackDepth {}\n }\n@@ -21,6 +24,7 @@ struct StackElem<'tcx> {\n }\n \n pub(super) struct SearchGraph<'tcx> {\n+    mode: SolverMode,\n     /// The stack of goals currently being computed.\n     ///\n     /// An element is *deeper* in the stack if its index is *lower*.\n@@ -30,14 +34,19 @@ pub(super) struct SearchGraph<'tcx> {\n }\n \n impl<'tcx> SearchGraph<'tcx> {\n-    pub(super) fn new(tcx: TyCtxt<'tcx>) -> SearchGraph<'tcx> {\n+    pub(super) fn new(tcx: TyCtxt<'tcx>, mode: SolverMode) -> SearchGraph<'tcx> {\n         Self {\n+            mode,\n             stack: Default::default(),\n             overflow_data: OverflowData::new(tcx),\n             provisional_cache: ProvisionalCache::empty(),\n         }\n     }\n \n+    pub(super) fn solver_mode(&self) -> SolverMode {\n+        self.mode\n+    }\n+\n     pub(super) fn is_empty(&self) -> bool {\n         self.stack.is_empty() && self.provisional_cache.is_empty()\n     }\n@@ -245,7 +254,8 @@ impl<'tcx> SearchGraph<'tcx> {\n             // dependencies, our non-root goal may no longer appear as child of the root goal.\n             //\n             // See https://github.com/rust-lang/rust/pull/108071 for some additional context.\n-            let should_cache_globally = !self.overflow_data.did_overflow() || self.stack.is_empty();\n+            let should_cache_globally = matches!(self.solver_mode(), SolverMode::Normal)\n+                && (!self.overflow_data.did_overflow() || self.stack.is_empty());\n             if should_cache_globally {\n                 tcx.new_solver_evaluation_cache.insert(\n                     current_goal.goal,"}, {"sha": "2ebdfc8fe72a168e6747cd86a86b55e189100bbc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use super::{assembly, EvalCtxt};\n+use super::{assembly, EvalCtxt, SolverMode};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n@@ -20,6 +20,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         self.self_ty()\n     }\n \n+    fn trait_ref(self, _: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+        self.trait_ref\n+    }\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n         self.with_self_ty(tcx, self_ty)\n     }\n@@ -43,6 +47,22 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             return Err(NoSolution);\n         }\n \n+        let impl_polarity = tcx.impl_polarity(impl_def_id);\n+        // An upper bound of the certainty of this goal, used to lower the certainty\n+        // of reservation impl to ambiguous during coherence.\n+        let maximal_certainty = match impl_polarity {\n+            ty::ImplPolarity::Positive | ty::ImplPolarity::Negative => {\n+                match impl_polarity == goal.predicate.polarity {\n+                    true => Certainty::Yes,\n+                    false => return Err(NoSolution),\n+                }\n+            }\n+            ty::ImplPolarity::Reservation => match ecx.solver_mode() {\n+                SolverMode::Normal => return Err(NoSolution),\n+                SolverMode::Coherence => Certainty::AMBIGUOUS,\n+            },\n+        };\n+\n         ecx.probe(|ecx| {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n@@ -55,7 +75,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n             ecx.add_goals(where_clause_bounds);\n-            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+\n+            ecx.evaluate_added_goals_and_make_canonical_response(maximal_certainty)\n         })\n     }\n \n@@ -547,6 +568,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let candidates = self.assemble_and_evaluate_candidates(goal);\n-        self.merge_candidates_and_discard_reservation_impls(candidates)\n+        self.merge_candidates(candidates)\n     }\n }"}, {"sha": "98e00e8223bbce9f43abcc124337588dfe072865", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -95,8 +95,11 @@ pub fn overlapping_impls(\n         return None;\n     }\n \n-    let infcx =\n-        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .intercrate(true)\n+        .build();\n     let selcx = &mut SelectionContext::new(&infcx);\n     let overlaps =\n         overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n@@ -107,8 +110,11 @@ pub fn overlapping_impls(\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    let infcx =\n-        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .intercrate(true)\n+        .build();\n     let selcx = &mut SelectionContext::new(&infcx);\n     selcx.enable_tracking_intercrate_ambiguity_causes();\n     Some(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())"}, {"sha": "e89706067046a9073406a8985b5ce2870a533010", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -4,7 +4,7 @@\n \n pub mod auto_trait;\n mod chalk_fulfill;\n-mod coherence;\n+pub(crate) mod coherence;\n pub mod const_evaluatable;\n mod engine;\n pub mod error_reporting;"}, {"sha": "ee5a7909ba3dc66c3d88c5b9238e850ccd67834a", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -539,7 +539,7 @@ fn make_thin_self_ptr<'tcx>(\n         // get a built-in pointer type\n         let mut fat_pointer_layout = layout;\n         'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n-            && !fat_pointer_layout.ty.is_region_ptr()\n+            && !fat_pointer_layout.ty.is_ref()\n         {\n             for i in 0..fat_pointer_layout.fields.count() {\n                 let field_layout = fat_pointer_layout.field(cx, i);"}, {"sha": "a6b9acb576eb454dbf66fbd3693b451208b524a9", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -209,6 +209,7 @@\n #![feature(derive_const)]\n #![feature(doc_cfg)]\n #![feature(doc_notable_trait)]\n+#![feature(generic_arg_infer)]\n #![feature(rustdoc_internals)]\n #![feature(exhaustive_patterns)]\n #![feature(doc_cfg_hide)]"}, {"sha": "b655243782c18d3419439daa523782e0818ecf26", "filename": "library/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstdarch?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1 +1 @@\n-Subproject commit a0c30f3e3c75adcd6ee7efc94014ebcead61c507\n+Subproject commit b655243782c18d3419439daa523782e0818ecf26"}, {"sha": "7dbb3f76a0a8366826f9e39d099b69a4649d9b62", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1471,27 +1471,68 @@ impl Type {\n         result\n     }\n \n-    /// Check if two types are \"potentially the same\".\n+    pub(crate) fn is_borrowed_ref(&self) -> bool {\n+        matches!(self, Type::BorrowedRef { .. })\n+    }\n+\n+    /// Check if two types are \"the same\" for documentation purposes.\n+    ///\n     /// This is different from `Eq`, because it knows that things like\n     /// `Placeholder` are possible matches for everything.\n-    pub(crate) fn is_same(&self, other: &Self, cache: &Cache) -> bool {\n-        match (self, other) {\n+    ///\n+    /// This relation is not commutative when generics are involved:\n+    ///\n+    /// ```ignore(private)\n+    /// # // see types/tests.rs:is_same_generic for the real test\n+    /// use rustdoc::format::cache::Cache;\n+    /// use rustdoc::clean::types::{Type, PrimitiveType};\n+    /// let cache = Cache::new(false);\n+    /// let generic = Type::Generic(rustc_span::symbol::sym::Any);\n+    /// let unit = Type::Primitive(PrimitiveType::Unit);\n+    /// assert!(!generic.is_same(&unit, &cache));\n+    /// assert!(unit.is_same(&generic, &cache));\n+    /// ```\n+    ///\n+    /// An owned type is also the same as its borrowed variants (this is commutative),\n+    /// but `&T` is not the same as `&mut T`.\n+    pub(crate) fn is_doc_subtype_of(&self, other: &Self, cache: &Cache) -> bool {\n+        // Strip the references so that it can compare the actual types, unless both are references.\n+        // If both are references, leave them alone and compare the mutabilities later.\n+        let (self_cleared, other_cleared) = if !self.is_borrowed_ref() || !other.is_borrowed_ref() {\n+            (self.without_borrowed_ref(), other.without_borrowed_ref())\n+        } else {\n+            (self, other)\n+        };\n+        match (self_cleared, other_cleared) {\n             // Recursive cases.\n             (Type::Tuple(a), Type::Tuple(b)) => {\n-                a.len() == b.len() && a.iter().zip(b).all(|(a, b)| a.is_same(b, cache))\n+                a.len() == b.len() && a.iter().zip(b).all(|(a, b)| a.is_doc_subtype_of(b, cache))\n             }\n-            (Type::Slice(a), Type::Slice(b)) => a.is_same(b, cache),\n-            (Type::Array(a, al), Type::Array(b, bl)) => al == bl && a.is_same(b, cache),\n+            (Type::Slice(a), Type::Slice(b)) => a.is_doc_subtype_of(b, cache),\n+            (Type::Array(a, al), Type::Array(b, bl)) => al == bl && a.is_doc_subtype_of(b, cache),\n             (Type::RawPointer(mutability, type_), Type::RawPointer(b_mutability, b_type_)) => {\n-                mutability == b_mutability && type_.is_same(b_type_, cache)\n+                mutability == b_mutability && type_.is_doc_subtype_of(b_type_, cache)\n             }\n             (\n                 Type::BorrowedRef { mutability, type_, .. },\n                 Type::BorrowedRef { mutability: b_mutability, type_: b_type_, .. },\n-            ) => mutability == b_mutability && type_.is_same(b_type_, cache),\n-            // Placeholders and generics are equal to all other types.\n+            ) => mutability == b_mutability && type_.is_doc_subtype_of(b_type_, cache),\n+            // Placeholders are equal to all other types.\n             (Type::Infer, _) | (_, Type::Infer) => true,\n-            (Type::Generic(_), _) | (_, Type::Generic(_)) => true,\n+            // Generics match everything on the right, but not on the left.\n+            // If both sides are generic, this returns true.\n+            (_, Type::Generic(_)) => true,\n+            (Type::Generic(_), _) => false,\n+            // Paths account for both the path itself and its generics.\n+            (Type::Path { path: a }, Type::Path { path: b }) => {\n+                a.def_id() == b.def_id()\n+                    && a.generics()\n+                        .zip(b.generics())\n+                        .map(|(ag, bg)| {\n+                            ag.iter().zip(bg.iter()).all(|(at, bt)| at.is_doc_subtype_of(bt, cache))\n+                        })\n+                        .unwrap_or(true)\n+            }\n             // Other cases, such as primitives, just use recursion.\n             (a, b) => a\n                 .def_id(cache)"}, {"sha": "d8c91a9680479fd81c18e4525b2ae2f9ef2ed91a", "filename": "src/librustdoc/clean/types/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -69,3 +69,14 @@ fn should_not_trim() {\n     run_test(\"\\t    line1  \\n\\t    line2\", \"line1  \\nline2\");\n     run_test(\"    \\tline1  \\n    \\tline2\", \"line1  \\nline2\");\n }\n+\n+#[test]\n+fn is_same_generic() {\n+    use crate::clean::types::{PrimitiveType, Type};\n+    use crate::formats::cache::Cache;\n+    let cache = Cache::new(false);\n+    let generic = Type::Generic(rustc_span::symbol::sym::Any);\n+    let unit = Type::Primitive(PrimitiveType::Unit);\n+    assert!(!generic.is_doc_subtype_of(&unit, &cache));\n+    assert!(unit.is_doc_subtype_of(&generic, &cache));\n+}"}, {"sha": "d75d03071f892b3089e344e1fe261382a1efe0a5", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1294,7 +1294,7 @@ pub(crate) fn notable_traits_button(ty: &clean::Type, cx: &mut Context<'_>) -> O\n     if let Some(impls) = cx.cache().impls.get(&did) {\n         for i in impls {\n             let impl_ = i.inner_impl();\n-            if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache()) {\n+            if !ty.is_doc_subtype_of(&impl_.for_, cx.cache()) {\n                 // Two different types might have the same did,\n                 // without actually being the same.\n                 continue;\n@@ -1330,7 +1330,7 @@ fn notable_traits_decl(ty: &clean::Type, cx: &Context<'_>) -> (String, String) {\n \n     for i in impls {\n         let impl_ = i.inner_impl();\n-        if !impl_.for_.without_borrowed_ref().is_same(ty.without_borrowed_ref(), cx.cache()) {\n+        if !ty.is_doc_subtype_of(&impl_.for_, cx.cache()) {\n             // Two different types might have the same did,\n             // without actually being the same.\n             continue;"}, {"sha": "67877780c0e901652d4f8c7acef783019013f99d", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -28,7 +28,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n+        } else if is_public && !is_proc_macro(attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n             check_must_use_candidate(\n                 cx,\n                 sig.decl,\n@@ -51,7 +51,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n         } else if is_public\n-            && !is_proc_macro(cx.sess(), attrs)\n+            && !is_proc_macro(attrs)\n             && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n         {\n             check_must_use_candidate(\n@@ -78,7 +78,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n             check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n             let body = cx.tcx.hir().body(eid);\n-            if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n+            if attr.is_none() && is_public && !is_proc_macro(attrs) {\n                 check_must_use_candidate(\n                     cx,\n                     sig.decl,"}, {"sha": "bc3d774540a51ca494a60f1dfdf3c94f3f35d97c", "filename": "src/tools/clippy/clippy_utils/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fattrs.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -145,8 +145,8 @@ pub fn get_unique_attr<'a>(\n \n /// Return true if the attributes contain any of `proc_macro`,\n /// `proc_macro_derive` or `proc_macro_attribute`, false otherwise\n-pub fn is_proc_macro(sess: &Session, attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(|attr| sess.is_proc_macro_attr(attr))\n+pub fn is_proc_macro(attrs: &[ast::Attribute]) -> bool {\n+    attrs.iter().any(|attr| attr.is_proc_macro_attr())\n }\n \n /// Return true if the attributes contain `#[doc(hidden)]`"}, {"sha": "22e45082a9f71b1d86e5e1f8d65feb493cb89ce2", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_ast::ast;\n use rustc_ast::HasAttrs;\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_span::{symbol::sym, Span};\n \n use self::doc_comment::DocCommentFormatter;\n use crate::comment::{contains_comment, rewrite_doc_comment, CommentStyle};\n@@ -19,20 +19,6 @@ use crate::utils::{count_newlines, mk_sp};\n \n mod doc_comment;\n \n-pub(crate) fn contains_name(attrs: &[ast::Attribute], name: Symbol) -> bool {\n-    attrs.iter().any(|attr| attr.has_name(name))\n-}\n-\n-pub(crate) fn first_attr_value_str_by_name(\n-    attrs: &[ast::Attribute],\n-    name: Symbol,\n-) -> Option<Symbol> {\n-    attrs\n-        .iter()\n-        .find(|attr| attr.has_name(name))\n-        .and_then(|attr| attr.value_str())\n-}\n-\n /// Returns attributes on the given statement.\n pub(crate) fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n     stmt.attrs()"}, {"sha": "6bc53159b38ba50e97895aedd2c1c5b72f7c3b86", "filename": "src/tools/rustfmt/src/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -2,13 +2,12 @@ use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::path::{Path, PathBuf};\n \n use rustc_ast::token::TokenKind;\n-use rustc_ast::{ast, ptr};\n+use rustc_ast::{ast, attr, ptr};\n use rustc_errors::Diagnostic;\n use rustc_parse::{new_parser_from_file, parser::Parser as RawParser};\n use rustc_span::{sym, Span};\n use thin_vec::ThinVec;\n \n-use crate::attr::first_attr_value_str_by_name;\n use crate::parse::session::ParseSess;\n use crate::Input;\n \n@@ -93,7 +92,7 @@ pub(crate) enum ParserError {\n \n impl<'a> Parser<'a> {\n     pub(crate) fn submod_path_from_attr(attrs: &[ast::Attribute], path: &Path) -> Option<PathBuf> {\n-        let path_sym = first_attr_value_str_by_name(attrs, sym::path)?;\n+        let path_sym = attr::first_attr_value_str_by_name(attrs, sym::path)?;\n         let path_str = path_sym.as_str();\n \n         // On windows, the base path might have the form"}, {"sha": "3bddf4c1b6a41d82f827d1e3733e12341eb7ba74", "filename": "src/tools/rustfmt/src/reorder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -8,7 +8,7 @@\n \n use std::cmp::{Ord, Ordering};\n \n-use rustc_ast::ast;\n+use rustc_ast::{ast, attr};\n use rustc_span::{symbol::sym, Span};\n \n use crate::config::{Config, GroupImportsTactic};\n@@ -167,7 +167,7 @@ fn rewrite_reorderable_or_regroupable_items(\n }\n \n fn contains_macro_use_attr(item: &ast::Item) -> bool {\n-    crate::attr::contains_name(&item.attrs, sym::macro_use)\n+    attr::contains_name(&item.attrs, sym::macro_use)\n }\n \n /// Divides imports into three groups, corresponding to standard, external"}, {"sha": "fc180ccfe28e2448844e50f6aa32fc9cc22c2235", "filename": "tests/run-make-fulldeps/issue-83045/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frun-make-fulldeps%2Fissue-83045%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frun-make-fulldeps%2Fissue-83045%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fissue-83045%2FMakefile?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -29,5 +29,5 @@ all:\n \t\t\t\t  --crate-type=rlib \\\n \t\t\t\t  --edition=2018 \\\n \t\t\t\t  c.rs 2>&1 | tee $(TMPDIR)/output.txt || exit 0\n-\t$(CGREP) E0463 < $(TMPDIR)/output.txt\n+\t$(CGREP) E0519 < $(TMPDIR)/output.txt\n \t$(CGREP) -v \"internal compiler error\" < $(TMPDIR)/output.txt"}, {"sha": "bfce46cf4444af0442dc41e8bb8d3b428462bfc9", "filename": "tests/rustdoc/notable-trait/doc-notable_trait-mut_t_is_not_an_iterator.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_an_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_an_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_an_iterator.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/doc-notable_trait-mut_t_is_not_an_iterator.rs"}, {"sha": "b359dcea0ff471bd768f366a6a13a3b45a9d7110", "filename": "tests/rustdoc/notable-trait/doc-notable_trait-mut_t_is_not_ref_t.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_ref_t.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_ref_t.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-mut_t_is_not_ref_t.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/doc-notable_trait-mut_t_is_not_ref_t.rs"}, {"sha": "46be00a080482818f4af2c588dbdf6612953ea4a", "filename": "tests/rustdoc/notable-trait/doc-notable_trait-slice.bare_fn_matches.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.bare_fn_matches.html", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.bare_fn_matches.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.bare_fn_matches.html?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/doc-notable_trait-slice.bare_fn_matches.html"}, {"sha": "ef206710b4b0829b9a757b1dbd36695fb3d8703f", "filename": "tests/rustdoc/notable-trait/doc-notable_trait-slice.rs", "status": "renamed", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait-slice.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -18,3 +18,9 @@ pub fn bare_fn_matches() -> &'static [SomeStruct] {\n pub fn bare_fn_no_matches() -> &'static [OtherStruct] {\n     &[]\n }\n+\n+// @has doc_notable_trait_slice/fn.bare_fn_mut_no_matches.html\n+// @count - '//script[@id=\"notable-traits-data\"]' 0\n+pub fn bare_fn_mut_no_matches() -> &'static mut [SomeStruct] {\n+    &mut []\n+}", "previous_filename": "tests/rustdoc/doc-notable_trait-slice.rs"}, {"sha": "f592e3b375c026061ec0fb7274a8eef453f201b5", "filename": "tests/rustdoc/notable-trait/doc-notable_trait.bare-fn.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.bare-fn.html", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.bare-fn.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.bare-fn.html?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/doc-notable_trait.bare-fn.html"}, {"sha": "d8941769fa67ab2aad23682979a892fd6b803d63", "filename": "tests/rustdoc/notable-trait/doc-notable_trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/doc-notable_trait.rs"}, {"sha": "e8f4f6000457dcaee93238ded6d67463ecf74304", "filename": "tests/rustdoc/notable-trait/doc-notable_trait.some-struct-new.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.some-struct-new.html", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.some-struct-new.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.some-struct-new.html?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/doc-notable_trait.some-struct-new.html"}, {"sha": "e7909669b150a2720e172d0079f428f88ff9199f", "filename": "tests/rustdoc/notable-trait/doc-notable_trait.wrap-me.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.wrap-me.html", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.wrap-me.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait.wrap-me.html?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/doc-notable_trait.wrap-me.html"}, {"sha": "3fb00c7db84115b3661fd87b6ac4a3e5f9305f7b", "filename": "tests/rustdoc/notable-trait/doc-notable_trait_box_is_not_an_iterator.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait_box_is_not_an_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait_box_is_not_an_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fdoc-notable_trait_box_is_not_an_iterator.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/doc-notable_trait_box_is_not_an_iterator.rs"}, {"sha": "611902abad65b99fd7cf44a0dce276d86c35a8d7", "filename": "tests/rustdoc/notable-trait/notable-trait-generics.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fnotable-trait-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fnotable-trait-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fnotable-trait-generics.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,35 @@\n+#![feature(doc_notable_trait)]\n+\n+// Notable traits SHOULD NOT be shown when the `impl` has a concrete type and\n+// the return type has a generic type.\n+pub mod generic_return {\n+    pub struct Wrapper<T>(T);\n+\n+    #[doc(notable_trait)]\n+    pub trait NotableTrait {}\n+\n+    impl NotableTrait for Wrapper<u8> {}\n+\n+    // @has notable_trait_generics/generic_return/fn.returning.html\n+    // @!has - '//a[@class=\"tooltip\"]/@data-notable-ty' 'Wrapper<T>'\n+    pub fn returning<T>() -> Wrapper<T> {\n+        loop {}\n+    }\n+}\n+\n+// Notable traits SHOULD be shown when the `impl` has a generic type and the\n+// return type has a concrete type.\n+pub mod generic_impl {\n+    pub struct Wrapper<T>(T);\n+\n+    #[doc(notable_trait)]\n+    pub trait NotableTrait {}\n+\n+    impl<T> NotableTrait for Wrapper<T> {}\n+\n+    // @has notable_trait_generics/generic_impl/fn.returning.html\n+    // @has - '//a[@class=\"tooltip\"]/@data-notable-ty' 'Wrapper<u8>'\n+    pub fn returning() -> Wrapper<u8> {\n+        loop {}\n+    }\n+}"}, {"sha": "5f54b7522ae38774e61e4c8cd7c44dc775ad410b", "filename": "tests/rustdoc/notable-trait/spotlight-from-dependency.odd.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.odd.html", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.odd.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.odd.html?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/spotlight-from-dependency.odd.html"}, {"sha": "426759c7bf8a218aca6c3a699782b037e8deccdb", "filename": "tests/rustdoc/notable-trait/spotlight-from-dependency.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fnotable-trait%2Fspotlight-from-dependency.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "previous_filename": "tests/rustdoc/spotlight-from-dependency.rs"}, {"sha": "a3b570ad8c40c5e572ba483eb4963980dfda68af", "filename": "tests/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cf811810fe8dc92b3ff25e7dd29fb3178c91d409/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf811810fe8dc92b3ff25e7dd29fb3178c91d409/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=cf811810fe8dc92b3ff25e7dd29fb3178c91d409", "patch": "@@ -1,80 +0,0 @@\n-// force-host\n-\n-#![feature(rustc_private)]\n-\n-extern crate rustc_driver;\n-extern crate rustc_hir;\n-extern crate rustc_lint;\n-extern crate rustc_span;\n-#[macro_use]\n-extern crate rustc_session;\n-extern crate rustc_ast;\n-\n-use rustc_ast::attr;\n-use rustc_driver::plugin::Registry;\n-use rustc_lint::{LateContext, LateLintPass, LintContext, LintPass};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::symbol::Symbol;\n-\n-macro_rules! fake_lint_pass {\n-    ($struct:ident, $($attr:expr),*) => {\n-        struct $struct;\n-\n-        impl LintPass for $struct {\n-            fn name(&self) -> &'static str {\n-                stringify!($struct)\n-            }\n-        }\n-\n-        impl LateLintPass<'_> for $struct {\n-            fn check_crate(&mut self, cx: &LateContext) {\n-                let attrs = cx.tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-                let span = cx.tcx.def_span(CRATE_DEF_ID);\n-                $(\n-                    if !cx.sess().contains_name(attrs, $attr) {\n-                        cx.lint(CRATE_NOT_OKAY, |lint| {\n-                             let msg = format!(\"crate is not marked with #![{}]\", $attr);\n-                             lint.build(&msg).set_span(span).emit();\n-                        });\n-                    }\n-                )*\n-            }\n-        }\n-\n-    }\n-}\n-\n-declare_lint!(CRATE_NOT_OKAY, Warn, \"crate not marked with #![crate_okay]\");\n-declare_lint!(CRATE_NOT_RED, Warn, \"crate not marked with #![crate_red]\");\n-declare_lint!(CRATE_NOT_BLUE, Warn, \"crate not marked with #![crate_blue]\");\n-declare_lint!(CRATE_NOT_GREY, Warn, \"crate not marked with #![crate_grey]\");\n-declare_lint!(CRATE_NOT_GREEN, Warn, \"crate not marked with #![crate_green]\");\n-\n-fake_lint_pass! {\n-    PassOkay,\n-    Symbol::intern(\"crate_okay\")\n-}\n-\n-fake_lint_pass! {\n-    PassRedBlue,\n-    Symbol::intern(\"crate_red\"), Symbol::intern(\"crate_blue\")\n-}\n-\n-fake_lint_pass! {\n-    PassGreyGreen,\n-    Symbol::intern(\"crate_grey\"), Symbol::intern(\"crate_green\")\n-}\n-\n-#[no_mangle]\n-fn __rustc_plugin_registrar(reg: &mut Registry) {\n-    reg.lint_store.register_lints(&[\n-        &CRATE_NOT_OKAY,\n-        &CRATE_NOT_RED,\n-        &CRATE_NOT_BLUE,\n-        &CRATE_NOT_GREY,\n-        &CRATE_NOT_GREEN,\n-    ]);\n-    reg.lint_store.register_late_pass(|_| Box::new(PassOkay));\n-    reg.lint_store.register_late_pass(|_| Box::new(PassRedBlue));\n-    reg.lint_store.register_late_pass(|_| Box::new(PassGreyGreen));\n-}"}, {"sha": "6304c07d2c7ce6fe88118d7e3f41f3ae7d5a314e", "filename": "tests/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -4,13 +4,13 @@\n \n extern crate rustc_driver;\n extern crate rustc_hir;\n-#[macro_use]\n extern crate rustc_lint;\n #[macro_use]\n extern crate rustc_session;\n extern crate rustc_ast;\n extern crate rustc_span;\n \n+use rustc_ast::attr;\n use rustc_driver::plugin::Registry;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_span::def_id::CRATE_DEF_ID;\n@@ -28,12 +28,10 @@ impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext) {\n         let attrs = cx.tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n         let span = cx.tcx.def_span(CRATE_DEF_ID);\n-        if !cx.sess().contains_name(attrs, Symbol::intern(\"crate_okay\")) {\n-            cx.lint(\n-                CRATE_NOT_OKAY,\n-                \"crate is not marked with #![crate_okay]\",\n-                |lint| lint.set_span(span)\n-            );\n+        if !attr::contains_name(attrs, Symbol::intern(\"crate_okay\")) {\n+            cx.lint(CRATE_NOT_OKAY, \"crate is not marked with #![crate_okay]\", |lint| {\n+                lint.set_span(span)\n+            });\n         }\n     }\n }"}, {"sha": "6f95273116b78af569216574bb78c975cede43e2", "filename": "tests/ui/associated-inherent-types/issue-109299-1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types, non_lifetime_binders, type_alias_impl_trait)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<T>(T);\n+\n+impl Lexer<i32> {\n+    type Cursor = ();\n+}\n+\n+type X = impl for<T> Fn() -> Lexer<T>::Cursor; //~ ERROR associated type `Cursor` not found for `Lexer<T>` in the current scope\n+\n+fn main() {}"}, {"sha": "dc59b56ee207dc1fec88cca04487dd9af07e481a", "filename": "tests/ui/associated-inherent-types/issue-109299-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,15 @@\n+error[E0220]: associated type `Cursor` not found for `Lexer<T>` in the current scope\n+  --> $DIR/issue-109299-1.rs:10:40\n+   |\n+LL | struct Lexer<T>(T);\n+   | --------------- associated item `Cursor` not found for this struct\n+...\n+LL | type X = impl for<T> Fn() -> Lexer<T>::Cursor;\n+   |                                        ^^^^^^ associated item not found in `Lexer<T>`\n+   |\n+   = note: the associated type was found for\n+           - `Lexer<i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "84e4f9e72527aa21025ab3b061ceb17b1a47afbd", "filename": "tests/ui/associated-inherent-types/issue-109299.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<'d>(&'d ());\n+\n+impl Lexer<'d> { //~ ERROR use of undeclared lifetime name `'d`\n+    type Cursor = ();\n+}\n+\n+fn test(_: Lexer::Cursor) {}\n+\n+fn main() {}"}, {"sha": "63f50732d3c50985b420dfa33b4686e6f88c97d5", "filename": "tests/ui/associated-inherent-types/issue-109299.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,11 @@\n+error[E0261]: use of undeclared lifetime name `'d`\n+  --> $DIR/issue-109299.rs:6:12\n+   |\n+LL | impl Lexer<'d> {\n+   |     -      ^^ undeclared lifetime\n+   |     |\n+   |     help: consider introducing lifetime `'d` here: `<'d>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0261`."}, {"sha": "7575372b940fdfa7cb85b674dc45ca7affe11137", "filename": "tests/ui/parser/ident-recovery.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Fident-recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Fident-recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fident-recovery.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,16 @@\n+fn ,comma() {\n+    //~^ ERROR expected identifier, found `,`\n+    struct Foo {\n+        x: i32,,\n+        //~^ ERROR expected identifier, found `,`\n+        y: u32,\n+    }\n+}\n+\n+fn break() {\n+//~^ ERROR expected identifier, found keyword `break`\n+    let continue = 5;\n+    //~^ ERROR expected identifier, found keyword `continue`\n+}\n+\n+fn main() {}"}, {"sha": "e9a55026d12450ffd7feb846d29db272058710d1", "filename": "tests/ui/parser/ident-recovery.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Fident-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Fident-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fident-recovery.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,42 @@\n+error: expected identifier, found `,`\n+  --> $DIR/ident-recovery.rs:1:4\n+   |\n+LL | fn ,comma() {\n+   |    ^\n+   |    |\n+   |    expected identifier\n+   |    help: remove this comma\n+\n+error: expected identifier, found `,`\n+  --> $DIR/ident-recovery.rs:4:16\n+   |\n+LL |         x: i32,,\n+   |                ^\n+   |                |\n+   |                expected identifier\n+   |                help: remove this comma\n+\n+error: expected identifier, found keyword `break`\n+  --> $DIR/ident-recovery.rs:10:4\n+   |\n+LL | fn break() {\n+   |    ^^^^^ expected identifier, found keyword\n+   |\n+help: escape `break` to use it as an identifier\n+   |\n+LL | fn r#break() {\n+   |    ++\n+\n+error: expected identifier, found keyword `continue`\n+  --> $DIR/ident-recovery.rs:12:9\n+   |\n+LL |     let continue = 5;\n+   |         ^^^^^^^^ expected identifier, found keyword\n+   |\n+help: escape `continue` to use it as an identifier\n+   |\n+LL |     let r#continue = 5;\n+   |         ++\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "b2c6612965608ed45307849ed034d9ce480ac0dc", "filename": "tests/ui/parser/integer-literal-start-ident.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Finteger-literal-start-ident.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Finteger-literal-start-ident.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Finteger-literal-start-ident.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -4,7 +4,11 @@ error: expected identifier, found `1main`\n LL | fn 1main() {}\n    |    ^^^^^ expected identifier\n    |\n-   = help: identifiers cannot start with a number\n+help: identifiers cannot start with a number\n+  --> $DIR/integer-literal-start-ident.rs:1:4\n+   |\n+LL | fn 1main() {}\n+   |    ^\n \n error: aborting due to previous error\n "}, {"sha": "3dc636b6a33bd5db95805b44a321838b934f6f75", "filename": "tests/ui/parser/issues/issue-104088.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,26 +1,19 @@\n-fn test() {\n+fn 1234test() {\n+//~^ ERROR expected identifier, found `1234test`\n     if let 123 = 123 { println!(\"yes\"); }\n-}\n-\n-fn test_2() {\n-    let 1x = 123;\n-    //~^ ERROR expected identifier, found `1x`\n-}\n-\n-fn test_3() {\n-    let 2x: i32 = 123;\n-    //~^ ERROR expected identifier, found `2x`\n-}\n \n-fn test_4() {\n     if let 2e1 = 123 {\n         //~^ ERROR mismatched types\n     }\n-}\n \n-fn test_5() {\n     let 23name = 123;\n     //~^ ERROR expected identifier, found `23name`\n+\n+    let 2x: i32 = 123;\n+    //~^ ERROR expected identifier, found `2x`\n+\n+    let 1x = 123;\n+    //~^ ERROR expected identifier, found `1x`\n }\n \n fn main() {}"}, {"sha": "8b751759d69a667314fef024e0be03a1356b5198", "filename": "tests/ui/parser/issues/issue-104088.stderr", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-104088.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,35 +1,59 @@\n-error: expected identifier, found `1x`\n-  --> $DIR/issue-104088.rs:6:9\n+error: expected identifier, found `1234test`\n+  --> $DIR/issue-104088.rs:1:4\n    |\n-LL |     let 1x = 123;\n-   |         ^^ expected identifier\n+LL | fn 1234test() {\n+   |    ^^^^^^^^ expected identifier\n+   |\n+help: identifiers cannot start with a number\n+  --> $DIR/issue-104088.rs:1:4\n+   |\n+LL | fn 1234test() {\n+   |    ^^^^\n+\n+error: expected identifier, found `23name`\n+  --> $DIR/issue-104088.rs:9:9\n+   |\n+LL |     let 23name = 123;\n+   |         ^^^^^^ expected identifier\n+   |\n+help: identifiers cannot start with a number\n+  --> $DIR/issue-104088.rs:9:9\n    |\n-   = help: identifiers cannot start with a number\n+LL |     let 23name = 123;\n+   |         ^^\n \n error: expected identifier, found `2x`\n-  --> $DIR/issue-104088.rs:11:9\n+  --> $DIR/issue-104088.rs:12:9\n    |\n LL |     let 2x: i32 = 123;\n    |         ^^ expected identifier\n    |\n-   = help: identifiers cannot start with a number\n+help: identifiers cannot start with a number\n+  --> $DIR/issue-104088.rs:12:9\n+   |\n+LL |     let 2x: i32 = 123;\n+   |         ^\n \n-error: expected identifier, found `23name`\n-  --> $DIR/issue-104088.rs:22:9\n+error: expected identifier, found `1x`\n+  --> $DIR/issue-104088.rs:15:9\n    |\n-LL |     let 23name = 123;\n-   |         ^^^^^^ expected identifier\n+LL |     let 1x = 123;\n+   |         ^^ expected identifier\n    |\n-   = help: identifiers cannot start with a number\n+help: identifiers cannot start with a number\n+  --> $DIR/issue-104088.rs:15:9\n+   |\n+LL |     let 1x = 123;\n+   |         ^\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-104088.rs:16:12\n+  --> $DIR/issue-104088.rs:5:12\n    |\n LL |     if let 2e1 = 123 {\n    |            ^^^   --- this expression has type `{integer}`\n    |            |\n    |            expected integer, found floating-point number\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "11636bfeb55095bef82786977005e554f45b2dd9", "filename": "tests/ui/traits/new-solver/coherence/issue-102048.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,44 @@\n+// This must fail coherence.\n+//\n+// Getting this to pass was fairly difficult, so here's an explanation\n+// of what's happening:\n+//\n+// Normalizing projections currently tries to replace them with inference variables\n+// while emitting a nested `Projection` obligation. This cannot be done if the projection\n+// has bound variables which is the case here.\n+//\n+// So the projections stay until after normalization. When unifying two projections we\n+// currently treat them as if they are injective, so we **incorrectly** unify their\n+// substs. This means that coherence for the two impls ends up unifying `?T` and `?U`\n+// as it tries to unify `<?T as WithAssoc1<'a>>::Assoc` with `<?U as WithAssoc1<'a>>::Assoc`.\n+//\n+// `impl1` therefore has the projection `<?T as WithAssoc2<'a>>::Assoc` and we have the\n+// assumption `?T: for<'a> WithAssoc2<'a, Assoc = i32>` in the `param_env`, so we normalize\n+// that to `i32`. We then try to unify `i32` from `impl1` with `u32` from `impl2` which fails,\n+// causing coherence to consider these two impls distinct.\n+\n+// compile-flags: -Ztrait-solver=next\n+pub trait Trait<T> {}\n+\n+pub trait WithAssoc1<'a> {\n+    type Assoc;\n+}\n+pub trait WithAssoc2<'a> {\n+    type Assoc;\n+}\n+\n+// impl 1\n+impl<T, U> Trait<for<'a> fn(<T as WithAssoc1<'a>>::Assoc, <U as WithAssoc2<'a>>::Assoc)> for (T, U)\n+where\n+    T: for<'a> WithAssoc1<'a> + for<'a> WithAssoc2<'a, Assoc = i32>,\n+    U: for<'a> WithAssoc2<'a>,\n+{\n+}\n+\n+// impl 2\n+impl<T, U> Trait<for<'a> fn(<U as WithAssoc1<'a>>::Assoc, u32)> for (T, U) where\n+    U: for<'a> WithAssoc1<'a> //~^ ERROR conflicting implementations of trait\n+{\n+}\n+\n+fn main() {}"}, {"sha": "17a43838fe2754d9c6bd20e23375e6fcbf24aec9", "filename": "tests/ui/traits/new-solver/coherence/issue-102048.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `Trait<for<'a> fn(<_ as WithAssoc1<'a>>::Assoc, <_ as WithAssoc2<'a>>::Assoc)>` for type `(_, _)`\n+  --> $DIR/issue-102048.rs:39:1\n+   |\n+LL | impl<T, U> Trait<for<'a> fn(<T as WithAssoc1<'a>>::Assoc, <U as WithAssoc2<'a>>::Assoc)> for (T, U)\n+   | --------------------------------------------------------------------------------------------------- first implementation here\n+...\n+LL | impl<T, U> Trait<for<'a> fn(<U as WithAssoc1<'a>>::Assoc, u32)> for (T, U) where\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(_, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "e5a3c3f5cc4b79db1bfd9d367e22c929caaa9984", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.next.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,11 @@\n+error[E0119]: conflicting implementations of trait `OtherTrait` for type `()`\n+  --> $DIR/coherence-conflict.rs:12:1\n+   |\n+LL | impl OtherTrait for () {}\n+   | ---------------------- first implementation here\n+LL | impl<T: MyTrait> OtherTrait for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "393350ea3f12a52f2a4b3a104566d671d242fc47", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.old.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,5 +1,5 @@\n error[E0119]: conflicting implementations of trait `OtherTrait` for type `()`\n-  --> $DIR/coherence-conflict.rs:11:1\n+  --> $DIR/coherence-conflict.rs:12:1\n    |\n LL | impl OtherTrait for () {}\n    | ---------------------- first implementation here", "previous_filename": "tests/ui/traits/reservation-impl/coherence-conflict.stderr"}, {"sha": "6bbd90f94dc392a121f8b875bc34884ae87e2559", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,5 +1,6 @@\n // check that reservation impls are accounted for in negative reasoning.\n-\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n #![feature(rustc_attrs)]\n \n trait MyTrait {}"}, {"sha": "542e3a28adf280889af0e8607e11d88a67da5985", "filename": "tests/ui/traits/reservation-impl/no-use.next.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `(): MyTrait` is not satisfied\n-  --> $DIR/no-use.rs:10:26\n+  --> $DIR/no-use.rs:11:26\n    |\n LL |     <() as MyTrait>::foo(&());\n    |     -------------------- ^^^ the trait `MyTrait` is not implemented for `()`", "previous_filename": "tests/ui/traits/reservation-impl/no-use.stderr"}, {"sha": "542e3a28adf280889af0e8607e11d88a67da5985", "filename": "tests/ui/traits/reservation-impl/no-use.old.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: the trait bound `(): MyTrait` is not satisfied\n+  --> $DIR/no-use.rs:11:26\n+   |\n+LL |     <() as MyTrait>::foo(&());\n+   |     -------------------- ^^^ the trait `MyTrait` is not implemented for `()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `MyTrait` is implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "864f1791fd0a79ab3d1d184b3f72813a51a9dba5", "filename": "tests/ui/traits/reservation-impl/no-use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -1,5 +1,6 @@\n // check that reservation impls can't be used as normal impls in positive reasoning.\n-\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n #![feature(rustc_attrs)]\n \n trait MyTrait { fn foo(&self); }"}, {"sha": "7787904d9b22d581ce12b00a566e4526dfcdd340", "filename": "tests/ui/traits/reservation-impl/non-lattice-ok.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -30,6 +30,12 @@\n //\n // [ii]: https://smallcultfollowing.com/babysteps/blog/2016/09/24/intersection-impls/\n \n+\n+// check that reservation impls can't be used as normal impls in positive reasoning.\n+\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n+\n #![feature(rustc_attrs, never_type)]\n \n trait MyTrait {}"}, {"sha": "8ff6645a2b3d38d3398470c80cf9bd4ef2d5edb0", "filename": "tests/ui/traits/reservation-impl/ok.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84dd6dfd9d19176cc3c94bc1448a841e44d57890/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs?ref=84dd6dfd9d19176cc3c94bc1448a841e44d57890", "patch": "@@ -3,6 +3,9 @@\n // rpass test for reservation impls. Not 100% required because `From` uses them,\n // but still.\n \n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n+\n #![feature(rustc_attrs)]\n \n use std::mem;"}]}