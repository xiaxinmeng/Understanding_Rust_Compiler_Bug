{"sha": "0b8d817404325c6bd777b38dec31428bc33f2746", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiOGQ4MTc0MDQzMjVjNmJkNzc3YjM4ZGVjMzE0MjhiYzMzZjI3NDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-22T01:17:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-22T01:17:52Z"}, "message": "Auto merge of #51433 - scalexm:finish-rules, r=nikomatsakis\n\n[chalkify] Small refactoring and WF/FromEnv rules for types\n\nr? @nikomatsakis", "tree": {"sha": "0dc37c89b045cba8a0803fbdd0df165de6646592", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dc37c89b045cba8a0803fbdd0df165de6646592"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b8d817404325c6bd777b38dec31428bc33f2746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b8d817404325c6bd777b38dec31428bc33f2746", "html_url": "https://github.com/rust-lang/rust/commit/0b8d817404325c6bd777b38dec31428bc33f2746", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b8d817404325c6bd777b38dec31428bc33f2746/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec60dd81f9b749092d9a2dc871eef620e0f520f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec60dd81f9b749092d9a2dc871eef620e0f520f5", "html_url": "https://github.com/rust-lang/rust/commit/ec60dd81f9b749092d9a2dc871eef620e0f520f5"}, {"sha": "796ded2dfd2c042fc355c22558881fc7b6ed00cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/796ded2dfd2c042fc355c22558881fc7b6ed00cf", "html_url": "https://github.com/rust-lang/rust/commit/796ded2dfd2c042fc355c22558881fc7b6ed00cf"}], "stats": {"total": 474, "additions": 335, "deletions": 139}, "files": [{"sha": "684a1d2965838e2bda85440abf9f9c3d63762bba", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0b8d817404325c6bd777b38dec31428bc33f2746", "patch": "@@ -1373,16 +1373,46 @@ impl_stable_hash_for!(enum infer::canonical::Certainty {\n     Proven, Ambiguous\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClauseAtom<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClause<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::WhereClauseAtom::*;\n+        use traits::WhereClause::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n             Implemented(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n             ProjectionEq(projection) => projection.hash_stable(hcx, hasher),\n+            TypeOutlives(ty_outlives) => ty_outlives.hash_stable(hcx, hasher),\n+            RegionOutlives(region_outlives) => region_outlives.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WellFormed<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::WellFormed::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Trait(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n+            Ty(ty) => ty.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::FromEnv<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use traits::FromEnv::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Trait(trait_ref) => trait_ref.hash_stable(hcx, hasher),\n+            Ty(ty) => ty.hash_stable(hcx, hasher),\n         }\n     }\n }\n@@ -1395,15 +1425,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx>\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n-            Holds(where_clause) |\n-            WellFormed(where_clause) |\n-            FromEnv(where_clause) => where_clause.hash_stable(hcx, hasher),\n-\n-            WellFormedTy(ty) => ty.hash_stable(hcx, hasher),\n+            Holds(wc) => wc.hash_stable(hcx, hasher),\n+            WellFormed(wf) => wf.hash_stable(hcx, hasher),\n+            FromEnv(from_env) => from_env.hash_stable(hcx, hasher),\n             Normalize(projection) => projection.hash_stable(hcx, hasher),\n-            FromEnvTy(ty) => ty.hash_stable(hcx, hasher),\n-            RegionOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n-            TypeOutlives(predicate) => predicate.hash_stable(hcx, hasher),\n         }\n     }\n }"}, {"sha": "354debf87dc0783bc85aae9830f93c7ec7c580af", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=0b8d817404325c6bd777b38dec31428bc33f2746", "patch": "@@ -269,29 +269,41 @@ pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n /// The following types:\n-/// * `WhereClauseAtom`\n+/// * `WhereClause`\n+/// * `WellFormed`\n+/// * `FromEnv`\n /// * `DomainGoal`\n /// * `Goal`\n /// * `Clause`\n /// are used for representing the trait system in the form of\n /// logic programming clauses. They are part of the interface\n /// for the chalk SLG solver.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum WhereClauseAtom<'tcx> {\n+pub enum WhereClause<'tcx> {\n     Implemented(ty::TraitPredicate<'tcx>),\n     ProjectionEq(ty::ProjectionPredicate<'tcx>),\n+    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum WellFormed<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum FromEnv<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum DomainGoal<'tcx> {\n-    Holds(WhereClauseAtom<'tcx>),\n-    WellFormed(WhereClauseAtom<'tcx>),\n-    FromEnv(WhereClauseAtom<'tcx>),\n-    WellFormedTy(Ty<'tcx>),\n+    Holds(WhereClause<'tcx>),\n+    WellFormed(WellFormed<'tcx>),\n+    FromEnv(FromEnv<'tcx>),\n     Normalize(ty::ProjectionPredicate<'tcx>),\n-    FromEnvTy(Ty<'tcx>),\n-    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n-    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n }\n \n pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n@@ -314,27 +326,27 @@ pub enum Goal<'tcx> {\n \n pub type Goals<'tcx> = &'tcx Slice<Goal<'tcx>>;\n \n+impl<'tcx> DomainGoal<'tcx> {\n+    pub fn into_goal(self) -> Goal<'tcx> {\n+        Goal::DomainGoal(self)\n+    }\n+}\n+\n impl<'tcx> Goal<'tcx> {\n     pub fn from_poly_domain_goal<'a>(\n         domain_goal: PolyDomainGoal<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ) -> Goal<'tcx> {\n         match domain_goal.no_late_bound_regions() {\n-            Some(p) => p.into(),\n+            Some(p) => p.into_goal(),\n             None => Goal::Quantified(\n                 QuantifierKind::Universal,\n-                domain_goal.map_bound(|p| tcx.mk_goal(Goal::from(p)))\n+                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal()))\n             ),\n         }\n     }\n }\n \n-impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n-    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n-        Goal::DomainGoal(domain_goal)\n-    }\n-}\n-\n /// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n /// Harrop Formulas\".\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "d24c84b2556f860653902fb8aace1aa896b6940c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 73, "deletions": 30, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=0b8d817404325c6bd777b38dec31428bc33f2746", "patch": "@@ -405,33 +405,50 @@ BraceStructTypeFoldableImpl! {\n     } where T: TypeFoldable<'tcx>\n }\n \n-impl<'tcx> fmt::Display for traits::WhereClauseAtom<'tcx> {\n+impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        use traits::WhereClauseAtom::*;\n+        use traits::WhereClause::*;\n \n         match self {\n             Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n             ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+            RegionOutlives(predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n+            TypeOutlives(predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::WellFormed::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        use traits::FromEnv::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n         }\n     }\n }\n \n impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         use traits::DomainGoal::*;\n-        use traits::WhereClauseAtom::*;\n \n         match self {\n             Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(Implemented(trait_ref)) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            WellFormed(ProjectionEq(projection)) => write!(fmt, \"WellFormed({})\", projection),\n-            FromEnv(Implemented(trait_ref)) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            FromEnv(ProjectionEq(projection)) => write!(fmt, \"FromEnv({})\", projection),\n-            WellFormedTy(ty) => write!(fmt, \"WellFormed({})\", ty),\n+            WellFormed(wf) => write!(fmt, \"{}\", wf),\n+            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n             Normalize(projection) => write!(fmt, \"Normalize({})\", projection),\n-            FromEnvTy(ty) => write!(fmt, \"FromEnv({})\", ty),\n-            RegionOutlives(predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n-            TypeOutlives(predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n         }\n     }\n }\n@@ -506,44 +523,70 @@ impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n }\n \n EnumTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for traits::WhereClauseAtom<'tcx> {\n-        (traits::WhereClauseAtom::Implemented)(trait_ref),\n-        (traits::WhereClauseAtom::ProjectionEq)(projection),\n+    impl<'tcx> TypeFoldable<'tcx> for traits::WhereClause<'tcx> {\n+        (traits::WhereClause::Implemented)(trait_ref),\n+        (traits::WhereClause::ProjectionEq)(projection),\n+        (traits::WhereClause::TypeOutlives)(ty_outlives),\n+        (traits::WhereClause::RegionOutlives)(region_outlives),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClause<'a> {\n+        type Lifted = traits::WhereClause<'tcx>;\n+        (traits::WhereClause::Implemented)(trait_ref),\n+        (traits::WhereClause::ProjectionEq)(projection),\n+        (traits::WhereClause::TypeOutlives)(ty_outlives),\n+        (traits::WhereClause::RegionOutlives)(region_outlives),\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::WellFormed<'tcx> {\n+        (traits::WellFormed::Trait)(trait_ref),\n+        (traits::WellFormed::Ty)(ty),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WellFormed<'a> {\n+        type Lifted = traits::WellFormed<'tcx>;\n+        (traits::WellFormed::Trait)(trait_ref),\n+        (traits::WellFormed::Ty)(ty),\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::FromEnv<'tcx> {\n+        (traits::FromEnv::Trait)(trait_ref),\n+        (traits::FromEnv::Ty)(ty),\n     }\n }\n \n EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClauseAtom<'a> {\n-        type Lifted = traits::WhereClauseAtom<'tcx>;\n-        (traits::WhereClauseAtom::Implemented)(trait_ref),\n-        (traits::WhereClauseAtom::ProjectionEq)(projection),\n+    impl<'a, 'tcx> Lift<'tcx> for traits::FromEnv<'a> {\n+        type Lifted = traits::FromEnv<'tcx>;\n+        (traits::FromEnv::Trait)(trait_ref),\n+        (traits::FromEnv::Ty)(ty),\n     }\n }\n \n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n         (traits::DomainGoal::Holds)(wc),\n-        (traits::DomainGoal::WellFormed)(wc),\n-        (traits::DomainGoal::FromEnv)(wc),\n-        (traits::DomainGoal::WellFormedTy)(ty),\n+        (traits::DomainGoal::WellFormed)(wf),\n+        (traits::DomainGoal::FromEnv)(from_env),\n         (traits::DomainGoal::Normalize)(projection),\n-        (traits::DomainGoal::FromEnvTy)(ty),\n-        (traits::DomainGoal::RegionOutlives)(predicate),\n-        (traits::DomainGoal::TypeOutlives)(predicate),\n     }\n }\n \n EnumLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for traits::DomainGoal<'a> {\n         type Lifted = traits::DomainGoal<'tcx>;\n         (traits::DomainGoal::Holds)(wc),\n-        (traits::DomainGoal::WellFormed)(wc),\n-        (traits::DomainGoal::FromEnv)(wc),\n-        (traits::DomainGoal::WellFormedTy)(ty),\n+        (traits::DomainGoal::WellFormed)(wf),\n+        (traits::DomainGoal::FromEnv)(from_env),\n         (traits::DomainGoal::Normalize)(projection),\n-        (traits::DomainGoal::FromEnvTy)(ty),\n-        (traits::DomainGoal::RegionOutlives)(predicate),\n-        (traits::DomainGoal::TypeOutlives)(predicate),\n     }\n }\n "}, {"sha": "a1242621cb18c5882197fd25c265bad632b7bac6", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=0b8d817404325c6bd777b38dec31428bc33f2746", "patch": "@@ -14,7 +14,16 @@ use rustc::infer::canonical::{\n     Canonical, CanonicalVarValues, Canonicalize, QueryRegionConstraint, QueryResult,\n };\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use rustc::traits::{DomainGoal, ExClauseFold, ExClauseLift, Goal, ProgramClause, QuantifierKind};\n+use rustc::traits::{\n+    WellFormed,\n+    FromEnv,\n+    DomainGoal,\n+    ExClauseFold,\n+    ExClauseLift,\n+    Goal,\n+    ProgramClause,\n+    QuantifierKind\n+};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, TyCtxt};\n@@ -314,43 +323,42 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         _environment: &ty::ParamEnv<'tcx>,\n         goal: &DomainGoal<'tcx>,\n     ) -> Vec<ProgramClause<'tcx>> {\n-        use rustc::traits::DomainGoal::*;\n-        use rustc::traits::WhereClauseAtom::*;\n+        use rustc::traits::WhereClause::*;\n \n         match goal {\n-            Holds(Implemented(_trait_predicate)) => {\n+            DomainGoal::Holds(Implemented(_trait_predicate)) => {\n                 // These come from:\n                 //\n                 // - Trait definitions (implied bounds)\n                 // - Implementations of the trait itself\n                 panic!()\n             }\n \n-            Holds(ProjectionEq(_projection_predicate)) => {\n+            DomainGoal::Holds(ProjectionEq(_projection_predicate)) => {\n                 // These come from:\n                 panic!()\n             }\n \n-            WellFormed(Implemented(_trait_predicate)) => {\n-                // These come from -- the trait decl.\n+            DomainGoal::Holds(RegionOutlives(_region_outlives)) => {\n                 panic!()\n             }\n \n-            WellFormed(ProjectionEq(_projection_predicate)) => panic!(),\n-\n-            FromEnv(Implemented(_trait_predicate)) => panic!(),\n-\n-            FromEnv(ProjectionEq(_projection_predicate)) => panic!(),\n+            DomainGoal::Holds(TypeOutlives(_type_outlives)) => {\n+                panic!()\n+            }\n \n-            WellFormedTy(_ty) => panic!(),\n+            DomainGoal::WellFormed(WellFormed::Trait(_trait_predicate)) => {\n+                // These come from -- the trait decl.\n+                panic!()\n+            }\n \n-            FromEnvTy(_ty) => panic!(),\n+            DomainGoal::WellFormed(WellFormed::Ty(_ty)) => panic!(),\n \n-            RegionOutlives(_region_outlives) => panic!(),\n+            DomainGoal::FromEnv(FromEnv::Trait(_trait_predicate)) => panic!(),\n \n-            TypeOutlives(_type_outlives) => panic!(),\n+            DomainGoal::FromEnv(FromEnv::Ty(_ty)) => panic!(),\n \n-            Normalize(_) => panic!(),\n+            DomainGoal::Normalize(_) => panic!(),\n         }\n     }\n "}, {"sha": "0270e970976eaa59906bccbfda1f1783ee4e462c", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 142, "deletions": 64, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=0b8d817404325c6bd777b38dec31428bc33f2746", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::map::definitions::DefPathData;\n use rustc::hir::{self, ImplPolarity};\n use rustc::traits::{Clause, Clauses, DomainGoal, Goal, PolyDomainGoal, ProgramClause,\n-                    WhereClauseAtom};\n+                    WhereClause, FromEnv, WellFormed};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Slice, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n@@ -23,7 +23,7 @@ use syntax::ast;\n use std::iter;\n \n crate trait Lower<T> {\n-    /// Lower a rustc construction (e.g. `ty::TraitPredicate`) to a chalk-like type.\n+    /// Lower a rustc construct (e.g. `ty::TraitPredicate`) to a chalk-like type.\n     fn lower(&self) -> T;\n }\n \n@@ -36,36 +36,36 @@ where\n     }\n }\n \n-impl<'tcx> Lower<WhereClauseAtom<'tcx>> for ty::TraitPredicate<'tcx> {\n-    fn lower(&self) -> WhereClauseAtom<'tcx> {\n-        WhereClauseAtom::Implemented(*self)\n+impl<'tcx> Lower<WhereClause<'tcx>> for ty::TraitPredicate<'tcx> {\n+    fn lower(&self) -> WhereClause<'tcx> {\n+        WhereClause::Implemented(*self)\n     }\n }\n \n-impl<'tcx> Lower<WhereClauseAtom<'tcx>> for ty::ProjectionPredicate<'tcx> {\n-    fn lower(&self) -> WhereClauseAtom<'tcx> {\n-        WhereClauseAtom::ProjectionEq(*self)\n+impl<'tcx> Lower<WhereClause<'tcx>> for ty::ProjectionPredicate<'tcx> {\n+    fn lower(&self) -> WhereClause<'tcx> {\n+        WhereClause::ProjectionEq(*self)\n     }\n }\n \n-impl<'tcx, T> Lower<DomainGoal<'tcx>> for T\n-where\n-    T: Lower<WhereClauseAtom<'tcx>>,\n-{\n-    fn lower(&self) -> DomainGoal<'tcx> {\n-        DomainGoal::Holds(self.lower())\n+impl<'tcx> Lower<WhereClause<'tcx>> for ty::RegionOutlivesPredicate<'tcx> {\n+    fn lower(&self) -> WhereClause<'tcx> {\n+        WhereClause::RegionOutlives(*self)\n     }\n }\n \n-impl<'tcx> Lower<DomainGoal<'tcx>> for ty::RegionOutlivesPredicate<'tcx> {\n-    fn lower(&self) -> DomainGoal<'tcx> {\n-        DomainGoal::RegionOutlives(*self)\n+impl<'tcx> Lower<WhereClause<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n+    fn lower(&self) -> WhereClause<'tcx> {\n+        WhereClause::TypeOutlives(*self)\n     }\n }\n \n-impl<'tcx> Lower<DomainGoal<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n+impl<'tcx, T> Lower<DomainGoal<'tcx>> for T\n+where\n+    T: Lower<WhereClause<'tcx>>,\n+{\n     fn lower(&self) -> DomainGoal<'tcx> {\n-        DomainGoal::TypeOutlives(*self)\n+        DomainGoal::Holds(self.lower())\n     }\n }\n \n@@ -86,15 +86,20 @@ where\n \n impl<'tcx> Lower<PolyDomainGoal<'tcx>> for ty::Predicate<'tcx> {\n     fn lower(&self) -> PolyDomainGoal<'tcx> {\n-        use rustc::ty::Predicate::*;\n+        use rustc::ty::Predicate;\n \n         match self {\n-            Trait(predicate) => predicate.lower(),\n-            RegionOutlives(predicate) => predicate.lower(),\n-            TypeOutlives(predicate) => predicate.lower(),\n-            Projection(predicate) => predicate.lower(),\n-            WellFormed(ty) => ty::Binder::dummy(DomainGoal::WellFormedTy(*ty)),\n-            ObjectSafe(..) | ClosureKind(..) | Subtype(..) | ConstEvaluatable(..) => {\n+            Predicate::Trait(predicate) => predicate.lower(),\n+            Predicate::RegionOutlives(predicate) => predicate.lower(),\n+            Predicate::TypeOutlives(predicate) => predicate.lower(),\n+            Predicate::Projection(predicate) => predicate.lower(),\n+            Predicate::WellFormed(ty) => ty::Binder::dummy(\n+                DomainGoal::WellFormed(WellFormed::Ty(*ty))\n+            ),\n+            Predicate::ObjectSafe(..) |\n+            Predicate::ClosureKind(..) |\n+            Predicate::Subtype(..) |\n+            Predicate::ConstEvaluatable(..) => {\n                 unimplemented!()\n             }\n         }\n@@ -110,11 +115,13 @@ trait IntoFromEnvGoal {\n \n impl<'tcx> IntoFromEnvGoal for DomainGoal<'tcx> {\n     fn into_from_env_goal(self) -> DomainGoal<'tcx> {\n-        use self::DomainGoal::*;\n+        use self::WhereClause::*;\n+\n         match self {\n-            Holds(wc_atom) => FromEnv(wc_atom),\n-            WellFormed(..) | FromEnv(..) | WellFormedTy(..) | FromEnvTy(..) | Normalize(..)\n-            | RegionOutlives(..) | TypeOutlives(..) => self,\n+            DomainGoal::Holds(Implemented(trait_ref)) => DomainGoal::FromEnv(\n+                FromEnv::Trait(trait_ref)\n+            ),\n+            other => other,\n         }\n     }\n }\n@@ -127,6 +134,8 @@ crate fn program_clauses_for<'a, 'tcx>(\n         DefPathData::Trait(_) => program_clauses_for_trait(tcx, def_id),\n         DefPathData::Impl => program_clauses_for_impl(tcx, def_id),\n         DefPathData::AssocTypeInImpl(..) => program_clauses_for_associated_type_value(tcx, def_id),\n+        DefPathData::AssocTypeInTrait(..) => program_clauses_for_associated_type_def(tcx, def_id),\n+        DefPathData::TypeNs(..) => program_clauses_for_type_def(tcx, def_id),\n         _ => Slice::empty(),\n     }\n }\n@@ -212,16 +221,20 @@ fn program_clauses_for_trait<'a, 'tcx>(\n             substs: Substs::identity_for_item(tcx, def_id),\n         },\n     };\n-    // `FromEnv(Self: Trait<P1..Pn>)`\n-    let from_env = Goal::from(DomainGoal::FromEnv(trait_pred.lower()));\n+\n     // `Implemented(Self: Trait<P1..Pn>)`\n-    let impl_trait = DomainGoal::Holds(WhereClauseAtom::Implemented(trait_pred));\n+    let impl_trait: DomainGoal = trait_pred.lower();\n+\n+     // `FromEnv(Self: Trait<P1..Pn>)`\n+    let from_env_goal = impl_trait.into_from_env_goal().into_goal();\n+    let hypotheses = tcx.intern_goals(&[from_env_goal]);\n \n     // `Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)`\n     let implemented_from_env = ProgramClause {\n         goal: impl_trait,\n-        hypotheses: tcx.intern_goals(&[from_env]),\n+        hypotheses,\n     };\n+\n     let clauses = iter::once(Clause::ForAll(ty::Binder::dummy(implemented_from_env)));\n \n     // Rule Implied-Bound-From-Trait\n@@ -239,25 +252,17 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     let where_clauses = &tcx.predicates_of(def_id).predicates;\n     let implied_bound_clauses = where_clauses[1..]\n         .into_iter()\n-        .map(|wc| implied_bound_from_trait(tcx, trait_pred, wc));\n+        .map(|wc| wc.lower())\n \n-    tcx.mk_clauses(clauses.chain(implied_bound_clauses))\n-}\n+        // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n+        .map(|wc| wc.map_bound(|goal| ProgramClause {\n+            goal: goal.into_from_env_goal(),\n+            hypotheses,\n+        }))\n \n-/// For a given `where_clause`, returns a clause `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`.\n-fn implied_bound_from_trait<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    trait_pred: ty::TraitPredicate<'tcx>,\n-    where_clause: &ty::Predicate<'tcx>,\n-) -> Clause<'tcx> {\n-    // `FromEnv(Self: Trait<P1..Pn>)`\n-    let impl_trait = DomainGoal::FromEnv(WhereClauseAtom::Implemented(trait_pred));\n-\n-    // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n-    Clause::ForAll(where_clause.lower().map_bound(|goal| ProgramClause {\n-        goal: goal.into_from_env_goal(),\n-        hypotheses: tcx.intern_goals(&[Goal::from(impl_trait)]),\n-    }))\n+        .map(Clause::ForAll);\n+\n+    tcx.mk_clauses(clauses.chain(implied_bound_clauses))\n }\n \n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n@@ -275,9 +280,11 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     // }\n     // ```\n \n-    let trait_ref = tcx.impl_trait_ref(def_id).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+\n     // `Implemented(A0: Trait<A1..An>)`\n     let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n+\n     // `WC`\n     let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n \n@@ -293,6 +300,72 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     tcx.intern_clauses(&[Clause::ForAll(ty::Binder::dummy(clause))])\n }\n \n+pub fn program_clauses_for_type_def<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> Clauses<'tcx> {\n+\n+    // Rule WellFormed-Type\n+    //\n+    // `struct Ty<P1..Pn> where WC1, ..., WCm`\n+    //\n+    // ```\n+    // forall<P1..Pn> {\n+    //   WellFormed(Ty<...>) :- WC1, ..., WCm`\n+    // }\n+    // ```\n+\n+    // `Ty<...>`\n+    let ty = tcx.type_of(def_id);\n+\n+    // `WC`\n+    let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n+\n+    // `WellFormed(Ty<...>) :- WC1, ..., WCm`\n+    let well_formed = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n+        hypotheses: tcx.mk_goals(\n+            where_clauses.iter().cloned().map(|wc| Goal::from_poly_domain_goal(wc, tcx))\n+        ),\n+    };\n+\n+    let well_formed_clause = iter::once(Clause::ForAll(ty::Binder::dummy(well_formed)));\n+\n+    // Rule FromEnv-Type\n+    //\n+    // For each where clause `WC`:\n+    // ```\n+    // forall<P1..Pn> {\n+    //   FromEnv(WC) :- FromEnv(Ty<...>)\n+    // }\n+    // ```\n+\n+    // `FromEnv(Ty<...>)`\n+    let from_env_goal = DomainGoal::FromEnv(FromEnv::Ty(ty)).into_goal();\n+    let hypotheses = tcx.intern_goals(&[from_env_goal]);\n+\n+    // For each where clause `WC`:\n+    let from_env_clauses = where_clauses\n+        .into_iter()\n+\n+        // `FromEnv(WC) :- FromEnv(Ty<...>)`\n+        .map(|wc| wc.map_bound(|goal| ProgramClause {\n+            goal: goal.into_from_env_goal(),\n+            hypotheses,\n+        }))\n+\n+        .map(Clause::ForAll);\n+\n+    tcx.mk_clauses(well_formed_clause.chain(from_env_clauses))\n+}\n+\n+pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n+    _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    _item_id: DefId,\n+) -> Clauses<'tcx> {\n+    unimplemented!()\n+}\n+\n pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     item_id: DefId,\n@@ -301,45 +374,50 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     //\n     // ```impl<P0..Pn> Trait<A1..An> for A0\n     // {\n-    //     type AssocType<Pn+1..Pm> where WC = T;\n+    //     type AssocType<Pn+1..Pm> = T;\n     // }```\n     //\n+    // FIXME: For the moment, we don't account for where clauses written on the associated\n+    // ty definition (i.e. in the trait def, as in `type AssocType<T> where T: Sized`).\n     // ```\n     // forall<P0..Pm> {\n     //   forall<Pn+1..Pm> {\n     //     Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> T) :-\n-    //       Implemented(A0: Trait<A1..An>) && WC\n+    //       Implemented(A0: Trait<A1..An>)\n     //   }\n     // }\n     // ```\n \n     let item = tcx.associated_item(item_id);\n     debug_assert_eq!(item.kind, ty::AssociatedKind::Type);\n-    let impl_id = if let ty::AssociatedItemContainer::ImplContainer(impl_id) = item.container {\n-        impl_id\n-    } else {\n-        bug!()\n+    let impl_id = match item.container {\n+        ty::AssociatedItemContainer::ImplContainer(impl_id) => impl_id,\n+        _ => bug!(\"not an impl container\"),\n     };\n+\n     // `A0 as Trait<A1..An>`\n     let trait_ref = tcx.impl_trait_ref(impl_id).unwrap();\n+\n     // `T`\n     let ty = tcx.type_of(item_id);\n+\n     // `Implemented(A0: Trait<A1..An>)`\n     let trait_implemented = ty::Binder::dummy(ty::TraitPredicate { trait_ref }.lower());\n-    // `WC`\n-    let item_where_clauses = tcx.predicates_of(item_id).predicates.lower();\n-    // `Implemented(A0: Trait<A1..An>) && WC`\n-    let mut where_clauses = vec![trait_implemented];\n-    where_clauses.extend(item_where_clauses);\n+\n+    // `Implemented(A0: Trait<A1..An>)`\n+    let hypotheses = vec![trait_implemented];\n+\n     // `<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm>`\n     let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.name);\n+\n     // `Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> T)`\n     let normalize_goal = DomainGoal::Normalize(ty::ProjectionPredicate { projection_ty, ty });\n+\n     // `Normalize(... -> T) :- ...`\n     let clause = ProgramClause {\n         goal: normalize_goal,\n         hypotheses: tcx.mk_goals(\n-            where_clauses\n+            hypotheses\n                 .into_iter()\n                 .map(|wc| Goal::from_poly_domain_goal(wc, tcx)),\n         ),"}, {"sha": "9287555a0568410a9262bc41a5e6ec09337781ec", "filename": "src/test/ui/chalkify/lower_struct.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs?ref=0b8d817404325c6bd777b38dec31428bc33f2746", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_dump_program_clauses] //~ ERROR program clause dump\n+struct Foo<T> where Box<T>: Clone {\n+    _x: std::marker::PhantomData<T>,\n+}\n+\n+fn main() { }"}, {"sha": "d6cc9c8e9a401d5c93a8d0459fc2fec5e9c1c623", "filename": "src/test/ui/chalkify/lower_struct.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr?ref=0b8d817404325c6bd777b38dec31428bc33f2746", "patch": "@@ -0,0 +1,12 @@\n+error: program clause dump\n+  --> $DIR/lower_struct.rs:13:1\n+   |\n+LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: FromEnv(T: std::marker::Sized) :- FromEnv(Foo<T>).\n+   = note: FromEnv(std::boxed::Box<T>: std::clone::Clone) :- FromEnv(Foo<T>).\n+   = note: WellFormed(Foo<T>) :- Implemented(T: std::marker::Sized), Implemented(std::boxed::Box<T>: std::clone::Clone).\n+\n+error: aborting due to previous error\n+"}, {"sha": "ea275d647fa7c143fb66a355d8853c1355906656", "filename": "src/test/ui/chalkify/lower_trait_higher_rank.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b8d817404325c6bd777b38dec31428bc33f2746/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr?ref=0b8d817404325c6bd777b38dec31428bc33f2746", "patch": "@@ -4,10 +4,10 @@ error: program clause dump\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(<F as std::ops::FnOnce<(&'a (u8, u16),)>>::Output == &'a u8) :- FromEnv(Self: Foo<F>).\n    = note: FromEnv(F: std::marker::Sized) :- FromEnv(Self: Foo<F>).\n    = note: FromEnv(F: std::ops::Fn<(&'a (u8, u16),)>) :- FromEnv(Self: Foo<F>).\n    = note: Implemented(Self: Foo<F>) :- FromEnv(Self: Foo<F>).\n+   = note: ProjectionEq(<F as std::ops::FnOnce<(&'a (u8, u16),)>>::Output == &'a u8) :- FromEnv(Self: Foo<F>).\n \n error: aborting due to previous error\n "}]}