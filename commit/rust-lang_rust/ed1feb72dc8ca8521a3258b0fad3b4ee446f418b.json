{"sha": "ed1feb72dc8ca8521a3258b0fad3b4ee446f418b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMWZlYjcyZGM4Y2E4NTIxYTMyNThiMGZhZDNiNGVlNDQ2ZjQxOGI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-06T20:28:04Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-06T20:28:04Z"}, "message": "Merge #211\n\n211: ra_syntax::File is just RootNode r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "263aed65ed9a8aa30b37674d01f8a82aee66d2f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/263aed65ed9a8aa30b37674d01f8a82aee66d2f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b", "html_url": "https://github.com/rust-lang/rust/commit/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "7196286ec5de7a545654ca94878230fc31d4a8db", "url": "https://api.github.com/repos/rust-lang/rust/commits/7196286ec5de7a545654ca94878230fc31d4a8db", "html_url": "https://github.com/rust-lang/rust/commit/7196286ec5de7a545654ca94878230fc31d4a8db"}, {"sha": "8eaf7952ae4ba510d448a7e310a3e2dcfd09f6d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eaf7952ae4ba510d448a7e310a3e2dcfd09f6d3", "html_url": "https://github.com/rust-lang/rust/commit/8eaf7952ae4ba510d448a7e310a3e2dcfd09f6d3"}], "stats": {"total": 1175, "additions": 969, "deletions": 206}, "files": [{"sha": "3878c99a86d9b5ce3f1e05c2f0e4952a213a572b", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 948, "deletions": 194, "changes": 1142, "blob_url": "https://github.com/rust-lang/rust/blob/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=ed1feb72dc8ca8521a3258b0fad3b4ee446f418b", "patch": "@@ -9,6 +9,8 @@\n \n #![cfg_attr(rustfmt, rustfmt_skip)]\n \n+use std::hash::{Hash, Hasher};\n+\n use crate::{\n     ast,\n     SyntaxNode, SyntaxNodeRef, AstNode,\n@@ -17,12 +19,20 @@ use crate::{\n };\n \n // ArgList\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ArgListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ArgList<'a> = ArgListNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ArgListNode<R1>> for ArgListNode<R2> {\n+    fn eq(&self, other: &ArgListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ArgListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ArgListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ArgList<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -50,12 +60,20 @@ impl<'a> ArgList<'a> {\n }\n \n // ArrayExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ArrayExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ArrayExpr<'a> = ArrayExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ArrayExprNode<R1>> for ArrayExprNode<R2> {\n+    fn eq(&self, other: &ArrayExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ArrayExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ArrayExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ArrayExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -79,12 +97,20 @@ impl<R: TreeRoot<RaTypes>> ArrayExprNode<R> {\n impl<'a> ArrayExpr<'a> {}\n \n // ArrayType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ArrayTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ArrayType<'a> = ArrayTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ArrayTypeNode<R1>> for ArrayTypeNode<R2> {\n+    fn eq(&self, other: &ArrayTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ArrayTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ArrayTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ArrayType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -108,12 +134,20 @@ impl<R: TreeRoot<RaTypes>> ArrayTypeNode<R> {\n impl<'a> ArrayType<'a> {}\n \n // Attr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct AttrNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Attr<'a> = AttrNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<AttrNode<R1>> for AttrNode<R2> {\n+    fn eq(&self, other: &AttrNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for AttrNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for AttrNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Attr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -141,12 +175,20 @@ impl<'a> Attr<'a> {\n }\n \n // BinExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct BinExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type BinExpr<'a> = BinExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BinExprNode<R1>> for BinExprNode<R2> {\n+    fn eq(&self, other: &BinExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for BinExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for BinExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for BinExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -170,12 +212,20 @@ impl<R: TreeRoot<RaTypes>> BinExprNode<R> {\n impl<'a> BinExpr<'a> {}\n \n // BindPat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct BindPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type BindPat<'a> = BindPatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BindPatNode<R1>> for BindPatNode<R2> {\n+    fn eq(&self, other: &BindPatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for BindPatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for BindPatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for BindPat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -200,12 +250,20 @@ impl<'a> ast::NameOwner<'a> for BindPat<'a> {}\n impl<'a> BindPat<'a> {}\n \n // Block\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct BlockNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Block<'a> = BlockNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BlockNode<R1>> for BlockNode<R2> {\n+    fn eq(&self, other: &BlockNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for BlockNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for BlockNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Block<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -237,12 +295,20 @@ impl<'a> Block<'a> {\n }\n \n // BlockExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct BlockExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type BlockExpr<'a> = BlockExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BlockExprNode<R1>> for BlockExprNode<R2> {\n+    fn eq(&self, other: &BlockExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for BlockExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for BlockExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for BlockExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -270,12 +336,20 @@ impl<'a> BlockExpr<'a> {\n }\n \n // BreakExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct BreakExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type BreakExpr<'a> = BreakExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<BreakExprNode<R1>> for BreakExprNode<R2> {\n+    fn eq(&self, other: &BreakExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for BreakExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for BreakExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for BreakExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -299,12 +373,20 @@ impl<R: TreeRoot<RaTypes>> BreakExprNode<R> {\n impl<'a> BreakExpr<'a> {}\n \n // CallExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct CallExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type CallExpr<'a> = CallExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<CallExprNode<R1>> for CallExprNode<R2> {\n+    fn eq(&self, other: &CallExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for CallExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for CallExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for CallExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -333,12 +415,20 @@ impl<'a> CallExpr<'a> {\n }\n \n // CastExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct CastExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type CastExpr<'a> = CastExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<CastExprNode<R1>> for CastExprNode<R2> {\n+    fn eq(&self, other: &CastExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for CastExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for CastExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for CastExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -362,12 +452,20 @@ impl<R: TreeRoot<RaTypes>> CastExprNode<R> {\n impl<'a> CastExpr<'a> {}\n \n // Char\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct CharNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Char<'a> = CharNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<CharNode<R1>> for CharNode<R2> {\n+    fn eq(&self, other: &CharNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for CharNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for CharNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Char<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -391,12 +489,20 @@ impl<R: TreeRoot<RaTypes>> CharNode<R> {\n impl<'a> Char<'a> {}\n \n // Comment\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct CommentNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Comment<'a> = CommentNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<CommentNode<R1>> for CommentNode<R2> {\n+    fn eq(&self, other: &CommentNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for CommentNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for CommentNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Comment<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -420,12 +526,20 @@ impl<R: TreeRoot<RaTypes>> CommentNode<R> {\n impl<'a> Comment<'a> {}\n \n // Condition\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ConditionNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Condition<'a> = ConditionNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ConditionNode<R1>> for ConditionNode<R2> {\n+    fn eq(&self, other: &ConditionNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ConditionNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ConditionNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Condition<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -457,12 +571,20 @@ impl<'a> Condition<'a> {\n }\n \n // ConstDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ConstDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ConstDef<'a> = ConstDefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ConstDefNode<R1>> for ConstDefNode<R2> {\n+    fn eq(&self, other: &ConstDefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ConstDefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ConstDefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ConstDef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -489,12 +611,20 @@ impl<'a> ast::AttrsOwner<'a> for ConstDef<'a> {}\n impl<'a> ConstDef<'a> {}\n \n // ContinueExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ContinueExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ContinueExpr<'a> = ContinueExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ContinueExprNode<R1>> for ContinueExprNode<R2> {\n+    fn eq(&self, other: &ContinueExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ContinueExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ContinueExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ContinueExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -518,12 +648,20 @@ impl<R: TreeRoot<RaTypes>> ContinueExprNode<R> {\n impl<'a> ContinueExpr<'a> {}\n \n // DynTraitType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct DynTraitTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type DynTraitType<'a> = DynTraitTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<DynTraitTypeNode<R1>> for DynTraitTypeNode<R2> {\n+    fn eq(&self, other: &DynTraitTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for DynTraitTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for DynTraitTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for DynTraitType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -547,12 +685,20 @@ impl<R: TreeRoot<RaTypes>> DynTraitTypeNode<R> {\n impl<'a> DynTraitType<'a> {}\n \n // EnumDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct EnumDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type EnumDef<'a> = EnumDefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<EnumDefNode<R1>> for EnumDefNode<R2> {\n+    fn eq(&self, other: &EnumDefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for EnumDefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for EnumDefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for EnumDef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -579,7 +725,7 @@ impl<'a> ast::AttrsOwner<'a> for EnumDef<'a> {}\n impl<'a> EnumDef<'a> {}\n \n // Expr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Expr<'a> {\n     TupleExpr(TupleExpr<'a>),\n     ArrayExpr(ArrayExpr<'a>),\n@@ -694,12 +840,20 @@ impl<'a> AstNode<'a> for Expr<'a> {\n impl<'a> Expr<'a> {}\n \n // ExprStmt\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ExprStmtNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ExprStmt<'a> = ExprStmtNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ExprStmtNode<R1>> for ExprStmtNode<R2> {\n+    fn eq(&self, other: &ExprStmtNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ExprStmtNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ExprStmtNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ExprStmt<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -727,12 +881,20 @@ impl<'a> ExprStmt<'a> {\n }\n \n // ExternCrateItem\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ExternCrateItemNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ExternCrateItem<'a> = ExternCrateItemNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ExternCrateItemNode<R1>> for ExternCrateItemNode<R2> {\n+    fn eq(&self, other: &ExternCrateItemNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ExternCrateItemNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ExternCrateItemNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ExternCrateItem<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -756,12 +918,20 @@ impl<R: TreeRoot<RaTypes>> ExternCrateItemNode<R> {\n impl<'a> ExternCrateItem<'a> {}\n \n // FieldExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct FieldExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type FieldExpr<'a> = FieldExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<FieldExprNode<R1>> for FieldExprNode<R2> {\n+    fn eq(&self, other: &FieldExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for FieldExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for FieldExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for FieldExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -785,12 +955,20 @@ impl<R: TreeRoot<RaTypes>> FieldExprNode<R> {\n impl<'a> FieldExpr<'a> {}\n \n // FieldPatList\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct FieldPatListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type FieldPatList<'a> = FieldPatListNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<FieldPatListNode<R1>> for FieldPatListNode<R2> {\n+    fn eq(&self, other: &FieldPatListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for FieldPatListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for FieldPatListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for FieldPatList<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -814,12 +992,20 @@ impl<R: TreeRoot<RaTypes>> FieldPatListNode<R> {\n impl<'a> FieldPatList<'a> {}\n \n // FnDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct FnDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type FnDef<'a> = FnDefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<FnDefNode<R1>> for FnDefNode<R2> {\n+    fn eq(&self, other: &FnDefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for FnDefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for FnDefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for FnDef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -859,12 +1045,20 @@ impl<'a> FnDef<'a> {\n }\n \n // FnPointerType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct FnPointerTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type FnPointerType<'a> = FnPointerTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<FnPointerTypeNode<R1>> for FnPointerTypeNode<R2> {\n+    fn eq(&self, other: &FnPointerTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for FnPointerTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for FnPointerTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for FnPointerType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -888,12 +1082,20 @@ impl<R: TreeRoot<RaTypes>> FnPointerTypeNode<R> {\n impl<'a> FnPointerType<'a> {}\n \n // ForExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ForExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ForExpr<'a> = ForExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ForExprNode<R1>> for ForExprNode<R2> {\n+    fn eq(&self, other: &ForExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ForExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ForExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ForExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -926,12 +1128,20 @@ impl<'a> ForExpr<'a> {\n }\n \n // ForType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ForTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ForType<'a> = ForTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ForTypeNode<R1>> for ForTypeNode<R2> {\n+    fn eq(&self, other: &ForTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ForTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ForTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ForType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -955,12 +1165,20 @@ impl<R: TreeRoot<RaTypes>> ForTypeNode<R> {\n impl<'a> ForType<'a> {}\n \n // IfExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct IfExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type IfExpr<'a> = IfExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<IfExprNode<R1>> for IfExprNode<R2> {\n+    fn eq(&self, other: &IfExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for IfExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for IfExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for IfExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -988,12 +1206,20 @@ impl<'a> IfExpr<'a> {\n }\n \n // ImplItem\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ImplItemNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ImplItem<'a> = ImplItemNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ImplItemNode<R1>> for ImplItemNode<R2> {\n+    fn eq(&self, other: &ImplItemNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ImplItemNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ImplItemNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ImplItem<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1017,12 +1243,20 @@ impl<R: TreeRoot<RaTypes>> ImplItemNode<R> {\n impl<'a> ImplItem<'a> {}\n \n // ImplTraitType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ImplTraitTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ImplTraitType<'a> = ImplTraitTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ImplTraitTypeNode<R1>> for ImplTraitTypeNode<R2> {\n+    fn eq(&self, other: &ImplTraitTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ImplTraitTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ImplTraitTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ImplTraitType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1046,12 +1280,20 @@ impl<R: TreeRoot<RaTypes>> ImplTraitTypeNode<R> {\n impl<'a> ImplTraitType<'a> {}\n \n // IndexExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct IndexExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type IndexExpr<'a> = IndexExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<IndexExprNode<R1>> for IndexExprNode<R2> {\n+    fn eq(&self, other: &IndexExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for IndexExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for IndexExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for IndexExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1075,12 +1317,20 @@ impl<R: TreeRoot<RaTypes>> IndexExprNode<R> {\n impl<'a> IndexExpr<'a> {}\n \n // ItemList\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ItemListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ItemList<'a> = ItemListNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ItemListNode<R1>> for ItemListNode<R2> {\n+    fn eq(&self, other: &ItemListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ItemListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ItemListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ItemList<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1106,12 +1356,20 @@ impl<'a> ast::ModuleItemOwner<'a> for ItemList<'a> {}\n impl<'a> ItemList<'a> {}\n \n // Label\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct LabelNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Label<'a> = LabelNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LabelNode<R1>> for LabelNode<R2> {\n+    fn eq(&self, other: &LabelNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for LabelNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for LabelNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Label<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1135,12 +1393,20 @@ impl<R: TreeRoot<RaTypes>> LabelNode<R> {\n impl<'a> Label<'a> {}\n \n // LambdaExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct LambdaExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type LambdaExpr<'a> = LambdaExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LambdaExprNode<R1>> for LambdaExprNode<R2> {\n+    fn eq(&self, other: &LambdaExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for LambdaExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for LambdaExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for LambdaExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1172,12 +1438,20 @@ impl<'a> LambdaExpr<'a> {\n }\n \n // LetStmt\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct LetStmtNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type LetStmt<'a> = LetStmtNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LetStmtNode<R1>> for LetStmtNode<R2> {\n+    fn eq(&self, other: &LetStmtNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for LetStmtNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for LetStmtNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for LetStmt<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1209,12 +1483,20 @@ impl<'a> LetStmt<'a> {\n }\n \n // Lifetime\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct LifetimeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Lifetime<'a> = LifetimeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LifetimeNode<R1>> for LifetimeNode<R2> {\n+    fn eq(&self, other: &LifetimeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for LifetimeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for LifetimeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Lifetime<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1238,12 +1520,20 @@ impl<R: TreeRoot<RaTypes>> LifetimeNode<R> {\n impl<'a> Lifetime<'a> {}\n \n // LifetimeParam\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct LifetimeParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type LifetimeParam<'a> = LifetimeParamNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LifetimeParamNode<R1>> for LifetimeParamNode<R2> {\n+    fn eq(&self, other: &LifetimeParamNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for LifetimeParamNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for LifetimeParamNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for LifetimeParam<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1271,12 +1561,20 @@ impl<'a> LifetimeParam<'a> {\n }\n \n // Literal\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct LiteralNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Literal<'a> = LiteralNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LiteralNode<R1>> for LiteralNode<R2> {\n+    fn eq(&self, other: &LiteralNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for LiteralNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for LiteralNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Literal<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1300,12 +1598,20 @@ impl<R: TreeRoot<RaTypes>> LiteralNode<R> {\n impl<'a> Literal<'a> {}\n \n // LoopExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct LoopExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type LoopExpr<'a> = LoopExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<LoopExprNode<R1>> for LoopExprNode<R2> {\n+    fn eq(&self, other: &LoopExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for LoopExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for LoopExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for LoopExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1330,12 +1636,20 @@ impl<'a> ast::LoopBodyOwner<'a> for LoopExpr<'a> {}\n impl<'a> LoopExpr<'a> {}\n \n // MatchArm\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct MatchArmNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type MatchArm<'a> = MatchArmNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MatchArmNode<R1>> for MatchArmNode<R2> {\n+    fn eq(&self, other: &MatchArmNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for MatchArmNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for MatchArmNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for MatchArm<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1371,12 +1685,20 @@ impl<'a> MatchArm<'a> {\n }\n \n // MatchArmList\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct MatchArmListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type MatchArmList<'a> = MatchArmListNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MatchArmListNode<R1>> for MatchArmListNode<R2> {\n+    fn eq(&self, other: &MatchArmListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for MatchArmListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for MatchArmListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for MatchArmList<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1404,12 +1726,20 @@ impl<'a> MatchArmList<'a> {\n }\n \n // MatchExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct MatchExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type MatchExpr<'a> = MatchExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MatchExprNode<R1>> for MatchExprNode<R2> {\n+    fn eq(&self, other: &MatchExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for MatchExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for MatchExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for MatchExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1441,12 +1771,20 @@ impl<'a> MatchExpr<'a> {\n }\n \n // MatchGuard\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct MatchGuardNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type MatchGuard<'a> = MatchGuardNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MatchGuardNode<R1>> for MatchGuardNode<R2> {\n+    fn eq(&self, other: &MatchGuardNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for MatchGuardNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for MatchGuardNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for MatchGuard<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1470,12 +1808,20 @@ impl<R: TreeRoot<RaTypes>> MatchGuardNode<R> {\n impl<'a> MatchGuard<'a> {}\n \n // MethodCallExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct MethodCallExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type MethodCallExpr<'a> = MethodCallExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<MethodCallExprNode<R1>> for MethodCallExprNode<R2> {\n+    fn eq(&self, other: &MethodCallExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for MethodCallExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for MethodCallExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for MethodCallExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1504,12 +1850,20 @@ impl<'a> MethodCallExpr<'a> {\n }\n \n // Module\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ModuleNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Module<'a> = ModuleNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ModuleNode<R1>> for ModuleNode<R2> {\n+    fn eq(&self, other: &ModuleNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ModuleNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ModuleNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Module<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1539,7 +1893,7 @@ impl<'a> Module<'a> {\n }\n \n // ModuleItem\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum ModuleItem<'a> {\n     StructDef(StructDef<'a>),\n     EnumDef(EnumDef<'a>),\n@@ -1591,12 +1945,20 @@ impl<'a> AstNode<'a> for ModuleItem<'a> {\n impl<'a> ModuleItem<'a> {}\n \n // Name\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct NameNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Name<'a> = NameNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NameNode<R1>> for NameNode<R2> {\n+    fn eq(&self, other: &NameNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for NameNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for NameNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Name<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1620,12 +1982,20 @@ impl<R: TreeRoot<RaTypes>> NameNode<R> {\n impl<'a> Name<'a> {}\n \n // NameRef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct NameRefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type NameRef<'a> = NameRefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NameRefNode<R1>> for NameRefNode<R2> {\n+    fn eq(&self, other: &NameRefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for NameRefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for NameRefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for NameRef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1649,12 +2019,20 @@ impl<R: TreeRoot<RaTypes>> NameRefNode<R> {\n impl<'a> NameRef<'a> {}\n \n // NamedField\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct NamedFieldNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type NamedField<'a> = NamedFieldNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NamedFieldNode<R1>> for NamedFieldNode<R2> {\n+    fn eq(&self, other: &NamedFieldNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for NamedFieldNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for NamedFieldNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for NamedField<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1678,12 +2056,20 @@ impl<R: TreeRoot<RaTypes>> NamedFieldNode<R> {\n impl<'a> NamedField<'a> {}\n \n // NamedFieldDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct NamedFieldDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type NamedFieldDef<'a> = NamedFieldDefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NamedFieldDefNode<R1>> for NamedFieldDefNode<R2> {\n+    fn eq(&self, other: &NamedFieldDefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for NamedFieldDefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for NamedFieldDefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for NamedFieldDef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1709,12 +2095,20 @@ impl<'a> ast::AttrsOwner<'a> for NamedFieldDef<'a> {}\n impl<'a> NamedFieldDef<'a> {}\n \n // NamedFieldList\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct NamedFieldListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type NamedFieldList<'a> = NamedFieldListNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NamedFieldListNode<R1>> for NamedFieldListNode<R2> {\n+    fn eq(&self, other: &NamedFieldListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for NamedFieldListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for NamedFieldListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for NamedFieldList<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1738,12 +2132,20 @@ impl<R: TreeRoot<RaTypes>> NamedFieldListNode<R> {\n impl<'a> NamedFieldList<'a> {}\n \n // NeverType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct NeverTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type NeverType<'a> = NeverTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NeverTypeNode<R1>> for NeverTypeNode<R2> {\n+    fn eq(&self, other: &NeverTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for NeverTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for NeverTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for NeverType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1767,7 +2169,7 @@ impl<R: TreeRoot<RaTypes>> NeverTypeNode<R> {\n impl<'a> NeverType<'a> {}\n \n // NominalDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum NominalDef<'a> {\n     StructDef(StructDef<'a>),\n     EnumDef(EnumDef<'a>),\n@@ -1795,12 +2197,20 @@ impl<'a> ast::AttrsOwner<'a> for NominalDef<'a> {}\n impl<'a> NominalDef<'a> {}\n \n // Param\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Param<'a> = ParamNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ParamNode<R1>> for ParamNode<R2> {\n+    fn eq(&self, other: &ParamNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ParamNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ParamNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Param<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1828,12 +2238,20 @@ impl<'a> Param<'a> {\n }\n \n // ParamList\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ParamListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ParamList<'a> = ParamListNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ParamListNode<R1>> for ParamListNode<R2> {\n+    fn eq(&self, other: &ParamListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ParamListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ParamListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ParamList<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1865,12 +2283,20 @@ impl<'a> ParamList<'a> {\n }\n \n // ParenExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ParenExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ParenExpr<'a> = ParenExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ParenExprNode<R1>> for ParenExprNode<R2> {\n+    fn eq(&self, other: &ParenExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ParenExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ParenExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ParenExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1894,12 +2320,20 @@ impl<R: TreeRoot<RaTypes>> ParenExprNode<R> {\n impl<'a> ParenExpr<'a> {}\n \n // ParenType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ParenTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ParenType<'a> = ParenTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ParenTypeNode<R1>> for ParenTypeNode<R2> {\n+    fn eq(&self, other: &ParenTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ParenTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ParenTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ParenType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -1923,7 +2357,7 @@ impl<R: TreeRoot<RaTypes>> ParenTypeNode<R> {\n impl<'a> ParenType<'a> {}\n \n // Pat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Pat<'a> {\n     RefPat(RefPat<'a>),\n     BindPat(BindPat<'a>),\n@@ -1972,12 +2406,20 @@ impl<'a> AstNode<'a> for Pat<'a> {\n impl<'a> Pat<'a> {}\n \n // Path\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PathNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Path<'a> = PathNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathNode<R1>> for PathNode<R2> {\n+    fn eq(&self, other: &PathNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PathNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PathNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Path<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2009,12 +2451,20 @@ impl<'a> Path<'a> {\n }\n \n // PathExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PathExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type PathExpr<'a> = PathExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathExprNode<R1>> for PathExprNode<R2> {\n+    fn eq(&self, other: &PathExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PathExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PathExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for PathExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2042,12 +2492,20 @@ impl<'a> PathExpr<'a> {\n }\n \n // PathPat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PathPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type PathPat<'a> = PathPatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathPatNode<R1>> for PathPatNode<R2> {\n+    fn eq(&self, other: &PathPatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PathPatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PathPatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for PathPat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2071,12 +2529,20 @@ impl<R: TreeRoot<RaTypes>> PathPatNode<R> {\n impl<'a> PathPat<'a> {}\n \n // PathSegment\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PathSegmentNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type PathSegment<'a> = PathSegmentNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathSegmentNode<R1>> for PathSegmentNode<R2> {\n+    fn eq(&self, other: &PathSegmentNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PathSegmentNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PathSegmentNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for PathSegment<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2104,12 +2570,20 @@ impl<'a> PathSegment<'a> {\n }\n \n // PathType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PathTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type PathType<'a> = PathTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PathTypeNode<R1>> for PathTypeNode<R2> {\n+    fn eq(&self, other: &PathTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PathTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PathTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for PathType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2133,12 +2607,20 @@ impl<R: TreeRoot<RaTypes>> PathTypeNode<R> {\n impl<'a> PathType<'a> {}\n \n // PlaceholderPat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PlaceholderPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type PlaceholderPat<'a> = PlaceholderPatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PlaceholderPatNode<R1>> for PlaceholderPatNode<R2> {\n+    fn eq(&self, other: &PlaceholderPatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PlaceholderPatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PlaceholderPatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for PlaceholderPat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2162,12 +2644,20 @@ impl<R: TreeRoot<RaTypes>> PlaceholderPatNode<R> {\n impl<'a> PlaceholderPat<'a> {}\n \n // PlaceholderType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PlaceholderTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type PlaceholderType<'a> = PlaceholderTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PlaceholderTypeNode<R1>> for PlaceholderTypeNode<R2> {\n+    fn eq(&self, other: &PlaceholderTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PlaceholderTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PlaceholderTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for PlaceholderType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2191,12 +2681,20 @@ impl<R: TreeRoot<RaTypes>> PlaceholderTypeNode<R> {\n impl<'a> PlaceholderType<'a> {}\n \n // PointerType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PointerTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type PointerType<'a> = PointerTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PointerTypeNode<R1>> for PointerTypeNode<R2> {\n+    fn eq(&self, other: &PointerTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PointerTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PointerTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for PointerType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2220,12 +2718,20 @@ impl<R: TreeRoot<RaTypes>> PointerTypeNode<R> {\n impl<'a> PointerType<'a> {}\n \n // PrefixExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct PrefixExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type PrefixExpr<'a> = PrefixExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PrefixExprNode<R1>> for PrefixExprNode<R2> {\n+    fn eq(&self, other: &PrefixExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PrefixExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PrefixExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for PrefixExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2249,12 +2755,20 @@ impl<R: TreeRoot<RaTypes>> PrefixExprNode<R> {\n impl<'a> PrefixExpr<'a> {}\n \n // RangeExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct RangeExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type RangeExpr<'a> = RangeExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RangeExprNode<R1>> for RangeExprNode<R2> {\n+    fn eq(&self, other: &RangeExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for RangeExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for RangeExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for RangeExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2278,12 +2792,20 @@ impl<R: TreeRoot<RaTypes>> RangeExprNode<R> {\n impl<'a> RangeExpr<'a> {}\n \n // RangePat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct RangePatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type RangePat<'a> = RangePatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RangePatNode<R1>> for RangePatNode<R2> {\n+    fn eq(&self, other: &RangePatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for RangePatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for RangePatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for RangePat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2307,12 +2829,20 @@ impl<R: TreeRoot<RaTypes>> RangePatNode<R> {\n impl<'a> RangePat<'a> {}\n \n // RefExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct RefExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type RefExpr<'a> = RefExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RefExprNode<R1>> for RefExprNode<R2> {\n+    fn eq(&self, other: &RefExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for RefExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for RefExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for RefExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2336,12 +2866,20 @@ impl<R: TreeRoot<RaTypes>> RefExprNode<R> {\n impl<'a> RefExpr<'a> {}\n \n // RefPat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct RefPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type RefPat<'a> = RefPatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RefPatNode<R1>> for RefPatNode<R2> {\n+    fn eq(&self, other: &RefPatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for RefPatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for RefPatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for RefPat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2365,12 +2903,20 @@ impl<R: TreeRoot<RaTypes>> RefPatNode<R> {\n impl<'a> RefPat<'a> {}\n \n // ReferenceType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ReferenceTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ReferenceType<'a> = ReferenceTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ReferenceTypeNode<R1>> for ReferenceTypeNode<R2> {\n+    fn eq(&self, other: &ReferenceTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ReferenceTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ReferenceTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ReferenceType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2394,12 +2940,20 @@ impl<R: TreeRoot<RaTypes>> ReferenceTypeNode<R> {\n impl<'a> ReferenceType<'a> {}\n \n // RetType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct RetTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type RetType<'a> = RetTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RetTypeNode<R1>> for RetTypeNode<R2> {\n+    fn eq(&self, other: &RetTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for RetTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for RetTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for RetType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2423,12 +2977,20 @@ impl<R: TreeRoot<RaTypes>> RetTypeNode<R> {\n impl<'a> RetType<'a> {}\n \n // ReturnExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct ReturnExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type ReturnExpr<'a> = ReturnExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ReturnExprNode<R1>> for ReturnExprNode<R2> {\n+    fn eq(&self, other: &ReturnExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ReturnExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ReturnExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for ReturnExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2452,12 +3014,20 @@ impl<R: TreeRoot<RaTypes>> ReturnExprNode<R> {\n impl<'a> ReturnExpr<'a> {}\n \n // Root\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct RootNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Root<'a> = RootNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<RootNode<R1>> for RootNode<R2> {\n+    fn eq(&self, other: &RootNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for RootNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for RootNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Root<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2487,12 +3057,20 @@ impl<'a> Root<'a> {\n }\n \n // SelfParam\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct SelfParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type SelfParam<'a> = SelfParamNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<SelfParamNode<R1>> for SelfParamNode<R2> {\n+    fn eq(&self, other: &SelfParamNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for SelfParamNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for SelfParamNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for SelfParam<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2516,12 +3094,20 @@ impl<R: TreeRoot<RaTypes>> SelfParamNode<R> {\n impl<'a> SelfParam<'a> {}\n \n // SlicePat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct SlicePatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type SlicePat<'a> = SlicePatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<SlicePatNode<R1>> for SlicePatNode<R2> {\n+    fn eq(&self, other: &SlicePatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for SlicePatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for SlicePatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for SlicePat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2545,12 +3131,20 @@ impl<R: TreeRoot<RaTypes>> SlicePatNode<R> {\n impl<'a> SlicePat<'a> {}\n \n // SliceType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct SliceTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type SliceType<'a> = SliceTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<SliceTypeNode<R1>> for SliceTypeNode<R2> {\n+    fn eq(&self, other: &SliceTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for SliceTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for SliceTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for SliceType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2574,12 +3168,20 @@ impl<R: TreeRoot<RaTypes>> SliceTypeNode<R> {\n impl<'a> SliceType<'a> {}\n \n // StaticDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct StaticDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type StaticDef<'a> = StaticDefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StaticDefNode<R1>> for StaticDefNode<R2> {\n+    fn eq(&self, other: &StaticDefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for StaticDefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for StaticDefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for StaticDef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2606,7 +3208,7 @@ impl<'a> ast::AttrsOwner<'a> for StaticDef<'a> {}\n impl<'a> StaticDef<'a> {}\n \n // Stmt\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Stmt<'a> {\n     ExprStmt(ExprStmt<'a>),\n     LetStmt(LetStmt<'a>),\n@@ -2631,12 +3233,20 @@ impl<'a> AstNode<'a> for Stmt<'a> {\n impl<'a> Stmt<'a> {}\n \n // StructDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct StructDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type StructDef<'a> = StructDefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StructDefNode<R1>> for StructDefNode<R2> {\n+    fn eq(&self, other: &StructDefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for StructDefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for StructDefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for StructDef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2667,12 +3277,20 @@ impl<'a> StructDef<'a> {\n }\n \n // StructLit\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct StructLitNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type StructLit<'a> = StructLitNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StructLitNode<R1>> for StructLitNode<R2> {\n+    fn eq(&self, other: &StructLitNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for StructLitNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for StructLitNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for StructLit<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2696,12 +3314,20 @@ impl<R: TreeRoot<RaTypes>> StructLitNode<R> {\n impl<'a> StructLit<'a> {}\n \n // StructPat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct StructPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type StructPat<'a> = StructPatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<StructPatNode<R1>> for StructPatNode<R2> {\n+    fn eq(&self, other: &StructPatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for StructPatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for StructPatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for StructPat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2725,12 +3351,20 @@ impl<R: TreeRoot<RaTypes>> StructPatNode<R> {\n impl<'a> StructPat<'a> {}\n \n // TokenTree\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TokenTreeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TokenTree<'a> = TokenTreeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TokenTreeNode<R1>> for TokenTreeNode<R2> {\n+    fn eq(&self, other: &TokenTreeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TokenTreeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TokenTreeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TokenTree<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2754,12 +3388,20 @@ impl<R: TreeRoot<RaTypes>> TokenTreeNode<R> {\n impl<'a> TokenTree<'a> {}\n \n // TraitDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TraitDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TraitDef<'a> = TraitDefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TraitDefNode<R1>> for TraitDefNode<R2> {\n+    fn eq(&self, other: &TraitDefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TraitDefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TraitDefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TraitDef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2785,12 +3427,20 @@ impl<'a> ast::AttrsOwner<'a> for TraitDef<'a> {}\n impl<'a> TraitDef<'a> {}\n \n // TryExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TryExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TryExpr<'a> = TryExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TryExprNode<R1>> for TryExprNode<R2> {\n+    fn eq(&self, other: &TryExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TryExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TryExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TryExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2814,12 +3464,20 @@ impl<R: TreeRoot<RaTypes>> TryExprNode<R> {\n impl<'a> TryExpr<'a> {}\n \n // TupleExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TupleExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TupleExpr<'a> = TupleExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TupleExprNode<R1>> for TupleExprNode<R2> {\n+    fn eq(&self, other: &TupleExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TupleExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TupleExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TupleExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2843,12 +3501,20 @@ impl<R: TreeRoot<RaTypes>> TupleExprNode<R> {\n impl<'a> TupleExpr<'a> {}\n \n // TuplePat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TuplePatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TuplePat<'a> = TuplePatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TuplePatNode<R1>> for TuplePatNode<R2> {\n+    fn eq(&self, other: &TuplePatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TuplePatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TuplePatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TuplePat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2872,12 +3538,20 @@ impl<R: TreeRoot<RaTypes>> TuplePatNode<R> {\n impl<'a> TuplePat<'a> {}\n \n // TupleStructPat\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TupleStructPatNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TupleStructPat<'a> = TupleStructPatNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TupleStructPatNode<R1>> for TupleStructPatNode<R2> {\n+    fn eq(&self, other: &TupleStructPatNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TupleStructPatNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TupleStructPatNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TupleStructPat<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2901,12 +3575,20 @@ impl<R: TreeRoot<RaTypes>> TupleStructPatNode<R> {\n impl<'a> TupleStructPat<'a> {}\n \n // TupleType\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TupleTypeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TupleType<'a> = TupleTypeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TupleTypeNode<R1>> for TupleTypeNode<R2> {\n+    fn eq(&self, other: &TupleTypeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TupleTypeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TupleTypeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TupleType<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2930,12 +3612,20 @@ impl<R: TreeRoot<RaTypes>> TupleTypeNode<R> {\n impl<'a> TupleType<'a> {}\n \n // TypeDef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TypeDefNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TypeDef<'a> = TypeDefNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TypeDefNode<R1>> for TypeDefNode<R2> {\n+    fn eq(&self, other: &TypeDefNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TypeDefNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TypeDefNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TypeDef<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2962,12 +3652,20 @@ impl<'a> ast::AttrsOwner<'a> for TypeDef<'a> {}\n impl<'a> TypeDef<'a> {}\n \n // TypeParam\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TypeParamNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TypeParam<'a> = TypeParamNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TypeParamNode<R1>> for TypeParamNode<R2> {\n+    fn eq(&self, other: &TypeParamNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TypeParamNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TypeParamNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TypeParam<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -2992,12 +3690,20 @@ impl<'a> ast::NameOwner<'a> for TypeParam<'a> {}\n impl<'a> TypeParam<'a> {}\n \n // TypeParamList\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct TypeParamListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type TypeParamList<'a> = TypeParamListNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<TypeParamListNode<R1>> for TypeParamListNode<R2> {\n+    fn eq(&self, other: &TypeParamListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for TypeParamListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for TypeParamListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for TypeParamList<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -3029,7 +3735,7 @@ impl<'a> TypeParamList<'a> {\n }\n \n // TypeRef\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum TypeRef<'a> {\n     ParenType(ParenType<'a>),\n     TupleType(TupleType<'a>),\n@@ -3087,12 +3793,20 @@ impl<'a> AstNode<'a> for TypeRef<'a> {\n impl<'a> TypeRef<'a> {}\n \n // UseItem\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct UseItemNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type UseItem<'a> = UseItemNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<UseItemNode<R1>> for UseItemNode<R2> {\n+    fn eq(&self, other: &UseItemNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for UseItemNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for UseItemNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for UseItem<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -3120,12 +3834,20 @@ impl<'a> UseItem<'a> {\n }\n \n // UseTree\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct UseTreeNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type UseTree<'a> = UseTreeNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<UseTreeNode<R1>> for UseTreeNode<R2> {\n+    fn eq(&self, other: &UseTreeNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for UseTreeNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for UseTreeNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for UseTree<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -3157,12 +3879,20 @@ impl<'a> UseTree<'a> {\n }\n \n // UseTreeList\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct UseTreeListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type UseTreeList<'a> = UseTreeListNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<UseTreeListNode<R1>> for UseTreeListNode<R2> {\n+    fn eq(&self, other: &UseTreeListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for UseTreeListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for UseTreeListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for UseTreeList<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -3190,12 +3920,20 @@ impl<'a> UseTreeList<'a> {\n }\n \n // WhereClause\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct WhereClauseNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type WhereClause<'a> = WhereClauseNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<WhereClauseNode<R1>> for WhereClauseNode<R2> {\n+    fn eq(&self, other: &WhereClauseNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for WhereClauseNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for WhereClauseNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for WhereClause<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -3219,12 +3957,20 @@ impl<R: TreeRoot<RaTypes>> WhereClauseNode<R> {\n impl<'a> WhereClause<'a> {}\n \n // WhileExpr\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct WhileExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type WhileExpr<'a> = WhileExprNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<WhileExprNode<R1>> for WhileExprNode<R2> {\n+    fn eq(&self, other: &WhileExprNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for WhileExprNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for WhileExprNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for WhileExpr<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {\n@@ -3253,12 +3999,20 @@ impl<'a> WhileExpr<'a> {\n }\n \n // Whitespace\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct WhitespaceNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type Whitespace<'a> = WhitespaceNode<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<WhitespaceNode<R1>> for WhitespaceNode<R2> {\n+    fn eq(&self, other: &WhitespaceNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for WhitespaceNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for WhitespaceNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for Whitespace<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {"}, {"sha": "131ee09ecb5646baf280833ed0e02ca880ac08a3", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=ed1feb72dc8ca8521a3258b0fad3b4ee446f418b", "patch": "@@ -11,6 +11,8 @@ the below applies to the result of this template\n \n #![cfg_attr(rustfmt, rustfmt_skip)]\n \n+use std::hash::{Hash, Hasher};\n+\n use crate::{\n     ast,\n     SyntaxNode, SyntaxNodeRef, AstNode,\n@@ -21,7 +23,7 @@ use crate::{\n // {{ node }}\n \n {%- if methods.enum %}\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum {{ node }}<'a> {\n {%- for kind in methods.enum %}\n     {{ kind }}({{ kind }}<'a>),\n@@ -46,12 +48,20 @@ impl<'a> AstNode<'a> for {{ node }}<'a> {\n     }\n }\n {% else %}\n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy,)]\n pub struct {{ node }}Node<R: TreeRoot<RaTypes> = OwnedRoot> {\n-    syntax: SyntaxNode<R>,\n+    pub(crate) syntax: SyntaxNode<R>,\n }\n pub type {{ node }}<'a> = {{ node }}Node<RefRoot<'a>>;\n \n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<{{node}}Node<R1>> for {{node}}Node<R2> {\n+    fn eq(&self, other: &{{node}}Node<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for {{node}}Node<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for {{node}}Node<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n impl<'a> AstNode<'a> for {{ node }}<'a> {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n         match syntax.kind() {"}, {"sha": "aa172ba42e310f2f376cf16db601c31c45e3beb6", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=ed1feb72dc8ca8521a3258b0fad3b4ee446f418b", "patch": "@@ -60,19 +60,18 @@ pub use crate::{\n \n use crate::yellow::GreenNode;\n \n+// TODO: pick a single name for everything. SourceFile maybe?\n /// File represents a parse tree for a single Rust file.\n-#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub struct File {\n-    root: SyntaxNode,\n-}\n+pub type File = ast::RootNode;\n \n impl File {\n     fn new(green: GreenNode, errors: Vec<SyntaxError>) -> File {\n         let root = SyntaxNode::new(green, errors);\n         if cfg!(debug_assertions) {\n             utils::validate_block_structure(root.borrowed());\n         }\n-        File { root }\n+        assert_eq!(root.kind(), SyntaxKind::ROOT);\n+        ast::RootNode { syntax: root }\n     }\n     pub fn parse(text: &str) -> File {\n         let tokens = tokenize(&text);\n@@ -95,14 +94,14 @@ impl File {\n     }\n     /// Typed AST representation of the parse tree.\n     pub fn ast(&self) -> ast::Root {\n-        ast::Root::cast(self.syntax()).unwrap()\n+        self.borrowed()\n     }\n     /// Untyped homogeneous representation of the parse tree.\n     pub fn syntax(&self) -> SyntaxNodeRef {\n-        self.root.borrowed()\n+        self.syntax.borrowed()\n     }\n     pub fn errors(&self) -> Vec<SyntaxError> {\n-        let mut errors = self.root.root_data().clone();\n+        let mut errors = self.syntax.root_data().clone();\n         errors.extend(validation::validate(self));\n         errors\n     }"}, {"sha": "2b26e388ddea4ea219c264403a4a2bc8ec74d597", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed1feb72dc8ca8521a3258b0fad3b4ee446f418b/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=ed1feb72dc8ca8521a3258b0fad3b4ee446f418b", "patch": "@@ -11,7 +11,7 @@ use crate::{\n \n pub(crate) fn validate(file: &File) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();\n-    for node in file.root.borrowed().descendants() {\n+    for node in file.syntax().descendants() {\n         let _ = visitor_ctx(&mut errors)\n             .visit::<ast::Char, _>(validate_char)\n             .accept(node);"}]}