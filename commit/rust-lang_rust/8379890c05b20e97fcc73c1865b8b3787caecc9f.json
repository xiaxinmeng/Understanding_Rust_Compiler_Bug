{"sha": "8379890c05b20e97fcc73c1865b8b3787caecc9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNzk4OTBjMDViMjBlOTdmY2M3M2MxODY1YjhiMzc4N2NhZWNjOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-09T16:36:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-09T16:36:09Z"}, "message": "auto merge of #10153 : nikomatsakis/rust/issue-4846-multiple-lifetime-parameters-7, r=pnkfelix\n\nFully support multiple lifetime parameters on types and elsewhere, removing special treatment for `'self`. I am submitting this a touch early in that I plan to push a new commit with more tests specifically targeting types with multiple lifetime parameters -- but the current code bootstraps and passes `make check`.\r\n\r\nFixes #4846", "tree": {"sha": "7e5bc81204faeedbe059224616a837e8378ab5a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e5bc81204faeedbe059224616a837e8378ab5a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8379890c05b20e97fcc73c1865b8b3787caecc9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8379890c05b20e97fcc73c1865b8b3787caecc9f", "html_url": "https://github.com/rust-lang/rust/commit/8379890c05b20e97fcc73c1865b8b3787caecc9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8379890c05b20e97fcc73c1865b8b3787caecc9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d", "html_url": "https://github.com/rust-lang/rust/commit/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d"}, {"sha": "f6e8d49a1a3cd67933c7efebfe7a0c55470049f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e8d49a1a3cd67933c7efebfe7a0c55470049f3", "html_url": "https://github.com/rust-lang/rust/commit/f6e8d49a1a3cd67933c7efebfe7a0c55470049f3"}], "stats": {"total": 8630, "additions": 5025, "deletions": 3605}, "files": [{"sha": "f5bb3cb2ed00fcdacc16ea594ac04f11a60d005c", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -125,6 +125,7 @@ ifdef TRACE\n   CFG_RUSTC_FLAGS += -Z trace\n endif\n ifndef DEBUG_BORROWS\n+  RUSTFLAGS_STAGE0 += -Z no-debug-borrows\n   RUSTFLAGS_STAGE1 += -Z no-debug-borrows\n   RUSTFLAGS_STAGE2 += -Z no-debug-borrows\n endif"}, {"sha": "b3da9b4f16b889f270f1dacedb061d120bc2018e", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -233,10 +233,10 @@ impl<T:Send> MutexArc<T> {\n \n     /// As unsafe_access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline]\n-    pub unsafe fn unsafe_access_cond<'x, 'c, U>(&self,\n-                                         blk: &fn(x: &'x mut T,\n-                                                  c: &'c Condvar) -> U)\n-                                         -> U {\n+    pub unsafe fn unsafe_access_cond<U>(&self,\n+                                        blk: &fn(x: &mut T,\n+                                                 c: &Condvar) -> U)\n+                                        -> U {\n         let state = self.x.get();\n         do (&(*state).lock).lock_cond |cond| {\n             check_poison(true, (*state).failed);\n@@ -290,10 +290,10 @@ impl<T:Freeze + Send> MutexArc<T> {\n \n     /// As unsafe_access_cond but safe and Freeze.\n     #[inline]\n-    pub fn access_cond<'x, 'c, U>(&self,\n-                                  blk: &fn(x: &'x mut T,\n-                                           c: &'c Condvar) -> U)\n-                                  -> U {\n+    pub fn access_cond<U>(&self,\n+                          blk: &fn(x: &mut T,\n+                                   c: &Condvar) -> U)\n+                          -> U {\n         unsafe { self.unsafe_access_cond(blk) }\n     }\n }\n@@ -402,9 +402,9 @@ impl<T:Freeze + Send> RWArc<T> {\n \n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline]\n-    pub fn write_cond<'x, 'c, U>(&self,\n-                                 blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n-                                 -> U {\n+    pub fn write_cond<U>(&self,\n+                         blk: &fn(x: &mut T, c: &Condvar) -> U)\n+                         -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write_cond |cond| {\n@@ -554,9 +554,9 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n     }\n \n     /// Access the pre-downgrade RWArc in write mode with a condvar.\n-    pub fn write_cond<'x, 'c, U>(&mut self,\n-                                 blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n-                                 -> U {\n+    pub fn write_cond<U>(&mut self,\n+                         blk: &fn(x: &mut T, c: &Condvar) -> U)\n+                         -> U {\n         match *self {\n             RWWriteMode {\n                 data: &ref mut data,"}, {"sha": "6346e4856f2d1a57a310f3e96cfb7ffb96751df9", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -239,20 +239,20 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         time(time_passes, \"resolution\", (), |_|\n              middle::resolve::resolve_crate(sess, lang_items, crate));\n \n+    let named_region_map = time(time_passes, \"lifetime resolution\", (),\n+                                |_| middle::resolve_lifetime::crate(sess, crate));\n+\n     time(time_passes, \"looking for entry point\", (),\n          |_| middle::entry::find_entry_point(sess, crate, ast_map));\n \n     let freevars = time(time_passes, \"freevar finding\", (), |_|\n                         freevars::annotate_freevars(def_map, crate));\n \n     let region_map = time(time_passes, \"region resolution\", (), |_|\n-                          middle::region::resolve_crate(sess, def_map, crate));\n-\n-    let rp_set = time(time_passes, \"region parameterization inference\", (), |_|\n-                      middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n+                          middle::region::resolve_crate(sess, crate));\n \n-    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                            region_map, rp_set, lang_items);\n+    let ty_cx = ty::mk_ctxt(sess, def_map, named_region_map, ast_map, freevars,\n+                            region_map, lang_items);\n \n     // passes are timed inside typeck\n     let (method_map, vtable_map) = typeck::check_crate("}, {"sha": "c2d0251b23cc21d3a490cb128702734129ae777f", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -116,12 +116,12 @@ impl fold::ast_fold for StandardLibraryInjector {\n             segments: ~[\n                 ast::PathSegment {\n                     identifier: self.sess.ident_of(\"std\"),\n-                    lifetime: None,\n+                    lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n                 },\n                 ast::PathSegment {\n                     identifier: self.sess.ident_of(\"prelude\"),\n-                    lifetime: None,\n+                    lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n                 },\n             ],"}, {"sha": "b6ae41833777a8626d46514acb71df1f02d47405", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -343,7 +343,7 @@ fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n         global: false,\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetime: None,\n+            lifetimes: opt_vec::Empty,\n             types: opt_vec::Empty,\n         }).collect()\n     }\n@@ -355,7 +355,7 @@ fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n         global: true,\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetime: None,\n+            lifetimes: opt_vec::Empty,\n             types: opt_vec::Empty,\n         }).collect()\n     }"}, {"sha": "8d273e638ee734fe61b63626e5291a05cc1c34b0", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -54,8 +54,10 @@ use syntax::diagnostic;\n pub mod middle {\n     pub mod trans;\n     pub mod ty;\n+    pub mod ty_fold;\n     pub mod subst;\n     pub mod resolve;\n+    pub mod resolve_lifetime;\n     pub mod typeck;\n     pub mod check_loop;\n     pub mod check_match;"}, {"sha": "5e6d0f276152341c3f282e6583a3ac6649f86f4b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -89,7 +89,7 @@ pub static tag_path_elt_name: uint = 0x43u;\n pub static tag_item_field: uint = 0x44u;\n pub static tag_struct_mut: uint = 0x45u;\n \n-pub static tag_region_param: uint = 0x46u;\n+pub static tag_item_variances: uint = 0x46;\n pub static tag_mod_impl_trait: uint = 0x47u;\n /*\n   trait items contain tag_item_trait_method elements,\n@@ -193,6 +193,11 @@ pub static tag_path_elt_pretty_name: uint = 0x87;\n pub static tag_path_elt_pretty_name_ident: uint = 0x88;\n pub static tag_path_elt_pretty_name_extra: uint = 0x89;\n \n+pub static tag_region_param_def: uint = 0x100;\n+pub static tag_region_param_def_ident: uint = 0x101;\n+pub static tag_region_param_def_def_id: uint = 0x102;\n+\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "fdda6b38462e32228f9b9f9a5174720f2149c2f6", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -14,7 +14,6 @@\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n-use metadata;\n use middle::ty;\n use middle::typeck;\n \n@@ -144,6 +143,12 @@ pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n+pub fn get_item_variances(cstore: @mut cstore::CStore,\n+                          def: ast::DefId) -> ty::ItemVariances {\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_item_variances(cdata, def.node)\n+}\n+\n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n                                   def: ast::DefId)\n                                -> ~[@ty::Method] {\n@@ -199,12 +204,6 @@ pub fn get_trait_def(tcx: ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n     decoder::get_trait_def(cdata, def.node, tcx)\n }\n \n-pub fn get_region_param(cstore: @mut metadata::cstore::CStore,\n-                        def: ast::DefId) -> Option<ty::region_variance> {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    return decoder::get_region_param(cdata, def.node);\n-}\n-\n pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n@@ -224,7 +223,7 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: @~[],\n-                                region_param: None},\n+                                region_param_defs: @[]},\n         ty: ty\n     }\n }"}, {"sha": "b63d9320bd6e0c816d2b799e44d3eafe157cad3d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -25,7 +25,7 @@ use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n-\n+use std::at_vec;\n use std::u64;\n use std::rt::io;\n use std::rt::io::extensions::u64_from_be_bytes;\n@@ -252,9 +252,11 @@ fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: Cmd,\n+fn item_ty_param_defs(item: ebml::Doc,\n+                      tcx: ty::ctxt,\n+                      cdata: Cmd,\n                       tag: uint)\n-    -> @~[ty::TypeParameterDef] {\n+                      -> @~[ty::TypeParameterDef] {\n     let mut bounds = ~[];\n     do reader::tagged_docs(item, tag) |p| {\n         let bd = parse_type_param_def_data(\n@@ -266,10 +268,23 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: Cmd,\n     @bounds\n }\n \n-fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n-    do reader::maybe_get_doc(item, tag_region_param).map |doc| {\n-        let mut decoder = reader::Decoder(doc);\n-        Decodable::decode(&mut decoder)\n+fn item_region_param_defs(item_doc: ebml::Doc,\n+                          tcx: ty::ctxt,\n+                          cdata: Cmd)\n+                          -> @[ty::RegionParameterDef] {\n+    do at_vec::build(None) |push| {\n+        do reader::tagged_docs(item_doc, tag_region_param_def) |rp_doc| {\n+            let ident_str_doc = reader::get_doc(rp_doc,\n+                                                tag_region_param_def_ident);\n+            let ident = item_name(tcx.sess.intr(), ident_str_doc);\n+            let def_id_doc = reader::get_doc(rp_doc,\n+                                             tag_region_param_def_def_id);\n+            let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n+            let def_id = translate_def_id(cdata, def_id);\n+            push(ty::RegionParameterDef { ident: ident,\n+                                          def_id: def_id });\n+            true\n+        };\n     }\n }\n \n@@ -393,7 +408,7 @@ pub fn get_trait_def(cdata: Cmd,\n     let item_doc = lookup_item(item_id, cdata.data);\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n                                      tag_items_data_item_ty_param_bounds);\n-    let rp = item_ty_region_param(item_doc);\n+    let rp_defs = item_region_param_defs(item_doc, tcx, cdata);\n     let mut bounds = ty::EmptyBuiltinBounds();\n     // Collect the builtin bounds from the encoded supertraits.\n     // FIXME(#8559): They should be encoded directly.\n@@ -407,7 +422,7 @@ pub fn get_trait_def(cdata: Cmd,\n     };\n     ty::TraitDef {\n         generics: ty::Generics {type_param_defs: tp_defs,\n-                                region_param: rp},\n+                                region_param_defs: rp_defs},\n         bounds: bounds,\n         trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n     }\n@@ -417,33 +432,27 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data);\n+\n     let t = item_type(ast::DefId { crate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n-    let tp_defs = if family_has_type_params(item_family(item)) {\n-        item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds)\n-    } else { @~[] };\n-    let rp = item_ty_region_param(item);\n+\n+    let tp_defs = item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds);\n+    let rp_defs = item_region_param_defs(item, tcx, cdata);\n+\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: tp_defs,\n-                                region_param: rp},\n+                                region_param_defs: rp_defs},\n         ty: t\n     }\n }\n \n-pub fn get_region_param(cdata: Cmd, id: ast::NodeId)\n-    -> Option<ty::region_variance> {\n-\n-    let item = lookup_item(id, cdata.data);\n-    return item_ty_region_param(item);\n-}\n-\n pub fn get_type_param_count(data: @~[u8], id: ast::NodeId) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n pub fn get_impl_trait(cdata: Cmd,\n-                       id: ast::NodeId,\n-                       tcx: ty::ctxt) -> Option<@ty::TraitRef>\n+                      id: ast::NodeId,\n+                      tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n     do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map |tp| {\n@@ -1044,6 +1053,7 @@ pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n     let name = item_name(intr, method_doc);\n     let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n                                              tag_item_method_tps);\n+    let rp_defs = item_region_param_defs(method_doc, tcx, cdata);\n     let transformed_self_ty = doc_transformed_self_ty(method_doc, tcx, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n     let vis = item_visibility(method_doc);\n@@ -1054,7 +1064,7 @@ pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n         name,\n         ty::Generics {\n             type_param_defs: type_param_defs,\n-            region_param: None\n+            region_param_defs: rp_defs,\n         },\n         transformed_self_ty,\n         fty,\n@@ -1078,6 +1088,14 @@ pub fn get_trait_method_def_ids(cdata: Cmd,\n     result\n }\n \n+pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n+    let data = cdata.data;\n+    let item_doc = lookup_item(id, data);\n+    let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n+    let mut decoder = reader::Decoder(variance_doc);\n+    Decodable::decode(&mut decoder)\n+}\n+\n pub fn get_provided_trait_methods(intr: @ident_interner, cdata: Cmd,\n                                   id: ast::NodeId, tcx: ty::ctxt) ->\n         ~[@ty::Method] {"}, {"sha": "fe9ca6a16f0c2714e730723b1b6bfa85149a7cca", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -121,17 +121,6 @@ pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: DefId) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: &EncodeContext,\n-                       ebml_w: &mut writer::Encoder,\n-                       it: @ast::item) {\n-    let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n-    for rp in opt_rp.iter() {\n-        ebml_w.start_tag(tag_region_param);\n-        rp.encode(ebml_w);\n-        ebml_w.end_tag();\n-    }\n-}\n-\n #[deriving(Clone)]\n struct entry<T> {\n     val: T,\n@@ -205,11 +194,38 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n     }\n }\n \n+fn encode_region_param_defs(ebml_w: &mut writer::Encoder,\n+                            ecx: &EncodeContext,\n+                            params: @[ty::RegionParameterDef]) {\n+    for param in params.iter() {\n+        ebml_w.start_tag(tag_region_param_def);\n+\n+        ebml_w.start_tag(tag_region_param_def_ident);\n+        encode_name(ecx, ebml_w, param.ident);\n+        ebml_w.end_tag();\n+\n+        ebml_w.wr_tagged_str(tag_region_param_def_def_id,\n+                             def_to_str(param.def_id));\n+\n+        ebml_w.end_tag();\n+    }\n+}\n+\n+fn encode_item_variances(ebml_w: &mut writer::Encoder,\n+                         ecx: &EncodeContext,\n+                         id: ast::NodeId) {\n+    let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n+    ebml_w.start_tag(tag_item_variances);\n+    v.encode(ebml_w);\n+    ebml_w.end_tag();\n+}\n+\n fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n                           ecx: &EncodeContext,\n                           tpt: &ty::ty_param_bounds_and_ty) {\n     encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs,\n                               tag_items_data_item_ty_param_bounds);\n+    encode_region_param_defs(ebml_w, ecx, tpt.generics.region_param_defs);\n     encode_type(ecx, ebml_w, tpt.ty);\n }\n \n@@ -976,7 +992,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ecx, ebml_w, item);\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n@@ -986,6 +1001,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 't');\n+        encode_item_variances(ebml_w, ecx, item.id);\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -994,7 +1010,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ecx, ebml_w, item);\n \n         // Encode inherent implementations for this enumeration.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1027,10 +1042,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 'S');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n \n+        encode_item_variances(ebml_w, ecx, item.id);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ecx, ebml_w, item);\n         encode_visibility(ebml_w, vis);\n \n         /* Encode def_ids for each field and method\n@@ -1075,7 +1090,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'i');\n-        encode_region_param(ecx, ebml_w, item);\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -1135,7 +1149,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'I');\n-        encode_region_param(ecx, ebml_w, item);\n+        encode_item_variances(ebml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_ty_type_param_defs(ebml_w, ecx,\n                                   trait_def.generics.type_param_defs,"}, {"sha": "31561e730d541b0d3c51b160e260332536131016", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 80, "deletions": 59, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -48,7 +48,10 @@ pub enum DefIdSource {\n     TypeWithId,\n \n     // Identifies a type parameter (`fn foo<X>() { ... }`).\n-    TypeParameter\n+    TypeParameter,\n+\n+    // Identifies a region parameter (`fn foo<'X>() { ... }`).\n+    RegionParameter,\n }\n type conv_did<'self> =\n     &'self fn(source: DefIdSource, ast::DefId) -> ast::DefId;\n@@ -143,7 +146,7 @@ fn parse_path(st: &mut PState) -> @ast::Path {\n                     segments: idents.move_iter().map(|identifier| {\n                         ast::PathSegment {\n                             identifier: identifier,\n-                            lifetime: None,\n+                            lifetimes: opt_vec::Empty,\n                             types: opt_vec::Empty,\n                         }\n                     }).collect()\n@@ -165,7 +168,7 @@ fn parse_sigil(st: &mut PState) -> ast::Sigil {\n     }\n }\n \n-fn parse_vstore(st: &mut PState) -> ty::vstore {\n+fn parse_vstore(st: &mut PState, conv: conv_did) -> ty::vstore {\n     assert_eq!(next(st), '/');\n \n     let c = peek(st);\n@@ -178,22 +181,22 @@ fn parse_vstore(st: &mut PState) -> ty::vstore {\n     match next(st) {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n-      '&' => ty::vstore_slice(parse_region(st)),\n+      '&' => ty::vstore_slice(parse_region(st, conv)),\n       c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n     }\n }\n \n-fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n+fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n         '@' => ty::BoxTraitStore,\n-        '&' => ty::RegionTraitStore(parse_region(st)),\n+        '&' => ty::RegionTraitStore(parse_region(st, conv)),\n         c => st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\", c))\n     }\n }\n \n fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n-    let regions = parse_region_substs(st);\n+    let regions = parse_region_substs(st, |x,y| conv(x,y));\n \n     let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n \n@@ -209,13 +212,13 @@ fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n     };\n }\n \n-fn parse_region_substs(st: &mut PState) -> ty::RegionSubsts {\n+fn parse_region_substs(st: &mut PState, conv: conv_did) -> ty::RegionSubsts {\n     match next(st) {\n         'e' => ty::ErasedRegions,\n         'n' => {\n             let mut regions = opt_vec::Empty;\n             while peek(st) != '.' {\n-                let r = parse_region(st);\n+                let r = parse_region(st, |x,y| conv(x,y));\n                 regions.push(r);\n             }\n             assert_eq!(next(st), '.');\n@@ -225,48 +228,65 @@ fn parse_region_substs(st: &mut PState) -> ty::RegionSubsts {\n     }\n }\n \n-fn parse_bound_region(st: &mut PState) -> ty::bound_region {\n+fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n     match next(st) {\n-      's' => ty::br_self,\n-      'a' => {\n-        let id = parse_uint(st);\n-        assert_eq!(next(st), '|');\n-        ty::br_anon(id)\n-      }\n-      '[' => ty::br_named(st.tcx.sess.ident_of(parse_str(st, ']'))),\n-      'c' => {\n-        let id = parse_uint(st) as int;\n-        assert_eq!(next(st), '|');\n-        ty::br_cap_avoid(id, @parse_bound_region(st))\n-      },\n-      _ => fail!(\"parse_bound_region: bad input\")\n+        'a' => {\n+            let id = parse_uint(st);\n+            assert_eq!(next(st), '|');\n+            ty::BrAnon(id)\n+        }\n+        '[' => {\n+            let def = parse_def(st, RegionParameter, |x,y| conv(x,y));\n+            let ident = st.tcx.sess.ident_of(parse_str(st, ']'));\n+            ty::BrNamed(def, ident)\n+        }\n+        'f' => {\n+            let id = parse_uint(st);\n+            assert_eq!(next(st), '|');\n+            ty::BrFresh(id)\n+        }\n+        _ => fail!(\"parse_bound_region: bad input\")\n     }\n }\n \n-fn parse_region(st: &mut PState) -> ty::Region {\n+fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     match next(st) {\n       'b' => {\n-        ty::re_bound(parse_bound_region(st))\n+        assert_eq!(next(st), '[');\n+        let id = parse_uint(st) as int;\n+        assert_eq!(next(st), '|');\n+        let br = parse_bound_region(st, |x,y| conv(x,y));\n+        assert_eq!(next(st), ']');\n+        ty::ReLateBound(id, br)\n+      }\n+      'B' => {\n+        assert_eq!(next(st), '[');\n+        let node_id = parse_uint(st) as int;\n+        assert_eq!(next(st), '|');\n+        let index = parse_uint(st);\n+        assert_eq!(next(st), '|');\n+        let nm = st.tcx.sess.ident_of(parse_str(st, ']'));\n+        ty::ReEarlyBound(node_id, index, nm)\n       }\n       'f' => {\n         assert_eq!(next(st), '[');\n         let id = parse_uint(st) as int;\n         assert_eq!(next(st), '|');\n-        let br = parse_bound_region(st);\n+        let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        ty::re_free(ty::FreeRegion {scope_id: id,\n+        ty::ReFree(ty::FreeRegion {scope_id: id,\n                                     bound_region: br})\n       }\n       's' => {\n         let id = parse_uint(st) as int;\n         assert_eq!(next(st), '|');\n-        ty::re_scope(id)\n+        ty::ReScope(id)\n       }\n       't' => {\n-        ty::re_static\n+        ty::ReStatic\n       }\n       'e' => {\n-        ty::re_static\n+        ty::ReStatic\n       }\n       _ => fail!(\"parse_region: bad input\")\n     }\n@@ -331,37 +351,37 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         assert_eq!(next(st), '[');\n         let def = parse_def(st, NominalType, |x,y| conv(x,y));\n         let substs = parse_substs(st, |x,y| conv(x,y));\n-        let store = parse_trait_store(st);\n+        let store = parse_trait_store(st, |x,y| conv(x,y));\n         let mt = parse_mutability(st);\n         let bounds = parse_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_trait(st.tcx, def, substs, store, mt, bounds.builtin_bounds);\n       }\n       'p' => {\n-        let did = parse_def(st, TypeParameter, conv);\n+        let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n         debug!(\"parsed ty_param: did={:?}\", did);\n         return ty::mk_param(st.tcx, parse_uint(st), did);\n       }\n       's' => {\n-        let did = parse_def(st, TypeParameter, conv);\n+        let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n         return ty::mk_self(st.tcx, did);\n       }\n-      '@' => return ty::mk_box(st.tcx, parse_mt(st, conv)),\n-      '~' => return ty::mk_uniq(st.tcx, parse_mt(st, conv)),\n-      '*' => return ty::mk_ptr(st.tcx, parse_mt(st, conv)),\n+      '@' => return ty::mk_box(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n+      '~' => return ty::mk_uniq(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n+      '*' => return ty::mk_ptr(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n       '&' => {\n-        let r = parse_region(st);\n-        let mt = parse_mt(st, conv);\n+        let r = parse_region(st, |x,y| conv(x,y));\n+        let mt = parse_mt(st, |x,y| conv(x,y));\n         return ty::mk_rptr(st.tcx, r, mt);\n       }\n-      'U' => return ty::mk_unboxed_vec(st.tcx, parse_mt(st, conv)),\n+      'U' => return ty::mk_unboxed_vec(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n       'V' => {\n-        let mt = parse_mt(st, conv);\n-        let v = parse_vstore(st);\n+        let mt = parse_mt(st, |x,y| conv(x,y));\n+        let v = parse_vstore(st, |x,y| conv(x,y));\n         return ty::mk_evec(st.tcx, mt, v);\n       }\n       'v' => {\n-        let v = parse_vstore(st);\n+        let v = parse_vstore(st, |x,y| conv(x,y));\n         return ty::mk_estr(st.tcx, v);\n       }\n       'T' => {\n@@ -372,10 +392,10 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_tup(st.tcx, params);\n       }\n       'f' => {\n-        return ty::mk_closure(st.tcx, parse_closure_ty(st, conv));\n+        return ty::mk_closure(st.tcx, parse_closure_ty(st, |x,y| conv(x,y)));\n       }\n       'F' => {\n-        return ty::mk_bare_fn(st.tcx, parse_bare_fn_ty(st, conv));\n+        return ty::mk_bare_fn(st.tcx, parse_bare_fn_ty(st, |x,y| conv(x,y)));\n       }\n       'Y' => return ty::mk_type(st.tcx),\n       'C' => {\n@@ -397,7 +417,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n                 pos: pos,\n                 .. *st\n             };\n-            let tt = parse_ty(&mut ps, conv);\n+            let tt = parse_ty(&mut ps, |x,y| conv(x,y));\n             st.tcx.rcache.insert(key, tt);\n             return tt;\n           }\n@@ -429,7 +449,7 @@ fn parse_mutability(st: &mut PState) -> ast::Mutability {\n \n fn parse_mt(st: &mut PState, conv: conv_did) -> ty::mt {\n     let m = parse_mutability(st);\n-    ty::mt { ty: parse_ty(st, conv), mutbl: m }\n+    ty::mt { ty: parse_ty(st, |x,y| conv(x,y)), mutbl: m }\n }\n \n fn parse_def(st: &mut PState, source: DefIdSource,\n@@ -495,7 +515,7 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let sigil = parse_sigil(st);\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n-    let region = parse_region(st);\n+    let region = parse_region(st, |x,y| conv(x,y));\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::ClosureTy {\n@@ -511,7 +531,7 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n     let purity = parse_purity(next(st));\n     let abi = parse_abi_set(st);\n-    let sig = parse_sig(st, conv);\n+    let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::BareFnTy {\n         purity: purity,\n         abis: abi,\n@@ -521,22 +541,23 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n \n fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n+    let id = parse_uint(st) as int;\n+    assert_eq!(next(st), '|');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n         inputs.push(parse_ty(st, |x,y| conv(x,y)));\n     }\n     st.pos += 1u; // eat the ']'\n-    let variadic = if peek(st) == 'A' {\n-        st.pos += 1; // eat the 'A'\n-        true\n-    } else { false };\n-    let ret_ty = parse_ty(st, conv);\n-    ty::FnSig {\n-        bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n-        inputs: inputs,\n-        output: ret_ty,\n-        variadic: variadic\n-    }\n+    let variadic = match next(st) {\n+        'V' => true,\n+        'N' => false,\n+        r => fail!(format!(\"Bad variadic: {}\", r)),\n+    };\n+    let ret_ty = parse_ty(st, |x,y| conv(x,y));\n+    ty::FnSig {binder_id: id,\n+               inputs: inputs,\n+               output: ret_ty,\n+               variadic: variadic}\n }\n \n // Rust metadata parsing"}, {"sha": "d304db0935ac5452902eb8addc75765bd0fe341e", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -155,35 +155,51 @@ fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n \n fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n     match r {\n-        ty::re_bound(br) => {\n-            mywrite!(w, \"b\");\n+        ty::ReLateBound(id, br) => {\n+            mywrite!(w, \"b[{}|\", id);\n             enc_bound_region(w, cx, br);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::ReEarlyBound(node_id, index, ident) => {\n+            mywrite!(w, \"B[{}|{}|{}]\",\n+                     node_id,\n+                     index,\n+                     cx.tcx.sess.str_of(ident));\n         }\n-        ty::re_free(ref fr) => {\n+        ty::ReFree(ref fr) => {\n             mywrite!(w, \"f[{}|\", fr.scope_id);\n             enc_bound_region(w, cx, fr.bound_region);\n             mywrite!(w, \"]\");\n         }\n-        ty::re_scope(nid) => mywrite!(w, \"s{}|\", nid),\n-        ty::re_static => mywrite!(w, \"t\"),\n-        ty::re_empty => mywrite!(w, \"e\"),\n-        ty::re_infer(_) => {\n+        ty::ReScope(nid) => {\n+            mywrite!(w, \"s{}|\", nid);\n+        }\n+        ty::ReStatic => {\n+            mywrite!(w, \"t\");\n+        }\n+        ty::ReEmpty => {\n+            mywrite!(w, \"e\");\n+        }\n+        ty::ReInfer(_) => {\n             // these should not crop up after typeck\n             cx.diag.handler().bug(\"Cannot encode region variables\");\n         }\n     }\n }\n \n-fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::bound_region) {\n+fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n     match br {\n-        ty::br_self => mywrite!(w, \"s\"),\n-        ty::br_anon(idx) => mywrite!(w, \"a{}|\", idx),\n-        ty::br_named(s) => mywrite!(w, \"[{}]\", cx.tcx.sess.str_of(s)),\n-        ty::br_cap_avoid(id, br) => {\n-            mywrite!(w, \"c{}|\", id);\n-            enc_bound_region(w, cx, *br);\n-        }\n-        ty::br_fresh(id) => mywrite!(w, \"{}\", id),\n+        ty::BrAnon(idx) => {\n+            mywrite!(w, \"a{}|\", idx);\n+        }\n+        ty::BrNamed(d, s) => {\n+            mywrite!(w, \"[{}|{}]\",\n+                     (cx.ds)(d),\n+                     cx.tcx.sess.str_of(s));\n+        }\n+        ty::BrFresh(id) => {\n+            mywrite!(w, \"f{}|\", id);\n+        }\n     }\n }\n \n@@ -366,13 +382,15 @@ fn enc_closure_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n }\n \n fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n-    mywrite!(w, \"[\");\n+    mywrite!(w, \"[{}|\", fsig.binder_id);\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }\n     mywrite!(w, \"]\");\n     if fsig.variadic {\n-        mywrite!(w, \"A\");\n+        mywrite!(w, \"V\");\n+    } else {\n+        mywrite!(w, \"N\");\n     }\n     enc_ty(w, cx, fsig.output);\n }"}, {"sha": "09c0951b9e3c5b44aada56b1d8ef217da969d3a3", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -15,7 +15,8 @@ use driver::session::Session;\n use e = metadata::encoder;\n use metadata::decoder;\n use metadata::tydecode;\n-use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n+use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n+                         RegionParameter};\n use metadata::tyencode;\n use middle::freevars::freevar_entry;\n use middle::typeck::{method_origin, method_map_entry};\n@@ -234,6 +235,12 @@ impl tr for ast::DefId {\n     }\n }\n \n+impl tr for Option<ast::DefId> {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> Option<ast::DefId> {\n+        self.map(|d| xcx.tr_def_id(d))\n+    }\n+}\n+\n impl tr for Span {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> Span {\n         xcx.tr_span(*self)\n@@ -469,24 +476,28 @@ impl tr for ty::AutoRef {\n impl tr for ty::Region {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::Region {\n         match *self {\n-            ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n-            ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n-            ty::re_empty | ty::re_static | ty::re_infer(*) => *self,\n-            ty::re_free(ref fr) => {\n-                ty::re_free(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n+            ty::ReLateBound(id, br) => ty::ReLateBound(xcx.tr_id(id),\n+                                                       br.tr(xcx)),\n+            ty::ReEarlyBound(id, index, ident) => ty::ReEarlyBound(xcx.tr_id(id),\n+                                                                     index,\n+                                                                     ident),\n+            ty::ReScope(id) => ty::ReScope(xcx.tr_id(id)),\n+            ty::ReEmpty | ty::ReStatic | ty::ReInfer(*) => *self,\n+            ty::ReFree(ref fr) => {\n+                ty::ReFree(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n                                             bound_region: fr.bound_region.tr(xcx)})\n             }\n         }\n     }\n }\n \n-impl tr for ty::bound_region {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::bound_region {\n+impl tr for ty::BoundRegion {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::BoundRegion {\n         match *self {\n-            ty::br_anon(_) | ty::br_named(_) | ty::br_self |\n-            ty::br_fresh(_) => *self,\n-            ty::br_cap_avoid(id, br) => ty::br_cap_avoid(xcx.tr_id(id),\n-                                                         @br.tr(xcx))\n+            ty::BrAnon(_) |\n+            ty::BrFresh(_) => *self,\n+            ty::BrNamed(id, ident) => ty::BrNamed(xcx.tr_def_id(id),\n+                                                    ident),\n         }\n     }\n }\n@@ -821,8 +832,8 @@ impl ebml_writer_helpers for writer::Encoder {\n                             this.emit_type_param_def(ecx, type_param_def);\n                         }\n                     }\n-                    do this.emit_struct_field(\"region_param\", 1) |this| {\n-                        tpbt.generics.region_param.encode(this);\n+                    do this.emit_struct_field(\"region_param_defs\", 1) |this| {\n+                        tpbt.generics.region_param_defs.encode(this);\n                     }\n                 }\n             }\n@@ -1086,17 +1097,15 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         // are not used during trans.\n \n         return do self.read_opaque |this, doc| {\n+            debug!(\"read_ty({})\", type_string(doc));\n+\n             let ty = tydecode::parse_ty_data(\n                 *doc.data,\n                 xcx.dcx.cdata.cnum,\n                 doc.start,\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n-            debug!(\"read_ty({}) = {}\",\n-                   type_string(doc),\n-                   ty_to_str(xcx.dcx.tcx, ty));\n-\n             ty\n         };\n \n@@ -1139,8 +1148,8 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                                     @this.read_to_vec(|this|\n                                         this.read_type_param_def(xcx))\n                             }),\n-                            region_param:\n-                                this.read_struct_field(\"region_param\",\n+                            region_param_defs:\n+                                this.read_struct_field(\"region_param_defs\",\n                                                        1,\n                                                        |this| {\n                                     Decodable::decode(this)\n@@ -1161,7 +1170,6 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                       did: ast::DefId)\n                       -> ast::DefId {\n         /*!\n-         *\n          * Converts a def-id that appears in a type.  The correct\n          * translation will depend on what kind of def-id this is.\n          * This is a subtle point: type definitions are not\n@@ -1172,10 +1180,25 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n          * However, *type parameters* are cloned along with the function\n          * they are attached to.  So we should translate those def-ids\n          * to refer to the new, cloned copy of the type parameter.\n+         * We only see references to free type parameters in the body of\n+         * an inlined function. In such cases, we need the def-id to\n+         * be a local id so that the TypeContents code is able to lookup\n+         * the relevant info in the ty_param_defs table.\n+         *\n+         * *Region parameters*, unfortunately, are another kettle of fish.\n+         * In such cases, def_id's can appear in types to distinguish\n+         * shadowed bound regions and so forth. It doesn't actually\n+         * matter so much what we do to these, since regions are erased\n+         * at trans time, but it's good to keep them consistent just in\n+         * case. We translate them with `tr_def_id()` which will map\n+         * the crate numbers back to the original source crate.\n+         *\n+         * It'd be really nice to refactor the type repr to not include\n+         * def-ids so that all these distinctions were unnecessary.\n          */\n \n         let r = match source {\n-            NominalType | TypeWithId => xcx.tr_def_id(did),\n+            NominalType | TypeWithId | RegionParameter => xcx.tr_def_id(did),\n             TypeParameter => xcx.tr_intern_def_id(did)\n         };\n         debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);"}, {"sha": "a5f1709058c4645456a94835e21d312e80f41f7e", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -199,7 +199,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n \n         // Make sure that the loan does not exceed the maximum time\n         // that we can root the value, dynamically.\n-        let root_region = ty::re_scope(self.root_scope_id);\n+        let root_region = ty::ReScope(self.root_scope_id);\n         if !self.bccx.is_subregion_of(self.loan_region, root_region) {\n             self.report_error(\n                 err_out_of_root_scope(root_region, self.loan_region));\n@@ -208,9 +208,9 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n \n         // Extract the scope id that indicates how long the rooting is required\n         let root_scope = match self.loan_region {\n-            ty::re_scope(id) => id,\n+            ty::ReScope(id) => id,\n             _ => {\n-                // the check above should fail for anything is not re_scope\n+                // the check above should fail for anything is not ReScope\n                 self.bccx.tcx.sess.span_bug(\n                     cmt_base.span,\n                     format!(\"Cannot issue root for scope region: {:?}\",\n@@ -260,12 +260,12 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                 note_and_explain_region(\n                     self.bccx.tcx,\n                     \"managed value only needs to be frozen for \",\n-                    ty::re_scope(root_scope),\n+                    ty::ReScope(root_scope),\n                     \"...\");\n                 note_and_explain_region(\n                     self.bccx.tcx,\n                     \"...but due to Issue #6248, it will be frozen for \",\n-                    ty::re_scope(cleanup_scope),\n+                    ty::ReScope(cleanup_scope),\n                     \"\");\n             }\n \n@@ -324,21 +324,21 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n \n         match cmt.cat {\n             mc::cat_rvalue(cleanup_scope_id) => {\n-                ty::re_scope(cleanup_scope_id)\n+                ty::ReScope(cleanup_scope_id)\n             }\n             mc::cat_copied_upvar(_) => {\n-                ty::re_scope(self.item_scope_id)\n+                ty::ReScope(self.item_scope_id)\n             }\n             mc::cat_static_item => {\n-                ty::re_static\n+                ty::ReStatic\n             }\n             mc::cat_local(local_id) |\n             mc::cat_arg(local_id) |\n             mc::cat_self(local_id) => {\n                 self.bccx.tcx.region_maps.encl_region(local_id)\n             }\n             mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n-                ty::re_static\n+                ty::ReStatic\n             }\n             mc::cat_deref(_, _, mc::region_ptr(_, r)) => {\n                 r"}, {"sha": "56c3417852299811b44c69689168502b25e242c7", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -277,7 +277,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n           // Currently these do not use adjustments, so we have to\n           // hardcode this check here (note that the receiver DOES use\n           // adjustments).\n-          let scope_r = ty::re_scope(ex.id);\n+          let scope_r = ty::ReScope(ex.id);\n           let arg_cmt = this.bccx.cat_expr(arg);\n           this.guarantee_valid(arg.id,\n                                arg.span,\n@@ -441,7 +441,7 @@ impl<'self> GatherLoanCtxt<'self> {\n \n         // a loan for the empty region can never be dereferenced, so\n         // it is always safe\n-        if loan_region == ty::re_empty {\n+        if loan_region == ty::ReEmpty {\n             return;\n         }\n \n@@ -470,10 +470,10 @@ impl<'self> GatherLoanCtxt<'self> {\n \n             restrictions::SafeIf(loan_path, restrictions) => {\n                 let loan_scope = match loan_region {\n-                    ty::re_scope(id) => id,\n-                    ty::re_free(ref fr) => fr.scope_id,\n+                    ty::ReScope(id) => id,\n+                    ty::ReFree(ref fr) => fr.scope_id,\n \n-                    ty::re_static => {\n+                    ty::ReStatic => {\n                         // If we get here, an error must have been\n                         // reported in\n                         // `lifetime::guarantee_lifetime()`, because\n@@ -485,9 +485,10 @@ impl<'self> GatherLoanCtxt<'self> {\n                         return;\n                     }\n \n-                    ty::re_empty |\n-                    ty::re_bound(*) |\n-                    ty::re_infer(*) => {\n+                    ty::ReEmpty |\n+                    ty::ReLateBound(*) |\n+                    ty::ReEarlyBound(*) |\n+                    ty::ReInfer(*) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             format!(\"Invalid borrow lifetime: {:?}\", loan_region));\n@@ -714,7 +715,7 @@ impl<'self> GatherLoanCtxt<'self> {\n                     let cmt_discr = match arm_match_ids {\n                         None => cmt,\n                         Some((arm_id, match_id)) => {\n-                            let arm_scope = ty::re_scope(arm_id);\n+                            let arm_scope = ty::ReScope(arm_id);\n                             if self.bccx.is_subregion_of(scope_r, arm_scope) {\n                                 self.bccx.cat_discr(cmt, match_id)\n                             } else {"}, {"sha": "a570160ce95720051f7853c46b48b32ad7897520", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -540,12 +540,12 @@ pub fn check_cast_for_escaping_regions(\n                 target_regions.push(r);\n             }\n         },\n-        |_| true);\n+        |_| ());\n \n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item).\n-    if target_regions.iter().any(|r| is_re_scope(*r)) {\n+    if target_regions.iter().any(|r| is_ReScope(*r)) {\n         return; /* case (1) */\n     }\n \n@@ -582,12 +582,11 @@ pub fn check_cast_for_escaping_regions(\n                 }\n                 _ => {}\n             }\n-            true\n         });\n \n-    fn is_re_scope(r: ty::Region) -> bool {\n+    fn is_ReScope(r: ty::Region) -> bool {\n         match r {\n-            ty::re_scope(*) => true,\n+            ty::ReScope(*) => true,\n             _ => false\n         }\n     }"}, {"sha": "eeedd25adac28d5f23bd04d6bde3df977d40665c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -781,7 +781,7 @@ impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n                                 debug!(\"privacy - list {}\", pid.node.id);\n                                 let seg = ast::PathSegment {\n                                     identifier: pid.node.name,\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 };\n                                 let segs = ~[seg];"}, {"sha": "32ac6ff549213ba06eda1bfcb7dbc854ef23ed67", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 490, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -22,22 +22,14 @@ Most of the documentation on regions can be found in\n \n \n use driver::session::Session;\n-use metadata::csearch;\n-use middle::resolve;\n-use middle::ty::{region_variance, rv_covariant, rv_invariant};\n-use middle::ty::{rv_contravariant, FreeRegion};\n+use middle::ty::{FreeRegion};\n use middle::ty;\n \n use std::hashmap::{HashMap, HashSet};\n-use syntax::ast_map;\n use syntax::codemap::Span;\n-use syntax::print::pprust;\n-use syntax::parse::token;\n-use syntax::parse::token::special_idents;\n use syntax::{ast, visit};\n use syntax::visit::{Visitor,fn_kind};\n use syntax::ast::{Block,item,fn_decl,NodeId,Arm,Pat,Stmt,Expr,Local};\n-use syntax::ast::{Ty,TypeMethod,struct_field};\n \n /**\n The region maps encode information about region relationships.\n@@ -74,7 +66,6 @@ pub struct Context {\n \n struct RegionResolutionVisitor {\n     sess: Session,\n-    def_map: resolve::DefMap,\n \n     // Generated maps:\n     region_maps: @mut RegionMaps,\n@@ -146,7 +137,7 @@ impl RegionMaps {\n     pub fn encl_region(&self, id: ast::NodeId) -> ty::Region {\n         //! Returns the narrowest scope region that encloses `id`, if any.\n \n-        ty::re_scope(self.encl_scope(id))\n+        ty::ReScope(self.encl_scope(id))\n     }\n \n     pub fn scopes_intersect(&self, scope1: ast::NodeId, scope2: ast::NodeId)\n@@ -236,19 +227,19 @@ impl RegionMaps {\n \n         sub_region == super_region || {\n             match (sub_region, super_region) {\n-                (_, ty::re_static) => {\n+                (_, ty::ReStatic) => {\n                     true\n                 }\n \n-                (ty::re_scope(sub_scope), ty::re_scope(super_scope)) => {\n+                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) => {\n                     self.is_subscope_of(sub_scope, super_scope)\n                 }\n \n-                (ty::re_scope(sub_scope), ty::re_free(ref fr)) => {\n+                (ty::ReScope(sub_scope), ty::ReFree(ref fr)) => {\n                     self.is_subscope_of(sub_scope, fr.scope_id)\n                 }\n \n-                (ty::re_free(sub_fr), ty::re_free(super_fr)) => {\n+                (ty::ReFree(sub_fr), ty::ReFree(super_fr)) => {\n                     self.sub_free_region(sub_fr, super_fr)\n                 }\n \n@@ -504,7 +495,6 @@ impl Visitor<Context> for RegionResolutionVisitor {\n }\n \n pub fn resolve_crate(sess: Session,\n-                     def_map: resolve::DefMap,\n                      crate: &ast::Crate) -> @mut RegionMaps\n {\n     let region_maps = @mut RegionMaps {\n@@ -516,483 +506,9 @@ pub fn resolve_crate(sess: Session,\n                       var_parent: None};\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n-        def_map: def_map,\n         region_maps: region_maps,\n     };\n     visit::walk_crate(&mut visitor, crate, cx);\n     return region_maps;\n }\n \n-// ___________________________________________________________________________\n-// Determining region parameterization\n-//\n-// Infers which type defns must be region parameterized---this is done\n-// by scanning their contents to see whether they reference a region\n-// type, directly or indirectly.  This is a fixed-point computation.\n-//\n-// We do it in two passes.  First we walk the AST and construct a map\n-// from each type defn T1 to other defns which make use of it.  For example,\n-// if we have a type like:\n-//\n-//    type S = *int;\n-//    type T = S;\n-//\n-// Then there would be a map entry from S to T.  During the same walk,\n-// we also construct add any types that reference regions to a set and\n-// a worklist.  We can then process the worklist, propagating indirect\n-// dependencies until a fixed point is reached.\n-\n-pub type region_paramd_items = @mut HashMap<ast::NodeId, region_variance>;\n-\n-#[deriving(Eq)]\n-pub struct region_dep {\n-    ambient_variance: region_variance,\n-    id: ast::NodeId\n-}\n-\n-pub struct DetermineRpCtxt {\n-    sess: Session,\n-    ast_map: ast_map::map,\n-    def_map: resolve::DefMap,\n-    region_paramd_items: region_paramd_items,\n-    dep_map: @mut HashMap<ast::NodeId, @mut ~[region_dep]>,\n-    worklist: ~[ast::NodeId],\n-\n-    // the innermost enclosing item id\n-    item_id: ast::NodeId,\n-\n-    // true when we are within an item but not within a method.\n-    // see long discussion on region_is_relevant().\n-    anon_implies_rp: bool,\n-\n-    // encodes the context of the current type; invariant if\n-    // mutable, covariant otherwise\n-    ambient_variance: region_variance,\n-}\n-\n-pub fn join_variance(variance1: region_variance,\n-                     variance2: region_variance)\n-                  -> region_variance {\n-    match (variance1, variance2) {\n-      (rv_invariant, _) => {rv_invariant}\n-      (_, rv_invariant) => {rv_invariant}\n-      (rv_covariant, rv_contravariant) => {rv_invariant}\n-      (rv_contravariant, rv_covariant) => {rv_invariant}\n-      (rv_covariant, rv_covariant) => {rv_covariant}\n-      (rv_contravariant, rv_contravariant) => {rv_contravariant}\n-    }\n-}\n-\n-/// Combines the ambient variance with the variance of a\n-/// particular site to yield the final variance of the reference.\n-///\n-/// Example: if we are checking function arguments then the ambient\n-/// variance is contravariant.  If we then find a `&'r T` pointer, `r`\n-/// appears in a co-variant position.  This implies that this\n-/// occurrence of `r` is contra-variant with respect to the current\n-/// item, and hence the function returns `rv_contravariant`.\n-pub fn add_variance(ambient_variance: region_variance,\n-                    variance: region_variance)\n-                 -> region_variance {\n-    match (ambient_variance, variance) {\n-      (rv_invariant, _) => rv_invariant,\n-      (_, rv_invariant) => rv_invariant,\n-      (rv_covariant, c) => c,\n-      (c, rv_covariant) => c,\n-      (rv_contravariant, rv_contravariant) => rv_covariant\n-    }\n-}\n-\n-impl DetermineRpCtxt {\n-    pub fn add_variance(&self, variance: region_variance) -> region_variance {\n-        add_variance(self.ambient_variance, variance)\n-    }\n-\n-    /// Records that item `id` is region-parameterized with the\n-    /// variance `variance`.  If `id` was already parameterized, then\n-    /// the new variance is joined with the old variance.\n-    pub fn add_rp(&mut self, id: ast::NodeId, variance: region_variance) {\n-        assert!(id != 0);\n-        let old_variance = self.region_paramd_items.find(&id).map(|x| *x);\n-        let joined_variance = match old_variance {\n-          None => variance,\n-          Some(v) => join_variance(v, variance)\n-        };\n-\n-        debug!(\"add_rp() variance for {}: {:?} == {:?} ^ {:?}\",\n-               ast_map::node_id_to_str(self.ast_map, id,\n-                                       token::get_ident_interner()),\n-               joined_variance, old_variance, variance);\n-\n-        if Some(joined_variance) != old_variance {\n-            let region_paramd_items = self.region_paramd_items;\n-            region_paramd_items.insert(id, joined_variance);\n-            self.worklist.push(id);\n-        }\n-    }\n-\n-    /// Indicates that the region-parameterization of the current item\n-    /// is dependent on the region-parameterization of the item\n-    /// `from`.  Put another way, it indicates that the current item\n-    /// contains a value of type `from`, so if `from` is\n-    /// region-parameterized, so is the current item.\n-    pub fn add_dep(&mut self, from: ast::NodeId) {\n-        debug!(\"add dependency from {} -> {} ({} -> {}) with variance {:?}\",\n-               from, self.item_id,\n-               ast_map::node_id_to_str(self.ast_map, from,\n-                                       token::get_ident_interner()),\n-               ast_map::node_id_to_str(self.ast_map, self.item_id,\n-                                       token::get_ident_interner()),\n-               self.ambient_variance);\n-        let vec = do self.dep_map.find_or_insert_with(from) |_| {\n-            @mut ~[]\n-        };\n-        let dep = region_dep {\n-            ambient_variance: self.ambient_variance,\n-            id: self.item_id\n-        };\n-        if !vec.iter().any(|x| x == &dep) { vec.push(dep); }\n-    }\n-\n-    // Determines whether a reference to a region that appears in the\n-    // AST implies that the enclosing type is region-parameterized (RP).\n-    // This point is subtle.  Here are some examples to make it more\n-    // concrete.\n-    //\n-    // 1. impl foo for &int { ... }\n-    // 2. impl foo for &'self int { ... }\n-    // 3. impl foo for bar { fn m(@self) -> &'self int { ... } }\n-    // 4. impl foo for bar { fn m(&self) -> &'self int { ... } }\n-    // 5. impl foo for bar { fn m(&self) -> &int { ... } }\n-    //\n-    // In case 1, the anonymous region is being referenced,\n-    // but it appears in a context where the anonymous region\n-    // resolves to self, so the impl foo is RP.\n-    //\n-    // In case 2, the self parameter is written explicitly.\n-    //\n-    // In case 3, the method refers to the region `self`, so that\n-    // implies that the impl must be region parameterized.  (If the\n-    // type bar is not region parameterized, that is an error, because\n-    // the self region is effectively unconstrained, but that is\n-    // detected elsewhere).\n-    //\n-    // In case 4, the method refers to the region `self`, but the\n-    // `self` region is bound by the `&self` receiver, and so this\n-    // does not require that `bar` be RP.\n-    //\n-    // In case 5, the anonymous region is referenced, but it\n-    // bound by the method, so it does not refer to self.  This impl\n-    // need not be region parameterized.\n-    //\n-    // Normally, & or &self implies that the enclosing item is RP.\n-    // However, within a function, & is always bound.  Within a method\n-    // with &self type, &self is also bound.  We detect those last two\n-    // cases via flags (anon_implies_rp and self_implies_rp) that are\n-    // true when the anon or self region implies RP.\n-    pub fn region_is_relevant(&self, r: &Option<ast::Lifetime>) -> bool {\n-        match r {\n-            &None => {\n-                self.anon_implies_rp\n-            }\n-            &Some(ref l) if l.ident == special_idents::statik => {\n-                false\n-            }\n-            &Some(ref l) if l.ident == special_idents::self_ => {\n-                true\n-            }\n-            &Some(_) => {\n-                false\n-            }\n-        }\n-    }\n-\n-    pub fn with(@mut self,\n-                item_id: ast::NodeId,\n-                anon_implies_rp: bool,\n-                f: &fn()) {\n-        let old_item_id = self.item_id;\n-        let old_anon_implies_rp = self.anon_implies_rp;\n-        self.item_id = item_id;\n-        self.anon_implies_rp = anon_implies_rp;\n-        debug!(\"with_item_id({}, {})\",\n-               item_id,\n-               anon_implies_rp);\n-        let _i = ::util::common::indenter();\n-        f();\n-        self.item_id = old_item_id;\n-        self.anon_implies_rp = old_anon_implies_rp;\n-    }\n-\n-    pub fn with_ambient_variance(@mut self,\n-                                 variance: region_variance,\n-                                 f: &fn()) {\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.add_variance(variance);\n-        f();\n-        self.ambient_variance = old_ambient_variance;\n-    }\n-}\n-\n-fn determine_rp_in_item(visitor: &mut DetermineRpVisitor,\n-                        item: @ast::item) {\n-    do visitor.cx.with(item.id, true) {\n-        visit::walk_item(visitor, item, ());\n-    }\n-}\n-\n-fn determine_rp_in_fn(visitor: &mut DetermineRpVisitor,\n-                      fk: &visit::fn_kind,\n-                      decl: &ast::fn_decl,\n-                      body: &ast::Block,\n-                      _: Span,\n-                      _: ast::NodeId) {\n-    let cx = visitor.cx;\n-    do cx.with(cx.item_id, false) {\n-        do cx.with_ambient_variance(rv_contravariant) {\n-            for a in decl.inputs.iter() {\n-                visitor.visit_ty(&a.ty, ());\n-            }\n-        }\n-        visitor.visit_ty(&decl.output, ());\n-        let generics = visit::generics_of_fn(fk);\n-        visitor.visit_generics(&generics, ());\n-        visitor.visit_block(body, ());\n-    }\n-}\n-\n-fn determine_rp_in_ty_method(visitor: &mut DetermineRpVisitor,\n-                             ty_m: &ast::TypeMethod) {\n-    let cx = visitor.cx;\n-    do cx.with(cx.item_id, false) {\n-        visit::walk_ty_method(visitor, ty_m, ());\n-    }\n-}\n-\n-fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n-                      ty: &ast::Ty) {\n-    let cx = visitor.cx;\n-\n-    // we are only interested in types that will require an item to\n-    // be region-parameterized.  if cx.item_id is zero, then this type\n-    // is not a member of a type defn nor is it a constitutent of an\n-    // impl etc.  So we can ignore it and its components.\n-    if cx.item_id == 0 { return; }\n-\n-    // if this type directly references a region pointer like &'r ty,\n-    // add to the worklist/set.  Note that &'r ty is contravariant with\n-    // respect to &r, because &'r ty can be used whereever a *smaller*\n-    // region is expected (and hence is a supertype of those\n-    // locations)\n-    let sess = cx.sess;\n-    match ty.node {\n-        ast::ty_rptr(ref r, _) => {\n-            debug!(\"referenced rptr type {}\",\n-                   pprust::ty_to_str(ty, sess.intr()));\n-\n-            if cx.region_is_relevant(r) {\n-                let rv = cx.add_variance(rv_contravariant);\n-                cx.add_rp(cx.item_id, rv)\n-            }\n-        }\n-\n-        ast::ty_closure(ref f) => {\n-            debug!(\"referenced fn type: {}\",\n-                   pprust::ty_to_str(ty, sess.intr()));\n-            match f.region {\n-                Some(_) => {\n-                    if cx.region_is_relevant(&f.region) {\n-                        let rv = cx.add_variance(rv_contravariant);\n-                        cx.add_rp(cx.item_id, rv)\n-                    }\n-                }\n-                None => {\n-                    if f.sigil == ast::BorrowedSigil && cx.anon_implies_rp {\n-                        let rv = cx.add_variance(rv_contravariant);\n-                        cx.add_rp(cx.item_id, rv)\n-                    }\n-                }\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    // if this references another named type, add the dependency\n-    // to the dep_map.  If the type is not defined in this crate,\n-    // then check whether it is region-parameterized and consider\n-    // that as a direct dependency.\n-    match ty.node {\n-      ast::ty_path(ref path, _, id) => {\n-        match cx.def_map.find(&id) {\n-          Some(&ast::DefTy(did)) |\n-          Some(&ast::DefTrait(did)) |\n-          Some(&ast::DefStruct(did)) => {\n-            if did.crate == ast::LOCAL_CRATE {\n-                if cx.region_is_relevant(&path.segments.last().lifetime) {\n-                    cx.add_dep(did.node);\n-                }\n-            } else {\n-                let cstore = sess.cstore;\n-                match csearch::get_region_param(cstore, did) {\n-                  None => {}\n-                  Some(variance) => {\n-                    debug!(\"reference to external, rp'd type {}\",\n-                           pprust::ty_to_str(ty, sess.intr()));\n-                    if cx.region_is_relevant(&path.segments.last().lifetime) {\n-                        let rv = cx.add_variance(variance);\n-                        cx.add_rp(cx.item_id, rv)\n-                    }\n-                  }\n-                }\n-            }\n-          }\n-          _ => {}\n-        }\n-      }\n-      _ => {}\n-    }\n-\n-    match ty.node {\n-      ast::ty_box(ref mt) | ast::ty_uniq(ref mt) | ast::ty_vec(ref mt) |\n-      ast::ty_rptr(_, ref mt) | ast::ty_ptr(ref mt) => {\n-        visit_mt(visitor, mt);\n-      }\n-\n-      ast::ty_path(ref path, _, _) => {\n-        // type parameters are---for now, anyway---always invariant\n-        do cx.with_ambient_variance(rv_invariant) {\n-            for tp in path.segments.iter().flat_map(|s| s.types.iter()) {\n-                visitor.visit_ty(tp, ());\n-            }\n-        }\n-      }\n-\n-      ast::ty_closure(@ast::TyClosure {decl: ref decl, _}) |\n-      ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n-        // fn() binds the & region, so do not consider &T types that\n-        // appear *inside* a fn() type to affect the enclosing item:\n-        do cx.with(cx.item_id, false) {\n-            // parameters are contravariant\n-            do cx.with_ambient_variance(rv_contravariant) {\n-                for a in decl.inputs.iter() {\n-                    visitor.visit_ty(&a.ty, ());\n-                }\n-            }\n-            visitor.visit_ty(&decl.output, ());\n-        }\n-      }\n-\n-      _ => {\n-        visit::walk_ty(visitor, ty, ());\n-      }\n-    }\n-\n-    fn visit_mt(visitor: &mut DetermineRpVisitor,\n-                mt: &ast::mt) {\n-        let cx = visitor.cx;\n-        // mutability is invariant\n-        if mt.mutbl == ast::MutMutable {\n-            do cx.with_ambient_variance(rv_invariant) {\n-                visitor.visit_ty(mt.ty, ());\n-            }\n-        } else {\n-            visitor.visit_ty(mt.ty, ());\n-        }\n-    }\n-}\n-\n-fn determine_rp_in_struct_field(visitor: &mut DetermineRpVisitor,\n-                                cm: @ast::struct_field) {\n-    visit::walk_struct_field(visitor, cm, ());\n-}\n-\n-struct DetermineRpVisitor {\n-    cx: @mut DetermineRpCtxt\n-}\n-\n-impl Visitor<()> for DetermineRpVisitor {\n-\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n-                b:&Block, s:Span, n:NodeId, _:()) {\n-        determine_rp_in_fn(self, fk, fd, b, s, n);\n-    }\n-    fn visit_item(&mut self, i:@item, _:()) {\n-        determine_rp_in_item(self, i);\n-    }\n-    fn visit_ty(&mut self, t:&Ty, _:()) {\n-        determine_rp_in_ty(self, t);\n-    }\n-    fn visit_ty_method(&mut self, t:&TypeMethod, _:()) {\n-        determine_rp_in_ty_method(self, t);\n-    }\n-    fn visit_struct_field(&mut self, s:@struct_field, _:()) {\n-        determine_rp_in_struct_field(self, s);\n-    }\n-\n-}\n-\n-pub fn determine_rp_in_crate(sess: Session,\n-                             ast_map: ast_map::map,\n-                             def_map: resolve::DefMap,\n-                             crate: &ast::Crate)\n-                          -> region_paramd_items {\n-    let cx = @mut DetermineRpCtxt {\n-        sess: sess,\n-        ast_map: ast_map,\n-        def_map: def_map,\n-        region_paramd_items: @mut HashMap::new(),\n-        dep_map: @mut HashMap::new(),\n-        worklist: ~[],\n-        item_id: 0,\n-        anon_implies_rp: false,\n-        ambient_variance: rv_covariant\n-    };\n-\n-    // Gather up the base set, worklist and dep_map\n-    let mut visitor = DetermineRpVisitor { cx: cx };\n-    visit::walk_crate(&mut visitor, crate, ());\n-\n-    // Propagate indirect dependencies\n-    //\n-    // Each entry in the worklist is the id of an item C whose region\n-    // parameterization has been updated.  So we pull ids off of the\n-    // worklist, find the current variance, and then iterate through\n-    // all of the dependent items (that is, those items that reference\n-    // C).  For each dependent item D, we combine the variance of C\n-    // with the ambient variance where the reference occurred and then\n-    // update the region-parameterization of D to reflect the result.\n-    {\n-        let cx = &mut *cx;\n-        while cx.worklist.len() != 0 {\n-            let c_id = cx.worklist.pop();\n-            let c_variance = cx.region_paramd_items.get_copy(&c_id);\n-            debug!(\"popped {} from worklist\", c_id);\n-            match cx.dep_map.find(&c_id) {\n-              None => {}\n-              Some(deps) => {\n-                for dep in deps.iter() {\n-                    let v = add_variance(dep.ambient_variance, c_variance);\n-                    cx.add_rp(dep.id, v);\n-                }\n-              }\n-            }\n-        }\n-    }\n-\n-    debug!(\"{}\", {\n-        debug!(\"Region variance results:\");\n-        let region_paramd_items = cx.region_paramd_items;\n-        for (&key, &value) in region_paramd_items.iter() {\n-            debug!(\"item {:?} ({}) is parameterized with variance {:?}\",\n-                   key,\n-                   ast_map::node_id_to_str(ast_map, key,\n-                                           token::get_ident_interner()),\n-                   value);\n-        }\n-        \"----\"\n-    });\n-\n-    // return final set\n-    return cx.region_paramd_items;\n-}"}, {"sha": "23fef5e3516748e571b384bed4454be8af6f46cf", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -4182,7 +4182,7 @@ impl Resolver {\n \n                             if path.segments\n                                    .iter()\n-                                   .any(|s| s.lifetime.is_some()) {\n+                                   .any(|s| !s.lifetimes.is_empty()) {\n                                 self.session.span_err(path.span,\n                                                       \"lifetime parameters \\\n                                                        are not allowed on \\"}, {"sha": "b21720f2e30a0ae6c5eab26dbfe0b8c79580bc80", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,321 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Name resolution for lifetimes.\n+ *\n+ * Name resolution for lifetimes follows MUCH simpler rules than the\n+ * full resolve. For example, lifetime names are never exported or\n+ * used between functions, and they operate in a purely top-down\n+ * way. Therefore we break lifetime name resolution into a separate pass.\n+ */\n+\n+use driver::session;\n+use std::hashmap::HashMap;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::opt_vec::OptVec;\n+use syntax::parse::token::special_idents;\n+use syntax::print::pprust::{lifetime_to_str};\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+\n+// maps the id of each lifetime reference to the lifetime decl\n+// that it corresponds to\n+pub type NamedRegionMap = HashMap<ast::NodeId, ast::DefRegion>;\n+\n+struct LifetimeContext {\n+    sess: session::Session,\n+    named_region_map: @mut NamedRegionMap,\n+}\n+\n+enum ScopeChain<'self> {\n+    ItemScope(&'self OptVec<ast::Lifetime>),\n+    FnScope(ast::NodeId, &'self OptVec<ast::Lifetime>, &'self ScopeChain<'self>),\n+    BlockScope(ast::NodeId, &'self ScopeChain<'self>),\n+    RootScope\n+}\n+\n+pub fn crate(sess: session::Session,\n+             crate: &ast::Crate)\n+             -> @mut NamedRegionMap {\n+    let mut ctxt = LifetimeContext {\n+        sess: sess,\n+        named_region_map: @mut HashMap::new()\n+    };\n+    visit::walk_crate(&mut ctxt, crate, &RootScope);\n+    sess.abort_if_errors();\n+    ctxt.named_region_map\n+}\n+\n+impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n+    fn visit_item(&mut self,\n+                  item: @ast::item,\n+                  _: &'self ScopeChain<'self>) {\n+        let scope = match item.node {\n+            ast::item_fn(*) | // fn lifetimes get added in visit_fn below\n+            ast::item_mod(*) |\n+            ast::item_mac(*) |\n+            ast::item_foreign_mod(*) |\n+            ast::item_static(*) => {\n+                RootScope\n+            }\n+            ast::item_ty(_, ref generics) |\n+            ast::item_enum(_, ref generics) |\n+            ast::item_struct(_, ref generics) |\n+            ast::item_impl(ref generics, _, _, _) |\n+            ast::item_trait(ref generics, _, _) => {\n+                self.check_lifetime_names(&generics.lifetimes);\n+                ItemScope(&generics.lifetimes)\n+            }\n+        };\n+        debug!(\"entering scope {:?}\", scope);\n+        visit::walk_item(self, item, &scope);\n+        debug!(\"exiting scope {:?}\", scope);\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: &visit::fn_kind,\n+                fd: &ast::fn_decl,\n+                b: &ast::Block,\n+                s: Span,\n+                n: ast::NodeId,\n+                scope: &'self ScopeChain<'self>) {\n+        match *fk {\n+            visit::fk_item_fn(_, generics, _, _) |\n+            visit::fk_method(_, generics, _) => {\n+                let scope1 = FnScope(n, &generics.lifetimes, scope);\n+                self.check_lifetime_names(&generics.lifetimes);\n+                debug!(\"pushing fn scope id={} due to item/method\", n);\n+                visit::walk_fn(self, fk, fd, b, s, n, &scope1);\n+                debug!(\"popping fn scope id={} due to item/method\", n);\n+            }\n+            visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+                visit::walk_fn(self, fk, fd, b, s, n, scope);\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self,\n+                ty: &ast::Ty,\n+                scope: &'self ScopeChain<'self>) {\n+        match ty.node {\n+            ast::ty_closure(@ast::TyClosure { lifetimes: ref lifetimes, _ }) |\n+            ast::ty_bare_fn(@ast::TyBareFn { lifetimes: ref lifetimes, _ }) => {\n+                let scope1 = FnScope(ty.id, lifetimes, scope);\n+                self.check_lifetime_names(lifetimes);\n+                debug!(\"pushing fn scope id={} due to type\", ty.id);\n+                visit::walk_ty(self, ty, &scope1);\n+                debug!(\"popping fn scope id={} due to type\", ty.id);\n+            }\n+            _ => {\n+                visit::walk_ty(self, ty, scope);\n+            }\n+        }\n+    }\n+\n+    fn visit_ty_method(&mut self,\n+                       m: &ast::TypeMethod,\n+                       scope: &'self ScopeChain<'self>) {\n+        let scope1 = FnScope(m.id, &m.generics.lifetimes, scope);\n+        self.check_lifetime_names(&m.generics.lifetimes);\n+        debug!(\"pushing fn scope id={} due to ty_method\", m.id);\n+        visit::walk_ty_method(self, m, &scope1);\n+        debug!(\"popping fn scope id={} due to ty_method\", m.id);\n+    }\n+\n+    fn visit_block(&mut self,\n+                   b: &ast::Block,\n+                   scope: &'self ScopeChain<'self>) {\n+        let scope1 = BlockScope(b.id, scope);\n+        debug!(\"pushing block scope {}\", b.id);\n+        visit::walk_block(self, b, &scope1);\n+        debug!(\"popping block scope {}\", b.id);\n+    }\n+\n+    fn visit_lifetime_ref(&mut self,\n+                          lifetime_ref: &ast::Lifetime,\n+                          scope: &'self ScopeChain<'self>) {\n+        if lifetime_ref.ident == special_idents::statik {\n+            self.insert_lifetime(lifetime_ref, ast::DefStaticRegion);\n+            return;\n+        }\n+        self.resolve_lifetime_ref(lifetime_ref, scope);\n+    }\n+}\n+\n+impl LifetimeContext {\n+    fn resolve_lifetime_ref(&self,\n+                            lifetime_ref: &ast::Lifetime,\n+                            scope: &ScopeChain) {\n+        // Walk up the scope chain, tracking the number of fn scopes\n+        // that we pass through, until we find a lifetime with the\n+        // given name or we run out of scopes. If we encounter a code\n+        // block, then the lifetime is not bound but free, so switch\n+        // over to `resolve_free_lifetime_ref()` to complete the\n+        // search.\n+        let mut depth = 0;\n+        let mut scope = scope;\n+        loop {\n+            match *scope {\n+                BlockScope(id, s) => {\n+                    return self.resolve_free_lifetime_ref(id, lifetime_ref, s);\n+                }\n+\n+                RootScope => {\n+                    break;\n+                }\n+\n+                ItemScope(lifetimes) => {\n+                    match search_lifetimes(lifetimes, lifetime_ref) {\n+                        Some((index, decl_id)) => {\n+                            let def = ast::DefEarlyBoundRegion(index, decl_id);\n+                            self.insert_lifetime(lifetime_ref, def);\n+                            return;\n+                        }\n+                        None => {\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                FnScope(id, lifetimes, s) => {\n+                    match search_lifetimes(lifetimes, lifetime_ref) {\n+                        Some((_index, decl_id)) => {\n+                            let def = ast::DefLateBoundRegion(id, depth, decl_id);\n+                            self.insert_lifetime(lifetime_ref, def);\n+                            return;\n+                        }\n+\n+                        None => {\n+                            depth += 1;\n+                            scope = s;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.unresolved_lifetime_ref(lifetime_ref);\n+    }\n+\n+    fn resolve_free_lifetime_ref(&self,\n+                                 scope_id: ast::NodeId,\n+                                 lifetime_ref: &ast::Lifetime,\n+                                 scope: &ScopeChain) {\n+        // Walk up the scope chain, tracking the outermost free scope,\n+        // until we encounter a scope that contains the named lifetime\n+        // or we run out of scopes.\n+        let mut scope_id = scope_id;\n+        let mut scope = scope;\n+        let mut search_result = None;\n+        loop {\n+            match *scope {\n+                BlockScope(id, s) => {\n+                    scope_id = id;\n+                    scope = s;\n+                }\n+\n+                RootScope => {\n+                    break;\n+                }\n+\n+                ItemScope(lifetimes) => {\n+                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n+                    break;\n+                }\n+\n+                FnScope(_, lifetimes, s) => {\n+                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n+                    if search_result.is_some() {\n+                        break;\n+                    }\n+                    scope = s;\n+                }\n+            }\n+        }\n+\n+        match search_result {\n+            Some((_depth, decl_id)) => {\n+                let def = ast::DefFreeRegion(scope_id, decl_id);\n+                self.insert_lifetime(lifetime_ref, def);\n+            }\n+\n+            None => {\n+                self.unresolved_lifetime_ref(lifetime_ref);\n+            }\n+        }\n+\n+    }\n+\n+    fn unresolved_lifetime_ref(&self,\n+                               lifetime_ref: &ast::Lifetime) {\n+        self.sess.span_err(\n+            lifetime_ref.span,\n+            format!(\"use of undeclared lifetime name `'{}`\",\n+                    self.sess.str_of(lifetime_ref.ident)));\n+    }\n+\n+    fn check_lifetime_names(&self, lifetimes: &OptVec<ast::Lifetime>) {\n+        for i in range(0, lifetimes.len()) {\n+            let lifetime_i = lifetimes.get(i);\n+\n+            let special_idents = [special_idents::statik];\n+            for lifetime in lifetimes.iter() {\n+                if special_idents.iter().any(|&i| i == lifetime.ident) {\n+                    self.sess.span_err(\n+                        lifetime.span,\n+                        format!(\"illegal lifetime parameter name: `{}`\",\n+                                self.sess.str_of(lifetime.ident)));\n+                }\n+            }\n+\n+            for j in range(i + 1, lifetimes.len()) {\n+                let lifetime_j = lifetimes.get(j);\n+\n+                if lifetime_i.ident == lifetime_j.ident {\n+                    self.sess.span_err(\n+                        lifetime_j.span,\n+                        format!(\"lifetime name `'{}` declared twice in \\\n+                                the same scope\",\n+                                self.sess.str_of(lifetime_j.ident)));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn insert_lifetime(&self,\n+                       lifetime_ref: &ast::Lifetime,\n+                       def: ast::DefRegion) {\n+        if lifetime_ref.id == ast::DUMMY_NODE_ID {\n+            self.sess.span_bug(lifetime_ref.span,\n+                               \"Lifetime reference not renumbered, \\\n+                               probably a bug in syntax::fold\");\n+        }\n+\n+        debug!(\"lifetime_ref={} id={} resolved to {:?}\",\n+                lifetime_to_str(lifetime_ref,\n+                                self.sess.intr()),\n+                lifetime_ref.id,\n+                def);\n+        self.named_region_map.insert(lifetime_ref.id, def);\n+    }\n+}\n+\n+fn search_lifetimes(lifetimes: &OptVec<ast::Lifetime>,\n+                    lifetime_ref: &ast::Lifetime)\n+                    -> Option<(uint, ast::NodeId)> {\n+    for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n+        if lifetime_decl.ident == lifetime_ref.ident {\n+            return Some((i, lifetime_decl.id));\n+        }\n+    }\n+    return None;\n+}"}, {"sha": "c9abf71e2b6ecf8911ef32c74e6ffed90d1af87f", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -10,10 +10,11 @@\n \n // Type substitutions.\n \n-\n use middle::ty;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFolder;\n use syntax::opt_vec::OptVec;\n-use util::ppaux::Repr;\n+use std::at_vec;\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n@@ -33,39 +34,43 @@ pub trait Subst {\n // to all subst methods but ran into trouble due to the limitations of\n // our current method/trait matching algorithm. - Niko\n \n-trait EffectfulSubst {\n-    fn effectfulSubst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Self;\n-}\n-\n impl Subst for ty::t {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::t {\n         if ty::substs_is_noop(substs) {\n-            return *self;\n+            *self\n         } else {\n-            return self.effectfulSubst(tcx, substs);\n+            let mut folder = SubstFolder {tcx: tcx, substs: substs};\n+            folder.fold_ty(*self)\n         }\n     }\n }\n \n-impl EffectfulSubst for ty::t {\n-    fn effectfulSubst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::t {\n-        if !ty::type_needs_subst(*self) {\n-            return *self;\n+struct SubstFolder<'self> {\n+    tcx: ty::ctxt,\n+    substs: &'self ty::substs\n+}\n+\n+impl<'self> TypeFolder for SubstFolder<'self> {\n+    fn tcx(&self) -> ty::ctxt { self.tcx }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        r.subst(self.tcx, self.substs)\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        if !ty::type_needs_subst(t) {\n+            return t;\n         }\n \n-        match ty::get(*self).sty {\n+        match ty::get(t).sty {\n             ty::ty_param(p) => {\n-                substs.tps[p.idx]\n+                self.substs.tps[p.idx]\n             }\n             ty::ty_self(_) => {\n-                substs.self_ty.expect(\"ty_self not found in substs\")\n+                self.substs.self_ty.expect(\"ty_self not found in substs\")\n             }\n             _ => {\n-                ty::fold_regions_and_ty(\n-                    tcx, *self,\n-                    |r| r.subst(tcx, substs),\n-                    |t| t.effectfulSubst(tcx, substs),\n-                    |t| t.effectfulSubst(tcx, substs))\n+                ty_fold::super_fold_ty(self, t)\n             }\n         }\n     }\n@@ -80,6 +85,12 @@ impl<T:Subst> Subst for ~[T] {\n     }\n }\n \n+impl<T:Subst> Subst for @[T] {\n+    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> @[T] {\n+        at_vec::map(*self, |t| t.subst(tcx, substs))\n+    }\n+}\n+\n impl<T:Subst> Subst for OptVec<T> {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> OptVec<T> {\n         self.map(|t| t.subst(tcx, substs))\n@@ -134,7 +145,8 @@ impl Subst for ty::RegionSubsts {\n \n impl Subst for ty::BareFnTy {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::BareFnTy {\n-        ty::fold_bare_fn_ty(self, |t| t.subst(tcx, substs))\n+        let mut folder = SubstFolder {tcx: tcx, substs: substs};\n+        folder.fold_bare_fn_ty(self)\n     }\n }\n \n@@ -161,35 +173,30 @@ impl Subst for ty::Generics {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::Generics {\n         ty::Generics {\n             type_param_defs: self.type_param_defs.subst(tcx, substs),\n-            region_param: self.region_param\n+            region_param_defs: self.region_param_defs.subst(tcx, substs),\n         }\n     }\n }\n \n+impl Subst for ty::RegionParameterDef {\n+    fn subst(&self, _: ty::ctxt, _: &ty::substs) -> ty::RegionParameterDef {\n+        *self\n+    }\n+}\n+\n impl Subst for ty::Region {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::Region {\n-        // Note: This routine only handles the self region, because it\n-        // is only concerned with substitutions of regions that appear\n-        // in types. Region substitution of the bound regions that\n-        // appear in a function signature is done using the\n-        // specialized routine\n+    fn subst(&self, _tcx: ty::ctxt, substs: &ty::substs) -> ty::Region {\n+        // Note: This routine only handles regions that are bound on\n+        // type declarationss and other outer declarations, not those\n+        // bound in *fn types*. Region substitution of the bound\n+        // regions that appear in a function signature is done using\n+        // the specialized routine\n         // `middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig()`.\n-        // As we transition to the new region syntax this distinction\n-        // will most likely disappear.\n         match self {\n-            &ty::re_bound(ty::br_self) => {\n+            &ty::ReEarlyBound(_, i, _) => {\n                 match substs.regions {\n-                    ty::ErasedRegions => ty::re_static,\n-                    ty::NonerasedRegions(ref regions) => {\n-                        if regions.len() != 1 {\n-                            tcx.sess.bug(\n-                                format!(\"ty::Region\\\\#subst(): \\\n-                                      Reference to self region when \\\n-                                      given substs with no self region: {}\",\n-                                     substs.repr(tcx)));\n-                        }\n-                        *regions.get(0)\n-                    }\n+                    ty::ErasedRegions => ty::ReStatic,\n+                    ty::NonerasedRegions(ref regions) => *regions.get(i),\n                 }\n             }\n             _ => *self"}, {"sha": "9dddf96e34d576580b5e2d3c69fa09f1a1b26ac8", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -1048,7 +1048,7 @@ fn extract_vec_elems(bcx: @mut Block,\n         let slice_len = Sub(bcx, len, slice_len_offset);\n         let slice_ty = ty::mk_evec(bcx.tcx(),\n             ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n-            ty::vstore_slice(ty::re_static)\n+            ty::vstore_slice(ty::ReStatic)\n         );\n         let scratch = scratch_datum(bcx, slice_ty, \"\", false);\n         Store(bcx, slice_begin,\n@@ -1697,7 +1697,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                   let t = node_id_type(bcx, pat_id);\n                   let Result {bcx: after_cx, val: matches} = {\n                       do with_scope_result(bcx, None,\n-                                           \"compare_scope\") |bcx| {\n+                                           \"compaReScope\") |bcx| {\n                           match trans_opt(bcx, opt) {\n                               single_result(\n                                   Result {bcx, val}) => {"}, {"sha": "06fe4717f58e194c47cc703ed01629f228823c10", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -181,7 +181,7 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n     let adjustment = cx.tcx.adjustments.find_copy(&e.id);\n     match adjustment {\n         None => { }\n-        Some(@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n+        Some(@ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil)) => {\n             llconst = C_struct([llconst, C_null(Type::opaque_box(cx).ptr_to())], false)\n         }\n         Some(@ty::AutoAddEnv(ref r, ref s)) => {\n@@ -211,11 +211,11 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n                     };\n                     match *autoref {\n                         ty::AutoUnsafe(m) |\n-                        ty::AutoPtr(ty::re_static, m) => {\n+                        ty::AutoPtr(ty::ReStatic, m) => {\n                             assert!(m != ast::MutMutable);\n                             llconst = llptr;\n                         }\n-                        ty::AutoBorrowVec(ty::re_static, m) => {\n+                        ty::AutoBorrowVec(ty::ReStatic, m) => {\n                             assert!(m != ast::MutMutable);\n                             assert_eq!(abi::slice_elt_base, 0);\n                             assert_eq!(abi::slice_elt_len, 1);"}, {"sha": "01cf102275023a0b3eb94f04cd1e200e7f88b733", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -588,7 +588,7 @@ impl Datum {\n         // result (which will be by-value).  Note that it is not\n         // significant *which* region we pick here.\n         let llval = self.to_ref_llval(bcx);\n-        let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::re_static,\n+        let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic,\n                                       self.ty);\n         Datum {val: llval, ty: rptr_ty, mode: ByValue}\n     }"}, {"sha": "ddf9354ad3835cf0e129e61c1ca56a17001e8379", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -271,7 +271,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         // real one, but it will have the same runtime representation\n         let slice_ty = ty::mk_evec(tcx,\n                                    ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n-                                   ty::vstore_slice(ty::re_static));\n+                                   ty::vstore_slice(ty::ReStatic));\n \n         let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n "}, {"sha": "0993d3322f1e650b849d5d79a62c7af5e0353bfe", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -339,7 +339,7 @@ pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n-                                                                     ty::re_static) {\n+                                                                     ty::ReStatic) {\n             Ok(pair) => pair,\n             Err(s) => {\n                 bcx.tcx().sess.fatal(s);"}, {"sha": "0781f724d48c3c30fd20d4c860a70c6b465ace59", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -59,7 +59,7 @@ impl Reflector {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n-        let str_vstore = ty::vstore_slice(ty::re_static);\n+        let str_vstore = ty::vstore_slice(ty::ReStatic);\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, \"\", false);\n         let len = C_uint(bcx.ccx(), s.len());"}, {"sha": "36af13d34e6565a35bb92bb50d7029d3b62c617f", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -14,6 +14,7 @@ use middle::trans::common::*;\n use middle::trans::foreign;\n use middle::ty;\n use util::ppaux;\n+use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n@@ -172,14 +173,16 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n-    debug!(\"type_of {:?}: {:?}\", t, ty::get(t));\n-\n     // Check the cache.\n     match cx.lltypes.find(&t) {\n-        Some(&t) => return t,\n+        Some(&llty) => {\n+            return llty;\n+        }\n         None => ()\n     }\n \n+    debug!(\"type_of {} {:?}\", t.repr(cx.tcx), t);\n+\n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n     // Rust types are defined as the same LLVM types.  If we don't do\n@@ -189,6 +192,12 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);\n+        debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n+                t.repr(cx.tcx),\n+                t,\n+                t_norm.repr(cx.tcx),\n+                t_norm,\n+                cx.tn.type_to_str(llty));\n         cx.lltypes.insert(t, llty);\n         return llty;\n     }\n@@ -299,6 +308,10 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       ty::ty_err(*) => cx.tcx.sess.bug(\"type_of with ty_err\")\n     };\n \n+    debug!(\"--> mapped t={} {:?} to llty={}\",\n+            t.repr(cx.tcx),\n+            t,\n+            cx.tn.type_to_str(llty));\n     cx.lltypes.insert(t, llty);\n \n     // If this was an enum or struct, fill in the type now."}, {"sha": "5072a95ddcf1bb145781149b4f6e90c5c321b88f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 298, "deletions": 375, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -17,9 +17,12 @@ use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n use middle::lang_items::OpaqueStructLangItem;\n use middle::freevars;\n use middle::resolve;\n+use middle::resolve_lifetime;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFolder;\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n@@ -206,13 +209,19 @@ pub enum ast_ty_to_ty_cache_entry {\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n-pub type opt_region_variance = Option<region_variance>;\n+#[deriving(Clone, Eq, Decodable, Encodable)]\n+pub struct ItemVariances {\n+    self_param: Option<Variance>,\n+    type_params: OptVec<Variance>,\n+    region_params: OptVec<Variance>\n+}\n \n #[deriving(Clone, Eq, Decodable, Encodable)]\n-pub enum region_variance {\n-    rv_covariant,\n-    rv_invariant,\n-    rv_contravariant,\n+pub enum Variance {\n+    Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n+    Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n+    Contravariant,  // T<A> <: T<B> iff B <: A -- e.g., function param type\n+    Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n #[deriving(Decodable, Encodable)]\n@@ -258,8 +267,9 @@ struct ctxt_ {\n     sess: session::Session,\n     def_map: resolve::DefMap,\n \n+    named_region_map: @mut resolve_lifetime::NamedRegionMap,\n+\n     region_maps: @mut middle::region::RegionMaps,\n-    region_paramd_items: middle::region::region_paramd_items,\n \n     // Stores the types for various nodes in the AST.  Note that this table\n     // is not guaranteed to be populated until after typeck.  See\n@@ -304,6 +314,10 @@ struct ctxt_ {\n     provided_method_sources: @mut HashMap<ast::DefId, ast::DefId>,\n     supertraits: @mut HashMap<ast::DefId, @~[@TraitRef]>,\n \n+    // Maps from def-id of a type or region parameter to its\n+    // (inferred) variance.\n+    item_variance_map: @mut HashMap<ast::DefId, @ItemVariances>,\n+\n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n     // present in this map, it does not have a destructor. This map is\n@@ -431,14 +445,17 @@ pub struct ClosureTy {\n  * Signature of a function type, which I have arbitrarily\n  * decided to use to refer to the input/output types.\n  *\n- * - `lifetimes` is the list of region names bound in this fn.\n+ * - `binder_id` is the node id where this fn type appeared;\n+ *   it is used to identify all the bound regions appearing\n+ *   in the input/output types that are bound by this fn type\n+ *   (vs some enclosing or enclosed fn type)\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type.\n  * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n  */\n #[deriving(Clone, Eq, IterBytes)]\n pub struct FnSig {\n-    bound_lifetime_names: OptVec<ast::Ident>,\n+    binder_id: ast::NodeId,\n     inputs: ~[t],\n     output: t,\n     variadic: bool\n@@ -453,86 +470,75 @@ pub struct param_ty {\n /// Representation of regions:\n #[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum Region {\n-    /// Bound regions are found (primarily) in function types.  They indicate\n-    /// region parameters that have yet to be replaced with actual regions\n-    /// (analogous to type parameters, except that due to the monomorphic\n-    /// nature of our type system, bound type parameters are always replaced\n-    /// with fresh type variables whenever an item is referenced, so type\n-    /// parameters only appear \"free\" in types.  Regions in contrast can\n-    /// appear free or bound.).  When a function is called, all bound regions\n-    /// tied to that function's node-id are replaced with fresh region\n-    /// variables whose value is then inferred.\n-    re_bound(bound_region),\n+    // Region bound in a type or fn declaration which will be\n+    // substituted 'early' -- that is, at the same time when type\n+    // parameters are substituted.\n+    ReEarlyBound(/* param id */ ast::NodeId, /*index*/ uint, ast::Ident),\n+\n+    // Region bound in a function scope, which will be substituted when the\n+    // function is called. The first argument must be the `binder_id` of\n+    // some enclosing function signature.\n+    ReLateBound(/* binder_id */ ast::NodeId, BoundRegion),\n \n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n     /// region parameters.\n-    re_free(FreeRegion),\n+    ReFree(FreeRegion),\n \n     /// A concrete region naming some expression within the current function.\n-    re_scope(NodeId),\n+    ReScope(NodeId),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n-    re_static,\n+    ReStatic,\n \n     /// A region variable.  Should not exist after typeck.\n-    re_infer(InferRegion),\n+    ReInfer(InferRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n-    /// Bottom in the region lattice. We treat re_empty somewhat\n+    /// Bottom in the region lattice. We treat ReEmpty somewhat\n     /// specially; at least right now, we do not generate instances of\n     /// it during the GLB computations, but rather\n     /// generate an error instead. This is to improve error messages.\n-    /// The only way to get an instance of re_empty is to have a region\n+    /// The only way to get an instance of ReEmpty is to have a region\n     /// variable with no constraints.\n-    re_empty,\n+    ReEmpty,\n }\n \n impl Region {\n     pub fn is_bound(&self) -> bool {\n         match self {\n-            &re_bound(*) => true,\n+            &ty::ReEarlyBound(*) => true,\n+            &ty::ReLateBound(*) => true,\n             _ => false\n         }\n     }\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n+#[deriving(Clone, Eq, TotalOrd, TotalEq, IterBytes, Encodable, Decodable, ToStr)]\n pub struct FreeRegion {\n     scope_id: NodeId,\n-    bound_region: bound_region\n+    bound_region: BoundRegion\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n-pub enum bound_region {\n-    /// The self region for structs, impls (&T in a type defn or &'self T)\n-    br_self,\n-\n+#[deriving(Clone, Eq, TotalEq, TotalOrd, IterBytes, Encodable, Decodable, ToStr)]\n+pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n-    br_anon(uint),\n+    BrAnon(uint),\n \n     /// Named region parameters for functions (a in &'a T)\n-    br_named(ast::Ident),\n+    ///\n+    /// The def-id is needed to distinguish free regions in\n+    /// the event of shadowing.\n+    BrNamed(ast::DefId, ast::Ident),\n \n     /// Fresh bound identifiers created during GLB computations.\n-    br_fresh(uint),\n-\n-    /**\n-     * Handles capture-avoiding substitution in a rather subtle case.  If you\n-     * have a closure whose argument types are being inferred based on the\n-     * expected type, and the expected type includes bound regions, then we\n-     * will wrap those bound regions in a br_cap_avoid() with the id of the\n-     * fn expression.  This ensures that the names are not \"captured\" by the\n-     * enclosing scope, which may define the same names.  For an example of\n-     * where this comes up, see src/test/compile-fail/regions-ret-borrowed.rs\n-     * and regions-ret-borrowed-1.rs. */\n-    br_cap_avoid(ast::NodeId, @bound_region),\n+    BrFresh(uint),\n }\n \n /**\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n- * trans, and all region parameters will be replaced with `ty::re_static`. */\n+ * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n #[deriving(Clone, Eq, IterBytes)]\n pub enum RegionSubsts {\n     ErasedRegions,\n@@ -697,8 +703,8 @@ pub enum type_err {\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n     terr_regions_no_overlap(Region, Region),\n-    terr_regions_insufficiently_polymorphic(bound_region, Region),\n-    terr_regions_overly_polymorphic(bound_region, Region),\n+    terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n+    terr_regions_overly_polymorphic(BoundRegion, Region),\n     terr_vstores_differ(terr_vstore_kind, expected_found<vstore>),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n     terr_in_field(@type_err, ast::Ident),\n@@ -774,7 +780,7 @@ pub enum InferTy {\n #[deriving(Clone, Encodable, Decodable, IterBytes, ToStr)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n-    ReSkolemized(uint, bound_region)\n+    ReSkolemized(uint, BoundRegion)\n }\n \n impl cmp::Eq for InferRegion {\n@@ -863,12 +869,21 @@ pub struct TypeParameterDef {\n     bounds: @ParamBounds\n }\n \n-/// Information about the type/lifetime parametesr associated with an item.\n+#[deriving(Encodable, Decodable, Clone)]\n+pub struct RegionParameterDef {\n+    ident: ast::Ident,\n+    def_id: ast::DefId,\n+}\n+\n+/// Information about the type/lifetime parameters associated with an item.\n /// Analogous to ast::Generics.\n #[deriving(Clone)]\n pub struct Generics {\n+    /// List of type parameters declared on the item.\n     type_param_defs: @~[TypeParameterDef],\n-    region_param: Option<region_variance>,\n+\n+    /// List of region parameters declared on the item.\n+    region_param_defs: @[RegionParameterDef],\n }\n \n impl Generics {\n@@ -877,6 +892,33 @@ impl Generics {\n     }\n }\n \n+/// When type checking, we use the `ParameterEnvironment` to track\n+/// details about the type/lifetime parameters that are in scope.\n+/// It primarily stores the bounds information.\n+///\n+/// Note: This information might seem to be redundant with the data in\n+/// `tcx.ty_param_defs`, but it is not. That table contains the\n+/// parameter definitions from an \"outside\" perspective, but this\n+/// struct will contain the bounds for a parameter as seen from inside\n+/// the function body. Currently the only real distinction is that\n+/// bound lifetime parameters are replaced with free ones, but in the\n+/// future I hope to refine the representation of types so as to make\n+/// more distinctions clearer.\n+pub struct ParameterEnvironment {\n+    /// A substitution that can be applied to move from\n+    /// the \"outer\" view of a type or method to the \"inner\" view.\n+    /// In general, this means converting from bound parameters to\n+    /// free parameters. Since we currently represent bound/free type\n+    /// parameters in the same way, this only has an affect on regions.\n+    free_substs: ty::substs,\n+\n+    /// Bound on the Self parameter\n+    self_param_bound: Option<@TraitRef>,\n+\n+    /// Bounds on each numbered type parameter\n+    type_param_bounds: ~[ParamBounds],\n+}\n+\n /// A polytype.\n ///\n /// - `bounds`: The list of bounds for each type parameter.  The length of the\n@@ -919,21 +961,22 @@ pub fn new_ty_hash<V:'static>() -> @mut HashMap<t, V> {\n \n pub fn mk_ctxt(s: session::Session,\n                dm: resolve::DefMap,\n+               named_region_map: @mut resolve_lifetime::NamedRegionMap,\n                amap: ast_map::map,\n                freevars: freevars::freevar_map,\n                region_maps: @mut middle::region::RegionMaps,\n-               region_paramd_items: middle::region::region_paramd_items,\n                lang_items: middle::lang_items::LanguageItems)\n             -> ctxt {\n     @ctxt_ {\n+        named_region_map: named_region_map,\n+        item_variance_map: @mut HashMap::new(),\n         diag: s.diagnostic(),\n         interner: @mut HashMap::new(),\n         next_id: @mut primitives::LAST_PRIMITIVE_ID,\n         cstore: s.cstore,\n         sess: s,\n         def_map: dm,\n         region_maps: region_maps,\n-        region_paramd_items: region_paramd_items,\n         node_types: @mut HashMap::new(),\n         node_type_substs: @mut HashMap::new(),\n         trait_refs: @mut HashMap::new(),\n@@ -978,7 +1021,7 @@ pub fn mk_ctxt(s: session::Session,\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-fn mk_t(cx: ctxt, st: sty) -> t {\n+pub fn mk_t(cx: ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n         ty_nil => return mk_nil(),\n@@ -987,6 +1030,8 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n         ty_int(i) => return mk_mach_int(i),\n         ty_uint(u) => return mk_mach_uint(u),\n         ty_float(f) => return mk_mach_float(f),\n+        ty_char => return mk_char(),\n+        ty_bot => return mk_bot(),\n         _ => {}\n     };\n \n@@ -1000,7 +1045,7 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n     fn rflags(r: Region) -> uint {\n         (has_regions as uint) | {\n             match r {\n-              ty::re_infer(_) => needs_infer as uint,\n+              ty::ReInfer(_) => needs_infer as uint,\n               _ => 0u\n             }\n         }\n@@ -1246,14 +1291,17 @@ pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n     mk_t(cx, ty_bare_fn(fty))\n }\n \n-pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n+pub fn mk_ctor_fn(cx: ctxt,\n+                  binder_id: ast::NodeId,\n+                  input_tys: &[ty::t],\n+                  output: ty::t) -> t {\n     let input_args = input_tys.map(|t| *t);\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::impure_fn,\n                    abis: AbiSet::Rust(),\n                    sig: FnSig {\n-                    bound_lifetime_names: opt_vec::Empty,\n+                    binder_id: binder_id,\n                     inputs: input_args,\n                     output: output,\n                     variadic: false\n@@ -1333,224 +1381,70 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n     }\n }\n \n-pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: &fn(t) -> t) -> t {\n-    mk_t(tcx, fold_sty(sty, foldop))\n+// Folds types from the bottom up.\n+pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n+    let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n+    f.fold_ty(t0)\n }\n \n-pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n-    let args = sig.inputs.map(|arg| fldop(*arg));\n-\n-    FnSig {\n-        bound_lifetime_names: sig.bound_lifetime_names.clone(),\n-        inputs: args,\n-        output: fldop(sig.output),\n-        variadic: sig.variadic\n-    }\n+pub fn walk_regions_and_ty(cx: ctxt,\n+                           ty: t,\n+                           fldr: &fn(r: Region),\n+                           fldt: &fn(t: t))\n+                           -> t {\n+    ty_fold::RegionFolder::general(cx,\n+                                   |r| { fldr(r); r },\n+                                   |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-pub fn fold_bare_fn_ty(fty: &BareFnTy, fldop: &fn(t) -> t) -> BareFnTy {\n-    BareFnTy {sig: fold_sig(&fty.sig, fldop),\n-              abis: fty.abis,\n-              purity: fty.purity}\n+pub fn fold_regions(cx: ctxt,\n+                    ty: t,\n+                    fldr: &fn(r: Region) -> Region)\n+                    -> t {\n+    ty_fold::RegionFolder::regions(cx, fldr).fold_ty(ty)\n }\n \n-fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n-    fn fold_substs(substs: &substs, fldop: &fn(t) -> t) -> substs {\n-        substs {regions: substs.regions.clone(),\n-                self_ty: substs.self_ty.map(|t| fldop(t)),\n-                tps: substs.tps.map(|t| fldop(*t))}\n-    }\n+// Substitute *only* type parameters.  Used in trans where regions are erased.\n+pub fn subst_tps(tcx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n+    let mut subst = TpsSubst { tcx: tcx, self_ty_opt: self_ty_opt, tps: tps };\n+    return subst.fold_ty(typ);\n \n-    match *sty {\n-        ty_box(ref tm) => {\n-            ty_box(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_uniq(ref tm) => {\n-            ty_uniq(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_ptr(ref tm) => {\n-            ty_ptr(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_unboxed_vec(ref tm) => {\n-            ty_unboxed_vec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_evec(ref tm, vst) => {\n-            ty_evec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n-        }\n-        ty_enum(tid, ref substs) => {\n-            ty_enum(tid, fold_substs(substs, fldop))\n-        }\n-        ty_trait(did, ref substs, st, mutbl, bounds) => {\n-            ty_trait(did, fold_substs(substs, fldop), st, mutbl, bounds)\n-        }\n-        ty_tup(ref ts) => {\n-            let new_ts = ts.map(|tt| fldop(*tt));\n-            ty_tup(new_ts)\n-        }\n-        ty_bare_fn(ref f) => {\n-            ty_bare_fn(fold_bare_fn_ty(f, fldop))\n-        }\n-        ty_closure(ref f) => {\n-            let sig = fold_sig(&f.sig, fldop);\n-            ty_closure(ClosureTy {\n-                sig: sig,\n-                purity: f.purity,\n-                sigil: f.sigil,\n-                onceness: f.onceness,\n-                region: f.region,\n-                bounds: f.bounds,\n-            })\n-        }\n-        ty_rptr(r, ref tm) => {\n-            ty_rptr(r, mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n-        }\n-        ty_struct(did, ref substs) => {\n-            ty_struct(did, fold_substs(substs, fldop))\n-        }\n-        ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) | ty_err |\n-        ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self(_) => {\n-            (*sty).clone()\n-        }\n+    pub struct TpsSubst<'self> {\n+        tcx: ctxt,\n+        self_ty_opt: Option<t>,\n+        tps: &'self [t],\n     }\n-}\n \n-// Folds types from the bottom up.\n-pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n-    let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), |t| fldop(t)));\n-    fldop(mk_t(cx, sty))\n-}\n-\n-pub fn walk_regions_and_ty(\n-    cx: ctxt,\n-    ty: t,\n-    walkr: &fn(r: Region),\n-    walkt: &fn(t: t) -> bool) {\n+    impl<'self> TypeFolder for TpsSubst<'self> {\n+        fn tcx(&self) -> ty::ctxt { self.tcx }\n \n-    if (walkt(ty)) {\n-        fold_regions_and_ty(\n-            cx, ty,\n-            |r| { walkr(r); r },\n-            |t| { walk_regions_and_ty(cx, t, |r| walkr(r), |t| walkt(t)); t },\n-            |t| { walk_regions_and_ty(cx, t, |r| walkr(r), |t| walkt(t)); t });\n-    }\n-}\n-\n-pub fn fold_regions_and_ty(\n-    cx: ctxt,\n-    ty: t,\n-    fldr: &fn(r: Region) -> Region,\n-    fldfnt: &fn(t: t) -> t,\n-    fldt: &fn(t: t) -> t) -> t {\n-\n-    fn fold_substs(\n-        substs: &substs,\n-        fldr: &fn(r: Region) -> Region,\n-        fldt: &fn(t: t) -> t)\n-     -> substs {\n-        let regions = match substs.regions {\n-            ErasedRegions => ErasedRegions,\n-            NonerasedRegions(ref regions) => {\n-                NonerasedRegions(regions.map(|r| fldr(*r)))\n+        fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+            if self.tps.len() == 0u && self.self_ty_opt.is_none() {\n+                return t;\n             }\n-        };\n \n-        substs {\n-            regions: regions,\n-            self_ty: substs.self_ty.map(|t| fldt(t)),\n-            tps: substs.tps.map(|t| fldt(*t))\n-        }\n-    }\n+            let tb = ty::get(t);\n+            if self.self_ty_opt.is_none() && !tbox_has_flag(tb, has_params) {\n+                return t;\n+            }\n \n-    let tb = ty::get(ty);\n-    match tb.sty {\n-      ty::ty_rptr(r, mt) => {\n-        let m_r = fldr(r);\n-        let m_t = fldt(mt.ty);\n-        ty::mk_rptr(cx, m_r, mt {ty: m_t, mutbl: mt.mutbl})\n-      }\n-      ty_estr(vstore_slice(r)) => {\n-        let m_r = fldr(r);\n-        ty::mk_estr(cx, vstore_slice(m_r))\n-      }\n-      ty_evec(mt, vstore_slice(r)) => {\n-        let m_r = fldr(r);\n-        let m_t = fldt(mt.ty);\n-        ty::mk_evec(cx, mt {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n-      }\n-      ty_enum(def_id, ref substs) => {\n-        ty::mk_enum(cx, def_id, fold_substs(substs, fldr, fldt))\n-      }\n-      ty_struct(def_id, ref substs) => {\n-        ty::mk_struct(cx, def_id, fold_substs(substs, fldr, fldt))\n-      }\n-      ty_trait(def_id, ref substs, st, mutbl, bounds) => {\n-        let st = match st {\n-            RegionTraitStore(region) => RegionTraitStore(fldr(region)),\n-            st => st,\n-        };\n-        ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), st, mutbl, bounds)\n-      }\n-      ty_bare_fn(ref f) => {\n-          ty::mk_bare_fn(cx, BareFnTy {\n-            sig: fold_sig(&f.sig, fldfnt),\n-            purity: f.purity,\n-            abis: f.abis.clone(),\n-          })\n-      }\n-      ty_closure(ref f) => {\n-          ty::mk_closure(cx, ClosureTy {\n-            region: fldr(f.region),\n-            sig: fold_sig(&f.sig, fldfnt),\n-            purity: f.purity,\n-            sigil: f.sigil,\n-            onceness: f.onceness,\n-            bounds: f.bounds,\n-          })\n-      }\n-      ref sty => {\n-        fold_sty_to_ty(cx, sty, |t| fldt(t))\n-      }\n-    }\n-}\n+            match ty::get(t).sty {\n+                ty_param(p) => {\n+                    self.tps[p.idx]\n+                }\n \n-// n.b. this function is intended to eventually replace fold_region() below,\n-// that is why its name is so similar.\n-pub fn fold_regions(\n-    cx: ctxt,\n-    ty: t,\n-    fldr: &fn(r: Region, in_fn: bool) -> Region) -> t {\n-    fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n-               fldr: &fn(Region, bool) -> Region) -> t {\n-        debug!(\"do_fold(ty={}, in_fn={})\", ty_to_str(cx, ty), in_fn);\n-        if !type_has_regions(ty) { return ty; }\n-        fold_regions_and_ty(\n-            cx, ty,\n-            |r| fldr(r, in_fn),\n-            |t| do_fold(cx, t, true,  |r,b| fldr(r,b)),\n-            |t| do_fold(cx, t, in_fn, |r,b| fldr(r,b)))\n-    }\n-    do_fold(cx, ty, false, fldr)\n-}\n+                ty_self(_) => {\n+                    match self.self_ty_opt {\n+                        None => self.tcx.sess.bug(\"ty_self unexpected here\"),\n+                        Some(self_ty) => self_ty\n+                    }\n+                }\n \n-// Substitute *only* type parameters.  Used in trans where regions are erased.\n-pub fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n-    if tps.len() == 0u && self_ty_opt.is_none() { return typ; }\n-    let tb = ty::get(typ);\n-    if self_ty_opt.is_none() && !tbox_has_flag(tb, has_params) { return typ; }\n-    match tb.sty {\n-        ty_param(p) => tps[p.idx],\n-        ty_self(_) => {\n-            match self_ty_opt {\n-                None => cx.sess.bug(\"ty_self unexpected here\"),\n-                Some(self_ty) => {\n-                    subst_tps(cx, tps, self_ty_opt, self_ty)\n+                _ => {\n+                    ty_fold::super_fold_ty(self, t)\n                 }\n             }\n         }\n-        ref sty => {\n-            fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, self_ty_opt, t))\n-        }\n     }\n }\n \n@@ -2256,7 +2150,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             ast::MutMutable => TC::ReachesMutable | TC::OwnsAffine,\n             ast::MutImmutable => TC::None,\n         };\n-        b | (TC::ReachesBorrowed).when(region != ty::re_static)\n+        b | (TC::ReachesBorrowed).when(region != ty::ReStatic)\n     }\n \n     fn closure_contents(cx: ctxt, cty: &ClosureTy) -> TypeContents {\n@@ -2722,55 +2616,6 @@ pub fn index_sty(sty: &sty) -> Option<mt> {\n     }\n }\n \n-/**\n- * Enforces an arbitrary but consistent total ordering over\n- * free regions.  This is needed for establishing a consistent\n- * LUB in region_inference. */\n-impl cmp::TotalOrd for FreeRegion {\n-    fn cmp(&self, other: &FreeRegion) -> Ordering {\n-        cmp::cmp2(&self.scope_id, &self.bound_region,\n-                  &other.scope_id, &other.bound_region)\n-    }\n-}\n-\n-impl cmp::TotalEq for FreeRegion {\n-    fn equals(&self, other: &FreeRegion) -> bool {\n-        *self == *other\n-    }\n-}\n-\n-/**\n- * Enforces an arbitrary but consistent total ordering over\n- * bound regions.  This is needed for establishing a consistent\n- * LUB in region_inference. */\n-impl cmp::TotalOrd for bound_region {\n-    fn cmp(&self, other: &bound_region) -> Ordering {\n-        match (self, other) {\n-            (&ty::br_self, &ty::br_self) => cmp::Equal,\n-            (&ty::br_self, _) => cmp::Less,\n-\n-            (&ty::br_anon(ref a1), &ty::br_anon(ref a2)) => a1.cmp(a2),\n-            (&ty::br_anon(*), _) => cmp::Less,\n-\n-            (&ty::br_named(ref a1), &ty::br_named(ref a2)) => a1.name.cmp(&a2.name),\n-            (&ty::br_named(*), _) => cmp::Less,\n-\n-            (&ty::br_cap_avoid(ref a1, @ref b1),\n-             &ty::br_cap_avoid(ref a2, @ref b2)) => cmp::cmp2(a1, b1, a2, b2),\n-            (&ty::br_cap_avoid(*), _) => cmp::Less,\n-\n-            (&ty::br_fresh(ref a1), &ty::br_fresh(ref a2)) => a1.cmp(a2),\n-            (&ty::br_fresh(*), _) => cmp::Less,\n-        }\n-    }\n-}\n-\n-impl cmp::TotalEq for bound_region {\n-    fn equals(&self, other: &bound_region) -> bool {\n-        *self == *other\n-    }\n-}\n-\n pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     match cx.trait_refs.find(&id) {\n        Some(&t) => t,\n@@ -3679,7 +3524,6 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     load_external: &fn() -> V) -> V\n {\n     /*!\n-     *\n      * Helper for looking things up in the various maps\n      * that are populated during typeck::collect (e.g.,\n      * `cx.methods`, `cx.tcache`, etc).  All of these share\n@@ -3689,8 +3533,8 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n      * the crate loading code (and cache the result for the future).\n      */\n \n-    match map.find(&def_id) {\n-        Some(&ref v) => { return (*v).clone(); }\n+    match map.find_copy(&def_id) {\n+        Some(v) => { return v; }\n         None => { }\n     }\n \n@@ -3728,7 +3572,7 @@ pub fn method(cx: ctxt, id: ast::DefId) -> @Method {\n \n pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @~[DefId] {\n     lookup_locally_or_in_crate_store(\n-        \"methods\", id, cx.trait_method_def_ids,\n+        \"trait_method_def_ids\", id, cx.trait_method_def_ids,\n         || @csearch::get_trait_method_def_ids(cx.cstore, id))\n }\n \n@@ -4354,77 +4198,57 @@ pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> ~[t] {\n \n /// Returns an equivalent type with all the typedefs and self regions removed.\n pub fn normalize_ty(cx: ctxt, t: t) -> t {\n-    fn normalize_mt(cx: ctxt, mt: mt) -> mt {\n-        mt { ty: normalize_ty(cx, mt.ty), mutbl: mt.mutbl }\n-    }\n-    fn normalize_vstore(vstore: vstore) -> vstore {\n-        match vstore {\n-            vstore_fixed(*) | vstore_uniq | vstore_box => vstore,\n-            vstore_slice(_) => vstore_slice(re_static)\n-        }\n-    }\n-\n-    match cx.normalized_cache.find(&t) {\n-      Some(&t) => return t,\n-      None => ()\n-    }\n-\n-    let t = match get(t).sty {\n-        ty_evec(mt, vstore) =>\n-            // This type has a vstore. Get rid of it\n-            mk_evec(cx, normalize_mt(cx, mt), normalize_vstore(vstore)),\n-\n-        ty_estr(vstore) =>\n-            // This type has a vstore. Get rid of it\n-            mk_estr(cx, normalize_vstore(vstore)),\n+    let u = TypeNormalizer(cx).fold_ty(t);\n+    return u;\n \n-        ty_rptr(_, mt) =>\n-            // This type has a region. Get rid of it\n-            mk_rptr(cx, re_static, normalize_mt(cx, mt)),\n+    struct TypeNormalizer(ctxt);\n \n-        ty_closure(ref closure_ty) => {\n-            mk_closure(cx, ClosureTy {\n-                region: ty::re_static,\n-                ..(*closure_ty).clone()\n-            })\n-        }\n+    impl TypeFolder for TypeNormalizer {\n+        fn tcx(&self) -> ty::ctxt { **self }\n \n-        ty_enum(did, ref r) => {\n-            match (*r).regions {\n-                NonerasedRegions(_) => {\n-                    // trans doesn't care about regions\n-                    mk_enum(cx, did, substs {regions: ty::ErasedRegions,\n-                                             self_ty: None,\n-                                             tps: (*r).tps.clone()})\n+        fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+            match self.tcx().normalized_cache.find_copy(&t) {\n+                Some(u) => {\n+                    return u;\n                 }\n-                ErasedRegions => {\n-                    t\n+                None => {\n+                    let t_norm = ty_fold::super_fold_ty(self, t);\n+                    self.tcx().normalized_cache.insert(t, t_norm);\n+                    return t_norm;\n                 }\n             }\n         }\n \n-        ty_struct(did, ref r) => {\n-            match (*r).regions {\n-                NonerasedRegions(_) => {\n-                    // Ditto.\n-                    mk_struct(cx, did, substs {regions: ty::ErasedRegions,\n-                                               self_ty: None,\n-                                               tps: (*r).tps.clone()})\n-                }\n-                ErasedRegions => {\n-                    t\n-                }\n+        fn fold_vstore(&mut self, vstore: vstore) -> vstore {\n+            match vstore {\n+                vstore_fixed(*) | vstore_uniq | vstore_box => vstore,\n+                vstore_slice(_) => vstore_slice(ReStatic)\n             }\n         }\n \n-        _ =>\n-            t\n-    };\n+        fn fold_region(&mut self, _: ty::Region) -> ty::Region {\n+            ty::ReStatic\n+        }\n+\n+        fn fold_substs(&mut self,\n+                       substs: &substs)\n+                       -> substs {\n+            substs { regions: ErasedRegions,\n+                     self_ty: ty_fold::fold_opt_ty(self, substs.self_ty),\n+                     tps: ty_fold::fold_ty_vec(self, substs.tps) }\n+        }\n \n-    let sty = fold_sty(&get(t).sty, |t| { normalize_ty(cx, t) });\n-    let t_norm = mk_t(cx, sty);\n-    cx.normalized_cache.insert(t, t_norm);\n-    return t_norm;\n+        fn fold_sig(&mut self,\n+                    sig: &ty::FnSig)\n+                    -> ty::FnSig {\n+            // The binder-id is only relevant to bound regions, which\n+            // are erased at trans time.\n+            ty::FnSig { binder_id: ast::DUMMY_NODE_ID,\n+                        inputs: ty_fold::fold_ty_vec(self, sig.inputs),\n+                        output: self.fold_ty(sig.output),\n+                        variadic: sig.variadic }\n+        }\n+    }\n }\n \n pub trait ExprTyProvider {\n@@ -4597,6 +4421,12 @@ pub fn visitor_object_ty(tcx: ctxt,\n                  EmptyBuiltinBounds())))\n }\n \n+pub fn item_variances(tcx: ctxt, item_id: ast::DefId) -> @ItemVariances {\n+    lookup_locally_or_in_crate_store(\n+        \"item_variance_map\", item_id, tcx.item_variance_map,\n+        || @csearch::get_item_variances(tcx.cstore, item_id))\n+}\n+\n /// Records a trait-to-implementation mapping.\n fn record_trait_implementation(tcx: ctxt,\n                                trait_def_id: DefId,\n@@ -4737,10 +4567,16 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n     let mut hash = SipState::new(0, 0);\n     let region = |_hash: &mut SipState, r: Region| {\n         match r {\n-            re_static => {}\n-\n-            re_empty | re_bound(*) | re_free(*) | re_scope(*) | re_infer(*) =>\n+            ReStatic => {}\n+\n+            ReEmpty |\n+            ReEarlyBound(*) |\n+            ReLateBound(*) |\n+            ReFree(*) |\n+            ReScope(*) |\n+            ReInfer(*) => {\n                 tcx.sess.bug(\"non-static region found when hashing a type\")\n+            }\n         }\n     };\n     let vstore = |hash: &mut SipState, v: vstore| {\n@@ -4878,3 +4714,90 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n \n     hash.result_u64()\n }\n+\n+impl Variance {\n+    pub fn to_str(self) -> &'static str {\n+        match self {\n+            Covariant => \"+\",\n+            Contravariant => \"-\",\n+            Invariant => \"o\",\n+            Bivariant => \"*\",\n+        }\n+    }\n+}\n+\n+pub fn construct_parameter_environment(\n+    tcx: ctxt,\n+    self_bound: Option<@TraitRef>,\n+    item_type_params: &[TypeParameterDef],\n+    method_type_params: &[TypeParameterDef],\n+    item_region_params: &[RegionParameterDef],\n+    free_id: ast::NodeId)\n+    -> ParameterEnvironment\n+{\n+    /*! See `ParameterEnvironment` struct def'n for details */\n+\n+    //\n+    // Construct the free substs.\n+    //\n+\n+    // map Self => Self\n+    let self_ty = self_bound.map(|t| ty::mk_self(tcx, t.def_id));\n+\n+    // map A => A\n+    let num_item_type_params = item_type_params.len();\n+    let num_method_type_params = method_type_params.len();\n+    let num_type_params = num_item_type_params + num_method_type_params;\n+    let type_params = vec::from_fn(num_type_params, |i| {\n+            let def_id = if i < num_item_type_params {\n+                item_type_params[i].def_id\n+            } else {\n+                method_type_params[i - num_item_type_params].def_id\n+            };\n+\n+            ty::mk_param(tcx, i, def_id)\n+        });\n+\n+    // map bound 'a => free 'a\n+    let region_params = item_region_params.iter().\n+        map(|r| ty::ReFree(ty::FreeRegion {\n+                scope_id: free_id,\n+                bound_region: ty::BrNamed(r.def_id, r.ident)})).\n+        collect();\n+\n+    let free_substs = substs {\n+        self_ty: self_ty,\n+        tps: type_params,\n+        regions: ty::NonerasedRegions(region_params)\n+    };\n+\n+    //\n+    // Compute the bounds on Self and the type parameters.\n+    //\n+\n+    let self_bound_substd = self_bound.map(|b| b.subst(tcx, &free_substs));\n+    let type_param_bounds_substd = vec::from_fn(num_type_params, |i| {\n+        if i < num_item_type_params {\n+            (*item_type_params[i].bounds).subst(tcx, &free_substs)\n+        } else {\n+            let j = i - num_item_type_params;\n+            (*method_type_params[j].bounds).subst(tcx, &free_substs)\n+        }\n+    });\n+\n+    ty::ParameterEnvironment {\n+        free_substs: free_substs,\n+        self_param_bound: self_bound_substd,\n+        type_param_bounds: type_param_bounds_substd,\n+    }\n+}\n+\n+impl substs {\n+    pub fn empty() -> substs {\n+        substs {\n+            self_ty: None,\n+            tps: ~[],\n+            regions: NonerasedRegions(opt_vec::Empty)\n+        }\n+    }\n+}"}, {"sha": "dc4fca0176a5f94ca938af46ca3260349bf7fbef", "filename": "src/librustc/middle/ty_fold.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,286 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Generalized type folding mechanism.\n+\n+use middle::ty;\n+use util::ppaux::Repr;\n+\n+pub trait TypeFolder {\n+    fn tcx(&self) -> ty::ctxt;\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        super_fold_ty(self, t)\n+    }\n+\n+    fn fold_mt(&mut self, t: &ty::mt) -> ty::mt {\n+        super_fold_mt(self, t)\n+    }\n+\n+    fn fold_trait_ref(&mut self, t: &ty::TraitRef) -> ty::TraitRef {\n+        super_fold_trait_ref(self, t)\n+    }\n+\n+    fn fold_sty(&mut self, sty: &ty::sty) -> ty::sty {\n+        super_fold_sty(self, sty)\n+    }\n+\n+    fn fold_substs(&mut self,\n+                   substs: &ty::substs)\n+                   -> ty::substs {\n+        super_fold_substs(self, substs)\n+    }\n+\n+    fn fold_sig(&mut self,\n+                sig: &ty::FnSig)\n+                -> ty::FnSig {\n+        super_fold_sig(self, sig)\n+    }\n+\n+    fn fold_bare_fn_ty(&mut self,\n+                       fty: &ty::BareFnTy)\n+                       -> ty::BareFnTy {\n+        ty::BareFnTy { sig: self.fold_sig(&fty.sig),\n+                       abis: fty.abis,\n+                       purity: fty.purity }\n+    }\n+\n+    fn fold_closure_ty(&mut self,\n+                       fty: &ty::ClosureTy)\n+                       -> ty::ClosureTy {\n+        ty::ClosureTy {\n+            region: self.fold_region(fty.region),\n+            sig: self.fold_sig(&fty.sig),\n+            purity: fty.purity,\n+            sigil: fty.sigil,\n+            onceness: fty.onceness,\n+            bounds: fty.bounds,\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        r\n+    }\n+\n+    fn fold_vstore(&mut self, vstore: ty::vstore) -> ty::vstore {\n+        super_fold_vstore(self, vstore)\n+    }\n+\n+    fn fold_trait_store(&mut self, s: ty::TraitStore) -> ty::TraitStore {\n+        super_fold_trait_store(self, s)\n+    }\n+}\n+\n+pub fn fold_opt_ty<T:TypeFolder>(this: &mut T,\n+                                 t: Option<ty::t>)\n+                                 -> Option<ty::t> {\n+    t.map(|t| this.fold_ty(t))\n+}\n+\n+pub fn fold_ty_vec<T:TypeFolder>(this: &mut T,\n+                                 tys: &[ty::t])\n+                                 -> ~[ty::t] {\n+    tys.map(|t| this.fold_ty(*t))\n+}\n+\n+pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n+                                   t: ty::t)\n+                                   -> ty::t {\n+    ty::mk_t(this.tcx(), this.fold_sty(&ty::get(t).sty))\n+}\n+\n+pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n+                                       substs: &ty::substs)\n+                                       -> ty::substs {\n+    let regions = match substs.regions {\n+        ty::ErasedRegions => {\n+            ty::ErasedRegions\n+        }\n+        ty::NonerasedRegions(ref regions) => {\n+            ty::NonerasedRegions(regions.map(|r| this.fold_region(*r)))\n+        }\n+    };\n+\n+    ty::substs { regions: regions,\n+                 self_ty: fold_opt_ty(this, substs.self_ty),\n+                 tps: fold_ty_vec(this, substs.tps), }\n+}\n+\n+pub fn super_fold_sig<T:TypeFolder>(this: &mut T,\n+                                    sig: &ty::FnSig)\n+                                    -> ty::FnSig {\n+    ty::FnSig { binder_id: sig.binder_id,\n+                inputs: fold_ty_vec(this, sig.inputs),\n+                output: this.fold_ty(sig.output),\n+                variadic: sig.variadic }\n+}\n+\n+pub fn super_fold_trait_ref<T:TypeFolder>(this: &mut T,\n+                                          t: &ty::TraitRef)\n+                                          -> ty::TraitRef {\n+    ty::TraitRef {\n+        def_id: t.def_id,\n+        substs: this.fold_substs(&t.substs)\n+    }\n+}\n+\n+pub fn super_fold_mt<T:TypeFolder>(this: &mut T,\n+                                   mt: &ty::mt) -> ty::mt {\n+    ty::mt {ty: this.fold_ty(mt.ty),\n+            mutbl: mt.mutbl}\n+}\n+\n+pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n+                                    sty: &ty::sty) -> ty::sty {\n+    match *sty {\n+        ty::ty_box(ref tm) => {\n+            ty::ty_box(this.fold_mt(tm))\n+        }\n+        ty::ty_uniq(ref tm) => {\n+            ty::ty_uniq(this.fold_mt(tm))\n+        }\n+        ty::ty_ptr(ref tm) => {\n+            ty::ty_ptr(this.fold_mt(tm))\n+        }\n+        ty::ty_unboxed_vec(ref tm) => {\n+            ty::ty_unboxed_vec(this.fold_mt(tm))\n+        }\n+        ty::ty_evec(ref tm, vst) => {\n+            ty::ty_evec(this.fold_mt(tm),\n+                        this.fold_vstore(vst))\n+        }\n+        ty::ty_enum(tid, ref substs) => {\n+            ty::ty_enum(tid, this.fold_substs(substs))\n+        }\n+        ty::ty_trait(did, ref substs, st, mutbl, bounds) => {\n+            ty::ty_trait(did,\n+                     this.fold_substs(substs),\n+                     this.fold_trait_store(st),\n+                     mutbl,\n+                     bounds)\n+        }\n+        ty::ty_tup(ref ts) => {\n+            ty::ty_tup(fold_ty_vec(this, *ts))\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            ty::ty_bare_fn(this.fold_bare_fn_ty(f))\n+        }\n+        ty::ty_closure(ref f) => {\n+            ty::ty_closure(this.fold_closure_ty(f))\n+        }\n+        ty::ty_rptr(r, ref tm) => {\n+            ty::ty_rptr(this.fold_region(r),\n+                        ty::mt {ty: this.fold_ty(tm.ty),\n+                                mutbl: tm.mutbl})\n+        }\n+        ty::ty_struct(did, ref substs) => {\n+            ty::ty_struct(did,\n+                          this.fold_substs(substs))\n+        }\n+        ty::ty_estr(vst) => {\n+            ty::ty_estr(this.fold_vstore(vst))\n+        }\n+        ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char |\n+        ty::ty_int(_) | ty::ty_uint(_) |\n+        ty::ty_float(_) | ty::ty_type |\n+        ty::ty_opaque_closure_ptr(_) |\n+        ty::ty_err | ty::ty_opaque_box | ty::ty_infer(_) |\n+        ty::ty_param(*) | ty::ty_self(_) => {\n+            (*sty).clone()\n+        }\n+    }\n+}\n+\n+pub fn super_fold_vstore<T:TypeFolder>(this: &mut T,\n+                                       vstore: ty::vstore)\n+                                       -> ty::vstore {\n+    match vstore {\n+        ty::vstore_fixed(i) => ty::vstore_fixed(i),\n+        ty::vstore_uniq => ty::vstore_uniq,\n+        ty::vstore_box => ty::vstore_box,\n+        ty::vstore_slice(r) => ty::vstore_slice(this.fold_region(r)),\n+    }\n+}\n+\n+pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n+                                            trait_store: ty::TraitStore)\n+                                            -> ty::TraitStore {\n+    match trait_store {\n+        ty::UniqTraitStore      => ty::UniqTraitStore,\n+        ty::BoxTraitStore       => ty::BoxTraitStore,\n+        ty::RegionTraitStore(r) => ty::RegionTraitStore(this.fold_region(r)),\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Some sample folders\n+\n+pub struct BottomUpFolder<'self> {\n+    tcx: ty::ctxt,\n+    fldop: &'self fn(ty::t) -> ty::t,\n+}\n+\n+impl<'self> TypeFolder for BottomUpFolder<'self> {\n+    fn tcx(&self) -> ty::ctxt { self.tcx }\n+\n+    fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n+        let t1 = super_fold_ty(self, ty);\n+        (self.fldop)(t1)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Region folder\n+\n+pub struct RegionFolder<'self> {\n+    tcx: ty::ctxt,\n+    fld_t: &'self fn(ty::t) -> ty::t,\n+    fld_r: &'self fn(ty::Region) -> ty::Region,\n+}\n+\n+impl<'self> RegionFolder<'self> {\n+    pub fn general(tcx: ty::ctxt,\n+                   fld_r: &'self fn(ty::Region) -> ty::Region,\n+                   fld_t: &'self fn(ty::t) -> ty::t)\n+                   -> RegionFolder<'self> {\n+        RegionFolder {\n+            tcx: tcx,\n+            fld_t: fld_t,\n+            fld_r: fld_r\n+        }\n+    }\n+\n+    pub fn regions(tcx: ty::ctxt,\n+                   fld_r: &'self fn(ty::Region) -> ty::Region)\n+                   -> RegionFolder<'self> {\n+        fn noop(t: ty::t) -> ty::t { t }\n+\n+        RegionFolder {\n+            tcx: tcx,\n+            fld_t: noop,\n+            fld_r: fld_r\n+        }\n+    }\n+}\n+\n+impl<'self> TypeFolder for RegionFolder<'self> {\n+    fn tcx(&self) -> ty::ctxt { self.tcx }\n+\n+    fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n+        debug!(\"RegionFolder.fold_ty({})\", ty.repr(self.tcx()));\n+        let t1 = super_fold_ty(self, ty);\n+        (self.fld_t)(t1)\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        debug!(\"RegionFolder.fold_region({})\", r.repr(self.tcx()));\n+        (self.fld_r)(r)\n+    }\n+}"}, {"sha": "57581306b5d5d24d152f92c8cd17eca87ed35b6c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 136, "deletions": 166, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -23,13 +23,10 @@\n  * In the check phase, when the @FnCtxt is used as the `AstConv`,\n  * `get_item_ty()` just looks up the item type in `tcx.tcache`.\n  *\n- * The `RegionScope` trait controls how region references are\n- * handled.  It has two methods which are used to resolve anonymous\n- * region references (e.g., `&T`) and named region references (e.g.,\n- * `&a.T`).  There are numerous region scopes that can be used, but most\n- * commonly you want either `EmptyRscope`, which permits only the static\n- * region, or `TypeRscope`, which permits the self region if the type in\n- * question is parameterized by a region.\n+ * The `RegionScope` trait controls what happens when the user does\n+ * not specify a region in some location where a region is required\n+ * (e.g., if the user writes `&Foo` as a type rather than `&'a Foo`).\n+ * See the `rscope` module for more details.\n  *\n  * Unlike the `AstConv` trait, the region scope can change as we descend\n  * the type.  This is to accommodate the fact that (a) fn types are binding\n@@ -57,20 +54,17 @@ use middle::const_eval;\n use middle::ty::{substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n-use middle::typeck::rscope::in_binding_rscope;\n-use middle::typeck::rscope::{RegionScope, RegionError};\n-use middle::typeck::rscope::RegionParamNames;\n+use middle::typeck::rscope;\n+use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n \n-use std::result;\n+use std::vec;\n use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n-use syntax::parse::token::special_idents;\n-use util::common::indenter;\n \n pub trait AstConv {\n     fn tcx(&self) -> ty::ctxt;\n@@ -81,64 +75,90 @@ pub trait AstConv {\n     fn ty_infer(&self, span: Span) -> ty::t;\n }\n \n-pub fn get_region_reporting_err(\n+pub fn ast_region_to_region(\n     tcx: ty::ctxt,\n-    span: Span,\n-    a_r: &Option<ast::Lifetime>,\n-    res: Result<ty::Region, RegionError>) -> ty::Region\n+    lifetime: &ast::Lifetime)\n+    -> ty::Region\n {\n-    match res {\n-        result::Ok(r) => r,\n-        result::Err(ref e) => {\n-            let descr = match a_r {\n-                &None => ~\"anonymous lifetime\",\n-                &Some(ref a) => format!(\"lifetime {}\",\n-                                lifetime_to_str(a, tcx.sess.intr()))\n-            };\n-            tcx.sess.span_err(\n-                span,\n-                format!(\"Illegal {}: {}\",\n-                     descr, e.msg));\n-            e.replacement\n+    let r = match tcx.named_region_map.find(&lifetime.id) {\n+        None => {\n+            // should have been recorded by the `resolve_lifetime` pass\n+            tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n         }\n-    }\n+\n+        Some(&ast::DefStaticRegion) => {\n+            ty::ReStatic\n+        }\n+\n+        Some(&ast::DefLateBoundRegion(binder_id, _, id)) => {\n+            ty::ReLateBound(binder_id, ty::BrNamed(ast_util::local_def(id),\n+                                                   lifetime.ident))\n+        }\n+\n+        Some(&ast::DefEarlyBoundRegion(index, id)) => {\n+            ty::ReEarlyBound(id, index, lifetime.ident)\n+        }\n+\n+        Some(&ast::DefFreeRegion(scope_id, id)) => {\n+            ty::ReFree(ty::FreeRegion {\n+                    scope_id: scope_id,\n+                    bound_region: ty::BrNamed(ast_util::local_def(id),\n+                                              lifetime.ident)\n+                })\n+        }\n+    };\n+\n+    debug!(\"ast_region_to_region(lifetime={} id={}) yields {}\",\n+            lifetime_to_str(lifetime, tcx.sess.intr()),\n+            lifetime.id,\n+            r.repr(tcx));\n+\n+    r\n }\n \n-pub fn ast_region_to_region<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     default_span: Span,\n     opt_lifetime: &Option<ast::Lifetime>) -> ty::Region\n {\n-    let (span, res) = match opt_lifetime {\n-        &None => {\n-            (default_span, rscope.anon_region(default_span))\n-        }\n-        &Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n-            (lifetime.span, Ok(ty::re_static))\n-        }\n-        &Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n-            (lifetime.span, rscope.self_region(lifetime.span))\n+    let r = match *opt_lifetime {\n+        Some(ref lifetime) => {\n+            ast_region_to_region(this.tcx(), lifetime)\n         }\n-        &Some(ref lifetime) => {\n-            (lifetime.span, rscope.named_region(lifetime.span,\n-                                                lifetime.ident))\n+\n+        None => {\n+            match rscope.anon_regions(default_span, 1) {\n+                Err(()) => {\n+                    debug!(\"optional region in illegal location\");\n+                    this.tcx().sess.span_err(\n+                        default_span, \"missing lifetime specifier\");\n+                    ty::ReStatic\n+                }\n+\n+                Ok(rs) => {\n+                    rs[0]\n+                }\n+            }\n         }\n     };\n \n-    get_region_reporting_err(this.tcx(), span, opt_lifetime, res)\n+    debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {}\",\n+            opt_lifetime.as_ref().map(\n+                |e| lifetime_to_str(e, this.tcx().sess.intr())),\n+            r.repr(this.tcx()));\n+\n+    r\n }\n \n-fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n-    def_id: ast::DefId,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n     path: &ast::Path) -> ty::substs\n {\n     /*!\n-     *\n      * Given a path `path` that refers to an item `I` with the\n      * declared generics `decl_generics`, returns an appropriate\n      * set of substitutions for this particular reference to `I`.\n@@ -149,30 +169,28 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let regions = match (&decl_generics.region_param,\n-                         &path.segments.last().lifetime) {\n-        (&None, &None) => {\n-            opt_vec::Empty\n-        }\n-        (&None, &Some(_)) => {\n+    let expected_num_region_params = decl_generics.region_param_defs.len();\n+    let supplied_num_region_params = path.segments.last().lifetimes.len();\n+    let regions = if expected_num_region_params == supplied_num_region_params {\n+        path.segments.last().lifetimes.map(\n+            |l| ast_region_to_region(this.tcx(), l))\n+    } else {\n+        let anon_regions =\n+            rscope.anon_regions(path.span, expected_num_region_params);\n+\n+        if supplied_num_region_params != 0 || anon_regions.is_err() {\n             tcx.sess.span_err(\n                 path.span,\n-                format!(\"no region bound is allowed on `{}`, \\\n-                      which is not declared as containing region pointers\",\n-                     ty::item_path_str(tcx, def_id)));\n-            opt_vec::Empty\n+                format!(\"wrong number of lifetime parameters: \\\n+                        expected {} but found {}\",\n+                        expected_num_region_params,\n+                        supplied_num_region_params));\n         }\n-        (&Some(_), &None) => {\n-            let res = rscope.anon_region(path.span);\n-            let r = get_region_reporting_err(this.tcx(), path.span, &None, res);\n-            opt_vec::with(r)\n-        }\n-        (&Some(_), &Some(_)) => {\n-            opt_vec::with(\n-                ast_region_to_region(this,\n-                                     rscope,\n-                                     path.span,\n-                                     &path.segments.last().lifetime))\n+\n+        match anon_regions {\n+            Ok(v) => opt_vec::from(v),\n+            Err(()) => opt_vec::from(vec::from_fn(expected_num_region_params,\n+                                                  |_| ty::ReStatic)) // hokey\n         }\n     };\n \n@@ -200,7 +218,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope + Clone + 'static>(\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,\n-                                 RS:RegionScope + Clone + 'static>(\n+                                 RS:RegionScope>(\n                                  this: &AC,\n                                  rscope: &RS,\n                                  did: ast::DefId,\n@@ -212,12 +230,12 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,\n         ty: decl_ty\n     } = this.get_item_ty(did);\n \n-    let substs = ast_path_substs(this, rscope, did, &generics, None, path);\n+    let substs = ast_path_substs(this, rscope, &generics, None, path);\n     let ty = ty::subst(tcx, &substs, decl_ty);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n \n-pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n@@ -230,7 +248,6 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope + Clone + 'static>(\n         ast_path_substs(\n             this,\n             rscope,\n-            trait_def.trait_ref.def_id,\n             &trait_def.generics,\n             self_ty,\n             path);\n@@ -240,7 +257,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     return trait_ref;\n }\n \n-pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         did: ast::DefId,\n@@ -260,12 +277,11 @@ pub static NO_REGIONS: uint = 1;\n pub static NO_TPS: uint = 2;\n \n // Parses the programmer's textual representation of a type into our\n-// internal notion of a type. `getter` is a function that returns the type\n-// corresponding to a definition ID:\n-pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n+// internal notion of a type.\n+pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n \n-    fn ast_mt_to_mt<AC:AstConv, RS:RegionScope + Clone + 'static>(\n+    fn ast_mt_to_mt<AC:AstConv, RS:RegionScope>(\n         this: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {\n \n         ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n@@ -274,21 +290,23 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle first-class trait types.\n-    fn mk_pointer<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+    fn mk_pointer<AC:AstConv,RS:RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         a_seq_ty: &ast::mt,\n         vst: ty::vstore,\n         constr: &fn(ty::mt) -> ty::t) -> ty::t\n     {\n         let tcx = this.tcx();\n+        debug!(\"mk_pointer(vst={:?})\", vst);\n \n         match a_seq_ty.ty.node {\n             ast::ty_vec(ref mt) => {\n                 let mut mt = ast_mt_to_mt(this, rscope, mt);\n                 if a_seq_ty.mutbl == ast::MutMutable {\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n                 }\n+                debug!(\"&[]: vst={:?}\", vst);\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n             ast::ty_path(ref path, ref bounds, id) => {\n@@ -347,7 +365,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n         }\n \n         if (flags & NO_REGIONS) != 0u {\n-            if path.segments.last().lifetime.is_some() {\n+            if !path.segments.last().lifetimes.is_empty() {\n                 tcx.sess.span_err(\n                     path.span,\n                     \"region parameters are not allowed on this type\");\n@@ -387,7 +405,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n         ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n       }\n       ast::ty_rptr(ref region, ref mt) => {\n-        let r = ast_region_to_region(this, rscope, ast_ty.span, region);\n+        let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n+        debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n         mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n@@ -399,8 +418,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n           if bf.decl.variadic && !bf.abis.is_c() {\n             tcx.sess.span_err(ast_ty.span, \"variadic function must have C calling convention\");\n           }\n-          ty::mk_bare_fn(tcx, ty_of_bare_fn(this, rscope, bf.purity,\n-                                            bf.abis, &bf.lifetimes, &bf.decl))\n+          ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n+                                            bf.abis, &bf.decl))\n       }\n       ast::ty_closure(ref f) => {\n         if f.sigil == ast::ManagedSigil {\n@@ -411,20 +430,20 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n           let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n               // Use corresponding trait store to figure out default bounds\n               // if none were specified.\n-              ast::BorrowedSigil => ty::RegionTraitStore(ty::re_empty), // dummy region\n+              ast::BorrowedSigil => ty::RegionTraitStore(ty::ReEmpty), // dummy region\n               ast::OwnedSigil    => ty::UniqTraitStore,\n               ast::ManagedSigil  => ty::BoxTraitStore,\n           });\n           let fn_decl = ty_of_closure(this,\n                                       rscope,\n+                                      ast_ty.id,\n                                       f.sigil,\n                                       f.purity,\n                                       f.onceness,\n                                       bounds,\n                                       &f.region,\n                                       &f.decl,\n                                       None,\n-                                      &f.lifetimes,\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n@@ -551,7 +570,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n }\n \n pub fn ty_of_arg<AC:AstConv,\n-                 RS:RegionScope + Clone + 'static>(\n+                 RS:RegionScope>(\n                  this: &AC,\n                  rscope: &RS,\n                  a: &ast::arg,\n@@ -564,46 +583,15 @@ pub fn ty_of_arg<AC:AstConv,\n     }\n }\n \n-pub fn bound_lifetimes<AC:AstConv>(\n-    this: &AC,\n-    ast_lifetimes: &OptVec<ast::Lifetime>) -> OptVec<ast::Ident>\n-{\n-    /*!\n-     *\n-     * Converts a list of lifetimes into a list of bound identifier\n-     * names.  Does not permit special names like 'static or 'this to\n-     * be bound.  Note that this function is for use in closures,\n-     * methods, and fn definitions.  It is legal to bind 'this in a\n-     * type.  Eventually this distinction should go away and the same\n-     * rules should apply everywhere ('this would not be a special name\n-     * at that point).\n-     */\n-\n-    let special_idents = [special_idents::statik, special_idents::self_];\n-    let mut bound_lifetime_names = opt_vec::Empty;\n-    ast_lifetimes.map_to_vec(|ast_lifetime| {\n-        if special_idents.iter().any(|&i| i == ast_lifetime.ident) {\n-            this.tcx().sess.span_err(\n-                ast_lifetime.span,\n-                format!(\"illegal lifetime parameter name: `{}`\",\n-                     lifetime_to_str(ast_lifetime, this.tcx().sess.intr())));\n-        } else {\n-            bound_lifetime_names.push(ast_lifetime.ident);\n-        }\n-    });\n-    bound_lifetime_names\n-}\n-\n struct SelfInfo {\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::explicit_self\n }\n \n-pub fn ty_of_method<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ty_of_method<AC:AstConv>(\n     this: &AC,\n-    rscope: &RS,\n+    id: ast::NodeId,\n     purity: ast::purity,\n-    lifetimes: &OptVec<ast::Lifetime>,\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::explicit_self,\n     decl: &ast::fn_decl) -> (Option<ty::t>, ty::BareFnTy)\n@@ -613,40 +601,35 @@ pub fn ty_of_method<AC:AstConv,RS:RegionScope + Clone + 'static>(\n         explicit_self: explicit_self\n     };\n     let (a, b) = ty_of_method_or_bare_fn(\n-        this, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n+        this, id, purity, AbiSet::Rust(), Some(&self_info), decl);\n     (a.unwrap(), b)\n }\n \n-pub fn ty_of_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ty_of_bare_fn<AC:AstConv>(\n     this: &AC,\n-    rscope: &RS,\n+    id: ast::NodeId,\n     purity: ast::purity,\n     abi: AbiSet,\n-    lifetimes: &OptVec<ast::Lifetime>,\n     decl: &ast::fn_decl) -> ty::BareFnTy\n {\n-    let (_, b) = ty_of_method_or_bare_fn(\n-        this, rscope, purity, abi, lifetimes, None, decl);\n+    let (_, b) = ty_of_method_or_bare_fn(this, id, purity,\n+                                         abi, None, decl);\n     b\n }\n \n-fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+fn ty_of_method_or_bare_fn<AC:AstConv>(\n     this: &AC,\n-    rscope: &RS,\n+    id: ast::NodeId,\n     purity: ast::purity,\n     abi: AbiSet,\n-    lifetimes: &OptVec<ast::Lifetime>,\n     opt_self_info: Option<&SelfInfo>,\n     decl: &ast::fn_decl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n {\n-    debug!(\"ty_of_bare_fn\");\n+    debug!(\"ty_of_method_or_bare_fn\");\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n-    let rb =\n-        in_binding_rscope(rscope,\n-                          RegionParamNames(bound_lifetime_names.clone()));\n+    let rb = rscope::BindingRscope::new(id);\n \n     let opt_transformed_self_ty = do opt_self_info.map |self_info| {\n         transform_self_ty(this, &rb, self_info)\n@@ -663,15 +646,13 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n             ty::BareFnTy {\n                 purity: purity,\n                 abis: abi,\n-                sig: ty::FnSig {\n-                    bound_lifetime_names: bound_lifetime_names,\n-                    inputs: input_tys,\n-                    output: output_ty,\n-                    variadic: decl.variadic\n-                }\n+                sig: ty::FnSig {binder_id: id,\n+                                inputs: input_tys,\n+                                output: output_ty,\n+                                variadic: decl.variadic}\n             });\n \n-    fn transform_self_ty<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+    fn transform_self_ty<AC:AstConv,RS:RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         self_info: &SelfInfo) -> Option<ty::t>\n@@ -683,9 +664,9 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n             }\n             ast::sty_region(ref lifetime, mutability) => {\n                 let region =\n-                    ast_region_to_region(this, rscope,\n-                                         self_info.explicit_self.span,\n-                                         lifetime);\n+                    opt_ast_region_to_region(this, rscope,\n+                                             self_info.explicit_self.span,\n+                                             lifetime);\n                 Some(ty::mk_rptr(this.tcx(), region,\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n@@ -704,55 +685,46 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n     }\n }\n \n-pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n+    id: ast::NodeId,\n     sigil: ast::Sigil,\n     purity: ast::purity,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n     opt_lifetime: &Option<ast::Lifetime>,\n     decl: &ast::fn_decl,\n     expected_sig: Option<ty::FnSig>,\n-    lifetimes: &OptVec<ast::Lifetime>,\n     span: Span)\n     -> ty::ClosureTy\n {\n-    // The caller should not both provide explicit bound lifetime\n-    // names and expected types.  Either we infer the bound lifetime\n-    // names or they are provided, but not both.\n-    assert!(lifetimes.is_empty() || expected_sig.is_none());\n-\n     debug!(\"ty_of_fn_decl\");\n-    let _i = indenter();\n \n     // resolve the function bound region in the original region\n     // scope `rscope`, not the scope of the function parameters\n     let bound_region = match opt_lifetime {\n-        &Some(_) => {\n-            ast_region_to_region(this, rscope, span, opt_lifetime)\n+        &Some(ref lifetime) => {\n+            ast_region_to_region(this.tcx(), lifetime)\n         }\n         &None => {\n             match sigil {\n                 ast::OwnedSigil | ast::ManagedSigil => {\n                     // @fn(), ~fn() default to static as the bound\n                     // on their upvars:\n-                    ty::re_static\n+                    ty::ReStatic\n                 }\n                 ast::BorrowedSigil => {\n                     // &fn() defaults as normal for an omitted lifetime:\n-                    ast_region_to_region(this, rscope, span, opt_lifetime)\n+                    opt_ast_region_to_region(this, rscope, span, opt_lifetime)\n                 }\n             }\n         }\n     };\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n-    let rb =\n-        in_binding_rscope(rscope,\n-                          RegionParamNames(bound_lifetime_names.clone()));\n+    let rb = rscope::BindingRscope::new(id);\n \n     let input_tys = do decl.inputs.iter().enumerate().map |(i, a)| {\n         let expected_arg_ty = do expected_sig.as_ref().and_then |e| {\n@@ -776,12 +748,10 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope + Clone + 'static>(\n         onceness: onceness,\n         region: bound_region,\n         bounds: bounds,\n-        sig: ty::FnSig {\n-            bound_lifetime_names: bound_lifetime_names,\n-            inputs: input_tys,\n-            output: output_ty,\n-            variadic: decl.variadic\n-        }\n+        sig: ty::FnSig {binder_id: id,\n+                        inputs: input_tys,\n+                        output: output_ty,\n+                        variadic: decl.variadic}\n     }\n }\n \n@@ -832,7 +802,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n         // @Trait is sugar for @Trait:'static.\n         // &'static Trait is sugar for &'static Trait:'static.\n         (&None, ty::BoxTraitStore) |\n-        (&None, ty::RegionTraitStore(ty::re_static)) => {\n+        (&None, ty::RegionTraitStore(ty::ReStatic)) => {\n             let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundStatic); set\n         }\n         // &'r Trait is sugar for &'r Trait:<no-bounds>."}, {"sha": "870b29882fd6eb167309d3e5a92a56009476f930", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -85,7 +85,6 @@ use middle::ty::*;\n use middle::ty;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n-use middle::typeck::check::vtable::VtableContext;\n use middle::typeck::check::vtable;\n use middle::typeck::check;\n use middle::typeck::infer;\n@@ -99,7 +98,6 @@ use util::ppaux::Repr;\n use std::hashmap::HashSet;\n use std::result;\n use std::vec;\n-use extra::list::Nil;\n use syntax::ast::{DefId, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, NodeId};\n use syntax::ast::{MutMutable, MutImmutable};\n@@ -265,8 +263,7 @@ impl<'self> LookupContext<'self> {\n         self.search_for_autosliced_method(self_ty, autoderefs)\n     }\n \n-    fn deref(&self, ty: ty::t)\n-                 -> Option<ty::t> {\n+    fn deref(&self, ty: ty::t) -> Option<ty::t> {\n         match ty::deref(self.tcx(), ty, false) {\n             None => None,\n             Some(t) => {\n@@ -327,11 +324,10 @@ impl<'self> LookupContext<'self> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, p);\n                 }\n-                ty_self(self_did) => {\n+                ty_self(*) => {\n                     // Call is of the form \"self.foo()\" and appears in one\n                     // of a trait's default method implementations.\n-                    self.push_inherent_candidates_from_self(\n-                        self_ty, self_did);\n+                    self.push_inherent_candidates_from_self(self_ty);\n                 }\n                 _ => { /* No bound methods in these types */ }\n             }\n@@ -448,32 +444,20 @@ impl<'self> LookupContext<'self> {\n                                            param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n                param_ty);\n-        let _indenter = indenter();\n-\n-        let tcx = self.tcx();\n-        let type_param_def = match tcx.ty_param_defs.find(&param_ty.def_id.node) {\n-            Some(t) => t,\n-            None => {\n-                tcx.sess.span_bug(\n-                    self.expr.span,\n-                    format!(\"No param def for {:?}\", param_ty));\n-            }\n-        };\n-\n         self.push_inherent_candidates_from_bounds(\n-            rcvr_ty, type_param_def.bounds.trait_bounds,\n+            rcvr_ty,\n+            self.fcx.inh.param_env.type_param_bounds[param_ty.idx].trait_bounds,\n             param_numbered(param_ty.idx));\n     }\n \n \n     fn push_inherent_candidates_from_self(&self,\n-                                              self_ty: ty::t,\n-                                              did: DefId) {\n-        let tcx = self.tcx();\n-\n-        let trait_ref = ty::lookup_trait_def(tcx, did).trait_ref;\n+                                          rcvr_ty: ty::t) {\n+        debug!(\"push_inherent_candidates_from_self()\");\n         self.push_inherent_candidates_from_bounds(\n-            self_ty, &[trait_ref], param_self);\n+            rcvr_ty,\n+            [self.fcx.inh.param_env.self_param_bound.unwrap()],\n+            param_self)\n     }\n \n     fn push_inherent_candidates_from_bounds(&self,\n@@ -574,10 +558,7 @@ impl<'self> LookupContext<'self> {\n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n         let location_info = &vtable::location_info_for_expr(self.self_expr);\n-        let vcx = VtableContext {\n-            ccx: self.fcx.ccx,\n-            infcx: self.fcx.infcx()\n-        };\n+        let vcx = self.fcx.vtable_context();\n         let ty::ty_param_substs_and_ty {\n             substs: impl_substs,\n             ty: impl_ty\n@@ -1010,7 +991,7 @@ impl<'self> LookupContext<'self> {\n         };\n         let (_, opt_transformed_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n-                tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n+                tcx, Some(transformed_self_ty), &bare_fn_ty.sig,\n                 |br| self.fcx.infcx().next_region_var(\n                     infer::BoundRegionInFnCall(self.expr.span, br)));\n         let transformed_self_ty = opt_transformed_self_ty.unwrap();"}, {"sha": "98d154a8d73b684da2a096fedf3a552cbe387a92", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 558, "deletions": 317, "changes": 875, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -81,10 +81,12 @@ use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::lint::unreachable_code;\n+use middle::subst::Subst;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty::{substs, param_ty, Disr, ExprTyProvider};\n use middle::ty;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n@@ -99,22 +101,18 @@ use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n-use middle::typeck::rscope::bound_self_region;\n-use middle::typeck::rscope::{RegionError};\n use middle::typeck::rscope::RegionScope;\n-use middle::typeck::{isr_alist, lookup_def_ccx};\n+use middle::typeck::{lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types, method_map, vtable_map};\n use util::common::{block_query, indenter, loop_query};\n-use util::ppaux::{bound_region_ptr_to_str};\n+use util::ppaux::UserString;\n use util::ppaux;\n \n-\n use std::hashmap::HashMap;\n use std::result;\n use std::util::replace;\n use std::vec;\n-use extra::list::Nil;\n use syntax::abi::AbiSet;\n use syntax::ast::{provided, required};\n use syntax::ast;\n@@ -127,7 +125,6 @@ use syntax::codemap;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::parse::token;\n-use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -157,9 +154,10 @@ pub struct SelfInfo {\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct inherited {\n+pub struct Inherited {\n     infcx: @mut infer::InferCtxt,\n     locals: @mut HashMap<ast::NodeId, ty::t>,\n+    param_env: ty::ParameterEnvironment,\n \n     // Temporary tables:\n     node_types: @mut HashMap<ast::NodeId, ty::t>,\n@@ -249,40 +247,45 @@ pub struct FnCtxt {\n     // function return type.\n     fn_kind: FnKind,\n \n-    in_scope_regions: isr_alist,\n-\n-    inh: @inherited,\n+    inh: @Inherited,\n \n     ccx: @mut CrateCtxt,\n }\n \n-pub fn blank_inherited(ccx: @mut CrateCtxt) -> @inherited {\n-    @inherited {\n-        infcx: infer::new_infer_ctxt(ccx.tcx),\n-        locals: @mut HashMap::new(),\n-        node_types: @mut HashMap::new(),\n-        node_type_substs: @mut HashMap::new(),\n-        adjustments: @mut HashMap::new(),\n-        method_map: @mut HashMap::new(),\n-        vtable_map: @mut HashMap::new(),\n+impl Inherited {\n+    fn new(tcx: ty::ctxt,\n+           param_env: ty::ParameterEnvironment)\n+           -> Inherited {\n+        Inherited {\n+            infcx: infer::new_infer_ctxt(tcx),\n+            locals: @mut HashMap::new(),\n+            param_env: param_env,\n+            node_types: @mut HashMap::new(),\n+            node_type_substs: @mut HashMap::new(),\n+            adjustments: @mut HashMap::new(),\n+            method_map: @mut HashMap::new(),\n+            vtable_map: @mut HashMap::new(),\n+        }\n     }\n }\n \n // Used by check_const and check_enum_variants\n pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n                      rty: ty::t,\n                      region_bnd: ast::NodeId)\n-                  -> @mut FnCtxt {\n-// It's kind of a kludge to manufacture a fake function context\n-// and statement context, but we might as well do write the code only once\n+                     -> @mut FnCtxt {\n+    // It's kind of a kludge to manufacture a fake function context\n+    // and statement context, but we might as well do write the code only once\n+    let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n+                                               self_param_bound: None,\n+                                               type_param_bounds: ~[] };\n     @mut FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n         ps: PurityState::function(ast::impure_fn, 0),\n         region_lb: region_bnd,\n-        in_scope_regions: @Nil,\n         fn_kind: Vanilla,\n-        inh: blank_inherited(ccx),\n+        inh: @Inherited::new(ccx.tcx, param_env),\n         ccx: ccx\n     }\n }\n@@ -315,14 +318,15 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n                      id: ast::NodeId,\n-                     self_info: Option<SelfInfo>) {\n-    let fty = ty::node_id_to_type(ccx.tcx, id);\n+                     self_info: Option<SelfInfo>,\n+                     fty: ty::t,\n+                     param_env: ty::ParameterEnvironment) {\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let fcx =\n                 check_fn(ccx, self_info, fn_ty.purity,\n                          &fn_ty.sig, decl, id, body, Vanilla,\n-                         @Nil, blank_inherited(ccx));;\n+                         @Inherited::new(ccx.tcx, param_env));\n \n             vtable::resolve_in_block(fcx, body);\n             regionck::regionck_fn(fcx, body);\n@@ -411,39 +415,35 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 id: ast::NodeId,\n                 body: &ast::Block,\n                 fn_kind: FnKind,\n-                inherited_isr: isr_alist,\n-                inherited: @inherited) -> @mut FnCtxt\n+                inherited: @Inherited) -> @mut FnCtxt\n {\n     /*!\n-     *\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n      * grungy work of checking a function body and returns the\n      * function context used for that purpose, since in the case of a\n      * fn item there is still a bit more to do.\n      *\n      * - ...\n-     * - inherited_isr: regions in scope from the enclosing fn (if any)\n      * - inherited: other fields inherited from the enclosing fn (if any)\n      */\n \n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    // ______________________________________________________________________\n     // First, we have to replace any bound regions in the fn and self\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n-    let (isr, opt_self_info, fn_sig) = {\n+    let (opt_self_info, fn_sig) = {\n         let opt_self_ty = opt_self_info.map(|i| i.self_ty);\n-        let (isr, opt_self_ty, fn_sig) =\n+        let (_, opt_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n-                tcx, inherited_isr, opt_self_ty, fn_sig,\n-                |br| ty::re_free(ty::FreeRegion {scope_id: body.id,\n+                tcx, opt_self_ty, fn_sig,\n+                |br| ty::ReFree(ty::FreeRegion {scope_id: body.id,\n                                                  bound_region: br}));\n         let opt_self_info =\n             opt_self_info.map(\n                 |si| SelfInfo {self_ty: opt_self_ty.unwrap(), .. si});\n-        (isr, opt_self_info, fn_sig)\n+        (opt_self_info, fn_sig)\n     };\n \n     relate_free_regions(tcx, opt_self_info.map(|s| s.self_ty), &fn_sig);\n@@ -456,7 +456,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n            ppaux::ty_to_str(tcx, ret_ty),\n            opt_self_info.map(|si| ppaux::ty_to_str(tcx, si.self_ty)));\n \n-    // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @mut FnCtxt = {\n@@ -465,7 +464,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             ret_ty: ret_ty,\n             ps: PurityState::function(purity, id),\n             region_lb: body.id,\n-            in_scope_regions: isr,\n             fn_kind: fn_kind,\n             inh: inherited,\n             ccx: ccx\n@@ -536,26 +534,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn check_method(ccx: @mut CrateCtxt,\n-                    method: @ast::method)\n-{\n-    let method_def_id = local_def(method.id);\n-    let method_ty = ty::method(ccx.tcx, method_def_id);\n-    let opt_self_info = method_ty.transformed_self_ty.map(|ty| {\n-        SelfInfo {self_ty: ty,\n-                  self_id: method.self_id,\n-                  span: method.explicit_self.span}\n-    });\n-\n-    check_bare_fn(\n-        ccx,\n-        &method.decl,\n-        &method.body,\n-        method.id,\n-        opt_self_info\n-    );\n-}\n-\n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n                                  fields: ~[(ast::Ident, Span)]) {\n     let mut field_names = HashMap::new();\n@@ -566,7 +544,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n         match orig_sp {\n             Some(orig_sp) => {\n                 tcx.sess.span_err(sp, format!(\"Duplicate field name {} in record type declaration\",\n-                                           tcx.sess.str_of(id)));\n+                                              tcx.sess.str_of(id)));\n                 tcx.sess.span_note(orig_sp, \"First declaration of this field occurred here\");\n                 break;\n             }\n@@ -603,26 +581,55 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                             it.id);\n       }\n       ast::item_fn(ref decl, _, _, _, ref body) => {\n-        check_bare_fn(ccx, decl, body, it.id, None);\n+        let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+\n+        // FIXME(#5121) -- won't work for lifetimes that appear in type bounds\n+        let param_env = ty::construct_parameter_environment(\n+                ccx.tcx,\n+                None,\n+                *fn_tpt.generics.type_param_defs,\n+                [],\n+                [],\n+                body.id);\n+\n+        check_bare_fn(ccx, decl, body, it.id, None, fn_tpt.ty, param_env);\n       }\n-      ast::item_impl(_, _, _, ref ms) => {\n-        let rp = ccx.tcx.region_paramd_items.find(&it.id).map(|x| *x);\n-        debug!(\"item_impl {} with id {} rp {:?}\",\n-               ccx.tcx.sess.str_of(it.ident), it.id, rp);\n+      ast::item_impl(_, ref opt_trait_ref, _, ref ms) => {\n+        debug!(\"item_impl {} with id {}\", ccx.tcx.sess.str_of(it.ident), it.id);\n+\n+        let impl_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for m in ms.iter() {\n-            check_method(ccx, *m);\n+            check_method_body(ccx, &impl_tpt.generics, None, *m);\n+        }\n+\n+        match *opt_trait_ref {\n+            Some(ref ast_trait_ref) => {\n+                let impl_trait_ref =\n+                    ty::node_id_to_trait_ref(ccx.tcx, ast_trait_ref.ref_id);\n+                check_impl_methods_against_trait(ccx,\n+                                             it.span,\n+                                             &impl_tpt.generics,\n+                                             ast_trait_ref,\n+                                             impl_trait_ref,\n+                                             *ms);\n+                vtable::resolve_impl(ccx, it, &impl_tpt.generics,\n+                                     impl_trait_ref);\n+            }\n+            None => { }\n         }\n-        vtable::resolve_impl(ccx, it);\n+\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n+        let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in (*trait_methods).iter() {\n             match *trait_method {\n               required(*) => {\n                 // Nothing to do, since required methods don't have\n                 // bodies to check.\n               }\n               provided(m) => {\n-                check_method(ccx, m);\n+                check_method_body(ccx, &trait_def.generics,\n+                                  Some(trait_def.trait_ref), m);\n               }\n             }\n         }\n@@ -662,6 +669,362 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n     }\n }\n \n+fn check_method_body(ccx: @mut CrateCtxt,\n+                     item_generics: &ty::Generics,\n+                     self_bound: Option<@ty::TraitRef>,\n+                     method: @ast::method) {\n+    /*!\n+     * Type checks a method body.\n+     *\n+     * # Parameters\n+     * - `item_generics`: generics defined on the impl/trait that contains\n+     *   the method\n+     * - `self_bound`: bound for the `Self` type parameter, if any\n+     * - `method`: the method definition\n+     */\n+\n+    debug!(\"check_method_body(item_generics={}, \\\n+            self_bound={}, \\\n+            method.id={})\",\n+            item_generics.repr(ccx.tcx),\n+            self_bound.repr(ccx.tcx),\n+            method.id);\n+    let method_def_id = local_def(method.id);\n+    let method_ty = ty::method(ccx.tcx, method_def_id);\n+    let method_generics = &method_ty.generics;\n+\n+    let param_env =\n+        ty::construct_parameter_environment(\n+            ccx.tcx,\n+            self_bound,\n+            *item_generics.type_param_defs,\n+            *method_generics.type_param_defs,\n+            item_generics.region_param_defs,\n+            method.body.id);\n+\n+    // Compute the self type and fty from point of view of inside fn\n+    let opt_self_info = method_ty.transformed_self_ty.map(|ty| {\n+        SelfInfo {self_ty: ty.subst(ccx.tcx, &param_env.free_substs),\n+                  self_id: method.self_id,\n+                  span: method.explicit_self.span}\n+    });\n+    let fty = ty::node_id_to_type(ccx.tcx, method.id);\n+    let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n+\n+    check_bare_fn(\n+        ccx,\n+        &method.decl,\n+        &method.body,\n+        method.id,\n+        opt_self_info,\n+        fty,\n+        param_env);\n+}\n+\n+fn check_impl_methods_against_trait(ccx: @mut CrateCtxt,\n+                                    impl_span: Span,\n+                                    impl_generics: &ty::Generics,\n+                                    ast_trait_ref: &ast::trait_ref,\n+                                    impl_trait_ref: &ty::TraitRef,\n+                                    impl_methods: &[@ast::method]) {\n+    // Locate trait methods\n+    let tcx = ccx.tcx;\n+    let trait_methods = ty::trait_methods(tcx, impl_trait_ref.def_id);\n+\n+    // Check existing impl methods to see if they are both present in trait\n+    // and compatible with trait signature\n+    for impl_method in impl_methods.iter() {\n+        let impl_method_def_id = local_def(impl_method.id);\n+        let impl_method_ty = ty::method(ccx.tcx, impl_method_def_id);\n+\n+        // If this is an impl of a trait method, find the corresponding\n+        // method definition in the trait.\n+        let opt_trait_method_ty =\n+            trait_methods.iter().\n+            find(|tm| tm.ident.name == impl_method_ty.ident.name);\n+        match opt_trait_method_ty {\n+            Some(trait_method_ty) => {\n+                compare_impl_method(ccx.tcx,\n+                                    impl_generics,\n+                                    impl_method_ty,\n+                                    impl_method.span,\n+                                    impl_method.body.id,\n+                                    *trait_method_ty,\n+                                    &impl_trait_ref.substs);\n+            }\n+            None => {\n+                tcx.sess.span_err(\n+                    impl_method.span,\n+                    format!(\"method `{}` is not a member of trait `{}`\",\n+                            tcx.sess.str_of(impl_method_ty.ident),\n+                            pprust::path_to_str(&ast_trait_ref.path,\n+                                                tcx.sess.intr())));\n+            }\n+        }\n+    }\n+\n+    // Check for missing methods from trait\n+    let provided_methods = ty::provided_trait_methods(tcx,\n+                                                      impl_trait_ref.def_id);\n+    let mut missing_methods = ~[];\n+    for trait_method in trait_methods.iter() {\n+        let is_implemented =\n+            impl_methods.iter().any(\n+                |m| m.ident.name == trait_method.ident.name);\n+        let is_provided =\n+            provided_methods.iter().any(\n+                |m| m.ident.name == trait_method.ident.name);\n+        if !is_implemented && !is_provided {\n+            missing_methods.push(\n+                format!(\"`{}`\", ccx.tcx.sess.str_of(trait_method.ident)));\n+        }\n+    }\n+\n+    if !missing_methods.is_empty() {\n+        tcx.sess.span_err(\n+            impl_span,\n+            format!(\"not all trait methods implemented, missing: {}\",\n+                    missing_methods.connect(\", \")));\n+    }\n+}\n+\n+/**\n+ * Checks that a method from an impl/class conforms to the signature of\n+ * the same method as declared in the trait.\n+ *\n+ * # Parameters\n+ *\n+ * - impl_generics: the generics declared on the impl itself (not the method!)\n+ * - impl_m: type of the method we are checking\n+ * - impl_m_span: span to use for reporting errors\n+ * - impl_m_body_id: id of the method body\n+ * - trait_m: the method in the trait\n+ * - trait_substs: the substitutions used on the type of the trait\n+ */\n+pub fn compare_impl_method(tcx: ty::ctxt,\n+                           impl_generics: &ty::Generics,\n+                           impl_m: @ty::Method,\n+                           impl_m_span: Span,\n+                           impl_m_body_id: ast::NodeId,\n+                           trait_m: &ty::Method,\n+                           trait_substs: &ty::substs) {\n+    debug!(\"compare_impl_method()\");\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    let impl_tps = impl_generics.type_param_defs.len();\n+\n+    // Try to give more informative error messages about self typing\n+    // mismatches.  Note that any mismatch will also be detected\n+    // below, where we construct a canonical function type that\n+    // includes the self parameter as a normal parameter.  It's just\n+    // that the error messages you get out of this code are a bit more\n+    // inscrutable, particularly for cases where one method has no\n+    // self.\n+    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n+        (&ast::sty_static, &ast::sty_static) => {}\n+        (&ast::sty_static, _) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+                        but not in the trait\",\n+                        tcx.sess.str_of(trait_m.ident),\n+                        pprust::explicit_self_to_str(&impl_m.explicit_self,\n+                                                     tcx.sess.intr())));\n+            return;\n+        }\n+        (_, &ast::sty_static) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+                        but not in the impl\",\n+                        tcx.sess.str_of(trait_m.ident),\n+                        pprust::explicit_self_to_str(&trait_m.explicit_self,\n+                                                     tcx.sess.intr())));\n+            return;\n+        }\n+        _ => {\n+            // Let the type checker catch other errors below\n+        }\n+    }\n+\n+    let num_impl_m_type_params = impl_m.generics.type_param_defs.len();\n+    let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n+    if num_impl_m_type_params != num_trait_m_type_params {\n+        tcx.sess.span_err(\n+            impl_m_span,\n+            format!(\"method `{}` has {} type parameter(s), but its trait \\\n+                    declaration has {} type parameter(s)\",\n+                    tcx.sess.str_of(trait_m.ident),\n+                    num_impl_m_type_params,\n+                    num_trait_m_type_params));\n+        return;\n+    }\n+\n+    if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n+        tcx.sess.span_err(\n+            impl_m_span,\n+            format!(\"method `{}` has {} parameter(s) \\\n+                    but the trait has {} parameter(s)\",\n+                    tcx.sess.str_of(trait_m.ident),\n+                    impl_m.fty.sig.inputs.len(),\n+                    trait_m.fty.sig.inputs.len()));\n+        return;\n+    }\n+\n+    for (i, trait_param_def) in trait_m.generics.type_param_defs.iter().enumerate() {\n+        // For each of the corresponding impl ty param's bounds...\n+        let impl_param_def = &impl_m.generics.type_param_defs[i];\n+\n+        // Check that the impl does not require any builtin-bounds\n+        // that the trait does not guarantee:\n+        let extra_bounds =\n+            impl_param_def.bounds.builtin_bounds -\n+            trait_param_def.bounds.builtin_bounds;\n+        if !extra_bounds.is_empty() {\n+           tcx.sess.span_err(\n+               impl_m_span,\n+               format!(\"in method `{}`, \\\n+                       type parameter {} requires `{}`, \\\n+                       which is not required by \\\n+                       the corresponding type parameter \\\n+                       in the trait declaration\",\n+                       tcx.sess.str_of(trait_m.ident),\n+                       i,\n+                       extra_bounds.user_string(tcx)));\n+           return;\n+        }\n+\n+        // FIXME(#2687)---we should be checking that the bounds of the\n+        // trait imply the bounds of the subtype, but it appears we\n+        // are...not checking this.\n+        if impl_param_def.bounds.trait_bounds.len() !=\n+            trait_param_def.bounds.trait_bounds.len()\n+        {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"in method `{}`, \\\n+                        type parameter {} has {} trait bound(s), but the \\\n+                        corresponding type parameter in \\\n+                        the trait declaration has {} trait bound(s)\",\n+                        tcx.sess.str_of(trait_m.ident),\n+                        i, impl_param_def.bounds.trait_bounds.len(),\n+                        trait_param_def.bounds.trait_bounds.len()));\n+            return;\n+        }\n+    }\n+\n+    // Create a substitution that maps the type parameters on the impl\n+    // to themselves and which replace any references to bound regions\n+    // in the self type with free regions.  So, for example, if the\n+    // impl type is \"&'self str\", then this would replace the self\n+    // type with a free region `self`.\n+    let dummy_impl_tps: ~[ty::t] =\n+        impl_generics.type_param_defs.iter().enumerate().\n+        map(|(i,t)| ty::mk_param(tcx, i, t.def_id)).\n+        collect();\n+    let dummy_method_tps: ~[ty::t] =\n+        impl_m.generics.type_param_defs.iter().enumerate().\n+        map(|(i,t)| ty::mk_param(tcx, i + impl_tps, t.def_id)).\n+        collect();\n+    let dummy_impl_regions: OptVec<ty::Region> =\n+        impl_generics.region_param_defs.iter().\n+        map(|l| ty::ReFree(ty::FreeRegion {\n+                scope_id: impl_m_body_id,\n+                bound_region: ty::BrNamed(l.def_id, l.ident)})).\n+        collect();\n+    let dummy_substs = ty::substs {\n+        tps: vec::append(dummy_impl_tps, dummy_method_tps),\n+        regions: ty::NonerasedRegions(dummy_impl_regions),\n+        self_ty: None };\n+\n+    // We are going to create a synthetic fn type that includes\n+    // both the method's self argument and its normal arguments.\n+    // So a method like `fn(&self, a: uint)` would be converted\n+    // into a function `fn(self: &T, a: uint)`.\n+    let mut trait_fn_args = ~[];\n+    let mut impl_fn_args = ~[];\n+\n+    // For both the trait and the impl, create an argument to\n+    // represent the self argument (unless this is a static method).\n+    // This argument will have the *transformed* self type.\n+    for &t in trait_m.transformed_self_ty.iter() {\n+        trait_fn_args.push(t);\n+    }\n+    for &t in impl_m.transformed_self_ty.iter() {\n+        impl_fn_args.push(t);\n+    }\n+\n+    // Add in the normal arguments.\n+    trait_fn_args.push_all(trait_m.fty.sig.inputs);\n+    impl_fn_args.push_all(impl_m.fty.sig.inputs);\n+\n+    // Create a bare fn type for trait/impl that includes self argument\n+    let trait_fty =\n+        ty::mk_bare_fn(tcx,\n+                       ty::BareFnTy {\n+                            purity: trait_m.fty.purity,\n+                            abis: trait_m.fty.abis,\n+                            sig: ty::FnSig {\n+                                binder_id: trait_m.fty.sig.binder_id,\n+                                inputs: trait_fn_args,\n+                                output: trait_m.fty.sig.output,\n+                                variadic: false\n+                            }\n+                        });\n+    let impl_fty =\n+        ty::mk_bare_fn(tcx,\n+                       ty::BareFnTy {\n+                            purity: impl_m.fty.purity,\n+                            abis: impl_m.fty.abis,\n+                            sig: ty::FnSig {\n+                                binder_id: impl_m.fty.sig.binder_id,\n+                                inputs: impl_fn_args,\n+                                output: impl_m.fty.sig.output,\n+                                variadic: false\n+                            }\n+                        });\n+\n+    // Perform substitutions so that the trait/impl methods are expressed\n+    // in terms of the same set of type/region parameters:\n+    // - replace trait type parameters with those from `trait_substs`,\n+    //   except with any reference to bound self replaced with `dummy_self_r`\n+    // - replace method parameters on the trait with fresh, dummy parameters\n+    //   that correspond to the parameters we will find on the impl\n+    // - replace self region with a fresh, dummy region\n+    let impl_fty = {\n+        debug!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n+        impl_fty.subst(tcx, &dummy_substs)\n+    };\n+    debug!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n+    let trait_fty = {\n+        let substs { regions: trait_regions,\n+                     tps: trait_tps,\n+                     self_ty: self_ty } = trait_substs.subst(tcx, &dummy_substs);\n+        let substs = substs {\n+            regions: trait_regions,\n+            tps: vec::append(trait_tps, dummy_method_tps),\n+            self_ty: self_ty,\n+        };\n+        debug!(\"trait_fty (pre-subst): {} substs={}\",\n+               trait_fty.repr(tcx), substs.repr(tcx));\n+        trait_fty.subst(tcx, &substs)\n+    };\n+    debug!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n+\n+    match infer::mk_subty(infcx, false, infer::MethodCompatCheck(impl_m_span),\n+                          impl_fty, trait_fty) {\n+        result::Ok(()) => {}\n+        result::Err(ref terr) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has an incompatible type: {}\",\n+                        tcx.sess.str_of(trait_m.ident),\n+                        ty::type_err_to_str(tcx, terr)));\n+            ty::note_and_explain_type_err(tcx, terr);\n+        }\n+    }\n+}\n+\n impl AstConv for FnCtxt {\n     fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n \n@@ -682,48 +1045,26 @@ impl FnCtxt {\n     pub fn infcx(&self) -> @mut infer::InferCtxt {\n         self.inh.infcx\n     }\n+\n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n-    pub fn search_in_scope_regions(&self,\n-                                   span: Span,\n-                                   br: ty::bound_region)\n-                                   -> Result<ty::Region, RegionError> {\n-        let in_scope_regions = self.in_scope_regions;\n-        match in_scope_regions.find(br) {\n-            Some(r) => result::Ok(r),\n-            None => {\n-                let blk_br = ty::br_named(special_idents::blk);\n-                if br == blk_br {\n-                    result::Ok(self.block_region())\n-                } else {\n-                    result::Err(RegionError {\n-                        msg: {\n-                            format!(\"named region `{}` not in scope here\",\n-                                 bound_region_ptr_to_str(self.tcx(), br))\n-                        },\n-                        replacement: {\n-                            self.infcx().next_region_var(\n-                                infer::BoundRegionError(span))\n-                        }\n-                    })\n-                }\n-            }\n+\n+    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a> {\n+        VtableContext {\n+            infcx: self.infcx(),\n+            param_env: &self.inh.param_env\n         }\n     }\n }\n \n-impl RegionScope for FnCtxt {\n-    fn anon_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n-        result::Ok(self.infcx().next_region_var(infer::MiscVariable(span)))\n-    }\n-    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n-        self.search_in_scope_regions(span, ty::br_self)\n-    }\n-    fn named_region(&self,\n+impl RegionScope for @mut infer::InferCtxt {\n+    fn anon_regions(&self,\n                     span: Span,\n-                    id: ast::Ident) -> Result<ty::Region, RegionError> {\n-        self.search_in_scope_regions(span, ty::br_named(id))\n+                    count: uint) -> Result<~[ty::Region], ()> {\n+        Ok(vec::from_fn(\n+                count,\n+                |_| self.next_region_var(infer::MiscVariable(span))))\n     }\n }\n \n@@ -746,7 +1087,7 @@ impl FnCtxt {\n     }\n \n     pub fn block_region(&self) -> ty::Region {\n-        ty::re_scope(self.region_lb)\n+        ty::ReScope(self.region_lb)\n     }\n \n     #[inline]\n@@ -805,7 +1146,7 @@ impl FnCtxt {\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n-        ast_ty_to_ty(self, self, ast_t)\n+        ast_ty_to_ty(self, &self.infcx(), ast_t)\n     }\n \n     pub fn pat_to_str(&self, pat: @ast::Pat) -> ~str {\n@@ -817,7 +1158,7 @@ impl FnCtxt {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n-                                         self.tag()));\n+                                            self.tag()));\n             }\n         }\n     }\n@@ -828,10 +1169,10 @@ impl FnCtxt {\n             None => {\n                 self.tcx().sess.bug(\n                     format!(\"no type for node {}: {} in fcx {}\",\n-                         id, ast_map::node_id_to_str(\n-                             self.tcx().items, id,\n-                             token::get_ident_interner()),\n-                         self.tag()));\n+                            id, ast_map::node_id_to_str(\n+                                self.tcx().items, id,\n+                                token::get_ident_interner()),\n+                            self.tag()));\n             }\n         }\n     }\n@@ -842,10 +1183,9 @@ impl FnCtxt {\n             None => {\n                 self.tcx().sess.bug(\n                     format!(\"no type substs for node {}: {} in fcx {}\",\n-                         id, ast_map::node_id_to_str(\n-                             self.tcx().items, id,\n-                             token::get_ident_interner()),\n-                         self.tag()));\n+                            id, ast_map::node_id_to_str(self.tcx().items, id,\n+                                                        token::get_ident_interner()),\n+                            self.tag()));\n             }\n         }\n     }\n@@ -924,20 +1264,6 @@ impl FnCtxt {\n         v\n     }\n \n-    pub fn region_var_if_parameterized(&self,\n-                                       rp: Option<ty::region_variance>,\n-                                       span: Span)\n-                                       -> OptVec<ty::Region> {\n-        match rp {\n-            None => opt_vec::Empty,\n-            Some(_) => {\n-                opt_vec::with(\n-                    self.infcx().next_region_var(\n-                        infer::BoundRegionInTypeOrImpl(span)))\n-            }\n-        }\n-    }\n-\n     pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: &fn(~str) -> ~str,\n@@ -1028,10 +1354,10 @@ pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-      ast::lit_str(*) => ty::mk_estr(tcx, ty::vstore_slice(ty::re_static)),\n+      ast::lit_str(*) => ty::mk_estr(tcx, ty::vstore_slice(ty::ReStatic)),\n       ast::lit_binary(*) => {\n           ty::mk_evec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n-                      ty::vstore_slice(ty::re_static))\n+                      ty::vstore_slice(ty::ReStatic))\n       }\n       ast::lit_char(_) => ty::mk_char(),\n       ast::lit_int(_, t) => ty::mk_mach_int(t),\n@@ -1105,20 +1431,22 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                  -> ty_param_substs_and_ty {\n     let tcx = vcx.tcx();\n \n-    let (n_tps, region_param, raw_ty) = {\n+    let (n_tps, n_rps, raw_ty) = {\n         let ity = ty::lookup_item_type(tcx, did);\n-        (ity.generics.type_param_defs.len(), ity.generics.region_param, ity.ty)\n+        (ity.generics.type_param_defs.len(),\n+         ity.generics.region_param_defs.len(),\n+         ity.ty)\n     };\n \n-    let regions = ty::NonerasedRegions(if region_param.is_some() {\n-        opt_vec::with(vcx.infcx.next_region_var(\n-            infer::BoundRegionInTypeOrImpl(location_info.span)))\n-    } else {\n-        opt_vec::Empty\n-    });\n+    let rps =\n+        vcx.infcx.next_region_vars(\n+            infer::BoundRegionInTypeOrImpl(location_info.span),\n+            n_rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n-    let substs = substs {regions: regions, self_ty: None, tps: tps};\n+    let substs = substs {regions: ty::NonerasedRegions(opt_vec::from(rps)),\n+                         self_ty: None,\n+                         tps: tps};\n     let substd_ty = ty::subst(tcx, &substs, raw_ty);\n \n     ty_param_substs_and_ty { substs: substs, ty: substd_ty }\n@@ -1174,30 +1502,29 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n     // Verify that no lifetimes or type parameters are present anywhere\n     // except the final two elements of the path.\n     for i in range(0, path.segments.len() - 2) {\n-        match path.segments[i].lifetime {\n-            None => {}\n-            Some(lifetime) => {\n-                function_context.tcx()\n-                                .sess\n-                                .span_err(lifetime.span,\n-                                          \"lifetime parameters may not \\\n-                                           appear here\")\n-            }\n+        for lifetime in path.segments[i].lifetimes.iter() {\n+            function_context.tcx()\n+                .sess\n+                .span_err(lifetime.span,\n+                          \"lifetime parameters may not \\\n+                          appear here\");\n+            break;\n         }\n \n         for typ in path.segments[i].types.iter() {\n             function_context.tcx()\n                             .sess\n                             .span_err(typ.span,\n-                                      \"type parameters may not appear here\")\n+                                      \"type parameters may not appear here\");\n+            break;\n         }\n     }\n \n     // If there are no parameters at all, there is nothing more to do; the\n     // rest of typechecking will (attempt to) infer everything.\n     if path.segments\n            .iter()\n-           .all(|s| s.lifetime.is_none() && s.types.is_empty()) {\n+           .all(|s| s.lifetimes.is_empty() && s.types.is_empty()) {\n         return\n     }\n \n@@ -1219,26 +1546,17 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n \n             // Make sure lifetime parameterization agrees with the trait or\n             // implementation type.\n-            match (generics.region_param, trait_segment.lifetime) {\n-                (Some(_), None) => {\n-                    function_context.tcx()\n-                                    .sess\n-                                    .span_err(path.span,\n-                                              format!(\"this {} has a lifetime \\\n-                                                    parameter but no \\\n-                                                    lifetime was specified\",\n-                                                   name))\n-                }\n-                (None, Some(_)) => {\n-                    function_context.tcx()\n-                                    .sess\n-                                    .span_err(path.span,\n-                                              format!(\"this {} has no lifetime \\\n-                                                    parameter but a lifetime \\\n-                                                    was specified\",\n-                                                   name))\n-                }\n-                (Some(_), Some(_)) | (None, None) => {}\n+            let trait_region_parameter_count = generics.region_param_defs.len();\n+            let supplied_region_parameter_count = trait_segment.lifetimes.len();\n+            if trait_region_parameter_count != supplied_region_parameter_count\n+                && supplied_region_parameter_count != 0 {\n+                function_context.tcx()\n+                    .sess\n+                    .span_err(path.span,\n+                              format!(\"expected {} lifetime parameter(s), \\\n+                                      found {} lifetime parameter(s)\",\n+                                      trait_region_parameter_count,\n+                                      supplied_region_parameter_count));\n             }\n \n             // Make sure the number of type parameters supplied on the trait\n@@ -1276,26 +1594,21 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n             // Verify that no lifetimes or type parameters are present on\n             // the penultimate segment of the path.\n             let segment = &path.segments[path.segments.len() - 2];\n-            match segment.lifetime {\n-                None => {}\n-                Some(lifetime) => {\n-                    function_context.tcx()\n-                                    .sess\n-                                    .span_err(lifetime.span,\n-                                              \"lifetime parameters may not\n-                                               appear here\")\n-                }\n+            for lifetime in segment.lifetimes.iter() {\n+                function_context.tcx()\n+                    .sess\n+                    .span_err(lifetime.span,\n+                              \"lifetime parameters may not\n+                              appear here\");\n+                break;\n             }\n             for typ in segment.types.iter() {\n                 function_context.tcx()\n                                 .sess\n                                 .span_err(typ.span,\n                                           \"type parameters may not appear \\\n                                            here\");\n-                function_context.tcx()\n-                                .sess\n-                                .span_note(typ.span,\n-                                           format!(\"this is a {:?}\", def));\n+                break;\n             }\n         }\n     }\n@@ -1556,7 +1869,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // In that case, we check each argument against \"error\" in order to\n         // set up all the node type bindings.\n         let error_fn_sig = FnSig {\n-            bound_lifetime_names: opt_vec::Empty,\n+            binder_id: ast::CRATE_NODE_ID,\n             inputs: err_args(args.len()),\n             output: ty::mk_err(),\n             variadic: false\n@@ -1577,7 +1890,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // signature with region variables\n         let (_, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(fcx.tcx(),\n-                                            @Nil,\n                                             None,\n                                             fn_sig,\n                                             |br| fcx.infcx()\n@@ -1908,10 +2220,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                      expected: Option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n \n-        // Find the expected input/output types (if any).  Careful to\n-        // avoid capture of bound regions in the expected type.  See\n-        // def'n of br_cap_avoid() for a more lengthy explanation of\n-        // what's going on here.\n+        // Find the expected input/output types (if any). Substitute\n+        // fresh bound regions for any bound regions we find in the\n+        // expected types so as to avoid capture.\n+        //\n         // Also try to pick up inferred purity and sigil, defaulting\n         // to impure and block. Note that we only will use those for\n         // block syntax lambdas; that is, lambdas without explicit\n@@ -1927,11 +2239,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n              expected_bounds) = {\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n-                    let id = expr.id;\n                     let (_, _, sig) =\n                         replace_bound_regions_in_fn_sig(\n-                            tcx, @Nil, None, &cenv.sig,\n-                            |br| ty::re_bound(ty::br_cap_avoid(id, @br)));\n+                            tcx, None, &cenv.sig,\n+                            |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n                     (Some(sig), cenv.purity, cenv.sigil,\n                      cenv.onceness, cenv.bounds)\n                 }\n@@ -1952,21 +2263,21 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // construct the function type\n         let fn_ty = astconv::ty_of_closure(fcx,\n-                                           fcx,\n+                                           &fcx.infcx(),\n+                                           expr.id,\n                                            sigil,\n                                            purity,\n                                            expected_onceness,\n                                            expected_bounds,\n                                            &None,\n                                            decl,\n                                            expected_sig,\n-                                           &opt_vec::Empty,\n                                            expr.span);\n \n         let fty_sig;\n         let fty = if error_happened {\n             fty_sig = FnSig {\n-                bound_lifetime_names: opt_vec::Empty,\n+                binder_id: ast::CRATE_NODE_ID,\n                 inputs: fn_ty.sig.inputs.map(|_| ty::mk_err()),\n                 output: ty::mk_err(),\n                 variadic: false\n@@ -1989,7 +2300,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            sigil);\n \n         check_fn(fcx.ccx, None, inherited_purity, &fty_sig,\n-                 decl, id, body, fn_kind, fcx.in_scope_regions, fcx.inh);\n+                 decl, id, body, fn_kind, fcx.inh);\n     }\n \n \n@@ -2168,50 +2479,18 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Look up the number of type parameters and the raw type, and\n         // determine whether the class is region-parameterized.\n-        let type_parameter_count;\n-        let region_parameterized;\n-        let raw_type;\n-        if class_id.crate == ast::LOCAL_CRATE {\n-            region_parameterized =\n-                tcx.region_paramd_items.find(&class_id.node).\n-                    map(|x| *x);\n-            match tcx.items.find(&class_id.node) {\n-                Some(&ast_map::node_item(@ast::item {\n-                        node: ast::item_struct(_, ref generics),\n-                        _\n-                    }, _)) => {\n-\n-                    type_parameter_count = generics.ty_params.len();\n-\n-                    let self_region =\n-                        bound_self_region(region_parameterized);\n-\n-                    raw_type = ty::mk_struct(tcx, class_id, substs {\n-                        regions: ty::NonerasedRegions(self_region),\n-                        self_ty: None,\n-                        tps: ty::ty_params_to_tys(\n-                            tcx,\n-                            generics)\n-                    });\n-                }\n-                _ => {\n-                    tcx.sess.span_bug(span,\n-                                      \"resolve didn't map this to a class\");\n-                }\n-            }\n-        } else {\n-            let item_type = ty::lookup_item_type(tcx, class_id);\n-            type_parameter_count = item_type.generics.type_param_defs.len();\n-            region_parameterized = item_type.generics.region_param;\n-            raw_type = item_type.ty;\n-        }\n+        let item_type = ty::lookup_item_type(tcx, class_id);\n+        let type_parameter_count = item_type.generics.type_param_defs.len();\n+        let region_parameter_count = item_type.generics.region_param_defs.len();\n+        let raw_type = item_type.ty;\n \n         // Generate the struct type.\n-        let regions =\n-            fcx.region_var_if_parameterized(region_parameterized, span);\n+        let regions = fcx.infcx().next_region_vars(\n+            infer::BoundRegionInTypeOrImpl(span),\n+            region_parameter_count);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(regions),\n+            regions: ty::NonerasedRegions(opt_vec::from(regions)),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -2258,48 +2537,18 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n-        let type_parameter_count;\n-        let region_parameterized;\n-        let raw_type;\n-        if enum_id.crate == ast::LOCAL_CRATE {\n-            region_parameterized =\n-                tcx.region_paramd_items.find(&enum_id.node).map(|x| *x);\n-            match tcx.items.find(&enum_id.node) {\n-                Some(&ast_map::node_item(@ast::item {\n-                        node: ast::item_enum(_, ref generics),\n-                        _\n-                    }, _)) => {\n-\n-                    type_parameter_count = generics.ty_params.len();\n-\n-                    let regions = bound_self_region(region_parameterized);\n-\n-                    raw_type = ty::mk_enum(tcx, enum_id, substs {\n-                        regions: ty::NonerasedRegions(regions),\n-                        self_ty: None,\n-                        tps: ty::ty_params_to_tys(\n-                            tcx,\n-                            generics)\n-                    });\n-                }\n-                _ => {\n-                    tcx.sess.span_bug(span,\n-                                      \"resolve didn't map this to an enum\");\n-                }\n-            }\n-        } else {\n-            let item_type = ty::lookup_item_type(tcx, enum_id);\n-            type_parameter_count = item_type.generics.type_param_defs.len();\n-            region_parameterized = item_type.generics.region_param;\n-            raw_type = item_type.ty;\n-        }\n+        let item_type = ty::lookup_item_type(tcx, enum_id);\n+        let type_parameter_count = item_type.generics.type_param_defs.len();\n+        let region_parameter_count = item_type.generics.region_param_defs.len();\n+        let raw_type = item_type.ty;\n \n         // Generate the enum type.\n-        let regions =\n-            fcx.region_var_if_parameterized(region_parameterized, span);\n+        let regions = fcx.infcx().next_region_vars(\n+            infer::BoundRegionInTypeOrImpl(span),\n+            region_parameter_count);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(regions),\n+            regions: ty::NonerasedRegions(opt_vec::from(regions)),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -3445,28 +3694,25 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n            ty_param_count,\n            ty_substs_len);\n \n-    // determine the region bound, using the value given by the user\n+    // determine the region parameters, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n-    let regions = match pth.segments.last().lifetime {\n-        Some(_) => { // user supplied a lifetime parameter...\n-            match tpt.generics.region_param {\n-                None => { // ...but the type is not lifetime parameterized!\n-                    fcx.ccx.tcx.sess.span_err\n-                        (span, \"this item is not region-parameterized\");\n-                    opt_vec::Empty\n-                }\n-                Some(_) => { // ...and the type is lifetime parameterized, ok.\n-                    opt_vec::with(\n-                        ast_region_to_region(fcx,\n-                                             fcx,\n-                                             span,\n-                                             &pth.segments.last().lifetime))\n-                }\n-            }\n-        }\n-        None => { // no lifetime parameter supplied, insert default\n-            fcx.region_var_if_parameterized(tpt.generics.region_param, span)\n+    let num_expected_regions = tpt.generics.region_param_defs.len();\n+    let num_supplied_regions = pth.segments.last().lifetimes.len();\n+    let regions = if num_expected_regions == num_supplied_regions {\n+        pth.segments.last().lifetimes.map(\n+            |l| ast_region_to_region(fcx.tcx(), l))\n+    } else {\n+        if num_supplied_regions != 0 {\n+            fcx.ccx.tcx.sess.span_err(\n+                span,\n+                format!(\"expected {} lifetime parameter(s), \\\n+                        found {} lifetime parameter(s)\",\n+                        num_expected_regions, num_supplied_regions));\n         }\n+\n+        opt_vec::from(fcx.infcx().next_region_vars(\n+                infer::BoundRegionInTypeOrImpl(span),\n+                num_expected_regions))\n     };\n \n     // Special case: If there is a self parameter, omit it from the list of\n@@ -3642,18 +3888,14 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n     if tps.len() == 0u { return; }\n     let mut tps_used = vec::from_elem(tps.len(), false);\n \n-    ty::walk_regions_and_ty(\n-        ccx.tcx, ty,\n-        |_r| {},\n-        |t| {\n+    ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n-              ty::ty_param(param_ty {idx, _}) => {\n-                  debug!(\"Found use of ty param \\\\#{}\", idx);\n-                  tps_used[idx] = true;\n-              }\n-              _ => ()\n+                ty::ty_param(param_ty {idx, _}) => {\n+                    debug!(\"Found use of ty param \\\\#{}\", idx);\n+                    tps_used[idx] = true;\n+                }\n+                _ => ()\n             }\n-            true\n         });\n \n     for (i, b) in tps_used.iter().enumerate() {\n@@ -3680,27 +3922,27 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n         //We only care about the operation here\n         match split[1] {\n             \"cxchg\" => (0, ~[ty::mk_mut_rptr(tcx,\n-                                             ty::re_bound(ty::br_anon(0)),\n+                                             ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                              ty::mk_int()),\n                         ty::mk_int(),\n                         ty::mk_int()\n                         ], ty::mk_int()),\n             \"load\" => (0,\n                ~[\n-                  ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n+                  ty::mk_imm_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int())\n                ],\n               ty::mk_int()),\n             \"store\" => (0,\n                ~[\n-                  ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int()),\n                   ty::mk_int()\n                ],\n                ty::mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\"   | \"xor\"  | \"max\"  |\n             \"min\"  | \"umax\" | \"umin\" => {\n                 (0, ~[ty::mk_mut_rptr(tcx,\n-                                      ty::re_bound(ty::br_anon(0)),\n+                                      ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                       ty::mk_int()), ty::mk_int() ], ty::mk_int())\n             }\n             \"fence\" => {\n@@ -3726,7 +3968,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             \"move_val\" | \"move_val_init\" => {\n                 (1u,\n                  ~[\n-                    ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n+                    ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),\n                     param(ccx, 0u)\n                   ],\n                ty::mk_nil())\n@@ -3738,7 +3980,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n               (0,\n                ~[\n-                  ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), ty::mk_int()),\n                   ty::mk_int()\n                ],\n                ty::mk_int())\n@@ -3761,7 +4003,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                   Ok(t) => t,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s); }\n               };\n-              let region = ty::re_bound(ty::br_anon(0));\n+              let region = ty::ReLateBound(it.id, ty::BrAnon(0));\n               let visitor_object_ty = match ty::visitor_object_ty(tcx, region) {\n                   Ok((_, vot)) => vot,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s); }\n@@ -3953,12 +4195,10 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         purity: ast::unsafe_fn,\n         abis: AbiSet::Intrinsic(),\n-        sig: FnSig {\n-            bound_lifetime_names: opt_vec::Empty,\n-            inputs: inputs,\n-            output: output,\n-            variadic: false\n-        }\n+        sig: FnSig {binder_id: it.id,\n+                    inputs: inputs,\n+                    output: output,\n+                    variadic: false}\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.type_param_defs.len();\n@@ -3974,3 +4214,4 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                      ppaux::ty_to_str(ccx.tcx, fty)));\n     }\n }\n+"}, {"sha": "b21d36777c293e8515772dad4f2455fec1439d71", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -29,7 +29,7 @@ this point a bit better.\n \n \n use middle::freevars::get_freevars;\n-use middle::ty::{re_scope};\n+use middle::ty::{ReScope};\n use middle::ty;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::regionmanip::relate_nested_regions;\n@@ -64,7 +64,7 @@ fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::Def) -> ty::Region {\n         DefUpvar(_, subdef, closure_id, body_id) => {\n             match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n                 BorrowedSigil => encl_region_of_def(fcx, *subdef),\n-                ManagedSigil | OwnedSigil => re_scope(body_id)\n+                ManagedSigil | OwnedSigil => ReScope(body_id)\n             }\n         }\n         _ => {\n@@ -317,7 +317,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n                         //\n                         // FIXME(#6268) remove to support nested method calls\n                         constrain_regions_in_type_of_node(\n-                            rcx, expr.id, ty::re_scope(expr.id),\n+                            rcx, expr.id, ty::ReScope(expr.id),\n                             infer::AutoBorrow(expr.span));\n                     }\n                 }\n@@ -416,7 +416,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n             //\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n-            constrain_regions_in_type(rcx, ty::re_scope(expr.id),\n+            constrain_regions_in_type(rcx, ty::ReScope(expr.id),\n                                       infer::AddrOf(expr.span), ty0);\n             visit::walk_expr(rcx, expr, ());\n         }\n@@ -474,7 +474,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                         // (since otherwise that would require\n                         // infinite stack).\n                         constrain_free_variables(rcx, region, expr);\n-                        let repeating_scope = ty::re_scope(rcx.repeating_scope);\n+                        let repeating_scope = ty::ReScope(rcx.repeating_scope);\n                         rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n                                         region, repeating_scope);\n                     }\n@@ -500,7 +500,7 @@ fn constrain_callee(rcx: &mut Rcx,\n                     call_expr: @ast::Expr,\n                     callee_expr: @ast::Expr)\n {\n-    let call_region = ty::re_scope(call_expr.id);\n+    let call_region = ty::ReScope(call_expr.id);\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n     match ty::get(callee_ty).sty {\n@@ -535,8 +535,14 @@ fn constrain_call(rcx: &mut Rcx,\n     //! appear in the arguments appropriately.\n \n     let tcx = rcx.fcx.tcx();\n-    debug!(\"constrain_call(call_expr={}, implicitly_ref_args={:?})\",\n-           call_expr.repr(tcx), implicitly_ref_args);\n+    debug!(\"constrain_call(call_expr={}, \\\n+            receiver={}, \\\n+            arg_exprs={}, \\\n+            implicitly_ref_args={:?})\",\n+            call_expr.repr(tcx),\n+            receiver.repr(tcx),\n+            arg_exprs.repr(tcx),\n+            implicitly_ref_args);\n     let callee_ty = rcx.resolve_node_type(callee_id);\n     if ty::type_is_error(callee_ty) {\n         // Bail, as function type is unknown\n@@ -549,9 +555,11 @@ fn constrain_call(rcx: &mut Rcx,\n     //\n     // FIXME(#6268) to support nested method calls, should be callee_id\n     let callee_scope = call_expr.id;\n-    let callee_region = ty::re_scope(callee_scope);\n+    let callee_region = ty::ReScope(callee_scope);\n \n     for &arg_expr in arg_exprs.iter() {\n+        debug!(\"Argument\");\n+\n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n         constrain_regions_in_type_of_node(\n@@ -569,6 +577,7 @@ fn constrain_call(rcx: &mut Rcx,\n \n     // as loop above, but for receiver\n     for &r in receiver.iter() {\n+        debug!(\"Receiver\");\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n@@ -595,7 +604,7 @@ fn constrain_derefs(rcx: &mut Rcx,\n      * the deref expr.\n      */\n     let tcx = rcx.fcx.tcx();\n-    let r_deref_expr = ty::re_scope(deref_expr.id);\n+    let r_deref_expr = ty::ReScope(deref_expr.id);\n     for i in range(0u, derefs) {\n         debug!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n@@ -641,7 +650,7 @@ fn constrain_index(rcx: &mut Rcx,\n     debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n \n-    let r_index_expr = ty::re_scope(index_expr.id);\n+    let r_index_expr = ty::ReScope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n         ty::ty_estr(ty::vstore_slice(r_ptr)) |\n         ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n@@ -727,9 +736,9 @@ fn constrain_regions_in_type(\n            ty_to_str(tcx, ty));\n \n     do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n-        debug!(\"relate(r_sub={}, r_sup={})\",\n-               region_to_str(tcx, \"\", false, r_sub),\n-               region_to_str(tcx, \"\", false, r_sup));\n+        debug!(\"relate_nested_regions(r_sub={}, r_sup={})\",\n+                r_sub.repr(tcx),\n+                r_sup.repr(tcx));\n \n         if r_sup.is_bound() || r_sub.is_bound() {\n             // a bound region is one which appears inside an fn type.\n@@ -903,7 +912,7 @@ pub mod guarantor {\n         let expr_cat = categorize(rcx, expr);\n         debug!(\"guarantor::for_by_ref(expr={:?}, callee_scope={:?}) category={:?}\",\n                expr.id, callee_scope, expr_cat);\n-        let minimum_lifetime = ty::re_scope(callee_scope);\n+        let minimum_lifetime = ty::ReScope(callee_scope);\n         for guarantor in expr_cat.guarantor.iter() {\n             mk_subregion_due_to_derefence(rcx, expr.span,\n                                           minimum_lifetime, *guarantor);"}, {"sha": "ec11adbfa3dabb35192ea1b313d629126e205ce3", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 74, "deletions": 170, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -10,155 +10,41 @@\n \n // #[warn(deprecated_mode)];\n \n-\n use middle::ty;\n-\n-use middle::typeck::isr_alist;\n-use util::common::indenter;\n-use util::ppaux::region_to_str;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFolder;\n+use std::hashmap::HashMap;\n+use util::ppaux::Repr;\n use util::ppaux;\n \n-use extra::list::Cons;\n-\n // Helper functions related to manipulating region types.\n \n pub fn replace_bound_regions_in_fn_sig(\n     tcx: ty::ctxt,\n-    isr: isr_alist,\n     opt_self_ty: Option<ty::t>,\n     fn_sig: &ty::FnSig,\n-    mapf: &fn(ty::bound_region) -> ty::Region)\n-    -> (isr_alist, Option<ty::t>, ty::FnSig)\n+    mapf: &fn(ty::BoundRegion) -> ty::Region)\n+    -> (HashMap<ty::BoundRegion,ty::Region>, Option<ty::t>, ty::FnSig)\n {\n-    let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n-\n-    for &t in opt_self_ty.iter() { all_tys.push(t) }\n-\n-    debug!(\"replace_bound_regions_in_fn_sig(self_ty={:?}, fn_sig={}, \\\n-            all_tys={:?})\",\n-           opt_self_ty.map(|t| ppaux::ty_to_str(tcx, t)),\n-           ppaux::fn_sig_to_str(tcx, fn_sig),\n-           all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n-    let _i = indenter();\n-\n-    let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n-        debug!(\"br={:?}\", br);\n-        mapf(br)\n-    };\n-    let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n-        replace_bound_regions(tcx, isr, t)\n-    });\n-    let new_self_ty = opt_self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n-\n-    debug!(\"result of replace_bound_regions_in_fn_sig: \\\n-            new_self_ty={:?}, \\\n-            fn_sig={}\",\n-           new_self_ty.map(|t| ppaux::ty_to_str(tcx, t)),\n-           ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n-\n-    return (isr, new_self_ty, new_fn_sig);\n-\n-    // Takes `isr`, a (possibly empty) mapping from in-scope region\n-    // names (\"isr\"s) to their corresponding regions; `tys`, a list of\n-    // types, and `to_r`, a closure that takes a bound_region and\n-    // returns a region.  Returns an updated version of `isr`,\n-    // extended with the in-scope region names from all of the bound\n-    // regions appearing in the types in the `tys` list (if they're\n-    // not in `isr` already), with each of those in-scope region names\n-    // mapped to a region that's the result of applying `to_r` to\n-    // itself.\n-    fn create_bound_region_mapping(\n-        tcx: ty::ctxt,\n-        isr: isr_alist,\n-        tys: ~[ty::t],\n-        to_r: &fn(ty::bound_region) -> ty::Region) -> isr_alist {\n-\n-        // Takes `isr` (described above), `to_r` (described above),\n-        // and `r`, a region.  If `r` is anything other than a bound\n-        // region, or if it's a bound region that already appears in\n-        // `isr`, then we return `isr` unchanged.  If `r` is a bound\n-        // region that doesn't already appear in `isr`, we return an\n-        // updated isr_alist that now contains a mapping from `r` to\n-        // the result of calling `to_r` on it.\n-        fn append_isr(isr: isr_alist,\n-                      to_r: &fn(ty::bound_region) -> ty::Region,\n-                      r: ty::Region) -> isr_alist {\n-            match r {\n-              ty::re_empty | ty::re_free(*) | ty::re_static | ty::re_scope(_) |\n-              ty::re_infer(_) => {\n-                isr\n-              }\n-              ty::re_bound(br) => {\n-                match isr.find(br) {\n-                  Some(_) => isr,\n-                  None => @Cons((br, to_r(br)), isr)\n+    debug!(\"replace_bound_regions_in_fn_sig(self_ty={}, fn_sig={})\",\n+            opt_self_ty.repr(tcx),\n+            fn_sig.repr(tcx));\n+\n+    let mut map = HashMap::new();\n+    let (fn_sig, opt_self_ty) = {\n+        let mut f = ty_fold::RegionFolder::regions(tcx, |r| {\n+                debug!(\"region r={}\", r.to_str());\n+                match r {\n+                ty::ReLateBound(s, br) if s == fn_sig.binder_id => {\n+                    *map.find_or_insert_with(br, |_| mapf(br))\n                 }\n-              }\n-            }\n-        }\n-\n-        // For each type `ty` in `tys`...\n-        do tys.iter().fold(isr) |isr, ty| {\n-            let mut isr = isr;\n-\n-            // Using fold_regions is inefficient, because it\n-            // constructs new types, but it avoids code duplication in\n-            // terms of locating all the regions within the various\n-            // kinds of types.  This had already caused me several\n-            // bugs so I decided to switch over.\n-            do ty::fold_regions(tcx, *ty) |r, in_fn| {\n-                if !in_fn { isr = append_isr(isr, |br| to_r(br), r); }\n-                r\n-            };\n-\n-            isr\n-        }\n-    }\n-\n-    // Takes `isr`, a mapping from in-scope region names (\"isr\"s) to\n-    // their corresponding regions; and `ty`, a type.  Returns an\n-    // updated version of `ty`, in which bound regions in `ty` have\n-    // been replaced with the corresponding bindings in `isr`.\n-    fn replace_bound_regions(\n-        tcx: ty::ctxt,\n-        isr: isr_alist,\n-        ty: ty::t) -> ty::t {\n-\n-        do ty::fold_regions(tcx, ty) |r, in_fn| {\n-            let r1 = match r {\n-              // As long as we are not within a fn() type, `&T` is\n-              // mapped to the free region anon_r.  But within a fn\n-              // type, it remains bound.\n-              ty::re_bound(ty::br_anon(_)) if in_fn => r,\n-\n-              ty::re_bound(br) => {\n-                match isr.find(br) {\n-                  // In most cases, all named, bound regions will be\n-                  // mapped to some free region.\n-                  Some(fr) => fr,\n-\n-                  // But in the case of a fn() type, there may be\n-                  // named regions within that remain bound:\n-                  None if in_fn => r,\n-                  None => {\n-                    tcx.sess.bug(\n-                        format!(\"Bound region not found in \\\n-                              in_scope_regions list: {}\",\n-                             region_to_str(tcx, \"\", false, r)));\n-                  }\n-                }\n-              }\n-\n-              // Free regions like these just stay the same:\n-              ty::re_empty |\n-              ty::re_static |\n-              ty::re_scope(_) |\n-              ty::re_free(*) |\n-              ty::re_infer(_) => r\n-            };\n-            r1\n-        }\n-    }\n+                _ => r\n+            }});\n+        (ty_fold::super_fold_sig(&mut f, fn_sig),\n+         ty_fold::fold_opt_ty(&mut f, opt_self_ty))\n+    };\n+    debug!(\"resulting map: {}\", map.to_str());\n+    (map, opt_self_ty, fn_sig)\n }\n \n pub fn relate_nested_regions(\n@@ -168,7 +54,6 @@ pub fn relate_nested_regions(\n     relate_op: &fn(ty::Region, ty::Region))\n {\n     /*!\n-     *\n      * This rather specialized function walks each region `r` that appear\n      * in `ty` and invokes `relate_op(r_encl, r)` for each one.  `r_encl`\n      * here is the region of any enclosing `&'r T` pointer.  If there is\n@@ -194,41 +79,60 @@ pub fn relate_nested_regions(\n      * Hence, in the second example above, `'r2` must be a subregion of `'r3`.\n      */\n \n-    let mut the_stack = ~[];\n-    for &r in opt_region.iter() { the_stack.push(r); }\n-    walk_ty(tcx, &mut the_stack, ty, relate_op);\n+    let mut rr = RegionRelator { tcx: tcx,\n+                                 stack: ~[],\n+                                 relate_op: relate_op };\n+    match opt_region {\n+        Some(o_r) => { rr.stack.push(o_r); }\n+        None => {}\n+    }\n+    rr.fold_ty(ty);\n \n-    fn walk_ty(tcx: ty::ctxt,\n-               the_stack: &mut ~[ty::Region],\n-               ty: ty::t,\n-               relate_op: &fn(ty::Region, ty::Region))\n-    {\n-        match ty::get(ty).sty {\n-            ty::ty_rptr(r, ref mt) |\n-            ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n-                relate(*the_stack, r, |x,y| relate_op(x,y));\n-                the_stack.push(r);\n-                walk_ty(tcx, the_stack, mt.ty, |x,y| relate_op(x,y));\n-                the_stack.pop();\n-            }\n-            _ => {\n-                ty::fold_regions_and_ty(\n-                    tcx,\n-                    ty,\n-                    |r| { relate(     *the_stack, r, |x,y| relate_op(x,y)); r },\n-                    |t| { walk_ty(tcx, the_stack, t, |x,y| relate_op(x,y)); t },\n-                    |t| { walk_ty(tcx, the_stack, t, |x,y| relate_op(x,y)); t });\n+    struct RegionRelator<'self> {\n+        tcx: ty::ctxt,\n+        stack: ~[ty::Region],\n+        relate_op: &'self fn(ty::Region, ty::Region),\n+    }\n+\n+    // FIXME(#10151) -- Define more precisely when a region is\n+    // considered \"nested\". Consider taking variance into account as\n+    // well.\n+\n+    impl<'self> TypeFolder for RegionRelator<'self> {\n+        fn tcx(&self) -> ty::ctxt {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n+            match ty::get(ty).sty {\n+                ty::ty_rptr(r, ref mt) |\n+                ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n+                    self.relate(r);\n+                    self.stack.push(r);\n+                    ty_fold::super_fold_ty(self, mt.ty);\n+                    self.stack.pop();\n+                }\n+\n+                _ => {\n+                    ty_fold::super_fold_ty(self, ty);\n+                }\n             }\n+\n+            ty\n+        }\n+\n+        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            self.relate(r);\n+            r\n         }\n     }\n \n-    fn relate(the_stack: &[ty::Region],\n-              r_sub: ty::Region,\n-              relate_op: &fn(ty::Region, ty::Region))\n-    {\n-        for &r in the_stack.iter() {\n-            if !r.is_bound() && !r_sub.is_bound() {\n-                relate_op(r, r_sub);\n+    impl<'self> RegionRelator<'self> {\n+        fn relate(&mut self, r_sub: ty::Region) {\n+            for &r in self.stack.iter() {\n+                if !r.is_bound() && !r_sub.is_bound() {\n+                    (self.relate_op)(r, r_sub);\n+                }\n             }\n         }\n     }\n@@ -265,7 +169,7 @@ pub fn relate_free_regions(\n         debug!(\"relate_free_regions(t={})\", ppaux::ty_to_str(tcx, t));\n         relate_nested_regions(tcx, None, t, |a, b| {\n             match (&a, &b) {\n-                (&ty::re_free(free_a), &ty::re_free(free_b)) => {\n+                (&ty::ReFree(free_a), &ty::ReFree(free_b)) => {\n                     tcx.region_maps.relate_free_regions(free_a, free_b);\n                 }\n                 _ => {}"}, {"sha": "996157df2e29981ca5bdef4c3b3298b55a219d35", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 78, "deletions": 71, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -11,6 +11,7 @@\n \n use middle::ty::param_ty;\n use middle::ty;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::infer::fixup_err_to_str;\n@@ -68,13 +69,13 @@ pub struct LocationInfo {\n \n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n-pub struct VtableContext {\n-    ccx: @mut CrateCtxt,\n-    infcx: @mut infer::InferCtxt\n+pub struct VtableContext<'self> {\n+    infcx: @mut infer::InferCtxt,\n+    param_env: &'self ty::ParameterEnvironment,\n }\n \n-impl VtableContext {\n-    pub fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n+impl<'self> VtableContext<'self> {\n+    pub fn tcx(&self) -> ty::ctxt { self.infcx.tcx }\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n@@ -95,7 +96,6 @@ fn lookup_vtables(vcx: &VtableContext,\n            substs.repr(vcx.tcx()));\n     let _i = indenter();\n \n-\n     // We do this backwards for reasons discussed above.\n     assert_eq!(substs.tps.len(), type_param_defs.len());\n     let mut result =\n@@ -233,8 +233,6 @@ fn lookup_vtable(vcx: &VtableContext,\n            vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n \n-    let tcx = vcx.tcx();\n-\n     let ty = match fixup_ty(vcx, location_info, ty, is_early) {\n         Some(ty) => ty,\n         None => {\n@@ -250,18 +248,21 @@ fn lookup_vtable(vcx: &VtableContext,\n     // If the type is self or a param, we look at the trait/supertrait\n     // bounds to see if they include the trait we are looking for.\n     let vtable_opt = match ty::get(ty).sty {\n-        ty::ty_param(param_ty {idx: n, def_id: did}) => {\n-            let type_param_def = tcx.ty_param_defs.get(&did.node);\n-            lookup_vtable_from_bounds(vcx, location_info,\n-                                      type_param_def.bounds.trait_bounds,\n+        ty::ty_param(param_ty {idx: n, _}) => {\n+            let type_param_bounds: &[@ty::TraitRef] =\n+                vcx.param_env.type_param_bounds[n].trait_bounds;\n+            lookup_vtable_from_bounds(vcx,\n+                                      location_info,\n+                                      type_param_bounds,\n                                       param_numbered(n),\n                                       trait_ref)\n         }\n \n-        ty::ty_self(trait_id) => {\n-            let self_trait_ref = ty::lookup_trait_def(tcx, trait_id).trait_ref;\n-            lookup_vtable_from_bounds(vcx, location_info,\n-                                      &[self_trait_ref],\n+        ty::ty_self(_) => {\n+            let self_param_bound = vcx.param_env.self_param_bound.unwrap();\n+            lookup_vtable_from_bounds(vcx,\n+                                      location_info,\n+                                      [self_param_bound],\n                                       param_self,\n                                       trait_ref)\n         }\n@@ -285,7 +286,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                              bounds: &[@ty::TraitRef],\n                              param: param_index,\n                              trait_ref: @ty::TraitRef)\n-    -> Option<vtable_origin> {\n+                             -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n \n     let mut n_bound = 0;\n@@ -317,8 +318,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                      ty: ty::t,\n                      trait_ref: @ty::TraitRef,\n                      is_early: bool)\n-    -> Option<vtable_origin>\n-{\n+                     -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n \n     let mut found = ~[];\n@@ -480,7 +480,7 @@ fn fixup_substs(vcx: &VtableContext,\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n-                         ty::RegionTraitStore(ty::re_static),\n+                         ty::RegionTraitStore(ty::ReStatic),\n                          ast::MutImmutable,\n                          ty::EmptyBuiltinBounds());\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n@@ -494,7 +494,8 @@ fn fixup_substs(vcx: &VtableContext,\n fn fixup_ty(vcx: &VtableContext,\n             location_info: &LocationInfo,\n             ty: ty::t,\n-            is_early: bool) -> Option<ty::t> {\n+            is_early: bool)\n+            -> Option<ty::t> {\n     let tcx = vcx.tcx();\n     match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n@@ -515,8 +516,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n                      impl_substs: &ty::substs,\n                      trait_ref: @ty::TraitRef,\n-                     impl_did: ast::DefId)\n-{\n+                     impl_did: ast::DefId) {\n     let tcx = vcx.tcx();\n \n     let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {\n@@ -571,7 +571,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n             if has_trait_bounds(*item_ty.generics.type_param_defs) {\n                 debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n                        item_ty.generics.type_param_defs.repr(fcx.tcx()));\n-                let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n+                let vcx = fcx.vtable_context();\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            *item_ty.generics.type_param_defs,\n                                            substs, is_early);\n@@ -599,7 +599,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                    ex.repr(fcx.tcx()));\n             if has_trait_bounds(*type_param_defs) {\n                 let substs = fcx.node_ty_substs(callee_id);\n-                let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n+                let vcx = fcx.vtable_context();\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            *type_param_defs, &substs, is_early);\n                 if !is_early {\n@@ -642,10 +642,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                       (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*)) => {\n                           let location_info =\n                               &location_info_for_expr(ex);\n-                          let vcx = VtableContext {\n-                              ccx: fcx.ccx,\n-                              infcx: fcx.infcx()\n-                          };\n+                          let vcx = fcx.vtable_context();\n                           let target_trait_ref = @ty::TraitRef {\n                               def_id: target_def_id,\n                               substs: ty::substs {\n@@ -726,48 +723,58 @@ fn resolve_expr(fcx: @mut FnCtxt,\n     visit::walk_expr(&mut fcx, ex, ());\n }\n \n-pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n-    let def_id = ast_util::local_def(impl_item.id);\n-    match ty::impl_trait_ref(ccx.tcx, def_id) {\n-        None => {},\n-        Some(trait_ref) => {\n-            let infcx = infer::new_infer_ctxt(ccx.tcx);\n-            let vcx = VtableContext { ccx: ccx, infcx: infcx };\n-            let loc_info = location_info_for_item(impl_item);\n-\n-            // First, check that the impl implements any trait bounds\n-            // on the trait.\n-            let trait_def = ty::lookup_trait_def(ccx.tcx, trait_ref.def_id);\n-            let vtbls = lookup_vtables(&vcx,\n-                                       &loc_info,\n-                                       *trait_def.generics.type_param_defs,\n-                                       &trait_ref.substs,\n-                                       false);\n-\n-            // Now, locate the vtable for the impl itself. The real\n-            // purpose of this is to check for supertrait impls,\n-            // but that falls out of doing this.\n-            let param_bounds = ty::ParamBounds {\n-                builtin_bounds: ty::EmptyBuiltinBounds(),\n-                trait_bounds: ~[trait_ref]\n-            };\n-            let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n-            debug!(\"=== Doing a self lookup now.\");\n-            // Right now, we don't have any place to store this.\n-            // We will need to make one so we can use this information\n-            // for compiling default methods that refer to supertraits.\n-            let self_vtable_res =\n-                lookup_vtables_for_param(&vcx, &loc_info, None,\n-                                         &param_bounds, t, false);\n-\n-\n-            let res = impl_res {\n-                trait_vtables: vtbls,\n-                self_vtables: self_vtable_res\n-            };\n-            ccx.tcx.impl_vtables.insert(def_id, res);\n-        }\n-    }\n+pub fn resolve_impl(ccx: @mut CrateCtxt,\n+                    impl_item: @ast::item,\n+                    impl_generics: &ty::Generics,\n+                    impl_trait_ref: &ty::TraitRef) {\n+    let param_env = ty::construct_parameter_environment(\n+        ccx.tcx,\n+        None,\n+        *impl_generics.type_param_defs,\n+        [],\n+        impl_generics.region_param_defs,\n+        impl_item.id);\n+\n+    let impl_trait_ref = @impl_trait_ref.subst(ccx.tcx, &param_env.free_substs);\n+\n+    let infcx = infer::new_infer_ctxt(ccx.tcx);\n+    let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n+    let loc_info = location_info_for_item(impl_item);\n+\n+    // First, check that the impl implements any trait bounds\n+    // on the trait.\n+    let trait_def = ty::lookup_trait_def(ccx.tcx, impl_trait_ref.def_id);\n+    let vtbls = lookup_vtables(&vcx,\n+                               &loc_info,\n+                               *trait_def.generics.type_param_defs,\n+                               &impl_trait_ref.substs,\n+                               false);\n+\n+    // Now, locate the vtable for the impl itself. The real\n+    // purpose of this is to check for supertrait impls,\n+    // but that falls out of doing this.\n+    let param_bounds = ty::ParamBounds {\n+        builtin_bounds: ty::EmptyBuiltinBounds(),\n+        trait_bounds: ~[impl_trait_ref]\n+    };\n+    let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n+    let t = t.subst(ccx.tcx, &param_env.free_substs);\n+    debug!(\"=== Doing a self lookup now.\");\n+\n+    // Right now, we don't have any place to store this.\n+    // We will need to make one so we can use this information\n+    // for compiling default methods that refer to supertraits.\n+    let self_vtable_res =\n+        lookup_vtables_for_param(&vcx, &loc_info, None,\n+                                 &param_bounds, t, false);\n+\n+\n+    let res = impl_res {\n+        trait_vtables: vtbls,\n+        self_vtables: self_vtable_res\n+    };\n+    let impl_def_id = ast_util::local_def(impl_item.id);\n+    ccx.tcx.impl_vtables.insert(impl_def_id, res);\n }\n \n impl visit::Visitor<()> for @mut FnCtxt {"}, {"sha": "bf00bee270943359215444504410f1a898bfc0e7", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 45, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -357,8 +357,8 @@ impl CoherenceChecker {\n                     @vec::append(\n                         (*impl_poly_type.generics.type_param_defs).clone(),\n                         *new_method_ty.generics.type_param_defs),\n-                region_param:\n-                    impl_poly_type.generics.region_param\n+                region_param_defs:\n+                    impl_poly_type.generics.region_param_defs\n             };\n             let new_polytype = ty::ty_param_bounds_and_ty {\n                 generics: new_generics,\n@@ -482,20 +482,17 @@ impl CoherenceChecker {\n     pub fn universally_quantify_polytype(&self,\n                                          polytype: ty_param_bounds_and_ty)\n                                          -> UniversalQuantificationResult {\n-        let regions = match polytype.generics.region_param {\n-            None => opt_vec::Empty,\n-            Some(_) => {\n-                opt_vec::with(\n-                    self.inference_context.next_region_var(\n-                        infer::BoundRegionInCoherence))\n-            }\n-        };\n+        let region_parameter_count = polytype.generics.region_param_defs.len();\n+        let region_parameters =\n+            self.inference_context.next_region_vars(\n+                infer::BoundRegionInCoherence,\n+                region_parameter_count);\n \n         let bounds_count = polytype.generics.type_param_defs.len();\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(regions),\n+            regions: ty::NonerasedRegions(opt_vec::from(region_parameters)),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -539,33 +536,6 @@ impl CoherenceChecker {\n         return trait_id;\n     }\n \n-    // This check doesn't really have anything to do with coherence. It's\n-    // here for historical reasons\n-    pub fn check_trait_methods_are_implemented(\n-        &self,\n-        all_methods: &mut ~[@Method],\n-        trait_did: DefId,\n-        trait_ref_span: Span) {\n-\n-        let tcx = self.crate_context.tcx;\n-\n-        let mut provided_names = HashSet::new();\n-        // Implemented methods\n-        for elt in all_methods.iter() {\n-            provided_names.insert(elt.ident.name);\n-        }\n-\n-        let r = ty::trait_methods(tcx, trait_did);\n-        for method in r.iter() {\n-            debug!(\"checking for {}\", method.ident.repr(tcx));\n-            if provided_names.contains(&method.ident.name) { continue; }\n-\n-            tcx.sess.span_err(trait_ref_span,\n-                              format!(\"missing method `{}`\",\n-                                   tcx.sess.str_of(method.ident)));\n-        }\n-    }\n-\n     /// For coherence, when we have `impl Type`, we need to guarantee that\n     /// `Type` is \"local\" to the crate. For our purposes, this means that it\n     /// must precisely name some nominal type defined in this crate.\n@@ -620,17 +590,10 @@ impl CoherenceChecker {\n                     let ty_trait_ref = ty::node_id_to_trait_ref(\n                         self.crate_context.tcx,\n                         trait_ref.ref_id);\n-                    let trait_did = ty_trait_ref.def_id;\n \n                     self.instantiate_default_methods(local_def(item.id),\n                                                      ty_trait_ref,\n                                                      &mut methods);\n-\n-                    // Check that we have implementations of every trait method\n-                    self.check_trait_methods_are_implemented(\n-                        &mut methods,\n-                        trait_did,\n-                        trait_ref.path.span);\n                 }\n \n                 return @Impl {"}, {"sha": "36ed9f94fb71a25caadbb13987578b7881dfced8", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 208, "deletions": 562, "changes": 770, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -39,15 +39,10 @@ use middle::subst::Subst;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n-use middle::typeck::infer;\n use middle::typeck::rscope::*;\n-use middle::typeck::rscope;\n use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n-use util::common::pluralize;\n use util::ppaux;\n-use util::ppaux::UserString;\n \n-use std::result;\n use std::vec;\n use syntax::abi::AbiSet;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n@@ -56,10 +51,9 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n use syntax::codemap::Span;\n use syntax::codemap;\n-use syntax::print::pprust::{path_to_str, explicit_self_to_str};\n+use syntax::print::pprust::{path_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n \n struct CollectItemTypesVisitor {\n@@ -97,19 +91,11 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n }\n \n pub trait ToTy {\n-    fn to_ty<RS:RegionScope + Clone + 'static>(\n-             &self,\n-             rs: &RS,\n-             ast_ty: &ast::Ty)\n-             -> ty::t;\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n }\n \n impl ToTy for CrateCtxt {\n-    fn to_ty<RS:RegionScope + Clone + 'static>(\n-             &self,\n-             rs: &RS,\n-             ast_ty: &ast::Ty)\n-             -> ty::t {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n@@ -149,88 +135,74 @@ impl AstConv for CrateCtxt {\n pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                               enum_ty: ty::t,\n                               variants: &[ast::variant],\n-                              generics: &ast::Generics,\n-                              rp: Option<ty::region_variance>) {\n+                              generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n     for variant in variants.iter() {\n-        let region_parameterization =\n-            RegionParameterization::from_variance_and_generics(rp, generics);\n-\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n-        let result_ty;\n-        match variant.node.kind {\n+        let scope = variant.node.id;\n+        let result_ty = match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n-                let rs = TypeRscope(region_parameterization);\n+                let rs = ExplicitRscope;\n                 let input_tys = args.map(|va| ccx.to_ty(&rs, &va.ty));\n-                result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n+                ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n             }\n \n             ast::tuple_variant_kind(_) => {\n-                result_ty = Some(enum_ty);\n+                enum_ty\n             }\n \n             ast::struct_variant_kind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, rp, generics, 0),\n+                    generics: ty_generics(ccx, generics, 0),\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx,\n-                               rp,\n-                               struct_def,\n-                               generics,\n-                               tpt,\n-                               variant.node.id);\n+                convert_struct(ccx, struct_def, tpt, variant.node.id);\n \n                 let input_tys = struct_def.fields.map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id));\n-                result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n+                ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n             }\n         };\n \n-        match result_ty {\n-            None => {}\n-            Some(result_ty) => {\n-                let tpt = ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, rp, generics, 0),\n-                    ty: result_ty\n-                };\n-                tcx.tcache.insert(local_def(variant.node.id), tpt);\n-                write_ty_to_tcx(tcx, variant.node.id, result_ty);\n-            }\n-        }\n+        let tpt = ty_param_bounds_and_ty {\n+            generics: ty_generics(ccx, generics, 0),\n+            ty: result_ty\n+        };\n+        tcx.tcache.insert(local_def(variant.node.id), tpt);\n+        write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n }\n \n pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             trait_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|x| *x);\n     match tcx.items.get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n             _\n         }, _) => {\n-            let trait_ty_generics = ty_generics(ccx, region_paramd, generics, 0);\n+            let trait_ty_generics =\n+                ty_generics(ccx, generics, 0);\n \n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.methods` table:\n             for m in ms.iter() {\n                 let ty_method = @match m {\n                     &ast::required(ref m) => {\n                         ty_method_of_trait_method(\n-                            ccx, trait_id, region_paramd, generics,\n+                            ccx, trait_id, &trait_ty_generics,\n                             &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, &m.decl)\n                     }\n \n                     &ast::provided(ref m) => {\n                         ty_method_of_trait_method(\n-                            ccx, trait_id, region_paramd, generics,\n+                            ccx, trait_id, &trait_ty_generics,\n                             &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, &m.decl)\n                     }\n@@ -264,13 +236,13 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                              trait_ty_generics: &ty::Generics) {\n         // If declaration is\n         //\n-        //     trait<A,B,C> {\n-        //        fn foo<D,E,F>(...) -> Self;\n+        //     trait<'a,'b,'c,A,B,C> {\n+        //        fn foo<'d,'e,'f,D,E,F>(...) -> Self;\n         //     }\n         //\n         // and we will create a function like\n         //\n-        //     fn foo<A',B',C',D',E',F',G'>(...) -> D' {}\n+        //     fn foo<'a,'b,'c,'d,'e,'f,A',B',C',D',E',F',G'>(...) -> D' {}\n         //\n         // Note that `Self` is replaced with an explicit type\n         // parameter D' that is sandwiched in between the trait params\n@@ -307,12 +279,19 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                          m.generics.type_param_defs[i].def_id)\n         };\n \n+        // Convert the regions 'a, 'b, 'c defined on the trait into\n+        // bound regions on the fn.\n+        let rps_from_trait = trait_ty_generics.region_param_defs.iter().map(|d| {\n+            ty::ReLateBound(m.fty.sig.binder_id,\n+                            ty::BrNamed(d.def_id, d.ident))\n+        }).collect();\n+\n         // build up the substitution from\n         //     A,B,C => A',B',C'\n         //     Self => D'\n         //     D,E,F => E',F',G'\n         let substs = substs {\n-            regions: ty::NonerasedRegions(opt_vec::Empty),\n+            regions: ty::NonerasedRegions(rps_from_trait),\n             self_ty: Some(self_param),\n             tps: non_shifted_trait_tps + shifted_method_tps\n         };\n@@ -357,16 +336,15 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                           ty_param_bounds_and_ty {\n                               generics: ty::Generics {\n                                   type_param_defs: @new_type_param_defs,\n-                                  region_param: trait_ty_generics.region_param\n+                                  region_param_defs: @[], // fn items\n                               },\n                               ty: ty\n                           });\n     }\n \n     fn ty_method_of_trait_method(this: &CrateCtxt,\n                                  trait_id: ast::NodeId,\n-                                 trait_rp: Option<ty::region_variance>,\n-                                 trait_generics: &ast::Generics,\n+                                 trait_generics: &ty::Generics,\n                                  m_id: &ast::NodeId,\n                                  m_ident: &ast::Ident,\n                                  m_explicit_self: &ast::explicit_self,\n@@ -375,14 +353,14 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  m_decl: &ast::fn_decl) -> ty::Method\n     {\n         let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n-        let rscope = MethodRscope::new(m_explicit_self.node, trait_rp, trait_generics);\n         let (transformed_self_ty, fty) =\n-            astconv::ty_of_method(this, &rscope, *m_purity, &m_generics.lifetimes,\n+            astconv::ty_of_method(this, *m_id, *m_purity,\n                                   trait_self_ty, *m_explicit_self, m_decl);\n-        let num_trait_type_params = trait_generics.ty_params.len();\n+        let num_trait_type_params = trait_generics.type_param_defs.len();\n         ty::Method::new(\n             *m_ident,\n-            ty_generics(this, None, m_generics, num_trait_type_params),\n+            // FIXME(#5121) -- distinguish early vs late lifetime params\n+            ty_generics(this, m_generics, num_trait_type_params),\n             transformed_self_ty,\n             fty,\n             m_explicit_self.node,\n@@ -398,9 +376,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::NodeId,\n                           sp: codemap::Span,\n-                          rp: Option<ty::region_variance>,\n-                          ast_trait_refs: &[ast::trait_ref],\n-                          generics: &ast::Generics) -> ty::BuiltinBounds\n+                          ast_trait_refs: &[ast::trait_ref])\n+                          -> ty::BuiltinBounds\n {\n     let tcx = ccx.tcx;\n \n@@ -416,8 +393,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         // FIXME(#8559): Need to instantiate the trait_ref whether or not it's a\n         // builtin trait, so that the trait's node id appears in the tcx trait_ref\n         // map. This is only needed for metadata; see the similar fixme in encoder.rs.\n-        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n-                                              generics, self_ty);\n+        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, self_ty);\n         if !ty::try_add_builtin_trait(ccx.tcx, trait_def_id, &mut bounds) {\n \n             // FIXME(#5527) Could have same trait multiple times\n@@ -435,376 +411,69 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     bounds\n }\n \n-/**\n- * Checks that a method from an impl/class conforms to the signature of\n- * the same method as declared in the trait.\n- *\n- * # Parameters\n- *\n- * - impl_tps: the type params declared on the impl itself (not the method!)\n- * - cm: info about the method we are checking\n- * - trait_m: the method in the trait\n- * - trait_substs: the substitutions used on the type of the trait\n- * - self_ty: the self type of the impl\n- */\n-pub fn compare_impl_method(tcx: ty::ctxt,\n-                           impl_tps: uint,\n-                           cm: &ConvertedMethod,\n-                           trait_m: &ty::Method,\n-                           trait_substs: &ty::substs,\n-                           self_ty: ty::t) {\n-    debug!(\"compare_impl_method()\");\n-    let infcx = infer::new_infer_ctxt(tcx);\n-\n-    let impl_m = &cm.mty;\n-\n-    // Try to give more informative error messages about self typing\n-    // mismatches.  Note that any mismatch will also be detected\n-    // below, where we construct a canonical function type that\n-    // includes the self parameter as a normal parameter.  It's just\n-    // that the error messages you get out of this code are a bit more\n-    // inscrutable, particularly for cases where one method has no\n-    // self.\n-    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ast::sty_static, &ast::sty_static) => {}\n-        (&ast::sty_static, _) => {\n-            tcx.sess.span_err(\n-                cm.span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n-                      but not in the trait\",\n-                     tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(&impl_m.explicit_self, tcx.sess.intr())));\n-            return;\n-        }\n-        (_, &ast::sty_static) => {\n-            tcx.sess.span_err(\n-                cm.span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n-                      but not in the impl\",\n-                     tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(&trait_m.explicit_self, tcx.sess.intr())));\n-            return;\n-        }\n-        _ => {\n-            // Let the type checker catch other errors below\n-        }\n-    }\n-\n-    let num_impl_m_type_params = impl_m.generics.type_param_defs.len();\n-    let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n-    if num_impl_m_type_params != num_trait_m_type_params {\n-        tcx.sess.span_err(\n-            cm.span,\n-            format!(\"method `{}` has {} type {}, but its trait \\\n-                  declaration has {} type {}\",\n-                 tcx.sess.str_of(trait_m.ident),\n-                 num_impl_m_type_params,\n-                 pluralize(num_impl_m_type_params, ~\"parameter\"),\n-                 num_trait_m_type_params,\n-                 pluralize(num_trait_m_type_params, ~\"parameter\")));\n-        return;\n-    }\n-\n-    if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n-        tcx.sess.span_err(\n-            cm.span,\n-            format!(\"method `{}` has {} parameter{} \\\n-                  but the trait has {}\",\n-                 tcx.sess.str_of(trait_m.ident),\n-                 impl_m.fty.sig.inputs.len(),\n-                 if impl_m.fty.sig.inputs.len() == 1 { \"\" } else { \"s\" },\n-                 trait_m.fty.sig.inputs.len()));\n-        return;\n-    }\n-\n-    for (i, trait_param_def) in trait_m.generics.type_param_defs.iter().enumerate() {\n-        // For each of the corresponding impl ty param's bounds...\n-        let impl_param_def = &impl_m.generics.type_param_defs[i];\n-\n-        // Check that the impl does not require any builtin-bounds\n-        // that the trait does not guarantee:\n-        let extra_bounds =\n-            impl_param_def.bounds.builtin_bounds -\n-            trait_param_def.bounds.builtin_bounds;\n-        if !extra_bounds.is_empty() {\n-           tcx.sess.span_err(\n-               cm.span,\n-               format!(\"in method `{}`, \\\n-                     type parameter {} requires `{}`, \\\n-                     which is not required by \\\n-                     the corresponding type parameter \\\n-                     in the trait declaration\",\n-                    tcx.sess.str_of(trait_m.ident),\n-                    i,\n-                    extra_bounds.user_string(tcx)));\n-           return;\n-        }\n-\n-        // FIXME(#2687)---we should be checking that the bounds of the\n-        // trait imply the bounds of the subtype, but it appears we\n-        // are...not checking this.\n-        if impl_param_def.bounds.trait_bounds.len() !=\n-            trait_param_def.bounds.trait_bounds.len()\n-        {\n-            tcx.sess.span_err(\n-                cm.span,\n-                format!(\"in method `{}`, \\\n-                      type parameter {} has {} trait {}, but the \\\n-                      corresponding type parameter in \\\n-                      the trait declaration has {} trait {}\",\n-                     tcx.sess.str_of(trait_m.ident),\n-                     i, impl_param_def.bounds.trait_bounds.len(),\n-                     pluralize(impl_param_def.bounds.trait_bounds.len(),\n-                               ~\"bound\"),\n-                     trait_param_def.bounds.trait_bounds.len(),\n-                     pluralize(trait_param_def.bounds.trait_bounds.len(),\n-                               ~\"bound\")));\n-            return;\n-        }\n-    }\n-\n-    // Replace any references to the self region in the self type with\n-    // a free region.  So, for example, if the impl type is\n-    // \"&'self str\", then this would replace the self type with a free\n-    // region `self`.\n-    let dummy_self_r = ty::re_free(ty::FreeRegion {scope_id: cm.body_id,\n-                                                   bound_region: ty::br_self});\n-    let self_ty = replace_bound_self(tcx, self_ty, dummy_self_r);\n-\n-    // We are going to create a synthetic fn type that includes\n-    // both the method's self argument and its normal arguments.\n-    // So a method like `fn(&self, a: uint)` would be converted\n-    // into a function `fn(self: &T, a: uint)`.\n-    let mut trait_fn_args = ~[];\n-    let mut impl_fn_args = ~[];\n-\n-    // For both the trait and the impl, create an argument to\n-    // represent the self argument (unless this is a static method).\n-    // This argument will have the *transformed* self type.\n-    for &t in trait_m.transformed_self_ty.iter() {\n-        trait_fn_args.push(t);\n-    }\n-    for &t in impl_m.transformed_self_ty.iter() {\n-        impl_fn_args.push(t);\n-    }\n-\n-    // Add in the normal arguments.\n-    trait_fn_args.push_all(trait_m.fty.sig.inputs);\n-    impl_fn_args.push_all(impl_m.fty.sig.inputs);\n-\n-    // Create a bare fn type for trait/impl that includes self argument\n-    let trait_fty =\n-        ty::mk_bare_fn(tcx,\n-                       ty::BareFnTy {\n-                            purity: trait_m.fty.purity,\n-                            abis: trait_m.fty.abis,\n-                            sig: ty::FnSig {\n-                                bound_lifetime_names:\n-                                    trait_m.fty\n-                                           .sig\n-                                           .bound_lifetime_names\n-                                           .clone(),\n-                                inputs: trait_fn_args,\n-                                output: trait_m.fty.sig.output,\n-                                variadic: false\n-                            }\n-                        });\n-    let impl_fty =\n-        ty::mk_bare_fn(tcx,\n-                       ty::BareFnTy {\n-                            purity: impl_m.fty.purity,\n-                            abis: impl_m.fty.abis,\n-                            sig: ty::FnSig {\n-                                bound_lifetime_names:\n-                                    impl_m.fty\n-                                          .sig\n-                                          .bound_lifetime_names\n-                                          .clone(),\n-                                    inputs: impl_fn_args,\n-                                    output: impl_m.fty.sig.output,\n-                                    variadic: false\n-                            }\n-                        });\n-\n-    // Perform substitutions so that the trait/impl methods are expressed\n-    // in terms of the same set of type/region parameters:\n-    // - replace trait type parameters with those from `trait_substs`,\n-    //   except with any reference to bound self replaced with `dummy_self_r`\n-    // - replace method parameters on the trait with fresh, dummy parameters\n-    //   that correspond to the parameters we will find on the impl\n-    // - replace self region with a fresh, dummy region\n-    let impl_fty = {\n-        debug!(\"impl_fty (pre-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n-        replace_bound_self(tcx, impl_fty, dummy_self_r)\n-    };\n-    debug!(\"impl_fty (post-subst): {}\", ppaux::ty_to_str(tcx, impl_fty));\n-    let trait_fty = {\n-        let num_trait_m_type_params = trait_m.generics.type_param_defs.len();\n-        let dummy_tps = do vec::from_fn(num_trait_m_type_params) |i| {\n-            ty::mk_param(tcx, i + impl_tps,\n-                         impl_m.generics.type_param_defs[i].def_id)\n-        };\n-        let trait_tps = trait_substs.tps.map(\n-            |t| replace_bound_self(tcx, *t, dummy_self_r));\n-        let substs = substs {\n-            regions: ty::NonerasedRegions(opt_vec::with(dummy_self_r)),\n-            self_ty: Some(self_ty),\n-            tps: vec::append(trait_tps, dummy_tps)\n-        };\n-        debug!(\"trait_fty (pre-subst): {} substs={}\",\n-               trait_fty.repr(tcx), substs.repr(tcx));\n-        ty::subst(tcx, &substs, trait_fty)\n-    };\n-    debug!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n-\n-    match infer::mk_subty(infcx, false, infer::MethodCompatCheck(cm.span),\n-                          impl_fty, trait_fty) {\n-        result::Ok(()) => {}\n-        result::Err(ref terr) => {\n-            tcx.sess.span_err(\n-                cm.span,\n-                format!(\"method `{}` has an incompatible type: {}\",\n-                     tcx.sess.str_of(trait_m.ident),\n-                     ty::type_err_to_str(tcx, terr)));\n-            ty::note_and_explain_type_err(tcx, terr);\n-        }\n-    }\n-    return;\n-\n-    // Replaces bound references to the self region with `with_r`.\n-    fn replace_bound_self(tcx: ty::ctxt, ty: ty::t,\n-                          with_r: ty::Region) -> ty::t {\n-        do ty::fold_regions(tcx, ty) |r, _in_fn| {\n-            if r == ty::re_bound(ty::br_self) {with_r} else {r}\n-        }\n-    }\n-}\n-\n-pub fn check_methods_against_trait(ccx: &CrateCtxt,\n-                                   generics: &ast::Generics,\n-                                   rp: Option<ty::region_variance>,\n-                                   selfty: ty::t,\n-                                   a_trait_ty: &ast::trait_ref,\n-                                   impl_ms: &[ConvertedMethod])\n-{\n-    let tcx = ccx.tcx;\n-    let trait_ref = instantiate_trait_ref(ccx, a_trait_ty, rp,\n-                                          generics, selfty);\n-\n-    if trait_ref.def_id.crate == ast::LOCAL_CRATE {\n-        ensure_trait_methods(ccx, trait_ref.def_id.node);\n-    }\n-\n-    // Check that each method we impl is a method on the trait\n-    // Trait methods we don't implement must be default methods, but if not\n-    // we'll catch it in coherence\n-    let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n-    for impl_m in impl_ms.iter() {\n-        match trait_ms.iter().find(|trait_m| trait_m.ident.name == impl_m.mty.ident.name) {\n-            Some(trait_m) => {\n-                let num_impl_tps = generics.ty_params.len();\n-                compare_impl_method(\n-                    ccx.tcx, num_impl_tps, impl_m, *trait_m,\n-                    &trait_ref.substs, selfty);\n-            }\n-            None => {\n-                // This method is not part of the trait\n-                tcx.sess.span_err(\n-                    impl_m.span,\n-                    format!(\"method `{}` is not a member of trait `{}`\",\n-                         tcx.sess.str_of(impl_m.mty.ident),\n-                         path_to_str(&a_trait_ty.path, tcx.sess.intr())));\n-            }\n-        }\n-    }\n-} // fn\n-\n pub fn convert_field(ccx: &CrateCtxt,\n-                     rp: Option<ty::region_variance>,\n-                     type_param_defs: @~[ty::TypeParameterDef],\n-                     v: &ast::struct_field,\n-                     generics: &ast::Generics) {\n-    let region_parameterization =\n-        RegionParameterization::from_variance_and_generics(rp, generics);\n-    let tt = ccx.to_ty(&TypeRscope(region_parameterization), &v.node.ty);\n+                     struct_generics: &ty::Generics,\n+                     v: &ast::struct_field) {\n+    let tt = ccx.to_ty(&ExplicitRscope, &v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n                           ty::ty_param_bounds_and_ty {\n-                              generics: ty::Generics {\n-                                  type_param_defs: type_param_defs,\n-                                  region_param: rp\n-                              },\n+                              generics: struct_generics.clone(),\n                               ty: tt\n                           });\n }\n \n-pub struct ConvertedMethod {\n-    mty: @ty::Method,\n-    id: ast::NodeId,\n-    span: Span,\n-    body_id: ast::NodeId\n-}\n-\n-pub fn convert_methods(ccx: &CrateCtxt,\n-                       container: MethodContainer,\n-                       ms: &[@ast::method],\n-                       untransformed_rcvr_ty: ty::t,\n-                       rcvr_ty_generics: &ty::Generics,\n-                       rcvr_ast_generics: &ast::Generics,\n-                       rcvr_visibility: ast::visibility)\n-                    -> ~[ConvertedMethod]\n+fn convert_methods(ccx: &CrateCtxt,\n+                   container: MethodContainer,\n+                   ms: &[@ast::method],\n+                   untransformed_rcvr_ty: ty::t,\n+                   rcvr_ty_generics: &ty::Generics,\n+                   rcvr_ast_generics: &ast::Generics,\n+                   rcvr_visibility: ast::visibility)\n {\n     let tcx = ccx.tcx;\n-    return ms.iter().map(|m| {\n+    for m in ms.iter() {\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs.len();\n-        let m_ty_generics =\n-            ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,\n-                        num_rcvr_ty_params);\n+        let m_ty_generics = ty_generics(ccx, &m.generics, num_rcvr_ty_params);\n         let mty = @ty_of_method(ccx,\n                                 container,\n                                 *m,\n-                                rcvr_ty_generics.region_param,\n                                 untransformed_rcvr_ty,\n                                 rcvr_ast_generics,\n-                                rcvr_visibility,\n-                                &m.generics);\n+                                rcvr_visibility);\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n+        debug!(\"method {} (id {}) has type {}\",\n+                m.ident.repr(ccx.tcx),\n+                m.id,\n+                fty.repr(ccx.tcx));\n         tcx.tcache.insert(\n             local_def(m.id),\n \n             // n.b.: the type of a method is parameterized by both\n-            // the tps on the receiver and those on the method itself\n+            // the parameters on the receiver and those on the method itself\n             ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @vec::append(\n                         (*rcvr_ty_generics.type_param_defs).clone(),\n                         *m_ty_generics.type_param_defs),\n-                    region_param: rcvr_ty_generics.region_param\n+                    region_param_defs: rcvr_ty_generics.region_param_defs,\n                 },\n                 ty: fty\n             });\n         write_ty_to_tcx(tcx, m.id, fty);\n         tcx.methods.insert(mty.def_id, mty);\n-        ConvertedMethod {mty: mty, id: m.id,\n-                         span: m.span, body_id: m.body.id}\n-    }).collect();\n+    }\n \n     fn ty_of_method(ccx: &CrateCtxt,\n                     container: MethodContainer,\n                     m: &ast::method,\n-                    rp: Option<ty::region_variance>,\n                     untransformed_rcvr_ty: ty::t,\n                     rcvr_generics: &ast::Generics,\n-                    rcvr_visibility: ast::visibility,\n-                    method_generics: &ast::Generics) -> ty::Method\n+                    rcvr_visibility: ast::visibility) -> ty::Method\n     {\n-        let rscope = MethodRscope::new(m.explicit_self.node,\n-                                       rp,\n-                                       rcvr_generics);\n         let (transformed_self_ty, fty) =\n-            astconv::ty_of_method(ccx, &rscope, m.purity,\n-                                  &method_generics.lifetimes,\n+            astconv::ty_of_method(ccx, m.id, m.purity,\n                                   untransformed_rcvr_ty,\n                                   m.explicit_self, &m.decl);\n \n@@ -817,7 +486,8 @@ pub fn convert_methods(ccx: &CrateCtxt,\n         let num_rcvr_type_params = rcvr_generics.ty_params.len();\n         ty::Method::new(\n             m.ident,\n-            ty_generics(ccx, None, &m.generics, num_rcvr_type_params),\n+            // FIXME(#5121) -- distinguish early vs late lifetime params\n+            ty_generics(ccx, &m.generics, num_rcvr_type_params),\n             transformed_self_ty,\n             fty,\n             m.explicit_self.node,\n@@ -845,27 +515,22 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n-    debug!(\"convert: item {} with id {} rp {:?}\",\n-           tcx.sess.str_of(it.ident), it.id, rp);\n+    debug!(\"convert: item {} with id {}\", tcx.sess.str_of(it.ident), it.id);\n     match it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n       ast::item_enum(ref enum_definition, ref generics) => {\n-        ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n-        let tpt = ty_of_item(ccx, it);\n-        write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        get_enum_variant_types(ccx,\n-                               tpt.ty,\n-                               enum_definition.variants,\n-                               generics,\n-                               rp);\n+          ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n+          let tpt = ty_of_item(ccx, it);\n+          write_ty_to_tcx(tcx, it.id, tpt.ty);\n+          get_enum_variant_types(ccx,\n+                                 tpt.ty,\n+                                 enum_definition.variants,\n+                                 generics);\n       }\n       ast::item_impl(ref generics, ref opt_trait_ref, ref selfty, ref ms) => {\n-        let i_ty_generics = ty_generics(ccx, rp, generics, 0);\n-        let region_parameterization =\n-            RegionParameterization::from_variance_and_generics(rp, generics);\n-        let selfty = ccx.to_ty(&TypeRscope(region_parameterization), selfty);\n+        let i_ty_generics = ty_generics(ccx, generics, 0);\n+        let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n                           ty_param_bounds_and_ty {\n@@ -883,41 +548,39 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n             it.vis\n         };\n \n-        let cms = convert_methods(ccx,\n-                                  ImplContainer(local_def(it.id)),\n-                                  *ms,\n-                                  selfty,\n-                                  &i_ty_generics,\n-                                  generics,\n-                                  parent_visibility);\n-        for t in opt_trait_ref.iter() {\n+        convert_methods(ccx,\n+                        ImplContainer(local_def(it.id)),\n+                        *ms,\n+                        selfty,\n+                        &i_ty_generics,\n+                        generics,\n+                        parent_visibility);\n+\n+        for trait_ref in opt_trait_ref.iter() {\n+            let trait_ref = instantiate_trait_ref(ccx, trait_ref, selfty);\n+\n             // Prevent the builtin kind traits from being manually implemented.\n-            let trait_def_id = ty::trait_ref_to_def_id(tcx, t);\n-            if tcx.lang_items.to_builtin_kind(trait_def_id).is_some() {\n+            if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_some() {\n                 tcx.sess.span_err(it.span,\n                     \"cannot provide an explicit implementation \\\n                      for a builtin kind\");\n             }\n-\n-            check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n       ast::item_trait(ref generics, _, ref trait_methods) => {\n-          let _trait_def = trait_def_of_item(ccx, it);\n+          let trait_def = trait_def_of_item(ccx, it);\n \n           // Run convert_methods on the provided methods.\n           let (_, provided_methods) =\n               split_trait_methods(*trait_methods);\n           let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n-          let (ty_generics, _) = mk_item_substs(ccx, generics, rp,\n-                                                Some(untransformed_rcvr_ty));\n-          let _ = convert_methods(ccx,\n-                                  TraitContainer(local_def(it.id)),\n-                                  provided_methods,\n-                                  untransformed_rcvr_ty,\n-                                  &ty_generics,\n-                                  generics,\n-                                  it.vis);\n+          convert_methods(ccx,\n+                          TraitContainer(local_def(it.id)),\n+                          provided_methods,\n+                          untransformed_rcvr_ty,\n+                          &trait_def.generics,\n+                          generics,\n+                          it.vis);\n \n           // We need to do this *after* converting methods, since\n           // convert_methods produces a tcache entry that is wrong for\n@@ -932,7 +595,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n \n-        convert_struct(ccx, rp, struct_def, generics, tpt, it.id);\n+        convert_struct(ccx, struct_def, tpt, it.id);\n       }\n       ast::item_ty(_, ref generics) => {\n         ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -950,18 +613,16 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n }\n \n pub fn convert_struct(ccx: &CrateCtxt,\n-                      rp: Option<ty::region_variance>,\n                       struct_def: &ast::struct_def,\n-                      generics: &ast::Generics,\n                       tpt: ty::ty_param_bounds_and_ty,\n                       id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members\n     for f in struct_def.fields.iter() {\n-       convert_field(ccx, rp, tpt.generics.type_param_defs, *f, generics);\n+       convert_field(ccx, &tpt.generics, *f);\n     }\n-    let (_, substs) = mk_item_substs(ccx, generics, rp, None);\n+    let substs = mk_item_substs(ccx, &tpt.generics, None);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -979,7 +640,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                     struct_def.fields.map(\n                         |field| ccx.tcx.tcache.get(\n                             &local_def(field.node.id)).ty);\n-                let ctor_fn_ty = ty::mk_ctor_fn(tcx, inputs, selfty);\n+                let ctor_fn_ty = ty::mk_ctor_fn(tcx, ctor_id, inputs, selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.insert(local_def(ctor_id), ty_param_bounds_and_ty {\n                     generics: tpt.generics,\n@@ -1014,8 +675,6 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n                              ast_trait_ref: &ast::trait_ref,\n-                             rp: Option<ty::region_variance>,\n-                             generics: &ast::Generics,\n                              self_ty: ty::t) -> @ty::TraitRef\n {\n     /*!\n@@ -1024,9 +683,8 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n      * trait. Fails if the type is a type other than an trait type.\n      */\n \n-    let rp = RegionParameterization::from_variance_and_generics(rp, generics);\n-\n-    let rscope = TypeRscope(rp);\n+    // FIXME(#5121) -- distinguish early vs late lifetime params\n+    let rscope = ExplicitRscope;\n \n     match lookup_def_tcx(ccx.tcx, ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n         ast::DefTrait(trait_did) => {\n@@ -1066,14 +724,12 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n       Some(&def) => return def,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n     match it.node {\n         ast::item_trait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n-            let (ty_generics, substs) = mk_item_substs(ccx, generics, rp,\n-                                                       Some(self_ty));\n-            let bounds = ensure_supertraits(ccx, it.id, it.span, rp,\n-                                            *supertraits, generics);\n+            let ty_generics = ty_generics(ccx, generics, 0);\n+            let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n+            let bounds = ensure_supertraits(ccx, it.id, it.span, *supertraits);\n             let trait_ref = @ty::TraitRef {def_id: def_id,\n                                            substs: substs};\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n@@ -1091,93 +747,89 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n }\n \n pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n-               -> ty::ty_param_bounds_and_ty {\n+                  -> ty::ty_param_bounds_and_ty {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.tcache.find(&def_id) {\n-      Some(&tpt) => return tpt,\n-      _ => {}\n+        Some(&tpt) => return tpt,\n+        _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n     match it.node {\n-      ast::item_static(ref t, _, _) => {\n-        let typ = ccx.to_ty(&EmptyRscope, t);\n-        let tpt = no_params(typ);\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n-      }\n-      ast::item_fn(ref decl, purity, abi, ref generics, _) => {\n-        assert!(rp.is_none());\n-        let ty_generics = ty_generics(ccx, None, generics, 0);\n-        let tofd = astconv::ty_of_bare_fn(ccx,\n-                                          &EmptyRscope,\n-                                          purity,\n-                                          abi,\n-                                          &generics.lifetimes,\n-                                          decl);\n-        let tpt = ty_param_bounds_and_ty {\n-            generics: ty::Generics {\n-                type_param_defs: ty_generics.type_param_defs,\n-                region_param: None\n-            },\n-            ty: ty::mk_bare_fn(ccx.tcx, tofd)\n-        };\n-        debug!(\"type of {} (id {}) is {}\",\n-               tcx.sess.str_of(it.ident),\n-               it.id,\n-               ppaux::ty_to_str(tcx, tpt.ty));\n-        ccx.tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n-      }\n-      ast::item_ty(ref t, ref generics) => {\n-        match tcx.tcache.find(&local_def(it.id)) {\n-          Some(&tpt) => return tpt,\n-          None => { }\n+        ast::item_static(ref t, _, _) => {\n+            let typ = ccx.to_ty(&ExplicitRscope, t);\n+            let tpt = no_params(typ);\n+            tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n         }\n-\n-        let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n-        let region_parameterization =\n-            RegionParameterization::from_variance_and_generics(rp, generics);\n-        let tpt = {\n-            let ty = ccx.to_ty(&TypeRscope(region_parameterization), t);\n-            ty_param_bounds_and_ty {\n-                generics: ty_generics(ccx, rp, generics, 0),\n-                ty: ty\n+        ast::item_fn(ref decl, purity, abi, ref generics, _) => {\n+            let ty_generics = ty_generics(ccx, generics, 0);\n+            let tofd = astconv::ty_of_bare_fn(ccx,\n+                                              it.id,\n+                                              purity,\n+                                              abi,\n+                                              decl);\n+            let tpt = ty_param_bounds_and_ty {\n+                generics: ty::Generics {\n+                    type_param_defs: ty_generics.type_param_defs,\n+                    region_param_defs: @[],\n+                },\n+                ty: ty::mk_bare_fn(ccx.tcx, tofd)\n+            };\n+            debug!(\"type of {} (id {}) is {}\",\n+                    tcx.sess.str_of(it.ident),\n+                    it.id,\n+                    ppaux::ty_to_str(tcx, tpt.ty));\n+            ccx.tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n+        }\n+        ast::item_ty(ref t, ref generics) => {\n+            match tcx.tcache.find(&local_def(it.id)) {\n+                Some(&tpt) => return tpt,\n+                None => { }\n             }\n-        };\n \n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n-      }\n-      ast::item_enum(_, ref generics) => {\n-        // Create a new generic polytype.\n-        let (ty_generics, substs) = mk_item_substs(ccx, generics, rp, None);\n-        let t = ty::mk_enum(tcx, local_def(it.id), substs);\n-        let tpt = ty_param_bounds_and_ty {\n-            generics: ty_generics,\n-            ty: t\n-        };\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n-      }\n-      ast::item_trait(*) => {\n-          tcx.sess.span_bug(\n-              it.span,\n-              format!(\"Invoked ty_of_item on trait\"));\n-      }\n-      ast::item_struct(_, ref generics) => {\n-          let (ty_generics, substs) = mk_item_substs(ccx, generics, rp, None);\n-          let t = ty::mk_struct(tcx, local_def(it.id), substs);\n-          let tpt = ty_param_bounds_and_ty {\n-              generics: ty_generics,\n-              ty: t\n-          };\n-          tcx.tcache.insert(local_def(it.id), tpt);\n-          return tpt;\n-      }\n-      ast::item_impl(*) | ast::item_mod(_) |\n-      ast::item_foreign_mod(_) => fail!(),\n-      ast::item_mac(*) => fail!(\"item macros unimplemented\")\n+            let tpt = {\n+                let ty = ccx.to_ty(&ExplicitRscope, t);\n+                ty_param_bounds_and_ty {\n+                    generics: ty_generics(ccx, generics, 0),\n+                    ty: ty\n+                }\n+            };\n+\n+            tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n+        }\n+        ast::item_enum(_, ref generics) => {\n+            // Create a new generic polytype.\n+            let ty_generics = ty_generics(ccx, generics, 0);\n+            let substs = mk_item_substs(ccx, &ty_generics, None);\n+            let t = ty::mk_enum(tcx, local_def(it.id), substs);\n+            let tpt = ty_param_bounds_and_ty {\n+                generics: ty_generics,\n+                ty: t\n+            };\n+            tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n+        }\n+        ast::item_trait(*) => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                format!(\"Invoked ty_of_item on trait\"));\n+        }\n+        ast::item_struct(_, ref generics) => {\n+            let ty_generics = ty_generics(ccx, generics, 0);\n+            let substs = mk_item_substs(ccx, &ty_generics, None);\n+            let t = ty::mk_struct(tcx, local_def(it.id), substs);\n+            let tpt = ty_param_bounds_and_ty {\n+                generics: ty_generics,\n+                ty: t\n+            };\n+            tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n+        }\n+        ast::item_impl(*) | ast::item_mod(_) |\n+        ast::item_foreign_mod(_) => fail!(),\n+        ast::item_mac(*) => fail!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1197,28 +849,29 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @~[],\n-                    region_param: None,\n+                    region_param_defs: @[],\n                 },\n-                ty: ast_ty_to_ty(ccx, &EmptyRscope, t)\n+                ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n             }\n         }\n     }\n }\n \n pub fn ty_generics(ccx: &CrateCtxt,\n-                   rp: Option<ty::region_variance>,\n                    generics: &ast::Generics,\n                    base_index: uint) -> ty::Generics {\n     return ty::Generics {\n-        region_param: rp,\n+        region_param_defs: generics.lifetimes.iter().map(|l| {\n+                ty::RegionParameterDef { ident: l.ident,\n+                                         def_id: local_def(l.id) }\n+            }).collect(),\n         type_param_defs: @generics.ty_params.mapi_to_vec(|offset, param| {\n             match ccx.tcx.ty_param_defs.find(&param.id) {\n                 Some(&def) => def,\n                 None => {\n                     let param_ty = ty::param_ty {idx: base_index + offset,\n                                                  def_id: local_def(param.id)};\n-                    let bounds = @compute_bounds(ccx, rp, generics,\n-                                                 param_ty, &param.bounds);\n+                    let bounds = @compute_bounds(ccx, param_ty, &param.bounds);\n                     let def = ty::TypeParameterDef {\n                         ident: param.ident,\n                         def_id: local_def(param.id),\n@@ -1234,13 +887,10 @@ pub fn ty_generics(ccx: &CrateCtxt,\n \n     fn compute_bounds(\n         ccx: &CrateCtxt,\n-        rp: Option<ty::region_variance>,\n-        generics: &ast::Generics,\n         param_ty: ty::param_ty,\n         ast_bounds: &OptVec<ast::TyParamBound>) -> ty::ParamBounds\n     {\n         /*!\n-         *\n          * Translate the AST's notion of ty param bounds (which are an\n          * enum consisting of a newtyped Ty or a region) to ty's\n          * notion of ty param bounds, which can either be user-defined\n@@ -1256,7 +906,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n             match *ast_bound {\n                 TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n-                    let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n+                    let trait_ref = instantiate_trait_ref(ccx, b, ty);\n                     if !ty::try_add_builtin_trait(\n                         ccx.tcx, trait_ref.def_id,\n                         &mut param_bounds.builtin_bounds)\n@@ -1282,9 +932,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              ast_generics: &ast::Generics,\n                              abis: AbiSet)\n                           -> ty::ty_param_bounds_and_ty {\n-    let ty_generics = ty_generics(ccx, None, ast_generics, 0);\n-    let region_param_names = RegionParamNames::from_generics(ast_generics);\n-    let rb = in_binding_rscope(&EmptyRscope, region_param_names);\n+    let ty_generics = ty_generics(ccx, ast_generics, 0);\n+    let rb = BindingRscope::new(def_id.node);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, a, None) );\n     let output_ty = ast_ty_to_ty(ccx, &rb, &decl.output);\n \n@@ -1293,12 +942,10 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         ty::BareFnTy {\n             abis: abis,\n             purity: ast::unsafe_fn,\n-            sig: ty::FnSig {\n-                bound_lifetime_names: opt_vec::Empty,\n-                inputs: input_tys,\n-                output: output_ty,\n-                variadic: decl.variadic\n-            }\n+            sig: ty::FnSig {binder_id: def_id.node,\n+                            inputs: input_tys,\n+                            output: output_ty,\n+                            variadic: decl.variadic}\n         });\n     let tpt = ty_param_bounds_and_ty {\n         generics: ty_generics,\n@@ -1309,19 +956,18 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n }\n \n pub fn mk_item_substs(ccx: &CrateCtxt,\n-                      ast_generics: &ast::Generics,\n-                      rp: Option<ty::region_variance>,\n-                      self_ty: Option<ty::t>) -> (ty::Generics, ty::substs)\n+                      ty_generics: &ty::Generics,\n+                      self_ty: Option<ty::t>) -> ty::substs\n {\n-    let mut i = 0;\n-    let ty_generics = ty_generics(ccx, rp, ast_generics, 0);\n-    let params = ast_generics.ty_params.map_to_vec(|atp| {\n-        let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n-        i += 1u;\n-        t\n-    });\n-    let regions = rscope::bound_self_region(rp);\n-    (ty_generics, substs {regions: ty::NonerasedRegions(regions),\n-                          self_ty: self_ty,\n-                          tps: params})\n+    let params: ~[ty::t] =\n+        ty_generics.type_param_defs.iter().enumerate().map(\n+            |(i, t)| ty::mk_param(ccx.tcx, i, t.def_id)).collect();\n+\n+    let regions: OptVec<ty::Region> =\n+        ty_generics.region_param_defs.iter().enumerate().map(\n+            |(i, l)| ty::ReEarlyBound(l.def_id.node, i, l.ident)).collect();\n+\n+    substs {regions: ty::NonerasedRegions(regions),\n+            self_ty: self_ty,\n+            tps: params}\n }"}, {"sha": "c42f74864d249d1ac63be19baed74b387f9eb509", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 90, "deletions": 109, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -123,76 +123,70 @@ pub trait Combine {\n         }\n     }\n \n-    fn substs(&self, generics: &ty::Generics, as_: &ty::substs,\n+    fn substs(&self,\n+              item_def_id: ast::DefId,\n+              as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n \n-        fn relate_region_params<C:Combine>(\n-                                           this: &C,\n-                                           generics: &ty::Generics,\n+        fn relate_region_params<C:Combine>(this: &C,\n+                                           item_def_id: ast::DefId,\n                                            a: &ty::RegionSubsts,\n                                            b: &ty::RegionSubsts)\n-            -> cres<ty::RegionSubsts>\n-            {\n+                                           -> cres<ty::RegionSubsts> {\n+            let tcx = this.infcx().tcx;\n             match (a, b) {\n-                (&ty::ErasedRegions, _) |\n-                    (_, &ty::ErasedRegions) => {\n+                (&ty::ErasedRegions, _) | (_, &ty::ErasedRegions) => {\n                     Ok(ty::ErasedRegions)\n                 }\n \n                 (&ty::NonerasedRegions(ref a_rs),\n                  &ty::NonerasedRegions(ref b_rs)) => {\n-                    match generics.region_param {\n-                        None => {\n-                            assert!(a_rs.is_empty());\n-                            assert!(b_rs.is_empty());\n-                            Ok(ty::NonerasedRegions(opt_vec::Empty))\n-                        }\n-\n-                        Some(variance) => {\n-                            assert_eq!(a_rs.len(), 1);\n-                            assert_eq!(b_rs.len(), 1);\n-                            let a_r = *a_rs.get(0);\n-                            let b_r = *b_rs.get(0);\n-\n-                            match variance {\n-                                ty::rv_invariant => {\n-                                    do eq_regions(this, a_r, b_r).then {\n-                                        Ok(ty::NonerasedRegions(opt_vec::with(a_r)))\n-                                    }\n-                                }\n-\n-                                ty::rv_covariant => {\n-                                    do this.regions(a_r, b_r).and_then |r| {\n-                                        Ok(ty::NonerasedRegions(opt_vec::with(r)))\n-                                    }\n-                                }\n-\n-                                ty::rv_contravariant => {\n-                                    do this.contraregions(a_r, b_r).and_then |r| {\n-                                        Ok(ty::NonerasedRegions(opt_vec::with(r)))\n-                                    }\n-                                }\n+                    let variances = ty::item_variances(tcx, item_def_id);\n+                    let region_params = &variances.region_params;\n+                    let num_region_params = region_params.len();\n+\n+                    debug!(\"relate_region_params(\\\n+                            item_def_id={}, \\\n+                            a_rs={}, \\\n+                            b_rs={},\n+                            region_params={})\",\n+                            item_def_id.repr(tcx),\n+                            a_rs.repr(tcx),\n+                            b_rs.repr(tcx),\n+                            region_params.repr(tcx));\n+\n+                    assert_eq!(num_region_params, a_rs.len());\n+                    assert_eq!(num_region_params, b_rs.len());\n+                    let mut rs = opt_vec::Empty;\n+                    for i in range(0, num_region_params) {\n+                        let a_r = *a_rs.get(i);\n+                        let b_r = *b_rs.get(i);\n+                        let variance = *region_params.get(i);\n+                        let r = match variance {\n+                            ty::Invariant => {\n+                                eq_regions(this, a_r, b_r)\n+                                    .and_then(|()| Ok(a_r))\n                             }\n-                        }\n+                            ty::Covariant => this.regions(a_r, b_r),\n+                            ty::Contravariant => this.contraregions(a_r, b_r),\n+                            ty::Bivariant => Ok(a_r),\n+                        };\n+                        rs.push(if_ok!(r));\n                     }\n+                    Ok(ty::NonerasedRegions(rs))\n                 }\n             }\n         }\n \n-        do self.tps(as_.tps, bs.tps).and_then |tps| {\n-            do self.self_tys(as_.self_ty, bs.self_ty).and_then |self_ty| {\n-                do relate_region_params(self,\n-                                        generics,\n-                                        &as_.regions,\n-                                        &bs.regions).and_then |regions| {\n-                    Ok(substs {\n-                            regions: regions,\n-                            self_ty: self_ty,\n-                            tps: tps.clone()\n-                        })\n-                }\n-            }\n-        }\n+        let tps = if_ok!(self.tps(as_.tps, bs.tps));\n+        let self_ty = if_ok!(self.self_tys(as_.self_ty, bs.self_ty));\n+        let regions = if_ok!(relate_region_params(self,\n+                                                  item_def_id,\n+                                                  &as_.regions,\n+                                                  &bs.regions));\n+        Ok(substs { regions: regions,\n+                    self_ty: self_ty,\n+                    tps: tps.clone() })\n     }\n \n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n@@ -267,9 +261,11 @@ pub trait Combine {\n                   -> cres<ty::Region>;\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n \n-    fn vstores(&self, vk: ty::terr_vstore_kind,\n-               a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-\n+    fn vstores(&self,\n+               vk: ty::terr_vstore_kind,\n+               a: ty::vstore,\n+               b: ty::vstore)\n+               -> cres<ty::vstore> {\n         debug!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n@@ -293,8 +289,7 @@ pub trait Combine {\n                     vk: ty::terr_vstore_kind,\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n-                 -> cres<ty::TraitStore> {\n-\n+                    -> cres<ty::TraitStore> {\n         debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n@@ -317,7 +312,8 @@ pub trait Combine {\n \n     fn trait_refs(&self,\n                   a: &ty::TraitRef,\n-                  b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+                  b: &ty::TraitRef)\n+                  -> cres<ty::TraitRef> {\n         // Different traits cannot be related\n \n         // - NOTE in the future, expand out subtraits!\n@@ -326,15 +322,9 @@ pub trait Combine {\n             Err(ty::terr_traits(\n                                 expected_found(self, a.def_id, b.def_id)))\n         } else {\n-            let tcx = self.infcx().tcx;\n-            let trait_def = ty::lookup_trait_def(tcx, a.def_id);\n-            let substs = if_ok!(self.substs(&trait_def.generics,\n-                                            &a.substs,\n-                                            &b.substs));\n-            Ok(ty::TraitRef {\n-                    def_id: a.def_id,\n-                    substs: substs\n-                })\n+            let substs = if_ok!(self.substs(a.def_id, &a.substs, &b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id,\n+                              substs: substs })\n         }\n     }\n }\n@@ -366,8 +356,8 @@ pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n                           -> ures {\n     debug!(\"eq_regions({}, {})\",\n-           a.inf_str(this.infcx()),\n-           b.inf_str(this.infcx()));\n+            a.repr(this.infcx().tcx),\n+            b.repr(this.infcx().tcx));\n     let sub = this.sub();\n     do indent {\n         this.infcx().try(|| {\n@@ -429,23 +419,20 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n         return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n     }\n \n-    do argvecs(this, a.inputs, b.inputs)\n-            .and_then |inputs| {\n-        do this.tys(a.output, b.output).and_then |output| {\n-            Ok(FnSig {\n-                bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n-                inputs: inputs.clone(),\n-                output: output,\n-                variadic: a.variadic\n-            })\n-        }\n-    }\n+    let inputs = if_ok!(argvecs(this, a.inputs, b.inputs));\n+    let output = if_ok!(this.tys(a.output, b.output));\n+    Ok(FnSig {binder_id: a.binder_id,\n+              inputs: inputs,\n+              output: output,\n+              variadic: a.variadic})\n }\n \n-pub fn super_tys<C:Combine>(\n-    this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n     let tcx = this.infcx().tcx;\n-    return match (&ty::get(a).sty, &ty::get(b).sty) {\n+    let a_sty = &ty::get(a).sty;\n+    let b_sty = &ty::get(b).sty;\n+    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    return match (a_sty, b_sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (&ty::ty_bot, _) |\n       (_, &ty::ty_bot) |\n@@ -494,6 +481,7 @@ pub fn super_tys<C:Combine>(\n             unify_float_variable(this, !this.a_is_expected(), v_id, v)\n         }\n \n+      (&ty::ty_char, _) |\n       (&ty::ty_nil, _) |\n       (&ty::ty_bool, _) |\n       (&ty::ty_int(_), _) |\n@@ -513,36 +501,30 @@ pub fn super_tys<C:Combine>(\n       (&ty::ty_enum(a_id, ref a_substs),\n        &ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n-          let type_def = ty::lookup_item_type(tcx, a_id);\n-          do this.substs(&type_def.generics, a_substs, b_substs).and_then |substs| {\n-              Ok(ty::mk_enum(tcx, a_id, substs))\n-          }\n+          let substs = if_ok!(this.substs(a_id,\n+                                          a_substs,\n+                                          b_substs));\n+          Ok(ty::mk_enum(tcx, a_id, substs))\n       }\n \n       (&ty::ty_trait(a_id, ref a_substs, a_store, a_mutbl, a_bounds),\n        &ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl, b_bounds))\n       if a_id == b_id && a_mutbl == b_mutbl => {\n-          let trait_def = ty::lookup_trait_def(tcx, a_id);\n-          do this.substs(&trait_def.generics, a_substs, b_substs).and_then |substs| {\n-              do this.trait_stores(ty::terr_trait, a_store, b_store).and_then |s| {\n-                  do this.bounds(a_bounds, b_bounds).and_then |bounds| {\n-                    Ok(ty::mk_trait(tcx,\n-                                    a_id,\n-                                    substs.clone(),\n-                                    s,\n-                                    a_mutbl,\n-                                    bounds))\n-                  }\n-              }\n-          }\n+          let substs = if_ok!(this.substs(a_id, a_substs, b_substs));\n+          let s = if_ok!(this.trait_stores(ty::terr_trait, a_store, b_store));\n+          let bounds = if_ok!(this.bounds(a_bounds, b_bounds));\n+          Ok(ty::mk_trait(tcx,\n+                          a_id,\n+                          substs.clone(),\n+                          s,\n+                          a_mutbl,\n+                          bounds))\n       }\n \n       (&ty::ty_struct(a_id, ref a_substs), &ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n-          let type_def = ty::lookup_item_type(tcx, a_id);\n-          do this.substs(&type_def.generics, a_substs, b_substs).and_then |substs| {\n-              Ok(ty::mk_struct(tcx, a_id, substs))\n-          }\n+            let substs = if_ok!(this.substs(a_id, a_substs, b_substs));\n+            Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n       (&ty::ty_box(ref a_mt), &ty::ty_box(ref b_mt)) => {\n@@ -578,9 +560,8 @@ pub fn super_tys<C:Combine>(\n       }\n \n       (&ty::ty_estr(vs_a), &ty::ty_estr(vs_b)) => {\n-        do this.vstores(ty::terr_str, vs_a, vs_b).and_then |vs| {\n-            Ok(ty::mk_estr(tcx,vs))\n-        }\n+        let vs = if_ok!(this.vstores(ty::terr_str, vs_a, vs_b));\n+        Ok(ty::mk_estr(tcx,vs))\n       }\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {"}, {"sha": "635de28194df9c5fa945965e0b6cf848e1d7c2c7", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 174, "deletions": 20, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -73,6 +73,7 @@ use middle::typeck::infer::region_inference::SubSupConflict;\n use middle::typeck::infer::region_inference::SupSupConflict;\n use syntax::opt_vec::OptVec;\n use util::ppaux::UserString;\n+use util::ppaux::bound_region_to_str;\n use util::ppaux::note_and_explain_region;\n \n pub trait ErrorReporting {\n@@ -110,6 +111,13 @@ pub trait ErrorReporting {\n                                region2: Region);\n }\n \n+trait ErrorReportingHelpers {\n+    fn report_inference_failure(@mut self,\n+                                var_origin: RegionVariableOrigin);\n+\n+    fn note_region_origin(@mut self,\n+                          origin: SubregionOrigin);\n+}\n \n impl ErrorReporting for InferCtxt {\n     fn report_region_errors(@mut self,\n@@ -398,30 +406,23 @@ impl ErrorReporting for InferCtxt {\n                                sub_region: Region,\n                                sup_origin: SubregionOrigin,\n                                sup_region: Region) {\n-        self.tcx.sess.span_err(\n-            var_origin.span(),\n-            format!(\"cannot infer an appropriate lifetime \\\n-                  due to conflicting requirements\"));\n+        self.report_inference_failure(var_origin);\n \n         note_and_explain_region(\n             self.tcx,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n-        self.tcx.sess.span_note(\n-            sup_origin.span(),\n-            format!(\"...due to the following expression\"));\n+        self.note_region_origin(sup_origin);\n \n         note_and_explain_region(\n             self.tcx,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");\n \n-        self.tcx.sess.span_note(\n-            sub_origin.span(),\n-            format!(\"...due to the following expression\"));\n+        self.note_region_origin(sub_origin);\n     }\n \n     fn report_sup_sup_conflict(@mut self,\n@@ -430,30 +431,183 @@ impl ErrorReporting for InferCtxt {\n                                region1: Region,\n                                origin2: SubregionOrigin,\n                                region2: Region) {\n-        self.tcx.sess.span_err(\n-            var_origin.span(),\n-            format!(\"cannot infer an appropriate lifetime \\\n-                  due to conflicting requirements\"));\n+        self.report_inference_failure(var_origin);\n \n         note_and_explain_region(\n             self.tcx,\n             \"first, the lifetime must be contained by \",\n             region1,\n             \"...\");\n \n-        self.tcx.sess.span_note(\n-            origin1.span(),\n-            format!(\"...due to the following expression\"));\n+        self.note_region_origin(origin1);\n \n         note_and_explain_region(\n             self.tcx,\n             \"but, the lifetime must also be contained by \",\n             region2,\n             \"...\");\n \n-        self.tcx.sess.span_note(\n-            origin2.span(),\n-            format!(\"...due to the following expression\"));\n+        self.note_region_origin(origin2);\n+    }\n+}\n+\n+impl ErrorReportingHelpers for InferCtxt {\n+    fn report_inference_failure(@mut self,\n+                                var_origin: RegionVariableOrigin) {\n+        let var_description = match var_origin {\n+            infer::MiscVariable(_) => ~\"\",\n+            infer::PatternRegion(_) => ~\" for pattern\",\n+            infer::AddrOfRegion(_) => ~\" for borrow expression\",\n+            infer::AddrOfSlice(_) => ~\" for slice expression\",\n+            infer::Autoref(_) => ~\" for autoref\",\n+            infer::Coercion(_) => ~\" for automatic coercion\",\n+            infer::BoundRegionInFnCall(_, br) => {\n+                format!(\" for {}in function call\",\n+                        bound_region_to_str(self.tcx, \"region \", true, br))\n+            }\n+            infer::BoundRegionInFnType(_, br) => {\n+                format!(\" for {}in function type\",\n+                        bound_region_to_str(self.tcx, \"region \", true, br))\n+            }\n+            infer::BoundRegionInTypeOrImpl(_) => {\n+                format!(\" for region in type/impl\")\n+            }\n+            infer::BoundRegionInCoherence(*) => {\n+                format!(\" for coherence check\")\n+            }\n+        };\n+\n+        self.tcx.sess.span_err(\n+            var_origin.span(),\n+            format!(\"cannot infer an appropriate lifetime{} \\\n+                    due to conflicting requirements\",\n+                    var_description));\n+    }\n+\n+    fn note_region_origin(@mut self,\n+                          origin: SubregionOrigin) {\n+        match origin {\n+            infer::Subtype(ref trace) => {\n+                let desc = match trace.origin {\n+                    infer::Misc(_) => {\n+                        format!(\"types are compatible\")\n+                    }\n+                    infer::MethodCompatCheck(_) => {\n+                        format!(\"method type is compatible with trait\")\n+                    }\n+                    infer::ExprAssignable(_) => {\n+                        format!(\"expression is assignable\")\n+                    }\n+                    infer::RelateTraitRefs(_) => {\n+                        format!(\"traits are compatible\")\n+                    }\n+                    infer::RelateSelfType(_) => {\n+                        format!(\"type matches impl\")\n+                    }\n+                    infer::MatchExpression(_) => {\n+                        format!(\"match arms have compatible types\")\n+                    }\n+                    infer::IfExpression(_) => {\n+                        format!(\"if and else have compatible types\")\n+                    }\n+                };\n+\n+                match self.values_str(&trace.values) {\n+                    Some(values_str) => {\n+                        self.tcx.sess.span_note(\n+                            trace.origin.span(),\n+                            format!(\"...so that {} ({})\",\n+                                    desc, values_str));\n+                    }\n+                    None => {\n+                        // Really should avoid printing this error at\n+                        // all, since it is derived, but that would\n+                        // require more refactoring than I feel like\n+                        // doing right now. - nmatsakis\n+                        self.tcx.sess.span_note(\n+                            trace.origin.span(),\n+                            format!(\"...so that {}\", desc));\n+                    }\n+                }\n+            }\n+            infer::Reborrow(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that borrowed pointer does not outlive \\\n+                    borrowed content\");\n+            }\n+            infer::InfStackClosure(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that closure does not outlive its stack frame\");\n+            }\n+            infer::InvokeClosure(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that closure is not invoked outside its lifetime\");\n+            }\n+            infer::DerefPointer(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that pointer is not dereferenced \\\n+                    outside its lifetime\");\n+            }\n+            infer::FreeVariable(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that captured variable does not outlive the \\\n+                    enclosing closure\");\n+            }\n+            infer::IndexSlice(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that slice is not indexed outside the lifetime\");\n+            }\n+            infer::RelateObjectBound(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that source pointer does not outlive \\\n+                     lifetime bound of the object type\");\n+            }\n+            infer::CallRcvr(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that method receiver is valid for the method call\");\n+            }\n+            infer::CallArg(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that argument is valid for the call\");\n+            }\n+            infer::CallReturn(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that return value is valid for the call\");\n+            }\n+            infer::AddrOf(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that borrowed pointer is valid \\\n+                     at the time of borrow\");\n+            }\n+            infer::AutoBorrow(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that automatically borrowed pointer is valid \\\n+                     at the time of borrow\");\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that variable is valid at time of its declaration\");\n+            }\n+            infer::ReferenceOutlivesReferent(_, span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that the pointer does not outlive the \\\n+                    data it points at\");\n+            }\n+        }\n     }\n }\n "}, {"sha": "9febef1c7c3997f91df0f6a6c1f3f30daafeafe4", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -20,15 +20,13 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n-use middle::typeck::isr_alist;\n use syntax::ast::{Many, Once, extern_fn, impure_fn, MutImmutable, MutMutable};\n-use syntax::ast::{unsafe_fn};\n+use syntax::ast::{unsafe_fn, NodeId};\n use syntax::ast::{Onceness, purity};\n+use std::hashmap::HashMap;\n use util::common::{indenter};\n use util::ppaux::mt_to_str;\n \n-use extra::list;\n-\n pub struct Glb(CombineFields);  // \"greatest lower bound\" (common subtype)\n \n impl Combine for Glb {\n@@ -132,14 +130,14 @@ impl Combine for Glb {\n         let snapshot = self.infcx.region_vars.start_snapshot();\n \n         // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_isr) =\n+        let (a_with_fresh, a_map) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.trace, a);\n-        let a_vars = var_ids(self, a_isr);\n-        let (b_with_fresh, b_isr) =\n+        let a_vars = var_ids(self, &a_map);\n+        let (b_with_fresh, b_map) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.trace, b);\n-        let b_vars = var_ids(self, b_isr);\n+        let b_vars = var_ids(self, &b_map);\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n@@ -152,20 +150,23 @@ impl Combine for Glb {\n             fold_regions_in_sig(\n                 self.infcx.tcx,\n                 &sig0,\n-                |r, _in_fn| generalize_region(self, snapshot,\n-                                              new_vars, a_isr, a_vars, b_vars,\n-                                              r));\n+                |r| generalize_region(self, snapshot,\n+                                      new_vars, sig0.binder_id,\n+                                      &a_map, a_vars, b_vars,\n+                                      r));\n         debug!(\"sig1 = {}\", sig1.inf_str(self.infcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,\n                              snapshot: uint,\n                              new_vars: &[RegionVid],\n-                             a_isr: isr_alist,\n+                             new_binder_id: NodeId,\n+                             a_map: &HashMap<ty::BoundRegion, ty::Region>,\n                              a_vars: &[RegionVid],\n                              b_vars: &[RegionVid],\n                              r0: ty::Region) -> ty::Region {\n             if !is_var_in_set(new_vars, r0) {\n+                assert!(!r0.is_bound());\n                 return r0;\n             }\n \n@@ -177,13 +178,13 @@ impl Combine for Glb {\n             for r in tainted.iter() {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {\n-                        return fresh_bound_variable(this);\n+                        return fresh_bound_variable(this, new_binder_id);\n                     } else {\n                         a_r = Some(*r);\n                     }\n                 } else if is_var_in_set(b_vars, *r) {\n                     if b_r.is_some() {\n-                        return fresh_bound_variable(this);\n+                        return fresh_bound_variable(this, new_binder_id);\n                     } else {\n                         b_r = Some(*r);\n                     }\n@@ -192,57 +193,57 @@ impl Combine for Glb {\n                 }\n             }\n \n-                // NB---I do not believe this algorithm computes\n-                // (necessarily) the GLB.  As written it can\n-                // spuriously fail.  In particular, if there is a case\n-                // like: &fn(fn(&a)) and fn(fn(&b)), where a and b are\n-                // free, it will return fn(&c) where c = GLB(a,b).  If\n-                // however this GLB is not defined, then the result is\n-                // an error, even though something like\n-                // \"fn<X>(fn(&X))\" where X is bound would be a\n-                // subtype of both of those.\n-                //\n-                // The problem is that if we were to return a bound\n-                // variable, we'd be computing a lower-bound, but not\n-                // necessarily the *greatest* lower-bound.\n+            // NB---I do not believe this algorithm computes\n+            // (necessarily) the GLB.  As written it can\n+            // spuriously fail.  In particular, if there is a case\n+            // like: &fn(fn(&a)) and fn(fn(&b)), where a and b are\n+            // free, it will return fn(&c) where c = GLB(a,b).  If\n+            // however this GLB is not defined, then the result is\n+            // an error, even though something like\n+            // \"fn<X>(fn(&X))\" where X is bound would be a\n+            // subtype of both of those.\n+            //\n+            // The problem is that if we were to return a bound\n+            // variable, we'd be computing a lower-bound, but not\n+            // necessarily the *greatest* lower-bound.\n+            //\n+            // Unfortunately, this problem is non-trivial to solve,\n+            // because we do not know at the time of computing the GLB\n+            // whether a GLB(a,b) exists or not, because we haven't\n+            // run region inference (or indeed, even fully computed\n+            // the region hierarchy!). The current algorithm seems to\n+            // works ok in practice.\n \n             if a_r.is_some() && b_r.is_some() && only_new_vars {\n                 // Related to exactly one bound variable from each fn:\n-                return rev_lookup(this, a_isr, a_r.unwrap());\n+                return rev_lookup(this, a_map, new_binder_id, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n+                assert!(!r0.is_bound());\n                 return r0;\n             } else {\n                 // Other:\n-                return fresh_bound_variable(this);\n+                return fresh_bound_variable(this, new_binder_id);\n             }\n         }\n \n         fn rev_lookup(this: &Glb,\n-                      a_isr: isr_alist,\n+                      a_map: &HashMap<ty::BoundRegion, ty::Region>,\n+                      new_binder_id: NodeId,\n                       r: ty::Region) -> ty::Region\n         {\n-            let mut ret = None;\n-            do list::each(a_isr) |pair| {\n-                let (a_br, a_r) = *pair;\n-                if a_r == r {\n-                    ret = Some(ty::re_bound(a_br));\n-                    false\n-                } else {\n-                    true\n+            for (a_br, a_r) in a_map.iter() {\n+                if *a_r == r {\n+                    return ty::ReLateBound(new_binder_id, *a_br);\n                 }\n-            };\n-\n-            match ret {\n-                Some(x) => x,\n-                None => this.infcx.tcx.sess.span_bug(\n-                            this.trace.origin.span(),\n-                            format!(\"could not find original bound region for {:?}\", r))\n             }\n+            this.infcx.tcx.sess.span_bug(\n+                this.trace.origin.span(),\n+                format!(\"could not find original bound region for {:?}\", r))\n         }\n \n-        fn fresh_bound_variable(this: &Glb) -> ty::Region {\n-            this.infcx.region_vars.new_bound()\n+        fn fresh_bound_variable(this: &Glb, binder_id: NodeId) -> ty::Region {\n+            this.infcx.region_vars.new_bound(binder_id)\n         }\n     }\n }"}, {"sha": "04bf5fda7258dab00abc2f51c30be8efd681262f", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -35,18 +35,16 @@\n \n use middle::ty::{RegionVid, TyVar, Vid};\n use middle::ty;\n-use middle::typeck::isr_alist;\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::unify::*;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n+use std::hashmap::HashMap;\n use util::common::indenter;\n \n-use extra::list;\n-\n pub trait LatticeValue {\n     fn sub(cf: &CombineFields, a: &Self, b: &Self) -> ures;\n     fn lub(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n@@ -366,14 +364,13 @@ impl TyLatticeDir for Glb {\n     }\n }\n \n-pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n-    this: &L,\n-    a: ty::t,\n-    b: ty::t) -> cres<ty::t> {\n+pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n+                                                            a: ty::t,\n+                                                            b: ty::t)\n+                                                            -> cres<ty::t> {\n     debug!(\"{}.lattice_tys({}, {})\", this.tag(),\n            a.inf_str(this.infcx()),\n            b.inf_str(this.infcx()));\n-    let _r = indenter();\n \n     if a == b {\n         return Ok(a);\n@@ -524,25 +521,22 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n \n-pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n-    let mut result = ~[];\n-    do list::each(isr) |pair| {\n-        match pair.second() {\n-            ty::re_infer(ty::ReVar(r)) => { result.push(r); }\n+pub fn var_ids<T:Combine>(this: &T,\n+                          map: &HashMap<ty::BoundRegion, ty::Region>)\n+                          -> ~[RegionVid] {\n+    map.iter().map(|(_, r)| match *r {\n+            ty::ReInfer(ty::ReVar(r)) => { r }\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n                     this.trace().origin.span(),\n                     format!(\"Found non-region-vid: {:?}\", r));\n             }\n-        }\n-        true\n-    };\n-    result\n+        }).collect()\n }\n \n pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n     match r {\n-        ty::re_infer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n+        ty::ReInfer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n         _ => false\n     }\n }"}, {"sha": "b826310df7bff7e78560a40f5c9cfefdb524d4c8", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -20,13 +20,11 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n-use middle::typeck::isr_alist;\n-use util::ppaux::mt_to_str;\n-\n-use extra::list;\n-use syntax::ast::{Many, Once, extern_fn, impure_fn};\n+use std::hashmap::HashMap;\n+use syntax::ast::{Many, Once, extern_fn, impure_fn, NodeId};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n+use util::ppaux::mt_to_str;\n \n pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n \n@@ -125,7 +123,7 @@ impl Combine for Lub {\n         let snapshot = self.infcx.region_vars.start_snapshot();\n \n         // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_isr) =\n+        let (a_with_fresh, a_map) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.trace, a);\n         let (b_with_fresh, _) =\n@@ -143,17 +141,20 @@ impl Combine for Lub {\n             fold_regions_in_sig(\n                 self.infcx.tcx,\n                 &sig0,\n-                |r, _in_fn| generalize_region(self, snapshot, new_vars,\n-                                              a_isr, r));\n+                |r| generalize_region(self, snapshot, new_vars,\n+                                      sig0.binder_id, &a_map, r));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Lub,\n                              snapshot: uint,\n                              new_vars: &[RegionVid],\n-                             a_isr: isr_alist,\n-                             r0: ty::Region) -> ty::Region {\n+                             new_scope: NodeId,\n+                             a_map: &HashMap<ty::BoundRegion, ty::Region>,\n+                             r0: ty::Region)\n+                             -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n+                assert!(!r0.is_bound());\n                 debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n@@ -167,6 +168,7 @@ impl Combine for Lub {\n                 debug!(\"generalize_region(r0={:?}): \\\n                         non-new-variables found in {:?}\",\n                        r0, tainted);\n+                assert!(!r0.is_bound());\n                 return r0;\n             }\n \n@@ -175,27 +177,19 @@ impl Combine for Lub {\n             // in both A and B.  Replace the variable with the \"first\"\n             // bound region from A that we find it to be associated\n             // with.\n-            let mut ret = None;\n-            do list::each(a_isr) |pair| {\n-                let (a_br, a_r) = *pair;\n-                if tainted.iter().any(|x| x == &a_r) {\n+            for (a_br, a_r) in a_map.iter() {\n+                if tainted.iter().any(|x| x == a_r) {\n                     debug!(\"generalize_region(r0={:?}): \\\n                             replacing with {:?}, tainted={:?}\",\n-                           r0, a_br, tainted);\n-                    ret = Some(ty::re_bound(a_br));\n-                    false\n-                } else {\n-                    true\n+                           r0, *a_br, tainted);\n+                    return ty::ReLateBound(new_scope, *a_br);\n                 }\n-            };\n-\n-            match ret {\n-                Some(x) => x,\n-                None => this.infcx.tcx.sess.span_bug(\n-                            this.trace.origin.span(),\n-                            format!(\"Region {:?} is not associated with \\\n-                                  any bound region from A!\", r0))\n             }\n+\n+            this.infcx.tcx.sess.span_bug(\n+                this.trace.origin.span(),\n+                format!(\"Region {:?} is not associated with \\\n+                        any bound region from A!\", r0))\n         }\n     }\n "}, {"sha": "eafc7e262f191ed67800485f6b715cc1f2f0bc76", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -20,8 +20,11 @@ pub use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n+use extra::smallintmap::SmallIntMap;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};\n use middle::typeck::infer::coercion::Coerce;\n use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n@@ -32,19 +35,16 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n-use middle::typeck::isr_alist;\n-use util::common::indent;\n-use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr,\n-                  UserString};\n-\n+use std::hashmap::HashMap;\n use std::result;\n use std::vec;\n-use extra::list::Nil;\n-use extra::smallintmap::SmallIntMap;\n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n+use util::common::indent;\n+use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr,\n+                  UserString};\n \n pub mod doc;\n pub mod macros;\n@@ -216,17 +216,15 @@ pub enum RegionVariableOrigin {\n \n     // Region variables created for bound regions\n     // in a function or method that is called\n-    BoundRegionInFnCall(Span, ty::bound_region),\n+    BoundRegionInFnCall(Span, ty::BoundRegion),\n \n     // Region variables created for bound regions\n     // when doing subtyping/lub/glb computations\n-    BoundRegionInFnType(Span, ty::bound_region),\n+    BoundRegionInFnType(Span, ty::BoundRegion),\n \n     BoundRegionInTypeOrImpl(Span),\n \n     BoundRegionInCoherence,\n-\n-    BoundRegionError(Span),\n }\n \n pub enum fixup_err {\n@@ -568,15 +566,16 @@ impl InferCtxt {\n     /// Execute `f`, unroll bindings on failure\n     pub fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n-        do indent {\n-            let snapshot = self.start_snapshot();\n-            let r = f();\n-            match r {\n-              Ok(_) => (),\n-              Err(_) => self.rollback_to(&snapshot)\n+        let snapshot = self.start_snapshot();\n+        let r = f();\n+        match r {\n+            Ok(_) => { debug!(\"success\"); }\n+            Err(ref e) => {\n+                debug!(\"error: {:?}\", *e);\n+                self.rollback_to(&snapshot)\n             }\n-            r\n         }\n+        r\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n@@ -639,7 +638,18 @@ impl InferCtxt {\n     }\n \n     pub fn next_region_var(&mut self, origin: RegionVariableOrigin) -> ty::Region {\n-        ty::re_infer(ty::ReVar(self.region_vars.new_region_var(origin)))\n+        ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n+    }\n+\n+    pub fn next_region_vars(&mut self,\n+                            origin: RegionVariableOrigin,\n+                            count: uint)\n+                            -> ~[ty::Region] {\n+        vec::from_fn(count, |_| self.next_region_var(origin))\n+    }\n+\n+    pub fn fresh_bound_region(&mut self, binder_id: ast::NodeId) -> ty::Region {\n+        self.region_vars.new_bound(binder_id)\n     }\n \n     pub fn resolve_regions(@mut self) {\n@@ -787,28 +797,28 @@ impl InferCtxt {\n     pub fn replace_bound_regions_with_fresh_regions(&mut self,\n                                                     trace: TypeTrace,\n                                                     fsig: &ty::FnSig)\n-                                                    -> (ty::FnSig, isr_alist) {\n-        let(isr, _, fn_sig) =\n-            replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n+                                                    -> (ty::FnSig,\n+                                                        HashMap<ty::BoundRegion,\n+                                                                ty::Region>) {\n+        let (map, _, fn_sig) =\n+            replace_bound_regions_in_fn_sig(self.tcx, None, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region {} maps to {:?}\",\n                        bound_region_to_str(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar\n             });\n-        (fn_sig, isr)\n+        (fn_sig, map)\n     }\n }\n \n pub fn fold_regions_in_sig(\n     tcx: ty::ctxt,\n     fn_sig: &ty::FnSig,\n-    fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n+    fldr: &fn(r: ty::Region) -> ty::Region) -> ty::FnSig\n {\n-    do ty::fold_sig(fn_sig) |t| {\n-        ty::fold_regions(tcx, t, |r, in_fn| fldr(r, in_fn))\n-    }\n+    ty_fold::RegionFolder::regions(tcx, fldr).fold_sig(fn_sig)\n }\n \n impl TypeTrace {\n@@ -910,7 +920,6 @@ impl RegionVariableOrigin {\n             BoundRegionInFnType(a, _) => a,\n             BoundRegionInTypeOrImpl(a) => a,\n             BoundRegionInCoherence => codemap::dummy_sp(),\n-            BoundRegionError(a) => a,\n         }\n     }\n }\n@@ -924,14 +933,13 @@ impl Repr for RegionVariableOrigin {\n             AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n             Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n-            BoundRegionInFnCall(a, b) => format!(\"BoundRegionInFnCall({},{})\",\n+            BoundRegionInFnCall(a, b) => format!(\"bound_regionInFnCall({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInFnType(a, b) => format!(\"BoundRegionInFnType({},{})\",\n+            BoundRegionInFnType(a, b) => format!(\"bound_regionInFnType({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInTypeOrImpl(a) => format!(\"BoundRegionInTypeOrImpl({})\",\n+            BoundRegionInTypeOrImpl(a) => format!(\"bound_regionInTypeOrImpl({})\",\n                                                a.repr(tcx)),\n-            BoundRegionInCoherence => format!(\"BoundRegionInCoherence\"),\n-            BoundRegionError(a) => format!(\"BoundRegionError({})\", a.repr(tcx)),\n+            BoundRegionInCoherence => format!(\"bound_regionInCoherence\"),\n         }\n     }\n }"}, {"sha": "e613aa4ba28de865aed15593e95e0313fd748032", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 107, "deletions": 87, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -13,8 +13,9 @@\n \n use middle::ty;\n use middle::ty::{FreeRegion, Region, RegionVid};\n-use middle::ty::{re_empty, re_static, re_infer, re_free, re_bound};\n-use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n+use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound,\n+                 ReLateBound};\n+use middle::ty::{ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::typeck::infer::cres;\n use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n use middle::typeck::infer;\n@@ -186,30 +187,39 @@ impl RegionVarBindings {\n         return vid;\n     }\n \n-    pub fn new_skolemized(&mut self, br: ty::bound_region) -> Region {\n+    pub fn new_skolemized(&mut self, br: ty::BoundRegion) -> Region {\n         let sc = self.skolemization_count;\n         self.skolemization_count += 1;\n-        re_infer(ReSkolemized(sc, br))\n+        ReInfer(ReSkolemized(sc, br))\n     }\n \n-    pub fn new_bound(&mut self) -> Region {\n+    pub fn new_bound(&mut self, binder_id: ast::NodeId) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n         //\n-        // This computation is mildly wrong in the face of rollover.\n-        // It's conceivable, if unlikely, that one might wind up with\n-        // accidental capture for nested functions in that case, if\n-        // the outer function had bound regions created a very long\n-        // time before and the inner function somehow wound up rolling\n-        // over such that supposedly fresh identifiers were in fact\n-        // shadowed.  We should convert our bound_region\n-        // representation to use deBruijn indices or something like\n-        // that to eliminate that possibility.\n+        // This computation is potentially wrong in the face of\n+        // rollover.  It's conceivable, if unlikely, that one might\n+        // wind up with accidental capture for nested functions in\n+        // that case, if the outer function had bound regions created\n+        // a very long time before and the inner function somehow\n+        // wound up rolling over such that supposedly fresh\n+        // identifiers were in fact shadowed. For now, we just assert\n+        // that there is no rollover -- eventually we should try to be\n+        // robust against this possibility, either by checking the set\n+        // of bound identifiers that appear in a given expression and\n+        // ensure that we generate one that is distinct, or by\n+        // changing the representation of bound regions in a fn\n+        // declaration\n \n         let sc = self.bound_count;\n         self.bound_count += 1;\n-        re_bound(br_fresh(sc))\n+\n+        if sc >= self.bound_count {\n+            self.tcx.sess.bug(\"Rollover in RegionInference new_bound()\");\n+        }\n+\n+        ReLateBound(binder_id, BrFresh(sc))\n     }\n \n     pub fn add_constraint(&mut self,\n@@ -236,25 +246,25 @@ impl RegionVarBindings {\n \n         debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n-          (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n+          (ReEarlyBound(*), _) |\n+          (ReLateBound(*), _) |\n+          (_, ReEarlyBound(*)) |\n+          (_, ReLateBound(*)) => {\n+            self.tcx.sess.span_bug(\n+                origin.span(),\n+                format!(\"Cannot relate bound region: {} <= {}\",\n+                        sub.repr(self.tcx),\n+                        sup.repr(self.tcx)));\n+          }\n+          (ReInfer(ReVar(sub_id)), ReInfer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n           }\n-          (r, re_infer(ReVar(sup_id))) => {\n+          (r, ReInfer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n           }\n-          (re_infer(ReVar(sub_id)), r) => {\n+          (ReInfer(ReVar(sub_id)), r) => {\n             self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n           }\n-          (re_bound(br), _) => {\n-            self.tcx.sess.span_bug(\n-                origin.span(),\n-                format!(\"Cannot relate bound region as subregion: {:?}\", br));\n-          }\n-          (_, re_bound(br)) => {\n-            self.tcx.sess.span_bug(\n-                origin.span(),\n-                format!(\"Cannot relate bound region as superregion: {:?}\", br));\n-          }\n           _ => {\n             self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n           }\n@@ -271,8 +281,8 @@ impl RegionVarBindings {\n \n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (re_static, _) | (_, re_static) => {\n-                re_static // nothing lives longer than static\n+            (ReStatic, _) | (_, ReStatic) => {\n+                ReStatic // nothing lives longer than static\n             }\n \n             _ => {\n@@ -294,7 +304,7 @@ impl RegionVarBindings {\n \n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (re_static, r) | (r, re_static) => {\n+            (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n                 r\n             }\n@@ -323,13 +333,13 @@ impl RegionVarBindings {\n             Value(r) => r,\n \n             NoValue => {\n-                // No constraints, return ty::re_empty\n-                re_empty\n+                // No constraints, return ty::ReEmpty\n+                ReEmpty\n             }\n \n             ErrorValue => {\n                 // An error that has previously been reported.\n-                re_static\n+                ReStatic\n             }\n         }\n     }\n@@ -356,7 +366,7 @@ impl RegionVarBindings {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).find(&vars) {\n             Some(&c) => {\n-                return re_infer(ReVar(c));\n+                return ReInfer(ReVar(c));\n             }\n             None => {}\n         }\n@@ -365,10 +375,10 @@ impl RegionVarBindings {\n         if self.in_snapshot() {\n             self.undo_log.push(AddCombination(t, vars));\n         }\n-        relate(self, a, re_infer(ReVar(c)));\n-        relate(self, b, re_infer(ReVar(c)));\n+        relate(self, a, ReInfer(ReVar(c)));\n+        relate(self, b, ReInfer(ReVar(c)));\n         debug!(\"combine_vars() c={:?}\", c);\n-        re_infer(ReVar(c))\n+        ReInfer(ReVar(c))\n     }\n \n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n@@ -411,14 +421,14 @@ impl RegionVarBindings {\n                 // nb: can't use uint::range() here as we move result_set\n                 let regs = match self.undo_log[undo_index] {\n                     AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n-                        Some((re_infer(ReVar(*a)),\n-                              re_infer(ReVar(*b))))\n+                        Some((ReInfer(ReVar(*a)),\n+                              ReInfer(ReVar(*b))))\n                     }\n                     AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n-                        Some((*a, re_infer(ReVar(*b))))\n+                        Some((*a, ReInfer(ReVar(*b))))\n                     }\n                     AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n-                        Some((re_infer(ReVar(*a)), *b))\n+                        Some((ReInfer(ReVar(*a)), *b))\n                     }\n                     AddConstraint(ConstrainRegSubReg(a, b)) => {\n                         Some((a, b))\n@@ -485,23 +495,33 @@ impl RegionVarBindings {\n \n     fn lub_concrete_regions(&self, a: Region, b: Region) -> Region {\n         match (a, b) {\n-          (re_static, _) | (_, re_static) => {\n-            re_static // nothing lives longer than static\n+          (ReLateBound(*), _) |\n+          (_, ReLateBound(*)) |\n+          (ReEarlyBound(*), _) |\n+          (_, ReEarlyBound(*)) => {\n+            self.tcx.sess.bug(\n+                format!(\"Cannot relate bound region: LUB({}, {})\",\n+                        a.repr(self.tcx),\n+                        b.repr(self.tcx)));\n           }\n \n-          (re_empty, r) | (r, re_empty) => {\n+          (ReStatic, _) | (_, ReStatic) => {\n+            ReStatic // nothing lives longer than static\n+          }\n+\n+          (ReEmpty, r) | (r, ReEmpty) => {\n             r // everything lives longer than empty\n           }\n \n-          (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n+          (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 self.var_origins[v_id.to_uint()].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: {:?}, {:?}\", a, b));\n           }\n \n-          (f @ re_free(ref fr), re_scope(s_id)) |\n-          (re_scope(s_id), f @ re_free(ref fr)) => {\n+          (f @ ReFree(ref fr), ReScope(s_id)) |\n+          (ReScope(s_id), f @ ReFree(ref fr)) => {\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n@@ -514,35 +534,30 @@ impl RegionVarBindings {\n \n               // otherwise, we don't know what the free region is,\n               // so we must conservatively say the LUB is static:\n-              _ => re_static\n+              _ => ReStatic\n             }\n           }\n \n-          (re_scope(a_id), re_scope(b_id)) => {\n+          (ReScope(a_id), ReScope(b_id)) => {\n             // The region corresponding to an outer block is a\n             // subtype of the region corresponding to an inner\n             // block.\n             let rm = self.tcx.region_maps;\n             match rm.nearest_common_ancestor(a_id, b_id) {\n-              Some(r_id) => re_scope(r_id),\n-              _ => re_static\n+              Some(r_id) => ReScope(r_id),\n+              _ => ReStatic\n             }\n           }\n \n-          (re_free(ref a_fr), re_free(ref b_fr)) => {\n+          (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n              self.lub_free_regions(a_fr, b_fr)\n           }\n \n           // For these types, we cannot define any additional\n           // relationship:\n-          (re_infer(ReSkolemized(*)), _) |\n-          (_, re_infer(ReSkolemized(*))) |\n-          (re_bound(_), re_bound(_)) |\n-          (re_bound(_), re_free(_)) |\n-          (re_bound(_), re_scope(_)) |\n-          (re_free(_), re_bound(_)) |\n-          (re_scope(_), re_bound(_)) => {\n-            if a == b {a} else {re_static}\n+          (ReInfer(ReSkolemized(*)), _) |\n+          (_, ReInfer(ReSkolemized(*))) => {\n+            if a == b {a} else {ReStatic}\n           }\n         }\n     }\n@@ -560,7 +575,7 @@ impl RegionVarBindings {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n             Greater => helper(self, b, a),\n-            Equal => ty::re_free(*a)\n+            Equal => ty::ReFree(*a)\n         };\n \n         fn helper(this: &RegionVarBindings,\n@@ -569,11 +584,11 @@ impl RegionVarBindings {\n         {\n             let rm = this.tcx.region_maps;\n             if rm.sub_free_region(*a, *b) {\n-                ty::re_free(*b)\n+                ty::ReFree(*b)\n             } else if rm.sub_free_region(*b, *a) {\n-                ty::re_free(*a)\n+                ty::ReFree(*a)\n             } else {\n-                ty::re_static\n+                ty::ReStatic\n             }\n         }\n     }\n@@ -584,26 +599,36 @@ impl RegionVarBindings {\n                          -> cres<Region> {\n         debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (re_static, r) | (r, re_static) => {\n+            (ReLateBound(*), _) |\n+            (_, ReLateBound(*)) |\n+            (ReEarlyBound(*), _) |\n+            (_, ReEarlyBound(*)) => {\n+              self.tcx.sess.bug(\n+                  format!(\"Cannot relate bound region: GLB({}, {})\",\n+                          a.repr(self.tcx),\n+                          b.repr(self.tcx)));\n+            }\n+\n+            (ReStatic, r) | (r, ReStatic) => {\n                 // static lives longer than everything else\n                 Ok(r)\n             }\n \n-            (re_empty, _) | (_, re_empty) => {\n+            (ReEmpty, _) | (_, ReEmpty) => {\n                 // nothing lives shorter than everything else\n-                Ok(re_empty)\n+                Ok(ReEmpty)\n             }\n \n-            (re_infer(ReVar(v_id)), _) |\n-            (_, re_infer(ReVar(v_id))) => {\n+            (ReInfer(ReVar(v_id)), _) |\n+            (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n                     self.var_origins[v_id.to_uint()].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: {:?}, {:?}\", a, b));\n             }\n \n-            (re_free(ref fr), s @ re_scope(s_id)) |\n-            (s @ re_scope(s_id), re_free(ref fr)) => {\n+            (ReFree(ref fr), s @ ReScope(s_id)) |\n+            (s @ ReScope(s_id), ReFree(ref fr)) => {\n                 // Free region is something \"at least as big as\n                 // `fr.scope_id`.\"  If we find that the scope `fr.scope_id` is bigger\n                 // than the scope `s_id`, then we can say that the GLB\n@@ -616,23 +641,18 @@ impl RegionVarBindings {\n                 }\n             }\n \n-            (re_scope(a_id), re_scope(b_id)) => {\n+            (ReScope(a_id), ReScope(b_id)) => {\n                 self.intersect_scopes(a, b, a_id, b_id)\n             }\n \n-            (re_free(ref a_fr), re_free(ref b_fr)) => {\n+            (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n                 self.glb_free_regions(a_fr, b_fr)\n             }\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (re_infer(ReSkolemized(*)), _) |\n-            (_, re_infer(ReSkolemized(*))) |\n-            (re_bound(_), re_bound(_)) |\n-            (re_bound(_), re_free(_)) |\n-            (re_bound(_), re_scope(_)) |\n-            (re_free(_), re_bound(_)) |\n-            (re_scope(_), re_bound(_)) => {\n+            (ReInfer(ReSkolemized(*)), _) |\n+            (_, ReInfer(ReSkolemized(*))) => {\n                 if a == b {\n                     Ok(a)\n                 } else {\n@@ -655,7 +675,7 @@ impl RegionVarBindings {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n             Greater => helper(self, b, a),\n-            Equal => Ok(ty::re_free(*a))\n+            Equal => Ok(ty::ReFree(*a))\n         };\n \n         fn helper(this: &RegionVarBindings,\n@@ -664,11 +684,11 @@ impl RegionVarBindings {\n         {\n             let rm = this.tcx.region_maps;\n             if rm.sub_free_region(*a, *b) {\n-                Ok(ty::re_free(*a))\n+                Ok(ty::ReFree(*a))\n             } else if rm.sub_free_region(*b, *a) {\n-                Ok(ty::re_free(*b))\n+                Ok(ty::ReFree(*b))\n             } else {\n-                this.intersect_scopes(ty::re_free(*a), ty::re_free(*b),\n+                this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n                                       a.scope_id, b.scope_id)\n             }\n         }\n@@ -695,8 +715,8 @@ impl RegionVarBindings {\n                scope_a, scope_b, region_a, region_b);\n         let rm = self.tcx.region_maps;\n         match rm.nearest_common_ancestor(scope_a, scope_b) {\n-            Some(r_id) if scope_a == r_id => Ok(re_scope(scope_b)),\n-            Some(r_id) if scope_b == r_id => Ok(re_scope(scope_a)),\n+            Some(r_id) if scope_a == r_id => Ok(ReScope(scope_b)),\n+            Some(r_id) if scope_b == r_id => Ok(ReScope(scope_a)),\n             _ => Err(ty::terr_regions_no_overlap(region_a, region_b))\n         }\n     }"}, {"sha": "168d8a57c7fecbecab90ebc2d683bfae59ca3cc1", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -50,6 +50,7 @@\n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{type_is_bot, IntType, UintType};\n use middle::ty;\n+use middle::ty_fold;\n use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{region_var_bound_by_region_var, unresolved_ty};\n use middle::typeck::infer::to_str::InferStr;\n@@ -96,6 +97,20 @@ pub fn resolver(infcx: @mut InferCtxt, modes: uint) -> ResolveState {\n     }\n }\n \n+impl ty_fold::TypeFolder for ResolveState {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        self.resolve_type(t)\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        self.resolve_region(r)\n+    }\n+}\n+\n impl ResolveState {\n     pub fn should(&mut self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n@@ -166,11 +181,7 @@ impl ResolveState {\n                     typ\n                 } else {\n                     self.type_depth += 1;\n-                    let result = ty::fold_regions_and_ty(\n-                        self.infcx.tcx, typ,\n-                        |r| self.resolve_region(r),\n-                        |t| self.resolve_type(t),\n-                        |t| self.resolve_type(t));\n+                    let result = ty_fold::super_fold_ty(self, typ);\n                     self.type_depth -= 1;\n                     result\n                 }\n@@ -181,21 +192,21 @@ impl ResolveState {\n     pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n         debug!(\"Resolve_region({})\", orig.inf_str(self.infcx));\n         match orig {\n-          ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n+          ty::ReInfer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig\n         }\n     }\n \n     pub fn resolve_region_var(&mut self, rid: RegionVid) -> ty::Region {\n         if !self.should(resolve_rvar) {\n-            return ty::re_infer(ty::ReVar(rid));\n+            return ty::ReInfer(ty::ReVar(rid));\n         }\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n     pub fn assert_not_rvar(&mut self, rid: RegionVid, r: ty::Region) {\n         match r {\n-          ty::re_infer(ty::ReVar(rid2)) => {\n+          ty::ReInfer(ty::ReVar(rid2)) => {\n             self.err = Some(region_var_bound_by_region_var(rid, rid2));\n           }\n           _ => { }"}, {"sha": "117b100005a01b90bd0b8636c647795b82b09ac3", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -24,8 +24,6 @@ use middle::typeck::infer::{TypeTrace, Subtype};\n use util::common::{indenter};\n use util::ppaux::bound_region_to_str;\n \n-use extra::list::Nil;\n-use extra::list;\n use syntax::ast::{Onceness, purity};\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n@@ -168,9 +166,8 @@ impl Combine for Sub {\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n-        let (skol_isr, _, b_sig) = {\n-            do replace_bound_regions_in_fn_sig(self.infcx.tcx, @Nil,\n-                                              None, b) |br| {\n+        let (skol_map, _, b_sig) = {\n+            do replace_bound_regions_in_fn_sig(self.infcx.tcx, None, b) |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.infcx.tcx, \"\", false, br),\n@@ -189,16 +186,13 @@ impl Combine for Sub {\n         // that the skolemized regions do not \"leak\".\n         let new_vars =\n             self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n-\n-        let mut ret = Ok(sig);\n-        do list::each(skol_isr) |pair| {\n-            let (skol_br, skol) = *pair;\n+        for (&skol_br, &skol) in skol_map.iter() {\n             let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n             for tainted_region in tainted.iter() {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n                 match *tainted_region {\n-                    ty::re_infer(ty::ReVar(ref vid)) => {\n+                    ty::ReInfer(ty::ReVar(ref vid)) => {\n                         if new_vars.iter().any(|x| x == vid) { continue; }\n                     }\n                     _ => {\n@@ -208,19 +202,16 @@ impl Combine for Sub {\n \n                 // A is not as polymorphic as B:\n                 if self.a_is_expected {\n-                    ret = Err(ty::terr_regions_insufficiently_polymorphic(\n-                        skol_br, *tainted_region));\n-                    break\n+                    return Err(ty::terr_regions_insufficiently_polymorphic(\n+                            skol_br, *tainted_region));\n                 } else {\n-                    ret = Err(ty::terr_regions_overly_polymorphic(\n-                        skol_br, *tainted_region));\n-                    break\n+                    return Err(ty::terr_regions_overly_polymorphic(\n+                            skol_br, *tainted_region));\n                 }\n             }\n-            ret.is_ok()\n-        };\n+        }\n \n-        ret\n+        return Ok(sig);\n     }\n \n }"}, {"sha": "7c56594d26755a653a9914a34c13b1fb087748f3", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -188,7 +188,7 @@ impl Env {\n             meta: FnMeta {purity: ast::impure_fn,\n                           proto: ast::ProtoBare,\n                           onceness: ast::Many,\n-                          region: ty::re_static,\n+                          region: ty::ReStatic,\n                           bounds: @~[]},\n             sig: FnSig {\n                 inputs: inputs,\n@@ -203,22 +203,22 @@ impl Env {\n     }\n \n     pub fn t_rptr_bound(&self, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_bound(ty::br_anon(id)), self.t_int())\n+        ty::mk_imm_rptr(self.tcx, ty::re_bound(ty::BrAnon(id)), self.t_int())\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::node_id) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_scope(id), self.t_int())\n+        ty::mk_imm_rptr(self.tcx, ty::ReScope(id), self.t_int())\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::node_id, id: uint) -> ty::t {\n         ty::mk_imm_rptr(self.tcx,\n-                        ty::re_free(ty::FreeRegion {scope_id: nid,\n-                                                    bound_region: ty::br_anon(id)}),\n+                        ty::ReFree(ty::FreeRegion {scope_id: nid,\n+                                                    bound_region: ty::BrAnon(id)}),\n                         self.t_int())\n     }\n \n     pub fn t_rptr_static(&self) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_static, self.t_int())\n+        ty::mk_imm_rptr(self.tcx, ty::ReStatic, self.t_int())\n     }\n \n     pub fn lub() -> Lub { Lub(self.infcx.combine_fields(true, dummy_sp())) }"}, {"sha": "63ddc9addc55edd00d90846f98c656b563ed45eb", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -19,16 +19,23 @@ The type checker is responsible for:\n 3. Guaranteeing that most type rules are met (\"most?\", you say, \"why most?\"\n    Well, dear reader, read on)\n \n-The main entry point is `check_crate()`.  Type checking operates in two major\n-phases: collect and check.  The collect phase passes over all items and\n-determines their type, without examining their \"innards\".  The check phase\n-then checks function bodies and so forth.\n+The main entry point is `check_crate()`.  Type checking operates in\n+several major phases:\n \n-Within the check phase, we check each function body one at a time (bodies of\n-function expressions are checked as part of the containing function).\n-Inference is used to supply types wherever they are unknown. The actual\n-checking of a function itself has several phases (check, regionck, writeback),\n-as discussed in the documentation for the `check` module.\n+1. The collect phase first passes over all items and determines their\n+   type, without examining their \"innards\".\n+\n+2. Variance inference then runs to compute the variance of each parameter\n+\n+3. Coherence checks for overlapping or orphaned impls\n+\n+4. Finally, the check phase then checks function bodies and so forth.\n+   Within the check phase, we check each function body one at a time\n+   (bodies of function expressions are checked as part of the\n+   containing function).  Inference is used to supply types wherever\n+   they are unknown. The actual checking of a function itself has\n+   several phases (check, regionck, writeback), as discussed in the\n+   documentation for the `check` module.\n \n The type checker is defined into various submodules which are documented\n independently:\n@@ -39,6 +46,10 @@ independently:\n - collect: computes the types of each top-level item and enters them into\n   the `cx.tcache` table for later use\n \n+- coherence: enforces coherence rules, builds some tables\n+\n+- variance: variance inference\n+\n - check: walks over function bodies and type checks them, inferring types for\n   local variables, type parameters, etc as necessary.\n \n@@ -64,14 +75,14 @@ use extra::list;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n-use syntax::opt_vec;\n \n pub mod check;\n pub mod rscope;\n pub mod astconv;\n pub mod infer;\n pub mod collect;\n pub mod coherence;\n+pub mod variance;\n \n #[deriving(Clone, Encodable, Decodable, Eq, Ord)]\n pub enum param_index {\n@@ -266,7 +277,7 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: @~[],\n-                                region_param: None},\n+                                region_param_defs: @[]},\n         ty: t\n     }\n }\n@@ -306,19 +317,19 @@ pub fn require_same_types(\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::Region\n-pub type isr_alist = @List<(ty::bound_region, ty::Region)>;\n+pub type isr_alist = @List<(ty::BoundRegion, ty::Region)>;\n \n trait get_and_find_region {\n-    fn get(&self, br: ty::bound_region) -> ty::Region;\n-    fn find(&self, br: ty::bound_region) -> Option<ty::Region>;\n+    fn get(&self, br: ty::BoundRegion) -> ty::Region;\n+    fn find(&self, br: ty::BoundRegion) -> Option<ty::Region>;\n }\n \n impl get_and_find_region for isr_alist {\n-    fn get(&self, br: ty::bound_region) -> ty::Region {\n+    fn get(&self, br: ty::BoundRegion) -> ty::Region {\n         self.find(br).unwrap()\n     }\n \n-    fn find(&self, br: ty::bound_region) -> Option<ty::Region> {\n+    fn find(&self, br: ty::BoundRegion) -> Option<ty::Region> {\n         let mut ret = None;\n         do list::each(*self) |isr| {\n             let (isr_br, isr_r) = *isr;\n@@ -354,7 +365,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 purity: ast::impure_fn,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n-                    bound_lifetime_names: opt_vec::Empty,\n+                    binder_id: main_id,\n                     inputs: ~[],\n                     output: ty::mk_nil(),\n                     variadic: false\n@@ -400,7 +411,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 purity: ast::impure_fn,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n-                    bound_lifetime_names: opt_vec::Empty,\n+                    binder_id: start_id,\n                     inputs: ~[\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n@@ -456,6 +467,9 @@ pub fn check_crate(tcx: ty::ctxt,\n     // have valid types and not error\n     tcx.sess.abort_if_errors();\n \n+    time(time_passes, \"variance inference\", (), |_|\n+         variance::infer_variance(tcx, crate));\n+\n     time(time_passes, \"coherence checking\", (), |_|\n         coherence::check_coherence(ccx, crate));\n "}, {"sha": "9a32eafa8e4de2a0510084ed1cbed9d2db3ebbc0", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 45, "deletions": 286, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -11,312 +11,71 @@\n \n use middle::ty;\n \n-use std::result;\n+use std::vec;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n-use syntax::parse::token::special_idents;\n-\n-#[deriving(ToStr)]\n-pub struct RegionError {\n-    msg: ~str,\n-    replacement: ty::Region\n-}\n \n+/// Defines strategies for handling regions that are omitted.  For\n+/// example, if one writes the type `&Foo`, then the lifetime of of\n+/// this borrowed pointer has been omitted. When converting this\n+/// type, the generic functions in astconv will invoke `anon_regions`\n+/// on the provided region-scope to decide how to translate this\n+/// omitted region.\n+///\n+/// It is not always legal to omit regions, therefore `anon_regions`\n+/// can return `Err(())` to indicate that this is not a scope in which\n+/// regions can legally be omitted.\n pub trait RegionScope {\n-    fn anon_region(&self, span: Span) -> Result<ty::Region, RegionError>;\n-    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError>;\n-    fn named_region(&self, span: Span, id: ast::Ident)\n-                      -> Result<ty::Region, RegionError>;\n-}\n-\n-#[deriving(Clone)]\n-pub struct EmptyRscope;\n-impl RegionScope for EmptyRscope {\n-    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        result::Err(RegionError {\n-            msg: ~\"only 'static is allowed here\",\n-            replacement: ty::re_static\n-        })\n-    }\n-    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        self.anon_region(_span)\n-    }\n-    fn named_region(&self, _span: Span, _id: ast::Ident)\n-        -> Result<ty::Region, RegionError>\n-    {\n-        self.anon_region(_span)\n-    }\n-}\n-\n-#[deriving(Clone)]\n-pub struct RegionParamNames(OptVec<ast::Ident>);\n-\n-impl RegionParamNames {\n-    fn has_self(&self) -> bool {\n-        self.has_ident(special_idents::self_)\n-    }\n-\n-    fn has_ident(&self, ident: ast::Ident) -> bool {\n-        for region_param_name in self.iter() {\n-            if *region_param_name == ident {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n-    pub fn add_generics(&mut self, generics: &ast::Generics) {\n-        match generics.lifetimes {\n-            opt_vec::Empty => {}\n-            opt_vec::Vec(ref new_lifetimes) => {\n-                match **self {\n-                    opt_vec::Empty => {\n-                        *self = RegionParamNames(\n-                            opt_vec::Vec(new_lifetimes.map(|lt| lt.ident)));\n-                    }\n-                    opt_vec::Vec(ref mut existing_lifetimes) => {\n-                        for new_lifetime in new_lifetimes.iter() {\n-                            existing_lifetimes.push(new_lifetime.ident);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // Convenience function to produce the error for an unresolved name. The\n-    // optional argument specifies a custom replacement.\n-    pub fn undeclared_name(custom_replacement: Option<ty::Region>)\n-                        -> Result<ty::Region, RegionError> {\n-        let replacement = match custom_replacement {\n-            None => ty::re_bound(ty::br_self),\n-            Some(custom_replacement) => custom_replacement\n-        };\n-        Err(RegionError {\n-            msg: ~\"this lifetime must be declared\",\n-            replacement: replacement\n-        })\n-    }\n-\n-    pub fn from_generics(generics: &ast::Generics) -> RegionParamNames {\n-        match generics.lifetimes {\n-            opt_vec::Empty => RegionParamNames(opt_vec::Empty),\n-            opt_vec::Vec(ref lifetimes) => {\n-                RegionParamNames(opt_vec::Vec(lifetimes.map(|lt| lt.ident)))\n-            }\n-        }\n-    }\n-\n-    pub fn from_lifetimes(lifetimes: &opt_vec::OptVec<ast::Lifetime>)\n-                       -> RegionParamNames {\n-        match *lifetimes {\n-            opt_vec::Empty => RegionParamNames::new(),\n-            opt_vec::Vec(ref v) => {\n-                RegionParamNames(opt_vec::Vec(v.map(|lt| lt.ident)))\n-            }\n-        }\n-    }\n-\n-    fn new() -> RegionParamNames {\n-        RegionParamNames(opt_vec::Empty)\n-    }\n-}\n-\n-#[deriving(Clone)]\n-struct RegionParameterization {\n-    variance: ty::region_variance,\n-    region_param_names: RegionParamNames,\n-}\n-\n-impl RegionParameterization {\n-    pub fn from_variance_and_generics(variance: Option<ty::region_variance>,\n-                                      generics: &ast::Generics)\n-                                   -> Option<RegionParameterization> {\n-        match variance {\n-            None => None,\n-            Some(variance) => {\n-                Some(RegionParameterization {\n-                    variance: variance,\n-                    region_param_names:\n-                        RegionParamNames::from_generics(generics),\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-#[deriving(Clone)]\n-pub struct MethodRscope {\n-    explicit_self: ast::explicit_self_,\n-    variance: Option<ty::region_variance>,\n-    region_param_names: RegionParamNames,\n-}\n-\n-impl MethodRscope {\n-    // `generics` here refers to the generics of the outer item (impl or\n-    // trait).\n-    pub fn new(explicit_self: ast::explicit_self_,\n-               variance: Option<ty::region_variance>,\n-               rcvr_generics: &ast::Generics)\n-            -> MethodRscope {\n-        let region_param_names =\n-            RegionParamNames::from_generics(rcvr_generics);\n-        MethodRscope {\n-            explicit_self: explicit_self,\n-            variance: variance,\n-            region_param_names: region_param_names\n-        }\n-    }\n-\n-    pub fn region_param_names(&self) -> RegionParamNames {\n-        self.region_param_names.clone()\n-    }\n-}\n-\n-impl RegionScope for MethodRscope {\n-    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        result::Err(RegionError {\n-            msg: ~\"anonymous lifetimes are not permitted here\",\n-            replacement: ty::re_bound(ty::br_self)\n-        })\n-    }\n-    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        assert!(self.variance.is_some());\n-        match self.variance {\n-            None => {}  // must be borrowed self, so this is OK\n-            Some(_) => {\n-                if !self.region_param_names.has_self() {\n-                    return Err(RegionError {\n-                        msg: ~\"the `self` lifetime must be declared\",\n-                        replacement: ty::re_bound(ty::br_self)\n-                    })\n-                }\n-            }\n-        }\n-        result::Ok(ty::re_bound(ty::br_self))\n-    }\n-    fn named_region(&self, span: Span, id: ast::Ident)\n-                      -> Result<ty::Region, RegionError> {\n-        if !self.region_param_names.has_ident(id) {\n-            return RegionParamNames::undeclared_name(None);\n-        }\n-        do EmptyRscope.named_region(span, id).or_else |_e| {\n-            result::Err(RegionError {\n-                msg: ~\"lifetime is not in scope\",\n-                replacement: ty::re_bound(ty::br_self)\n-            })\n-        }\n-    }\n+    fn anon_regions(&self,\n+                    span: Span,\n+                    count: uint)\n+                    -> Result<~[ty::Region], ()>;\n }\n \n-#[deriving(Clone)]\n-pub struct TypeRscope(Option<RegionParameterization>);\n-\n-impl TypeRscope {\n-    fn replacement(&self) -> ty::Region {\n-        if self.is_some() {\n-            ty::re_bound(ty::br_self)\n-        } else {\n-            ty::re_static\n-        }\n-    }\n-}\n-impl RegionScope for TypeRscope {\n-    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        result::Err(RegionError {\n-            msg: ~\"anonymous lifetimes are not permitted here\",\n-            replacement: self.replacement()\n-        })\n-    }\n-    fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n-        match **self {\n-            None => {\n-                // if the self region is used, region parameterization should\n-                // have inferred that this type is RP\n-                fail!(\"region parameterization should have inferred that \\\n-                        this type is RP\");\n-            }\n-            Some(ref region_parameterization) => {\n-                if !region_parameterization.region_param_names.has_self() {\n-                    return Err(RegionError {\n-                        msg: ~\"the `self` lifetime must be declared\",\n-                        replacement: ty::re_bound(ty::br_self)\n-                    })\n-                }\n-            }\n-        }\n-        result::Ok(ty::re_bound(ty::br_self))\n-    }\n-    fn named_region(&self, span: Span, id: ast::Ident)\n-                      -> Result<ty::Region, RegionError> {\n-        do EmptyRscope.named_region(span, id).or_else |_e| {\n-            result::Err(RegionError {\n-                msg: ~\"only 'self is allowed as part of a type declaration\",\n-                replacement: self.replacement()\n-            })\n-        }\n-    }\n-}\n+// A scope in which all regions must be explicitly named\n+pub struct ExplicitRscope;\n \n-pub fn bound_self_region(rp: Option<ty::region_variance>)\n-                      -> OptVec<ty::Region> {\n-    match rp {\n-      Some(_) => opt_vec::with(ty::re_bound(ty::br_self)),\n-      None => opt_vec::Empty\n+impl RegionScope for ExplicitRscope {\n+    fn anon_regions(&self,\n+                    _span: Span,\n+                    _count: uint)\n+                    -> Result<~[ty::Region], ()> {\n+        Err(())\n     }\n }\n \n+/// A scope in which we generate anonymous, late-bound regions for\n+/// omitted regions. This occurs in function signatures.\n pub struct BindingRscope {\n-    base: @RegionScope,\n-    anon_bindings: @mut uint,\n-    region_param_names: RegionParamNames,\n+    binder_id: ast::NodeId,\n+    anon_bindings: @mut uint\n }\n \n-impl Clone for BindingRscope {\n-    fn clone(&self) -> BindingRscope {\n+impl BindingRscope {\n+    pub fn new(binder_id: ast::NodeId) -> BindingRscope {\n         BindingRscope {\n-            base: self.base,\n-            anon_bindings: self.anon_bindings,\n-            region_param_names: self.region_param_names.clone(),\n+            binder_id: binder_id,\n+            anon_bindings: @mut 0\n         }\n     }\n }\n \n-pub fn in_binding_rscope<RS:RegionScope + Clone + 'static>(\n-        this: &RS,\n-        region_param_names: RegionParamNames)\n-     -> BindingRscope {\n-    let base = @(*this).clone();\n-    let base = base as @RegionScope;\n-    BindingRscope {\n-        base: base,\n-        anon_bindings: @mut 0,\n-        region_param_names: region_param_names,\n-    }\n-}\n-\n impl RegionScope for BindingRscope {\n-    fn anon_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n+    fn anon_regions(&self,\n+                    _: Span,\n+                    count: uint)\n+                    -> Result<~[ty::Region], ()> {\n         let idx = *self.anon_bindings;\n-        *self.anon_bindings += 1;\n-        result::Ok(ty::re_bound(ty::br_anon(idx)))\n-    }\n-    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n-        self.base.self_region(span)\n-    }\n-    fn named_region(&self,\n-                    span: Span,\n-                    id: ast::Ident) -> Result<ty::Region, RegionError>\n-    {\n-        do self.base.named_region(span, id).or_else |_e| {\n-            let result = ty::re_bound(ty::br_named(id));\n-            if self.region_param_names.has_ident(id) {\n-                result::Ok(result)\n-            } else {\n-                RegionParamNames::undeclared_name(Some(result))\n-            }\n-        }\n+        *self.anon_bindings += count;\n+        Ok(vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n+                                                   ty::BrAnon(idx + i))))\n     }\n }\n+\n+pub fn bound_type_regions(defs: &[ty::RegionParameterDef])\n+                          -> OptVec<ty::Region> {\n+    assert!(defs.iter().all(|def| def.def_id.crate == ast::LOCAL_CRATE));\n+    defs.iter().enumerate().map(\n+        |(i, def)| ty::ReEarlyBound(def.def_id.node, i, def.ident)).collect()\n+}"}, {"sha": "1b435d11404b1542d524317f0f50e2aebb1bd7c7", "filename": "src/librustc/middle/typeck/variance.rs", "status": "added", "additions": 1000, "deletions": 0, "changes": 1000, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,1000 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+This file infers the variance of type and lifetime parameters. The\n+algorithm is taken from Section 4 of the paper \"Taming the Wildcards:\n+Combining Definition- and Use-Site Variance\" published in PLDI'11 and\n+written by Altidor et al., and hereafter referred to as The Paper.\n+\n+This inference is explicitly designed *not* to consider the uses of\n+types within code. To determine the variance of type parameters\n+defined on type `X`, we only consider the definition of the type `X`\n+and the definitions of any types it references.\n+\n+We only infer variance for type parameters found on *types*: structs,\n+enums, and traits. We do not infer variance for type parameters found\n+on fns or impls. This is because those things are not type definitions\n+and variance doesn't really make sense in that context.\n+\n+It is worth covering what variance means in each case. For structs and\n+enums, I think it is fairly straightforward. The variance of the type\n+or lifetime parameters defines whether `T<A>` is a subtype of `T<B>`\n+(resp. `T<'a>` and `T<'b>`) based on the relationship of `A` and `B`\n+(resp. `'a` and `'b`). (FIXME #3598 -- we do not currently make use of\n+the variances we compute for type parameters.)\n+\n+### Variance on traits\n+\n+The meaning of variance for trait parameters is more subtle and worth\n+expanding upon. There are in fact two uses of the variance values we\n+compute.\n+\n+#### Trait variance and object types\n+\n+The first is for object types. Just as with structs and enums, we can\n+decide the subtyping relationship between two object types `&Trait<A>`\n+and `&Trait<B>` based on the relationship of `A` and `B`. Note that\n+for object types we ignore the `Self` type parameter -- it is unknown,\n+and the nature of dynamic dispatch ensures that we will always call a\n+function that is expected the appropriate `Self` type. However, we\n+must be careful with the other type parameters, or else we could end\n+up calling a function that is expecting one type but provided another.\n+\n+To see what I mean, consider a trait like so:\n+\n+    trait ConvertTo<A> {\n+        fn convertTo(&self) -> A;\n+    }\n+\n+Intuitively, If we had one object `O=&ConvertTo<Object>` and another\n+`S=&ConvertTo<String>`, then `S <: O` because `String <: Object`\n+(presuming Java-like \"string\" and \"object\" types, my go to examples\n+for subtyping). The actual algorithm would be to compare the\n+(explicit) type parameters pairwise respecting their variance: here,\n+the type parameter A is covariant (it appears only in a return\n+position), and hence we require that `String <: Object`.\n+\n+You'll note though that we did not consider the binding for the\n+(implicit) `Self` type parameter: in fact, it is unknown, so that's\n+good. The reason we can ignore that parameter is precisely because we\n+don't need to know its value until a call occurs, and at that time (as\n+you said) the dynamic nature of virtual dispatch means the code we run\n+will be correct for whatever value `Self` happens to be bound to for\n+the particular object whose method we called. `Self` is thus different\n+from `A`, because the caller requires that `A` be known in order to\n+know the return type of the method `convertTo()`. (As an aside, we\n+have rules preventing methods where `Self` appears outside of the\n+receiver position from being called via an object.)\n+\n+#### Trait variance and vtable resolution\n+\n+But traits aren't only used with objects. They're also used when\n+deciding whether a given impl satisfies a given trait bound (or should\n+be -- FIXME #5781). To set the scene here, imagine I had a function:\n+\n+    fn convertAll<A,T:ConvertTo<A>>(v: &[T]) {\n+        ...\n+    }\n+\n+Now imagine that I have an implementation of `ConvertTo` for `Object`:\n+\n+    impl ConvertTo<int> for Object { ... }\n+\n+And I want to call `convertAll` on an array of strings. Suppose\n+further that for whatever reason I specifically supply the value of\n+`String` for the type parameter `T`:\n+\n+    let mut vector = ~[\"string\", ...];\n+    convertAll::<int, String>(v);\n+\n+Is this legal? To put another way, can we apply the `impl` for\n+`Object` to the type `String`? The answer is yes, but to see why\n+we have to expand out what will happen:\n+\n+- `convertAll` will create a pointer to one of the entries in the\n+  vector, which will have type `&String`\n+- It will then call the impl of `convertTo()` that is intended\n+  for use with objects. This has the type:\n+\n+      fn(self: &Object) -> int\n+\n+  It is ok to provide a value for `self` of type `&String` because\n+  `&String <: &Object`.\n+\n+OK, so intuitively we want this to be legal, so let's bring this back\n+to variance and see whether we are computing the correct result. We\n+must first figure out how to phrase the question \"is an impl for\n+`Object,int` usable where an impl for `String,int` is expected?\"\n+\n+Maybe it's helpful to think of a dictionary-passing implementation of\n+type classes. In that case, `convertAll()` takes an implicit parameter\n+representing the impl. In short, we *have* an impl of type:\n+\n+    V_O = ConvertTo<int> for Object\n+\n+and the function prototype expects an impl of type:\n+\n+    V_S = ConvertTo<int> for String\n+\n+As with any argument, this is legal if the type of the value given\n+(`V_O`) is a subtype of the type expected (`V_S`). So is `V_O <: V_S`?\n+The answer will depend on the variance of the various parameters. In\n+this case, because the `Self` parameter is contravariant and `A` is\n+covariant, it means that:\n+\n+    V_O <: V_S iff\n+        int <: int\n+        String <: Object\n+\n+These conditions are satisfied and so we are happy.\n+\n+### The algorithm\n+\n+The basic idea is quite straightforward. We iterate over the types\n+defined and, for each use of a type parameter X, accumulate a\n+constraint indicating that the variance of X must be valid for the\n+variance of that use site. We then iteratively refine the variance of\n+X until all constraints are met. There is *always* a sol'n, because at\n+the limit we can declare all type parameters to be invariant and all\n+constraints will be satisfied.\n+\n+As a simple example, consider:\n+\n+    enum Option<A> { Some(A), None }\n+    enum OptionalFn<B> { Some(&fn(B)), None }\n+    enum OptionalMap<C> { Some(&fn(C) -> C), None }\n+\n+Here, we will generate the constraints:\n+\n+    1. V(A) <= +\n+    2. V(B) <= -\n+    3. V(C) <= +\n+    4. V(C) <= -\n+\n+These indicate that (1) the variance of A must be at most covariant;\n+(2) the variance of B must be at most contravariant; and (3, 4) the\n+variance of C must be at most covariant *and* contravariant. All of these\n+results are based on a variance lattice defined as follows:\n+\n+      *      Top (bivariant)\n+   -     +\n+      o      Bottom (invariant)\n+\n+Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n+optimal solution. Note that there is always a naive solution which\n+just declares all variables to be invariant.\n+\n+You may be wondering why fixed-point iteration is required. The reason\n+is that the variance of a use site may itself be a function of the\n+variance of other type parameters. In full generality, our constraints\n+take the form:\n+\n+    V(X) <= Term\n+    Term := + | - | * | o | V(X) | Term x Term\n+\n+Here the notation V(X) indicates the variance of a type/region\n+parameter `X` with respect to its defining class. `Term x Term`\n+represents the \"variance transform\" as defined in the paper:\n+\n+  If the variance of a type variable `X` in type expression `E` is `V2`\n+  and the definition-site variance of the [corresponding] type parameter\n+  of a class `C` is `V1`, then the variance of `X` in the type expression\n+  `C<E>` is `V3 = V1.xform(V2)`.\n+\n+*/\n+\n+use std::hashmap::HashMap;\n+use extra::arena;\n+use extra::arena::Arena;\n+use middle::ty;\n+use std::vec;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::ast_util;\n+use syntax::parse::token;\n+use syntax::opt_vec;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+\n+pub fn infer_variance(tcx: ty::ctxt,\n+                      crate: &ast::Crate) {\n+    let mut arena = arena::Arena::new();\n+    let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, crate);\n+    let constraints_cx = add_constraints_from_crate(terms_cx, crate);\n+    solve_constraints(constraints_cx);\n+}\n+\n+/**************************************************************************\n+ * Representing terms\n+ *\n+ * Terms are structured as a straightforward tree. Rather than rely on\n+ * GC, we allocate terms out of a bounded arena (the lifetime of this\n+ * arena is the lifetime 'self that is threaded around).\n+ *\n+ * We assign a unique index to each type/region parameter whose variance\n+ * is to be inferred. We refer to such variables as \"inferreds\". An\n+ * `InferredIndex` is a newtype'd int representing the index of such\n+ * a variable.\n+ */\n+\n+type VarianceTermPtr<'self> = &'self VarianceTerm<'self>;\n+\n+struct InferredIndex(uint);\n+\n+enum VarianceTerm<'self> {\n+    ConstantTerm(ty::Variance),\n+    TransformTerm(VarianceTermPtr<'self>, VarianceTermPtr<'self>),\n+    InferredTerm(InferredIndex),\n+}\n+\n+impl<'self> ToStr for VarianceTerm<'self> {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ConstantTerm(c1) => format!(\"{}\", c1.to_str()),\n+            TransformTerm(v1, v2) => format!(\"({} \\u00D7 {})\",\n+                                          v1.to_str(), v2.to_str()),\n+            InferredTerm(id) => format!(\"[{}]\", *id)\n+        }\n+    }\n+}\n+\n+/**************************************************************************\n+ * The first pass over the crate simply builds up the set of inferreds.\n+ */\n+\n+struct TermsContext<'self> {\n+    tcx: ty::ctxt,\n+    arena: &'self Arena,\n+\n+    empty_variances: @ty::ItemVariances,\n+\n+    // Maps from the node id of a type/generic parameter to the\n+    // corresponding inferred index.\n+    inferred_map: HashMap<ast::NodeId, InferredIndex>,\n+\n+    // Maps from an InferredIndex to the info for that variable.\n+    inferred_infos: ~[InferredInfo<'self>],\n+}\n+\n+enum ParamKind { TypeParam, RegionParam, SelfParam }\n+\n+struct InferredInfo<'self> {\n+    item_id: ast::NodeId,\n+    kind: ParamKind,\n+    index: uint,\n+    param_id: ast::NodeId,\n+    term: VarianceTermPtr<'self>,\n+}\n+\n+fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n+                                           arena: &'a mut Arena,\n+                                           crate: &ast::Crate)\n+                                           -> TermsContext<'a> {\n+    let mut terms_cx = TermsContext {\n+        tcx: tcx,\n+        arena: arena,\n+        inferred_map: HashMap::new(),\n+        inferred_infos: ~[],\n+\n+        // cache and share the variance struct used for items with\n+        // no type/region parameters\n+        empty_variances: @ty::ItemVariances { self_param: None,\n+                                              type_params: opt_vec::Empty,\n+                                              region_params: opt_vec::Empty }\n+    };\n+\n+    visit::walk_crate(&mut terms_cx, crate, ());\n+\n+    terms_cx\n+}\n+\n+impl<'self> TermsContext<'self> {\n+    fn add_inferred(&mut self,\n+                    item_id: ast::NodeId,\n+                    kind: ParamKind,\n+                    index: uint,\n+                    param_id: ast::NodeId) {\n+        let inf_index = InferredIndex(self.inferred_infos.len());\n+        let term = self.arena.alloc(|| InferredTerm(inf_index));\n+        self.inferred_infos.push(InferredInfo { item_id: item_id,\n+                                                kind: kind,\n+                                                index: index,\n+                                                param_id: param_id,\n+                                                term: term });\n+        let newly_added = self.inferred_map.insert(param_id, inf_index);\n+        assert!(newly_added);\n+\n+        debug!(\"add_inferred(item_id={}, \\\n+                kind={:?}, \\\n+                index={}, \\\n+                param_id={},\n+                inf_index={:?})\",\n+                item_id, kind, index, param_id, inf_index);\n+    }\n+\n+    fn num_inferred(&self) -> uint {\n+        self.inferred_infos.len()\n+    }\n+}\n+\n+impl<'self> Visitor<()> for TermsContext<'self> {\n+    fn visit_item(&mut self,\n+                  item: @ast::item,\n+                  (): ()) {\n+        debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n+\n+        let inferreds_on_entry = self.num_inferred();\n+\n+        // NB: In the code below for writing the results back into the\n+        // tcx, we rely on the fact that all inferreds for a particular\n+        // item are assigned continuous indices.\n+        match item.node {\n+            ast::item_trait(*) => {\n+                self.add_inferred(item.id, SelfParam, 0, item.id);\n+            }\n+            _ => { }\n+        }\n+\n+        match item.node {\n+            ast::item_enum(_, ref generics) |\n+            ast::item_struct(_, ref generics) |\n+            ast::item_trait(ref generics, _, _) => {\n+                for (i, p) in generics.lifetimes.iter().enumerate() {\n+                    self.add_inferred(item.id, RegionParam, i, p.id);\n+                }\n+                for (i, p) in generics.ty_params.iter().enumerate() {\n+                    self.add_inferred(item.id, TypeParam, i, p.id);\n+                }\n+\n+                // If this item has no type or lifetime parameters,\n+                // then there are no variances to infer, so just\n+                // insert an empty entry into the variance map.\n+                // Arguably we could just leave the map empty in this\n+                // case but it seems cleaner to be able to distinguish\n+                // \"invalid item id\" from \"item id with no\n+                // parameters\".\n+                if self.num_inferred() == inferreds_on_entry {\n+                    let newly_added = self.tcx.item_variance_map.insert(\n+                        ast_util::local_def(item.id),\n+                        self.empty_variances);\n+                    assert!(newly_added);\n+                }\n+\n+                visit::walk_item(self, item, ());\n+            }\n+\n+            ast::item_impl(*) |\n+            ast::item_static(*) |\n+            ast::item_fn(*) |\n+            ast::item_mod(*) |\n+            ast::item_foreign_mod(*) |\n+            ast::item_ty(*) |\n+            ast::item_mac(*) => {\n+                visit::walk_item(self, item, ());\n+            }\n+        }\n+    }\n+}\n+\n+/**************************************************************************\n+ * Constraint construction and representation\n+ *\n+ * The second pass over the AST determines the set of constraints.\n+ * We walk the set of items and, for each member, generate new constraints.\n+ */\n+\n+struct ConstraintContext<'self> {\n+    terms_cx: TermsContext<'self>,\n+\n+    // These are pointers to common `ConstantTerm` instances\n+    covariant: VarianceTermPtr<'self>,\n+    contravariant: VarianceTermPtr<'self>,\n+    invariant: VarianceTermPtr<'self>,\n+    bivariant: VarianceTermPtr<'self>,\n+\n+    constraints: ~[Constraint<'self>],\n+}\n+\n+/// Declares that the variable `decl_id` appears in a location with\n+/// variance `variance`.\n+struct Constraint<'self> {\n+    inferred: InferredIndex,\n+    variance: &'self VarianceTerm<'self>,\n+}\n+\n+fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n+                                  crate: &ast::Crate)\n+                                  -> ConstraintContext<'a> {\n+    let covariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Covariant));\n+    let contravariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Contravariant));\n+    let invariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Invariant));\n+    let bivariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Bivariant));\n+    let mut constraint_cx = ConstraintContext {\n+        terms_cx: terms_cx,\n+        covariant: covariant,\n+        contravariant: contravariant,\n+        invariant: invariant,\n+        bivariant: bivariant,\n+        constraints: ~[],\n+    };\n+    visit::walk_crate(&mut constraint_cx, crate, ());\n+    constraint_cx\n+}\n+\n+impl<'self> Visitor<()> for ConstraintContext<'self> {\n+    fn visit_item(&mut self,\n+                  item: @ast::item,\n+                  (): ()) {\n+        let did = ast_util::local_def(item.id);\n+        let tcx = self.terms_cx.tcx;\n+\n+        match item.node {\n+            ast::item_enum(ref enum_definition, _) => {\n+                // Hack: If we directly call `ty::enum_variants`, it\n+                // annoyingly takes it upon itself to run off and\n+                // evaluate the discriminants eagerly (*grumpy* that's\n+                // not the typical pattern). This results in double\n+                // error messages because typeck goes off and does\n+                // this at a later time. All we really care about is\n+                // the types of the variant arguments, so we just call\n+                // `ty::VariantInfo::from_ast_variant()` ourselves\n+                // here, mainly so as to mask the differences between\n+                // struct-like enums and so forth.\n+                for ast_variant in enum_definition.variants.iter() {\n+                    let variant =\n+                        ty::VariantInfo::from_ast_variant(tcx,\n+                                                          ast_variant,\n+                                                          /*discrimant*/ 0);\n+                    for &arg_ty in variant.args.iter() {\n+                        self.add_constraints_from_ty(arg_ty, self.covariant);\n+                    }\n+                }\n+            }\n+\n+            ast::item_struct(*) => {\n+                let struct_fields = ty::lookup_struct_fields(tcx, did);\n+                for field_info in struct_fields.iter() {\n+                    assert_eq!(field_info.id.crate, ast::LOCAL_CRATE);\n+                    let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n+                    self.add_constraints_from_ty(field_ty, self.covariant);\n+                }\n+            }\n+\n+            ast::item_trait(*) => {\n+                let methods = ty::trait_methods(tcx, did);\n+                for method in methods.iter() {\n+                    match method.transformed_self_ty {\n+                        Some(self_ty) => {\n+                            // The implicit self parameter is basically\n+                            // equivalent to a normal parameter declared\n+                            // like:\n+                            //\n+                            //     self : self_ty\n+                            //\n+                            // where self_ty is `&Self` or `&mut Self`\n+                            // or whatever.\n+                            self.add_constraints_from_ty(\n+                                self_ty, self.contravariant);\n+                        }\n+                        None => {}\n+                    }\n+\n+                    self.add_constraints_from_sig(\n+                        &method.fty.sig, self.covariant);\n+                }\n+            }\n+\n+            ast::item_static(*) |\n+            ast::item_fn(*) |\n+            ast::item_mod(*) |\n+            ast::item_foreign_mod(*) |\n+            ast::item_ty(*) |\n+            ast::item_impl(*) |\n+            ast::item_mac(*) => {\n+                visit::walk_item(self, item, ());\n+            }\n+        }\n+    }\n+}\n+\n+impl<'self> ConstraintContext<'self> {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.terms_cx.tcx\n+    }\n+\n+    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n+        match self.terms_cx.inferred_map.find(&param_id) {\n+            Some(&index) => index,\n+            None => {\n+                self.tcx().sess.bug(format!(\n+                        \"No inferred index entry for {}\",\n+                        ast_map::node_id_to_str(self.tcx().items,\n+                                                param_id,\n+                                                token::get_ident_interner())));\n+            }\n+        }\n+    }\n+\n+    fn declared_variance(&self,\n+                         param_def_id: ast::DefId,\n+                         item_def_id: ast::DefId,\n+                         kind: ParamKind,\n+                         index: uint)\n+                         -> VarianceTermPtr<'self> {\n+        /*!\n+         * Returns a variance term representing the declared variance of\n+         * the type/region parameter with the given id.\n+         */\n+\n+        assert_eq!(param_def_id.crate, item_def_id.crate);\n+        if param_def_id.crate == ast::LOCAL_CRATE {\n+            // Parameter on an item defined within current crate:\n+            // variance not yet inferred, so return a symbolic\n+            // variance.\n+            let index = self.inferred_index(param_def_id.node);\n+            self.terms_cx.inferred_infos[*index].term\n+        } else {\n+            // Parameter on an item defined within another crate:\n+            // variance already inferred, just look it up.\n+            let variances = ty::item_variances(self.tcx(), item_def_id);\n+            let variance = match kind {\n+                SelfParam => variances.self_param.unwrap(),\n+                TypeParam => *variances.type_params.get(index),\n+                RegionParam => *variances.region_params.get(index),\n+            };\n+            self.constant_term(variance)\n+        }\n+    }\n+\n+    fn add_constraint(&mut self,\n+                      index: InferredIndex,\n+                      variance: VarianceTermPtr<'self>) {\n+        debug!(\"add_constraint(index={}, variance={})\",\n+                *index, variance.to_str());\n+        self.constraints.push(Constraint { inferred: index,\n+                                           variance: variance });\n+    }\n+\n+    fn contravariant(&mut self,\n+                     variance: VarianceTermPtr<'self>)\n+                     -> VarianceTermPtr<'self> {\n+        self.xform(variance, self.contravariant)\n+    }\n+\n+    fn invariant(&mut self,\n+                 variance: VarianceTermPtr<'self>)\n+                 -> VarianceTermPtr<'self> {\n+        self.xform(variance, self.invariant)\n+    }\n+\n+    fn constant_term(&self, v: ty::Variance) -> VarianceTermPtr<'self> {\n+        match v {\n+            ty::Covariant => self.covariant,\n+            ty::Invariant => self.invariant,\n+            ty::Contravariant => self.contravariant,\n+            ty::Bivariant => self.bivariant,\n+        }\n+    }\n+\n+    fn xform(&mut self,\n+             v1: VarianceTermPtr<'self>,\n+             v2: VarianceTermPtr<'self>)\n+             -> VarianceTermPtr<'self> {\n+        match (*v1, *v2) {\n+            (_, ConstantTerm(ty::Covariant)) => {\n+                // Applying a \"covariant\" transform is always a no-op\n+                v1\n+            }\n+\n+            (ConstantTerm(c1), ConstantTerm(c2)) => {\n+                self.constant_term(c1.xform(c2))\n+            }\n+\n+            _ => {\n+                self.terms_cx.arena.alloc(|| TransformTerm(v1, v2))\n+            }\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for an instance of `ty` appearing\n+    /// in a context with ambient variance `variance`\n+    fn add_constraints_from_ty(&mut self,\n+                               ty: ty::t,\n+                               variance: VarianceTermPtr<'self>) {\n+        debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n+\n+        match ty::get(ty).sty {\n+            ty::ty_nil | ty::ty_bot | ty::ty_bool |\n+            ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n+            ty::ty_float(_) => {\n+                /* leaf type -- noop */\n+            }\n+\n+            ty::ty_rptr(region, ref mt) => {\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(region, contra);\n+                self.add_constraints_from_mt(mt, variance);\n+            }\n+\n+            ty::ty_estr(vstore) => {\n+                self.add_constraints_from_vstore(vstore, variance);\n+            }\n+\n+            ty::ty_evec(ref mt, vstore) => {\n+                self.add_constraints_from_vstore(vstore, variance);\n+                self.add_constraints_from_mt(mt, variance);\n+            }\n+\n+            ty::ty_box(ref mt) |\n+            ty::ty_uniq(ref mt) |\n+            ty::ty_ptr(ref mt) => {\n+                self.add_constraints_from_mt(mt, variance);\n+            }\n+\n+            ty::ty_tup(ref subtys) => {\n+                for &subty in subtys.iter() {\n+                    self.add_constraints_from_ty(subty, variance);\n+                }\n+            }\n+\n+            ty::ty_enum(def_id, ref substs) |\n+            ty::ty_struct(def_id, ref substs) => {\n+                let item_type = ty::lookup_item_type(self.tcx(), def_id);\n+                self.add_constraints_from_substs(def_id, &item_type.generics,\n+                                                 substs, variance);\n+            }\n+\n+            ty::ty_trait(def_id, ref substs, _, _, _) => {\n+                let trait_def = ty::lookup_trait_def(self.tcx(), def_id);\n+                self.add_constraints_from_substs(def_id, &trait_def.generics,\n+                                                 substs, variance);\n+            }\n+\n+            ty::ty_param(ty::param_ty { def_id: ref def_id, _ }) => {\n+                assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n+                match self.terms_cx.inferred_map.find(&def_id.node) {\n+                    Some(&index) => {\n+                        self.add_constraint(index, variance);\n+                    }\n+                    None => {\n+                        // We do not infer variance for type parameters\n+                        // declared on methods. They will not be present\n+                        // in the inferred_map.\n+                    }\n+                }\n+            }\n+\n+            ty::ty_self(ref def_id) => {\n+                assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n+                let index = self.inferred_index(def_id.node);\n+                self.add_constraint(index, variance);\n+            }\n+\n+            ty::ty_bare_fn(ty::BareFnTy { sig: ref sig, _ }) => {\n+                self.add_constraints_from_sig(sig, variance);\n+            }\n+\n+            ty::ty_closure(ty::ClosureTy { sig: ref sig, region, _ }) => {\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(region, contra);\n+                self.add_constraints_from_sig(sig, variance);\n+            }\n+\n+            ty::ty_infer(*) | ty::ty_err | ty::ty_type |\n+            ty::ty_opaque_box | ty::ty_opaque_closure_ptr(*) |\n+            ty::ty_unboxed_vec(*) => {\n+                self.tcx().sess.bug(\n+                    format!(\"Unexpected type encountered in \\\n+                            variance inference: {}\",\n+                            ty.repr(self.tcx())));\n+            }\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for a vector with vstore `vstore`\n+    /// appearing in a context with ambient variance `variance`\n+    fn add_constraints_from_vstore(&mut self,\n+                                   vstore: ty::vstore,\n+                                   variance: VarianceTermPtr<'self>) {\n+        match vstore {\n+            ty::vstore_slice(r) => {\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(r, contra);\n+            }\n+\n+            ty::vstore_fixed(_) | ty::vstore_uniq | ty::vstore_box => {\n+            }\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for a nominal type (enum, struct,\n+    /// object, etc) appearing in a context with ambient variance `variance`\n+    fn add_constraints_from_substs(&mut self,\n+                                   def_id: ast::DefId,\n+                                   generics: &ty::Generics,\n+                                   substs: &ty::substs,\n+                                   variance: VarianceTermPtr<'self>) {\n+        debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n+\n+        for (i, p) in generics.type_param_defs.iter().enumerate() {\n+            let variance_decl =\n+                self.declared_variance(p.def_id, def_id, TypeParam, i);\n+            let variance_i = self.xform(variance, variance_decl);\n+            self.add_constraints_from_ty(substs.tps[i], variance_i);\n+        }\n+\n+        match substs.regions {\n+            ty::ErasedRegions => {}\n+            ty::NonerasedRegions(ref rps) => {\n+                for (i, p) in generics.region_param_defs.iter().enumerate() {\n+                    let variance_decl =\n+                        self.declared_variance(p.def_id, def_id, RegionParam, i);\n+                    let variance_i = self.xform(variance, variance_decl);\n+                    self.add_constraints_from_region(*rps.get(i), variance_i);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for a function with signature\n+    /// `sig` appearing in a context with ambient variance `variance`\n+    fn add_constraints_from_sig(&mut self,\n+                                sig: &ty::FnSig,\n+                                variance: VarianceTermPtr<'self>) {\n+        let contra = self.contravariant(variance);\n+        for &input in sig.inputs.iter() {\n+            self.add_constraints_from_ty(input, contra);\n+        }\n+        self.add_constraints_from_ty(sig.output, variance);\n+    }\n+\n+    /// Adds constraints appropriate for a region appearing in a\n+    /// context with ambient variance `variance`\n+    fn add_constraints_from_region(&mut self,\n+                                   region: ty::Region,\n+                                   variance: VarianceTermPtr<'self>) {\n+        match region {\n+            ty::ReEarlyBound(param_id, _, _) => {\n+                let index = self.inferred_index(param_id);\n+                self.add_constraint(index, variance);\n+            }\n+\n+            ty::ReStatic => { }\n+\n+            ty::ReLateBound(*) => {\n+                // We do not infer variance for region parameters on\n+                // methods or in fn types.\n+            }\n+\n+            ty::ReFree(*) | ty::ReScope(*) | ty::ReInfer(*) |\n+            ty::ReEmpty => {\n+                // We don't expect to see anything but 'static or bound\n+                // regions when visiting member types or method types.\n+                self.tcx().sess.bug(format!(\"Unexpected region encountered in \\\n+                                            variance inference: {}\",\n+                                            region.repr(self.tcx())));\n+            }\n+        }\n+    }\n+\n+    /// Adds constraints appropriate for a mutability-type pair\n+    /// appearing in a context with ambient variance `variance`\n+    fn add_constraints_from_mt(&mut self,\n+                               mt: &ty::mt,\n+                               variance: VarianceTermPtr<'self>) {\n+        match mt.mutbl {\n+            ast::MutMutable => {\n+                let invar = self.invariant(variance);\n+                self.add_constraints_from_ty(mt.ty, invar);\n+            }\n+\n+            ast::MutImmutable => {\n+                self.add_constraints_from_ty(mt.ty, variance);\n+            }\n+        }\n+    }\n+}\n+\n+/**************************************************************************\n+ * Constraint solving\n+ *\n+ * The final phase iterates over the constraints, refining the variance\n+ * for each inferred until a fixed point is reached. This will be the\n+ * optimal solution to the constraints. The final variance for each\n+ * inferred is then written into the `variance_map` in the tcx.\n+ */\n+\n+struct SolveContext<'self> {\n+    terms_cx: TermsContext<'self>,\n+    constraints: ~[Constraint<'self>],\n+\n+    // Maps from an InferredIndex to the inferred value for that variable.\n+    solutions: ~[ty::Variance]\n+}\n+\n+fn solve_constraints(constraints_cx: ConstraintContext) {\n+    let ConstraintContext { terms_cx, constraints, _ } = constraints_cx;\n+    let solutions = vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n+    let mut solutions_cx = SolveContext {\n+        terms_cx: terms_cx,\n+        constraints: constraints,\n+        solutions: solutions\n+    };\n+    solutions_cx.solve();\n+    solutions_cx.write();\n+}\n+\n+impl<'self> SolveContext<'self> {\n+    fn solve(&mut self) {\n+        // Propagate constraints until a fixed point is reached.  Note\n+        // that the maximum number of iterations is 2C where C is the\n+        // number of constraints (each variable can change values at most\n+        // twice). Since number of constraints is linear in size of the\n+        // input, so is the inference process.\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+\n+            for constraint in self.constraints.iter() {\n+                let Constraint { inferred, variance: term } = *constraint;\n+                let variance = self.evaluate(term);\n+                let old_value = self.solutions[*inferred];\n+                let new_value = glb(variance, old_value);\n+                if old_value != new_value {\n+                    debug!(\"Updating inferred {} (node {}) \\\n+                            from {:?} to {:?} due to {}\",\n+                            *inferred,\n+                            self.terms_cx.inferred_infos[*inferred].param_id,\n+                            old_value,\n+                            new_value,\n+                            term.to_str());\n+\n+                    self.solutions[*inferred] = new_value;\n+                    changed = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn write(&self) {\n+        // Collect all the variances for a particular item and stick\n+        // them into the variance map. We rely on the fact that we\n+        // generate all the inferreds for a particular item\n+        // consecutively (that is, we collect solutions for an item\n+        // until we see a new item id, and we assume (1) the solutions\n+        // are in the same order as the type parameters were declared\n+        // and (2) all solutions or a given item appear before a new\n+        // item id).\n+\n+        let tcx = self.terms_cx.tcx;\n+        let item_variance_map = tcx.item_variance_map;\n+        let solutions = &self.solutions;\n+        let inferred_infos = &self.terms_cx.inferred_infos;\n+        let mut index = 0;\n+        let num_inferred = self.terms_cx.num_inferred();\n+        while index < num_inferred {\n+            let item_id = inferred_infos[index].item_id;\n+            let mut item_variances = ty::ItemVariances {\n+                self_param: None,\n+                type_params: opt_vec::Empty,\n+                region_params: opt_vec::Empty\n+            };\n+            while (index < num_inferred &&\n+                   inferred_infos[index].item_id == item_id) {\n+                let info = &inferred_infos[index];\n+                match info.kind {\n+                    SelfParam => {\n+                        assert!(item_variances.self_param.is_none());\n+                        item_variances.self_param = Some(solutions[index]);\n+                    }\n+                    TypeParam => {\n+                        item_variances.type_params.push(solutions[index]);\n+                    }\n+                    RegionParam => {\n+                        item_variances.region_params.push(solutions[index]);\n+                    }\n+                }\n+                index += 1;\n+            }\n+\n+            debug!(\"item_id={} item_variances={}\",\n+                    item_id,\n+                    item_variances.repr(tcx));\n+\n+            let item_def_id = ast_util::local_def(item_id);\n+\n+            // For unit testing: check for a special \"rustc_variance\"\n+            // attribute and report an error with various results if found.\n+            if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n+                let found = item_variances.repr(tcx);\n+                tcx.sess.span_err(ast_map::item_span(tcx.items, item_id), found);\n+            }\n+\n+            let newly_added = item_variance_map.insert(item_def_id,\n+                                                       @item_variances);\n+            assert!(newly_added);\n+        }\n+    }\n+\n+    fn evaluate(&self, term: VarianceTermPtr<'self>) -> ty::Variance {\n+        match *term {\n+            ConstantTerm(v) => {\n+                v\n+            }\n+\n+            TransformTerm(t1, t2) => {\n+                let v1 = self.evaluate(t1);\n+                let v2 = self.evaluate(t2);\n+                v1.xform(v2)\n+            }\n+\n+            InferredTerm(index) => {\n+                self.solutions[*index]\n+            }\n+        }\n+    }\n+}\n+\n+/**************************************************************************\n+ * Miscellany transformations on variance\n+ */\n+\n+trait Xform {\n+    fn xform(self, v: Self) -> Self;\n+}\n+\n+impl Xform for ty::Variance {\n+    fn xform(self, v: ty::Variance) -> ty::Variance {\n+        // \"Variance transformation\", Figure 1 of The Paper\n+        match (self, v) {\n+            // Figure 1, column 1.\n+            (ty::Covariant, ty::Covariant) => ty::Covariant,\n+            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n+            (ty::Covariant, ty::Invariant) => ty::Invariant,\n+            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 2.\n+            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n+            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n+            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n+            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 3.\n+            (ty::Invariant, _) => ty::Invariant,\n+\n+            // Figure 1, column 4.\n+            (ty::Bivariant, _) => ty::Bivariant,\n+        }\n+    }\n+}\n+\n+fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n+    // Greatest lower bound of the variance lattice as\n+    // defined in The Paper:\n+    //\n+    //       *\n+    //    -     +\n+    //       o\n+    match (v1, v2) {\n+        (ty::Invariant, _) | (_, ty::Invariant) => ty::Invariant,\n+\n+        (ty::Covariant, ty::Contravariant) => ty::Invariant,\n+        (ty::Contravariant, ty::Covariant) => ty::Invariant,\n+\n+        (ty::Covariant, ty::Covariant) => ty::Covariant,\n+\n+        (ty::Contravariant, ty::Contravariant) => ty::Contravariant,\n+\n+        (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n+    }\n+}\n+"}, {"sha": "c5d7db465e6a1104553c0632b1bdf6f5b54ddc03", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 135, "deletions": 51, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -11,11 +11,11 @@\n \n use metadata::encoder;\n use middle::ty::{ReSkolemized, ReVar};\n-use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n-use middle::ty::{br_fresh, ctxt, field};\n+use middle::ty::{BoundRegion, BrAnon, BrNamed};\n+use middle::ty::{BrFresh, ctxt, field};\n use middle::ty::{mt, t, param_ty};\n-use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region,\n-                 re_empty};\n+use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n+                 ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n@@ -71,7 +71,7 @@ pub fn explain_region(cx: ctxt, region: ty::Region) -> ~str {\n pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n-      re_scope(node_id) => {\n+      ReScope(node_id) => {\n         match cx.items.find(&node_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n@@ -104,11 +104,11 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n         }\n       }\n \n-      re_free(ref fr) => {\n+      ReFree(ref fr) => {\n         let prefix = match fr.bound_region {\n-          br_anon(idx) => format!(\"the anonymous lifetime \\\\#{} defined on\",\n+          BrAnon(idx) => format!(\"the anonymous lifetime \\\\#{} defined on\",\n                                idx + 1),\n-          br_fresh(_) => format!(\"an anonymous lifetime defined on\"),\n+          BrFresh(_) => format!(\"an anonymous lifetime defined on\"),\n           _ => format!(\"the lifetime {} as defined on\",\n                     bound_region_ptr_to_str(cx, fr.bound_region))\n         };\n@@ -118,20 +118,25 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n+          Some(&ast_map::node_item(it, _)) if match it.node {\n+                ast::item_impl(*) => true, _ => false} => {\n+            let (msg, opt_span) = explain_span(cx, \"impl\", it.span);\n+            (format!(\"{} {}\", prefix, msg), opt_span)\n+          }\n           Some(_) | None => {\n             // this really should not happen\n             (format!(\"{} node {}\", prefix, fr.scope_id), None)\n           }\n         }\n       }\n \n-      re_static => { (~\"the static lifetime\", None) }\n+      ReStatic => { (~\"the static lifetime\", None) }\n \n-      re_empty => { (~\"the empty lifetime\", None) }\n+      ReEmpty => { (~\"the empty lifetime\", None) }\n \n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n-      re_infer(_) | re_bound(_) => {\n+      ty::ReInfer(_) | ty::ReEarlyBound(*) | ty::ReLateBound(*) => {\n         (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n@@ -145,27 +150,28 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n     }\n }\n \n-pub fn bound_region_ptr_to_str(cx: ctxt, br: bound_region) -> ~str {\n+pub fn bound_region_ptr_to_str(cx: ctxt, br: BoundRegion) -> ~str {\n     bound_region_to_str(cx, \"&\", true, br)\n }\n \n pub fn bound_region_to_str(cx: ctxt,\n                            prefix: &str, space: bool,\n-                           br: bound_region) -> ~str {\n+                           br: BoundRegion) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n \n-    if cx.sess.verbose() { return format!(\"{}{:?}{}\", prefix, br, space_str); }\n+    if cx.sess.verbose() {\n+        return format!(\"{}{}{}\", prefix, br.repr(cx), space_str);\n+    }\n \n     match br {\n-      br_named(id)         => format!(\"{}'{}{}\", prefix, cx.sess.str_of(id), space_str),\n-      br_self              => format!(\"{}'self{}\", prefix, space_str),\n-      br_anon(_)           => prefix.to_str(),\n-      br_fresh(_)          => prefix.to_str(),\n-      br_cap_avoid(_, br)  => bound_region_to_str(cx, prefix, space, *br)\n+      BrNamed(_, ident)   => format!(\"{}'{}{}\", prefix,\n+                                      cx.sess.str_of(ident), space_str),\n+      BrAnon(_)           => prefix.to_str(),\n+      BrFresh(_)          => prefix.to_str(),\n     }\n }\n \n-pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n+pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n     match cx.items.find(&node_id) {\n       Some(&ast_map::node_block(ref blk)) => {\n         format!(\"<block at {}>\",\n@@ -198,7 +204,7 @@ pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n         format!(\"<unknown-{}>\", node_id)\n       }\n       _ => { cx.sess.bug(\n-          format!(\"re_scope refers to {}\",\n+          format!(\"ReScope refers to {}\",\n                ast_map::node_id_to_str(cx.items, node_id,\n                                        token::get_ident_interner()))) }\n     }\n@@ -215,23 +221,24 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n-        return format!(\"{}{:?}{}\", prefix, region, space_str);\n+        return format!(\"{}{}{}\", prefix, region.repr(cx), space_str);\n     }\n \n     // These printouts are concise.  They do not contain all the information\n     // the user might want to diagnose an error, but there is basically no way\n     // to fit that into a short string.  Hence the recommendation to use\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n-        re_scope(_) => prefix.to_str(),\n-        re_bound(br) => bound_region_to_str(cx, prefix, space, br),\n-        re_free(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n-        re_infer(ReSkolemized(_, br)) => {\n+        ty::ReScope(_) => prefix.to_str(),\n+        ty::ReEarlyBound(_, _, ident) => cx.sess.str_of(ident).to_owned(),\n+        ty::ReLateBound(_, br) => bound_region_to_str(cx, prefix, space, br),\n+        ty::ReFree(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n+        ty::ReInfer(ReSkolemized(_, br)) => {\n             bound_region_to_str(cx, prefix, space, br)\n         }\n-        re_infer(ReVar(_)) => prefix.to_str(),\n-        re_static => format!(\"{}'static{}\", prefix, space_str),\n-        re_empty => format!(\"{}'<empty>{}\", prefix, space_str)\n+        ty::ReInfer(ReVar(_)) => prefix.to_str(),\n+        ty::ReStatic => format!(\"{}'static{}\", prefix, space_str),\n+        ty::ReEmpty => format!(\"{}'<empty>{}\", prefix, space_str)\n     }\n }\n \n@@ -289,9 +296,10 @@ pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n }\n \n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n-    format!(\"fn{} -> {}\",\n-         tys_to_str(cx, typ.inputs.map(|a| *a)),\n-         ty_to_str(cx, typ.output))\n+    format!(\"fn{}{} -> {}\",\n+            typ.binder_id,\n+            typ.inputs.repr(cx),\n+            typ.output.repr(cx))\n }\n \n pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n@@ -348,8 +356,8 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         };\n \n         match (cty.sigil, cty.region) {\n-            (ast::ManagedSigil, ty::re_static) |\n-            (ast::OwnedSigil, ty::re_static) => {}\n+            (ast::ManagedSigil, ty::ReStatic) |\n+            (ast::OwnedSigil, ty::ReStatic) => {}\n \n             (_, region) => {\n                 s.push_str(region_to_str(cx, \"\", true, region));\n@@ -594,8 +602,17 @@ impl<T:Repr> Repr for ~[T] {\n \n impl Repr for ty::TypeParameterDef {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"TypeParameterDef \\\\{{:?}, bounds: {}\\\\}\",\n-             self.def_id, self.bounds.repr(tcx))\n+        format!(\"TypeParameterDef({:?}, {})\",\n+                self.def_id,\n+                self.bounds.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::RegionParameterDef {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"RegionParameterDef({}, {:?})\",\n+                tcx.sess.str_of(self.ident),\n+                self.def_id)\n     }\n }\n \n@@ -655,6 +672,15 @@ impl Repr for ast::Expr {\n     }\n }\n \n+impl Repr for ast::item {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"item({})\",\n+                ast_map::node_id_to_str(tcx.items,\n+                                        self.id,\n+                                        token::get_ident_interner()))\n+    }\n+}\n+\n impl Repr for ast::Pat {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         format!(\"pat({}: {})\",\n@@ -663,15 +689,58 @@ impl Repr for ast::Pat {\n     }\n }\n \n-impl Repr for ty::bound_region {\n+impl Repr for ty::BoundRegion {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        bound_region_ptr_to_str(tcx, *self)\n+        match *self {\n+            ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n+            ty::BrNamed(id, ident) => format!(\"BrNamed({}, {})\",\n+                                               id.repr(tcx),\n+                                               ident.repr(tcx)),\n+            ty::BrFresh(id) => format!(\"BrFresh({})\", id),\n+        }\n     }\n }\n \n impl Repr for ty::Region {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        region_to_str(tcx, \"\", false, *self)\n+        match *self {\n+            ty::ReEarlyBound(id, index, ident) => {\n+                format!(\"ReEarlyBound({}, {}, {})\",\n+                        id, index, ident.repr(tcx))\n+            }\n+\n+            ty::ReLateBound(binder_id, ref bound_region) => {\n+                format!(\"ReLateBound({}, {})\",\n+                        binder_id, bound_region.repr(tcx))\n+            }\n+\n+            ty::ReFree(ref fr) => {\n+                format!(\"ReFree({}, {})\",\n+                        fr.scope_id,\n+                        fr.bound_region.repr(tcx))\n+            }\n+\n+            ty::ReScope(id) => {\n+                format!(\"ReScope({})\", id)\n+            }\n+\n+            ty::ReStatic => {\n+                format!(\"ReStatic\")\n+            }\n+\n+            ty::ReInfer(ReVar(ref vid)) => {\n+                format!(\"ReInfer({})\", vid.id)\n+            }\n+\n+            ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n+                format!(\"re_skolemized({}, {})\",\n+                        id, bound_region.repr(tcx))\n+            }\n+\n+            ty::ReEmpty => {\n+                format!(\"ReEmpty\")\n+            }\n+        }\n     }\n }\n \n@@ -707,23 +776,38 @@ impl Repr for ty::ty_param_bounds_and_ty {\n \n impl Repr for ty::Generics {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"Generics \\\\{type_param_defs: {}, region_param: {:?}\\\\}\",\n-             self.type_param_defs.repr(tcx),\n-             self.region_param)\n+        format!(\"Generics(type_param_defs: {}, region_param_defs: {})\",\n+                self.type_param_defs.repr(tcx),\n+                self.region_param_defs.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::ItemVariances {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"IterVariances(self_param={}, type_params={}, region_params={})\",\n+                self.self_param.repr(tcx),\n+                self.type_params.repr(tcx),\n+                self.region_params.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::Variance {\n+    fn repr(&self, _: ctxt) -> ~str {\n+        self.to_str().to_owned()\n     }\n }\n \n impl Repr for ty::Method {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"method \\\\{ident: {}, generics: {}, transformed_self_ty: {}, \\\n-              fty: {}, explicit_self: {}, vis: {}, def_id: {}\\\\}\",\n-             self.ident.repr(tcx),\n-             self.generics.repr(tcx),\n-             self.transformed_self_ty.repr(tcx),\n-             self.fty.repr(tcx),\n-             self.explicit_self.repr(tcx),\n-             self.vis.repr(tcx),\n-             self.def_id.repr(tcx))\n+        format!(\"method(ident: {}, generics: {}, transformed_self_ty: {}, \\\n+                fty: {}, explicit_self: {}, vis: {}, def_id: {})\",\n+                self.ident.repr(tcx),\n+                self.generics.repr(tcx),\n+                self.transformed_self_ty.repr(tcx),\n+                self.fty.repr(tcx),\n+                self.explicit_self.repr(tcx),\n+                self.vis.repr(tcx),\n+                self.def_id.repr(tcx))\n     }\n }\n "}, {"sha": "f48ad25712d1226cd129f13637f6a1433f22406e", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -835,15 +835,15 @@ impl Clean<Path> for ast::Path {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct PathSegment {\n     name: ~str,\n-    lifetime: Option<Lifetime>,\n+    lifetimes: ~[Lifetime],\n     types: ~[Type],\n }\n \n impl Clean<PathSegment> for ast::PathSegment {\n     fn clean(&self) -> PathSegment {\n         PathSegment {\n             name: self.identifier.clean(),\n-            lifetime: self.lifetime.clean(),\n+            lifetimes: self.lifetimes.clean(),\n             types: self.types.clean()\n         }\n     }"}, {"sha": "4c64feee384397ed5f1ef198e41aa8c13b99343d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -92,16 +92,17 @@ impl fmt::Default for clean::Path {\n             if i > 0 { f.buf.write(\"::\".as_bytes()) }\n             f.buf.write(seg.name.as_bytes());\n \n-            if seg.lifetime.is_some() || seg.types.len() > 0 {\n+            if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n                 f.buf.write(\"&lt;\".as_bytes());\n-                match seg.lifetime {\n-                    Some(ref lifetime) => write!(f.buf, \"{}\", *lifetime),\n-                    None => {}\n+                let mut comma = false;\n+                for lifetime in seg.lifetimes.iter() {\n+                    if comma { f.buf.write(\", \".as_bytes()); }\n+                    comma = true;\n+                    write!(f.buf, \"{}\", *lifetime);\n                 }\n-                for (i, ty) in seg.types.iter().enumerate() {\n-                    if i > 0 || seg.lifetime.is_some() {\n-                        f.buf.write(\", \".as_bytes());\n-                    }\n+                for ty in seg.types.iter() {\n+                    if comma { f.buf.write(\", \".as_bytes()); }\n+                    comma = true;\n                     write!(f.buf, \"{}\", *ty);\n                 }\n                 f.buf.write(\"&gt;\".as_bytes());\n@@ -152,16 +153,17 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n     let last = path.segments.last();\n-    if last.lifetime.is_some() || last.types.len() > 0 {\n+    if last.lifetimes.len() > 0 || last.types.len() > 0 {\n+        let mut counter = 0;\n         generics.push_str(\"&lt;\");\n-        match last.lifetime {\n-            Some(ref lifetime) => generics.push_str(format!(\"{}\", *lifetime)),\n-            None => {}\n+        for lifetime in last.lifetimes.iter() {\n+            if counter > 0 { generics.push_str(\", \"); }\n+            counter += 1;\n+            generics.push_str(format!(\"{}\", *lifetime));\n         }\n-        for (i, ty) in last.types.iter().enumerate() {\n-            if i > 0 || last.lifetime.is_some() {\n-                generics.push_str(\", \");\n-            }\n+        for ty in last.types.iter() {\n+            if counter > 0 { generics.push_str(\", \"); }\n+            counter += 1;\n             generics.push_str(format!(\"{}\", *ty));\n         }\n         generics.push_str(\"&gt;\");\n@@ -495,7 +497,7 @@ impl fmt::Default for clean::ViewListIdent {\n                     global: false,\n                     segments: ~[clean::PathSegment {\n                         name: v.name.clone(),\n-                        lifetime: None,\n+                        lifetimes: ~[],\n                         types: ~[],\n                     }]\n                 };"}, {"sha": "90729966c18a64be77025e69ad8826ab5081584c", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -12,7 +12,7 @@\n \n use clone::Clone;\n use container::Container;\n-use iter::Iterator;\n+use iter::{Iterator, FromIterator};\n use option::{Option, Some, None};\n use mem;\n use unstable::raw::Repr;\n@@ -134,6 +134,17 @@ impl<T> Clone for @[T] {\n     }\n }\n \n+impl<A> FromIterator<A> for @[A] {\n+    fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> @[A] {\n+        let (lower, _) = iterator.size_hint();\n+        do build(Some(lower)) |push| {\n+            for x in *iterator {\n+                push(x);\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(not(test))]\n #[allow(missing_doc)]\n pub mod traits {"}, {"sha": "88a8bbf7cf28f104fecda06bdb0e76c1796cf51a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -28,7 +28,7 @@ use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Clone, IterBytes, ToStr)]\n+#[deriving(Clone, IterBytes, ToStr, TotalEq, TotalOrd)]\n pub struct Ident { name: Name, ctxt: SyntaxContext }\n \n impl Ident {\n@@ -110,6 +110,7 @@ pub enum SyntaxContext_ {\n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n pub type Name = uint;\n+\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = uint;\n \n@@ -156,9 +157,8 @@ pub struct Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     identifier: Ident,\n-    /// The lifetime parameter for this path segment. Currently only one\n-    /// lifetime parameter is allowed.\n-    lifetime: Option<Lifetime>,\n+    /// The lifetime parameters for this path segment.\n+    lifetimes: OptVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     types: OptVec<Ty>,\n }\n@@ -167,7 +167,7 @@ pub type CrateNum = int;\n \n pub type NodeId = int;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n+#[deriving(Clone, TotalEq, TotalOrd, Eq, Encodable, Decodable, IterBytes, ToStr)]\n pub struct DefId {\n     crate: CrateNum,\n     node: NodeId,\n@@ -251,6 +251,14 @@ pub enum Def {\n     DefMethod(DefId /* method */, Option<DefId> /* trait */),\n }\n \n+#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n+pub enum DefRegion {\n+    DefStaticRegion,\n+    DefEarlyBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n+    DefLateBoundRegion(/* binder_id */ NodeId, /* depth */ uint, /* lifetime decl */ NodeId),\n+    DefFreeRegion(/* block scope */ NodeId, /* lifetime decl */ NodeId),\n+}\n+\n // The set of MetaItems that define the compilation environment of the crate,\n // used to drive conditional compilation\n pub type CrateConfig = ~[@MetaItem];"}, {"sha": "f3d7ac1804db79f7431369a738f9a919cf6c6e25", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -488,3 +488,15 @@ pub fn node_item_query<Result>(items: map, id: NodeId,\n         _ => fail!(\"{}\", error_msg)\n     }\n }\n+\n+pub fn item_span(items: map,\n+                 id: ast::NodeId)\n+                 -> Span {\n+    match items.find(&id) {\n+        Some(&node_item(item, _)) => item.span,\n+        r => {\n+            fail!(format!(\"item_span: expected item with id {} but found {:?}\",\n+                           id, r))\n+        }\n+    }\n+}"}, {"sha": "ccae25dc012ac8866a643cf3850c17a5335e2543", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -225,7 +225,7 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n         segments: ~[\n             ast::PathSegment {\n                 identifier: identifier,\n-                lifetime: None,\n+                lifetimes: opt_vec::Empty,\n                 types: opt_vec::Empty,\n             }\n         ],\n@@ -948,7 +948,7 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n         for (idx,seg) in a.iter().enumerate() {\n             if (seg.identifier.name != b[idx].identifier.name)\n                 // FIXME #7743: ident -> name problems in lifetime comparison?\n-                || (seg.lifetime != b[idx].lifetime)\n+                || (seg.lifetimes != b[idx].lifetimes)\n                 // can types contain idents?\n                 || (seg.types != b[idx].types) {\n                 return false;\n@@ -966,7 +966,9 @@ mod test {\n     use std::hashmap::HashMap;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n-        PathSegment{identifier:id.clone(), lifetime: None, types: opt_vec::Empty}\n+        PathSegment {identifier:id.clone(),\n+                     lifetimes: opt_vec::Empty,\n+                     types: opt_vec::Empty}\n     }\n \n     #[test] fn idents_name_eq_test() {"}, {"sha": "5ae158045e0e72e289430f48732e84ef8d52a4a1", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -38,7 +38,7 @@ pub trait AstBuilder {\n     fn path_all(&self, sp: Span,\n                 global: bool,\n                 idents: ~[ast::Ident],\n-                rp: Option<ast::Lifetime>,\n+                lifetimes: OptVec<ast::Lifetime>,\n                 types: ~[ast::Ty])\n         -> ast::Path;\n \n@@ -237,33 +237,33 @@ pub trait AstBuilder {\n \n impl AstBuilder for @ExtCtxt {\n     fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n-        self.path_all(span, false, strs, None, ~[])\n+        self.path_all(span, false, strs, opt_vec::Empty, ~[])\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, ~[id])\n     }\n     fn path_global(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n-        self.path_all(span, true, strs, None, ~[])\n+        self.path_all(span, true, strs, opt_vec::Empty, ~[])\n     }\n     fn path_all(&self,\n                 sp: Span,\n                 global: bool,\n                 mut idents: ~[ast::Ident],\n-                rp: Option<ast::Lifetime>,\n+                lifetimes: OptVec<ast::Lifetime>,\n                 types: ~[ast::Ty])\n                 -> ast::Path {\n         let last_identifier = idents.pop();\n         let mut segments: ~[ast::PathSegment] = idents.move_iter()\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n-                lifetime: None,\n+                lifetimes: opt_vec::Empty,\n                 types: opt_vec::Empty,\n             }\n         }).collect();\n         segments.push(ast::PathSegment {\n             identifier: last_identifier,\n-            lifetime: rp,\n+            lifetimes: lifetimes,\n             types: opt_vec::from(types),\n         });\n         ast::Path {\n@@ -327,7 +327,7 @@ impl AstBuilder for @ExtCtxt {\n                               self.ident_of(\"option\"),\n                               self.ident_of(\"Option\")\n                           ],\n-                          None,\n+                          opt_vec::Empty,\n                           ~[ ty ]), None)\n     }\n "}, {"sha": "216bc3097ce9402ef86150ac0f6c3e32a62ea538", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -43,7 +43,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                  segments: ~[\n                     ast::PathSegment {\n                         identifier: res,\n-                        lifetime: None,\n+                        lifetimes: opt_vec::Empty,\n                         types: opt_vec::Empty,\n                     }\n                 ]"}, {"sha": "b37757341efd8fea67b42cba87e03576afd6b191", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -375,14 +375,10 @@ impl<'self> TraitDef<'self> {\n             cx.ty_ident(trait_span, ty_param.ident)\n         };\n \n-        let self_lifetime = if generics.lifetimes.is_empty() {\n-            None\n-        } else {\n-            Some(*generics.lifetimes.get(0))\n-        };\n+        let self_lifetimes = generics.lifetimes.clone();\n \n         // Create the type of `self`.\n-        let self_type = cx.ty_path(cx.path_all(trait_span, false, ~[ type_ident ], self_lifetime,\n+        let self_type = cx.ty_path(cx.path_all(trait_span, false, ~[ type_ident ], self_lifetimes,\n                                                opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute("}, {"sha": "d014816c070c113c202e8f37c2160eeb1967b5da", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -14,6 +14,7 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n+use opt_vec;\n \n pub fn expand_deriving_rand(cx: @ExtCtxt,\n                             span: Span,\n@@ -77,7 +78,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n             let rand_name = cx.path_all(span,\n                                         true,\n                                         rand_ident.clone(),\n-                                        None,\n+                                        opt_vec::Empty,\n                                         ~[]);\n             let rand_name = cx.expr_path(rand_name);\n "}, {"sha": "d1a5af5f7e8911102811fa26ed2c04a0569bd848", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -19,6 +19,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use opt_vec;\n+use opt_vec::OptVec;\n \n /// The types of pointers\n pub enum PtrTy<'self> {\n@@ -71,7 +72,7 @@ impl<'self> Path<'self> {\n                    self_generics: &Generics)\n                    -> ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n-        let lt = mk_lifetime(cx, span, &self.lifetime);\n+        let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n \n         cx.path_all(span, self.global, idents, lt, tys)\n@@ -116,6 +117,13 @@ fn mk_lifetime(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifet\n     }\n }\n \n+fn mk_lifetimes(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> OptVec<ast::Lifetime> {\n+    match *lt {\n+        Some(ref s) => opt_vec::with(cx.lifetime(span, cx.ident_of(*s))),\n+        None => opt_vec::Empty\n+    }\n+}\n+\n impl<'self> Ty<'self> {\n     pub fn to_ty(&self,\n                  cx: @ExtCtxt,\n@@ -166,13 +174,9 @@ impl<'self> Ty<'self> {\n                 let self_params = do self_generics.ty_params.map |ty_param| {\n                     cx.ty_ident(span, ty_param.ident)\n                 };\n-                let lifetime = if self_generics.lifetimes.is_empty() {\n-                    None\n-                } else {\n-                    Some(*self_generics.lifetimes.get(0))\n-                };\n+                let lifetimes = self_generics.lifetimes.clone();\n \n-                cx.path_all(span, false, ~[self_ty], lifetime,\n+                cx.path_all(span, false, ~[self_ty], lifetimes,\n                             opt_vec::take_vec(self_params))\n             }\n             Literal(ref p) => {"}, {"sha": "b74349da2a9fa6b80e7e88cb75a26001d38d2115", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -169,7 +169,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                     segments: ~[\n                         ast::PathSegment {\n                             identifier: ident,\n-                            lifetime: None,\n+                            lifetimes: opt_vec::Empty,\n                             types: opt_vec::Empty,\n                         }\n                     ],\n@@ -628,7 +628,7 @@ impl Visitor<()> for NewNameFinderContext {\n                         segments: [\n                             ast::PathSegment {\n                                 identifier: id,\n-                                lifetime: _,\n+                                lifetimes: _,\n                                 types: _\n                             }\n                         ]"}, {"sha": "00919fce5db6cf79ddf1451630c24dc0e757113f", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -15,7 +15,7 @@ use ext::base;\n use ext::build::AstBuilder;\n use rsparse = parse;\n use parse::token;\n-\n+use opt_vec;\n use std::fmt::parse;\n use std::hashmap::{HashMap, HashSet};\n use std::vec;\n@@ -464,7 +464,7 @@ impl Context {\n                 sp,\n                 true,\n                 rtpath(\"Method\"),\n-                Some(life),\n+                opt_vec::with(life),\n                 ~[]\n             ), None);\n             let st = ast::item_static(ty, ast::MutImmutable, method);\n@@ -582,7 +582,8 @@ impl Context {\n                     self.ecx.ident_of(\"rt\"),\n                     self.ecx.ident_of(\"Piece\"),\n                 ],\n-                Some(self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n+                opt_vec::with(\n+                    self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n                 ~[]\n             ), None);\n         let ty = ast::ty_fixed_length_vec("}, {"sha": "ea0ab95a45105358ce4aa269870049cdab3c8c2d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -144,7 +144,7 @@ pub trait ast_fold {\n             ident: self.fold_ident(m.ident),\n             attrs: m.attrs.map(|a| fold_attribute_(*a, self)),\n             generics: fold_generics(&m.generics, self),\n-            explicit_self: m.explicit_self,\n+            explicit_self: self.fold_explicit_self(&m.explicit_self),\n             purity: m.purity,\n             decl: fold_fn_decl(&m.decl, self),\n             body: self.fold_block(&m.body),\n@@ -245,12 +245,14 @@ pub trait ast_fold {\n             ty_uniq(ref mt) => ty_uniq(fold_mt(mt, self)),\n             ty_vec(ref mt) => ty_vec(fold_mt(mt, self)),\n             ty_ptr(ref mt) => ty_ptr(fold_mt(mt, self)),\n-            ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, self)),\n+            ty_rptr(ref region, ref mt) => {\n+                ty_rptr(fold_opt_lifetime(region, self), fold_mt(mt, self))\n+            }\n             ty_closure(ref f) => {\n                 ty_closure(@TyClosure {\n                     sigil: f.sigil,\n                     purity: f.purity,\n-                    region: f.region,\n+                    region: fold_opt_lifetime(&f.region, self),\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n                     decl: fold_fn_decl(&f.decl, self),\n@@ -349,7 +351,7 @@ pub trait ast_fold {\n             global: p.global,\n             segments: p.segments.map(|segment| ast::PathSegment {\n                 identifier: self.fold_ident(segment.identifier),\n-                lifetime: segment.lifetime,\n+                lifetimes: segment.lifetimes.map(|l| fold_lifetime(l, self)),\n                 types: segment.types.map(|typ| self.fold_ty(typ)),\n             })\n         }\n@@ -389,6 +391,24 @@ pub trait ast_fold {\n     fn new_span(&self, sp: Span) -> Span {\n         sp\n     }\n+\n+    fn fold_explicit_self(&self, es: &explicit_self) -> explicit_self {\n+        Spanned {\n+            span: self.new_span(es.span),\n+            node: self.fold_explicit_self_(&es.node)\n+        }\n+    }\n+\n+    fn fold_explicit_self_(&self, es: &explicit_self_) -> explicit_self_ {\n+        match *es {\n+            sty_static | sty_value(_) | sty_uniq(_) | sty_box(_) => {\n+                *es\n+            }\n+            sty_region(ref lifetime, m) => {\n+                sty_region(fold_opt_lifetime(lifetime, self), m)\n+            }\n+        }\n+    }\n }\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n@@ -505,6 +525,11 @@ pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &T)\n     lts.map(|l| fold_lifetime(l, fld))\n }\n \n+pub fn fold_opt_lifetime<T:ast_fold>(o_lt: &Option<Lifetime>, fld: &T)\n+                                     -> Option<Lifetime> {\n+    o_lt.as_ref().map(|lt| fold_lifetime(lt, fld))\n+}\n+\n pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &T) -> Generics {\n     Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n@@ -675,7 +700,7 @@ pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n         purity: m.purity,\n         decl: fold_fn_decl(&m.decl, fld),\n         generics: fold_generics(&m.generics, fld),\n-        explicit_self: m.explicit_self,\n+        explicit_self: fld.fold_explicit_self(&m.explicit_self),\n         id: fld.new_id(m.id),\n         span: fld.new_span(m.span),\n     }"}, {"sha": "4d39d4df72f5363123e9c302e6d3b4bcbfb5c2d7", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -165,3 +165,13 @@ impl<'self, T> Iterator<&'self T> for OptVecIterator<'self, T> {\n         }\n     }\n }\n+\n+impl<A> FromIterator<A> for OptVec<A> {\n+    fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> OptVec<A> {\n+        let mut r = Empty;\n+        for x in *iterator {\n+            r.push(x);\n+        }\n+        r\n+    }\n+}"}, {"sha": "672865aadcc2672123a45a47375f9b079b945bab", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -368,7 +368,7 @@ mod test {\n                         segments: ~[\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n-                                lifetime: None,\n+                                lifetimes: opt_vec::Empty,\n                                 types: opt_vec::Empty,\n                             }\n                         ],\n@@ -387,12 +387,12 @@ mod test {\n                             segments: ~[\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 },\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n                             ]\n@@ -592,7 +592,7 @@ mod test {\n                             segments: ~[\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n                             ],\n@@ -614,7 +614,7 @@ mod test {\n                                segments: ~[\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n                                ],\n@@ -641,7 +641,7 @@ mod test {\n                                     segments: ~[\n                                         ast::PathSegment {\n                                             identifier: str_to_ident(\"b\"),\n-                                            lifetime: None,\n+                                            lifetimes: opt_vec::Empty,\n                                             types: opt_vec::Empty,\n                                         }\n                                     ],\n@@ -669,7 +669,7 @@ mod test {\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n-                                                lifetime: None,\n+                                                lifetimes: opt_vec::Empty,\n                                                 types: opt_vec::Empty,\n                                             }\n                                         ],\n@@ -687,7 +687,7 @@ mod test {\n                                                     ast::PathSegment {\n                                                         identifier:\n                                                             str_to_ident(\"b\"),\n-                                                        lifetime: None,\n+                                                        lifetimes: opt_vec::Empty,\n                                                         types: opt_vec::Empty,\n                                                     }\n                                                 ],\n@@ -724,8 +724,8 @@ mod test {\n                                                                 identifier:\n                                                                 str_to_ident(\n                                                                     \"b\"),\n-                                                                lifetime:\n-                                                                    None,\n+                                                                lifetimes:\n+                                                                opt_vec::Empty,\n                                                                 types:\n                                                                 opt_vec::Empty\n                                                             }"}, {"sha": "cfb4da87720becaf97ca6bb29c68df389faf7491", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 40, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -1490,7 +1490,7 @@ impl Parser {\n                 segments.push(PathSegmentAndBoundSet {\n                     segment: ast::PathSegment {\n                         identifier: identifier,\n-                        lifetime: None,\n+                        lifetimes: opt_vec::Empty,\n                         types: opt_vec::Empty,\n                     },\n                     bound_set: bound_set\n@@ -1499,46 +1499,21 @@ impl Parser {\n             }\n \n             // Parse the `<` before the lifetime and types, if applicable.\n-            let (any_lifetime_or_types, optional_lifetime, types) =\n-                    if mode != NoTypesAllowed && self.eat(&token::LT) {\n-                // Parse an optional lifetime.\n-                let optional_lifetime = match *self.token {\n-                    token::LIFETIME(*) => Some(self.parse_lifetime()),\n-                    _ => None,\n-                };\n-\n-                // Parse type parameters.\n-                let mut types = opt_vec::Empty;\n-                let mut need_comma = optional_lifetime.is_some();\n-                loop {\n-                    // We're done if we see a `>`.\n-                    match *self.token {\n-                        token::GT | token::BINOP(token::SHR) => {\n-                            self.expect_gt();\n-                            break\n-                        }\n-                        _ => {} // Go on.\n-                    }\n-\n-                    if need_comma {\n-                        self.expect(&token::COMMA)\n-                    } else {\n-                        need_comma = true\n-                    }\n-\n-                    types.push(self.parse_ty(false))\n+            let (any_lifetime_or_types, lifetimes, types) = {\n+                if mode != NoTypesAllowed && self.eat(&token::LT) {\n+                    let (lifetimes, types) =\n+                        self.parse_generic_values_after_lt();\n+                    (true, lifetimes, opt_vec::from(types))\n+                } else {\n+                    (false, opt_vec::Empty, opt_vec::Empty)\n                 }\n-\n-                (true, optional_lifetime, types)\n-            } else {\n-                (false, None, opt_vec::Empty)\n             };\n \n             // Assemble and push the result.\n             segments.push(PathSegmentAndBoundSet {\n                 segment: ast::PathSegment {\n                     identifier: identifier,\n-                    lifetime: optional_lifetime,\n+                    lifetimes: lifetimes,\n                     types: types,\n                 },\n                 bound_set: bound_set\n@@ -1609,11 +1584,11 @@ impl Parser {\n     pub fn parse_lifetime(&self) -> ast::Lifetime {\n         match *self.token {\n             token::LIFETIME(i) => {\n-                let span = self.span;\n+                let span = *self.span;\n                 self.bump();\n                 return ast::Lifetime {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: *span,\n+                    span: span,\n                     ident: i\n                 };\n             }\n@@ -4856,7 +4831,7 @@ impl Parser {\n                 segments: path.move_iter().map(|identifier| {\n                     ast::PathSegment {\n                         identifier: identifier,\n-                        lifetime: None,\n+                        lifetimes: opt_vec::Empty,\n                         types: opt_vec::Empty,\n                     }\n                 }).collect()\n@@ -4892,7 +4867,7 @@ impl Parser {\n                         segments: path.move_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetime: None,\n+                                lifetimes: opt_vec::Empty,\n                                 types: opt_vec::Empty,\n                             }\n                         }).collect()\n@@ -4910,7 +4885,7 @@ impl Parser {\n                         segments: path.move_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetime: None,\n+                                lifetimes: opt_vec::Empty,\n                                 types: opt_vec::Empty,\n                             }\n                         }).collect()\n@@ -4932,7 +4907,7 @@ impl Parser {\n             segments: path.move_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,\n-                    lifetime: None,\n+                    lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n                 }\n             }).collect()"}, {"sha": "ed8eb4b54271075c289394eb631a8301052dcfd5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -1566,23 +1566,30 @@ fn print_path_(s: @ps,\n             }\n         }\n \n-        if segment.lifetime.is_some() || !segment.types.is_empty() {\n+        if !segment.lifetimes.is_empty() || !segment.types.is_empty() {\n             if colons_before_params {\n                 word(s.s, \"::\")\n             }\n             word(s.s, \"<\");\n \n-            for lifetime in segment.lifetime.iter() {\n-                print_lifetime(s, lifetime);\n-                if !segment.types.is_empty() {\n+            let mut comma = false;\n+            for lifetime in segment.lifetimes.iter() {\n+                if comma {\n                     word_space(s, \",\")\n                 }\n+                print_lifetime(s, lifetime);\n+                comma = true;\n             }\n \n-            commasep(s,\n-                     inconsistent,\n-                     segment.types.map_to_vec(|t| (*t).clone()),\n-                     print_type);\n+            if !segment.types.is_empty() {\n+                if comma {\n+                    word_space(s, \",\")\n+                }\n+                commasep(s,\n+                         inconsistent,\n+                         segment.types.map_to_vec(|t| (*t).clone()),\n+                         print_type);\n+            }\n \n             word(s.s, \">\")\n         }\n@@ -1905,7 +1912,8 @@ pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, ref path, _) => {\n-        if path.segments.last().identifier != ident {\n+        // FIXME(#6993) can't compare identifiers directly here\n+        if path.segments.last().identifier.name != ident.name {\n             print_ident(s, ident);\n             space(s.s);\n             word_space(s, \"=\");"}, {"sha": "60127be87b6ef7d48ee96d75b8119eb402fdff97", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 88, "deletions": 15, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -90,7 +90,32 @@ pub trait Visitor<E:Clone> {\n         walk_struct_def(self, s, i, g, n, e)\n     }\n     fn visit_struct_field(&mut self, s:@struct_field, e:E) { walk_struct_field(self, s, e) }\n-    fn visit_mac(&mut self, m:&mac, e:E) { walk_mac(self, m, e); }\n+    fn visit_opt_lifetime_ref(&mut self,\n+                              _span: Span,\n+                              opt_lifetime: &Option<Lifetime>,\n+                              env: E) {\n+        /*!\n+         * Visits an optional reference to a lifetime. The `span` is\n+         * the span of some surrounding reference should opt_lifetime\n+         * be None.\n+         */\n+        match *opt_lifetime {\n+            Some(ref l) => self.visit_lifetime_ref(l, env),\n+            None => ()\n+        }\n+    }\n+    fn visit_lifetime_ref(&mut self, _lifetime: &Lifetime, _e: E) {\n+        /*! Visits a reference to a lifetime */\n+    }\n+    fn visit_lifetime_decl(&mut self, _lifetime: &Lifetime, _e: E) {\n+        /*! Visits a declaration of a lifetime */\n+    }\n+    fn visit_explicit_self(&mut self, es: &explicit_self, e: E) {\n+        walk_explicit_self(self, es, e)\n+    }\n+    fn visit_mac(&mut self, macro:&mac, e:E) {\n+        walk_mac(self, macro, e)\n+    }\n }\n \n pub fn walk_crate<E:Clone, V:Visitor<E>>(visitor: &mut V, crate: &Crate, env: E) {\n@@ -119,6 +144,18 @@ pub fn walk_local<E:Clone, V:Visitor<E>>(visitor: &mut V, local: &Local, env: E)\n     }\n }\n \n+fn walk_explicit_self<E:Clone, V:Visitor<E>>(visitor: &mut V,\n+                                             explicit_self: &explicit_self,\n+                                             env: E) {\n+    match explicit_self.node {\n+        sty_static | sty_value(_) | sty_box(_) | sty_uniq(_) => {\n+        }\n+        sty_region(ref lifetime, _) => {\n+            visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n+        }\n+    }\n+}\n+\n fn walk_trait_ref<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                             trait_ref: &ast::trait_ref,\n                             env: E) {\n@@ -221,8 +258,11 @@ pub fn skip_ty<E, V:Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     match typ.node {\n         ty_box(ref mutable_type) | ty_uniq(ref mutable_type) |\n-        ty_vec(ref mutable_type) | ty_ptr(ref mutable_type) |\n-        ty_rptr(_, ref mutable_type) => {\n+        ty_vec(ref mutable_type) | ty_ptr(ref mutable_type) => {\n+            visitor.visit_ty(mutable_type.ty, env)\n+        }\n+        ty_rptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_opt_lifetime_ref(typ.span, lifetime, env.clone());\n             visitor.visit_ty(mutable_type.ty, env)\n         }\n         ty_tup(ref tuple_element_types) => {\n@@ -231,19 +271,27 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n             }\n         }\n         ty_closure(ref function_declaration) => {\n-             for argument in function_declaration.decl.inputs.iter() {\n+            for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&argument.ty, env.clone())\n-             }\n-             visitor.visit_ty(&function_declaration.decl.output, env.clone());\n-             for bounds in function_declaration.bounds.iter() {\n+            }\n+            visitor.visit_ty(&function_declaration.decl.output, env.clone());\n+            for bounds in function_declaration.bounds.iter() {\n                 walk_ty_param_bounds(visitor, bounds, env.clone())\n-             }\n+            }\n+            visitor.visit_opt_lifetime_ref(\n+                typ.span,\n+                &function_declaration.region,\n+                env.clone());\n+            walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n+                                env.clone());\n         }\n         ty_bare_fn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&argument.ty, env.clone())\n             }\n-            visitor.visit_ty(&function_declaration.decl.output, env.clone())\n+            visitor.visit_ty(&function_declaration.decl.output, env.clone());\n+            walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n+                                env.clone());\n         }\n         ty_path(ref path, ref bounds, _) => {\n             walk_path(visitor, path, env.clone());\n@@ -262,10 +310,21 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     }\n }\n \n+fn walk_lifetime_decls<E:Clone, V:Visitor<E>>(visitor: &mut V,\n+                                              lifetimes: &OptVec<Lifetime>,\n+                                              env: E) {\n+    for l in lifetimes.iter() {\n+        visitor.visit_lifetime_decl(l, env.clone());\n+    }\n+}\n+\n pub fn walk_path<E:Clone, V:Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n     for segment in path.segments.iter() {\n         for typ in segment.types.iter() {\n-            visitor.visit_ty(typ, env.clone())\n+            visitor.visit_ty(typ, env.clone());\n+        }\n+        for lifetime in segment.lifetimes.iter() {\n+            visitor.visit_lifetime_ref(lifetime, env.clone());\n         }\n     }\n }\n@@ -354,6 +413,7 @@ pub fn walk_generics<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     for type_parameter in generics.ty_params.iter() {\n         walk_ty_param_bounds(visitor, &type_parameter.bounds, env.clone())\n     }\n+    walk_lifetime_decls(visitor, &generics.lifetimes, env);\n }\n \n pub fn walk_fn_decl<E:Clone, V:Visitor<E>>(visitor: &mut V,\n@@ -385,18 +445,31 @@ pub fn walk_fn<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                          function_kind: &fn_kind,\n                          function_declaration: &fn_decl,\n                          function_body: &Block,\n-                         _: Span,\n+                         _span: Span,\n                          _: NodeId,\n                          env: E) {\n     walk_fn_decl(visitor, function_declaration, env.clone());\n-    let generics = generics_of_fn(function_kind);\n-    visitor.visit_generics(&generics, env.clone());\n+\n+    match *function_kind {\n+        fk_item_fn(_, generics, _, _) => {\n+            visitor.visit_generics(generics, env.clone());\n+        }\n+        fk_method(_, generics, method) => {\n+            visitor.visit_generics(generics, env.clone());\n+\n+            visitor.visit_explicit_self(&method.explicit_self, env.clone());\n+        }\n+        fk_anon(*) | fk_fn_block(*) => {\n+        }\n+    }\n+\n     visitor.visit_block(function_body, env)\n }\n \n pub fn walk_ty_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                method_type: &TypeMethod,\n-                                env: E) {\n+                                             method_type: &TypeMethod,\n+                                             env: E) {\n+    visitor.visit_explicit_self(&method_type.explicit_self, env.clone());\n     for argument_type in method_type.decl.inputs.iter() {\n         visitor.visit_ty(&argument_type.ty, env.clone())\n     }"}, {"sha": "90d6147f0eda3416956c715d62251930a2cafd76", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -28,10 +28,11 @@ impl Trait<int> for S2 {\n     }\n }\n \n-fn main() {\n+fn foo<'a>() {\n     let _ = S::new::<int,f64>(1, 1.0);    //~ ERROR the impl referenced by this path has 1 type parameter, but 0 type parameters were supplied\n-    let _ = S::<'self,int>::new::<f64>(1, 1.0);  //~ ERROR this impl has no lifetime parameter\n+    let _ = S::<'a,int>::new::<f64>(1, 1.0);  //~ ERROR expected 0 lifetime parameter(s)\n     let _: S2 = Trait::new::<int,f64>(1, 1.0);    //~ ERROR the trait referenced by this path has 1 type parameter, but 0 type parameters were supplied\n-    let _: S2 = Trait::<'self,int>::new::<f64>(1, 1.0);   //~ ERROR this trait has no lifetime parameter\n+    let _: S2 = Trait::<'a,int>::new::<f64>(1, 1.0);   //~ ERROR expected 0 lifetime parameter(s)\n }\n \n+fn main() {}"}, {"sha": "ca97a8997689f87786d551c541d1718a0c2a2e50", "filename": "src/test/compile-fail/class-method-missing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:missing method `eat`\n trait animal {\n   fn eat(&self);\n }\n@@ -18,6 +17,7 @@ struct cat {\n }\n \n impl animal for cat {\n+    //~^ ERROR not all trait methods implemented, missing: `eat`\n }\n \n fn cat(in_x : uint) -> cat {"}, {"sha": "70573ca4f180cd3ff660e85eef31d1aff9f56f66", "filename": "src/test/compile-fail/core-tls-store-pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -13,6 +13,6 @@\n use std::local_data;\n \n local_data_key!(key: @&int)\n-//~^ ERROR only 'static is allowed\n+//~^ ERROR missing lifetime specifier\n \n fn main() {}"}, {"sha": "1a649c8ad2f83128c3ae252b5e6888ec11c8f1b2", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct thing(uint);\n-impl Ord for thing { //~ ERROR missing method `lt`\n+impl Ord for thing { //~ ERROR not all trait methods implemented, missing: `lt`\n     fn le(&self, other: &thing) -> bool { **self < **other }\n     fn ge(&self, other: &thing) -> bool { **self < **other }\n }"}, {"sha": "032b2564f4fb2d5ea3b12d827bf6ff95cb96c8e9", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -10,7 +10,7 @@\n \n fn id<T>(t: T) -> T { t }\n \n-fn f<'r, T>(v: &'r T) -> &'r fn()->T { id::<&'r fn()->T>(|| *v) } //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+fn f<'r, T>(v: &'r T) -> &'r fn()->T { id::<&'r fn()->T>(|| *v) } //~ ERROR cannot infer an appropriate lifetime\n \n fn main() {\n     let v = &5;"}, {"sha": "8205a6dae64704714081991b0dfd2d5f0f6f0180", "filename": "src/test/compile-fail/issue-5216.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5216.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n fn f() { }\n-struct S(&fn()); //~ ERROR Illegal anonymous lifetime\n-pub static C: S = S(f); //~ ERROR Illegal anonymous lifetime\n+struct S(&fn()); //~ ERROR missing lifetime specifier\n+pub static C: S = S(f);\n \n \n fn g() { }\n-type T = &fn(); //~ ERROR Illegal anonymous lifetime\n-pub static D: T = g; //~ ERROR Illegal anonymous lifetime\n+type T = &fn();  //~ ERROR missing lifetime specifier\n+pub static D: T = g;\n \n fn main() {}"}, {"sha": "5fe9b13f83befeb30a22a18d99ac7be3510fc3bb", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,29 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n+trait Repeat<A> { fn get(&self) -> A; }\n \n-trait repeat<A> { fn get(&self) -> A; }\n-\n-impl<A:Clone> repeat<A> for @A {\n-    fn get(&self) -> A { **self }\n+impl<A:Clone> Repeat<A> for A {\n+    fn get(&self) -> A { self.clone() }\n }\n \n-fn repeater<A:Clone>(v: @A) -> @repeat<A> {\n-    // Note: owned kind is not necessary as A appears in the trait type\n-    @v as @repeat<A> // No\n+fn repeater<A:Clone>(v: A) -> ~Repeat:<A> {\n+    ~v as ~Repeat:<A> // No\n }\n \n fn main() {\n     // Error results because the type of is inferred to be\n-    // @repeat<&'blk int> where blk is the lifetime of the block below.\n+    // ~Repeat<&'blk int> where blk is the lifetime of the block below.\n \n-    let y = { //~ ERROR lifetime of variable does not enclose its declaration\n-        let x: &'blk int = &3;\n-        repeater(@x)\n+    let y = {\n+        let tmp0 = 3;\n+        let tmp1 = &tmp0; //~ ERROR borrowed value does not live long enough\n+        repeater(tmp1)\n     };\n     assert!(3 == *(y.get()));\n-    //~^ ERROR dereference of reference outside its lifetime\n-    //~^^ ERROR automatically borrowed pointer is not valid at the time of borrow\n-    //~^^^ ERROR lifetime of return value does not outlive the function call\n }"}, {"sha": "4e45f33fe9b141e4f5953ba76f3ecc98799bae8f", "filename": "src/test/compile-fail/missing-derivable-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -20,7 +20,7 @@ impl MyEq for int {\n     fn eq(&self, other: &int) -> bool { *self == *other }\n }\n \n-impl MyEq for A {}  //~ ERROR missing method\n+impl MyEq for A {}  //~ ERROR not all trait methods implemented, missing: `eq`\n \n fn main() {\n }"}, {"sha": "ff13548b4946f9417e655dc7950799fa90dbc022", "filename": "src/test/compile-fail/regions-addr-of-arg.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,12 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Check that taking the address of an argument yields a lifetime\n+// bounded by the current function call.\n+\n fn foo(a: int) {\n     let _p: &'static int = &a; //~ ERROR borrowed value does not live long enough\n }\n \n fn bar(a: int) {\n-    let _q: &'blk int = &a;\n+    let _q: &int = &a;\n+}\n+\n+fn zed<'a>(a: int) -> &'a int {\n+    &a //~ ERROR borrowed value does not live long enough\n }\n \n fn main() {"}, {"sha": "b7be0dd7b9b1e65365a445f8acb12cd8dd8a82f3", "filename": "src/test/compile-fail/regions-addr-of-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -14,12 +14,12 @@ struct dog {\n \n impl dog {\n     pub fn chase_cat(&mut self) {\n-        let p: &'static mut uint = &mut self.cats_chased; //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+        let p: &'static mut uint = &mut self.cats_chased; //~ ERROR cannot infer an appropriate lifetime\n         *p += 1u;\n     }\n \n     pub fn chase_cat_2(&mut self) {\n-        let p: &'blk mut uint = &mut self.cats_chased;\n+        let p: &mut uint = &mut self.cats_chased;\n         *p += 1u;\n     }\n }"}, {"sha": "2f60898cfeef152e094dc9b02ad9199c14e81115", "filename": "src/test/compile-fail/regions-addr-of-upvar-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -17,7 +17,7 @@ struct dog {\n impl dog {\n     pub fn chase_cat(&mut self) {\n         let _f = || {\n-            let p: &'static mut uint = &mut self.food; //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+            let p: &'static mut uint = &mut self.food; //~ ERROR cannot infer an appropriate lifetime\n             *p = 3u;\n         };\n     }"}, {"sha": "cad73daa46b157f7806fd93a099cbc6a80f8204e", "filename": "src/test/compile-fail/regions-fn-subtyping.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -24,9 +24,9 @@ fn test_fn<'x,'y,'z,T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n         of::<&fn<'b>(&'b T)>());\n \n     subtype::<&fn<'b>(&'b T)>(\n-        of::<&fn<'x>(&'x T)>());\n+        of::<&fn(&'x T)>());\n \n-    subtype::<&fn<'x>(&'x T)>(\n+    subtype::<&fn(&'x T)>(\n         of::<&fn<'b>(&'b T)>());  //~ ERROR mismatched types\n \n     subtype::<&fn<'a,'b>(&'a T, &'b T)>(\n@@ -36,9 +36,9 @@ fn test_fn<'x,'y,'z,T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n         of::<&fn<'a,'b>(&'a T, &'b T)>()); //~ ERROR mismatched types\n \n     subtype::<&fn<'a,'b>(&'a T, &'b T)>(\n-        of::<&fn<'x,'y>(&'x T, &'y T)>());\n+        of::<&fn(&'x T, &'y T)>());\n \n-    subtype::<&fn<'x,'y>(&'x T, &'y T)>(\n+    subtype::<&fn(&'x T, &'y T)>(\n         of::<&fn<'a,'b>(&'a T, &'b T)>()); //~ ERROR mismatched types\n }\n "}, {"sha": "fb31e477ba279658a8e85e6a0ff73eb6aa019c3c", "filename": "src/test/compile-fail/regions-free-region-ordering-callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -26,7 +26,7 @@ fn ordering2<'a, 'b>(x: &'a &'b uint, y: &'a uint) -> &'b uint {\n fn ordering3<'a, 'b>(x: &'a uint, y: &'b uint) -> &'a &'b uint {\n     // Do not infer an ordering from the return value.\n     let z: &'b uint = &*x;\n-    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    //~^ ERROR cannot infer an appropriate lifetime\n     fail!();\n }\n "}, {"sha": "58fa437a6a365b2c5947005756ff1339a11d3b0a", "filename": "src/test/compile-fail/regions-free-region-ordering-caller.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -14,12 +14,6 @@\n \n struct Paramd<'self> { x: &'self uint }\n \n-fn call1<'a>(x: &'a uint) {\n-    let y: uint = 3;\n-    let z: &'a &'blk uint = &(&y);\n-    //~^ ERROR pointer has a longer lifetime than the data it references\n-}\n-\n fn call2<'a, 'b>(a: &'a uint, b: &'b uint) {\n     let z: Option<&'b &'a uint> = None;\n     //~^ ERROR pointer has a longer lifetime than the data it references"}, {"sha": "1408f75be896e39cbf5aa1153ed4d38ab03ffe31", "filename": "src/test/compile-fail/regions-free-region-ordering-caller1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller1.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various ways to construct a pointer with a longer lifetime\n+// than the thing it points at and ensure that they result in\n+// errors. See also regions-free-region-ordering-callee.rs\n+\n+fn call1<'a>(x: &'a uint) {\n+    // Test that creating a pointer like\n+    // &'a &'z uint requires that 'a <= 'z:\n+    let y: uint = 3;\n+    let z: &'a & uint = &(&y);\n+    //~^ ERROR borrowed value does not live long enough\n+    //~^^ ERROR borrowed value does not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "9f2facf4e1f9f35ea91031aa66c50f42efe29af5", "filename": "src/test/compile-fail/regions-in-consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static c_x: &'blk int = &22; //~ ERROR Illegal lifetime 'blk: only 'static is allowed here\n-static c_y: &int = &22; //~ ERROR Illegal anonymous lifetime: only 'static is allowed here\n+static c_y: &int = &22; //~ ERROR missing lifetime specifier\n static c_z: &'static int = &22;\n \n fn main() {"}, {"sha": "5c7a37d0359a493d7dc1d7489d155d1a72cedb30", "filename": "src/test/compile-fail/regions-in-enums-anon.rs", "status": "renamed", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-enums-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-enums-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-enums-anon.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,16 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct item_ty_yes0<'self> {\n-    x: &'self uint\n-}\n-\n-struct item_ty_yes1<'self> {\n-    x: &'self uint\n-}\n+// Test that anonymous lifetimes are not permitted in enum declarations\n \n-struct item_ty_yes2 {\n-    x: &'a uint //~ ERROR only 'self is allowed\n+enum Foo {\n+    Bar(&int) //~ ERROR missing lifetime specifier\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/regions-in-type-items.rs"}, {"sha": "0a221b9a533909f563dc374dfc4a728a537e37b2", "filename": "src/test/compile-fail/regions-in-enums.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,17 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that lifetimes must be declared for use on enums.\n+// See also regions-undeclared.rs\n+\n enum yes0<'lt> {\n-    // This will eventually be legal (and in fact the only way):\n-    X3(&'lt uint) //~ ERROR Illegal lifetime 'lt: only 'self is allowed\n+    X3(&'lt uint)\n }\n \n enum yes1<'self> {\n     X4(&'self uint)\n }\n \n-enum yes2 {\n-    X5(&'foo uint) //~ ERROR Illegal lifetime 'foo: only 'self is allowed\n+enum no0 {\n+    X5(&'foo uint) //~ ERROR use of undeclared lifetime name `'foo`\n+}\n+\n+enum no1 {\n+    X6(&'self uint) //~ ERROR use of undeclared lifetime name `'self`\n }\n \n fn main() {}"}, {"sha": "0f2036a56cdd600c244e7714c346144533e453be", "filename": "src/test/compile-fail/regions-in-structs-anon.rs", "status": "renamed", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-structs-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-structs-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-structs-anon.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,19 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n+// Test that anonymous lifetimes are not permitted in struct declarations\n \n-struct invariant<'self> {\n-    f: @mut &'self int\n+struct Foo {\n+    x: &int //~ ERROR missing lifetime specifier\n }\n \n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n-}\n-\n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}\n+fn main() {}", "previous_filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-1.rs"}, {"sha": "1e74fa4adb9f6288229f4a0cb6d4e4c3abfe872f", "filename": "src/test/compile-fail/regions-in-structs.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct yes0<'self> {\n-  x: &uint, //~ ERROR Illegal anonymous lifetime: anonymous lifetimes are not permitted here\n-}\n-\n struct yes1<'self> {\n   x: &'self uint,\n }\n \n-struct yes2<'self> {\n-  x: &'foo uint, //~ ERROR Illegal lifetime 'foo: only 'self is allowed\n+struct yes2<'a> {\n+  x: &'a uint,\n }\n \n+struct StructDecl {\n+    a: &'a int, //~ ERROR use of undeclared lifetime name `'a`\n+    b: &'self int, //~ ERROR use of undeclared lifetime name `'self`\n+}\n+\n+\n fn main() {}"}, {"sha": "83e39ebd9f4d022ae3a016f5e67934fba7bbfb9c", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-immutability.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs?ref=dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct contravariant<'self> {\n-    f: &'self int\n-}\n-\n-fn to_same_lifetime<'r>(bi: contravariant<'r>) {\n-    let bj: contravariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: contravariant<'r>) {\n-    let bj: contravariant<'blk> = bi;\n-}\n-\n-fn to_longer_lifetime<'r>(bi: contravariant<'r>) -> contravariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "3fcc5184b4a7c8404df6c416ffc032249090ba4b", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-ret.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs?ref=dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Contravariant with respect to a region:\n-//\n-// You can upcast to a *smaller region* but not a larger one.  This is\n-// the normal case.\n-\n-struct contravariant<'self> {\n-    f: &'static fn() -> &'self int\n-}\n-\n-fn to_same_lifetime<'r>(bi: contravariant<'r>) {\n-    let bj: contravariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: contravariant<'r>) {\n-    let bj: contravariant<'blk> = bi;\n-}\n-\n-fn to_longer_lifetime<'r>(bi: contravariant<'r>) -> contravariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "4b26e6b60216372277337a5e10f8133b174a1339", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-arg.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs?ref=dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Covariant with respect to a region:\n-//\n-// You can upcast to a *larger region* but not a smaller one.\n-\n-struct covariant<'self> {\n-    f: &'static fn(x: &'self int) -> int\n-}\n-\n-fn to_same_lifetime<'r>(bi: covariant<'r>) {\n-    let bj: covariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: covariant<'r>) {\n-    let bj: covariant<'blk> = bi; //~ ERROR mismatched types\n-    //~^ ERROR cannot infer an appropriate lifetime\n-}\n-\n-fn to_longer_lifetime<'r>(bi: covariant<'r>) -> covariant<'static> {\n-    bi\n-}\n-\n-fn main() {\n-}"}, {"sha": "0d4d4056a44011fb29fc7ab173710a529705c3e5", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-arg-and-ret.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs?ref=dc5d9b908f776bd2a18a8b30f558b6c1cc3f779d", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Invariance with respect to a region:\n-//\n-// You cannot convert between regions.\n-\n-struct invariant<'self> {\n-    f: &'self fn(x: &'self int) -> &'self int\n-}\n-\n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'blk> = bi; //~ ERROR mismatched types\n-}\n-\n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "5c979955ec9ae4fdab6282a1232292170b27c91a", "filename": "src/test/compile-fail/regions-infer-region-in-fn-but-not-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -13,7 +13,7 @@\n // contains region pointers\n struct foo(~fn(x: &int));\n \n-fn take_foo(x: foo<'static>) {} //~ ERROR no region bound is allowed on `foo`\n+fn take_foo(x: foo<'static>) {} //~ ERROR wrong number of lifetime parameters\n \n fn main() {\n }"}, {"sha": "518fe0b00b6ce7c743de9f0ba701bb644bafe24e", "filename": "src/test/compile-fail/regions-name-duplicated.rs", "status": "renamed", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,19 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n-struct invariant<'self> {\n-    f: @mut [&'self int]\n-}\n-\n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n+struct Foo<'a, 'a> { //~ ERROR lifetime name `'a` declared twice\n+    x: &'a int\n }\n \n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}\n+fn main() {}", "previous_filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-2.rs"}, {"sha": "c1170654dd294c7b00e43bed3e0c6e8b04eb333d", "filename": "src/test/compile-fail/regions-name-static.rs", "status": "renamed", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,18 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(cond: bool) {\n-    let x = 5;\n-    let mut y: &'blk int = &x;\n-\n-    let mut z: &'blk int;\n-    if cond {\n-        z = &x; //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n-    } else {\n-        let w: &'blk int = &x;\n-        z = w;\n-    }\n+struct Foo<'static> { //~ ERROR illegal lifetime parameter name: `static`\n+    x: &'static int\n }\n \n-fn main() {\n-}\n+fn main() {}", "previous_filename": "src/test/compile-fail/regions-blk.rs"}, {"sha": "abff33e05149126f18c4da94dfc48d7234b26fa0", "filename": "src/test/compile-fail/regions-name-undeclared.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that lifetime resolver enforces the lifetime name scoping\n+// rules correctly in various scenarios.\n+\n+struct Foo<'a> {\n+    x: &'a int\n+}\n+\n+impl<'a> Foo<'a> {\n+    // &'a is inherited:\n+    fn m1(&self, arg: &'a int) { }\n+    fn m2(&'a self) { }\n+    fn m3(&self, arg: Foo<'a>) { }\n+\n+    // &'b is not:\n+    fn m4(&self, arg: &'b int) { } //~ ERROR undeclared lifetime\n+    fn m5(&'b self) { } //~ ERROR undeclared lifetime\n+    fn m6(&self, arg: Foo<'b>) { } //~ ERROR undeclared lifetime\n+}\n+\n+fn bar<'a>(x: &'a int) {\n+    // &'a is visible to code:\n+    let y: &'a int = x;\n+\n+    // &'a is not visible to *items*:\n+    type X = Option<&'a int>; //~ ERROR undeclared lifetime\n+    enum E {\n+        E1(&'a int) //~ ERROR undeclared lifetime\n+    }\n+    struct S {\n+        f: &'a int //~ ERROR undeclared lifetime\n+    }\n+    fn f(a: &'a int) { } //~ ERROR undeclared lifetime\n+\n+    // &'a CAN be declared on functions and used then:\n+    fn g<'a>(a: &'a int) { } // OK\n+    fn h(a: &fn<'a>(&'a int)) { } // OK\n+}\n+\n+// Test nesting of lifetimes in fn type declarations\n+fn fn_types(a: &'a int, //~ ERROR undeclared lifetime\n+            b: &fn<'a>(a: &'a int,\n+                       b: &'b int, //~ ERROR undeclared lifetime\n+                       c: &fn<'b>(a: &'a int,\n+                                  b: &'b int),\n+                       d: &'b int), //~ ERROR undeclared lifetime\n+            c: &'a int) //~ ERROR undeclared lifetime\n+{\n+}\n+\n+pub fn main() {}"}, {"sha": "ee6ed3b0d76f631f872a8993a91541f02a62d1af", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -12,7 +12,7 @@\n // some point regions-ret-borrowed reported an error but this file did\n // not, due to special hardcoding around the anonymous region.\n \n-fn with<'a, R>(f: &fn(x: &'a int) -> R) -> R {\n+fn with<R>(f: &fn<'a>(x: &'a int) -> R) -> R {\n     f(&3)\n }\n "}, {"sha": "fcf3a73b19f0d008008e73fc82aa8514995b20b9", "filename": "src/test/compile-fail/regions-undeclared.rs", "status": "renamed", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-undeclared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-undeclared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-undeclared.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -8,23 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n+static c_x: &'blk int = &22; //~ ERROR use of undeclared lifetime name `'blk`\n \n-struct invariant<'self> {\n-    f: @mut &'self int\n+enum EnumDecl {\n+    Foo(&'a int), //~ ERROR use of undeclared lifetime name `'a`\n+    Bar(&'self int), //~ ERROR use of undeclared lifetime name `'self`\n }\n \n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'blk> = bi; //~ ERROR mismatched types\n-}\n-\n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n+fn fnDecl(x: &'a int, //~ ERROR use of undeclared lifetime name `'a`\n+          y: &'self int) //~ ERROR use of undeclared lifetime name `'self`\n+{}\n \n fn main() {\n }", "previous_filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability.rs"}, {"sha": "77a54fec7bf7c6204699aefceea5e85a0cb9616a", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant-in-second-position.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is covariant with respect to its region\n+// parameter yields an error when used in a contravariant way.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+// `S` is contravariant with respect to both parameters.\n+struct S<'a, 'b> {\n+    f: &'a int,\n+    g: &'b int,\n+}\n+\n+fn use_<'short,'long>(c: S<'long, 'short>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+\n+    let _: S<'long, 'short> = c; // OK\n+    let _: S<'short, 'short> = c; // OK\n+\n+    // Test whether S<_,'short> <: S<_,'long>.  Since\n+    // 'short <= 'long, this would be true if the Contravariant type were\n+    // covariant with respect to its parameter 'a.\n+\n+    let _: S<'long, 'long> = c; //~ ERROR mismatched types\n+    //~^ ERROR  cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "3f0161d9deb2b9c46f8111fdf1dec7c86c1515fa", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is covariant with respect to its region\n+// parameter yields an error when used in a contravariant way.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+// This is contravariant with respect to 'a, meaning that\n+// Contravariant<'foo> <: Contravariant<'static> because\n+// 'foo <= 'static\n+struct Contravariant<'a> {\n+    f: &'a int\n+}\n+\n+fn use_<'short,'long>(c: Contravariant<'short>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+\n+    // Test whether Contravariant<'short> <: Contravariant<'long>.  Since\n+    // 'short <= 'long, this would be true if the Contravariant type were\n+    // covariant with respect to its parameter 'a.\n+\n+    let _: Contravariant<'long> = c; //~ ERROR mismatched types\n+    //~^ ERROR  cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "5cc3f1bdc3780e7066c372bfeb9615ba5efcd891", "filename": "src/test/compile-fail/regions-variance-covariant-use-contravariant.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is covariant with respect to its region\n+// parameter yields an error when used in a contravariant way.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+// This is covariant with respect to 'a, meaning that\n+// Covariant<'foo> <: Covariant<'static> because\n+// 'foo <= 'static\n+struct Covariant<'a> {\n+    f: extern \"Rust\" fn(&'a int)\n+}\n+\n+fn use_<'short,'long>(c: Covariant<'long>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+\n+    // Test whether Covariant<'long> <: Covariant<'short>.  Since\n+    // 'short <= 'long, this would be true if the Covariant type were\n+    // contravariant with respect to its parameter 'a.\n+\n+    let _: Covariant<'short> = c; //~ ERROR mismatched types\n+    //~^ ERROR  cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "0790c3f956a114b7a356d7fa5351ff0bf0680fa6", "filename": "src/test/compile-fail/regions-variance-invariant-use-contravariant.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that an invariant region parameter used in a contravariant way\n+// yields an error.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+struct Invariant<'a> {\n+    f: &'static mut &'a int\n+}\n+\n+fn use_<'short,'long>(c: Invariant<'long>,\n+                      s: &'short int,\n+                      l: &'long int,\n+                      _where:Option<&'short &'long ()>) {\n+\n+    // Test whether Invariant<'long> <: Invariant<'short>.  Since\n+    // 'short <= 'long, this would be true if the Invariant type were\n+    // contravariant with respect to its parameter 'a.\n+\n+    let _: Invariant<'short> = c; //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "9cdd05f8ebe1853752b468644bd39d8c5d3e8212", "filename": "src/test/compile-fail/regions-variance-invariant-use-covariant.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is invariant with respect to its region\n+// parameter used in a covariant way yields an error.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+struct Invariant<'a> {\n+    f: &'static mut &'a int\n+}\n+\n+fn use_<'b>(c: Invariant<'b>) {\n+\n+    // For this assignment to be legal, Invariant<'b> <: Invariant<'static>.\n+    // Since 'b <= 'static, this would be true if Invariant were covariant\n+    // with respect to its parameter 'a.\n+\n+    let _: Invariant<'static> = c; //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "940c1b3a237b8bbd9d20065008e60831f2c4de93", "filename": "src/test/compile-fail/trait-impl-different-num-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Ftrait-impl-different-num-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Ftrait-impl-different-num-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-different-num-params.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -13,7 +13,7 @@ trait foo {\n }\n impl foo for int {\n     fn bar(&self) -> int {\n-        //~^ ERROR method `bar` has 0 parameters but the trait has 1\n+        //~^ ERROR method `bar` has 0 parameter(s) but the trait has 1\n         *self\n     }\n }"}, {"sha": "ae8444f015e7e256d642f09ea98fa14141d2882d", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly infer variance for region parameters in\n+// various self-contained types.\n+\n+// Regions that just appear in normal spots are contravariant:\n+\n+#[rustc_variance]\n+struct Test2<'a, 'b, 'c> { //~ ERROR region_params=[-, -, -]\n+    x: &'a int,\n+    y: &'b [int],\n+    c: &'c str\n+}\n+\n+// Those same annotations in function arguments become covariant:\n+\n+#[rustc_variance]\n+struct Test3<'a, 'b, 'c> { //~ ERROR region_params=[+, +, +]\n+    x: extern \"Rust\" fn(&'a int),\n+    y: extern \"Rust\" fn(&'b [int]),\n+    c: extern \"Rust\" fn(&'c str),\n+}\n+\n+// Mutability induces invariance:\n+\n+#[rustc_variance]\n+struct Test4<'a, 'b> { //~ ERROR region_params=[-, o]\n+    x: &'a mut &'b int,\n+}\n+\n+// Mutability induces invariance, even when in a\n+// contravariant context:\n+\n+#[rustc_variance]\n+struct Test5<'a, 'b> { //~ ERROR region_params=[+, o]\n+    x: extern \"Rust\" fn(&'a mut &'b int),\n+}\n+\n+// Invariance is a trap from which NO ONE CAN ESCAPE.\n+// In other words, even though the `&'b int` occurs in\n+// a argument list (which is contravariant), that\n+// argument list occurs in an invariant context.\n+\n+#[rustc_variance]\n+struct Test6<'a, 'b> { //~ ERROR region_params=[-, o]\n+    x: &'a mut extern \"Rust\" fn(&'b int),\n+}\n+\n+// No uses at all is bivariant:\n+\n+#[rustc_variance]\n+struct Test7<'a> { //~ ERROR region_params=[*]\n+    x: int\n+}\n+\n+// Try enums too.\n+\n+#[rustc_variance]\n+enum Test8<'a, 'b, 'c> { //~ ERROR region_params=[+, -, o]\n+    Test8A(extern \"Rust\" fn(&'a int)),\n+    Test8B(&'b [int]),\n+    Test8C(&'b mut &'c str),\n+}\n+\n+fn main() {}"}, {"sha": "fa22bb41aa321fe13191f3b70bfb9e1ed2ab67c4", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly infer variance for region parameters in\n+// case that involve multiple intracrate types.\n+// Try enums too.\n+\n+#[rustc_variance]\n+enum Base<'a, 'b, 'c, 'd> { //~ ERROR region_params=[+, -, o, *]\n+    Test8A(extern \"Rust\" fn(&'a int)),\n+    Test8B(&'b [int]),\n+    Test8C(&'b mut &'c str),\n+}\n+\n+#[rustc_variance]\n+struct Derived1<'w, 'x, 'y, 'z> { //~ ERROR region_params=[*, o, -, +]\n+    f: Base<'z, 'y, 'x, 'w>\n+}\n+\n+#[rustc_variance] // Combine - and + to yield o\n+struct Derived2<'a, 'b, 'c> { //~ ERROR region_params=[o, o, *]\n+    f: Base<'a, 'a, 'b, 'c>\n+}\n+\n+#[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n+struct Derived3<'a, 'b, 'c> { //~ ERROR region_params=[o, -, *]\n+    f: Base<'a, 'b, 'a, 'c>\n+}\n+\n+#[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n+struct Derived4<'a, 'b, 'c> { //~ ERROR region_params=[+, -, o]\n+    f: Base<'a, 'b, 'c, 'a>\n+}\n+\n+fn main() {}"}, {"sha": "d8076f543ecc1436e9145357dd96ace3dafb29c4", "filename": "src/test/run-pass/regions-dependent-addr-of.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "previous_filename": "src/test/run-pass/region-dependent-addr-of.rs"}, {"sha": "bce2159cc7b9ffa314b78f28d72b517112926428", "filename": "src/test/run-pass/regions-dependent-autofn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-dependent-autofn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-dependent-autofn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-autofn.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "previous_filename": "src/test/run-pass/region-dependent-autofn.rs"}, {"sha": "dab881549c44cfda196696df0ad3b16697c81696", "filename": "src/test/run-pass/regions-dependent-autoslice.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-autoslice.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "previous_filename": "src/test/run-pass/region-dependent-autoslice.rs"}, {"sha": "50a71278c0656cf0b16ed78deba4a14ffbd8f32b", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast `use` standards don't resolve\n+\n+// Test a sample usage pattern for regions. Makes use of the\n+// following features:\n+//\n+// - Multiple lifetime parameters\n+// - Arenas\n+\n+extern mod extra;\n+\n+use extra::arena;\n+use extra::arena::Arena;\n+use std::hashmap::HashMap;\n+use std::cast;\n+use std::libc;\n+use std::mem;\n+\n+type Type<'tcx> = &'tcx TypeStructure<'tcx>;\n+\n+#[deriving(Eq)]\n+enum TypeStructure<'tcx> {\n+    TypeInt,\n+    TypeFunction(Type<'tcx>, Type<'tcx>),\n+}\n+\n+struct TypeContext<'tcx, 'ast> {\n+    ty_arena: &'tcx Arena,\n+    types: ~[Type<'tcx>],\n+    type_table: HashMap<NodeId, Type<'tcx>>,\n+\n+    ast_arena: &'ast Arena,\n+    ast_counter: uint,\n+}\n+\n+impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n+    fn new(ty_arena: &'tcx Arena, ast_arena: &'ast Arena)\n+           -> TypeContext<'tcx, 'ast> {\n+        TypeContext { ty_arena: ty_arena,\n+                      types: ~[],\n+                      type_table: HashMap::new(),\n+\n+                      ast_arena: ast_arena,\n+                      ast_counter: 0 }\n+    }\n+\n+    fn add_type(&mut self, s: TypeStructure<'tcx>) -> Type<'tcx> {\n+        for &ty in self.types.iter() {\n+            if *ty == s {\n+                return ty;\n+            }\n+        }\n+\n+        let ty = self.ty_arena.alloc(|| s);\n+        self.types.push(ty);\n+        ty\n+    }\n+\n+    fn set_type(&mut self, id: NodeId, ty: Type<'tcx>) -> Type<'tcx> {\n+        self.type_table.insert(id, ty);\n+        ty\n+    }\n+\n+    fn ast(&mut self, a: AstKind<'ast>) -> Ast<'ast> {\n+        let id = self.ast_counter;\n+        self.ast_counter += 1;\n+        self.ast_arena.alloc(|| AstStructure { id: NodeId {id:id}, kind: a })\n+    }\n+}\n+\n+#[deriving(Eq, IterBytes)]\n+struct NodeId {\n+    id: uint\n+}\n+\n+type Ast<'ast> = &'ast AstStructure<'ast>;\n+\n+struct AstStructure<'ast> {\n+    id: NodeId,\n+    kind: AstKind<'ast>\n+}\n+\n+enum AstKind<'ast> {\n+    ExprInt,\n+    ExprVar(uint),\n+    ExprLambda(Ast<'ast>),\n+}\n+\n+fn compute_types<'tcx,'ast>(tcx: &mut TypeContext<'tcx,'ast>,\n+                            ast: Ast<'ast>) -> Type<'tcx>\n+{\n+    match ast.kind {\n+        ExprInt | ExprVar(_) => {\n+            let ty = tcx.add_type(TypeInt);\n+            tcx.set_type(ast.id, ty)\n+        }\n+        ExprLambda(ast) => {\n+            let arg_ty = tcx.add_type(TypeInt);\n+            let body_ty = compute_types(tcx, ast);\n+            let lambda_ty = tcx.add_type(TypeFunction(arg_ty, body_ty));\n+            tcx.set_type(ast.id, lambda_ty)\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    let ty_arena = arena::Arena::new();\n+    let ast_arena = arena::Arena::new();\n+    let mut tcx = TypeContext::new(&ty_arena, &ast_arena);\n+    let ast = tcx.ast(ExprInt);\n+    let ty = compute_types(&mut tcx, ast);\n+    assert_eq!(*ty, TypeInt);\n+}"}, {"sha": "6740230728c6c9692fc7007603cca8fdcc0fb5b9", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -30,7 +30,7 @@ struct Ccx {\n #[fixed_stack_segment] #[inline(never)]\n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n-        cast::transmute(libc::malloc(mem::size_of::<Bcx<'blk>>()\n+        cast::transmute(libc::malloc(mem::size_of::<Bcx<'a>>()\n             as libc::size_t))\n     }\n }"}, {"sha": "aa4630717db6c63feb058acd7f350d25028abe77", "filename": "src/test/run-pass/regions-return-interior-of-option.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-return-interior-of-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-return-interior-of-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-return-interior-of-option.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "previous_filename": "src/test/run-pass/region-return-interior-of-option.rs"}, {"sha": "ffc2f07a1530e0b118dd08a9e050108d187c3b28", "filename": "src/test/run-pass/regions-variance-contravariant-use-contravariant.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-variance-contravariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-variance-contravariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-variance-contravariant-use-contravariant.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is contravariant with respect to its region\n+// parameter compiles successfully when used in a contravariant way.\n+//\n+// Note: see compile-fail/variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+struct Contravariant<'a> {\n+    f: &'a int\n+}\n+\n+fn use_<'a>(c: Contravariant<'a>) {\n+    let x = 3;\n+\n+    // 'b winds up being inferred to this call.\n+    // Contravariant<'a> <: Contravariant<'call> is true\n+    // if 'call <= 'a, which is true, so no error.\n+    collapse(&x, c);\n+\n+    fn collapse<'b>(x: &'b int, c: Contravariant<'b>) { }\n+}\n+\n+pub fn main() {}"}, {"sha": "7e0ca41501833a1ae8746d8d28d6421c7247df90", "filename": "src/test/run-pass/regions-variance-covariant-use-covariant.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-variance-covariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8379890c05b20e97fcc73c1865b8b3787caecc9f/src%2Ftest%2Frun-pass%2Fregions-variance-covariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-variance-covariant-use-covariant.rs?ref=8379890c05b20e97fcc73c1865b8b3787caecc9f", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is covariant with respect to its region\n+// parameter is successful when used in a covariant way.\n+//\n+// Note: see compile-fail/variance-regions-*.rs for the tests that\n+// check that the variance inference works in the first place.\n+\n+// This is covariant with respect to 'a, meaning that\n+// Covariant<'foo> <: Covariant<'static> because\n+// 'foo <= 'static\n+struct Covariant<'a> {\n+    f: extern \"Rust\" fn(&'a int)\n+}\n+\n+fn use_<'a>(c: Covariant<'a>) {\n+    // OK Because Covariant<'a> <: Covariant<'static> iff 'a <= 'static\n+    let _: Covariant<'static> = c;\n+}\n+\n+pub fn main() {}"}]}